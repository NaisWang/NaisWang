# 计算机编程语言的分类
## 计算机编程语言的分类
- 机器语言（二进制代码）
- 汇编语言（面向机器的程序设计语言）
- 高级语言
	- 按转换方式可分为两类：1.编译型语言;  2.解释型语言
	- 按照客观系统的描述可分为两类：1.面向过程语言;  2.面向对象语言    
	- 按照编程范型可分为：1.命令式语言;  2.函数式语言;  3.逻辑式语言;  4.面向对象语言

## 三种语言的优缺点：
### 机器语言：
可读性、可移植性差，编程繁杂。
直接执行，速度快，资源占用少；
### 汇编语言：
不同的处理器有不同的汇编语言语法和编译器，编译的程序无法在不同的处理器上执行，缺乏可移植性，难于从汇编语言代码上理解程序设计意图，可维护性差，即使是完成简单的工作也需要大量的汇编语言代码，很容易产生bug，难于调试，使用汇编语言必须对某种处理器非常了解，而且只能针对特定的体系结构和处理器进行优化，开发效率很低，周期长且单调。
能够保持机器语言的一致性，直接、简捷，并能像机器指令一样访问、控制计算机的各种硬件设备，如磁盘、存储器、CPU、I/O端口等。使用汇编语言，可以访问所有能够被访问的软、硬件资源，目标代码简短，占用内存少，执行速度快。
### 高级语言：
运行速度基本上比直接用汇编写的慢，速度和程序大小与编译软件有关。
高级语言接近算法语言，易学、易掌握，级语言为程序员提供了结构化程序设计的环境和工具，使得设计出来的程序可读性好，可维护性强，可靠性高；高级语言远离机器语言，与具体的计算机硬件关系不大，可移植性好，重用率高；由于把繁杂琐碎的事务交给了编译程序去做，所以自动化程度高，开发周期短，且程序员得到解脱，可以集中时间和精力去从事对于他们来说更为重要的创造性劳动，以提高程序的质量。

## 高级语言的分类：
### 按转换方式可分为两类：1.编译型语言;  2.解释型语言
1.编译型语言：
编译性语言写的程序在被执行之前，需要一个专门的编译过程，把程序编译成为机器语言的文件，比如exe文件，以后要运行的话就不用重新翻译了，直接使用编译的结果就行了（exe文件），因为翻译只做了一次，运行时不需要翻译，所以编译型语言的程序执行效率高。
2.解释型语言： 
解释性语言的程序不需要编译，在运行程序的时候才翻译，每个语句都是执行的时候才翻译。这样解释性语言每执行一次就需要逐行翻译一次，效率比较低。
现代解释性语言通常把源程序编译成中间代码，然后用解释器把中间代码一条条翻译成目标机器代码，一条条执行。

关于脚本语言：
脚本语言是一种解释性的语言，脚本语言是为了缩短传统的编写-编译-链接-运行（edit-compile-link-run）过程而创建的计算机编程语言。脚本语言一般都 有相应的脚本引擎来解释执行。 他们一般需要解释器才能运行。一个脚本通常是解释运行而非编译。脚本语言通常都有简单、易学、易用的特性，目的就是希望能让程序员快速完成程序的编写工作。而宏语言则可视为脚本语言的分支，两者也有实质上的相同之处。脚本语言一般都是以文本形式存在,类似于一种命令。

举例：
- 解释性语言：Java、JavaScript、Perl、Python、Ruby、MATLAB 等。
- 编译性语言： C/C++、Pascal/Object Pascal（Delphi)
- 脚本语言：Python、JavaScript，ASP，PHP，Perl等

### 按照客观系统的描述可分为两类：1.面向过程语言;  2.面向对象语言
1.面向过程语言：
面向过程语言是以过程或函数为基础的，这种语言对底层硬件，内存等操作比较方便，但是写代码和调试维护等会很麻烦。例如：c语言
2.面向对象语言：
面向对象语言（Object-Oriented Language）是一类以对象作为基本程序结构单位的程序设计语言，指用于描述的设计是以对象为核心，而对象是程序运行时刻的基本成分。语言中提供了类、继承等成分。
面向对象语言的发展有两个方向：一种是纯面向对象语言，如Smalltalk、EIFFEL等；另一种是混合型面向对象语言，即在过程式语言及其它语言中加入类、继承等成分，如C++、Objective-C等

### 按照编程范型可分为：1.命令式语言;  2.函数式语言;  3.逻辑式语言;  4.面向对象语言
1.命令式语言：
命令式程序设计语言是基于动作的语言，以冯诺依曼计算机体系结构为背景。机器语言及汇编语言是最早的命令式语言。在这种语言中，计算机被看做是动作的序列，程序就是用语言提供的操作命令书写的一个操作序列。用命令式程序设计语言编写程序，就是描述解题过程中每一步的过程，程序的运行过程就是问题的求解过程，因此也称为过程式语言。Fortran、ALGOL、COBOL、C、Ada、Pascal等都是命令式程序设计语言。
2.函数式语言：
函数式编程是种编程典范，它将电脑运算视为函数的计算。函数编程语言最重要的基础是 λ 演算（lambda calculus）。而且λ演算的函数可以接受函数当作输入（参数）和输出（返回值）。和指令式编程相比，函数式编程强调函数的计算比指令的执行重要。和过程化编程相比，函数式编程里，函数的计算可随时调用。这种语言的语义基础是基于数学函数概念的值映射的λ算子可计算模型。这种语言非常适合于进行人工智能等工作的计算。典型的函数式语言如 Lisp、Haskell、ML、Scheme 、F#等。
3.逻辑式语言：
这种语言的语义基础是基于一组已知规则的形式逻辑系统。这种语言主要用在专家系统的实现中。最著名的逻辑式语言是 Prolog。
4.面向对象语言：
现代语言中的大多数都提供面向对象的支持，但有些语言是直接建立在面向对象基本模型上的，语言的语法形式的语义就是基本对象操作。主要的纯面向对象语言是 Smalltalk。

# 向下兼容与向上兼容
向下兼容指的是高版本支持低版本的或者说后期开发的版本支持和兼容早期开发的版本，
向上兼容的很少，大多数软件都是向下兼容的。
向上向下和向前向后是一样的，向上和向下是相对的，
对于软件来说，向下兼容的意思是，较高版本的程序能顺利处理较低版本程序的数据，
硬件也是如此了，新的产品支持旧产品（向下兼容），
当然这时旧产品是得到新产品的支持，对旧产品来说，它是向上兼容的，
能不能兼容是新产品说的算。

# 软件版本号命名规范
## 总原则
- 标准的版本号必须采用XYZ的格式，并且X、Y 和 Z 为非负的整数，禁止在数字前方补零
- 版本是严格递增的，此处是：16.2.0 -> 16.3.0 -> 16.3.1
- 在发布重要版本时，可以发布alpha, rc等先行版本
- alpha和rc等修饰版本的关键字后面可以带上次数和meta信息
- 版本的优先层级指的是不同版本在排序时如何比较。判断优先层级时，必须把版本依序拆分为`主版本号`、`次版本号`、`修订号`及`先行版本号`后进行比较。

## 软件版本阶段说明
- Alpha版: 此版本表示该软件在此阶段主要是以实现软件功能为主，通常只在软件开发者内部交流，一般而言，该版本软件的Bug较多，需要继续修改。
- Beta版: 该版本相对于α版已有了很大的改进，消除了严重的错误，但还是存在着一些缺陷，需要经过多次测试来进一步消除，此版本主要的修改对像是软件的UI。
- RC版: 该版本已经相当成熟了，基本上不存在导致错误的BUG，与即将发行的正式版相差无几。
- Release版: 该版本意味“最终版本”，在前面版本的一系列测试版之后，终归会有一个正式版本，是最终交付用户使用的一个版本。该版本有时也称为标准版。一般情况下，Release不会以单词形式出现在软件封面上，取而代之的是符号®。

# 编辑器的撤销和重做如何实现
我一直好奇，编辑器的undo和redo是如何实现的，而且因为不了解uodo和redo工作原理到底是怎样的。常常会发现它并不能我所想的去工作。

这篇文章用一种模型解释undo和redo，我在编辑器上试过这种思路是没问题的，但我不能把握这种模型一定是对的，如果在以后的学习中发现还有问题，我会进一步修改。

清晰的思路
首先要明白，为什么有的时候我们点击redo是没用的，<font color="red">因为只有undo的才能redo，你在一个新操作上redo是没用的</font>。

而且，虽然看上去在操作过程中，我们是在保存每一次的状态，但是在底层实现中，程序员是不会蠢到把每一次的缓冲区都保存为状态，真实情况就是只保存变化。这还真算是编程里面的一个范式了。版本管理器的原理也是如此。

还有我们要明白，任何一个操作都是可以被反转义为一个逆操作。比如“在xxx位置插入”abc”字符”的逆操作就是“将xxx位置到len（”abc”）长度的字符删除”。

## 构建模型
undo和redo的模型类似于下图:

![](https://raw.githubusercontent.com/NaisWang/images/master/20220409163344.png)

我们的每一次操作，就被放到一个类似栈的容器中（说类似，是因为它的属性和栈并不完全相同）。我们把编辑器底层维护的这块字符内存成为缓冲区，而在栈中存放的都是类似的操作：
```
在缓冲区的xx位置插入"abc"。
将缓冲区xx到yy位置的字符串删除。
......
```

## 分析操作
对缓冲区进行新的操作（current指针在栈顶）。当进行一个新的操作时，会将这个操作压栈。并将一个current指针指向它。

### undo撤销
当我们撤销操作时，会将current指向的操作，做一个反转义，将生成的逆向操作在缓冲区中执行，并将current向栈底的移动一位。（注意，刚才的那个操作并没有出栈，只是移动current指针而已）

### redo重做
当我们重做操作时，会将current指针栈顶的方向移动一位，并将指向的操作在缓冲区中执行。对缓冲区进行新的操作(current指针不在栈顶)

那么如果我们在uodo几次后，直接对缓冲区直接进行操作呢？
这时将对current上方的所有操作出栈，将新的操作压栈，并将current指针指向它。
这也就是为什么，你在这时，redo操作是没用的。因为栈顶已经没东西了。


# 算术运算与逻辑运输
- 算术运算指令会考虑将操作数看做是一个有符号的数，在运算时要考虑正数和负数的这个性质。即符号位不
- 逻辑运算指令是将操作数视为一组二进制的01串，这就不存在正数或着负数这样的概念

程序代码中的`^, &, |, ~`都是逻辑运输, `<<, >>`是算术运算

# 取整问题
- 向上取整：比自己大的最小整数；
- 向下取整：比自己小的最大整数；
- 向0取整: 即如果是正数时：向下取整；如果是负数时：向上取整

![](https://raw.githubusercontent.com/NaisWang/images/master/20211223110250.png)

## java/c/c++默认是向0取整
java:
```java
1  / 2  => 0
-1 / 2  => 0
```

c/c++:
```c
1  / 2  => 0
-1 / 2  => 0
```

## python3默认是向下取整
python3:
```python
1  /  2   => 0.5
1  // 2   => 0
-1 /  2   => -0.5
-1 //  2  => -1
```

## js中没有整除运算符
js:
```js
1   /  2   => 0.5
-1  /  2   => -0.5
```

# 负数取模怎么算
参考：
- https://www.jianshu.com/p/452c1a5acd31  
- https://segmentfault.com/a/1190000015581794

---

## 取模怎么算
取模运算实际上是计算两数相除以后的余数。假设 q 是 a、b 相除产生的商(quotient)，r 是相应的余数(remainder)，那么在几乎所有的计算系统中，都满足：`a = b x q + r`，其中 `|r|<|a|`。因此 r 有两个选择，一个为正，一个为负;相应的，q 也有两个选择。如果a、b 都是正数的话，那么一般的编程语言中，r 为正数；或者如果 a、b 都是负数的话，一般 r 为负数。但是如果 a、b 一正一负的话，不同的语言则会根据除法的不同结果而使得 r 的结果也不同，但是一般 r 的计算方法都会满足：`r = a - (a / b) x b`

## 计算机怎么算
计算机怎么算，并不是一个好回答的问题，因为不同语言里面，对于整数除法取整的处理方式并不一样。
- C/Java 的处理方式
  - 大多数语言的处理方式都与 C/Java 一致，采用了 truncate 除法。所以在 C/Java 语言中:
  - -17 % 10 的计算结果如下：r = (-17) - (-17 / 10) x 10 = (-17) - (-1 x 10) = -7
  - 17 % -10 的计算结果如下：r = 17 - (17 / -10) x (-10) = (17) - (-1 x -10) = 7
  - -17 % -10 的计算结果如下：r = (-17) - (-17 / -10) x (-10) = (-17) - (1 x -10) = -7

- Python 的处理方式
  - Python 语言除法采用的是 floor 除法，所以对 Python 程序员来讲：
  - -17 % 10 的计算结果如下：r = (-17) - (-17 / 10) x 10 = (-17) - (-2 x 10) = 3
  - 17 % -10 的计算结果如下：r = 17 - (17 / -10) x (-10) = (17) - (-2 x -10) = －3
  - -17 % -10 的计算结果如下：r = (-17) - (-17 / -10) x (-10) = (-17) - (1 x -10) = -7
  - 据说，Python 3.x 中「/」运算符的意义发生了变化，「/」产生的结果将不会再进行取整，相应的「//」运算符的结果才会进行取整。

- Common Lisp 的处理方式
  - Common Lisp 的特殊操作符「/」的结果是分数，因此不会存在截尾的问题。但是 Common Lisp 提供了 TRUNCATE 函数和 FLOOR 函数分别对应上述的两种除法。相应的，Common Lisp 的 REM 函数类似于 C/Java 语言中的取模运算；而 MOD 函数类似于 Python 语言中的取模运算。
  - 例如，在 Clojure 这门 Lisp 方言中，(rem -17 10) == -7，(mod -17 10) == 3


# 轻量应用服务器与ESC的区别
区别：
- 轻量应用服务器面向单机应用，云服务器ECS则未做任何限制。
- 轻量应用服务器的可扩展性差，云服务器ECS的可扩展性好。
- 轻量应用服务器基本不存在网络的扩展问题；云服务器ECS在专有网络VPC下，用户可以自定义专有网络。

## 轻量应用服务器
轻量应用服务器：面向单机应用场景的新一代计算服务，提供应用一键部署、一站式域名解析、网站发布、安全、运维、应用管理等服务。极大地优化了搭建简单应用的体验，降低了入门级用户使用云计算产品的门槛。

套餐资源包括：
- 由阿里云精选的常用应用镜像和系统镜像；
- 云服务器计算资源，包括基于 SSD 的存储资源、网络资源；
- 阿里云其他产品的基础功能（DNS，VPC 等）

简单理解，轻量应用服务器跟我们之前使用的虚拟主机类似，主要用于部署网站来使用，跟虚拟主机不同的是轻量应用服务器底层是云服务器，操作系统包含运行环境，上传程序即可使用。

## 云服务器
云服务器（Elastic Compute Service，简称ECS）：阿里云提供的性能卓越、稳定可靠、弹性扩展的IaaS（Infrastructure as a Service）级别云计算服务。

从定义中不难看出，轻量应用服务器和云服务器ECS主要有以下几个方面不同：
- 使用对象：轻量应用服务器面向单机应用，云服务器ECS则未做任何限制；
- 可扩展性：轻量应用服务器提供的配置仅有少量的几个可供选择，升配局限较大；云服务器ECS提供数十种类型上百种配置可供选择，并且支持升级，同时ECS支持搭配其他应用如RDS、OSS来使用；
- 网络：轻量应用服务器面向对象是单机，基本不存在网络的扩展问题；云服务器ECS在专有网络VPC下，用户可以自定义专有网络，并且可以通过网络与线下IDC或者其他云产品进行互联互通；

## 应用镜像和系统镜像
应用镜像和系统镜像是阿里云轻量应用服务器特有的：系统镜像是指纯净版的操作系统，应用镜像是在原操作系统基础上另外安装了WordPress、LAMP、Drupal、Node.js、ECShop、phpwind、ASP/.NET 4.0及BT-Panel等镜像。

如果应用镜像中有所需镜像，选择应用镜像更方便，不需要自行手动安装程序；如果喜欢自己搭建环境，可以选择系统镜像。

如果是云服务器一般推荐选择安装系统镜像，安装纯净的操作系统，这样的话操作系统是纯净的未安装过任何环境和程序的，这样的话，环境我们可以自己创建，自由度更好。

# VR, AR, MR
- VR:看到的都是假的，把意识带入虚拟场景。
- AR:看到的一部分真，一部分假，把虚拟信息带入现实世界。
- MR:全息与真实世界完美契合，可以实现互动。
<div class="container">
  <iframe width="560" height="315" src="https://www.youtube.com/embed/eCfqY9O2v8Y" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>

# 集群、分布式、微服务
## 集群
集群是指在几个服务器上部署相同的应用程序来分担客户端的请求。它是同一个系统部署在不同的服务器上，比如一个登陆系统部署在不同的服务器上。好比 多个人一起做同样的事。

集群主要的使用场景是为了分担请求的压力。

但是，当压力进一步增大的时候，可能在需要存储的部分，比如mysql无法面对大量的“写压力”。

因为在mysql做成集群之后，主要的写压力还是在master的机器上，其他slave机器无法分担写压力，这时，就引出了“分布式”。

## 分布式
分布式的核心就一个字：拆。只要是将一个项目拆分成了多个模块，并将这些模块分开部署，那就算是分布式。

如何拆呢？有两种方式：水平拆分，或垂直拆分（也称为“横向拆分”和“垂直拆分”），具体如下：

**水平拆分**：根据“分层”的思想进行拆分。例如，可以将一个项目根据“三层架构”拆分成 表示层（jsp+servlet）、业务逻辑层（service）和数据访问层（dao），然后再分开部署：把表示层部署在服务器A上，把service和dao层部署在服务器B上，然后服务器A和服务器B之间通过dubbo等RPC进行进行整合（在左下角的“阅读原文”里有dubbo的视频课程，可以点击学习），如图所示。

![](https://raw.githubusercontent.com/NaisWang/images/master/20220409122345.png)

**垂直拆分**：根据业务进行拆分。例如，可以根据业务逻辑，将“电商项目”拆分成“订单项目”、“用户项目”和“秒杀项目”。显然这三个拆分后的项目，仍然可以作为独立的项目使用。像这种拆分的方法，就成为垂直拆分。

![](https://raw.githubusercontent.com/NaisWang/images/master/20220409122356.png)

## 微服务
从名字就能知道，“微服务”就是非常微小的服务。

微服务可以理解为一种非常细粒度的垂直拆分。例如，以上“订单项目”本来就是垂直拆分后的子项目，但实际上“订单项目”还能进一步拆分为“购物项目”、“结算项目”和“售后项目”，如图。

![](https://raw.githubusercontent.com/NaisWang/images/master/20220409122406.png)

现在看图中的“订单项目”，它完全可以作为一个分布式项目的组成元素，但就不适合作为微服务的组成元素了（因为它还能再拆，而微服务应该是不能再拆的“微小”服务，类似于“原子性”）。

## 总结：
- 集群: 把处理同一个业务的系统部署多个节点
- 分布式：拆了就行。
- 微服务：细粒度的垂直拆分。

# 横向扩展、纵向扩展
为了搞懂什么是横向扩展与纵向扩展，我们可以先搞懂什么是`横向发展`与`纵向发展`

- 横向发展: 就是拓宽工作范围,各项工作齐头并进；
- 纵向发展: 就是让某一工作逐渐深入,力求抓出成效.

由此可以引导出什么是横向扩展与纵向扩展

- 横向扩展：多增加几台API服务器，一起服务。
- 纵向扩展：把API服务器换成性能更好的机器。

- 横向扩展 也叫 水平扩展，用更多的节点支撑更大量的请求。 如成千上万的蚂蚁完成一项搬运工作
- 纵向扩展 又叫 垂直扩展，扩展一个点的能力支撑更大的请求。如利用1个人的能力，如蜘蛛侠逼停火车

# 时区和时间戳
## 时区和时间戳
什么是时间戳（timestamp）？它和时区（timezone）又有什么关系？初学者可能一开始很难搞懂时间戳这个概念，就像这期《程序员的日常》漫画中的主人公一样。

![](https://raw.githubusercontent.com/NaisWang/images/master/20220712184342.png)

从漫画中举的例子来看，这里的时间戳，指的就是Unix时间戳(Unix timestamp)。它也被称为Unix时间(Unix time)、POSIX时间(POSIX time)，是一种时间表示方式，定义为从格林威治时间1970年01月01日00时00分00秒起至现在的总秒数。因此，严格来说，不管你处在地球上的哪个地方，任意时间点的时间戳都是相同的。这点有利于线上和客户端分布式应用统一追踪时间信息。

Unix时间戳不仅被使用在Unix系统、类Unix系统中，也在许多其他操作系统中被广泛采用。但是，这并不意味着目前的时间戳规范会一直持续使用下去。因为到2038年1月19日时，Unix时间戳就会因为32位内存溢出（32-bit overflow）而无法继续使用。因此，在这一天之前，上千万的网络应用要么采用新的时间戳规范，要么迁移到64位系统，后者可以给时间戳争取“一点”时间。

## 格林威治时间（GMT）
GMT时间就是英国格林威治时间，也就是世界标准时间

## 协调世界时（UTC）
协调世界时（英语：Coordinated Universal Time简称UTC）是最主要的世界时间标准，其以原子时秒长为基础，在时刻上尽量接近于格林尼治标准时间。

协调世界时是世界上调节时钟和时间的主要时间标准，它与0度经线的平太阳时相差不超过1秒，并不遵守夏令时。协调世界时是最接近格林威治标准时间（GMT）的几个替代时间系统之一。对于大多数用途来说，UTC时间被认为能与GMT时间互换，但GMT时间已不再被科学界所确定。
