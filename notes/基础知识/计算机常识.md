# 计算机编程语言的分类
## 计算机编程语言的分类
- 机器语言（二进制代码）
- 汇编语言（面向机器的程序设计语言）
- 高级语言
	- 按转换方式可分为两类：1.编译型语言;  2.解释型语言
	- 按照客观系统的描述可分为两类：1.面向过程语言;  2.面向对象语言    
	- 按照编程范型可分为：1.命令式语言;  2.函数式语言;  3.逻辑式语言;  4.面向对象语言

## 三种语言的优缺点：
### 机器语言：
可读性、可移植性差，编程繁杂。
直接执行，速度快，资源占用少；
### 汇编语言：
不同的处理器有不同的汇编语言语法和编译器，编译的程序无法在不同的处理器上执行，缺乏可移植性，难于从汇编语言代码上理解程序设计意图，可维护性差，即使是完成简单的工作也需要大量的汇编语言代码，很容易产生bug，难于调试，使用汇编语言必须对某种处理器非常了解，而且只能针对特定的体系结构和处理器进行优化，开发效率很低，周期长且单调。
能够保持机器语言的一致性，直接、简捷，并能像机器指令一样访问、控制计算机的各种硬件设备，如磁盘、存储器、CPU、I/O端口等。使用汇编语言，可以访问所有能够被访问的软、硬件资源，目标代码简短，占用内存少，执行速度快。
### 高级语言：
运行速度基本上比直接用汇编写的慢，速度和程序大小与编译软件有关。
高级语言接近算法语言，易学、易掌握，级语言为程序员提供了结构化程序设计的环境和工具，使得设计出来的程序可读性好，可维护性强，可靠性高；高级语言远离机器语言，与具体的计算机硬件关系不大，可移植性好，重用率高；由于把繁杂琐碎的事务交给了编译程序去做，所以自动化程度高，开发周期短，且程序员得到解脱，可以集中时间和精力去从事对于他们来说更为重要的创造性劳动，以提高程序的质量。

## 高级语言的分类：
### 按转换方式可分为两类：1.编译型语言;  2.解释型语言
1.编译型语言：
编译性语言写的程序在被执行之前，需要一个专门的编译过程，把程序编译成为机器语言的文件，比如exe文件，以后要运行的话就不用重新翻译了，直接使用编译的结果就行了（exe文件），因为翻译只做了一次，运行时不需要翻译，所以编译型语言的程序执行效率高。
2.解释型语言： 
解释性语言的程序不需要编译，在运行程序的时候才翻译，每个语句都是执行的时候才翻译。这样解释性语言每执行一次就需要逐行翻译一次，效率比较低。
现代解释性语言通常把源程序编译成中间代码，然后用解释器把中间代码一条条翻译成目标机器代码，一条条执行。

关于脚本语言：
脚本语言是一种解释性的语言，脚本语言是为了缩短传统的编写-编译-链接-运行（edit-compile-link-run）过程而创建的计算机编程语言。脚本语言一般都 有相应的脚本引擎来解释执行。 他们一般需要解释器才能运行。一个脚本通常是解释运行而非编译。脚本语言通常都有简单、易学、易用的特性，目的就是希望能让程序员快速完成程序的编写工作。而宏语言则可视为脚本语言的分支，两者也有实质上的相同之处。脚本语言一般都是以文本形式存在,类似于一种命令。

举例：
- 解释性语言：Java、JavaScript、Perl、Python、Ruby、MATLAB 等。
- 编译性语言： C/C++、Pascal/Object Pascal（Delphi)
- 脚本语言：Python、JavaScript，ASP，PHP，Perl等

### 按照客观系统的描述可分为两类：1.面向过程语言;  2.面向对象语言
1.面向过程语言：
面向过程语言是以过程或函数为基础的，这种语言对底层硬件，内存等操作比较方便，但是写代码和调试维护等会很麻烦。例如：c语言
2.面向对象语言：
面向对象语言（Object-Oriented Language）是一类以对象作为基本程序结构单位的程序设计语言，指用于描述的设计是以对象为核心，而对象是程序运行时刻的基本成分。语言中提供了类、继承等成分。
面向对象语言的发展有两个方向：一种是纯面向对象语言，如Smalltalk、EIFFEL等；另一种是混合型面向对象语言，即在过程式语言及其它语言中加入类、继承等成分，如C++、Objective-C等

### 按照编程范型可分为：1.命令式语言;  2.函数式语言;  3.逻辑式语言;  4.面向对象语言
1.命令式语言：
命令式程序设计语言是基于动作的语言，以冯诺依曼计算机体系结构为背景。机器语言及汇编语言是最早的命令式语言。在这种语言中，计算机被看做是动作的序列，程序就是用语言提供的操作命令书写的一个操作序列。用命令式程序设计语言编写程序，就是描述解题过程中每一步的过程，程序的运行过程就是问题的求解过程，因此也称为过程式语言。Fortran、ALGOL、COBOL、C、Ada、Pascal等都是命令式程序设计语言。
2.函数式语言：
函数式编程是种编程典范，它将电脑运算视为函数的计算。函数编程语言最重要的基础是 λ 演算（lambda calculus）。而且λ演算的函数可以接受函数当作输入（参数）和输出（返回值）。和指令式编程相比，函数式编程强调函数的计算比指令的执行重要。和过程化编程相比，函数式编程里，函数的计算可随时调用。这种语言的语义基础是基于数学函数概念的值映射的λ算子可计算模型。这种语言非常适合于进行人工智能等工作的计算。典型的函数式语言如 Lisp、Haskell、ML、Scheme 、F#等。
3.逻辑式语言：
这种语言的语义基础是基于一组已知规则的形式逻辑系统。这种语言主要用在专家系统的实现中。最著名的逻辑式语言是 Prolog。
4.面向对象语言：
现代语言中的大多数都提供面向对象的支持，但有些语言是直接建立在面向对象基本模型上的，语言的语法形式的语义就是基本对象操作。主要的纯面向对象语言是 Smalltalk。

# 向下兼容与向上兼容
向下兼容指的是高版本支持低版本的或者说后期开发的版本支持和兼容早期开发的版本，
向上兼容的很少，大多数软件都是向下兼容的。
向上向下和向前向后是一样的，向上和向下是相对的，
对于软件来说，向下兼容的意思是，较高版本的程序能顺利处理较低版本程序的数据，
硬件也是如此了，新的产品支持旧产品（向下兼容），
当然这时旧产品是得到新产品的支持，对旧产品来说，它是向上兼容的，
能不能兼容是新产品说的算。

# 软件版本号命名规范
## 总原则
- 标准的版本号必须采用XYZ的格式，并且X、Y 和 Z 为非负的整数，禁止在数字前方补零
- 版本是严格递增的，此处是：16.2.0 -> 16.3.0 -> 16.3.1
- 在发布重要版本时，可以发布alpha, rc等先行版本
- alpha和rc等修饰版本的关键字后面可以带上次数和meta信息
- 版本的优先层级指的是不同版本在排序时如何比较。判断优先层级时，必须把版本依序拆分为`主版本号`、`次版本号`、`修订号`及`先行版本号`后进行比较。

## 软件版本阶段说明
- Alpha版: 此版本表示该软件在此阶段主要是以实现软件功能为主，通常只在软件开发者内部交流，一般而言，该版本软件的Bug较多，需要继续修改。
- Beta版: 该版本相对于α版已有了很大的改进，消除了严重的错误，但还是存在着一些缺陷，需要经过多次测试来进一步消除，此版本主要的修改对像是软件的UI。
- RC版: 该版本已经相当成熟了，基本上不存在导致错误的BUG，与即将发行的正式版相差无几。
- Release版: 该版本意味“最终版本”，在前面版本的一系列测试版之后，终归会有一个正式版本，是最终交付用户使用的一个版本。该版本有时也称为标准版。一般情况下，Release不会以单词形式出现在软件封面上，取而代之的是符号®。

# 编辑器的撤销和重做如何实现
我一直好奇，编辑器的undo和redo是如何实现的，而且因为不了解uodo和redo工作原理到底是怎样的。常常会发现它并不能我所想的去工作。

这篇文章用一种模型解释undo和redo，我在编辑器上试过这种思路是没问题的，但我不能把握这种模型一定是对的，如果在以后的学习中发现还有问题，我会进一步修改。

清晰的思路
首先要明白，为什么有的时候我们点击redo是没用的，<font color="red">因为只有undo的才能redo，你在一个新操作上redo是没用的</font>。

而且，虽然看上去在操作过程中，我们是在保存每一次的状态，但是在底层实现中，程序员是不会蠢到把每一次的缓冲区都保存为状态，真实情况就是只保存变化。这还真算是编程里面的一个范式了。版本管理器的原理也是如此。

还有我们要明白，任何一个操作都是可以被反转义为一个逆操作。比如“在xxx位置插入”abc”字符”的逆操作就是“将xxx位置到len（”abc”）长度的字符删除”。

## 构建模型
undo和redo的模型类似于下图:
![](https://gitee.com/NaisWang/images/raw/master/img/20211201103439.png)

我们的每一次操作，就被放到一个类似栈的容器中（说类似，是因为它的属性和栈并不完全相同）。我们把编辑器底层维护的这块字符内存成为缓冲区，而在栈中存放的都是类似的操作：
```
在缓冲区的xx位置插入"abc"。
将缓冲区xx到yy位置的字符串删除。
......
```

## 分析操作
对缓冲区进行新的操作（current指针在栈顶）。当进行一个新的操作时，会将这个操作压栈。并将一个current指针指向它。

### undo撤销
当我们撤销操作时，会将current指向的操作，做一个反转义，将生成的逆向操作在缓冲区中执行，并将current向栈底的移动一位。（注意，刚才的那个操作并没有出栈，只是移动current指针而已）

### redo重做
当我们重做操作时，会将current指针栈顶的方向移动一位，并将指向的操作在缓冲区中执行。对缓冲区进行新的操作(current指针不在栈顶)

那么如果我们在uodo几次后，直接对缓冲区直接进行操作呢？
这时将对current上方的所有操作出栈，将新的操作压栈，并将current指针指向它。
这也就是为什么，你在这时，redo操作是没用的。因为栈顶已经没东西了。


# 算术运算与逻辑运输
- 算术运算指令会考虑将操作数看做是一个有符号的数，在运算时要考虑正数和负数的这个性质。即符号位不
- 逻辑运算指令是将操作数视为一组二进制的01串，这就不存在正数或着负数这样的概念

程序代码中的`^, &, |, ~`都是逻辑运输, `<<, >>`是算术运算

# 取整问题
- 向上取整：比自己大的最小整数；
- 向下取整：比自己小的最大整数；
- 向0取整: 即如果是正数时：向下取整；如果是负数时：向上取整

![](https://raw.githubusercontent.com/NaisWang/images/master/20211223110250.png)

## java/c/c++默认是向0取整
java:
```java
1  / 2  => 0
-1 / 2  => 0
```

c/c++:
```c
1  / 2  => 0
-1 / 2  => 0
```

## python3默认是向下取整
python3:
```python
1  /  2   => 0.5
1  // 2   => 0
-1 /  2   => -0.5
-1 //  2  => -1
```

## js中没有整除运算符
js:
```js
1   /  2   => 0.5
-1  /  2   => -0.5
```

# 轻量应用服务器与ESC的区别
区别：
- 轻量应用服务器面向单机应用，云服务器ECS则未做任何限制。
- 轻量应用服务器的可扩展性差，云服务器ECS的可扩展性好。
- 轻量应用服务器基本不存在网络的扩展问题；云服务器ECS在专有网络VPC下，用户可以自定义专有网络。

## 轻量应用服务器
轻量应用服务器：面向单机应用场景的新一代计算服务，提供应用一键部署、一站式域名解析、网站发布、安全、运维、应用管理等服务。极大地优化了搭建简单应用的体验，降低了入门级用户使用云计算产品的门槛。

套餐资源包括：
- 由阿里云精选的常用应用镜像和系统镜像；
- 云服务器计算资源，包括基于 SSD 的存储资源、网络资源；
- 阿里云其他产品的基础功能（DNS，VPC 等）

简单理解，轻量应用服务器跟我们之前使用的虚拟主机类似，主要用于部署网站来使用，跟虚拟主机不同的是轻量应用服务器底层是云服务器，操作系统包含运行环境，上传程序即可使用。

## 云服务器
云服务器（Elastic Compute Service，简称ECS）：阿里云提供的性能卓越、稳定可靠、弹性扩展的IaaS（Infrastructure as a Service）级别云计算服务。

从定义中不难看出，轻量应用服务器和云服务器ECS主要有以下几个方面不同：
- 使用对象：轻量应用服务器面向单机应用，云服务器ECS则未做任何限制；
- 可扩展性：轻量应用服务器提供的配置仅有少量的几个可供选择，升配局限较大；云服务器ECS提供数十种类型上百种配置可供选择，并且支持升级，同时ECS支持搭配其他应用如RDS、OSS来使用；
- 网络：轻量应用服务器面向对象是单机，基本不存在网络的扩展问题；云服务器ECS在专有网络VPC下，用户可以自定义专有网络，并且可以通过网络与线下IDC或者其他云产品进行互联互通；

## 应用镜像和系统镜像
应用镜像和系统镜像是阿里云轻量应用服务器特有的：系统镜像是指纯净版的操作系统，应用镜像是在原操作系统基础上另外安装了WordPress、LAMP、Drupal、Node.js、ECShop、phpwind、ASP/.NET 4.0及BT-Panel等镜像。

如果应用镜像中有所需镜像，选择应用镜像更方便，不需要自行手动安装程序；如果喜欢自己搭建环境，可以选择系统镜像。

如果是云服务器一般推荐选择安装系统镜像，安装纯净的操作系统，这样的话操作系统是纯净的未安装过任何环境和程序的，这样的话，环境我们可以自己创建，自由度更好。