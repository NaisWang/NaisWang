# java基础
## String变量的两种创建方式
在java中，有两种创建String类型变量的方式：
```java
String str01="abc";//第一种方式
String str02=new String("abc")；//第二种方式
```
- 第一种方式创建String变量时，首先查找JVM方法区的字符串常量池是否存在存放"abc"的地址，如果存在，则将该变量指向这个地址，不存在，则在方法区创建一个存放字面值"abc"的地址。
- 第二种方式创建String变量时，在堆中创建一个存放"abc"的对象，使变量str02指向堆中的对象。


根据上面的创建方式，观察下面的示例：
```java
String str01 = "abc";
String str02 = "abc";
String str03 = new String("abc");
String str04 = new String("abc");
System.out.println("str01==str02:" + (str01 == str02));
System.out.println("str03==str04:" + (str03 == str04));
System.out.println("str01==str03:" + (str01 == str03));
```

分析：
1. 在创建str01时，方法区的字符串常量池中没有存储"abc"的地址，就在常量池中创建一个存放"abc"的地址，使变量str01指向该地址。创建str02时，字符串常量池已存在存放"abc"的地址，将str02变量指向该地址，此时str01与str02指向同一内存地址，所以"str01==str02"为true。
2. 使用new关键字创建对象时，每一次都会在堆中创建一个新的对象，所以str03与str04指向对象的地址不同，"str03==str04"为false。
3. str01指向方法区，str03指向堆，所以"str01==str03"为false。

![](https://raw.githubusercontent.com/NaisWang/images/master/20220929150846.png)

String对象被设计成不可改变的对象，即String对象所包含的字面值发生改变时，会开辟一个新的地址，创建一个新的对象，原地址不变。
```java
String str01 = "abc";
String str02 = "abc";
str01="def";
```

![](https://raw.githubusercontent.com/NaisWang/images/master/20220929151003.png)

在方法区的字符串常量池中建立一个新的存储"def"的地址，str01指向该地址，str02的指向不变。


## ==和equals

视频：https://www.bilibili.com/video/BV1bA411P7yr?p=1&vd_source=0dbec39578cccad08efd6fd6d0a696e2

- == : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象。(基本数 据类型 == 比较的是值，引用数据类型 == 比较的是内存地址)
- equals() : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况: 
  - 情况1:类没有覆盖 equals() 方法。则通过 equals() 比较该类的两个对象时，等价于通过
“==”比较这两个对象。
  - 情况2:类覆盖了 equals() 方法。一般，我们都覆盖 equals() 方法来两个对象的内容相等;
若它们的内容相等，则返回 true (即，认为这两个对象相等)。

举个例子:
```java
public class test1 {
  public static void main(String[] args) {
    String a = new String("ab"); // a 为一个引用 
    String b = new String("ab"); // b为另一个引用,对象的内容一样 
    String aa = "ab"; // 放在常量池中
    String bb = "ab"; // 从常量池中查找
    if (aa == bb) // true
      System.out.println("aa==bb"); 
    if (a == b) // false，非同一对象
      System.out.println("a==b");
    if (a.equals(b)) // true
      System.out.println("aEQb");
    if (42 == 42.0) { // true
      System.out.println("true");
    } 
  }
}
```
说明:
- String中的equals方法是被重写过的，因为object的equals方法是比较的对象的内存地址， 而String的equals方法比较的是对象的值。 
- 有关String的创建过程，可以参考**String变量的两种创建方式**章节

## ArrayList和LinkedList区别
### ArrayList
基于动态数组，连续内存存储，适合下标访问（随机访问）。

#### 扩容机制
因为数组长度固定，所以超出长度存储数据时需要新建数组，然后将老数组的数据拷贝到新数组中。如果不是尾部插入数据还会涉及到元素的移动。

#### ArrayList的数据插入一定比LinkedList低效吗
答案是不一定，我们通常认为ArrayList的数据插入一定比LinkedList低效的原因是因为ArrayList插入数据时，可能会涉及到元素的移动所产生的消耗。如果我们使用尾插法并指定初始容量，则插入数据不会涉及到元素的移动，可以极大提高性能，甚至会超过LinkedList

### LinkedList
基于链表，可以存储在分散的内存中，适合做数据插入以及删除操作，不适合查询操作

#### 为什么LinkedList不建议使用for循环遍历，而使用iterator方式进行遍历

如果使用for循环方式遍历链表，由于链表中元素是通过指针连接彼此的，不存在索引的概念，如果使用for循环方式遍历LinkedList，依次传入索引值，则就相当于每次都要将链表撸一遍。

如：在下面的这个遍历操作中，我们采用for的方式
```java
public static void main(String[] args)
{
    List<Integer> linkedList = new LinkedList<Integer>();
    
    for (int i = 0; i < 100; i++)
    {
        linkedList.add(i);
    }
    for (int i = 0; i < 100; i++)
    {
        System.out.println(linkedList.get(i));
    }
} 
```
实际上底层所执行的操作是，拿到这个值：
```java
     public E get(int index) {
        checkElementIndex(index);
        return node(index).item;
     }
     /**
     * Returns the (non-null) Node at the specified element index.
     */
    Node<E> node(int index) {
        // assert isElementIndex(index);
         
        if (index < (size >> 1)) {
            Node<E> x = first;
            //遍历链表，找到下标所对应的节点
            for (int i = 0; i < index; i++)
                x = x.next;
            return x;
        } else {
            Node<E> x = last;
            for (int i = size - 1; i > index; i--)
                x = x.prev;
            return x;
        }
    }
```
可以发现，如果使用for循环方式遍历LinkedList，问题的焦点是每次get()方法接收一个值，都会对链表遍历找到这个数值在链表中所对应的节点，肯定效率不高，而如果是ArrayList，由于它底层使用的对象数组实现，对象数组能够支持随机访问，所以效率比较高。

那为什么使用iterator方式来遍历LinkedList效率比较高呢？这是因为iterator的next()，是顺着链表节点顺序读取数据，所以效率就很高了。

究其根本原因是数组支持随机访问，但是链表不支持随机访问。

> 扩展：for-Each方式的底层使用的是iterator方式遍历

#### 为什么不推荐indexOf返回元素索引
不要试图用indexOf返回元素索引,同样查看代码也可以看出LinkedList的indexOf函数也需要对链表进行遍历操作。

```java
   public int indexOf(Object o) {
        int index = 0;
        if (o == null) {
            for (Node<E> x = first; x != null; x = x.next) {
                if (x.item == null)
                    return index;
                index++;
            }
        } else {
            for (Node<E> x = first; x != null; x = x.next) {
                if (o.equals(x.item))
                    return index;
                index++;
            }
        }
        return -1;
    }
```
