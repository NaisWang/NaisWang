# UML：
## 用例图
用例图是描述用例、参与者以及它们之间关系的图。
用例图是从用户的角度来描述对信息系统的需求，分析产品的功能和行为。
用例图定义和描述了系统的外部可见行为，是分析、设计直至组装测试的重要依据。

用例图由如下几个概念组成：
- `参与者actor`：角色，系统的用户；
- `系统边界system scope`：确定系统的范围，边界是一个方框，用例在边界内，参与者在边界外；
- `用例use case`：系统提供的服务；
- `关联association`：参与者与用例间、用例与用例间的关系。

### 参与者
参与者是指在系统之外，但与系统直接交互的对象，即actor，也叫执行者、活动者。

参与者用人形符号表示，在人形符号下面标出参与者的角色名。参与者不止是人员，也有可能是信息系统、设备。
<img src="https://gitee.com/NaisWang/images/raw/master/img/20210521075434.png" width="700px"/>

### 用例
用例是用户期望系统具备的功能，每一个用例说明一个系统提供给它的使用者的一种服务或功能。

用例的目标是要定义系统的一个行为，但并不显示系统的内部结构。

用例名一般为动宾短语，符号是椭圆加用例名（Visio中用例名写在椭圆内）。

### 用例描述
用例图没有描述系统行为的细节，所以需要以书面文档的形式对用例进行描述。至少包括：
- `名称`：与用例图中的名称保持一致；
- `标识符`：用例的代码或编号；
- `基本操作流程`：描述各项工作都正常进行时用例的工作方式；
- `可选操作流程`：很少使用、异常情况、发出错误的情况。
<img src="https://gitee.com/NaisWang/images/raw/master/img/20210521075645.png" width="700px"/>

另外还能包括：用例概述、范围、参与者、前置条件、后置条件、子事件流、规则与约束等。


### 用例图中的各种关系
- 参与者与用例间的关联关系：参与者与用例之间的通信，也成为关联或通信关系。
<img src="https://gitee.com/NaisWang/images/raw/master/img/20210521075724.png" width="500px"/>

- 用例与用例之间的关系：包含关系（include）、扩展关系（extend）、泛化关系。

#### 包含关系
包含关系描述的是一个用例需要某种功能，而该功能被另外一个用例定义，那么在用例的执行过程中，就可以调用已经定义好的用例。表示符号：`<<include>>`
<img src="https://gitee.com/NaisWang/images/raw/master/img/20210521075820.png" width="500px"/>
<img src="https://gitee.com/NaisWang/images/raw/master/img/20210521075839.png" width="500px"/>

#### 扩展关系
用一个用例（可选）扩展另一个用例（基本例）的功能，将一些常规的动作放在一个基本用例中，将可选的或只在特定条件下才执行的动作放在它的扩展用例中。表示符号：`<<extend>>`。
<img src="https://gitee.com/NaisWang/images/raw/master/img/20210521075940.png" width="500px"/>

**包含关系与扩展关系的区别**
<img src="https://gitee.com/NaisWang/images/raw/master/img/20210521082343.png" width="700px"/>

A用例发生是B用例发生的充分必要条件
A用例发生是C用例发生的必要不充分条件

A用例发生一定会导致B用例发生，但C用例不一定会发生
B用例与C用例发生的前提条件是A用例发生

#### 泛化关系
子用例继承了父用例所有的结构、行为和关系，是父用例的一种特殊形式。
<img src="https://gitee.com/NaisWang/images/raw/master/img/20210521080016.png" width="500px"/>

## 状态图
状态图用来描述一个特定对象的所有可能状态以及由于各种事件的发生而引起的状态之间的转移

状态图的图符
- 状态：矩形，四角为圆弧
- 转移：箭头
- 起点：一个黑点
- 终点：一个圈加一个黑点
<img src="https://gitee.com/NaisWang/images/raw/master/img/20210521195115.png" width="700px"/>

## 类图
### 关联关系
关联关系是类属性的一种表示方式。如下：

![](https://raw.githubusercontent.com/NaisWang/images/master/20211225161903.png)

上面三种方式都表示Register类多属性含有Sale类

### 依赖关系
在类图中，使用依赖线描述对象之间的全局变量、参数变量、局部变量和静态方怯(对其他类的静态方法加以调用)的依赖。

例如:
```java
public class Sale {
  public void updatePriceFor(ProductDescription description){
    Money basePrice = description.getPrice();
  }
}
```
updatePriceFor方法接收ProductDescription对象作为参数，然后向其发送getPrice消息。由此可见， Sale对象对ProductDescription具有参数可见性，并且有发送消息的藕合，因此对ProductDescriptio有依赖。如果后者发生变化， Sale类将会受到影响。这种依赖可以在类图中表示:

![](https://raw.githubusercontent.com/NaisWang/images/master/20211225162355.png)


再看一个例子，以下的Java代码显示了Foo类中的doX方法：
```java
public class Foo {
  public void doX() {
    System.runFinalization();
  }
}
```
其中， doX方法调用了System类的静态方怯。因此， Foo对象对System类具有静态方法依赖。这种依赖可以在类图中表示:

![](https://raw.githubusercontent.com/NaisWang/images/master/20211225162612.png)

#### 侬赖标签
为表示依赖的类型，或者为代码生成工具提供帮助，可以给依赖线附加关键字或构造型。
![](https://raw.githubusercontent.com/NaisWang/images/master/20211225162712.png)

### 关系判断技巧
类图中泛化、实现关系好判断，主要是关联、组合、依赖不好判断。可以按装下列步骤来判断：
- 类A包含成员变量类B时，如果A与B实例不能分离，即同生同灭的话，则A与B为组合关系。反之为关联关系。
- 类A不包含成员变量类B，但调用了类B中的成员属性时，则A与B为依赖关系
![](https://raw.githubusercontent.com/NaisWang/images/master/20211225165329.png)

# 代理模式
代理模式的分类：
- 静态代理
- 动态代理

## 静态代理
代理模式角色示意图
<img src="https://gitee.com/NaisWang/images/raw/master/img/20210412211628.png" width="700px"/>
- 抽象角色：一般会使用接口或者抽象类来完成， 如上面的租房
- 真实角色：被代理的角色，如房东
- 代理角色：代理真实角色，如中介，即代理房东做一些事情
- 客户：访问代理角色的人，如租房的人

代码实现
**抽象角色**
```java
public interface Rent{
  public void rent();
}
```
**真实角色**
```java
public class Host implements Rent{
  public void rent(){
    System.out.println("房东要出租房子了");
  }
}
```
**代理角色**
```java
public class Proxy implements Rent{
  private Host host;

  public Proxy(){
  }
  public Proxy(Host host){
    this.host = host;
  }

  public void rent(){
    seeHouse();
    host.rent();
    fare();
  }

  public void seeHouse(){
    System.out.println("中介带你看房");
  }
  public void fare(){
    System.out.println("收中介费");
  }
}
```
**客户**
```java
public class Client{
  public static void main(String[] args){
    Host host = new Host();
    Proxy proxy = new Proxy(host);
    proxy.rent();
  }
}
```

## 动态代理
静态代理的缺点：
- 假如一个系统中由100个真实角色，则需要创建100个代理对象
- 如果一个真实角色中有很多方法需要增强，那么会发现代理对象的方法中有很多重复的代码
基于上述问题，就可以很好地用动态代理解决

动态代理的角色示意图与静态代理的一样，区别只在于动态代理的代理对象是动态生成的，而不是直接写好的
动态代理分为两大类：
- 基于接口的动态代理，常用JDK动态代理
- 基于类的动态代理，常用cglib动态代理

### JDK动态代理
需要了解：Proxy类与InvocationHandler接口
**Proxy类**：提供了创建动态代理类和实例的静态方法，它也是由这些方法创建的所有动态代理类的超类

# 观察者模式
观察者模式角色示意图
<img src="https://gitee.com/NaisWang/images/raw/master/img/20210405110446.png" width="700px"/>
现在需求时，网易与腾讯都在观察着气象站发生的变化，气象站一发生变化就会通知到网易与腾讯

**气象站**
```java
class WeatherStation{
  private List<WeatherObserver> observers = new ArrayList<WeatherObserver>();
  private int weatherState;

  public int getWeatherState(){return weatherState;}

  public void setWeatherState(int weatherState){
    this.weatherState = weatherState;
    notifyAllWeatherObservers();
  }

  public void addWeatherObserver(WeatherObserver ob){
    observers.add(ob);
  }

  public void notifyAllWeatherObservers(){
    for(WeatherObserver observer : observers){
      observer.update();
    }
  }
}
```
**抽象观察者**
```java
abstract class WeatherObserver{
  public WeatherStation weatherStation;
  public abstract void update();
}
```
**具体观察者(网易、腾讯)**
```java
class Wangyi extends WeatherObserver{
  public Wangyi(WeatherStation weatherStation){
    this.weatherStation = weatherStation;
    this.weatherStation.addWeatherObserver(this);
  }
  public void update(){
    System.out.println("网易观察到气象站发来的气象变化通知:" + weatherStation.getWeatherState());
  }
}

class Tencent extends WeatherObserver{
  public Tencent(WeatherStation weatherStation){
    this.weatherStation = weatherStation;
    this.weatherStation.addWeatherObserver(this);
  }
  public void update(){
    System.out.println("腾讯观察到气象站发来的气象变化通知:" + weatherStation.getWeatherState());
  }
}
```
**Client**
```java
public class Math{
  public static void main(String[] args){
    WeatherStation weatherStation = new WeatherStation();

    new Wangyi(weatherStation);
    new Tencent(weatherStation);

    System.out.println("First state change: 天气是15°");   
    weatherStation.setWeatherState(15);
    System.out.println("Second state change: 天气是20°");  
    weatherStation.setWeatherState(20);
  }
}
```
输出：
```
First state change: 天气是15°
网易观察到气象站发来的气象变化通知:15
腾讯观察到气象站发来的气象变化通知:15
Second state change: 天气是20°
网易观察到气象站发来的气象变化通知:20
腾讯观察到气象站发来的气象变化通知:20
```

## 发布订阅模式
观察者模式和发布订阅模式最大的区别就是发布订阅模式有个事件调度中心。
在观察者模式中，观察者与目标(气象站)是直接进行交互的。
在发布订阅模式中，订阅者(观察者)和发布者(气象站)是互不干扰的，是由调度中心来处理的

发布订阅模式角色示意图
<img src="https://gitee.com/NaisWang/images/raw/master/img/20210405112233.png" width="700px"/>

# 正确理解一对多的关系
A与B的关系为`1:n`, 则表示A中的一个实体与B中的多个实体对应，**而B中的一个实体只跟A中的一个实体对应。**

例如班级与学生就是`1:n`的关系，1个班级对应多个学生；1个学生对应1个班级
