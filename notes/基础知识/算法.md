![](https://raw.githubusercontent.com/NaisWang/images/master/20220604110723.png)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220604110827.png)

# 算法入门
## 算法的伪码编写
### 分支语句
```
if a = b then
  ...
else
  ...
end if
```

### 循环语句
```
while a != b do
  ...
end while


for i=1 to k do
  ...
end for
```

### 集合表示
```
a = {v}
b = a - {i};
c = a + {i};
```

### 方法
```
function a(s, x)
  ...
end fun
```

## 命名习惯
- `res`: 局部使用
- `ans`: 全局使用
- `r` : 行
- `c` : 列
- `nr` : 下一行
- `nc` : 下一列
- `cnt` : 计数

## 算法常用技巧
### 子序列、子数组、子串区别
- 子序列 是不要求连续的
- 子数组和子串一样，是需要连续的

### 循环n次
```java
while (n-- != 0) {
  ...
}
```

### 字符串常用技巧
#### 判断字符串中是否只有一种元素
没有什么比较快捷的方式来判断字符串中是否只有一种元素。常用的是下面2中方法。

字符串长度较少时：
```java
if (str[0] == str[1] && str[1] == str[2] && str[2] == str[3] ...) {
  ...
}
```

字符串长度较长时：
```java
for (int i = 0; i < str.length() - 1; i++) {
  if (str[i] != str[i + 1]) {
    // 不只有一个元素
  }
}
```

##### 例题1: 字符串中最大的3位相同数字
[字符串中最大的3位相同数字](https://leetcode.cn/problems/largest-3-same-digit-number-in-string/)

此处判断子字符串是否由唯一一个数字组成的方式可以使用`if(str[0] == str[1] && str[1] == str[2])`来判断

代码：
```java
class Solution {
  public String largestGoodInteger(String num) {
    String ans = "";
    for (int i = 0; i < num.length() - 2; i++) {
      String sub = num.substring(i, i + 3);
      char[] charArray = sub.toCharArray();
      if (charArray[0] == charArray[1] && charArray[1] == charArray[2]) {
        if (ans.equals("") || Integer.parseInt(ans) < Integer.parseInt(sub)) {
          ans = sub;
        }
      }
    }
    return ans;
  }
}
```

#### substring左闭右开
```java
String a = "ab";

// substring为左闭右开
System.out.println(a.substring(0, 1)); //输出a
System.out.println(a.substring(0, 2)); //输出ab
```

#### 获取所有子串
```java
// 假设str的长度的为n，则时间复杂度为O(n^2); 
for (int i = 0; i < str.length(); i++) {
  for (int j = i + 1; j <= str.length(); j++) {
    System.out.println(str.substring(i, j));
  }
}
```

#### 在字符串中间插入/删除字符串
```java
// 方式一
String str = "abcdefg";
str = str.substring(0, 2) + "123" + str.substring(2);
System.out.println(str); // 输出：ab123cdefg
str = str.substring(0, 2) + str.substring(5);
System.out.println(str); // 输出：abcdefg

// 方式二
StringBuffer str = new StringBuffer("abcdefg");
str.insert(2, "123"); 
System.out.println(str); // 输出：ab123cdefg
// 左闭右开
str.delete(2, 5); 
System.out.println(str); // 输出：abcdefg
```

**当插入删除操作次数大时，方式一比方式二耗时地多**。例图下面例图，使用方式一会超时，而使用方式二不会

![](https://raw.githubusercontent.com/NaisWang/images/master/20220605143453.png)

使用方式一的代码：
```java
class TextEditor {
  int cursorIndex = 0;
  String str;

  public TextEditor() {
    str = "";
  }

  public void addText(String text) {
    str = str.substring(0, cursorIndex) + text + str.substring(cursorIndex);
    cursorIndex += text.length();
  }

  public int deleteText(int k) {
    int temp = cursorIndex;
    cursorIndex = cursorIndex - k < 0 ? 0 : cursorIndex - k;
    str = str.substring(0, cursorIndex) + str.substring(temp);
    return Math.min(k, temp);
  }

  public String cursorLeft(int k) {
    cursorIndex -= k;
    if (cursorIndex < 0) {
      cursorIndex = 0;
    }
    int left = cursorIndex - 10 < 0 ? 0 : cursorIndex - 10;
    return str.substring(left, cursorIndex);
  }

  public String cursorRight(int k) {
    cursorIndex += k;
    if (cursorIndex > str.length()) {
      cursorIndex = str.length();
    }
    int left = cursorIndex - 10 < 0 ? 0 : cursorIndex - 10;
    return str.substring(left, cursorIndex);
  }
}
```
上升代码会超时，此时只更改在字符串中间插入/删除字符串的操作为使用StringBuffer时，不会超时，代码如下：

使用方式二：
```java
class TextEditor {
  int cursorIndex = 0;
  StringBuffer str;

  public TextEditor() {
    str = new StringBuffer();
  }

  public void addText(String text) {
    str.insert(cursorIndex, text);
    cursorIndex += text.length();
  }

  public int deleteText(int k) {
    int temp = cursorIndex;
    cursorIndex = cursorIndex - k < 0 ? 0 : cursorIndex - k;
    str.delete(cursorIndex, temp);
    return Math.min(k, temp);
  }

  public String cursorLeft(int k) {
    cursorIndex -= k;
    if (cursorIndex < 0) {
      cursorIndex = 0;
    }
    int left = cursorIndex - 10 < 0 ? 0 : cursorIndex - 10;
    return str.substring(left, cursorIndex);
  }

  public String cursorRight(int k) {
    cursorIndex += k;
    if (cursorIndex > str.length()) {
      cursorIndex = str.length();
    }
    int left = cursorIndex - 10 < 0 ? 0 : cursorIndex - 10;
    return str.substring(left, cursorIndex);
  }
}
```

### 多个数字数组判重
假设给你多个数字数组，让你判重。此时有多个方法可以实现，比较常见的是使用`Set<String>`类型。将数字数组转换成能唯一标识的字符串存入`Set<String>`中。

例如现在有`[2, 3]`, `[2, 12]`, `[2, 3]`, `[2, 1, 2]`, `[2]`数组。将这些数组转换能唯一标识的字符串的方式主要如下2种方式：

方式一：使用数组的`toString()`方法, 例如上述数组分别可以转换成`"[2, 3]"`, `"[2, 12]"`, `"[2, 3]"`, `"[2, 1, 2]"`, `"[2]"`

方式二：循环遍历每个元素，在元素后加逗号`,`，然后将其拼接。例如上述数组分别可以转换成`"2,3"`, `"2,12"`, `"2,3"`, `"2,1,2"`, `"2"`

#### 例题1: 含最多 K 个可整除元素的子数组
[含最多 K 个可整除元素的子数组](https://leetcode.cn/problems/k-divisible-elements-subarrays/)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220606223706.png)


##### 分析
分析1: 由于子数组是连续的，所以穷举所有子数组的时间复杂度为O(n^2)，其中n为原数组的长度。这题中的原数组的长度为`1 <= nums.length <= 200`，显然可以使用O(n^2)的时间复杂度来穷举所有子数组

分析2: 由于需要对数组进行去重，所以可以使用`Set<String>`

代码:
```java
public int countDistinct(int[] nums, int k, int p) {
  Set<String> set = new HashSet<>();
  for (int i = 0; i < nums.length; i++) {
    int cnt = 0;
    StringBuffer sb = new StringBuffer();
    for (int j = i; j < nums.length; j++) {
      sb.append(nums[j] + ",");
      if (nums[j] % p == 0) {
        cnt++;
      }
      if (cnt > k) {
        break;
      }
      if (!set.contains(sb)) {
        set.add(sb.toString());
      }
    }
  }
  return set.size();
}
```

### 区间常用技巧
#### 获取区间的mid
获取[left, right]区间的mid下标
```java
// 方式一
int mid = (left + right) / 2;

// 方式二: 可以防止数据溢出
int mid = left + (right - left) / 2;
```

![](https://raw.githubusercontent.com/NaisWang/images/master/20220605135921.png)

## 时间复杂度与数据范围

![](https://raw.githubusercontent.com/NaisWang/images/master/20220414115008.png)

在竞赛中，一般认为计算机一秒能执行$5 ×10^8$次计算，如果题目给出的时间限制为1秒，那么选择的算法执行的计算次数最多应该在$10^8$量级才有可能解决这个题目。
一般情况下：
- $O(n)$的算法能解决的数据范围在 $n≤10^8$
- $O(nlogn)$ 的算法能解决的数据范围在 $n≤10^6$
- $O(n\sqrt{n})$ 的算法能解决的数据范围在 $n≤10^5$
- $O(n^2)$ 的算法能解决的数据范围在 $n≤5000$; $5000^2 = 25000000 ≈ 3 * 10^8 $
- $O(n^3)$ 的算法能解决的数据范围在 $n≤300$; $300^3 = 27000000 ≈ 3 * 10^8 $
- $O(2^n)$ 的算法能解决的数据范围在 $n≤25$; $2^25 = 33554432 ≈ 3 * 10^8$$
- $O(n!)$ 的算法能解决的数据范围在 $n≤11$; $11! = 39916800 ≈ 4 * 10^8$

以上范围仅供参考，实际过程中还要考虑每种算法的常数。


### 渐渐符号

#### Θ符号
$$Θ(g(n)) = {f(n):存在正常量c_1, c_2, 和n_0，使得对所有n \geq n_0, 有0 \leq c_1g(n) \leq f(n) \leq c_2g(n)}$$

若存在正常量$c_1和c_2$，使得对于足够大的n，函数f(n)能“夹入”$c_1g(n)与c_2g(n)$之间，则f(n)属于集合Θ(g(n))。因为Θ(g(n))是一个集合，所以可以记“$f(n) \in Θ(g(n))$”，以指出f(n)是Θ(g(n))的成员。作为替代，我们通常记“f(n) = Θ(g(n))”以表达相同的概念。

#### O符号
$$O(g(n)) = {f(n):存在正常量c, 和n_0，使得对所有n \geq n_0, 有0 \leq f(n) \leq cg(n)}$$

#### Ω符号
$$Ω(g(n)) = {f(n):存在正常量c, 和n_0，使得对所有n \geq n_0, 有0 \leq cg(n) \leq f(n)}$$

![](https://raw.githubusercontent.com/NaisWang/images/master/20220119104219.png)

#### o符号
由于O符号提供的渐进上界可能是也可能不是渐近紧确的。界$2n^2=O(n^2)$是渐近紧确的,但是$2n=O(n^2)$却不是。我们使用o符号来表示一个非渐近紧确的上界。

$$o(g(n)) = {f(n):对任意正常量c, 和n_0，使得对所有n \geq n_0, 有0 \leq f(n) < cg(n)}$$

例如：$2n=o(n^2), 但是2n^2 \not= o(n^2)$

#### ω符号
ω符号与Ω符号的关系类似于o符号与O符号的关系。我们使用ω符号来表示一个非渐近紧确的下界。

$$ω(g(n)) = {f(n):对任意正常量c, 和n_0，使得对所有n \geq n_0, 有0 \leq cg(n) < f(n)}\\\$$

### 主方法

<div class="container">
  <iframe src="https://docs.google.com/document/d/e/2PACX-1vROjB7rSJrDTeE8SPvqcjH0x7q0Z0NOSDotAduN8ihLBAUVaGdacHq-Z9ToHB4HQLOpgSzTPq0ITzeW/pub?embedded=true"></iframe>
</div>

## 回溯、分治、递归区别
### 递归
递归就是自我调用，经常作为一种编程的实现方式，比如动态规划、回溯法、分治法都可以用递归来实现，当然也可以用非递归来实现。

### 分治算法
#### 基本思想
分治法的设计思想是： 将一个难以直接解决的大问题，分割成一些规模较小的相同问题，以便各个击破，分而治之 。

在计算机科学中，分治法是一种很重要的算法。字面上的解释是“分而治之”，就是 把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并 。这个技巧是很多高效算法的基础，如排序算法(快速排序，归并排序)，傅立叶变换(快速傅立叶变换)……

任何一个可以用计算机求解的问题所需的计算时间都与其规模有关。问题的规模越小，越容易直接求解，解题所需的计算时间也越少。例如，对于n个元素的排序问题，当n=1时，不需任何计算。n=2时，只要作一次比较即可排好序。n=3时只要作3次比较即可，…。而当n较大时，问题就不那么容易处理了。要想直接解决一个规模较大的问题，有时是相当困难的。

#### 分治法的基本步骤
分治法在每一层递归上都有三个步骤：
- step1 分解：将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题；
- step2 解决：若子问题规模较小而容易被解决则直接解，否则递归地解各个子问题
- step3 合并：将各个子问题的解合并为原问题的解。

#### 使用分治法的经典案例
- 二分查找
- 归并排序
- 快速排序

### 回溯法
回溯是一种通用的算法，把问题分步解决，在每一步都试验所有的可能，当发现已经找到一种方式或者目前这种方式不可能是结果的时候，退回上一步继续尝试其他可能。很多时候每一步的处理都是一致的，这时候用递归来实现就很自然。回溯有点类似于穷举，但是和穷举不同的是回溯会“剪枝”。

#### 使用回溯法的经典案例
- DFS
- 全排列

## 枚举
<div class="container">
  <iframe src="https://drive.google.com/file/d/14BqjQi3YcamJgb1tzUMgj7Ltvv9lKpA4/preview" width="640" height="480" allow="autoplay"></iframe>
</div>

### OpenJudge-NOI/2.1基本算法之枚举-1816：拨钟问题
总时间限制: 1000ms 内存限制: 65536kB

描述

有9个时钟，排成一个`3*3`的矩阵。
```
|-------|    |-------|    |-------|
|       |    |       |    |   |   |
|---O   |    |---O   |    |   O   |
|       |    |       |    |       |
|-------|    |-------|    |-------|
    A            B            C    

|-------|    |-------|    |-------|
|       |    |       |    |       |
|   O   |    |   O   |    |   O   |
|   |   |    |   |   |    |   |   |
|-------|    |-------|    |-------|
    D            E            F    

|-------|    |-------|    |-------|
|       |    |       |    |       |
|   O   |    |   O---|    |   O   |
|   |   |    |       |    |   |   |
|-------|    |-------|    |-------|
    G            H            I    
```
              (图 1)
现在需要用最少的移动，将9个时钟的指针都拨到12点的位置。共允许有9种不同的移动。如下表所示，每个移动会将若干个时钟的指针沿顺时针方向拨动90度。
```
移动    影响的时钟

 1         ABDE
 2         ABC
 3         BCEF
 4         ADG
 5         BDEFH
 6         CFI
 7         DEGH
 8         GHI
 9         EFHI    
```
输入

9个整数，表示各时钟指针的起始位置，相邻两个整数之间用单个空格隔开。其中，0=12点、1=3点、2=6点、3=9点。

输出

输出一个最短的移动序列，使得9个时钟的指针都指向12点。按照移动的序号从小到大输出结果。相邻两个整数之间用单个空格隔开。

样例输入
```
3 3 0 
2 2 2 
2 1 2 
```
样例输出

```
4 5 8 9
```

#### 题解
由题可知，一共有9种不同的移动，那么我们将每一种移动对应于一种操作(operation),简写成op。每种操作都会影响若干个时钟，那么我们将每种操作影响的时钟转换为每个时钟受哪些操作的影响。如下所示：
```
A 1 2 4
B 1 2 3 5
C 2 3 6
D 1 4 5 7
E 1 3 5 7 9
F 3 5 6 9
G 4 7 8
H 5 7 8 9
I 6 8 9
```
又因为每次操作会将若干个时钟转动90度，所以当同一个操作进行4次，其实就是旋转了360度，相当于没有操作。(**一种操作做四次和不做是一样的**)所以每种操作做的次数为：0，1，2，3。一共有9种操作，所以枚举次数为4的9次方，暴力枚举就是一个9重循环。最后用一个变量sum来累加每个时钟被操作后的指向，如果累加完后sum=0，那么说明找到了一个移动序列使得9个时钟的指针都指向12点。但此时我们并不知道找到的是否就是最短的序列，所以还要进行比较取操作次数的最小值。

##### 方法一 暴力枚举
代码如下：
```cpp
#include<iostream>
using namespace std;
int ori[10];
int op[10];
int result[10];
int main()
{
    int sum,min=28,moves;
    for(int i=1; i<10; ++i)
      cin >> ori[i];
    for(op[1]=0; op[1]<4; ++op[1])
      for(op[2]=0; op[2]<4; ++op[2])
        for(op[3]=0; op[3]<4; ++op[3])
          for(op[4]=0; op[4]<4; ++op[4])
            for(op[5]=0; op[5]<4; ++op[5])
              for(op[6]=0; op[6]<4; ++op[6])
                for(op[7]=0; op[7]<4; ++op[7])
                  for(op[8]=0; op[8]<4; ++op[8])
                    for(op[9]=0; op[9]<4; ++op[9])
                    {
                        sum=0;
                        sum+=(ori[1]+op[1]+op[2]+op[4])%4;
                        sum+=(ori[2]+op[1]+op[2]+op[3]+op[5])%4;
                        sum+=(ori[3]+op[2]+op[3]+op[6])%4;
                        sum+=(ori[4]+op[1]+op[4]+op[5]+op[7])%4;
                        sum+=(ori[5]+op[1]+op[3]+op[5]+op[7]+op[9])%4;
                        sum+=(ori[6]+op[3]+op[5]+op[6]+op[9])%4;
                        sum+=(ori[7]+op[4]+op[7]+op[8])%4;
                        sum+=(ori[8]+op[5]+op[7]+op[8]+op[9])%4;
                        sum+=(ori[9]+op[6]+op[8]+op[9])%4;
                        if(sum==0)
                        {   
                            moves=0;
                            for(int i=1; i<10; ++i)
                                moves+=op[i];
                            if(moves<min)
                            {
                                min=moves;
                                for(int i=1; i<10; ++i)
                                    result[i]=op[i];
                            }   
                        }
                    }
    for(int i=1; i<10; ++i)
    {
        while(result[i]--)
        {
            cout << i << " ";
        }
    }
    return 0;
}
```

枚举的核心问题就是：
1. 怎样去枚举？
2. 在答案正确的情况下，怎么减少枚举次数？

所以这道题怎么减少枚举次数呢？

枚举中有一个十分重要的思想—<font color="red">局部思想法</font>，它的基本思路如下：

所以我们来看这道题，看能不能找到一个局部使得枚举的次数减少。不难发现操作1，2，3为一个局部。例如，当我们确定了操作1，2，3的次数以后，得到A,B,C这三个时钟的指针的指向，此时只有操作4能够改变A时钟的的指针方向，使它能指向12点。同理，只有操作5才能够改变B时钟的指针方向，只有操作6才能够改变C时钟的指针方向。那么操作4-6的次数也就确定了。同样，继续往下，现在操作1-6的次数都确定了，只有操作7才能改变D时钟的指针方向，只有操作8才能改变G时钟的指针方向,只有操作9才能改变F时钟的指针方向。

这样操作1-9的次数都被确定了，A,B,C,D,G,F这6个时钟的指针都指向了12点，只有E,H,I这三个时钟指针方向还没有确定。所以剩下只用判断E,H,I这三个时钟的指针指向12点没有，如果都指向了12点，那说明找到了一个序列使得9个时钟的指针都指向了12点。

所以根据局部思想的方法，我们只需对操作1，2，3进行枚举，枚举的次数为4的3次方=64次。

##### 方法二 局部枚举
代码如下：
```cpp
#include<iostream>
using namespace std;
int ori[10];
int op[10];
int result[10];
int main()
{
    int min=28,moves,e,h,i;
    for(int i=1; i<10; ++i)
      cin >> ori[i];
    for(op[1]=0; op[1]<4; ++op[1])
      for(op[2]=0; op[2]<4; ++op[2])
        for(op[3]=0; op[3]<4; ++op[3])
        {
            op[4]=(4-(ori[1]+op[1]+op[2])%4)%4;//确定A
            op[5]=(4-(ori[2]+op[1]+op[2]+op[3])%4)%4;//确定B
            op[6]=(4-(ori[3]+op[2]+op[3])%4)%4;//确定C
            op[7]=(4-(ori[4]+op[1]+op[4]+op[5])%4)%4;//确定D
            op[8]=(4-(ori[7]+op[4]+op[7])%4)%4;//确定G
            op[9]=(4-(ori[6]+op[3]+op[5]+op[6])%4)%4;//确定F
            e=(ori[5]+op[1]+op[3]+op[5]+op[7]+op[9])%4;
            h=(ori[8]+op[5]+op[7]+op[8]+op[9])%4;
            i=(ori[9]+op[6]+op[8]+op[9])%4;
            if((e+h+i)==0)//判断E,H,I这三个时钟指针都指向12点没有
            {
                moves=0;
                for(int i=1; i<10; ++i)
                    moves+=op[i];
                if(moves<min)
                {
                    min=moves;
                    for(int i=1; i<10; ++i)
                        result[i]=op[i];
                }       
            }
        }
    for(int i=1; i<10; ++i)
    {
        while(result[i]--)
        {
            cout << i << " ";
        }
    }
    return 0;               
}
```

### 枚举总结
#### 枚举流程图

![](https://raw.githubusercontent.com/NaisWang/images/master/20220515194653.png)

#### 枚举遍历方法
枚举**由n个节点状态组合搭配而成的集合**，常见有如下4种方法：
- 使用for循环
- 使用进位
- 使用dfs

例如：现在有3个节点，分别是A、B、C。这三个节点都有4个状态，分别是0、1、2、3。现在需要枚举由这3个节点状态组合搭配而成的集合{(i, j, z) | i, j, z∈(0, 1, 2, 3) }。

##### 使用for循环
```java
for (int i = 0; i < 4; i++) {
  for (int j = 0; j < 4; j++) {
    for (int z = 0; z < 4; z++) {
      System.out.println(i + "," + j + "," + z);
    }
  }
}
```

##### 使用进位
```java
// base长度表示节点个数；base的元素表示节点的状态
int[] base = new int[3];

// 4 * 4 * 4 表示集合元素个数
for (int times = 0; times < 4 * 4 * 4; times++) {
  System.out.println(Arrays.toString(base));

  base[0]++;
  int i = 0;
  // 进位操作
  while (base[i] == 4) {
    base[i] = 0;
    i++;
    if (i != 3) {
      base[i]++;
    } else {
      break;
    }
  }
}
```

##### 使用dfs

方式一：
```java
int[] nodes = new int[3];
dfs(nodes, 0);

/**
* nodes：节点集合
* nowNode: 当前节点
*/
public void dfs(int[] nodes, int nowNode) {

  for (int status = 0; status < 4; status++) {
    nodes[nowNode] = status;
    if (nowNode != 2) {
      dfs(nodes, nowNode + 1);
    } else {
      System.out.println(Arrays.toString(nodes));
    }
  }

}
```

方式二:
```java
class Node {

  private String name;
  private int status;

  public Node(String name) {
    this.name = name;
  }

  @Override
  public String toString() {
    return status + "";
  }

}

private Node A = new Node("A");
private Node B = new Node("B");
private Node C = new Node("C");
private Node[] nodes = new Node[]{A, B, C};

/**
* nodeIndex: 节点下标
*/
public void dfs(int nodeIndex) {
  for (int status = 0; status < 4; status++) {
    nodes[nodeIndex].status = status;
    if (nodeIndex != 2) {
      dfs(nodeIndex + 1);
    } else {
      System.out.println(Arrays.toString(nodes));
    }
  }
}
```

## 递归
### 递归解题套路
#### 递归树
由于<font color="red">所有的递归都可以对应到一个**递归树**上，每个节点代表一个栈帧，表示递归函数。</font>

![](https://raw.githubusercontent.com/NaisWang/images/master/20220408161854.png)

1. 按照以上的搜索路线来搜索树时，当节点第一次被碰到时入栈，最后一次碰到时出栈。
   对应以上图：节点的碰到顺序：1->2->3->2->4->2->1->5->6->5->1
          节点的入栈顺序：1->2->3->4->5->6
          节点的出栈顺序：3->4->2->6->5->1
2. 记录每个节点入栈、出栈时的栈帧之间共享的数据， 以及入栈时的形参值，退栈时的返回值
3. 指向子节点的有向边对应着代码中子节点入栈前父节点要执行的代码；指向父节点的有向边对应着代码中子节点出栈后父节点要执行的操作。

<font color="red">所以我们在思考如何使用递归时，只需要搞清3件事：</font>
1. 节点对应的函数
2. 父子节点之间的关系
3. 节点不能生成子节点的情况

如果能搞清上述3件事，就能使用递归

#### 题目
使用以上知识点完成下面三个题目，下面三个题目严格遵循上述知识点

##### 递归实现指数型枚举

- [递归实现指数型枚举](https://www.acwing.com/problem/content/94/)

**题目描述:**
从 1∼n,这 n个整数中随机选取任意多个，输出所有可能的选择方案。
输入格式: 输入一个整数 n
输出格式: 每行输出一种方案。
同一行内的数必须升序排列，相邻两个数用恰好1个空格隔开。对于没有选任何数的方案，输出空行。
数据范围: `1≤n≤15`
输入样例：`3`
输出样例：
```
3
2
2 3
1
1 3
1 2
1 2 3
```

###### 分析

1. 节点的作用：给定一个数num与一个列表，做2种处理，分别是将这num添加到列表中、不添加到列表中
2. 父子节点之间的关系： 子节点的num比父节点的num大1
3. 节点不能生成子节点的情况: 节点的num等于输入的n

当n=3时对应的递归树如下：

![](https://raw.githubusercontent.com/NaisWang/images/master/20220408161907.png)

代码:
```java
public class Main{

  private static Integer n = null;

  public static void main(String[] args){
    initInput();
    dfs(1, new LinkedList()); 
  }

  public static void initInput(){
    Scanner scan = new Scanner(System.in); 
    n = scan.nextInt();
  }

  public static void dfs(int num, List<Integer> ans){
    if(num == n+1){
      System.out.println(ans.toString().replace("[", "").replace("]", "").replace(",", ""));
      return;
    }
    ans.add(num++);
    dfs(num, ans);
    ans.remove(ans.size()-1);
    dfs(num, ans);
  }
}
```

##### 递归实现组合型枚举
- [递归实现排列型枚举](https://www.acwing.com/problem/content/96/)
**题目描述:**
把 1∼n这 n个整数排成一行后随机打乱顺序，输出所有可能的次序。
输入格式: 一个整数 n
输出格式: 按照从小到大的顺序输出所有方案，每行 1个。
首先，同一行相邻两个数用一个空格隔开。
其次，对于两个不同的行，对应下标的数一一比较，字典序较小的排在前面。
数据范围: `1≤n≤9`
输入样例：`3`
输出样例：
```
1 2 3
1 3 2
2 1 3
2 3 1
3 1 2
3 2 1
```

###### 分析
1. 节点的作用：将1～n中为被访问到的数字添加或不添加到答案列表中
2. 父子节点之间的关系：父节点访问了一个数字, 子节点不能再访问这个数字
3. 节点不能生成子节点的情况:  1～n的数全部被访问

当n=3时对应的递归树如下：

![](https://raw.githubusercontent.com/NaisWang/images/master/20220408161919.png)

代码：
```java
public class Main{

  private static Integer n = null;
  private static boolean[] flag = null; 

  public static void main(String[] args){
    initInput();    
    flag = new boolean[n+1];
    dfs(new LinkedList());
  } 

  public static void initInput(){
    Scanner scan = new Scanner(System.in);
    n = scan.nextInt(); 
  }
  
  public static void dfs(List<Integer> ans){
    if(ans.size() == n) {
      System.out.println(ans.toString().replace(",", "").replace("[", "").replace("]", ""));
      return;
    }
    for(int i = 1; i <= n; i++){
      if(!flag[i]){
        flag[i] = true;
        ans.add(i);
        dfs(ans);
        ans.remove(ans.size()-1);
        flag[i] = false;
      }
    }
  }
}
```

##### 矩阵中的路径
- [矩阵中的路径](https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/)
给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。
单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。
例如，在下面的 3×4 的矩阵中包含单词 "ABCCED"（单词中的字母已标出）。

![](https://raw.githubusercontent.com/NaisWang/images/master/20220408161931.png)

示例 1：
输入：board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCCED"
输出：true
示例 2：
输入：board = [["a","b"],["c","d"]], word = "abcd"
输出：false

###### 分析
1. 节点的作用：判断从当前坐标出发，是否能够找到从index到最后字符的字符串
2. 父子节点之间的关系：子节点的index比父节点大1
3. 节点不能生成子节点的情况: index等于目标字符串的长度

对于输入为board = [["A","B","D"],["B","C","E"],["D","C","E"]], word = "ABDE"时，递归树为：

![](https://raw.githubusercontent.com/NaisWang/images/master/20220408161942.png)

代码：
```java
class Solution{
  private int[] rowDirection = {-1, 1, 0, 0};
  private int[] columnDirection = {0, 0, -1, 1};
  
  public boolean exist(char[][] board, String word){
    for(int i = 0; i < board.length; i++){
      for(int j = 0; j < board[0].length; j++){
        if(board[i][j] == word.charAt(0)){
          char temp = board[i][j];
          board[i][j] = '0';
          if(dfs(board, word, i, j, 1)){
            return true;
          }
          board[i][j] = temp;
        }
      }
    }
    return false;
  } 

  public boolean dfs(char[][] board, String word, int row, int column, int index){
    if(index == word.length()){
      return true;
    }
    for(int i = 0; i < 4; i++){
      int nextRow = row+rowDirection[i];
      int nextColumn = column+columnDirection[i];
      if(nextRow >= 0 && nextRow < board.length && nextColumn >= 0 && nextColumn < board[0].length){
        if(word.charAt(index) == board[nextRow][nextColumn]){
          index++;
          char temp = board[nextRow][nextColumn];
          board[nextRow][nextColumn] = '0';
          if(dfs(board, word, nextRow, nextColumn, index)){
            return true;
          }
          index--; 
          board[nextRow][nextColumn] = temp;
        }
      }
    }
    return false;
  }
}
```

### 尾递归

如果一个函数中所有递归形式的调用都出现在函数的末尾，我们称这个递归函数是尾递归的。当递归调用是整个函数体中最后执行的语句且它的返回值不属于表达式的一部分时，这个递归调用就是尾递归。尾递归函数的特点是在回归过程中不用做任何操作，这个特性很重要，因为大多数现代的编译器会利用这种特点自动生成优化的代码。
#### 原理
当编译器检测到一个函数调用是尾递归的时候，它就覆盖当前的活动记录而不是在栈中去创建一个新的。编译器可以做到这点，因为递归调用是当前活跃期内最后一条待执行的语句，于是当这个调用返回时栈帧中并没有其他事情可做，因此也就没有保存栈帧的必要了。通过覆盖当前的栈帧而不是在其之上重新添加一个，这样所使用的栈空间就大大缩减了，这使得实际的运行效率会变得更高。
#### 实例
为了理解尾递归是如何工作的，让我们再次以递归的形式计算阶乘。首先，这可以很容易让我们理解为什么之前所定义的递归不是尾递归。回忆之前对计算n!的定义：在每个活跃期计算n倍的(n－1)!的值，让n=n－1并持续这个过程直到n=1为止。这种定义不是尾递归的，因为每个活跃期的返回值都依赖于用n乘以下一个活跃期的返回值，因此每次调用产生的栈帧将不得不保存在栈上直到下一个子调用的返回值确定。现在让我们考虑以尾递归的形式来定义计算n!的过程。
这种定义还需要接受第二个参数a，除此之外并没有太大区别。a（初始化为1）维护递归层次的深度。这就让我们避免了每次还需要将返回值再乘以n。然而，在每次递归调用中，令a=na并且n=n－1。继续递归调用，直到n=1，这满足结束条件，此时直接返回a即可。
代码实例3-2给出了一个C函数facttail，它接受一个整数n并以尾递归的形式计算n的阶乘。这个函数还接受一个参数a，a的初始值为1。facttail使用a来维护递归层次的深度，除此之外它和fact很相似。读者可以注意一下函数的具体实现和尾递归定义的相似之处。
示例3-2：以尾递归的形式计算阶乘的一个函数实现
```cpp
int facttail(int n, int a)
{
    if (n < 0)
        return 0;    
    else if (n == 0)
        return 1;    
    else if (n == 1)
        return a;
    else
        return facttail(n - 1, n * a);
}
```
示例3-2中的函数是尾递归的，因为对facttail的单次递归调用是函数返回前最后执行的一条语句。在facttail中碰巧最后一条语句也是对facttail的调用，但这并不是必需的。换句话说，在递归调用之后还可以有其他的语句执行，只是它们只能在递归调用没有执行时才可以执行。
尾递归是极其重要的，不用尾递归，函数的堆栈耗用难以估量，需要保存很多中间函数的堆栈。比如f(n, sum) = f(n-1) + value(n) + sum; 会保存n个函数调用堆栈，而使用尾递归f(n, sum) = f(n-1, sum+value(n)); 这样则只保留后一个函数堆栈即可，之前的可优化删去。
也许在C语言中有很多的特例，但编程语言不只有C语言，在函数式语言Erlang中（亦是栈语言），如果想要保持语言的高并发特性，就必须用尾递归来替代传统的递归。

# 栈与队列
## 栈
### 递归函数转非递归
首先，递归的本质就是函数调用，我们都知道函数调用是依靠栈来完成，调用函数就入栈，函数结束是出栈。

在 Java 代码中可以自定义一个类来模拟一个栈帧，我们模拟的栈帧必须要含有如下基本信息：
- 局部变量表：用于存放方法参数和方法内部定义的局部变量。 可以用`HashMap<String, Object>`类型来存储，key为变量名，value为值
- 方法返回地址: 方法被调用的位置。可以用`int`类型来存储
- 操作数栈: 在此处只有一个作用，就是用来存放被调用者返回的返回值。可以用`Stack<Object>`类型来存储

#### 模版
```java
int dfsBystack(int n) {

  // 定义函数栈
  Stack<Frame> stack = new Stack();

  // 压入main函数的栈帧, 用于接收main函数中调用这个递归函数后的返回值
  stack.push(new Frame(new HashMap())); 

  // 压入当前函数的栈帧
  HashMap<String, Integer> locals = new HashMap(); 
  locals.put("n", n);
  stack.push(new Frame(locals)); 

  // 当函数栈中只有main函数栈帧时，退出循环
  while(stack.size() != 1) {

    // 获取当前函数栈栈顶元素  
    Frame currentFrame = stack.peek();

    // 将代码定位到方法返回地址处执行相应后续代码
    if (currentFrame.flag == 0) {
      ... //
    } else if (currentFrame.flag == 1) {
      ... // 
    } 
    ...
    else {
      ... //
    }

  }

  // 将函数栈中的操作数栈的栈顶元素返回
  return stack.peek().operand.peek();

}

class Frame {
  // 局部变量表
  HashMap<String, Integer> locals; 

  // 方法返回地址
  int flag; 

  // 操作数栈
  Stack<Integer> operand;  
  
  public Frame (HashMap<String, Integer> locals) {
    this.locals = locals;
    flag = 0;
    operand = new Stack();
  }
  
}
```

#### 例子1: 斐波拉契数列
[斐波拉契数列](https://leetcode.cn/problems/fibonacci-number/)

以斐波拉契数列生成为例，典型的递归版本如下
```java
int fibonacci(int n) {
  if (n == 0 || n == 1) {
    return 1;
  } else {
    return fibonacci(n - 1) + fibonacci(n - 2);
  }
}
```

该函数对于到class字节码文件内容如下：
```
 0: iload_0
 1: ifeq          9
 4: iload_0
 5: iconst_1
 6: if_icmpne     11
 9: iconst_1           
10: ireturn
11: iload_0                           // 把第一个局部变量，即n压入操作数栈
12: iconst_1                          // 把1(int型)压入操作数栈
13: isub                              // 将操作数栈栈顶两int类型数弹出进行相减，并将结果压入操作数栈
14: invokestatic  #2                  // Method fibonacci:(I)I ，会把返回值压入操作数栈
17: iload_0                           // 把第一个局部变量，即n压入操作数栈 
18: iconst_2                          // 把2(int型)压入操作数栈
19: isub                              // 将操作数栈栈顶两int类型数弹出进行相减，并将结果压入操作数栈
20: invokestatic  #2                  // Method fibonacci:(I)I, 会把返回值压入操作数栈
23: iadd                              // 将操作数栈栈顶两int类型数弹出并进行相加，并将结果压入操作数栈
24: ireturn                           // 返回操作数栈栈顶元素
```

找到其中的方法调用，标记上flag，即方法返回地址标识
```java
int fibonacci(int n) {
  // flag 0 函数入口
  if (n == 0 || n == 1) {
    return 1;
  } else {
    // 在调用fibonacci(n - 1)后有一个方法返回地址标识，记做flag 1
    // 在调用fibonacci(n - 2)后有一个方法返回地址标识，记做flag 2
    return fibonacci(n - 1) + fibonacci(n - 2);
  }
}
```

代码: 
```
class Solution {
  public int fib(int n) {
    return dfsByStack(n);
  }
  
  int dfsByStack(int n) {
    Stack<Frame> stack = new Stack();
    stack.push(new Frame(new HashMap()));

    HashMap<String, Integer> locals = new HashMap(); 
    locals.put("n", n);
    stack.push(new Frame(locals));

    while(stack.size() != 1) {
      Frame currentFrame = stack.peek();
      // 将代码定位到方法返回地址处
      if (currentFrame.flag == 0) {
        if (currentFrame.locals.get("n") == 0 || currentFrame.locals.get("n") == 1) {
          stack.pop();
          stack.peek().operand.push(currentFrame.locals.get("n"));
        } else {
           locals = new HashMap(); 
           locals.put("n", currentFrame.locals.get("n") - 1);
           Frame nextFrame = new Frame(locals);
           stack.push(nextFrame);
           currentFrame.flag = 1;
        }
      } else if (currentFrame.flag == 1) {
        locals = new HashMap(); 
        locals.put("n", currentFrame.locals.get("n") - 2);
        Frame nextFrame = new Frame(locals);
        stack.push(nextFrame);
        currentFrame.flag = 2;
      } else if (currentFrame.flag == 2) {
        int returnValue = currentFrame.operand.push(currentFrame.operand.pop() + currentFrame.operand.pop());
        stack.pop();
        stack.peek().operand.push(returnValue);
      }
    }

    return stack.peek().operand.peek();
  }

  class Frame {
    HashMap<String, Integer> locals; // 局部变量表
    int flag; // 方法返回地址
    Stack<Integer> operand;  // 操作数栈
    
    public Frame (HashMap<String, Integer> locals) {
      this.locals = locals;
      flag = 0;
      operand = new Stack();
    }
  }
}
```

#### 例子2: 二叉树的中序遍历
[二叉树的中序遍历](https://leetcode.cn/problems/binary-tree-inorder-traversal/)

代码：
```java
class Solution {

  List<Integer> ans = new ArrayList();

  public List<Integer> inorderTraversal(TreeNode root) {
    dfsByStack(root);
    return ans;
  }
  
  void dfsByStack(TreeNode root) {
    Stack<Frame> stack = new Stack();
    stack.push(new Frame(new HashMap()));

    HashMap<String, TreeNode> locals = new HashMap();
    locals.put("root", root);
    stack.push(new Frame(locals));

    while (stack.size() != 1) {
      Frame currentFrame = stack.peek();
      if (currentFrame.flag == 0) {
        if (currentFrame.locals.get("root") == null) {
          stack.pop();
        } else {
          locals = new HashMap();
          locals.put("root", currentFrame.locals.get("root").left);
          stack.push(new Frame(locals));
          currentFrame.flag = 1;
        }
      } else if (currentFrame.flag == 1) {
        ans.add(currentFrame.locals.get("root").val);
        locals = new HashMap();
        locals.put("root", currentFrame.locals.get("root").right);
        stack.push(new Frame(locals));
        currentFrame.flag = 2;
      } else {
        stack.pop();
      }
    }
    
  }

  class Frame {
    HashMap<String, TreeNode> locals;
    int flag;
    
    public Frame (HashMap<String, TreeNode> locals) {
      this.locals = locals;
      flag = 0;
    }
  }
}
```

### 栈在表达式求值中的应用

![](https://raw.githubusercontent.com/NaisWang/images/master/20220524194225.png)

#### 例题1: 逆波兰表达式求值
[逆波兰表达式求值](https://leetcode.cn/problems/evaluate-reverse-polish-notation/)

根据 逆波兰表示法，求表达式的值。

有效的算符包括 `+、-、*、/` 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。

注意 两个整数之间的除法只保留整数部分。

可以保证给定的逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。


示例 1：
```txt
输入：tokens = ["2","1","+","3","*"]
输出：9
解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9
```


```java
class Solution {
  public int evalRPN(String[] tokens) {
    Stack<Integer> operand = new Stack();

    for (String token : tokens) {
      if (token.equals("+")) {
        operand.push(operand.pop() + operand.pop());
      }else if (token.equals("-")) {
        operand.push(-1 * operand.pop() + operand.pop());
      }else if (token.equals("*")) {
        operand.push(operand.pop() * operand.pop());
      }else if (token.equals("/")) {
        operand.push((int)(1.0 / operand.pop() * operand.pop()));
      } else {
        operand.push(Integer.valueOf(token));
      }
    }

    return operand.peek();
  }
}
```

### 用栈实现队列
例题： [用栈实现队列](https://leetcode.cn/problems/implement-queue-using-stacks/)

分析：https://leetcode.cn/problems/implement-queue-using-stacks/solution/yong-zhan-shi-xian-dui-lie-by-leetcode/

代码：
```java
class MyQueue {

  Stack<Integer> stack1; 
  Stack<Integer> stack2;

  public MyQueue() {
    stack1 = new Stack();
    stack2 = new Stack();
  }
  
  public void push(int x) {
    while (!stack1.isEmpty()) {
      stack2.push(stack1.pop());
    }
    stack1.push(x);
    while (!stack2.isEmpty()) {
      stack1.push(stack2.pop());
    }
  }
  
  public int pop() {
    return stack1.pop();
  }
  
  public int peek() {
    return stack1.peek();
  }
  
  public boolean empty() {
    return stack1.isEmpty();
  }
}
```


## 单调栈
单调栈是一种特殊的栈。栈本来就是一种受限的数据结构了，单调栈在此基础上又受限了一次（受限++）。即要往栈中添加数据A时，要先判断添加数据A后，是否影响了单调性，若影响了则弹出栈顶元素，直到插入数据A后不会影响栈的单调性后，再插入数据A。

单调递增栈：栈顶到栈底，元素单调递增
单调递减栈：栈顶到栈底，元素单调递减

比如：
```txt
 \  9  /      \  1  /
 |  7  |      |  3  |
 |  5  |      |  5  |
 |  3  |      |  7  |
 |  2  |      |  9  |
 -------      -------
单调递减栈     单调递增栈
```

### 适用场景一
给一个数组或序列，如果想要知道每个元素的右边第一个比它大（小）的元素是哪个。如果用暴力算法来做的话，复杂度是O(n^2)。而使用单调栈可以将复杂度降到只有O(n); 这是单调栈的主要应用场景。 具体过程如下：

当给一个数组或序列，如果想要知道每个元素的右边第一个比它大（小）的元素是哪个，则我们可以从数组右边界开始往左遍历，将这些元素插入单调递增栈（单调递减栈）中。往单调递增栈（单调递减栈）中插入元素时，可以先需要弹出一些元素，因为要使得元素插入后，依然是单调递增栈（单调递减栈）。在弹出一些元素后，如果此时元素可以插入了，那么此时栈顶元素就是要插入元素的右边第一个比它大（小）的元素。

因为是要知道一个元素A的右边第一个比它大（小）的元素是哪个，所以我们肯定是要先遍历到这个元素A的右边，从而我们是从数组的右边界开始往左遍历。又因为A元素右边第一个比它大（小）的元素B一定是先到栈底，而且元素A插入栈时元素B是没有弹出来的，即后入栈的元素A小于（大于）现入栈的B，所以我们需要维护的是单调递增栈（单调递减栈）

例子：现在有一个数组`[2,1,2,4,3]`, 我先需要知道该数组中的每个元素的左边第一个比它大的元素是哪个? 我们从数组右边界开始往左遍历，维护一个单调递增栈。然后维护一个res数组，这个数组就是存储`[2,1,2,4,3]`数组中的每个元素的左边第一个比它大的元素是哪个。 过程如下：

|第i步|操作|单调栈(栈顶->栈底)|res数组|
|--|--|--|--|
|1|3进栈|3|[0,0,0,0,-1]|
|2|3出栈，4进栈|4|[0,0,0,-1,-1]|
|3|2进栈|2->4|[0,0,4,-1,-1]|
|4|1进栈|1->2->4|[0,2,4,-1,-1]|
|5|1,2出栈，2进栈|2->4|[4,2,4,-1,-1]|

所以最终`res=[4,2,4,-1,-1]`

#### 模版
**获取右边第一个更大元素的元素值**
```java
int[] rightFirstGreater(int[] nums) {
  int[] res = new int[nums.length];
  Stack<Integer> stack = new Stack(); 
  for (int i = nums.length - 1; i >= 0; i--) {
    while (!stack.isEmpty() && nums[i] >= stack.peek()) {
      stack.pop();
    }
    res[i] = stack.isEmpty() ? -1 : stack.peek(); 
    stack.push(nums[i]);
  }
  return res;
}
```

**获取右边第一个更大元素的下标**, 见例题2
```java
int[] rightFirstGreater(int[] nums) {
  int[] res = new int[nums.length];
  Stack<Integer> stack = new Stack();
  for (int i = nums.length - 1; i >= 0; i--) {
    while (!stack.isEmpty() && nums[i] >= nums[stack.peek()]) {
      stack.pop();
    }
    res[i] = stack.isEmpty() ? -1 : stack.peek();
    stack.push(i);
  }
  return res;
}
```

#### 例题1: 下一个更大元素 I
[下一个更大元素 I](https://leetcode.cn/problems/next-greater-element-i/)

nums1 中数字 x 的 下一个更大元素 是指 x 在 nums2 中对应位置 右侧 的 第一个 比 x 大的元素。

给你两个 没有重复元素 的数组 nums1 和 nums2 ，下标从 0 开始计数，其中nums1 是 nums2 的子集。

对于每个 0 <= i < nums1.length ，找出满足 nums1[i] == nums2[j] 的下标 j ，并且在 nums2 确定 nums2[j] 的 下一个更大元素 。如果不存在下一个更大元素，那么本次查询的答案是 -1 。

返回一个长度为 nums1.length 的数组 ans 作为答案，满足 ans[i] 是如上所述的 下一个更大元素 。

示例 1：
```txt
输入：nums1 = [4,1,2], nums2 = [1,3,4,2].
输出：[-1,3,-1]
解释：nums1 中每个值的下一个更大元素如下所述：
- 4 ，用加粗斜体标识，nums2 = [1,3,4,2]。不存在下一个更大元素，所以答案是 -1 。
- 1 ，用加粗斜体标识，nums2 = [1,3,4,2]。下一个更大元素是 3 。
- 2 ，用加粗斜体标识，nums2 = [1,3,4,2]。不存在下一个更大元素，所以答案是 -1 。
```

示例 2：
```txt
输入：nums1 = [2,4], nums2 = [1,2,3,4].
输出：[3,-1]
解释：nums1 中每个值的下一个更大元素如下所述：
- 2 ，用加粗斜体标识，nums2 = [1,2,3,4]。下一个更大元素是 3 。
- 4 ，用加粗斜体标识，nums2 = [1,2,3,4]。不存在下一个更大元素，所以答案是 -1 。
```

代码：
```java
class Solution {
  public int[] nextGreaterElement(int[] nums1, int[] nums2) {
    int[] res = rightFirstGreater(nums2);
    int[] ans = new int[nums1.length];
    for (int i = 0; i < nums1.length; i++) {
      for (int j = 0; j < nums2.length; j++) {
        if (nums1[i] == nums2[j]) {
          ans[i] = res[j];
        }
      }
    }
    return ans;
  }
  
  int[] rightFirstGreater(int[] nums) {
    int[] res = new int[nums.length];
    Stack<Integer> stack = new Stack(); 
    for (int i = nums.length - 1; i >= 0; i--) {
      while (!stack.isEmpty() && nums[i] >= stack.peek()) {
        stack.pop();
      }
      res[i] = stack.isEmpty() ? -1 : stack.peek(); 
      stack.push(nums[i]);
    }
    return res;
  }
}
```

#### 例题2: 每日温度
[每日温度](https://leetcode.cn/problems/daily-temperatures/)

给定一个整数数组 temperatures ，表示每天的温度，返回一个数组 answer ，其中 answer[i] 是指在第 i 天之后，才会有更高的温度。如果气温在这之后都不会升高，请在该位置用 0 来代替。

示例 1:
```java
输入: temperatures = [73,74,75,71,69,72,76,73]
输出: [1,1,4,2,1,1,0,0]
```

代码：
```java
class Solution {
  public int[] dailyTemperatures(int[] temperatures) {
    int[] nextGreaterElement = rightFirstGreater(temperatures); 
    int[] ans = new int[temperatures.length];
    for (int i = 0; i < nextGreaterElement.length; i++) {
      if (nextGreaterElement[i] == -1) {
        ans[i] = 0;
      } else {
        ans[i] = nextGreaterElement[i] - i;
      }
    }
    return ans;
  }

  int[] rightFirstGreater(int[] nums) {
    int[] res = new int[nums.length];
    Stack<Integer> stack = new Stack();
    for (int i = nums.length - 1; i >= 0; i--) {
      while (!stack.isEmpty() && nums[i] >= nums[stack.peek()]) {
        stack.pop();
      }
      res[i] = stack.isEmpty() ? -1 : stack.peek();
      stack.push(i);
    }
    return res;
  }

}
```

#### 例题3: 链表中的下一个更大节点
[链表中的下一个更大节点](https://leetcode.cn/problems/next-greater-node-in-linked-list/)

给定一个长度为 n 的链表 head

对于列表中的每个节点，查找下一个 更大节点 的值。也就是说，对于每个节点，找到它旁边的第一个节点的值，这个节点的值 严格大于 它的值。

返回一个整数数组 answer ，其中 answer[i] 是第 i 个节点( 从1开始 )的下一个更大的节点的值。如果第 i 个节点没有下一个更大的节点，设置 answer[i] = 0 。

代码：
```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
  public int[] nextLargerNodes(ListNode head) {
    List<Integer> numsList = new ArrayList();
    ListNode p = head;
    while (p != null) {
      numsList.add(p.val);
      p = p.next;
    }
    Integer[] nums = numsList.toArray(new Integer[numsList.size()]);
    return rightFirstGreater(nums);
  }

  int[] rightFirstGreater(Integer[] nums) {
    int[] res = new int[nums.length];
    Stack<Integer> stack = new Stack();
    for (int i = nums.length - 1; i >= 0; i--) {
      while (!stack.isEmpty() && nums[i] >= stack.peek()) {
        stack.pop();
      }
      res[i] = stack.isEmpty() ? 0 : stack.peek();
      stack.push(nums[i]);
    }
    return res;
  }
  
}
```

#### 例题4: 接雨水
[接雨水](https://leetcode.cn/problems/trapping-rain-water/)

给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。


##### 分析

<div class="container">
  <iframe width="560" height="315" src="https://www.youtube.com/embed/x9uvA-Rd1vI" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>

![](https://raw.githubusercontent.com/NaisWang/images/master/20220526143029.png)

过程：
- 第2块：左边没有比它高的柱子，跳过
- 第3块：左边第一个比它高的柱子为第2块，高度为1；右边第一个不比它矮的柱子左边第一个比它高的柱子为第2块，高度为1；右边第一个不比它矮的柱子为第4块，高度为2；所以可以积水`（(min(2, 1) - 0) * （4 - 2 - 1））= 1`
- 第4块：左边没有比它高的柱子，跳过
- 第5块：左边第一个比它高的柱子为第4块，高度为2；但是右边存在一个不比它矮的柱子为第7块，且高度相等，所以第5块与第7块的积水范围是同一范围，为了避免重复计算，可以把第5块的积水放在计算第7块的积水上
- 第6块：左边第一个比它高的柱子为第5块，高度为1；右边第一个不比它矮的柱子为第7块，高度为1；所以可以积水`（(min(1, 1) - 0 )* (7 - 5 - 1)） = 1`
- 第7块：左边第一个比它高的柱子为第4块，高度为2；右边第一个不比它矮的柱子为第8块，高度为3；所以可以积水`（(min(2, 3) - 1) * (8 - 4 - 1)） = 3`
- 第8块：左边没有比它高的柱子，跳过
- 第9块：左边第一个比它高的柱子为第8块，高度为3；但是右边存在一个不比它矮的柱子为第11块，且高度相等，所以第9块与第11块的积水范围是同一范围，为了避免重复计算，可以把第9块的积水放在计算第11块的积水上
- 第10块：左边第一个比它的柱子为第9块，高度为2；右边第一个不比它矮的柱子为第11块，高度为2；所以可以积水`（(min(2, 2) - 1) * (11 - 9 - 1)）= 1`
- 第11块：右边不存在一个不比它矮的柱子，跳过

所以一共可以积水：1 + 1 + 3 + 1 = 6

代码：
```java
class Solution {
  public int trap(int[] height) {
    int[] res = rightFirstGreater(height);
    int[] resReverse = leftFirstGreater(height);
    int ans = 0;
    for (int i = 1; i < height.length - 1; i++) {
      if (res[i] != -1 && resReverse[i] != -1 && height[i] != height[res[i]]) {
        ans += (Math.min(height[res[i]], height[resReverse[i]]) - height[i]) * (res[i] - resReverse[i] - 1);
      }
    } 
    return ans;
  }

  int[] leftFirstGreater(int[] nums) {
    Stack<Integer> stack = new Stack();
    int[] res = new int[nums.length];
    for (int i = 0; i < nums.length; i++) {
      while (!stack.isEmpty() && nums[i] >= nums[stack.peek()]) {
        stack.pop(); 
      }
      res[i] = stack.isEmpty() ? -1 : stack.peek();
      stack.push(i);
    }
    return res;
  }

  int[] rightFirstGreater(int[] nums) {
    Stack<Integer> stack = new Stack();
    int[] res = new int[nums.length];
    for (int i = nums.length - 1; i >= 0; i--) {
      while (!stack.isEmpty() && nums[i] > nums[stack.peek()]) {
        stack.pop(); 
      }
      res[i] = stack.isEmpty() ? -1 : stack.peek();
      stack.push(i);
    }
    return res;
  } 

}
```

#### 例题5: 柱状图中最大的矩形
[柱状图中最大的矩形](https://leetcode.cn/problems/largest-rectangle-in-histogram/)

给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。

求在该柱状图中，能够勾勒出来的矩形的最大面积。

示例 1:

![](https://raw.githubusercontent.com/NaisWang/images/master/20220526152849.png)
```txt
输入：heights = [2,1,5,6,2,3]
输出：10
解释：最大的矩形为图中红色区域，面积为 10
```

代码:
```java
class Solution {
  public int largestRectangleArea(int[] heights) {
    int[] leftFirstLess = leftFirstLess(heights);
    int[] rightFirstLess = rightFirstLess(heights);
    int ans = Integer.MIN_VALUE;
    for (int i = 0; i < heights.length; i++) {
      int left = leftFirstLess[i] == -1 ? 0 : leftFirstLess[i] + 1;
      int right = rightFirstLess[i] == -1 ? heights.length - 1 : rightFirstLess[i] - 1;
      int width = right - left + 1; 
      ans = Math.max(ans, width * heights[i]); 
    }
    return ans;
  }

  int[] leftFirstLess(int[] nums) {
    Stack<Integer> stack = new Stack();
    int[] res = new int[nums.length];
    for (int i = 0; i < nums.length; i++) {
      while (!stack.isEmpty() && nums[i] <= nums[stack.peek()]) {
        stack.pop();
      }
      res[i] = stack.isEmpty() ? -1 : stack.peek();
      stack.push(i);
    }
    return res;
  }

  int[] rightFirstLess(int[] nums) {
    Stack<Integer> stack = new Stack();
    int[] res = new int[nums.length];
    for (int i = nums.length - 1; i >= 0; i--) {
      while (!stack.isEmpty() && nums[i] <= nums[stack.peek()]) {
        stack.pop();
      }
      res[i] = stack.isEmpty() ? -1 : stack.peek();
      stack.push(i);
    }
    return res;
  }
  
}
```

### 适用场景二
这种场景用下面几个例题来说明

#### 例题1: 移掉 K 位数字
给你一个以字符串表示的非负整数 num 和一个整数 k ，移除这个数中的 k 位数字，使得剩下的数字最小。请你以字符串形式返回这个最小的数字。

示例 1 ：
```txt
输入：num = "1432219", k = 3
输出："1219"
解释：移除掉三个数字 4, 3, 和 2 形成一个新的最小的数字 1219 。
```

示例 2 ：
```txt
输入：num = "10200", k = 1
输出："200"
解释：移掉首位的 1 剩下的数字为 200. 注意输出不能有任何前导零。
```

##### 分析

视频讲解:
<div class="container">
  <iframe width="560" height="315" src="https://www.youtube.com/embed/qWL2KS_Hxic" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>

```java
class Solution {
  public String removeKdigits(String num, int k) {
    Stack<Character> stack = new Stack();
    char[] numChar = num.toCharArray();
    for (int i = 0; i < numChar.length; i++) {
      while (!stack.isEmpty() && k >  0 && numChar[i] < stack.peek()) {
        stack.pop();
        k--;
      }
      stack.push(numChar[i]);
    }
    while (k != 0) {
      stack.pop();
      k--;
    }
    StringBuffer sb = new StringBuffer();
    while (!stack.isEmpty()) {
      sb.append(stack.pop());
    }
    for (int i = sb.length() - 1; i >= 0; i--) {
      if (sb.charAt(i) == '0') {
        sb.deleteCharAt(i);
      } else {
        break;
      }
    }
    if (sb.length() == 0) {
      return "0";
    }
    return sb.reverse().toString();
  }
}
```

#### 例题2: 去除重复字母
[去除重复字母](https://leetcode.cn/problems/remove-duplicate-letters/)

给你一个字符串 s ，请你去除字符串中重复的字母，使得每个字母只出现一次。需保证 返回结果的字典序最小（要求不能打乱其他字符的相对位置）。

示例 1：
```txt
输入：s = "bcabc"
输出："abc"
```

示例 2：
```txt
输入：s = "cbacdcbc"
输出："acdb"
```

##### 分析
视频讲解:
<div class="container">
  <iframe width="560" height="315" src="https://www.youtube.com/embed/QpZFxXa-hnE" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>

代码：
```java
class Solution {
  public String removeDuplicateLetters(String s) {
    HashMap<Character, Integer> map = new HashMap();
    char[] ch = s.toCharArray();
    for (int i = 0; i < ch.length; i++) {
      if (map.containsKey(ch[i])) {
        map.put(ch[i], map.get(ch[i]) + 1); 
      } else {
        map.put(ch[i], 1);
      }
    }
    Stack<Character> stack = new Stack();
    boolean[] visited = new boolean[26];
    for (int i = 0; i < ch.length; i++) {
      if (visited[ch[i] - 'a']) {
        map.put(ch[i], map.get(ch[i]) - 1);
        continue;
      }
      while (!stack.isEmpty() && map.get(stack.peek()) != 1 && ch[i] < stack.peek()) {
        map.put(stack.peek(), map.get(stack.peek()) - 1);
        visited[stack.peek() - 'a'] = false;
        stack.pop();
      }
      visited[ch[i] - 'a'] = true;
      stack.push(ch[i]);
    }
    
    StringBuffer sb = new StringBuffer();
    while (!stack.isEmpty()) {
      sb.append(stack.pop());
    }
    return sb.reverse().toString();

  }

}
```

## 队列
### 设计循环队列
例题： [设计循环队列](https://leetcode.cn/problems/design-circular-queue/)

设计你的循环队列实现。 循环队列是一种线性数据结构，其操作表现基于 FIFO（先进先出）原则并且队尾被连接在队首之后以形成一个循环。它也被称为“环形缓冲器”。

循环队列的一个好处是我们可以利用这个队列之前用过的空间。在一个普通队列里，一旦一个队列满了，我们就不能插入下一个元素，即使在队列前面仍有空间。但是使用循环队列，我们能使用这些空间去存储新的值。

你的实现应该支持如下操作：
- MyCircularQueue(k): 构造器，设置队列长度为 k 。
- Front: 从队首获取元素。如果队列为空，返回 -1 。
- Rear: 获取队尾元素。如果队列为空，返回 -1 。
- enQueue(value): 向循环队列插入一个元素。如果成功插入则返回真。
- deQueue(): 从循环队列中删除一个元素。如果成功删除则返回真。
- isEmpty(): 检查循环队列是否为空。
- isFull(): 检查循环队列是否已满。

示例：
```txt
MyCircularQueue circularQueue = new MyCircularQueue(3); // 设置长度为 3
circularQueue.enQueue(1);  // 返回 true
circularQueue.enQueue(2);  // 返回 true
circularQueue.enQueue(3);  // 返回 true
circularQueue.enQueue(4);  // 返回 false，队列已满
circularQueue.Rear();  // 返回 3
circularQueue.isFull();  // 返回 true
circularQueue.deQueue();  // 返回 true
circularQueue.enQueue(4);  // 返回 true
circularQueue.Rear();  // 返回 4
```

#### 分析

![](https://raw.githubusercontent.com/NaisWang/images/master/20220526221306.png)

该题难点在于如何设计循环队列初始时front与rear的指向以及如何判断队列为空或满

代码：
```java
class MyCircularQueue {
  Integer[] items;
  int head;
  int tail;
  int k;
  
  public MyCircularQueue(int k) {
    items = new Integer[k];
    head = 0;
    tail = 0;
    this.k = k;
  }
  
  public boolean enQueue(int value) {
    if (isFull()) return false;
    items[tail] = value;
    tail = (tail + 1) % k;
    return true;
  }
  
  public boolean deQueue() {
    if (isEmpty()) return false;
    items[head] = null;
    head = (head + 1) % k;
    return true;
  }
  
  public int Front() {
    if (isEmpty()) {
      return -1;
    }
    return items[head];
  }
  
  public int Rear() {
    if (isEmpty()) {
      return -1;
    }
    return items[(tail - 1 + k) % k]; 
  }
  
  public boolean isEmpty() {
    return head == tail && items[head] == null;
  }
  
  public boolean isFull() {
    return head == tail && items[head] != null;
  }
}
```

### 用队列实现栈
例题：[用队列实现栈](https://leetcode.cn/problems/implement-stack-using-queues/) 

分析：https://leetcode.cn/problems/implement-stack-using-queues/solution/yong-dui-lie-shi-xian-zhan-by-leetcode-solution/

代码：
```java
class MyStack {

  Deque<Integer> deque1;
  Deque<Integer> deque2;

  public MyStack() {
    deque1 = new LinkedList();
    deque2 = new LinkedList();
  }
  
  public void push(int x) {
    if (deque1.isEmpty()) {
      deque1.add(x);
      transfer(deque2, deque1);
    } else {
      deque2.add(x);
      transfer(deque1, deque2);
    }
  }
  
  private void transfer(Deque a, Deque b) {
    while (!a.isEmpty()) {
      b.add(a.poll());
    }
  }
  
  public int pop() {
    if (deque1.isEmpty()) {
      return deque2.poll();
    } 
    return deque1.poll();
  }
  
  public int top() {
    if (deque1.isEmpty()) {
      return deque2.peek();
    } 
    return deque1.peek();
  }
  
  public boolean empty() {
    return deque1.isEmpty() && deque2.isEmpty();
  }
}
```

## 单调队列
<div class="container">
  <iframe src="https://docs.google.com/document/d/e/2PACX-1vTXVQTof9bfXfioACZ9_UyYv4_JREankuTIlwD2Pz60geTts3dxM0aKiwRpkyyU4taXIkCW9gSTQI2O/pub?embedded=true"></iframe>
</div>
### 模版
```java
public int[] maxSlidingWindow(int[] nums, int k) {
  Deque<Integer> deque = new ArrayDeque();
  int[] res = new int[nums.length - k + 1];
  for (int i = 0; i < nums.length; i++) {
    // 窗口标识
    int startWindowIndex = i - k + 1;

    // 左出q，保证窗口大小为k-1
    while (!deque.isEmpty() && i - deque.peekFirst() >= k){
      deque.pollFirst();
    }

    // 右出q，保证为递增队列
    while (!deque.isEmpty() && nums[deque.peekLast()] <= nums[i]) {
      deque.pollLast();
    }

    // 进q，此时q.size == k
    deque.offerLast(i);

    // 此时q队首为此窗口的最大值
    if (startWindowIndex >= 0) res[startWindowIndex] = nums[deque.peekFirst()];
  }
  return res;
}
```

### 例题1: 滑动窗口最大值
[滑动窗口最大值](https://leetcode.cn/problems/sliding-window-maximum/)

给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。

返回 滑动窗口中的最大值 。

示例 1：
```txt
输入：nums = [1,3,-1,-3,5,3,6,7], k = 3
输出：[3,3,5,5,6,7]
解释：
滑动窗口的位置                最大值
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7
```

**代码：**
```java
class Solution {
  public int[] maxSlidingWindow(int[] nums, int k) {
    Deque<Integer> deque = new ArrayDeque();
    int[] res = new int[nums.length - k + 1];
    for (int i = 0; i < nums.length; i++) {
      int startWindowIndex = i - k + 1;
      while (!deque.isEmpty() && i - deque.peekFirst() >= k){
        deque.pollFirst();
      }
      while (!deque.isEmpty() && nums[deque.peekLast()] <= nums[i]) {
        deque.pollLast();
      }
      deque.offerLast(i);
      if (startWindowIndex >= 0) res[startWindowIndex] = nums[deque.peekFirst()];
    }
    return res;
  }
}
```

# 搜索技术
## 二分搜索
视频：
<div class="container">
  <iframe width="560" height="315" src="https://www.youtube.com/embed/Smu6LsYERJg" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>

<div class="container">
  <iframe width="560" height="315" src="https://www.youtube.com/embed/nrBMGE0KtzQ" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>

文字版：https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/solution/lan-hong-hua-fen-fa-dan-mo-ban-miao-sha-e7r40/

二分搜索有两种定义：
- 第一种：在一个有序的数组中折半查找一个数
- 第二种：在一个有序的`boolean function f(v)`中找到转折点
  - 有序的：表示$f(v_i) = true, i <= k 且 f(v_j) = false, j > k$
  - 转折点：假如$f(v_k) = true 且 f(v_(k+1)) = false$, 则$v_k$与$v_(k+1)$为转折点

例如: 假如`f(0)=f(1)=...=f(3)=true,f(4)=f(5)=..=f(7)=false`, 则此时`3`与`4`为转折点

| v    | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 |
|------|---|---|---|---|---|---|---|---|
| f(v) | T | T | T | T | F | F | F | F |

其实二分搜索的第一种定义就是第二种的定义的一种特殊情况

### 二分搜索模版
```java
// 初始化时left为列表的左边界-1，right为列表的右边界+1
int binarySearch(int left, int right) {
  while(left + 1 != right) {
    int mid = left + (right - left) / 2;
    if (f(mid) == true) {
      left = mid;
    } else if (f(mid) == false){
      right = mid;
    }
  }
  return left;
}
```

关键点：
- 无论什么时候，`f(left)`都是为true, `f(right)`都是为false
- 最后返回left还是right，看你是想要获取哪个转折点。据需求而定
- 要进行二分查找时，left的值为列表的左边界-1，right为列表的右边界+1

### 解题流程

![](https://raw.githubusercontent.com/NaisWang/images/master/20220520163540.png)

### 例题
#### 例题1: 猜数字大小
[猜数字大小](https://leetcode.cn/problems/guess-number-higher-or-lower/)

猜数字游戏的规则如下：

每轮游戏，我都会从 1 到 n 随机选择一个数字。 请你猜选出的是哪个数字。
如果你猜错了，我会告诉你，你猜测的数字比我选出的数字是大了还是小了。
你可以通过调用一个预先定义好的接口 int guess(int num) 来获取猜测结果，返回值一共有 3 种可能的情况（-1，1 或 0）：

- -1：我选出的数字比你猜的数字小 pick < num
- 1：我选出的数字比你猜的数字大 pick > num
- 0：我选出的数字和你猜的数字一样。恭喜！你猜对了！pick == num
返回我选出的数字。

示例 1：
```
输入：n = 10, pick = 6
输出：6
```

代码：
```java
/** 
 * Forward declaration of guess API.
 * @param  num   your guess
 * @return 	     -1 if num is lower than the guess number
 *			      1 if num is higher than the guess number
 *               otherwise return 0
 * int guess(int num);
 */
public class Solution extends GuessGame {
  public int guessNumber(int n) {
    return binarySearch(0, (long) n + 1);
  }
  
  int binarySearch(int left,  long right) {
    while((long)left + 1 != right) {
      int mid = left + (int)((right - left) / 2);
      if (guess(mid) == -1) {
        right = mid;
      } else if (guess(mid) == 1 || guess(mid) == 0){
        left = mid;
      }
    }
    return left;
  }
}

```

#### 例题2: x 的平方根
[x 的平方根 ](https://leetcode.cn/problems/sqrtx/)

给你一个非负整数 x ，计算并返回 x 的 算术平方根 。

由于返回类型是整数，结果只保留 整数部分 ，小数部分将被 舍去 。

注意：不允许使用任何内置指数函数和算符，例如 pow(x, 0.5) 或者 `x ** 0.5`。

示例 1：
```txt
输入：x = 4
输出：2
```

示例 2：
```txt
输入：x = 8
输出：2
解释：8 的算术平方根是 2.82842..., 由于返回类型是整数，小数部分将被舍去。
```

代码：
```java
class Solution {
    public int mySqrt(int x) {
        return binarySearch(-1, (long)x + 1, x);
    }
    
    int binarySearch(int left, long right, int x) {
        while ((long)left + 1 != right) {
            int mid = left + (int) ((right - left) / 2);
            if (f(mid, x)) {
                left = mid;
            } else {
                right = mid;
            }
        }
        return left;
    }
    
    boolean f(int index, int x) {
        if ((long)index * index <= x) {
            return true;
        }
        return false;
    }
}
```

#### 例题3: 第一个错误的版本
[第一个错误的版本](https://leetcode.cn/problems/first-bad-version/)

你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。

假设你有 n 个版本 [1, 2, ..., n]，你想找出导致之后所有版本出错的第一个错误的版本。

你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。

示例 1：
```txt
输入：n = 5, bad = 4
输出：4
解释：
调用 isBadVersion(3) -> false 
调用 isBadVersion(5) -> true 
调用 isBadVersion(4) -> true
所以，4 是第一个错误的版本。
```

示例 2：
```
输入：n = 1, bad = 1
输出：1
```

代码:
```java
/* The isBadVersion API is defined in the parent class VersionControl.
      boolean isBadVersion(int version); */

public class Solution extends VersionControl {
    public int firstBadVersion(int n) {
       return binarySearch(0, (long)n + 1);
    }

    int binarySearch(int left, long right) {
        while((long)left + 1 != right) {
            int mid = left + (int) ((right - left) / 2);
            if (isBadVersion(mid)) {
                right = mid;
            } else {
                left = mid;
            }
        }
        return (int)right;
    }
    
}
```

#### 例题4: 寻找旋转排序数组中的最小值
[寻找旋转排序数组中的最小值](https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/)

已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums = [0,1,2,4,5,6,7] 在变化后可能得到：
- 若旋转 4 次，则可以得到 [4,5,6,7,0,1,2]
- 若旋转 7 次，则可以得到 [0,1,2,4,5,6,7]
注意，数组 [a[0], a[1], a[2], ..., a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], ..., a[n-2]] 。

给你一个元素值 互不相同 的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。

你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。

示例 1：
```txt
输入：nums = [3,4,5,1,2]
输出：1
解释：原数组为 [1,2,3,4,5] ，旋转 3 次得到输入数组。
```

示例 2：
```txt
输入：nums = [4,5,6,7,0,1,2]
输出：0
解释：原数组为 [0,1,2,4,5,6,7] ，旋转 4 次得到输入数组。
```

示例 3：
```txt
输入：nums = [11,13,15,17]
输出：11
解释：原数组为 [11,13,15,17] ，旋转 4 次得到输入数组。
```

代码:
```java
class Solution {
  public int findMin(int[] nums) {
    int ansIndex = binarySearch(0, nums.length, nums);
    if (ansIndex == nums.length) {
      return nums[0];
    }
    return nums[ansIndex];
  }

  int binarySearch(int left, int right, int[] nums) {
    while (left + 1 != right) {
      int mid = left + (right - left) / 2;
      if (nums[mid] >= nums[0]) {
        left = mid;
      } else {
        right = mid;
      }
    }
    return right;
  }
}
```

#### 例题5: 寻找旋转排序数组中的最小值 II
[寻找旋转排序数组中的最小值 II](https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array-ii/)

已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums = [0,1,4,4,5,6,7] 在变化后可能得到：
- 若旋转 4 次，则可以得到 [4,5,6,7,0,1,4]
- 若旋转 7 次，则可以得到 [0,1,4,4,5,6,7]
注意，数组 [a[0], a[1], a[2], ..., a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], ..., a[n-2]] 。

给你一个可能存在 **重复** 元素值的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。

你必须尽可能减少整个过程的操作步骤。

示例 1：
```txt
输入：nums = [1,3,5]
输出：1
```

示例 2：
```txt
输入：nums = [2,2,2,0,1]
输出：0
```

代码：
```java
class Solution {
  public int findMin(int[] nums) {
    // 使其符合二分查找模版 
    int i = nums.length - 1;
    while (i > 0 && nums[i] == nums[0]) {
        nums[i--] = nums[0] - 1;
        if (i == 0) {
          return nums[0]; 
        }
    }
    if (nums[0] < nums[i]) {
      return nums[0];
    }
    int ansIndex = binarySearch(0, nums.length, nums);
    if (ansIndex == nums.length) {
      return nums[0];
    }
    return nums[ansIndex];
  }

  int binarySearch(int left, int right, int[] nums) {
    while (left + 1 != right) {
      int mid = left + (right - left) / 2;
      if (nums[mid] >= nums[0]) {
        left = mid;
      } else {
        right = mid;
      }
    }
    return right;
  }
 
}
```

#### 例题6: 在排序数组中查找元素的第一个和最后一个位置
[在排序数组中查找元素的第一个和最后一个位置](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/)

给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。

如果数组中不存在目标值 target，返回 [-1, -1]。

进阶：
- 你可以设计并实现时间复杂度为 O(log n) 的算法解决此问题吗？

示例 1：
```txt
输入：nums = [5,7,7,8,8,10], target = 8
输出：[3,4]
```

示例 2：
```txt
输入：nums = [5,7,7,8,8,10], target = 6
输出：[-1,-1]
```

示例 3：
```txt
输入：nums = [], target = 0
输出：[-1,-1]
```

代码:
```java
class Solution {
  public int[] searchRange(int[] nums, int target) {
    if (nums.length == 0) return new int[]{-1, -1};
    int left = binarySearch1(-1, nums.length, nums, target);
    if (left == nums.length || nums[left] != target) {
      left = -1; 
      return new int[]{-1, -1};
    }
    int right = binarySearch2(-1, nums.length, nums, target);
    return new int[]{left, right};
  }

  int binarySearch1(int left, int right, int[] nums, int target) {
    while (left + 1 != right) {
      int mid = left + (right - left) / 2;
      if (nums[mid] < target) {
        left = mid;
      } else {
        right = mid;
      }
    } 
    return right;
  }

  int binarySearch2(int left, int right, int[] nums, int target) {
    while (left + 1 != right) {
      int mid = left + (right - left) / 2;
      if (nums[mid] <= target) {
        left = mid;
      } else {
        right = mid;
      }
    } 
    return left;
  }
  
}
```

#### K-th object problems
K-th object problems问题可以归纳为：有一堆objects，让你找出将这些objects按其某属性A的值排序后的第k个object的属性值

这类问题的解题步骤：
1. 列出所有可能解：object的属性A的所有可能值
2. 找到boolean function f(v)能把所有可能解划分成2部分：这里function为，将这些objects排好序后，如果位于属性值v前面的object个数大于等于k个，则返回true，反之，返回false

##### 例题7: 乘法表中第k小的数
[乘法表中第k小的数](https://leetcode.cn/problems/kth-smallest-number-in-multiplication-table/)

<div class="container">
  <iframe width="560" height="315" src="https://www.youtube.com/embed/mUOuMmt5gEY" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>

几乎每一个人都用 乘法表。但是你能在乘法表中快速找到第k小的数字吗？

给定高度m 、宽度n 的一张 m * n的乘法表，以及正整数k，你需要返回表中第k 小的数字。

例 1：
```txt
输入: m = 3, n = 3, k = 5
输出: 3
解释: 
乘法表:
1	2	3
2	4	6
3	6	9

第5小的数字是 3 (1, 2, 2, 3, 3).
```

例 2：
```txt
输入: m = 2, n = 3, k = 6
输出: 6
解释: 
乘法表:
1	2	3
2	4	6

第6小的数字是 6 (1, 2, 2, 3, 4, 6).
```

###### 题目分析
1. 这一堆objects就是乘法表中元素
2. 属性：乘法表中元素的大小值
3. 所有可能解是`[1, m*n]`;
4. `boolean f(v)`是将objects按大小排好序后，如果大小小于value的个数大于等于k，则返回true，反之，返回false

代码：
```java
class Solution {
  public int findKthNumber(int m, int n, int k) {
    return binearySearch(0, m * n + 1, m, n, k);
  }

  // 如果矩阵中元素小于value的个数大于等于k，则返回true，反之，返回false
  boolean f(int m, int n, int k, int value) {
    int cnt = 0;
    for (int i = 1; i <= m; i++) {
      cnt += Math.min(value / i, n);
    }
    return cnt >= k;
  }

  int binearySearch(int left, int right, int m, int n, int k) {
    while (left + 1 != right) {
      int mid = left + (right - left) / 2;
      if (f(m, n, k, mid)) {
        right = mid;
      } else {
        left = mid;
      }
    }
    return right;
  }
}
```

##### 例题8: 第 N 个神奇数字
[第 N 个神奇数字](https://leetcode.cn/problems/nth-magical-number/)

<div class="container">
  <iframe width="560" height="315" src="https://www.youtube.com/embed/mwIge6NXAyQ" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>

一个正整数如果能被 a 或 b 整除，那么它是神奇的。

给定三个整数 n , a , b ，返回第 n 个神奇的数字。因为答案可能很大，所以返回答案 对 109 + 7 取模 后的值。

示例 1：
```txt
输入：n = 1, a = 2, b = 3
输出：2
```

示例 2：
```txt
输入：n = 4, a = 2, b = 3
输出：6
```

###### 题目分析
1. 这一堆objects就是a与b的神奇数字
2. 属性：神奇数字大小
3. 所有可能解是`[0, n * Math.min(a, b)]`;
4. `boolean f(v)`是将objects排好序后，如果大小小于value的个数大于等于k，则返回true，反之，返回false

代码：
```java
class Solution {
  public int nthMagicalNumber(int n, int a, int b) {
    return binarySearch(0, (long)n * Math.min(a, b), n, a, b);
  }
  
  int binarySearch(long left, long right, int n, int a, int b) {
    while (left + 1 != right) {
      long mid = left + (right - left) / 2;
      if (f(n, a, b, mid)) {
        right = mid;
      } else {
        left = mid;
      }
    }
    return (int)(right % (1e9 + 7));
  }

  // 如果a与b的神奇数字小于value的个数大于或等于n，则返回true，反之返回false
  boolean f(int n, int a, int b, long value) {
    return value / a + value / b - value / lcm(a, b) >= n;
  }

  int gcd(int a, int b) {
    if (a % b == 0) {
      return b;
    }
    return gcd(b, a % b);
  }
  
  int lcm(int a, int b) {
    return a * b / gcd(a, b);
  }
}
```

##### 例题9: 找出第 K 小的数对距离
[找出第 K 小的数对距离](https://leetcode.cn/problems/find-k-th-smallest-pair-distance/)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220603211022.png)

##### 分析

<div class="container">
  <iframe width="560" height="315" src="https://www.youtube.com/embed/2YtgPABdeHE" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>

代码：
```java
class Solution {
  int[] nums;
  public int smallestDistancePair(int[] nums, int k) {
    this.nums = nums;
    Arrays.sort(this.nums);
    int res = binearySearch(-1, 1000001, k);
    return res;
  }
  
  // 如果数组中对距离小于value的个数大于或等于k，则返回true，反之返回false
  boolean f(int value, int k) {
    int cnt = 0;
    int rloc = 0;
    for (int i = 0; i < nums.length; i++) {
      while (rloc < nums.length && nums[rloc] - nums[i] <= value) {
         rloc++;
      }
      cnt += rloc - i - 1;
    }
    return cnt >= k;
  }

  int binearySearch(int left, int right, int k) {
    while (left + 1 != right) {
      int mid = left + (right - left) / 2;
      if (f(mid, k)) {
        right = mid; 
      } else {
        left = mid;
      }
    }
    return right;
  }
  
}
```

##### 例题10: 有序矩阵中第 K 小的元素
[有序矩阵中第 K 小的元素](https://leetcode.cn/problems/kth-smallest-element-in-a-sorted-matrix/)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220604100441.png)

代码：
```java
class Solution {
  int[][] matrix;
  public int kthSmallest(int[][] matrix, int k) {
    this.matrix = matrix;
    return binearySearch((int)-1e9, (int)1e9+1, k);
  }

  boolean f(int value, int k) {
    int cnt = 0;
    for (int r = 0; r < matrix.length; r++) {
      for (int c = 0; c < matrix[0].length; c++) {
        if (matrix[r][c] > value) {
          break;
        }
        cnt++;
      }
    }
    return cnt >= k;
  }

  int binearySearch(int left, int right, int k) {
    while (left + 1 != right) {
      int mid = left + (right - left) / 2;
      if (f(mid, k)) {
        right = mid;
      } else {
        left = mid;
      }
    }
    return right;
  }

}
```

## 隐式图上的DFS和BFS算法

<div class="container">
  <iframe width="560" height="315" src="https://www.youtube.com/embed/g9SOQIKspaw" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>

<div class="container">
  <iframe width="560" height="315" src="https://www.youtube.com/embed/xdmyuHKsTYU" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>

<div class="container">
  <iframe src="https://drive.google.com/file/d/179HorlJSGlAwA-c-FV6b-JsYovjfpjb9/preview" width="640" height="480" allow="autoplay"></iframe>
</div>

### 模版

#### DFS模版
```java
/**
* visited: 用来存储被访问过的状态。如果允许状态是能够重复访问，则不需要创建visited变量
* path: 用来存储路径。如果不需要输出路径，则不需要创建path变量
* return: 是否可以到达目标状态
*/
boolean dfs(State currentState, Map<State, Boolean> visited, LinkedList<State> path) {
  visited.put(currentState, true);
  
  // 如果currentState是目标状态
  if (isObjective(currentState)) {
    // 可以在这里输出path
    return true;
  }

  // 获取当前状态可以转换到的所有下一个状态。此时不需要考虑这个状态是否能被添加到队列中
  List<State> nextStates = transition(currentState);

  for (State nextState : nextStates) {
    if (visited.containsKey(nextState)) continue;
    path.push(nextState);
    if (dfs(nextState, visited, path)){
      return true;
    }
    path.pop();
  }
  return false;
}
```

#### BFS模版
##### 模版1：求路径是否存在
```java
/**
* visited: 用来存储被访问过的状态。如果允许状态是能够重复访问，则不需要创建visited变量
* path: 用来存储路径。如果不需要输出路径，则不需要创建path变量
* return: 是否可以到达目标状态
*/
boolean bfs(State startState) {
  Queue<State> queue = new LinkedList();
  Map<State, Boolean> visited = new HashMap();
  Map<State, State> path = new HashMap();
  
  queue.add(startState);
  visited.put(startState, true);

  while (!queue.isEmpty()) {
    State currentState = queue.poll();
    // 如果currentState是目标状态
    if (isObjective(currentState)) {
      // 可以在这里输出path
      return visited.get(currentState);
    }

    // 获取当前状态可以转换到的所有下一个状态。此时不需要考虑这个状态是否能被添加到队列中
    List<State> nextStates = transition(currentState);

    for (State nextState : nextStates) {
      if (visited.containsKey(nextState)) continue;
      queue.add(nextState);
      visited.put(nextState, true);
      path.put(nextState, currentState); 
    }
  }
  return false;
}
```

##### 模版2：求最短路径
```java
/**
* visited: 用来存储被访问过的状态。如果允许状态是能够重复访问，则不需要创建visited变量
* path: 用来存储路径。如果不需要输出路径，则不需要创建path变量
*/
boolean bfs(State startState) {
  Queue<State> queue = new LinkedList();
  Map<State, Integer> visited = new HashMap();
  Map<State, State> path = new HashMap();
  
  queue.add(startState);
  visited.put(startState, true);

  while (!queue.isEmpty()) {
    State currentState = queue.poll();
    // 如果currentState是目标状态
    if (isObjective(currentState)) {
      // 可以在这里输出path
      return true;
    }

    // 获取当前状态可以转换到的所有下一个状态。此时不需要考虑下一个状态是否被访问过
    List<State> nextStates = transition(currentState);
    for (State nextState : nextStates) {
      if (visited.containsKey(nextState)) continue;
      queue.add(nextState);
      visited.put(nextState, visited.get(currentState) + 1);
      path.put(nextState, currentState); 
    }
  }
  return false;
}
```

###### visited妙用
用BFS求最短路径时visited不但可以用来存储被访问过的状态，还可以用来存储到达此状态的最短路径。见例题2: 完全平方数、例题4: 滑动谜题、例题5: 零钱兑换

### 总结
使用模版前，需要思考下面2点：
1. 是否允许状态被重复访问?
  - 允许，不需要创建visited。见例题3：N皇后 II
  - 不允许，需要创建visited
2. 是否要求出最短路径?
  - 是，只能使用BFS，也能使用DFS，但是DFS复杂度高，不推荐使用。见例题2: 完全平方数
  - 不是，既能使用BFS，也能使用DFS

### 例题
#### 例题1: 水壶问题
[水壶问题](https://leetcode.cn/problems/water-and-jug-problem/)

有两个水壶，容量分别为 jug1Capacity 和 jug2Capacity 升。水的供应是无限的。确定是否有可能使用这两个壶准确得到 targetCapacity 升。

如果可以得到 targetCapacity 升水，最后请用以上水壶中的一或两个来盛放取得的 targetCapacity 升水。

你可以：
- 装满任意一个水壶
- 清空任意一个水壶
- 从一个水壶向另外一个水壶倒水，直到装满或者倒空

示例 1: 
```txt
输入: jug1Capacity = 3, jug2Capacity = 5, targetCapacity = 4
输出: true
```

示例 2:
```
输入: jug1Capacity = 2, jug2Capacity = 6, targetCapacity = 5
输出: false
```

代码：
DFS实现
```java
class Solution {
  int jug1 = 0;
  int jug2 = 0;
  int target = 0;

  public boolean canMeasureWater(int jug1Capacity, int jug2Capacity, int targetCapacity) {
    jug1 = jug1Capacity;
    jug2 = jug2Capacity;
    target = targetCapacity;
    return dfs(new State(0, 0), new HashMap());
  }

  boolean dfs(State currentState, Map<State, Boolean> visited) {
    visited.put(currentState, true);

    if (currentState.x == target || 
    currentState.y == target || 
    currentState.x + currentState.y == target) {
      return true;
    }

    List<State> nextStates = transition(currentState);
    for (State nextState : nextStates) {
      if (visited.containsKey(nextState)) continue;
      if (dfs(nextState, visited)){
        return true;
      }
    }
    return false;
  }

  List<State> transition(State state) {
    List<State> res = new ArrayList();
    if (state.x < jug1) {
      res.add(new State(jug1, state.y)); // 把第一个壶倒满
    }
    if (state.y < jug2) {
      res.add(new State(state.x, jug2)); // 把第二个壶倒满
    }
    if (state.x > 0) {
      res.add(new State(0, state.y)); // 清空第一个壶
    }
    if (state.y > 0) {
      res.add(new State(state.x, 0)); // 清空第二个壶
    }
    if (state.x < jug1 && state.y > 0) {
      res.add(new State(Math.min(jug1, state.x + state.y), Math.max(0, state.y - (jug1 - state.x)))); // 将第二个壶中的水倒入第一个壶中
    }
    if (state.y < jug2 && state.x > 0) {
      res.add(new State(Math.max(0, state.x - (jug2 - state.y)), Math.min(jug2, state.y + state.x))); // 将第一个壶中的水倒入第二个壶中
    }
    return res;
  }

  class State {
    int x;
    int y;

    public State(int x, int y) {
      this.x = x; 
      this.y = y;
    }

    public boolean equals(Object o) {
      if (this == o) return true;
      if (o == null) return false;
      State a = (State) o;
      return x == a.x && y == a.y;
    }

    public int hashCode() {
      return Objects.hash(x, y);
    } 

  }

}
```

BFS实现
```java
class Solution {
  int jug1 = 0;
  int jug2 = 0;
  int target = 0;

  public boolean canMeasureWater(int jug1Capacity, int jug2Capacity, int targetCapacity) {
    jug1 = jug1Capacity;
    jug2 = jug2Capacity;
    target = targetCapacity;
    return bfs(new State(0, 0));
  }

  boolean bfs(State startState) {
    Queue<State> queue = new LinkedList();
    Map<State, Boolean> visited = new HashMap();
    Map<State, State> path = new HashMap();
    
    queue.add(startState);
    visited.put(startState, true);

    while (!queue.isEmpty()) {
      State currentState = queue.poll();
      if (currentState.x == target || 
        currentState.y == target || 
        currentState.x + currentState.y == target) {
      return true;
      }

      List<State> nextStates = transition(currentState);
      for (State nextState : nextStates) {
        if (visited.containsKey(nextState)) continue;
        queue.add(nextState);
        visited.put(nextState, true);
        path.put(nextState, currentState); 
      }
    }
    return false;

  }

  List<State> transition(State state) {
    List<State> res = new ArrayList();
    if (state.x < jug1) {
      res.add(new State(jug1, state.y)); // 把第一个壶倒满
    }
    if (state.y < jug2) {
      res.add(new State(state.x, jug2)); // 把第二个壶倒满
    }
    if (state.x > 0) {
      res.add(new State(0, state.y)); // 清空第一个壶
    }
    if (state.y > 0) {
      res.add(new State(state.x, 0)); // 清空第二个壶
    }
    if (state.x < jug1 && state.y > 0) {
      res.add(new State(Math.min(jug1, state.x + state.y), Math.max(0, state.y - (jug1 - state.x)))); // 将第二个壶中的水倒入第一个壶中
    }
    if (state.y < jug2 && state.x > 0) {
      res.add(new State(Math.max(0, state.x - (jug2 - state.y)), Math.min(jug2, state.y + state.x))); // 将第一个壶中的水倒入第二个壶中
    }
    return res;
  }

  class State {
    int x;
    int y;

    public State(int x, int y) {
      this.x = x; 
      this.y = y;
    }

    public boolean equals(Object o) {
      if (this == o) return true;
      if (o == null) return false;
      State a = (State) o;
      return x == a.x && y == a.y;
    }

    public int hashCode() {
      return Objects.hash(x, y);
    } 

  }

}
```

#### 例题2: 完全平方数

[完全平方数](https://leetcode.cn/problems/perfect-squares/)

给你一个整数 n ，返回 和为 n 的完全平方数的最少数量 。

完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。

示例 1：
```txt
输入：n = 12
输出：3 
解释：12 = 4 + 4 + 4
```

示例 2：
```txt
输入：n = 13
输出：2
解释：13 = 4 + 9
```

##### 分析
此题是最短路径问题，可以用BFS来做，但是不能用DFS来做

代码：
```java
class Solution {
  public int numSquares(int n) {
    return bfs(n);    
  }
  
  int bfs(Integer startState) {
    Queue<Integer> queue = new LinkedList(); 
    Map<Integer, Integer> visited = new HashMap(); // 技巧： 可以用visited表示是否被访问过，也过表示访问此状态所经过的步数

    queue.add(startState);
    visited.put(startState, 0);
    
    while(!queue.isEmpty()) {
      Integer currentState = queue.poll();
      if (currentState == 0) {
        return visited.get(currentState);
      }

      List<Integer> nextStates = new ArrayList();
      for (int i = 1; i * i <= currentState; i++) {
        nextStates.add(currentState - i * i); 
      }
      for (Integer nextState : nextStates) {
        if (visited.containsKey(nextState)) continue;;
        queue.add(nextState);
        visited.put(nextState, visited.get(currentState) + 1);
      }  
    }
    return -1;
  }
}
```


#### 例题3：N皇后 II
[N皇后 II](https://leetcode.cn/problems/n-queens-ii/)

n 皇后问题 研究的是如何将 n 个皇后放置在 n × n 的棋盘上，并且使皇后彼此之间不能相互攻击。

给你一个整数 n ，返回 n 皇后问题 不同的解决方案的数量。

示例 1：
```txt
输入：n = 4
输出：2
```

##### 分析
DFS代码：
```java
class Solution {

  int n; 
  int cnt = 0; 

  public int totalNQueens(int n) {
    this.n = n;
    dfs(new State(new int[9], 0));
    return cnt;
  }
  
  void dfs(State currentState) {
    if (currentState.nowRow == n) {
      cnt++;
      return;
    }

    List<State> nextStates = new ArrayList();
    for (int col = 0; col < n; col++) {
      boolean conflict = false;
      for (int row = 0; row < currentState.nowRow; row++) {
        if (col == currentState.preRows[row] || currentState.nowRow - row  == Math.abs(currentState.preRows[row] - col)) {
          conflict = true; 
          break;
        }
      }
      if (!conflict) {
        int[] temp =  Arrays.copyOf(currentState.preRows, n);
        temp[currentState.nowRow] = col; 
        nextStates.add(new State(temp,  currentState.nowRow + 1));
      }
    }
    
    for (State nextState : nextStates) {
      dfs(nextState);
    }

  }

  class State {
    int[] preRows; // 存放位于nowRow前面的每行中皇后所在列
    int nowRow; // 当前需要摆放皇后的行

    public State(int[] preRows, int nowRow) {
      this.preRows = preRows;
      this.nowRow = nowRow;
    }


    public boolean equals(Object o) {
      if (this == o) return true;
      if (o == null || getClass() != o.getClass()) return false;
      State state = (State) o;
      return nowRow == state.nowRow && Arrays.equals(preRows, state.preRows);
    }
  
    public int hashCode() {
      int result = Objects.hash(nowRow);
      result = 31 * result + Arrays.hashCode(preRows);
      return result;
    }
  }

}
```

BFS代码：
```java
class Solution {

  int n; 
  int cnt = 0; 

  public int totalNQueens(int n) {
    this.n = n;
    //dfs(new State(new int[9], 0));
    bfs(new State(new int[9], 0));
    return cnt;
  }

  void bfs(State startState) {
    Queue<State> queue = new LinkedList();
    queue.add(startState);

    while(!queue.isEmpty()) {
      State currentState = queue.poll();

      if (currentState.nowRow == n) {
        cnt++;
        continue;
      }

      List<State> nextStates = new ArrayList();
      for (int col = 0; col < n; col++) {
        boolean conflict = false;
        for (int row = 0; row < currentState.nowRow; row++) {
          if (col == currentState.preRows[row] || currentState.nowRow - row  == Math.abs(currentState.preRows[row] - col)) {
            conflict = true; 
            break;
          }
        }

        if (!conflict) {
          int[] temp =  Arrays.copyOf(currentState.preRows, n);
          temp[currentState.nowRow] = col; 
          nextStates.add(new State(temp,  currentState.nowRow + 1));
        }
      }

      for (State nextState : nextStates) {
        queue.add(nextState); 
      }
    }
  }

  class State {
    int[] preRows; // 存放位于nowRow前面的每行中皇后所在列
    int nowRow; // 当前需要摆放皇后的行

    public State(int[] preRows, int nowRow) {
      this.preRows = preRows;
      this.nowRow = nowRow;
    }


    public boolean equals(Object o) {
      if (this == o) return true;
      if (o == null || getClass() != o.getClass()) return false;
      State state = (State) o;
      return nowRow == state.nowRow && Arrays.equals(preRows, state.preRows);
    }
  
    public int hashCode() {
      int result = Objects.hash(nowRow);
      result = 31 * result + Arrays.hashCode(preRows);
      return result;
    }
  }

}
```

##### 判断棋盘中的两个点是否在同一斜线上
假如现在有两个点(x1, y1), (x2, y2); 则其两个在同一斜线上点充要条件是：$abs(x1 - x2) == abs(y1 - y2)$

#### 例题4: 滑动谜题
[滑动谜题](https://leetcode.cn/problems/sliding-puzzle/)

在一个 2 x 3 的板上（board）有 5 块砖瓦，用数字 1~5 来表示, 以及一块空缺用 0 来表示。一次 移动 定义为选择 0 与一个相邻的数字（上下左右）进行交换.

最终当板 board 的结果是 [[1,2,3],[4,5,0]] 谜板被解开。

给出一个谜板的初始状态 board ，返回最少可以通过多少次移动解开谜板，如果不能解开谜板，则返回 -1 。

#### 分析

代码:
```java
class Solution {

  public int slidingPuzzle(int[][] board) {
    return bfs(new State(board)); 
  }

  int bfs(State startState) {
    Queue<State> queue = new LinkedList();
    Map<State, Integer> visited = new HashMap();

    queue.add(startState);
    visited.put(startState, 0);

    while (!queue.isEmpty()) {
      State currentState = queue.poll();
      if (Arrays.deepEquals(currentState.board, new int[][]{ {1,2,3}, {4,5,0} })) {
        return visited.get(currentState);
      }

      List<State> nextStates = transition(currentState);
      for(State nextState : nextStates) {
        if (visited.containsKey(nextState)) continue;    
        queue.add(nextState);
        visited.put(nextState, visited.get(currentState) + 1);
      }
    }
    return -1;
  }

  List<State> transition(State currentState) {
    int[] now = currentState.now;
    int[][] board = currentState.board;
    List<State> res = new ArrayList();
    int[] dc = new int[]{0, 0, -1, 1};
    int[] dr = new int[]{-1, 1, 0, 0};
    for (int i = 0; i < 4; i++) {
      int nr = now[0] + dr[i];
      int nc = now[1] + dc[i];
      if (nr >= 0 && nr <= 1 && nc >= 0 && nc <= 2) {
        int[][] newBoard = new int[2][3];
        for (int j = 0; j < 2; j++) {
          newBoard[j] = Arrays.copyOf(board[j], 3);
        }
        newBoard[now[0]][now[1]] = newBoard[nr][nc];
        newBoard[nr][nc] = 0;
        res.add(new State(newBoard, new int[]{nr, nc}));
      }
    }
    return res;
  }

  class State {
    int[][] board = new int[2][3];
    int[] now; // 现在空缺块坐标

    public State(int[][] board, int[] now) {
      this.board = board;
      this.now = now;
    }

    public State(int[][] board) {
      this.board = board;
      for (int r = 0; r < 2; r++) {
        for (int c = 0; c < 3; c++) {
          if (board[r][c] == 0) {
            this.now = new int[]{r, c};
            return;
          }
        }
      }
    }

    @Override
    public boolean equals(Object o) {
      if (this == o) return true;
      if (o == null || getClass() != o.getClass()) return false;
      State state = (State) o;
      return Arrays.deepEquals(board, state.board) && Arrays.equals(now, state.now);
    }

    @Override
    public int hashCode() {
      int result = Arrays.deepHashCode(board);
      result = 31 * result + Arrays.hashCode(now);
      return result;
    }

  }
 
}
```

#### 例题5: 零钱兑换
[零钱兑换](https://leetcode.cn/problems/coin-change/)

给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。

计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。

你可以认为每种硬币的数量是无限的。

示例 1：
```txt
输入：coins = [1, 2, 5], amount = 11
输出：3 
解释：11 = 5 + 5 + 1
```

示例 2：
```txt
输入：coins = [2], amount = 3
输出：-1
```

代码：
```java
class Solution {
  int[] coins;

  public int coinChange(int[] coins, int amount) {
    this.coins = coins; 
    return bfs(amount); 
  }

  int bfs(int startState) {
    Queue<Integer> queue = new LinkedList();
    Map<Integer, Integer> visited = new HashMap();
    queue.add(startState);
    visited.put(startState, 0); 
    
    while(!queue.isEmpty()) {
      Integer currentState = queue.poll();
      if (currentState == 0) {
        return visited.get(currentState);
      }

      List<Integer> nextStates = new ArrayList(); 
      for (int coin : coins) {
        int temp = currentState - coin;
        if (temp >= 0) {
          nextStates.add(temp); 
        }
      }
      for (Integer nextState : nextStates) {
        if (visited.containsKey(nextState)) continue;
        queue.add(nextState);
        visited.put(nextState, visited.get(currentState) + 1);
      } 
    }
    return -1;
  }
}
```

#### 例题6: 跳跃游戏 III
[跳跃游戏 III](https://leetcode.cn/problems/jump-game-iii/)

这里有一个非负整数数组 arr，你最开始位于该数组的起始下标 start 处。当你位于下标 i 处时，你可以跳到 i + arr[i] 或者 i - arr[i]。

请你判断自己是否能够跳到对应元素值为 0 的 任一 下标处。

注意，不管是什么情况下，你都无法跳到数组之外。

示例 1：
```txt
输入：arr = [4,2,3,0,3,1,2], start = 5
输出：true
解释：
到达值为 0 的下标 3 有以下可能方案： 
下标 5 -> 下标 4 -> 下标 1 -> 下标 3 
下标 5 -> 下标 6 -> 下标 4 -> 下标 1 -> 下标 3 
```

示例 2：
```txt
输入：arr = [4,2,3,0,3,1,2], start = 0
输出：true 
解释：
到达值为 0 的下标 3 有以下可能方案： 
下标 0 -> 下标 4 -> 下标 1 -> 下标 3
```

##### 分析
BFS代码：
```java
class Solution {
  int[] arr;

  public boolean canReach(int[] arr, int start) {
    this.arr = arr;
    return bfs(start); 
  }

  boolean bfs(Integer startState) {
    Queue<Integer> queue = new LinkedList();
    Map<Integer, Boolean> visited = new HashMap();
    
    queue.add(startState);
    visited.put(startState, true); 

    while (!queue.isEmpty()) {
      Integer currentState = queue.poll();
      if (arr[currentState] == 0) {
        return true; 
      }

      List<Integer> nextStates = new ArrayList();  
      for (int i : new int[]{currentState + arr[currentState], currentState - arr[currentState]}) {
        if (i < arr.length && i >= 0) {
          nextStates.add(i);
        }
      }

      for (Integer nextState : nextStates) {
        if (visited.containsKey(nextState)) continue;
        queue.add(nextState);
        visited.put(nextState, true);
      }
    }
    return false;
  }
}
```

DFS代码：
```java
class Solution {
  int[] arr;
  int start;

  public boolean canReach(int[] arr, int start) {
    this.arr = arr;
    return dfs(start, new HashMap()); 
  }

  boolean dfs(Integer currentState, Map<Integer, Boolean> visited) {
    visited.put(currentState, true);
    
    if (arr[currentState] == 0) {
      return true;
    }

    List<Integer> nextStates = new ArrayList();  
    for (int i : new int[]{currentState + arr[currentState], currentState - arr[currentState]}) {
      if (i < arr.length && i >= 0) {
        nextStates.add(i);
      }
    }

    for (Integer nextState : nextStates) {
      if (nextState >= arr.length || nextState < 0 || visited.containsKey(nextState)) continue;
      if (dfs(nextState, visited)) {
        return true;
      }
    }
    return false;
  }
}
```

#### 例题7: 被围绕的区域
[被围绕的区域](https://leetcode.cn/problems/surrounded-regions/)

给你一个 m x n 的矩阵 board ，由若干字符 'X' 和 'O' ，找到所有被 'X' 围绕的区域，并将这些区域里所有的 'O' 用 'X' 填充。

##### 分析
BFS代码：
```java
class Solution {

  int row;
  int col;
  int[] dr = new int[]{-1, 1, 0, 0};
	int[] dc = new int[]{0, 0, -1, 1};
  char[][] board;
  Map<State, Boolean> visited = new HashMap();
  List<State> change = new LinkedList();
  List<State> tempChange = new LinkedList();
  boolean flag = true; // 用来标记当前连通块是否被‘x’围绕
  
  public void solve(char[][] board) {
    this.board = board;
    row = board.length;
    col = board[0].length;
    for (int r = 0; r < row; r++) {
      for (int c = 0; c < col; c++) {
        State state = new State(new int[]{r, c});
        if (board[r][c] == 'O' && !visited.containsKey(state)) {
          tempChange = new LinkedList();
          flag = true;
          bfs(state);
          if (flag) {
            change.addAll(tempChange);
          }
        }
      }
    } 

    for (State state : change) {
      board[state.coor[0]][state.coor[1]] = 'X';
    }

  }
  
  void bfs(State startState) {
    Queue<State> queue = new LinkedList();
    queue.add(startState); 
    visited.put(startState, true);
    tempChange.add(startState);

    while (!queue.isEmpty()) {
      State currentState = queue.poll();

      List<State> nextStates = new ArrayList();
      for (int i = 0; i < 4; i++) {
        int nr = currentState.coor[0] + dr[i];
        int nc = currentState.coor[1] + dc[i];
        if (nr < 0 || nr >= row || nc < 0 || nc >= col) {
          flag = false;  // 当前连通块没有被‘x’围绕
        } else if (board[nr][nc] == 'O'){
          nextStates.add(new State(new int[]{nr, nc}));
        }
      }
      for (State nextState : nextStates) {
        if (visited.containsKey(nextState)) continue;
        queue.add(nextState);
        visited.put(nextState, true);
        tempChange.add(nextState);
      }
    }

  }

  class State {
    int[] coor;

    public State(int[] coor) {
      this.coor = coor;
    }

    @Override
    public boolean equals(Object o) {
      if (this == o) return true;
      if (o == null || getClass() != o.getClass()) return false;
      State state = (State) o;
      return Arrays.equals(coor, state.coor);
    }

    @Override
    public int hashCode() {
      return Arrays.hashCode(coor);
    }
  }

}
```

DFS代码：
```java
class Solution {

  int row;
  int col;
  int[] dr = new int[]{-1, 1, 0, 0};
	int[] dc = new int[]{0, 0, -1, 1};
  char[][] board;
  Map<State, Boolean> visited = new HashMap();
  List<State> change = new LinkedList();
  List<State> tempChange = new LinkedList();
  boolean flag = true; // 用来标记当前连通块是否被‘x’围绕
  
  public void solve(char[][] board) {
    this.board = board;
    row = board.length;
    col = board[0].length;
    for (int r = 0; r < row; r++) {
      for (int c = 0; c < col; c++) {
        State state = new State(new int[]{r, c});
        if (board[r][c] == 'O' && !visited.containsKey(state)) {
          tempChange = new LinkedList();
          flag = true;
          dfs(state);
          if (flag) {
            change.addAll(tempChange);
          }
        }
      }
    } 

    for (State state : change) {
      board[state.coor[0]][state.coor[1]] = 'X';
    }

  }
  

  void dfs(State currentState) {
    visited.put(currentState, true);
    tempChange.add(currentState);

    List<State> nextStates = new ArrayList();
    for (int i = 0; i < 4; i++) {
      int nr = currentState.coor[0] + dr[i];
      int nc = currentState.coor[1] + dc[i];
      if (nr < 0 || nr >= row || nc < 0 || nc >= col) {
        flag = false;  // 当前连通块没有被‘x’围绕
      } else if (board[nr][nc] == 'O'){
        nextStates.add(new State(new int[]{nr, nc}));
      }
    }

    for (State nextState : nextStates) {
      if (visited.containsKey(nextState)) continue;
      dfs(nextState);
    }
  }
  
  class State {
    int[] coor;

    public State(int[] coor) {
      this.coor = coor;
    }

    @Override
    public boolean equals(Object o) {
      if (this == o) return true;
      if (o == null || getClass() != o.getClass()) return false;
      State state = (State) o;
      return Arrays.equals(coor, state.coor);
    }

    @Override
    public int hashCode() {
      return Arrays.hashCode(coor);
    }
  }

}
```





# 图论

<div class="container">
  <iframe src="https://drive.google.com/file/d/1tR9QKcnBXvdVaQQOByffi8BKGjrXuxIA/preview" width="640" height="480" allow="autoplay"></iframe>
</div>

<div class="container">
  <iframe width="560" height="315" src="https://www.youtube.com/embed/OBEHTlAdUrI" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>

<div class="container">
  <iframe width="560" height="315" src="https://www.youtube.com/embed/w89GTZApgIs" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>

## 图的逻辑结构和具体实现
### 邻接表与邻接矩阵
参考：
- https://labuladong.gitee.io/algo/2/20/47/

---

一幅图是由节点和边构成的，逻辑结构如下：

![](https://raw.githubusercontent.com/NaisWang/images/master/20220531152018.png)


**什么叫「逻辑结构」？就是说为了方便研究，我们把图抽象成这个样子。**

根据这个逻辑结构，我们可以认为每个节点的实现如下：
```java
/* 图节点的逻辑结构 */
class Vertex {
    int id;
    Vertex[] neighbors;
}
```

看到这个实现，你有没有很熟悉？它和我们之前说的多叉树节点几乎完全一样：
```java
/* 基本的 N 叉树节点 */
class TreeNode {
    int val;
    TreeNode[] children;
}
```

所以说，图真的没啥高深的，本质上就是个高级点的多叉树而已，适用于树的 DFS/BFS 遍历算法，全部适用于图。

不过呢，上面的这种实现是「逻辑上的」，实际上我们很少用这个`Vertex`类实现图，而是用常说的邻接表和邻接矩阵来实现。

比如还是刚才那幅图：

![](https://raw.githubusercontent.com/NaisWang/images/master/20220531152313.png)

用邻接表和邻接矩阵的存储方式如下：

![](https://raw.githubusercontent.com/NaisWang/images/master/20220531152338.png)

邻接表很直观，我把每个节点`x`的邻居都存到一个列表里，然后把`x`和这个列表关联起来，这样就可以通过一个节点`x`找到它的所有相邻节点。

邻接矩阵则是一个二维布尔数组，我们权且称为`matrix`，如果节点`x` 和 `y` 是相连的，那么就把 `matrix[x][y]` 设为 `true`（上图中绿色的方格代表 `true`）。如果想找节点 `x` 的邻居，去扫一圈 `matrix[x][..]` 就行了。

如果用代码的形式来表现，邻接表和邻接矩阵大概长这样：

```java
// 邻接表
// graph[x] 存储节点x 的所有邻居节点
List<Integer>[] graph;

// 邻接矩阵
// matrix[x][y] 记录节点x 是否有一条指向 y 的边
boolean[][] matrix;
```

**那么，为什么有这两种存储图的方式呢？肯定是因为他们各有优劣。**

对于邻接表，好处是占用的空间少。

你看邻接矩阵里面空着那么多位置，肯定需要更多的存储空间。

但是，邻接表无法快速判断两个节点是否相邻。

比如说我想判断节点 1 是否和节点 3 相邻，我要去邻接表里 1 对应的邻居列表里查找 3 是否存在。但对于邻接矩阵就简单了，只要看看 `matrix[1][3]` 就知道了，效率高。

所以说，使用哪一种方式实现图，要看具体情况。

> PS：在常规的算法题中，邻接表的使用会更频繁一些，主要是因为操作起来较为简单，但这不意味着邻接矩阵应该被轻视。矩阵是一个强有力的数学工具，图的一些隐晦性质可以借助精妙的矩阵运算展现出来。不过本文不准备引入数学内容，所以有兴趣的读者可以自行搜索学习。

那你可能会问，我们上面说的这个图的模型仅仅是「有向无权图」，不是还有什么加权图，无向图，等等……

其实，这些更复杂的模型都是基于这个最简单的图衍生出来的。

有向加权图怎么实现？很简单呀：

如果是邻接表，我们不仅仅存储某个节点 x 的所有邻居节点，还存储 x 到每个邻居的权重，不就实现加权有向图了吗？

如果是邻接矩阵，`matrix[x][y]` 不再是布尔值，而是一个 int 值，0 表示没有连接，其他值表示权重，不就变成加权有向图了吗？

如果用代码的形式来表现，大概长这样：

```java
// 邻接表
// graph[x] 存储节点x 的所有邻居节点以及对应的权重
// from -> List<(to, weight)>
// graph[from].add(new int[]{to, weight}); 
List<int[]>[] graph;

// 邻接矩阵
// matrix[x][y] 记录 x 指向 y 的边的权重，0 表示不相邻
int[][] matrix;
```

无向图怎么实现？也很简单，所谓的「无向」，是不是等同于「双向」？

![](https://raw.githubusercontent.com/NaisWang/images/master/20220531152900.png)

如果连接无向图中的节点 x 和 y，把`matrix[x][y]`和`matrix[y][x]` 都变成 true 不就行了；邻接表也是类似的操作，在 x 的邻居列表里添加 y，同时在 y 的邻居列表里添加 x。

把上面的技巧合起来，就变成了无向加权图

### 边集数组
边集数组由两个一维数组构成：
- 一个存储顶点信息。
- 一个存储边的信息，这个边数组每个数据元素由一条边的起点下标（begin）、终点下标（end）、和权（weight）组成。

![](https://raw.githubusercontent.com/NaisWang/images/master/20220602095849.png)

实现方式：
```java
int[][] edges =  { {0,1,100}, {1,2,100}, {0,2,500} }
```

```java
Edge[] edges = new ArrayList();
edges.add(new Edge(0, 1, 100));
edges.add(new Edge(1, 2, 100));
edges.add(new Edge(0, 2, 500));

class Edge {
  int begin, end, weight;

  Edge(int begin, int end, int weight) {
    begin = begin;
    end = end;
    weight = weight;
  }
}
```

边集数组适用场景：
- 边集数组关注的是边的集合，在边集数组中要查找一个顶点的度需要扫描整个边数组，效率并不高。
- 因此它更适合对边依次进行处理的操作，而不适合对顶点相关的操作。

例如： Bellman-Ford算法中使用了边集数组来存储图

### 链式前向星

<div class="container">
  <iframe width="560" height="315" src="https://www.youtube.com/embed/CrQSuA9JibU" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>

<div class="container">
  <iframe width="560" height="315" src="https://www.youtube.com/embed/fNPI5UQeJjU" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>

<div class="container">
  <iframe src="https://docs.google.com/document/d/e/2PACX-1vSE5-XNTFLefwz5oVJlJh21f_K5cGuikjhPQghcZZgmxqQV0GktdWsjTq3FhD3Ib8bABMLkv8awhsMb/pub?embedded=true"></iframe>
</div>

## 无向图的连通性
### 静态图的算法 -- DFS/BFS
#### BFS实现模版
```java
int findComponents() {
  // key表示节点/状态，value表示该节点/状态所属于的连通分支。
  // 该components可以作为visited使用, 即当componets.containsKey(i) == false时，表示i节点没有被访问，反之，则被访问了
  Map<State, Integer> components = new HashMap<>();

  // 现在所求的连通分支标识
  int currentComponent = 0;

  // 遍历每个节点/状态
  for (State state : States) {
    if (!components.containsKey(state)) {
      bfs(state, components, currentComponent++);
    }
  }
  return currentComponent;
}

void bfs(State startState, Map<State, Integer> components, Integer currentComponent) {
  Queue<State> queue = new LinkedList();

  queue.add(startState);
  components.put(startState, currentComponent);

  while (!queue.isEmpty()) {
    State currentState = queue.poll();

    // 获取当前状态可以转换到的所有下一个状态。此时不需要考虑这个状态是否能被添加到队列中
    List<State> nextStates = transition(currentState);

    for (State nextState : nextStates) {
      if (components.containsKey(nextState)) continue;
      queue.add(nextState);
      components.put(nextState, currentComponent);
    }
  }
}

class State {

}
```

#### DFS实现模版
```java
int findComponents() {
  // key表示节点/状态，value表示该节点/状态所属于的连通分支。
  // 该components可以作为visited使用, 即当componets.containsKey(i) == false时，表示i节点没有被访问，反之，则被访问了
  Map<State, Integer> components = new HashMap<>();

  // 现在所求的连通分支标识
  int currentComponent = 0;

  // 遍历每个节点/状态
  for (State state : States) {
    if (!components.containsKey(state)) {
      bfs(state, components, currentComponent++);
    }
  }
  return currentComponent;
}

void dfs(State startState, Map<State, Integer> components, Integer currentComponent) {
  components.put(startState, currentComponent);

  // 获取当前状态可以转换到的所有下一个状态。此时不需要考虑这个状态是否能被添加到队列中
  List<State> nextStates = transition(currentState);

  for (State nextState : nextStates) {
    if (components.containsKey(nextState)) continue;
    dfs(nextState, components, currentComponent);
  }
}

class State {

}
```

#### 例题1: 省份数量
[省份数量](https://leetcode.cn/problems/number-of-provinces/)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220605223032.png)

BFS代码：
```java
class Solution {
  int[][] isConnected;
  public int findCircleNum(int[][] isConnected) {
    this.isConnected = isConnected; 
    return findComponents();
  }

  int findComponents() {
    Map<Integer, Integer> components = new HashMap(); 
    
    int currentComponent = 0;
    
    for (int i = 0; i < isConnected.length; i++) {
      if (!components.containsKey(i)) {
        bfs(i, components, currentComponent++);
      }
    }
    return currentComponent;
  }

  void bfs(Integer startState, Map<Integer, Integer> components, Integer currentComponent) {
    Queue<Integer> queue = new LinkedList();

    queue.add(startState);
    components.put(startState, currentComponent);

    while (!queue.isEmpty()) {
      Integer currentState = queue.poll();

      List<Integer> nextStates = new ArrayList();
      for (int i = 0; i < isConnected.length; i++) {
        if (isConnected[currentState][i] == 1) {
          nextStates.add(i);
        }
      }

      for (Integer nextState : nextStates) {
        if (components.containsKey(nextState)) continue;
        queue.add(nextState);
        components.put(nextState, currentComponent);
      }
      
    }
  }
}
```

DFS代码:
```java
class Solution {
  int[][] isConnected;

  public int findCircleNum(int[][] isConnected) {
    this.isConnected = isConnected; 
    return findComponents();
  }

  int findComponents() {
    Map<Integer, Integer> components = new HashMap(); 
    
    int currentComponent = 0;
    
    for (int i = 0; i < isConnected.length; i++) {
      if (!components.containsKey(i)) {
        dfs(i, components, currentComponent++);
      }
    }
    return currentComponent;
  }

  void dfs(Integer currentState, Map<Integer, Integer> components, Integer currentComponent) {
    components.put(currentState, currentComponent);

    List<Integer> nextStates = new ArrayList();
    for (int i = 0; i < isConnected.length; i++) {
      if (isConnected[currentState][i] == 1) {
        nextStates.add(i);
      }
    }

    for (Integer nextState : nextStates) {
      if (components.containsKey(nextState)) continue;
      dfs(nextState, components, currentComponent);
    }

  }
}
```

#### 例题2: 岛屿数量
[岛屿数量](https://leetcode.cn/problems/number-of-islands/)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220605230048.png)

BFS代码:
```java
class Solution {
  
  char[][] grid;

  public int numIslands(char[][] grid) {
    this.grid = grid;
    return findComponents();
  }

  int findComponents() {
    // key表示节点/状态，value表示该节点/状态所属于的连通分支。
    // 该components可以作为visited使用, 即当componets.containsKey(i) == false时，表示i节点没有被访问，反之，则被访问了
    Map<State, Integer> components = new HashMap<>();
  
    // 现在所求的连通分支标识
    int currentComponent = 0;
  
    // 遍历每个节点/状态
    for (int r = 0; r < grid.length; r++) {
      for (int c = 0; c < grid[0].length; c++) {
        if (grid[r][c] == '1') {
          State state = new State(r, c);  
          if (!components.containsKey(state)) {
            bfs(state, components, currentComponent++);
          }
        }
      }
    }
    return currentComponent;
  }
  
  void bfs(State startState, Map<State, Integer> components, Integer currentComponent) {
    Queue<State> queue = new LinkedList();
  
    queue.add(startState);
    components.put(startState, currentComponent);
  
    while (!queue.isEmpty()) {
      State currentState = queue.poll();
  
      // 获取当前状态可以转换到的所有下一个状态。此时不需要考虑这个状态是否能被添加到队列中
      List<State> nextStates = new ArrayList();
      int[] dr = new int[]{-1, 1, 0, 0};
      int[] dc = new int[]{0, 0, -1, 1};
      for (int i = 0; i < 4; i++) {
        int nr = currentState.row + dr[i];
        int nc = currentState.col + dc[i];
        if (nr >= 0 && nr < grid.length && nc >= 0 && nc < grid[0].length && grid[nr][nc] == '1') {
          nextStates.add(new State(nr, nc));
        }
      }
  
      for (State nextState : nextStates) {
        if (components.containsKey(nextState)) continue;
        queue.add(nextState);
        components.put(nextState, currentComponent);
      }
    }
  }

  class State {
    int row;
    int col;

    public State(int row, int col) {
      this.row = row;
      this.col = col;
    }

    @Override
    public boolean equals(Object o) {
      if (this == o) return true;
      if (o == null || getClass() != o.getClass()) return false;
      State state = (State) o;
      return row == state.row && col == state.col;
    }

    @Override
    public int hashCode() {
      return Objects.hash(row, col);
    }
  }
}
```

DFS代码：
```java
class Solution {
  
  char[][] grid;

  public int numIslands(char[][] grid) {
    this.grid = grid;
    return findComponents();
  }

  int findComponents() {
    // key表示节点/状态，value表示该节点/状态所属于的连通分支。
    // 该components可以作为visited使用, 即当componets.containsKey(i) == false时，表示i节点没有被访问，反之，则被访问了
    Map<State, Integer> components = new HashMap<>();
  
    // 现在所求的连通分支标识
    int currentComponent = 0;
  
    // 遍历每个节点/状态
    for (int r = 0; r < grid.length; r++) {
      for (int c = 0; c < grid[0].length; c++) {
        if (grid[r][c] == '1') {
          State state = new State(r, c);  
          if (!components.containsKey(state)) {
            dfs(state, components, currentComponent++);
          }
        }
      }
    }
    return currentComponent;
  }
  
  void dfs(State currentState, Map<State, Integer> components, Integer currentComponent) {
    components.put(currentState, currentComponent);
  
    // 获取当前状态可以转换到的所有下一个状态。此时不需要考虑这个状态是否能被添加到队列中
    List<State> nextStates = new ArrayList();
    int[] dr = new int[]{-1, 1, 0, 0};
    int[] dc = new int[]{0, 0, -1, 1};
    for (int i = 0; i < 4; i++) {
      int nr = currentState.row + dr[i];
      int nc = currentState.col + dc[i];
      if (nr >= 0 && nr < grid.length && nc >= 0 && nc < grid[0].length && grid[nr][nc] == '1') {
        nextStates.add(new State(nr, nc));
      }
    }
  
    for (State nextState : nextStates) {
      if (components.containsKey(nextState)) continue;
      dfs(nextState, components, currentComponent);
    }
  }

  class State {
    int row;
    int col;

    public State(int row, int col) {
      this.row = row;
      this.col = col;
    }

    @Override
    public boolean equals(Object o) {
      if (this == o) return true;
      if (o == null || getClass() != o.getClass()) return false;
      State state = (State) o;
      return row == state.row && col == state.col;
    }

    @Override
    public int hashCode() {
      return Objects.hash(row, col);
    }
  }
}
```


### 动态(递增)图的算法 - 并查集
#### 没有权值的并查集
##### 模版
```java
class DisjointSet {
  int[] parent;
  // 连通分量的个数
  int cnt;

  public DisjointSet(int n) {
    cnt = n;
    // 初始化parent
    parent = new int[n];
    for (int i = 0; i < n; i++) {
      parent[i] = i;
    }
  }

  // 查找x属于哪个连通分支
  int findParent(int x) {
    if (x == parent[x]) {
      return x; 
    } 
    parent[x] = findParent(parent[x]);
    return parent[x];
  }

  // 合并2个连通分支
  void unionSets(int a, int b) {
    a = findParent(a);
    b = findParent(b);
    if (a != b) {
      parent[a] = b;
      cnt--;
    }
  }
}
``` 


##### 例题1: 等式方程的可满足性
[等式方程的可满足性](https://leetcode.cn/problems/satisfiability-of-equality-equations/)

给定一个由表示变量之间关系的字符串方程组成的数组，每个字符串方程 equations[i] 的长度为 4，并采用两种不同的形式之一："a==b" 或 "a!=b"。在这里，a 和 b 是小写字母（不一定不同），表示单字母变量名。

只有当可以将整数分配给变量名，以便满足所有给定的方程时才返回 true，否则返回 false。 

示例 1：
```txt
输入：["a==b","b!=a"]
输出：false
解释：如果我们指定，a = 1 且 b = 1，那么可以满足第一个方程，但无法满足第二个方程。没有办法分配变量同时满足这两个方程。
```

示例 2：
```txt
输入：["b==a","a==b"]
输出：true
解释：我们可以指定 a = 1 且 b = 1 以满足满足这两个方程。
```

示例 3：
```txt
输入：["a==b","b==c","a==c"]
输出：true
```

###### 分析
- "a==b"可以看成a与b属于同一分支
- "a!=b"可以看成a与b不属于同一分支

如果一个等式中"a==b", "a!=b", 则表明a与b属于同一分支, 也不属于同一分支。这显然是矛盾的

代码：
```java
class Solution {

  public boolean equationsPossible(String[] equations) {
    DisjointSet disjointSet = new DisjointSet(26);
    for (String equation : equations) {
      if (equation.charAt(1) == '=') {
        disjointSet.unionSets(equation.charAt(0) - 'a', equation.charAt(3) - 'a');
      }
    }

    for (String equation : equations) {
      if (equation.charAt(1) == '!') {
        if (disjointSet.findParent(equation.charAt(0) - 'a') == disjointSet.findParent(equation.charAt(3)- 'a')) return false;
      }
    }
    return true;
  }

  class DisjointSet {
    int[] parent;

    public DisjointSet(int n) {
      parent = new int[n];
      for (int i = 0; i < n; i++) {
        parent[i] = i;
      }
    }

    int findParent(int x) {
      if (x == parent[x]) {
        return x; 
      } 
      parent[x] = findParent(parent[x]);
      return parent[x];
    }
  
    void unionSets(int a, int b) {
      a = findParent(a);
      b = findParent(b);
      if (a != b) {
        parent[a] = b;
      }
    }
  }

}
```

##### 例题2: 连通网络的操作次数
[连通网络的操作次数](https://leetcode.cn/problems/number-of-operations-to-make-network-connected/)

用以太网线缆将 n 台计算机连接成一个网络，计算机的编号从 0 到 n-1。线缆用 connections 表示，其中 connections[i] = [a, b] 连接了计算机 a 和 b。

网络中的任何一台计算机都可以通过网络直接或者间接访问同一个网络中其他任意一台计算机。

给你这个计算机网络的初始布线 connections，你可以拔开任意两台直连计算机之间的线缆，并用它连接一对未直连的计算机。请你计算并返回使所有计算机都连通所需的最少操作次数。如果不可能，则返回 -1 。

示例 1：
![](https://raw.githubusercontent.com/NaisWang/images/master/20220528101836.png)

输入：n = 6, connections = [[0,1],[0,2],[0,3],[1,2],[1,3]]
输出：2

###### 分析
将m个连通分支相连至少需要m-1个边

代码:
```java
class Solution {
  public int makeConnected(int n, int[][] connections) {
    DisjointSet disjointSet = new DisjointSet(n);
    // 多余的缆线个数
    int redundant = 0;
    // 存储已经每个节点位于哪个连通分支中
    for (int i = 0; i < connections.length; i++) {
      int a =  connections[i][0];
      int b =  connections[i][1];
      if (disjointSet.findParent(a) == disjointSet.findParent(b)) {
        redundant++;
      } else {
        disjointSet.unionSets(a, b);
      }
    }
    // 查看连通分支的个数
    int componentNum = 0;
    for (int i = 0; i < n; i++) {
      if (disjointSet.parent[i] == i) componentNum++;
    }

    // 将m个连通分支相连至少需要m-1个边
    if (redundant >= componentNum - 1) {
      return componentNum - 1;
    }
    return -1;
  }

  class DisjointSet {
    int[] parent;

    public DisjointSet(int n) {
      parent = new int[n];
      for (int i = 0; i < n; i++) {
        parent[i] = i;
      }
    }

    int findParent(int x) {
      if (x == parent[x]) {
        return x; 
      } 
      parent[x] = findParent(parent[x]);
      return parent[x];
    }
  
    void unionSets(int a, int b) {
      a = findParent(a);
      b = findParent(b);
      if (a != b) {
        parent[a] = b;
      }
    }
  }

}
```

##### 例题3: 交换字符串中的元素
[交换字符串中的元素](https://leetcode.cn/problems/smallest-string-with-swaps/)

给你一个字符串 s，以及该字符串中的一些「索引对」数组 pairs，其中 pairs[i] = [a, b] 表示字符串中的两个索引（编号从 0 开始）。

你可以 任意多次交换 在 pairs 中任意一对索引处的字符。

返回在经过若干次交换后，s 可以变成的按字典序最小的字符串。

示例 1:
```txt
输入：s = "dcab", pairs = [[0,3],[1,2]]
输出："bacd"
解释： 
交换 s[0] 和 s[3], s = "bcad"
交换 s[1] 和 s[2], s = "bacd"
```

###### 分析

参考：https://leetcode.cn/problems/smallest-string-with-swaps/solution/1202-jiao-huan-zi-fu-chuan-zhong-de-yuan-wgab/

<div class="container">
  <iframe width="560" height="315" src="https://www.youtube.com/embed/f4I4FGDFKRc" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>

代码：
```java
class Solution {
  public String smallestStringWithSwaps(String s, List<List<Integer>> pairs) {
    DisjointSet disjointSet = new DisjointSet(s.length());
    
    // 将任意能交换的节点纳入一个连通分支中
    for (List<Integer> pair : pairs) {
      disjointSet.unionSets(pair.get(0), pair.get(1));
    }

    // 构建映射关系
    char[] charArray = s.toCharArray();
    // key：连通分支代表元。value：同一连通分支中的字符集合，保存在一个优先队列中
    Map<Integer, PriorityQueue<Character>> map = new HashMap();
    for (int i = 0; i < s.length(); i++) {
      int root = disjointSet.findParent(i);
      if (map.containsKey(root)) {
        map.get(root).offer(charArray[i]);
      } else {
        PriorityQueue<Character> minHeap = new PriorityQueue();
        minHeap.offer(charArray[i]);
        map.put(root, minHeap);
      }
    }

    // 重组字符串
    StringBuffer sb = new StringBuffer();
    for (int i = 0; i < s.length(); i++) {
      int root = disjointSet.findParent(i);
      sb.append(map.get(root).poll());
    }
    return sb.toString();
  }

  class DisjointSet {
    int[] parent;
    
    public DisjointSet(int n) {
      parent = new int[n];
      for (int i = 0; i < n; i++) {
        parent[i] = i;
      }
    }

    int findParent(int x) {
      if (x == parent[x]) {
        return x;
      }
      parent[x] = findParent(parent[x]);
      return parent[x];
    }

    void unionSets(int a, int b) {
      a = findParent(a);
      b = findParent(b);
      if (a != b) {
        parent[a] = b;
      }
    }

  }

}
```
##### 例题4: 由斜杠划分区域
[由斜杠划分区域](https://leetcode.cn/problems/regions-cut-by-slashes/)

在由 1 x 1 方格组成的 n x n 网格 grid 中，每个 1 x 1 方块由 `'/'`、`'\'` 或空格构成。这些字符会将方块划分为一些共边的区域。

给定网格 grid 表示为一个字符串数组，返回 区域的数量 。

请注意，反斜杠字符是转义的，因此 `'\'` 用 `'\\'` 表示。

###### 分析
文字讲解：https://leetcode.cn/problems/regions-cut-by-slashes/solution/you-xie-gang-hua-fen-qu-yu-by-leetcode-67xb/

<div class="container">
  <iframe width="560" height="315" src="https://www.youtube.com/embed/1XptDhgm4KE" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>

代码：
```java
class Solution {
  public int regionsBySlashes(String[] grid) {
    int n = grid.length;
    DisjointSet disjointSet = new DisjointSet(4 * n * n);
    
    for (int r = 0; r < n; r++) {
      char[] rowStr = grid[r].toCharArray();
      for (int c = 0; c < n; c++) {
        int index = 4 * (n * r + c);

        // 单元格内合并
        if (rowStr[c] == '/'){
          // 合并0, 3 
          disjoinkSet.unionSets(index, index + 3); 
          // 合并1, 2
          disjointSet.unionSets(index + 1, index + 2); 
        } else if (rowStr[c] == '\\') {
          // 合并0， 1
          disjointSet.unionSets(index, index + 1);
          // 合并2， 3
          disjointSet.unionSets(index + 2, index + 3);
        } else {
          // 合并0,1,2,3
          disjointSet.unionSets(index, index + 1);
          disjointSet.unionSets(index + 1, index + 2);
          disjointSet.unionSets(index + 2, index + 3);
        }
        
        // 单元格间合并
        // 合并1， 3  
        if (c + 1 < n) {
          disjointSet.unionSets(index + 1, index + 4 + 3);
        }
        // 合并2, 0
        if (r + 1 <n) {
          disjointSet.unionSets(index + 2, 4 * (n * (r + 1) + c)); 
        }
        
      }
    }
    return disjointSet.cnt;
  }

  class DisjointSet {
    int[] parent;
    int cnt;
    
    public DisjointSet(int n) {
      cnt = n;
      parent = new int[n];
      for (int i = 0; i < n; i++) {
        parent[i] = i;
      }
    }

    int findParent(int x) {
      if (x == parent[x]) {
        return x;
      }
      return parent[x] = findParent(parent[x]);
    }
    
    void unionSets(int a, int b) {
      a = findParent(a);
      b = findParent(b);
      if (a != b) {
        parent[a] = b;
        cnt--;
      }
    }
  }
}
```

#### 有权值的并查集
##### 模版
```java
class DisjointSet {
  int[] parent;
  // weight[x]表示节点x指向父节点的权值
  double[] weight;
  // 连通分量的个数
  int cnt;

  public DisjointSet(int n) {
    cnt = n;
    parent = new int[n];
    weight = new double[n];
    for (int i = 0; i < n; i++) {
      parent[i] = i;
      // 权值初始化, 如何初始化，根据情况而定
      weight[i] = 1;
    }
  }

  int findParent(int x) {
    if (x == parent[x]) {
      return x;
    } 
    // 保存节点x没有进行路径压缩时的父节点。这样做是为了方便后续获取父节点的weight来更新节点x的weight
    int origin = parent[x];
    parent[x] = findParent(parent[x]);
    // 更新weight[x], 具体如何更新，根据情况而定
    weight[x] *= weight[origin];
    return parent[x];
  }

  void unionSets(int a, int b, double value) {
    int rootA = findParent(a);
    int rootB = findParent(b);
    
    if (rootA != rootB) {
      parent[rootA] = rootB;
      // 更新weight[rootA], 具体如何更新，根据情况而定
      weight[rootA] = value * weight[b] / weight[a];
      cnt--;
    }
  }
}
```

##### 例题1: 除法求值

[除法求值](https://leetcode.cn/problems/evaluate-division/)

给你一个变量对数组 equations 和一个实数值数组 values 作为已知条件，其中 $equations[i] = [A_i, B_i]$ 和 values[i] 共同表示等式 $A_i / B_i = values[i]$ 。每个 $A_i$ 或 $B_i$ 是一个表示单个变量的字符串。

另有一些以数组 queries 表示的问题，其中 $queries[j] = [C_j, D_j]$ 表示第 j 个问题，请你根据已知条件找出 $C_j / D_j = ?$ 的结果作为答案。

返回 所有问题的答案 。如果存在某个无法确定的答案，则用 -1.0 替代这个答案。如果问题中出现了给定的已知条件中没有出现的字符串，也需要用 -1.0 替代这个答案。

注意：输入总是有效的。你可以假设除法运算中不会出现除数为 0 的情况，且不存在任何矛盾的结果。

示例 1：
```txt
输入：equations = [["a","b"],["b","c"]], values = [2.0,3.0], queries = [["a","c"],["b","a"],["a","e"],["a","a"],["x","x"]]
输出：[6.00000,0.50000,-1.00000,1.00000,-1.00000]
解释：
条件：a / b = 2.0, b / c = 3.0
问题：a / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ?
结果：[6.0, 0.5, -1.0, 1.0, -1.0 ]
```

###### 分析
文字解释： https://leetcode.cn/problems/evaluate-division/solution/399-chu-fa-qiu-zhi-nan-du-zhong-deng-286-w45d/

<div class="container">
  <iframe width="560" height="315" src="https://www.youtube.com/embed/948WwjXili4" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>


代码：
```java
class Solution {
  public double[] calcEquation(List<List<String>> equations, double[] values, List<List<String>> queries) {

    DisjointSet disjointSet = new DisjointSet(equations.size() * 2);
    // 第 1 步：预处理，将变量的值与 id 进行映射，使得并查集的底层使用数组实现，方便编码
    Map<String, Integer> map = new HashMap();
    int id = 0;
    for (int i = 0; i < equations.size(); i++) {
      List<String> equation = equations.get(i);
      String a = equation.get(0);
      String b = equation.get(1);
      if (!map.containsKey(a)) {
        map.put(a, id++); 
      }
      if (!map.containsKey(b)) {
        map.put(b, id++); 
      }
      disjointSet.unionSets(map.get(a), map.get(b), values[i]);
    }
    
    // 第 2 步：做查询 
    double[] res = new double[queries.size()];
    for (int i = 0; i < queries.size(); i++) {
      List<String> querie = queries.get(i);
      String c = querie.get(0);
      String d = querie.get(1);
      Integer cId = map.get(c);
      Integer dId = map.get(d);
      if (cId == null || dId == null) {
        res[i] = -1; 
        continue;
      }
      if (disjointSet.findParent(cId) != disjointSet.findParent(dId)) {
        res[i] = -1;
        continue;
      }
      res[i] = disjointSet.weight[cId] / disjointSet.weight[dId];
    }
    return res;
  }

  class DisjointSet {
    int[] parent;
    // 指向的父结点的权值
    double[] weight;

    public DisjointSet(int n) {
      parent = new int[n];
      weight = new double[n];
      for (int i = 0; i < n; i++) {
        parent[i] = i;
        weight[i] = 1;
      }
    }

    int findParent(int x) {
      if (x == parent[x]) {
        return x;
      } 
      int origin = parent[x];
      parent[x] = findParent(parent[x]);
      weight[x] *= weight[origin];
      return parent[x];
    }

    void unionSets(int a, int b, double value) {
      int rootA = findParent(a);
      int rootB = findParent(b);
      
      if (rootA != rootB) {
        parent[rootA] = rootB;
        weight[rootA] = value * weight[b] / weight[a];
      }
    }
  }

}
```

#### 初始化时节点总数不确定的并查集
当初始化时节点总数不确定或者是可能被选择的节点个数太多时，例如可能被选中的节点编号为1~100000，但是需要用到的节点个数只有500个，远小于100000个。此时用`int[] parent`就显得不合适，因为我们需要开辟长度100000的数组。为了提高效率，我们可以使用`Map<Integer, Integer> parent`来存储，key为节点编号；value为该节点的父节点。

模版：
```java
class DisjointSet {
  // key：节点编号；value：该节点的父节点
  Map<Integer, Integer> parent;
  // 连通分量的个数
  int cnt;
  
  public DisjointSet() {
    parent = new HashMap();
    // 刚初始化话时，parent中节点个数为0，所以连通分量个数为0
    cnt = 0;
  }

  int findParent(int x) {
    // 如果parent没有统计当前节点x, 则将节点x添加到parent中，节点x的父节点为它自己。此时连通分量个数加1
    if (!parent.containsKey(x)) {
      parent.put(x, x);
      cnt++;
    }

    if (x == parent.get(x)) {
      return x;
    }
    parent.put(x, findParent(parent.get(x)));
    return parent.get(x);
  }

  void unionSets(int a, int b) {
    a = findParent(a);
    b = findParent(b);
    if (a != b) {
      parent.put(a, b);
      // 连通分量个数减1
      cnt--;
    }
  }
}
```

##### 例题1: 移除最多的同行或同列石头
[移除最多的同行或同列石头](https://leetcode.cn/problems/most-stones-removed-with-same-row-or-column/)

n 块石头放置在二维平面中的一些整数坐标点上。每个坐标点上最多只能有一块石头。

如果一块石头的 同行或者同列 上有其他石头存在，那么就可以移除这块石头。

给你一个长度为 n 的数组 stones ，其中 $stones[i] = [x_i, y_i]$ 表示第 i 块石头的位置，返回 可以移除的石子 的最大数量。

示例 1：
```txt
输入：stones = [[0,0],[0,1],[1,0],[1,2],[2,1],[2,2]]
输出：5
解释：一种移除 5 块石头的方法如下所示：
1. 移除石头 [2,2] ，因为它和 [2,1] 同行。
2. 移除石头 [2,1] ，因为它和 [0,1] 同列。
3. 移除石头 [1,2] ，因为它和 [1,0] 同行。
4. 移除石头 [1,0] ，因为它和 [0,0] 同列。
5. 移除石头 [0,1] ，因为它和 [0,0] 同行。
石头 [0,0] 不能移除，因为它没有与另一块石头同行/列。
```

###### 分析
文字解析：https://leetcode.cn/problems/most-stones-removed-with-same-row-or-column/solution/947-yi-chu-zui-duo-de-tong-xing-huo-tong-ezha/

<div class="container">
  <iframe width="560" height="315" src="https://www.youtube.com/embed/ZvY-1X0gN2I" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>

代码：
```java
class Solution {
  public int removeStones(int[][] stones) {
    int stonesLength = stones.length;
    DisjointSet disjointSet = new DisjointSet();
    for (int i = 0; i < stonesLength; i++) {
      disjointSet.unionSets(stones[i][0] + 10001, stones[i][1]);
    }
    return stonesLength - disjointSet.cnt;
  }
  
  class DisjointSet {
    // key：节点；value：该节点的父节点
    Map<Integer, Integer> parent;
    int cnt;
    
    public DisjointSet() {
      parent = new HashMap();
      cnt = 0;
    }

    int findParent(int x) {
      // 如果parent没有统计当前节点x
      if (!parent.containsKey(x)) {
        parent.put(x, x);
        cnt++;
        return x;
      }
      if (x == parent.get(x)) {
        return x;
      }
      parent.put(x, findParent(parent.get(x)));
      return parent.get(x);
    }

    void unionSets(int a, int b) {
      a = findParent(a);
      b = findParent(b);
      if (a != b) {
        parent.put(a, b);
        cnt--;
      }
    }
  }
}
```

## 最短路径算法
### 最短路径中的松弛技术
松弛(relaxation):指对于图 G = (V, E) 中 每个顶点v ∈ V，都设置一个属性dist[v]，用来描述从源点s到v的最短路径上权值的上界。

在开始进行一个最短路径算法时,只知道图中边和权值.随着算法的进行,逐渐得到各对顶点的最短路径的信息.算法会逐渐更新这些信息,每步都会检查是否可以找到一条路径比当前给定路径更短.这一过程通常称为松弛.

下面这两张图即为对边`<u, v>`的松弛操作, 即尝试能否通过 `<u, v>`, 对迄今为止找到的 v 的最短路径进行改进.在这里源点为点 S, 用 dist[i] 表示点 i 到源点 S 的最短路径,现对于边权为 60 的边 `<u, v>`进行松弛操作,如第一副图所示,现到顶点 v, u的最短路径分别为 100 和 30, 即 dist[v] = 100,那么 `dist[v] > dist[u] + W<u, v>`, 所以对于 dist[v] 需要更新,则 S 到 v 的最短路径为 S 到 u 的最短路径经过`<u, v>`到 v, 即 `dist[u] = dist[v] + W<u, v> = 90`.

![](https://raw.githubusercontent.com/NaisWang/images/master/20220602115627.png)

写成伪代码:
```java
Relax( u,  v,  W<u, v> ) { //W<u, v>代表边<u, v> 的权值
    if ( dist[v] > dist[u] + W<u, v> ) {
        dist[v] = dist[u] + W<u, v>;
    }
}
```

- Dijkstra是通过遍历**顶点**来进行松弛操作
- Bellman-Ford是通过遍历**边**来进行松弛操作

### 单源最短路径
#### Dijkstra算法
参考：
- https://zhuanlan.zhihu.com/p/409121513

<div class="container">
  <iframe width="560" height="315" src="https://www.youtube.com/embed/VRQL664Oesk" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>

---

首先，我们先看一下 Dijkstra 算法的签名：
```java
// 输入一幅图和一个起点 start，计算 start 到其他节点的最短距离
int[] dijkstra(int start, int[] path, List<int[]>[] graph);
```
输入是一幅图 graph 和一个起点 start，返回是一个记录最短路径权重的数组。

比方说，输入起点 start = 3，函数返回一个`int[]`数组，假设赋值给`distTo`变量，那么从起点 3 到节点 6 的最短路径权重的值就是 `distTo[6]`。

是的，标准的 Dijkstra 算法会把从起点 start 到所有其他节点的最短路径都算出来。

当然，如果你的需求只是计算从起点 start 到某一个终点 end 的最短路径，那么在标准 Dijkstra 算法上稍作修改就可以更高效地完成这个需求，这个我们后面再说。

其次，我们也需要一个 State 类来辅助算法的运行：
```java
class State {
    // 图节点的 id
    int id;
    // 从 start 节点到当前节点的距离
    int distFromStart;

    State(int id, int distFromStart) {
        this.id = id;
        this.distFromStart = distFromStart;
    }
}
```

类似刚才二叉树的层序遍历，我们也需要用 State 类记录一些额外信息，也就是使用 distFromStart 变量记录从起点 start 到当前这个节点的距离。

刚才说普通 BFS 算法中，根据 BFS 的逻辑和无权图的特点，第一次遇到某个节点所走的步数就是最短距离，所以用一个 visited 数组防止走回头路，每个节点只会经过一次。

加权图中的 Dijkstra 算法和无权图中的普通 BFS 算法不同，在 Dijkstra 算法中，你第一次经过某个节点时的路径权重，不见得就是最小的，所以对于同一个节点，我们可能会经过多次，而且每次的 distFromStart 可能都不一样，比如下图：

![](https://raw.githubusercontent.com/NaisWang/images/master/20220601134025.png)

我会经过节点 5 三次，每次的 distFromStart 值都不一样，那我取 distFromStart 最小的那次，不就是从起点 start 到节点 5 的最短路径权重了么？

<font color="red">Dijkstra的核心思想就是贪心，即每次从队列中找到dist最小的点，即为从起点到该点的最短路径长度。</font>所以我们在不知道是否能使用Dijkstra时，可以判断一下这个贪心策略是否成立，如果成立，则可以使用Dijkstra。

而Dijkstra的贪心过程可以使用BFS（优先队列版）来实现
- 元素出队：由于是优先队列，所以出队的元素是当前队列中最优先的元素。由于这个元素的id可能出过队列，即这个元素的id是已经确定好了最短路径。对于这种情况，我们是不做任何处理的。我们可能通过判断State.distFromStart 是否大于 dist[State.id]来判断是否为这种情况，如果大于，则是这种情况。
- 元素入队：没确定一个节点的最短路径后，都需要更新这个节点相邻的节点的dist值, 而这个更新是通过创建一个新的State,并将该State入队来实现的。

##### 时间复杂度分析
Dijkstra 算法的时间复杂度是多少？你去网上查，可能会告诉你是 `O(ElogV)`，其中 E 代表图中边的条数，V 代表图中节点的个数。

因为理想情况下优先级队列中最多装 V 个节点，对优先级队列的操作次数和 E 成正比，所以整体的时间复杂度就是 `O(ElogV)`。

不过这是理想情况，Dijkstra 算法的代码实现有很多版本，不同编程语言或者不同数据结构 API 都会导致算法的时间复杂度发生一些改变。

比如本文实现的 Dijkstra 算法，使用了 Java 的 PriorityQueue 这个数据结构，这个容器类底层使用二叉堆实现，但没有提供通过索引操作队列中元素的 API，所以队列中会有重复的节点，最多可能有 E 个节点存在队列中。

所以本文实现的 Dijkstra 算法复杂度并不是理想情况下的 `O(ElogV)`，而是 `O(ElogE)`，可能会略大一些，因为图中边的条数一般是大于节点的个数的。

不过就对数函数来说，就算真数大一些，对数函数的结果也大不了多少，所以这个算法实现的实际运行效率也是很高的，以上只是理论层面的时间复杂度分析，供大家参考。

##### 模版1: 需求到达其他所有点的最短路径
```java
/**
* startState: 开始状态
* graph: 图的表示方式，这里是使用的带有的权值的邻接表的表示方式
*/
int[] dijkstra(State startState,  List<int[]>[] graph) {
  // 优先队列，distFromStart较小的排在前面
  Queue<State> pq = new PriorityQueue<>((a, b) -> {
    return a.distFromStart - b.distFromStart;
  });

  // 初始化dist
  // dist[i] 的值就是节点 start 到达节点 i 的最短路径权重
  int[] dist = new int[graph.length];
  // 起始点到各点的最短路径长度为Integer.MAX_VALUE
  Arrays.fill(dist, Integer.MAX_VALUE);
  // 节点start 到节点start的最短路径为0 
  dist[startState.id] = 0;

  // 用来标记节点是否已经被选择
  boolean[] isSelected = new boolean[graph.length];

  // 从起点start开始进bfs
  pq.add(startState);

  while (!pq.isEmpty()) {
    State currentState = pq.poll();
    
    if (isSelected[currentState.id]) {
      continue;
    }
    isSelected[currentState.id] = true;

    // 获取currentState相邻节点
    List<State> nextStates = new ArrayList();
    for (int[] neighbor : graph[currentState.id]) {
      int nextNodeID = neighbor[0];
      int distToNextNode = dist[currentState.id] + neighbor[1];
      nextStates.add(new State(nextNodeID, distToNextNode));
    }
     
    for (State nextState : nextStates) {
      if (isSelected[nextState.id]) continue;
      if (dist[nextState.id] > nextState.distFromStart) {
        dist[nextState.id] = nextState.distFromStart;
        pq.add(nextState);
      }
    }
  }
  
  return dist;
}

// 辅助类, 用于优先队列
class State {
    // 图节点的 id
    int id;
    // 从 start 节点到当前节点的距离
    int distFromStart;

    State(int id, int distFromStart) {
        this.id = id;
        this.distFromStart = distFromStart;
    }
}
```

###### 例题1: 网络延迟时间
[网络延迟时间](https://leetcode.cn/problems/network-delay-time/)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220601134440.png)

让你求所有节点都收到信号的时间，你把所谓的传递时间看做距离，实际上就是问你「从节点 k 到其他所有节点的最短路径中，最长的那条最短路径距离是多少」，说白了就是让你算从节点 k 出发到其他所有节点的最短路径，就是标准的 Dijkstra 算法。

在用 Dijkstra 之前，别忘了要满足一些条件，加权有向图，没有负权重边，OK，可以用 Dijkstra 算法计算最短路径。

根据我们之前 Dijkstra 算法的框架，我们可以写出下面代码：

代码：
```java
class Solution {
  public int networkDelayTime(int[][] times, int n, int k) {
    // 构造图。节点编号是从1开始的，所以要一个大小为n + 1的邻接表
    List<int[]>[] graph = new LinkedList[n + 1];
    for (int i = 1; i <= n; i++) {
      graph[i] = new LinkedList();
    }
    for (int[] edge : times) {
      int from = edge[0];
      int to = edge[1];
      int weight = edge[2];
      // from -> List<(to, weight)>
      // 邻接表存储图结构，同时存储权重信息
      graph[from].add(new int[]{to, weight});
    }

    // 启动 dijkstra 算法计算以节点 k 为起点到其他节点的最短路径
    int[] dist = dijkstra(new State(k, 0), graph);

    // 找到最长的那一条最短路径
    int res = 0;
    for (int i = 1; i < dist.length; i++) {
      if (dist[i] == Integer.MAX_VALUE) {
        // 有节点不可达，返回-1
        return -1;
      }
      res = Math.max(res, dist[i]);
    }
    return res;
  }
  
  int[] dijkstra(State startState,  List<int[]>[] graph) {
    // 优先队列，distFromStart较小的排在前面
    Queue<State> pq = new PriorityQueue<>((a, b) -> {
      return a.distFromStart - b.distFromStart;
    });

    // 初始化dist
    // dist[i] 的值就是节点 start 到达节点 i 的最短路径权重
    int[] dist = new int[graph.length];
    // 起始点到各点的最短路径长度为Integer.MAX_VALUE
    Arrays.fill(dist, Integer.MAX_VALUE);
    // 节点start 到节点start的最短路径为0 
    dist[startState.id] = 0;

    // 用来标记节点是否已经被选择
    boolean[] isSelected = new boolean[graph.length];

    // 从起点start开始进bfs
    pq.add(startState);

    while (!pq.isEmpty()) {
      State currentState = pq.poll();

      if (isSelected[currentState.id]) {
        continue;
      }
      isSelected[currentState.id] = true;

      // 获取currentState相邻节点
      List<State> nextStates = new ArrayList();
      for (int[] neighbor : graph[currentState.id]) {
        int nextNodeID = neighbor[0];
        int distToNextNode = dist[currentState.id] + neighbor[1];
        nextStates.add(new State(nextNodeID, distToNextNode));
      }
       
      for (State nextState : nextStates) {
        if (isSelected[nextState.id]) continue;
        if (dist[nextState.id] > nextState.distFromStart) {
          dist[nextState.id] = nextState.distFromStart;
          pq.add(nextState);
        }
      }
    }
    
    return dist;
  }

  // 辅助类, 用于优先队列
  class State {
      // 图节点的 id
      int id;
      // 从 start 节点到当前节点的距离
      int distFromStart;
  
      State(int id, int distFromStart) {
          this.id = id;
          this.distFromStart = distFromStart;
      }
  }
}
```

###### 例题2: 阈值距离内邻居最少的城市
[阈值距离内邻居最少的城市](https://leetcode.cn/problems/find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance/)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220602201121.png)

对每个点进行Dijkstra

代码：
```java
class Solution {
  public int findTheCity(int n, int[][] edges, int distanceThreshold) {
    List<int[]>[] graph = new ArrayList[n];
    for (int i = 0; i < n; i++) {
      graph[i] = new ArrayList();
    }
    for (int i = 0; i < edges.length; i++) {
      graph[edges[i][0]].add(new int[]{edges[i][1], edges[i][2]});
      graph[edges[i][1]].add(new int[]{edges[i][0], edges[i][2]});
    }
    int res = 0;
    int minCnt = Integer.MAX_VALUE;
    for (int i = 0; i < n; i++) {
      int[] dist = dijkstra(new State(i, 0), graph);
      int cnt = 0;
      for (int j = 0; j < n; j++) {
        if (dist[j] <= distanceThreshold) {
          cnt++;
        }
      }
      if (cnt != 0 && minCnt >= cnt) {
        res = i;
        minCnt = cnt;
      }
    }
    return res;
  }

  int[] dijkstra(State startState, List<int[]>[] graph) {
    Queue<State> pq = new PriorityQueue<>((a, b) -> {
      return a.distFromStart - b.distFromStart;
    });
    
    int[] dist = new int[graph.length];
    Arrays.fill(dist, Integer.MAX_VALUE);
    dist[startState.id] = 0;

    boolean[] isSelected = new boolean[graph.length];

    pq.add(startState);
    while (!pq.isEmpty()) {
      State currentState = pq.poll();

      if (isSelected[currentState.id]) {
        continue;
      }
      isSelected[currentState.id] = true;

      List<State> nextStates = new ArrayList();
      for (int[] neighbor : graph[currentState.id]) {
        nextStates.add(new State(neighbor[0], dist[currentState.id] + neighbor[1]));
      }

      for (State nextState : nextStates) {
        if (isSelected[nextState.id]) continue;
        if (dist[nextState.id] > nextState.distFromStart) {
          dist[nextState.id] = nextState.distFromStart;
          pq.add(nextState);
        }
      }
      
    }
    return dist;
  }
    
  class State {
    int id;
    int distFromStart;
    public State(int id, int distFromStart) {
      this.id = id;
      this.distFromStart = distFromStart;
    }
  }

}
```

###### 例题3: 细分图中的可到达结点
[细分图中的可到达结点](https://leetcode.cn/problems/reachable-nodes-in-subdivided-graph/)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220602212459.png)

```代码
class Solution {

  public int reachableNodes(int[][] edges, int maxMoves, int n) {
    List<int[]>[] graph = new ArrayList[n];
    for (int i = 0; i < n; i++) {
      graph[i] = new ArrayList();
    }
    for (int i = 0; i < edges.length; i++) {
      graph[edges[i][0]].add(new int[]{edges[i][1], edges[i][2]});
      graph[edges[i][1]].add(new int[]{edges[i][0], edges[i][2]});
    } 
    int res = 0; 
    int[] dist = dijkstra(new State(0, 0), graph);
    for (int i = 0; i < edges.length; i++) {
      // 这条边点起点还能在这条边上走多少个顶点
      int right = maxMoves - dist[edges[i][0]] < 0 ? 0 : maxMoves - dist[edges[i][0]];
      // 这条边点终点还能在这条边上走多少个顶点
      int left = maxMoves - dist[edges[i][1]] < 0 ? 0 : maxMoves - dist[edges[i][1]];
      res += (right + left) > edges[i][2] ? edges[i][2] : right + left;
    }
    for (int i = 0; i < n; i++) {
      if (dist[i] <= maxMoves) {
        res++;
      }
    }
    return res;
  }

  int[] dijkstra(State startState,  List<int[]>[] graph) {
    // 优先队列，distFromStart较小的排在前面
    Queue<State> pq = new PriorityQueue<>((a, b) -> {
      return a.distFromStart - b.distFromStart;
    });

    // 初始化dist
    // dist[i] 的值就是节点 start 到达节点 i 的最短路径权重
    int[] dist = new int[graph.length];
    // 起始点到各点的最短路径长度为Integer.MAX_VALUE
    Arrays.fill(dist, Integer.MAX_VALUE);
    // 节点start 到节点start的最短路径为0 
    dist[startState.id] = 0;

    boolean[] isSelected = new boolean[graph.length];

    // 从起点start开始进bfs
    pq.add(startState);

    while (!pq.isEmpty()) {
      State currentState = pq.poll();

      if (isSelected[currentState.id]) {
        continue;
      }
      isSelected[currentState.id] = true;

      // 获取currentState相邻节点
      List<State> nextStates = new ArrayList();
      for (int[] neighbor : graph[currentState.id]) {
        int nextNodeID = neighbor[0];
        int distToNextNode = dist[currentState.id] + neighbor[1] + 1;
        nextStates.add(new State(nextNodeID, distToNextNode));
      }
       
      for (State nextState : nextStates) {
        if (isSelected[nextState.id]) continue;
        if (dist[nextState.id] > nextState.distFromStart) {
          dist[nextState.id] = nextState.distFromStart;
          pq.add(nextState);
        }
      }
    }
    //System.out.println(Arrays.toString(dist)); 
    return dist;
  }



  class State {
    int id;
    int distFromStart;
    public State(int id, int distFromStart) {
      this.id = id;
      this.distFromStart = distFromStart;
    }
  }
}
```


##### 模版2: 只需求到达某个点的最短路径
```java
/**
* startState: 开始状态
* graph: 图的表示方式，这里是使用的带有的权值的邻接表的表示方式
* end: 目标点
*/
int dijkstra(State startState,  List<int[]>[] graph, int end) {
  // 优先队列，distFromStart较小的排在前面
  Queue<State> pq = new PriorityQueue<>((a, b) -> {
    return a.distFromStart - b.distFromStart;
  });

  // 初始化dist
  // dist[i] 的值就是节点 start 到达节点 i 的最短路径权重
  int[] dist = new int[graph.length];
  // 起始点到各点的最短路径长度为Integer.MAX_VALUE
  Arrays.fill(dist, Integer.MAX_VALUE);
  // 节点start 到节点start的最短路径为0 
  dist[startState.id] = 0;

  // 用来标记节点是否已经被选择
  boolean[] isSelected = new boolean[graph.length];

  // 从起点start开始进bfs
  pq.add(startState);

  while (!pq.isEmpty()) {
    State currentState = pq.poll();
    
    // 如果currentState是目标点
    if (currentState.id == end) {
      return currentState.distFromStart;
    }

    if (isSelected[currentState.id]) {
      continue;
    }
    isSelected[currentState.id] = true;


    // 获取currentState相邻节点
    List<State> nextStates = new ArrayList();
    for (int[] neighbor : graph[currentState.id]) {
      int nextNodeID = neighbor[0];
      int distToNextNode = dist[currentState.id] + neighbor[1];
      nextStates.add(new State(nextNodeID, distToNextNode));
    }
     
    for (State nextState : nextStates) {
      if (isSelected[nextState.id]) continue;
      if (dist[nextState.id] > nextState.distFromStart) {
        dist[nextState.id] = nextState.distFromStart;
        pq.add(nextState);
      }
    }
  }

  // 如果到达这里，说明从 start 开始无法到达 end，返回 -1
  return -1;
}

// 辅助类, 用于优先队列
class State {
    // 图节点的 id
    int id;
    // 从 start 节点到当前节点的距离
    int distFromStart;

    State(int id, int distFromStart) {
        this.id = id;
        this.distFromStart = distFromStart;
    }
}
```

###### 例题1: 到达角落需要移除障碍物的最小数目
[到达角落需要移除障碍物的最小数目](https://leetcode.cn/problems/minimum-obstacle-removal-to-reach-corner/)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220601161114.png)

代码：
```java
class Solution {
  public int minimumObstacles(int[][] grid) {
    return dijkstra(new State(0, 0, 0), grid);
  }

  int dijkstra(State startState, int[][] graph) {
    Queue<State> pq = new PriorityQueue<>((a, b) -> {
      return a.distFromStart - b.distFromStart;
    });

    int[][] dist = new int[graph.length][graph[0].length];
    for (int i = 0; i < dist.length; i++) {
      Arrays.fill(dist[i], Integer.MAX_VALUE);
    }
    dist[startState.row][startState.col] = 0;

    boolean[][] isSelected = new boolean[graph.length][graph[0].length]; 

    pq.add(startState);
    
    while (!pq.isEmpty()) {
      State currentState = pq.poll();
      
      if (currentState.row == graph.length - 1 && currentState.col == graph[0].length - 1) {
        return currentState.distFromStart;
      }

      if (isSelected[currentState.row][currentState.col]) {
        continue;
      }
      isSelected[currentState.row][currentState.col] = true;
      
      List<State> nextStates = new ArrayList();
      
			int[] dr = new int[]{-1, 1, 0, 0};
			int[] dc = new int[]{0, 0, -1, 1};
      
			for (int i = 0; i < 4; i++) {
				int nr = currentState.row + dr[i];
				int nc = currentState.col + dc[i];
        if (nr >= 0 && nr < graph.length && nc >= 0 && nc < graph[0].length) {
          nextStates.add(new State(nr, nc, graph[nr][nc] == 1 ? currentState.distFromStart + 1 : currentState.distFromStart));
        }
			}
      
      for (State nextState : nextStates) {
        if (isSelected[nextState.row][nextState.col]) continue;
        if (dist[nextState.row][nextState.col] > nextState.distFromStart) {
          dist[nextState.row][nextState.col] = nextState.distFromStart;
          pq.add(nextState);
        }   
      }
    }
    return -1;
  }

  class State{
    int row;
    int col;
    int distFromStart;
    public State(int row, int col, int distFromStart) {
      this.row = row;
      this.col = col;
      this.distFromStart = distFromStart;
    }
  }
}
```
###### 例题2: 概率最大的路径
[概率最大的路径](https://leetcode.cn/problems/path-with-maximum-probability/)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220601194923.png)

代码：
```java
class Solution {
  int end;
  public double maxProbability(int n, int[][] edges, double[] succProb, int start, int end) {
    this.end = end;
    // 构建图
    List<double[]>[] graph = new LinkedList[n];
    for (int i = 0; i < n; i++) {
      graph[i] = new LinkedList();
    }
    for (int i = 0; i < edges.length; i++) {
      int[] edge = edges[i]; 
      int from = edge[0];
      int to = edge[1];
      double weight = succProb[i];
      graph[from].add(new double[]{to, weight});
      graph[to].add(new double[]{from, weight});
    }
    return dijkstra(new State(start, 1), graph);
  
  }
  
  double dijkstra(State startState, List<double[]>[] graph) {
    Queue<State> pq = new PriorityQueue<>((a, b) -> {
      return Double.compare(b.distFromStart, a.distFromStart);
    });

    double[] dist = new double[graph.length];
    Arrays.fill(dist, -1);
    dist[startState.id] = 1;

    boolean[] isSelected = new boolean[graph.length];

    pq.add(startState); 
    
    while(!pq.isEmpty()) {
      State currentState = pq.poll();
      
      // 如果当前点为end点
      if (currentState.id == end) {
        return currentState.distFromStart;
      }

      if (isSelected[currentState.id]) {
        continue;
      }
      isSelected[currentState.id] = true;

      List<State> nextStates = new ArrayList();
      for (double[] neighbor : graph[currentState.id]) {
        double nextNodeId = neighbor[0];
        double distToNextNode = dist[currentState.id] * neighbor[1];
        nextStates.add(new State((int)nextNodeId, distToNextNode));
      }

      for (State nextState : nextStates) {
        if (isSelected[nextState.id]) continue;
        if (dist[nextState.id] < nextState.distFromStart) {
          dist[nextState.id] = nextState.distFromStart;
          pq.add(nextState);
        }
      }
    }
    return 0;
  }

  class State {
    int id;
    double distFromStart;
    public State(int id, double distFromStart) {
      this.id = id;
      this.distFromStart = distFromStart;
    }
  }
  
}
```

###### 例题3: 最小体力消耗路径
[最小体力消耗路径](https://leetcode.cn/problems/path-with-minimum-effort/)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220601224956.png)

代码：
```java
class Solution {
  public int minimumEffortPath(int[][] heights) {
    return dijkstra(new State(0, 0, 0), heights);
  }

  int dijkstra(State startState, int[][] heights) {
    Queue<State> pq = new PriorityQueue<>((a, b) -> {
      return a.distFromStart - b.distFromStart;
    });

    int[][] dist = new int[heights.length][heights[0].length];
    for (int i = 0; i < heights.length; i++) {
      Arrays.fill(dist[i], Integer.MAX_VALUE);
    }
    dist[startState.row][startState.col] = 0;

    boolean[][] isSelected = new boolean[heights.length][heights[0].length]; 

    pq.add(startState);
    
    while (!pq.isEmpty()) {
      State currentState = pq.poll();
      
      if (currentState.row == heights.length - 1 && currentState.col == heights[0].length - 1) {
        return currentState.distFromStart;
      }

      if (isSelected[currentState.row][currentState.col]) {
        continue;
      }
      isSelected[currentState.row][currentState.col] = true;

      List<State> nextStates = new ArrayList();
      int[] dr = new int[]{-1, 1, 0, 0};
			int[] dc = new int[]{0, 0, -1, 1};
			for (int i = 0; i < 4; i++) {
				int nr = currentState.row + dr[i];
				int nc = currentState.col + dc[i];
        if (nr >= 0 && nr < heights.length && nc >= 0 && nc < heights[0].length) {
          nextStates.add(new State(nr, nc, Math.max(dist[currentState.row][currentState.col], Math.abs(heights[currentState.row][currentState.col] - heights[nr][nc]))));
        }
			}

      for (State nextState : nextStates) {
        if (isSelected[nextState.row][nextState.col]) continue;
        if (dist[nextState.row][nextState.col] > nextState.distFromStart) {
          dist[nextState.row][nextState.col] = nextState.distFromStart;
          pq.add(nextState);
        }
      }
    }
    return -1;
  }
  
  class State {
    int row;
    int col;
    int distFromStart;
    public State(int row, int col, int distFromStart) {
      this.row = row;
      this.col = col;
      this.distFromStart = distFromStart;
    }
  }

}
```

#### Bellman-Ford算法

<div class="container">
  <iframe width="560" height="315" src="https://www.youtube.com/embed/c0aFMkpW5Lo" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>

<div class="container">
  <iframe width="560" height="315" src="https://www.youtube.com/embed/bxC1y6MsNlQ" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>

需要注意的是，在遍历所有的边来进行松弛操作前，需要先对 dist 进行备份，否则会出现「本次松弛操作所使用到的边，也是在同一次迭代所更新的」，从而不满足边数限制的要求。

举个例子，例如本次松弛操作使用了从 a 到 b 的当前最短距离来更新 dist[b]，直接使用 dist[a] 的话，不能确保 dist[a] 不是在同一次迭代中所更新，如果 dist[a] 是同一次迭代所更新的话，那么使用的边数将会大于 k 条。

因此在每次迭代开始前，我们都应该对 dist 进行备份，在迭代时使用备份来进行松弛操作。

##### 模版
```java
/**
 * @param s     起点
 * @param k     得到使用小于等于k条边的最短路径
 * @param edges 边集数组存储的图
 * @param dist  用于得到第s个顶点到其它顶点之间的最短距离
 * @return 是否存在负环，返回true，则存在负环
 */
boolean bellmanFord(int s, int k, List<Edge> edges, int[] dist) {
  // 初始化dist。此处不使用Integer.MAX_VALUE，而是除2的原因：防止 distClone[edge.begin] + edge.weight 数据溢出
  Arrays.fill(dist, Integer.MAX_VALUE / 2);
  dist[s] = 0;

  // 执行k次
  for (int i = 0; i < k; i++) {
    // 对 dist 进行备份，在迭代时使用备份来进行松弛操作
    int[] distClone = dist.clone();
    // 用来标记此轮操作中是否对顶点进行了松弛操作
    boolean flag = false;
    for (Edge edge : edges) {
      if (dist[edge.end] > distClone[edge.begin] + edge.weight) {
        dist[edge.end] = distClone[edge.begin] + edge.weight;
        flag = true;
      }
    }
    if (!flag) {
      // 此时flag为false, 说明此轮操作中没有顶点进行松弛操作，说明已经找到了所有顶点的做短路径, 且不存在负环
      return false;
    }
  }

  // 再执行1次，用来判断是否有负环；如果还能松弛, 则说明有负环
  for (Edge edge : edges) {
    if (dist[edge.end] > dist[edge.begin] + edge.weight) {
      return true;
    }
  }
  return false;
}


/**
 * 使用边集数组存储图
 */
class Edge {
  int begin, end, weight;

  Edge(int begin, int end, int weight) {
    this.begin = begin;
    this.end = end;
    this.weight = weight;
  }
}
```

##### 例题1: K 站中转内最便宜的航班
[K 站中转内最便宜的航班](https://leetcode.cn/problems/cheapest-flights-within-k-stops/)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220602124644.png)

代码：
```java
class Solution {
  public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {
    List<Edge> edges = new ArrayList();
    for (int i = 0; i < flights.length; i++) {
      edges.add(new Edge(flights[i][0], flights[i][1], flights[i][2]));
    }
    int[] dist = new int[n];
    bellmanFord(src, k + 1, edges, dist);
    return dist[dst] == Integer.MAX_VALUE / 2 ? -1 : dist[dst];
  }

 		/**
		 * @param s     起点
		 * @param k     得到使用小于等于k条边的最短路径
		 * @param edges 边集数组存储的图
		 * @param dist  用于得到第s个顶点到其它顶点之间的最短距离
		 * @return 是否存在负环，返回true，则存在负环
		 */
		boolean bellmanFord(int s, int k, List<Edge> edges, int[] dist) {
			// 初始化dist
			Arrays.fill(dist, Integer.MAX_VALUE / 2);
			dist[s] = 0;

			// 执行k次
			for (int i = 0; i < k; i++) {
				// 对 dist 进行备份，在迭代时使用备份来进行松弛操作
				int[] distClone = dist.clone();
				// 用来标记此轮操作中是否对顶点进行了松弛操作
				boolean flag = false;
				for (Edge edge : edges) {
					if (dist[edge.end] > distClone[edge.begin] + edge.weight) {
						dist[edge.end] = distClone[edge.begin] + edge.weight;
						flag = true;
					}
				}
				if (!flag) {
					// 此时flag为false, 说明此轮操作中没有顶点进行松弛操作，说明已经找到了所有顶点的做短路径, 且不存在负环
					return false;
				}
			}

			// 在执行1次，还能松弛则说明有负环
			for (Edge edge : edges) {
				if (dist[edge.end] > dist[edge.begin] + edge.weight) {
					return true;
				}
			}
			return false;
		}


		/**
		 * 使用边集数组存储图
		 */
		class Edge {
			int begin, end, weight;

			Edge(int begin, int end, int weight) {
				this.begin = begin;
				this.end = end;
				this.weight = weight;
			}
		}
}
```

#### SPFA算法

<div class="container">
  <iframe width="560" height="315" src="https://www.youtube.com/embed/r4MSAJ9Y0Ek" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>

##### 模版:
```java
/**
 * @param startState 起点状态
 * @param n          节点个数
 * @param dist       用于得到起点到其它顶点之间的最短距离
 * @param graph      图
 * @return 是否存在负环，返回true，则存在负环
 */
boolean spfa(State startState, int n, int[] dist, List<int[]>[] graph) {
  Queue<State> queue = new LinkedList<>();
  // 标记顶点是否正在队列中
  boolean[] used = new boolean[n];
  // 标记顶点进入了几次队列
  int[] num = new int[n];
  Arrays.fill(dist, Integer.MAX_VALUE);
  dist[startState.id] = 0; //第s个顶点到自身距离为0
  queue.add(startState); // 第s个顶点入队
  num[startState.id] = 1; // 表示第s个顶点已进入了1次队列
  used[startState.id] = true; // 表示第s个节点正在队列中

  while (!queue.isEmpty()) {
    State currentState = queue.poll();
    used[currentState.id] = false;

    List<State> nextStates = new ArrayList<>();
    for (int[] neighbor : graph[currentState.id]) {
      nextStates.add(new State(neighbor[0], dist[currentState.id] + neighbor[1]));
    }

    for (State nextState : nextStates) {
      if (dist[nextState.id] > nextState.distFromStart) {
        dist[nextState.id] = nextState.distFromStart;
        if (!used[nextState.id]) {
          queue.add(nextState);
          num[nextState.id]++;
          if (num[nextState.id] > n) {
            return false;
          }
          used[nextState.id] = true;
        }
      }
    }
  }
  return false;
}

// 辅助类, 用于优先队列
class State {
    // 图节点的 id
    int id;
    // 从 start 节点到当前节点的距离
    int distFromStart;

    State(int id, int distFromStart) {
        this.id = id;
        this.distFromStart = distFromStart;
    }
}
```

### 最小生成树
最小生成树与最短路径的区别:
- 最短路径是求两个点之间的最短距离
- 最小生成树是求生成树中所有边上的权值之和最小

![](https://raw.githubusercontent.com/NaisWang/images/master/20220603094800.png)

#### Prim算法
Prim的算法执行与Dijkstra算法十分相似。都是使用了贪心策略。Prim与Dijkstra只有贪心策略不同，其他部分代码逻辑一样。Prim的贪心策略为：每次从集合中选取**边**权值最小的节点。

##### 模版
```java
/**
 * @param startState 开始状态
 * @param graph      图的表示方式，这里是使用的带有的权值的邻接表的表示方式
 * @return 最小生成树中的每个节点边的权值
 */
int[] prim(State startState, List<int[]>[] graph) {
  Queue<State> pq = new PriorityQueue<>((a, b) -> {
    return a.distValue - b.distValue;
  });

  int[] dist = new int[graph.length];
  Arrays.fill(dist, Integer.MAX_VALUE);
  dist[startState.id] = 0;

  boolean[] isSelected = new boolean[graph.length];

  pq.add(startState);
  while (!pq.isEmpty()) {
    State currentState = pq.poll();

    if (isSelected[currentState.id]) {
      continue;
    }
    isSelected[currentState.id] = true;

    List<State> nextStates = new ArrayList();
    for (int[] neighbor : graph[currentState.id]) {
      nextStates.add(new State(neighbor[0], neighbor[1]));
    }

    for (State nextState : nextStates) {
      if (isSelected[nextState.id]) continue;
      if (dist[nextState.id] > nextState.distValue) {
        dist[nextState.id] = nextState.distValue;
        pq.add(nextState);
      }
    }

  }
  return dist;
}

class State {
  // 节点的id
  int id;
  // 节点相连的边的权值
  int distValue;

  public State(int id, int distValue) {
    this.id = id;
    this.distValue = distValue;
  }
}
```

你会发现此模版与Dijkstra模版几乎一摸一样

##### 例题1: 连接所有点的最小费用
[连接所有点的最小费用](https://leetcode.cn/problems/min-cost-to-connect-all-points/)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220603113058.png)

代码:
```java
class Solution {
  public int minCostConnectPoints(int[][] points) {
    int n = points.length;

    // 构建图
    List<int[]>[] graph = new ArrayList[n];
    for (int i = 0; i < n; i++) {
      graph[i] = new ArrayList();  
    }
    for (int i = 0; i < n; i++) {
      for (int j = i + 1; j < n; j++) {
        graph[i].add(new int[]{j, Math.abs(points[i][0] - points[j][0]) + Math.abs(points[i][1] - points[j][1])});
        graph[j].add(new int[]{i, Math.abs(points[i][0] - points[j][0]) + Math.abs(points[i][1] - points[j][1])});
      }
    }
    
    int res = 0;
    int[] dist = prim(new State(0, 0), graph); 
    for (int i = 0; i < dist.length; i++) {
      res += dist[i];
    }
    return res;
  }

  /**
  * @param startState 开始状态
  * @param graph      图的表示方式，这里是使用的带有的权值的邻接表的表示方式
  * @return 最小生成树中的每个节点边的权值
  */
  int[] prim(State startState, List<int[]>[] graph) {
    Queue<State> pq = new PriorityQueue<>((a, b) -> {
      return a.distValue - b.distValue;
    });
  
    int[] dist = new int[graph.length];
    Arrays.fill(dist, Integer.MAX_VALUE);
    dist[startState.id] = 0;
  
    boolean[] isSelected = new boolean[graph.length];
  
    pq.add(startState);
    while (!pq.isEmpty()) {
      State currentState = pq.poll();
  
      if (isSelected[currentState.id]) {
        continue;
      }
      isSelected[currentState.id] = true;
  
      List<State> nextStates = new ArrayList();
      for (int[] neighbor : graph[currentState.id]) {
        nextStates.add(new State(neighbor[0], neighbor[1]));
      }
  
      for (State nextState : nextStates) {
        if (isSelected[nextState.id]) continue;
        if (dist[nextState.id] > nextState.distValue) {
          dist[nextState.id] = nextState.distValue;
          pq.add(nextState);
        }
      }
  
    }
    return dist;
  }
  
  class State {
    // 节点的id
    int id;
    // 节点相连的边的权值
    int distValue;
  
    public State(int id, int distValue) {
      this.id = id;
      this.distValue = distValue;
    }
  }

}
```





# 动态规划
动态规划通过组合子问题的解来求解原问题，一般来说，动态规划应用于**重叠子问题**的情况，即不同的子问题具有公共的子子问题。

动态规划算法对每个子子问题**只求解一次**，将其解保存在一个表格中，从而无需每次求解一个子子问题时都重新计算，避免了这种不必要的计算工作。

动态规划有两种实现方法：
- 第一种方法称为**带备忘的自顶向下法（top-down with memoization）**, 即**带备忘录的递归**。此方法仍按自然的递归形式编写过程，但过程会保存每个子问题的解（通常保存在一个数组或散列表中）。当需要一个子问题的解时，过程首先检查是否已经保存过此解。如果是，则直接返回保存的值，从而节省了计算时间；否则，按通常方式计算这个子问题。我们称这个递归过程是带备忘的（memoized），因为它“记住”了之前已经计算出的结果。
- 第二种方法称为**自底向上法（bottom-up method）**。这种方法一般需要恰当定义子问题“规模”的概念，使得任何子问题的求解都只依赖于“更小的"子问题的求解。因而我们可以将子问题按规模排序，按由小至大的顺序进行求解。当求解某个子问题时，它所依赖的那些更小的子问题都已求解完毕，结果已经保存。每个子问题只需求解一次，当我们求解它（也是第一次遇到它）时，它的所有前提子问题都已求解完成。

以上两个实现方法的核心思想就是**保存子问题的值，解决重叠子问题重复计算的问题**。 而我们常用一个数组来保存子问题的值，而这个数组就是备忘录或dp数组。这个备忘录或dp数组能表达如下2中意思：
- `状态`， 由数组的下标确定, 不同的数组下标对应不同的状态
- `状态对应的值`, 由数组的值确定

所以我们在使用备忘录或dp数组时，一定要深知该表达的 状态以及该状态对应的值 所表达的含义

### 动态规划的三个特征
”三个特征“分别为最优子结构、无后效性和重复子问题

#### 最优子结构
最优子结构指的是，问题的最优解包含子问题的最优解。反过来说就是，可以通过子问题的最优解，推导出问题的最优解。

若把最优子结构对应到前面定义的动态规划问题模型上，可以理解为，后面阶段的状态可以通过前面阶段的状态推导出来。

例如，现在有`min_dist(i, j) = w[i][j] + min(min_dist(i, j-1), min_dist(i-1, j))`状态转移方程，即`dp(i, j)` 可以通过 `dp(i, j-1)` 和 `dp(i-1, j)` 两个状态推导出来。这就说明，这个问题符合“最优子结构”。

#### 无后效性
无后效性有两层含义
- 第一层含义是，在推导后面阶段的状态的时候，只关心前面阶段的状态值，不关心这个状态是怎么一步一步推导出来的。
- 第二层含义是，某阶段状态一旦确定，就不受之后阶段的决策影响。

例如在求最长上升子序列中，如果把子问题定义为"求序列的前n个元素的最长上升子序列的长度"。这个子问题是不具有“无后效性”的。分析如下：

假设F(n) = x, 但可能有多个序列满足F(n) = x。有的序列的最后一个元素比$a_(n+1)$小, 则加上$a_(n+1)$就能形成更长上升子序列；有的序列最后一个元素不比$a_(n+1)$小...以后的事情受如何达到状态n的影响，不符合“无后效性”

**递归中子问题可以不是无后效性的, 但是如果能将递归转换成自底向上的动态规划, 此时的子问题一定是无后效性的。当我们选取子问题时 最好选择无后效性是子问题, 因为无后效性的子问题比有后效性的易处理**

#### 重复子问题
不同的决策序列，到达某个相同的阶段时，可能会产生重复的状态。

## 步骤

![](https://raw.githubusercontent.com/NaisWang/images/master/20220408163551.png)

### 例题：打家劫舍(力扣198)
你是一个小偷，现在有一排相邻的房屋等着你去偷窃。这些房子装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。给定一个代表每个房屋存放金额的正整数数组，计算你不触动警报装置的情况下，一夜之内能够偷窃到的最高金额。（不用考虑偷窃时间）
```
示例1：
输入：[1，2，3，1，3]
输出：7解释：偷窃1号房屋（金额=1），然后偷窃3号房屋（金额=3），接着偷窃5号房屋（金额=3）。偷窃到的最高金额=1+3+3=7。
示例2：
输入：[2，7，2，3，8]
输出：15解释：偷窃2号房屋（金额=7），然后偷窃5号房屋（金额=8）。偷窃到的最高金额=7+8=15。
```

#### 分析1
递归分析：
1. 节点的作用: 当第一家偷的是第now家且以后偷的家都是大于now时的最大偷窃金额
2. 父子节点之间的关系: 子节点表示在父节点情况下第二家偷的情况
3. 节点不能生成子节点的情况: 没有下一家可以偷了

递归树:

![](https://raw.githubusercontent.com/NaisWang/images/master/20220408163642.png)

代码：
```java
public class Main {
  public static void main(String args[]) {
    Solution so = new Solution();
    System.out.println(so.rob(new int[]{1, 2, 3, 1, 3}));
  }
}

class Solution {
  private int length;

  public int rob(int[] nums) {
    length = nums.length; 
    return dfs(-2, nums);
  }

  private int dfs(int now, int[] nums) {
    if (now >= length - 2) {
      return nums[now];
    }
    int maxNum = Integer.MIN_VALUE;
    for (int i = now + 2; i < length; i++) {
      maxNum = Math.max(maxNum, dfs(i, nums));
    }
    if(now == -2) return maxNum;
    return maxNum + nums[now];
  }
}
```

我们发现出现子问题重复计算的情况，因此我们用备忘录来存储子问题；此处的备忘录可以设置为`dp[i]`, 表示当第一家偷的是i时，最大偷窃金额为`dp[i]`。定义完备忘录后，简化递归树:

![](https://raw.githubusercontent.com/NaisWang/images/master/20220408163820.png)

代码：
```java
public class Main {
  public static void main(String args[]) {
    Solution1 so = new Solution1();
    System.out.println(so.rob(new int[]{1, 2, 3, 1, 3}));
  }
}

class Solution1 {
  private int[] dp = null;
  private int length;

  public int rob(int[] nums) {
    length = nums.length; 
    dp = new int[length];
    initDp();
    return dfs(-2, nums);
  }

  private void initDp() {
    for (int i = 0; i < length; i++) {
      dp[i] = -1; 
    }
  }

  private int dfs(int now, int[] nums) {
    if (now >= length -2) {
      return nums[now];
    }
    int maxNum = Integer.MIN_VALUE;
    for (int i = now + 2; i < length; i++) {
      if(dp[i] == -1){
        dp[i] = dfs(i, nums);
      }
      maxNum = Math.max(maxNum, dp[i]);
    }
    if(now == -2) return maxNum;
    return maxNum + nums[now];
  }
}
```

通过分析发现，无法推出备忘录中的各个数据之间的通项公式, 所以只能使用上述的带有备忘录的递归，而不能使用自底向上法

#### 分析2

递归分析：
1. 节点的作用: 求自在前now家（包括第now家）偷时，最大的偷窃金额
2. 父子节点之间的关系: 子节点表示在父节点情况下第二家偷的情况
3. 节点不能生成子节点的情况: 没有下一家可以偷了

递归树：

![](https://raw.githubusercontent.com/NaisWang/images/master/20220408163831.png)

代码
```java
public class Main {
  public static void main(String args[]) {
    Solution so = new Solution();
    System.out.println(so.rob(new int[]{1, 2, 3, 1, 3}));
  }
}

class Solution {
  public int rob(int[] nums) {
    return dfs(nums.length-1, nums);
  }

  private int dfs(int now, int[] nums) {
    if(now == 0) return nums[0];
    if(now == 1) return Math.max(nums[1], nums[0]);
    return Math.max(dfs(now-1, nums), dfs(now-2, nums) + nums[now]);
  }
}
```

**子问题分析：**
- 子问题的范围: 只在前now家（包括第now家）偷
- 子问题的属性：最大偷窃金额

我们发现出现子问题重复计算的情况，因此我们用备忘录来存储子问题；此处的备忘录可以设置为`dp[i]`, 表示只在前i家偷时，最大偷窃金额为`dp[i]`。定义完备忘录后，简化递归树:

![](https://raw.githubusercontent.com/NaisWang/images/master/20220408164255.png)

代码：
```java
public class Main {
  public static void main(String args[]) {
    Solution so = new Solution();
    System.out.println(so.rob(new int[]{1, 2, 3, 1, 3}));
  }
}

class Solution {
  private int[] dp = null;

  public int rob(int[] nums) {
    int length = nums.length;
    dp = new int[length];
    initDp(length); 
    return dfs(nums.length-1, nums);
  }

  private void initDp(int length) {
    for (int i = 0; i < length; i++) {
      dp[i] = -1; 
    }
  }

  private int dfs(int now, int[] nums) {
    if(now == 0) return nums[0];
    if(now == 1) return Math.max(nums[1], nums[0]);
    if(dp[now-1] == -1) {
      dp[now-1] = dfs(now-1, nums);
    }
    if(dp[now-2] == -1) {
      dp[now-2] = dfs(now-2, nums);
    }
    return Math.max(dp[now-1], dp[now-2] + nums[now]);
  }
}
```

通过分析发现，可以推出备忘录中的各个数据之间的通项公式为
$$dp(now) = \begin{cases}
nums[0] & now = 0 \\
max(nums[0], nums[1]) & now = 1 \\
max\{dp(now-1), dp(now-2) + nums[now]\} & now \geq 2
\end{cases}$$


所以可以使用从底向上法，代码如下：
```java
public class Main {
  public static void main(String args[]) {
    Solution4 so = new Solution4();
    System.out.println(so.rob(new int[]{1, 2, 3, 1, 3}));
  }
}

class Solution4 {
  public int rob(int[] nums) {
    int length = nums.length;
    if (length == 1) return nums[0]; 
    if (length == 2) return Math.max(nums[0], nums[1]);
    int[] dp = new int[length];
    dp[0] = nums[0];
    dp[1] = Math.max(nums[0], nums[1]);
    for (int i = 2; i < length; i++) {
      dp[i] = Math.max(dp[i-1], dp[i-2] + nums[i]);
    }
    return dp[length-1];
  }
}
```

### 0-1背包问题
[0-1背包问题-模板题](https://www.acwing.com/problem/content/2/)

分析：
当输入为：
```
4 5
1 2
2 4
4 4
4 5
```
递归树：

![](https://raw.githubusercontent.com/NaisWang/images/master/20220408164308.png)

代码：
```java
class Solution1 {

  public int solution(int N, int V, int[] v, int[] w) {
    return dfs(N, V, v, w);
  }

  private int dfs(int nowN, int nowV, int[] v, int[] w) {
    if (nowN == 1) {
      if (nowV >= v[1]) {
        return w[1];
      }
      return 0;
    } 

    int min = Integer.MIN_VALUE;
    if (nowV >= v[nowN] ) {
      min = dfs(nowN - 1, nowV - v[nowN], v, w) + w[nowN];
    }

    return Math.max(min, dfs(nowN - 1, nowV, v, w));
  }
  
}
```
**子问题分析：**
- 子问题的范围: 当在前nowN个物品（包括第nowN个物品）中选，且背包容量为nowV时
- 子问题的属性：总价值最大

经过分析：发现子问题符合`无后效性`

我们发现出现子问题重复计算的情况，因此我们用备忘录来存储子问题；
此处的备忘录可以设置为`dp[nowN][nowV]`, 表示当在前nowN个物品（包括第nowN个物品）中选，且背包容量为nowV时, 总价值最大为`dp[nowN][nowV]`
定义完备忘录后，简化递归树:

![](https://raw.githubusercontent.com/NaisWang/images/master/20220408164321.png)

代码：
```java
class Solution2 {

  private Integer[][] dp = null; 

  public int solution(int N, int V, int[] v, int[] w) {
    dp = new Integer[N+1][V+1];
    return dfs(N, V, v, w);
  }

  private int dfs(int nowN, int nowV, int[] v, int[] w) {
    if (nowN == 1) {
      if (nowV >= v[1]) {
        return w[1];
      }
      return 0;
    } 
    if (nowV >= v[nowN] ) {
      if (dp[nowN - 1][nowV - v[nowN]] == null) {
        dp[nowN - 1][nowV - v[nowN]] = dfs(nowN - 1, nowV - v[nowN], v, w);
      }
    } 
    if (dp[nowN - 1][nowV] == null) {
      dp[nowN - 1][nowV] = dfs(nowN - 1, nowV, v, w);
    } 
    return Math.max(nowV >= v[nowN] ? dp[nowN - 1][nowV - v[nowN]] + w[nowN] : 0, dp[nowN - 1][nowV]);
  }
  
}
```

通过分析发现，可以推出备忘录中的各个数据之间的通项公式为
$$dp[nowN][nowV] = \begin{cases}
dp[nowN-1][nowV] & nowV < v[nowN] \\
max(dp[nowN - 1][nowV - v[nowN]] + w[nowN], dp[nowN - 1][nowV]) & nowV \geq v[nowN] \\
\end{cases}$$


所以可以使用从底向上法，代码如下：
```java
class Solution3 {
  public int solution(int N, int V, int[] v, int[] w) {
    int[][] dp = new int[N+1][V+1];
    for (int nowN = 1; nowN <= N; nowN++) {
      for (int nowV = 0; nowV <= V; nowV++) {
        if (nowV < v[nowN]) {
          dp[nowN][nowV] = dp[nowN - 1][nowV];
        } else {
          dp[nowN][nowV] = Math.max(dp[nowN - 1][nowV - v[nowN]] + w[nowN], dp[nowN - 1][nowV]);
        }
      }
    }
    return dp[N][V]; 
  }
}
```
可以使用滚动数组讲将dp数组从二维降到一维，代码如下：
```java
class Solution {
  public int solution(int N, int V, int[] v, int[] w) {
    int[] dp = new int[V+1];
    for (int i = 1; i <= N; i++) {
      for (int j = V; j >= v[i]; j--) {
        dp[j] = Math.max(dp[j], dp[j - v[i]] + w[i]);
      }
    }
    return dp[V]; 
  }
}
```

### 完全背包问题
[完全背包问题-模板题](https://www.acwing.com/problem/content/3/)
完全背包问题与0-1背包问题的不同点在于完全背包问题中的每种物品都有无限件可用

分析：
当输入为：
```
4 5
1 2
2 4
4 4
4 5
```
递归树：

![](https://raw.githubusercontent.com/NaisWang/images/master/20220408164333.png)

代码：
```java
class Solution1 {
  public int solution(int N, int V, int[] v, int[] w) {
    return dfs(N, V, v, w);
  }
  
  private int dfs(int nowN, int nowV, int[] v, int[] w) {
    if (nowN == 1) {
      return nowV / v[1] * w[1];
    }
    int maxNum = nowV / v[nowN];
    int max = Integer.MIN_VALUE;
    for (int i = 0; i <= maxNum; i++) {
      max = Math.max(max, dfs(nowN - 1, nowV - i * v[nowN], v, w) + i * w[nowN]);
    }
    return max;
  }
}
```
**子问题分析：**
- 子问题的范围: 当在前nowN个物品（包括第nowN个物品）中选，且背包容量为nowV时
- 子问题的属性：总价值最大

经过分析：发现子问题符合`无后效性`

我们发现出现子问题重复计算的情况，因此我们用备忘录来存储子问题；
此处的备忘录可以设置为`dp[nowN][nowV]`, 表示当在前nowN个物品（包括第nowN个物品）中选，且背包容量为nowV时, 总价值最大为`dp[nowN][nowV]`
定义完备忘录后，简化递归树:

![](https://raw.githubusercontent.com/NaisWang/images/master/20220408164352.png)

代码：
```java
class Solution2 {
  private Integer[][] dp = null;

  public int solution(int N, int V, int[] v, int[] w) {
    dp = new Integer[N + 1][V + 1];
    return dfs(N, V, v, w);
  }
  
  private int dfs(int nowN, int nowV, int[] v, int[] w) {
    if (nowN == 1) {
      return nowV / v[1] * w[1];
    }
    int maxNum = nowV / v[nowN];
    int max = Integer.MIN_VALUE;
    for (int i = 0; i <= maxNum; i++) {
      if (dp[nowN - 1][nowV - i * v[nowN]] == null) {
        dp[nowN - 1][nowV - i * v[nowN]] = dfs(nowN - 1, nowV - i * v[nowN], v, w); 
      } 
      max = Math.max(max, dp[nowN - 1][nowV - i * v[nowN]] + i * w[nowN]);
    }
    return max;
  }
}
```

通过分析发现，于是易得状态转移方程：
`$dp[nowN][nowV]=max( dp[nowN−1][nowV], dp[nowN−1][nowV−v[nowN]]+w[nowN], dp[nowN-1][nowV−2*v[nowN]]+2*w[nowN],...)$`

但是这个东西项数太多，想办法把它转换成两项

由上面的状态转移方程我们可以得到：
`$dp[nowN][nowV−v[nowN]]=max(dp[nowN−1][nowV−v[nowN]], dp[nowN−1][nowV−2*v[nowN]]+w[nowN], dp[nowN−1][nowV−3*v[nowN]]+2*w[nowN] ,...)$`
观察得到，上面的第二项后面的每一项都是下面的每一项加上一个$W_i$。

于是我们可以得到状态转移方程：
$dp[nowN][nowV]=max(dp[nowN−1][nowV] , dp[nowN][nowV-v[nowN]]+w[nowN]$

$$dp[nowN][nowV] = \begin{cases}
dp[nowN-1][nowV] & nowV < v[nowN] \\
max(dp[nowN−1][nowV] , dp[nowN][nowV-v[nowN]]+w[nowN] & nowV \geq v[nowN] \\
\end{cases}$$

代码：
```java
class Solution3 {

  private int[][] dp;

  public int solution(int N, int V, int[] v, int[] w) {
    dp = new int[N + 1][V + 1];
    for (int nowN = 1; nowN <= N; nowN++) {
      for (int nowV = 0; nowV <= V; nowV++) {
        if (nowV < v[nowN]) {
          dp[nowN][nowV] = dp[nowN - 1][nowV];
        } else {
          dp[nowN][nowV] = Math.max(dp[nowN - 1][nowV], dp[nowN][nowV -v[nowN]] + w[nowN]);
        }
      }
    }
    return dp[N][V];
  }
}
```

### 最长公共子序列
[最长公共子序列](https://leetcode.cn/problems/qJnOS7/)

给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0 。

一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。
- 例如，"ace" 是 "abcde" 的子序列，但 "aec" 不是 "abcde" 的子序列。
两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。

示例 1：
```txt
输入：text1 = "abcde", text2 = "ace" 
输出：3  
解释：最长公共子序列是 "ace" ，它的长度为 3 。
```

示例 2：
```txt
输入：text1 = "abc", text2 = "abc"
输出：3
解释：最长公共子序列是 "abc" ，它的长度为 3 。
```

示例 3：
```txt
输入：text1 = "abc", text2 = "def"
输出：0
解释：两个字符串没有公共子序列，返回 0 。
```

#### 分析

递归树：

![](https://raw.githubusercontent.com/NaisWang/images/master/20220511200641.png)

代码:

```java
class Solution {

	public int longestCommonSubsequence(String text1, String text2) {
		return dfs(0, 0, text1, text2);
	}

	private int dfs(int i, int j, String text1, String text2) {
		if (i == text1.length() || j == text2.length()) {
			return 0;
		}
		if (text1.charAt(i) == text2.charAt(j)) {
			int temp = dfs(i + 1, j + 1, text1, text2) + 1;
			return temp;
		}
		int temp = Math.max(dfs(i + 1, j, text1, text2), dfs(i, j + 1, text1, text2));
		return temp;
	}

}

public class MainOfferII095 {
	public static void main(String[] args) {
		Solution solution = new Solution();
		System.out.println(solution.longestCommonSubsequence("abcde", "ace"));
	}
}
```

子问题分析：
- 子问题的范围: 第一个字符串从第i个字符到最后一个字符的子串与第二个字符串从第j个字符开始到最后一个字符到子串之间的最长公共子序列
- 子问题的属性：最长公共子序列的长度

经过分析：发现子问题符合`无后效性`

我们发现出现重复计算的情况，因此我们用备忘录来存储子问题；

此处的备忘录可以设置为`dp[i][j]`, 表示第一个字符串从第i个字符到最后一个字符的子串与第二个字符串从第j个字符开始到最后一个字符到子串之间的最长公共子序列的长度为`dp[i][j]`

定义完备忘录后，简化递归树:

![](https://raw.githubusercontent.com/NaisWang/images/master/20220511203152.png)

代码：
```java
class SolutionOfferII095 {

	private Integer[][] dp;

	public int longestCommonSubsequence(String text1, String text2) {
		dp = new Integer[text1.length() + 1][text2.length() + 1];
		return dfs(0, 0, text1, text2);
	}

	private int dfs(int i, int j, String text1, String text2) {
		if (i == text1.length() || j == text2.length()) {
			return 0;
		}
		if (text1.charAt(i) == text2.charAt(j)) {
			if (dp[i + 1][j + 1] == null) {
				dp[i + 1][j + 1] = dfs(i + 1, j + 1, text1, text2);
			}
			return dp[i + 1][j + 1] + 1;
		}
		if (dp[i + 1][j] == null) {
			dp[i + 1][j] = dfs(i + 1, j, text1, text2);
		} 
		if (dp[i][j + 1] == null) {
			dp[i][j + 1] = dfs(i, j + 1, text1, text2);
		} 
		int temp = Math.max(dp[i + 1][j], dp[i][j + 1]);
		return temp;
	}

}

public class MainOfferII095 {
	public static void main(String[] args) {
		SolutionOfferII095 solution = new SolutionOfferII095();
		System.out.println(solution.longestCommonSubsequence("abcde", "ace"));
	}
}
```

通过分析发现，可以推出备忘录中的各个数据之间的通项公式为

$$dp[i][j] = \begin{cases}
dp[i + 1][j + 1] + 1& text1[i] = text2[j] \\
max(dp[i + 1][j] , dp[i][j + 1] & text1[i] != text2[j] \\
\end{cases}$$

代码：
```java
class SolutionOfferII095 {
	private Integer[][] dp;

	public int longestCommonSubsequence(String text1, String text2) {
		dp = new Integer[text1.length() + 1][text2.length() + 1];
		return dp(text1, text2);
	}

	private int dp(String text1, String text2) {

		dpInit(text1, text2);

		for (int i = text1.length() - 1; i > -1; i--) {
			for (int j = text2.length() - 1; j > -1; j--) {
				if (text1.charAt(i) == text2.charAt(j)) {
					dp[i][j] = dp[i + 1][j + 1] + 1;
				} else {
					dp[i][j] = Math.max(dp[i + 1][j], dp[i][j + 1]);
				}
			}
		}
		return dp[0][0];
	}

	private void dpInit(String text1, String text2) {
		for (int i = 0; i <= text1.length(); i++) {
			dp[i][text2.length()] = 0;
		}

		for (int i = 0; i <= text2.length(); i++) {
			dp[text1.length()][i] = 0;
		}
	}
}

public class MainOfferII095 {
	public static void main(String[] args) {
		SolutionOfferII095 solution = new SolutionOfferII095();
		System.out.println(solution.longestCommonSubsequence("abcde", "ace"));
	}
}
```

## 分析二
#### 序列上按结尾位置规划
### 例题1: 最长递增子序列
[最长递增子序列](https://leetcode.cn/problems/longest-increasing-subsequence/)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220614102644.png)

#### 分析
- 子问题：dp[i]="**以arr[i]结尾**的最长递增子序列的长度"
- 初始条件：dp[0] = 1
- 递推表达式：dp[i] = max{Best[j] + 1, if 0 <= j < i && arr[j] < arr[i]}
- 最后的解答：dp数组中最大值

代码：
```java
class Solution {
  public int lengthOfLIS(int[] nums) {
    int[] dp = new int[nums.length];
    dp[0] = 1;
    int res = dp[0];
    for (int i = 1; i < nums.length; i++) {
      dp[i] = 1;
      for (int j = 0; j < i; j++) {
        if (nums[j] < nums[i]) {
          dp[i] = Math.max(dp[i], dp[j] + 1);
        }
      }
      res = Math.max(res, dp[i]);
    }
    return res;
  }
}
```

### 例题2: 最大子数组和
[最大子数组和](https://leetcode.cn/problems/maximum-subarray/)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220614104309.png)

#### 分析
- 子问题：dp[i]="**以nums[i]结尾**的连续子数组中，可以产生的最大和"
- 初始条件：dp[0] = nums[0]
- 递推表达式：dp[i] = max{nums[i], dp[i - 1] + nums[i]};
- 最后的解答：dp数组中最大值

代码：
```java
class Solution {
  public int maxSubArray(int[] nums) {
    int[] dp = new int[nums.length];
    dp[0] = nums[0];
    int res = dp[0];
    for (int i = 1; i < nums.length; i++) {
      dp[i] = Math.max(dp[i - 1] + nums[i], nums[i]);
      res = Math.max(res, dp[i]);
    }
    return res;
  }
}
```

### 例题3: 乘积最大子数组
[乘积最大子数组](https://leetcode.cn/problems/maximum-product-subarray/)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220614110829.png)

#### 分析
- 子问题：dp[i]="**以nums[i]结尾**的连续子数组中，可以产生的最大乘积`dp[i][0]`与最小乘积`dp[i][1]`"
- 初始条件：dp[0] = new int[]{nums[0], nums[0]}
- 递推表达式：
  - `dp[i][0] = Math.max(nums[i], Math.max(dp[i - 1][0] * nums[i], dp[i - 1][1] * nums[i]));`
  - `dp[i][1] = Math.min(nums[i], Math.min(dp[i - 1][0] * nums[i], dp[i - 1][1] * nums[i]));`
- 最后的解答：dp数组中最大值

代码：
```java
class Solution {
  public int maxProduct(int[] nums) {
    int[][] dp = new int[nums.length][2];
    dp[0] = new int[]{nums[0], nums[0]};
    int res = dp[0][0];
    for (int i = 1; i < nums.length; i++) {
      dp[i][0] = Math.max(nums[i], Math.max(dp[i - 1][0] * nums[i], dp[i - 1][1] * nums[i]));
      dp[i][1] = Math.min(nums[i], Math.min(dp[i - 1][0] * nums[i], dp[i - 1][1] * nums[i]));
      res = Math.max(res, dp[i][0]);
    }
    return res;
  }
}
```

### 例题4: 单词拆分
[单词拆分](https://leetcode.cn/problems/word-break/)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220614141710.png)

#### 分析
- 子问题：dp[i]="字符串s前i+1个字符组成的字符串`s[0..i]`是否能被空格拆分成若干个字典中出现的单词"
- 递推表达式：dp[i] = (j == 0 || dp[j - 1]) && wordDictSet.contains(s.substring(j, i + 1))
- 最后的解答：dp[s.length - 1]

代码：
```java
class Solution {
  public boolean wordBreak(String s, List<String> wordDict) {
    Set<String> wordDictSet = new HashSet(wordDict);
    boolean[] dp = new boolean[s.length()];
    for (int i = 0; i < s.length(); i++) {
      for (int j = 0; j <= i; j++) {
        if ( (j == 0 || dp[j - 1]) && wordDictSet.contains(s.substring(j, i + 1))) {
          dp[i] = true;
          break;
        }
      }
    }
    return dp[s.length() - 1];
  }
}
```

### 例题5: 爬楼梯
[爬楼梯](https://leetcode.cn/problems/climbing-stairs/)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220614152002.png)

#### 分析
- 子问题：dp[i]="爬到第i阶的方法种数"
- 初始问题：dp[1] = 1, dp[2] = 2
- 递推表达式：dp[i] = dp[i - 1] + dp[i - 2];
- 最后的解答：dp[n]

代码：
```java
class Solution {
  public int climbStairs(int n) {
    int[] dp = new int[n + 1];
    dp[1] = 1;
    if (n == 1) return dp[n];
    dp[2] = 2;
    for (int i = 3; i <= n; i++) {
      dp[i] = dp[i - 1] + dp[i - 2];
    }
    return dp[n];
  }
}
```

### 例题6: 解码方法
[解码方法](https://leetcode.cn/problems/decode-ways/)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220614172954.png)

#### 分析
- 子问题：dp[i]="字符串s前i+1个字符组成的字符串`s[0..i]`的编码方法个数"
- 初始化：
  - dp[0] = s.charAt(0) == '0' ? 0 : 1;
  - dp[1] = ((Integer.valueOf(s.substring(0, 2)) >= 10 && Integer.valueOf(s.substring(0, 2)) <= 26) ? 1 : 0) + (Integer.valueOf(s.substring(1, 2)) > 0 ? dp[0] : 0);
- 递推表达式：dp[i] = (Integer.valueOf(s.substring(i - 1, i + 1)) >= 10 && Integer.valueOf(s.substring(i - 1, i + 1)) <= 26 ? dp[i - 2] : 0) + (Integer.valueOf(s.substring(i, i + 1)) > 0 ? dp[i - 1] : 0);
- 最后的解答：dp[s.length - 1]

代码：
```java
class Solution {
  public int numDecodings(String s) {
    int[] dp = new int[s.length()];
    dp[0] = s.charAt(0) == '0' ? 0 : 1;
    if (s.length() == 1) return dp[0];
    dp[1] = ((Integer.valueOf(s.substring(0, 2)) >= 10 && Integer.valueOf(s.substring(0, 2)) <= 26) ? 1 : 0) + (Integer.valueOf(s.substring(1, 2)) > 0 ? dp[0] : 0);
    for (int i = 2; i < s.length(); i++) {
      dp[i] = (Integer.valueOf(s.substring(i - 1, i + 1)) >= 10 && Integer.valueOf(s.substring(i - 1, i + 1)) <= 26 ? dp[i - 2] : 0) + (Integer.valueOf(s.substring(i, i + 1)) > 0 ? dp[i - 1] : 0);
    }
    return dp[s.length() - 1];
  }
}
```

## 闫式dp分析法
核心思想：从集合的角度考虑
<font color="red">所有的dp问题，本质上都是有限集中的最值、数量问题</font>


![](https://raw.githubusercontent.com/NaisWang/images/master/20220408164542.png)

### 分析阶段
动态规划有两个要点：状态与状态转移
那么阶段自然也应该有两个：**状态表示**和**状态计算**
#### 状态表示
把几个具有相同点的元素合在一起考虑，成为一个状态
对于一个状态 F(i) ，考虑两个角度：
- **1.集合** ：F(i) 表示什么集合
由于 F(i) 表示的是一堆东西(这也是DP优于枚举的核心)，我们要考虑这一堆东西的共同特征，如：所有满足某个条件的元素集合
这一点请仔细考虑，到底是大于等于，大于，小于，小于等于，等于......这些的不同会导致状态计算方式的不同
- **2.属性**：F(i)的值与集合的关系：如 max,min,count,sum 等
很明显，F(i)的值大多数时候是一个数，代表这个集合的某一个属性，多是最大值、最小值、数量、总和等。题目问什么，属性一般就是什么

#### 状态计算
**三步走**
1. 先看 F(i) 表示的集合：

![](https://raw.githubusercontent.com/NaisWang/images/master/20220408182417.png)

2. 将其划分为若干个子集合，要求不重(有些情况可以重复，例如求最大值)和不漏

![](https://raw.githubusercontent.com/NaisWang/images/master/20220408182430.png)

<font color="red">划分的依据：找最后一个不同点(这个待会会讲)</font>

3. 划分过后，根据子集合来求F(i)
如：当属性为 max 时，F(i)=max(子集的max)
当属性为 count 时，F(i)=∑(子集的count)

#### 代码优化
dp问题的优化是对代码作等价变形，常用的手段是使用滚动数组

### 选择问题的dp
有关选择问题的dp，常见的就是背包问题。<font color="red">而选择问题的状态表示都是很相似的，一般状态的第一维表示我只考虑前面i个物品，后面几维一般表示限制，比如体积的限制，重量的限制</font>

#### 0-1背包问题
[0-1背包问题-模板题](https://www.acwing.com/problem/content/2/)
在上述例题中，由于每个物体只有2种可能的状态（取与不取），正如二进制中的0和1，这类问题便被称为「0-1 背包问题」。

**1. 解析**
根据乘法原理，总共的方案为$2^n$  。在所有的方案数中选择一个价值最大的方案，属于有限集的最优问题，可以用试着DP来解。

**2. 状态表示**
对于F(i,j)：
集合：所有只考虑前i个物品，且总体积不超过的j的方案
属性：题目要求我们求最大价值，则其属性就是max。

**3. 状态计算**

![](https://raw.githubusercontent.com/NaisWang/images/master/20220408182442.png)

于是我们可以得到状态转移方程：
$F(i,j)=max( F(i−1,j) , F(i−1,j−V_i)+W_i)$
这就事朴素DP的分析过程了，至于压维等时空优化从状态转移方程出发

**代码**
```java
/**
* n: 表示物品数量
* m: 表示背包容积
* v[]: 表示第 i 件物品的体积
* w[]: 表示第 i 件物品的价值
*/
public static int f(){
  int[][] dp = new int[N+1][V+1];
  for(int i = 1; i <= N; i++){
    for(int j = 0; j <= V; j++){
      dp[i][j] = dp[i-1][j];
      if(j >= v[i]) dp[i][j] = Math.max(dp[i][j], dp[i-1][j-v[i]]+w[i]);
    }
  }
  return dp[N][V];
}
```

#### 完全背包问题
[完全背包问题-模板题](https://www.acwing.com/problem/content/3/)
完全背包问题与0-1背包问题的不同点在于完全背包问题中的每种物品都有无限件可用

**1. 解析**
仍然从两个角度考虑：
设状态 F(i,j)

**2. 状态表示**
对于 F(i,j):
集合：所有只从前i个物品中选，总体积不超过j的所有方案。
属性：max。
原因和01背包相似

**3. 状态计算**

![](https://raw.githubusercontent.com/NaisWang/images/master/20220408182455.png)

于是易得状态转移方程：
`$F(i,j)=max( F(i−1,j), F(i−1,j−V_i)+W_i, F(i−1,j−2*V_i)+2*W_i,...)$`

但是这个东西项数太多，想办法把它转换成两项

由上面的状态转移方程我们可以得到：
`$F(i,j−V_i)=max( F(i−1,j−V_i), F(i−1,j−2*V_i)+W_i, F(i−1,j−3*V_i)+2*W_i ,...)$`
观察得到，上面的第二项后面的每一项都是下面的每一项加上一个$W_i$。

于是我们可以得到状态转移方程：
$F(i,j)=max(F(i−1,j) , F(i,j−V_i)+W_i)$


**代码**
```java
/**
* n: 表示物品数量
* m: 表示背包容积
* v[]: 表示第 i 件物品的体积
* w[]: 表示第 i 件物品的价值
*/
public static int f(){
  int[][] dp = new int[n+1][m+1];
  for(int i = 1; i <= n; i++){
    for(int j = 0; j <= m; j++){
      dp[i][j] = dp[i-1][j];
      if(j >= v[i]) f[i][j] = Math.max(dp[i][j], dp[i][j-v[i]]+w[i]);
    }
  }
  return f[n][m];
}
```

### 区间Dp
顾名思义：区间dp就是在区间上进行动态规划，求解一段区间上的最优解。主要是通过合并小区间的 最优解进而得出整个大区间上最优解的dp算法。

有关区间dp，常见的就是石子合并问题。<font color="red">而区间dp的状态表示都是很相似的，一般状态的第一维表示区间的左端点，第二维表示区间的右端点</font>

#### 石子合并问题
[石子合并题目链接](https://www.acwing.com/problem/content/284/)

**解析**
满足有限集最优化

**状态表示**
对于F(i,j)
集合：所有将区间`[i,j]`合并成一堆的方案集合
属性：题目求的是最小值，所以min。

**状态计算**
1. 看这个F(i,j)表示的集合：

![](https://raw.githubusercontent.com/NaisWang/images/master/20220408162412.png)

2. 将其划分若干个子集合
考虑最后一个不同点
最后一次， 也就是合并到`[i,j]`时，一定是由两个区间`[i,k]`和`[k,j]`合并而来的。显然，k∈`[i,j]`
所以我们考虑以这个分界点 k 为划分依据，分成 j−i 类。

![](https://raw.githubusercontent.com/NaisWang/images/master/20220408162422.png)

再来看一下合并的区间：

![](https://raw.githubusercontent.com/NaisWang/images/master/20220408162433.png)

3. 根据子集合求F(i, j)
以 左边`[i, i+2]`与右边`[i+3, j]`合并成一堆的子集合 为例 ，左边的`[i, i+2]`区间与右边的`[i+3, j]`区间互不干扰，所以两边取min再加上这部分石子的总质量，即为这个子集合的最小值，两边恰好是 F(i,i+2) 和 F(i+3,j)。于是这个子集合的最小代价为$F(i,i+2)+F(i+3,j)+S_j−S_{i−1}$ ，S是石子重量的前缀和。

所以状态转移方程为：
$F(i,j)=min( F(i, i)+F(i+1, j), F(i, i+1)+F(i+2, j), F(i, i+2)+F(i+3,j), ..., F(i, i+k)+F(i+k+1, j), ..., F(i, i+j-1)+F(j,j) ) + S_j-S_{i-1}$

**代码**
```java
public static int f(){
  int[][] f = new int[n+1][n+1];
  for(int len = 2; len <= n; len++){  //len表示区间的长度
    for(int i = 1; i+len-1 <= n; i++){ //i表示区间的左端点
      int j = i+len-1; //j表示区间的右端点
      f[i][j] = Integer.MAX_VALUE;
      for(int k = i; k < j; k++){
        f[i][j] = Math.min(f[i][j], f[i][k]+f[k+1][j]);
      }
      f[i][j] = f[i][j] + s[j] - s[i-1];
    }
  } 
  return f[1][n];
}
```

# 数论
## 常用数的整除特征

<div class="container">
  <iframe width="560" height="315" src="https://www.youtube.com/embed/d2ziUoPM9rE" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>

### 方法

#### 末位法
- 能否被`2`，`5`整除，看末一位能否被2，5整除
- 能否被`4`，`25`整除，看末二位能否被4，25整除
- 能否被`8`，`125`整除，看末三位能否被8，125整除
- 能否被$2^n$，$5^n$整除，看末n位能否被$2^n$，$5^n$整除

例如：
- 2025的为末一位能被5整除，则2025能被5整除
- 2025的为末二位能被25整除，则2025能被25整除

#### 数和法
判断数A能否被`3`，`9`整除：把各位数字加起来，如果能被3，9整除，则数A能被3，9整除

例如：
- 2019的各位数字加起来为12，12能被3整除，所以2019能被3整除

#### 数差法
判断数A能否被`11`整除：如果`奇数位数字和`与`偶数位数字和`之差能被11整除，则数A能被11整除

例如：
- 4356中的奇数位和为9，偶数位数字和为9，它们差为0，0能被11整除，则4356能被11整除

#### 截尾法
判断数A能否被`7`,`11`,`13` 整除：截掉后面3位，如果截断后的数字与后面3位数字之差能被7，11，13整除，则数A能被7，11，13整除

例如：
- 2023截掉后面3位后值为2，2与023之差为21，21能被7整除，所以2023能被7整除

### 例题
在acm中，会出现让你计算一个字符串中能被$2^n$或$5^n$整除的子串个数。如果暴力枚举每个子串进行统计的话，时间复杂度为$O(n^2)$,会TLE。

我们可以使用末尾法来进行统计能被$2^n$或$5^n$整除的子串个数。见例题1

#### 例题1: 整除子串
[整除子串](https://www.acwing.com/problem/content/4429/)

给定一个由数字组成的字符串 s，请你计算能够被 4 整除的 s 的子串数量。

子串可以包含前导 0。

例如，如果 s 为 124，则满足条件的子串有 4 个：12，4，24，124；如果 s 为 04，则满足条件的子串有 3 个：0，4，04。

输入格式: 一个由数字组成的字符串 s。

输出格式:一个整数，表示满足条件的子串数量。

数据范围
- 前 4 个测试点满足 1≤|s|≤10。
- 所有测试点满足 1≤|s|≤3×10^5。

输入样例1：
```txt
124
```
输出样例1：
```txt
4
```
输入样例2：
```txt
04
```
输出样例2：
```txt
3
```
输入样例3：
```txt
5810438174
```
输出样例3：
```txt
9
```

##### 分析：
视频讲解:

<div class="container">
  <iframe width="560" height="315" src="https://www.youtube.com/embed/SwneFgy_MxU" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>

代码：
```java
String str = cin.nextLine();

public void solve() {
  Long res = 0l;
  char[] charArray = str.toCharArray();
  for (int i = 0; i < charArray.length; i++) {
    if (Integer.valueOf(charArray[i]) % 4 == 0) {
      res++;
    }
    if (i != 0 && Integer.valueOf(charArray[i - 1] + "" + charArray[i]) % 4 == 0) {
      res += i;
    }
  }
  System.out.println(res);
}
```

## a+b的巧算

a+b == (a^b)+(a&b<<1)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220408162452.png)

不用加减乘除做加法
```java
public int add(int a, int b){
  while(b != 0){
    int sum = a^b;
    int carry = (a&b)<<1;
    a = sum;
    b = carry;
  }
  return b;
} 
```

## 同余
预备知识：
- $\frac{a}{b}$，a称为被除数，b是除数。记为：a被b除，或b除a
- $n | x$, 说明是n整除x，也就是x能被n整除，说明x是被除数，n是除数

数论中的重要概念。给定一个正整数m，如果两个整数a和b满足a-b能够被m整除，即(a-b)/m得到一个整数，那么就称整数a与b对模m同余，记作a≡b(mod m)。对模m同余是整数的一个等价关系，即：
$$m \mid (a-b) \iff a \equiv b\pmod {m}$$

## 位运算
题目
[191.位1的个数](https://leetcode-cn.com/problems/number-of-1-bits)
[231.2的幂](https://leetcode-cn.com/problems/power-of-two/)

---
本文分两部分，第一部分列举几个有趣的位操作，第二部分讲解算法中常用的 n & (n - 1) 操作，顺便把用到这个技巧的算法题列出来讲解一下。因为位操作很简单，所以假设读者已经了解与、或、异或这三种基本操作。

位操作（Bit Manipulation）可以玩出很多奇技淫巧，但是这些技巧大部分都过于晦涩，没必要深究，读者只要记住一些有用的操作即可。

### 几个有趣的位操作
**1. 利用或操作 | 和空格将英文字符转换为小写**
```
('a' | ' ') = 'a'
('A' | ' ') = 'a'
```
**2. 利用与操作 & 和下划线将英文字符转换为大写**
```
('b' & '_') = 'B'
('B' & '_') = 'B'
```
**3. 利用异或操作 ^ 和空格进行英文字符大小写互换**
```
('d' ^ ' ') = 'D'
('D' ^ ' ') = 'd'
```
以上操作能够产生奇特效果的原因在于 ASCII 编码。字符其实就是数字，恰巧这些字符对应的数字通过位运算就能得到正确的结果，有兴趣的读者可以查 ASCII 码表自己算算，本文就不展开讲了。
**4. 判断两个数是否异号**
```
int x = -1, y = 2;
bool f = ((x ^ y) < 0); // true

int x = 3, y = 2;
bool f = ((x ^ y) < 0); // false
```
这个技巧还是很实用的，利用的是补码编码的符号位。如果不用位运算来判断是否异号，需要使用 if else 分支，还挺麻烦的。读者可能想利用乘积或者商来判断两个数是否异号，但是这种处理方式可能造成溢出，从而出现错误。

### 算法常用操作
`n&(n-1)`这个操作是算法中常见的，作用是消除数字 n 的二进制表示中的最后一个 1。
看个图就很容易理解了：

![](https://raw.githubusercontent.com/NaisWang/images/master/20220408162504.png)

其核心逻辑就是，n - 1 一定可以消除最后一个 1，同时把其后的 0 都变成 1，这样再和 n 做一次 & 运算，就可以仅仅把最后一个 1 变成 0 了。

**1. 计算汉明权重（Hamming Weight）**

![](https://raw.githubusercontent.com/NaisWang/images/master/20220408162514.png)

就是让你返回 n 的二进制表示中有几个 1。因为 n & (n - 1) 可以消除最后一个 1，所以可以用一个循环不停地消除 1 同时计数，直到 n 变成 0 为止。
```java
int hammingWeight(uint32_t n) {
    int res = 0;
    while (n != 0) {
        n = n & (n - 1);
        res++;
    }
    return res;
}
```
**2. 判断一个数是不是 2 的指数**
一个数如果是 2 的指数，那么它的二进制表示一定只含有一个 1：
```
2^0 = 1 = 0b0001
2^1 = 2 = 0b0010
2^2 = 4 = 0b0100
```
如果使用 n&(n-1) 的技巧就很简单了（注意运算符优先级，括号不可以省略）：
```java
bool isPowerOfTwo(int n) {
    if (n <= 0) return false;
    return (n & (n - 1)) == 0;
}
```

**3. 查找只出现一次的元素**
这里就可以运用异或运算的性质：
一个数和它本身做异或运算结果为 0，即 a ^ a = 0；一个数和 0 做异或运算的结果为它本身，即 a ^ 0 = a。

对于这道题目，我们只要把所有数字进行异或，成对儿的数字就会变成 0，落单的数字和 0 做异或还是它本身，所以最后异或的结果就是只出现一次的元素：

```java
int singleNumber(vector<int>& nums) {
    int res = 0;
    for (int n : nums) {
        res ^= n;
    }
    return res;
}
```

## 快速幂
快速幂，二进制取幂（Binary Exponentiation，也称平方法），是一个在$O(logn)$的时间内计算$a^n$的小技巧，而暴力的计算需要$O(n)$的时间。而这个技巧也常常用在非计算的场景，因为它可以应用在任何具有结合律的运算中。其中显然的是它可以应用于模意义下取幂、矩阵幂等运算，我们接下来会讨论。

![](https://raw.githubusercontent.com/NaisWang/images/master/20220408162524.png)

### 模板
$求a^n$
递归版
```java
public long binpow(long a, long n){
  if(n == 0) return 1;
  long res = binpow(a, n/2);
  if(n%2 == 1) 
    return res*res*a;
  else
    return res*res;
}
```
非递归版
```java
public static long binpow(long a, long n){
  long res = 1;
  while(n > 0){
    if((n & 1) == 1) res = res * a; 
    a = a * a;
    n >>= 1;
  }
  return res;
}
```

**题目链接**
[a^b](https://www.acwing.com/problem/content/submission/91/)

## 64位整数乘法 
求`(a*b)%p`，

如果直接计算a乘b这会超过long的最大范围，所以采用类似于快速幂的思想把 b写成二进制形式，然后如果某位上为1就加上它`a*（2^n）`次方（n与这位的位置有关）并且每次计算后取模就可以了

例如：计算`3*7`， 由于7的二进制为111, 所以`$3*7 = 3*(2^0)+3*(2^1)+3*(2^2)$`

### 模板
求`(a*b)%p`

```java
public static long ksc(long a, long b, long p){
  long res = 0;
  while(b > 0){
    if((b&1) == 1) res = (res+a)%p;
    b >>= 1;
    a = 2*a%p;
  }
  return res;
}
```

# 区间信息维护与查询

<div class="container">
  <iframe src="https://drive.google.com/file/d/15qVlx2wnt89JZWzfGKQ3P43IbK4UNJF1/preview" width="640" height="480" allow="autoplay"></iframe>
</div>

<div class="container">
  <iframe width="560" height="315" src="https://www.youtube.com/embed/zxPdekOBfTo" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>

<div class="container">
  <iframe width="560" height="315" src="https://www.youtube.com/embed/MocAQVJfJOQ" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>


## 二分堆与二叉搜索树
- 如果只需要找最值，就用`二分堆(PrioityQueue)`。
- 如果我不止需要找到最值，还要进行搜索、删除指定元素、`lower_bound`或`upper_bound`操作，就用`二叉搜索树(TreeSet/TreeMap)`。

### 动态排行问题 (Heap和BST的应用)
#### K是固定值时
##### 实现方式一: 大根堆加小根堆
维护一个最大(映射)堆A和一个最小(映射)堆B，A里面维护当前数据集合的前K大的元素，B里面维护其他的元素，那么A的根就是当前集合里的第k大元素。

此算法的复杂度为O(nlogk);

##### 模版
```java
class FindKthByHeap {
  private int[] nums;
  // 所要找的第几大的元素
  int k;

  /**
   * 创建大根堆与小根堆。
   * 堆存储堆是元素的id。即nums的下标
   */
  Comparator<Integer> comparator = (a, b) -> nums[a] != nums[b] ? Integer.compare(nums[a], nums[b]) : a - b;
  TreeSet<Integer> maxHeap = new TreeSet<>(comparator.reversed());
  TreeSet<Integer> minHeap = new TreeSet<>(comparator);

  public FindKthByHeap(int[] nums, int k) {
    this.nums = nums;
    this.k = k;
  }

  /**
   * 往堆中添加元素
   */
  public void add(int itemId) {
    minHeap.add(itemId);
    maxHeap.add(minHeap.pollFirst());
    balance();
  }

  /**
   * 通过给定的元素id删除堆中对应的元素
   *
   * @param itemId 元素的id
   */
  public void remove(int itemId) {
    if (!maxHeap.remove(itemId)) {
      minHeap.remove(itemId);
    }
  }

  /**
   * @return 第k大元素的id
   */
  public int getKthItemId() {
    return maxHeap.first();
  }

  /**
   * @return 第k大元素
   */
  public int getKthItem() {
    return nums[maxHeap.first()];
  }


  /**
   * @return 第k+1大元素的id
   */
  public int getK1thItemId() {
    return minHeap.first();
  }

  /**
   * @return 第k+1大元素
   */
  public int getK1thItem() {
    return nums[minHeap.first()];
  }

  /**
   * 维持大根堆元素个数小于等于k
   */
  private void balance() {
    while (maxHeap.size() > k) {
      minHeap.add(maxHeap.pollFirst());
    }
  }

  }
```
注意的比较器不能写成下面形式： 
```java
Comparator<Integer> comparator = (a, b) -> Integer.compare(nums[a], nums[b]);
```
之所以不写成上述形式的原因是因为TreeSet存的是元素的id。如果a与b分别是2个不同的元素的id的话，那么a与b是不会相同的。 但是按照上述比较器的话，a与b是会相同的。例如当a=1, b=2,且num[1]等于num[2]时，如果按照上述比较器的话，`Integer.compare(nums[a], nums[b])`返回0，表示a等于b，由于TreeSet中是无重复元素的, 所以TreeSet中不会同时出现a与b。而这显然与需求不符合。所以比较器应该写成如下形式： 
```java
Comparator<Integer> comparator = (a, b) -> nums[a] != nums[b] ? Integer.compare(nums[a], nums[b]) : a - b;
```

###### 例题1: 滑动窗口中位数
[滑动窗口中位数](https://leetcode.cn/problems/sliding-window-median/)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220603194139.png)

代码：
```java
class Solution {
  public double[] medianSlidingWindow(int[] nums, int k) {
    FindKthByHeap findKthByHeap = new FindKthByHeap(nums, (int)Math.ceil(k / 2.0));
    double[] res = new double[nums.length - k + 1];
    for (int i = 0; i < k; i++) {
      findKthByHeap.add(i);
    }
    if (k % 2 == 0) {
      res[0] = ((double) findKthByHeap.getKthItem() + findKthByHeap.getK1thItem()) / 2.0;
    } else {
      res[0] = (double) findKthByHeap.getKthItem();
    }
    
    int j = 1;
    for (int i = k; i < nums.length; i++) {
      findKthByHeap.remove(i - k);
      findKthByHeap.add(i);
      if (k % 2 == 0) {
        res[j++] = ((double) findKthByHeap.getKthItem() + findKthByHeap.getK1thItem()) / 2.0;
      } else {
        res[j++] = (double) findKthByHeap.getKthItem();
      }
    }
    return res;
  }


  class FindKthByHeap {
    private int[] nums;
    // 所要找的第几大的元素
    int k;

    /**
      * 创建大根堆与小根堆。
      * 堆存储堆是元素的id。即nums的下标
      */
    Comparator<Integer> comparator = (a, b) -> nums[a] != nums[b] ? Integer.compare(nums[a], nums[b]) : a - b;
    TreeSet<Integer> maxHeap = new TreeSet<>(comparator.reversed());
    TreeSet<Integer> minHeap = new TreeSet<>(comparator);

    public FindKthByHeap(int[] nums, int k) {
      this.nums = nums;
      this.k = k;
    }

    public void add(int itemId) {
      minHeap.add(itemId);
      maxHeap.add(minHeap.pollFirst());
      balance();
    }

    /**
      * @return 第k大元素的id
      */
    public int getKthItemId() {
      return maxHeap.first();
    }

    /**
      * @return 第k大元素
      */
    public int getKthItem() {
      return nums[maxHeap.first()];
    }


    /**
      * @return 第k+1大元素的id
      */
    public int getK1thItemId() {
      return minHeap.first();
    }

    /**
      * @return 第k+1大元素
      */
    public int getK1thItem() {
      return nums[minHeap.first()];
    }

    /**
      * 通过给定的元素id删除堆中对应的元素
      *
      * @param itemId 元素的id
      */
    public void remove(int itemId) {
      if (!maxHeap.remove(itemId)) {
        minHeap.remove(itemId);
      }
    }

    /**
      * 维持大根堆元素个数小于等于k
      */
    private void balance() {
      while (maxHeap.size() > k) {
        minHeap.add(maxHeap.pollFirst());
      }
    }

  }

} 
```

###### 例题2: 找出数组中的第 K 大整数
[找出数组中的第 K 大整数](https://leetcode.cn/problems/find-the-kth-largest-integer-in-the-array/)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220603231915.png)

注意：这里的第K大正数的定义有点不同

```java
class Solution {
  public String kthLargestNumber(String[] nums, int k) {
    FindKthByHead findKthByHead = new FindKthByHead(k, nums);
    for (int i = 0; i < nums.length; i++) {
      findKthByHead.add(i);
    }
    return findKthByHead.getKthItem();
  }

  class FindKthByHead {
    String[] nums;
    int k; 

    Comparator<Integer> comparator = (a, b) -> {

      // 注意：nums[a]等于nums[b]时不能返回0
      if (nums[a].equals(nums[b])) {
        return a - b;
      }

      if (nums[a].length() < nums[b].length()) {
        return -1;
      }
      if (nums[a].length() > nums[b].length()) {
        return 1;
      }
      return nums[a].compareTo(nums[b]);
    };
    TreeSet<Integer> maxHeap = new TreeSet<>(comparator.reversed());
    TreeSet<Integer> minHeap = new TreeSet<>(comparator); 

    public FindKthByHead(int k, String[] nums) {
      this.k = k;
      this.nums = nums;
    } 

    public void add(int itemId) {
      maxHeap.add(itemId);
      minHeap.add(maxHeap.pollFirst());
      balance();
    }
    
    public String getKthItem() {
      return nums[minHeap.first()];
    }

    private void balance() {
      while (minHeap.size() > k) {
        maxHeap.add(minHeap.pollFirst());
      }
    }
  }
}
```

## 前缀和
前缀和的思路是这样的，对于一个给定的数组 nums，我们额外开辟一个前缀和数组进行预处理：
```java
int n = nums.length;
// 前缀和数组
int[] preSum = new int[n + 1];
preSum[0] = nums[0];
for (int i = 1; i < n; i++) {
  preSum[i] = preSum[i - 1] + nums[i];
}
```

### 例题1: 转角路径的乘积中最多能有几个尾随零
[转角路径的乘积中最多能有几个尾随零](https://leetcode.cn/problems/maximum-trailing-zeros-in-a-cornered-path/)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220609164612.png)

#### 分析
因子分解：尾数0的个数由乘积因子中10的个数所决定，而10又由`2*5`组成。
- 两个2和两个5可组成两个10：`2 * 5 * 2 * 5 = 100`
- 三个2和两个5可组成两个10：`2 * 5 * 2 * 5 * 2 = 200`

可发现，对于一个整数num而言，其质因子中2和5的数目的较小值即为尾数0的数目。

因此，一条路径的乘积中尾数0的个数，即为该条路径中各个乘数所包含的因子2的个数和与因子5的个数和的较小者。

因此先用前缀和维护每一行和每一列因子2与因子5的数量，再枚举拐点计算答案即可。

代码：
```java
class Solution {
  
    static int[][] c25 = new int[1001][2];
    static {
        // 预处理：递推算出每个数的因子 2 的个数和因子 5 的个数
        for (int i = 2; i <= 1000; i++) {
            if (i % 2 == 0) c25[i][0] = c25[i / 2][0] + 1;
            if (i % 5 == 0) c25[i][1] = c25[i / 5][1] + 1;
        }
    }

    public int maxTrailingZeros(int[][] grid) {
      // 不同行的前缀和
      // rowPreSum[i][j][0]的第i行中前j列中能被2整除的个数
      // rowPreSum[i][j][1]的第i行中前j列中能被5整除的个数
      int[][][] rowPreSum = new int[grid.length][grid[0].length][2];
      // 不同列的前缀和
      // colPreSum[i][j][0]的第i列中前j行中能被2整除的个数
      // colPreSum[i][j][1]的第i列中前j行中能被5整除的个数
      int[][][] colPreSum = new int[grid[0].length][grid.length][2];
      
      for (int r = 0; r < grid.length; r++) {
        rowPreSum[r][0][0] = c25[grid[r][0]][0];
        rowPreSum[r][0][1] = c25[grid[r][0]][1];
        for (int c = 1; c < grid[0].length; c++) {
          rowPreSum[r][c][0] = rowPreSum[r][c - 1][0] + c25[grid[r][c]][0];
          rowPreSum[r][c][1] = rowPreSum[r][c - 1][1] + c25[grid[r][c]][1];
        }
      }
      
      for (int c = 0; c < grid[0].length; c++) {
        colPreSum[c][0][0] = c25[grid[0][c]][0];
        colPreSum[c][0][1] = c25[grid[0][c]][1];
        for (int r = 1; r < grid.length; r++) {
          colPreSum[c][r][0] = colPreSum[c][r - 1][0] + c25[grid[r][c]][0];
          colPreSum[c][r][1] = colPreSum[c][r - 1][1] + c25[grid[r][c]][1];
        }
      }
      
      int res = Integer.MIN_VALUE;
      for (int r = 0; r < grid.length; r++) {
        for (int c = 0; c < grid[0].length; c++) {
          
          int tempRowLeftFor2 = rowPreSum[r][c][0];
          int tempRowRightFor2 = rowPreSum[r][grid[0].length -1][0] - rowPreSum[r][c][0] + c25[grid[r][c]][0];
          int tempColUpFor2 = colPreSum[c][r][0];
          int tempColDownFor2 = colPreSum[c][grid.length - 1][0] - colPreSum[c][r][0] + c25[grid[r][c]][0];
          
          int tempRowLeftFor5 = rowPreSum[r][c][1];
          int tempRowRightFor5 = rowPreSum[r][grid[0].length -1][1] - rowPreSum[r][c][1] + c25[grid[r][c]][1];
          int tempColUpFor5 = colPreSum[c][r][1];
          int tempColDownFor5 = colPreSum[c][grid.length - 1][1] - colPreSum[c][r][1] + c25[grid[r][c]][1];
          
          int leftUpFor2 = tempRowLeftFor2 + tempColUpFor2 - c25[grid[r][c]][0];
          int leftUpFor5 = tempRowLeftFor5 + tempColUpFor5 - c25[grid[r][c]][1];
          int leftUp = Math.min(leftUpFor2, leftUpFor5);
          
          res = Math.max(res, leftUp);
          
          int leftDownFor2 = tempRowLeftFor2 + tempColDownFor2 - c25[grid[r][c]][0];
          int leftDownFor5 = tempRowLeftFor5 + tempColDownFor5 - c25[grid[r][c]][1];
          int leftDown = Math.min(leftDownFor2, leftDownFor5);
          res = Math.max(res, leftDown);
          
          int rightUpFor2 = tempRowRightFor2 + tempColUpFor2 - c25[grid[r][c]][0];
          int rightUpFor5 = tempRowRightFor5 + tempColUpFor5 -c25[grid[r][c]][1]; 
          int rightUp = Math.min(rightUpFor2, rightUpFor5);
          res = Math.max(res, rightUp);
          
          int rightDownFor2 = tempRowRightFor2 + tempColDownFor2 - c25[grid[r][c]][0];
          int rightDownFor5 = tempRowRightFor5 + tempColDownFor5 - c25[grid[r][c]][1];
          int rightDown = Math.min(rightDownFor2, rightDownFor5);
          res = Math.max(res, rightDown);
           
        }
      }
      return res;  
    }

}
```

### 例题2：选择建筑的方案数
[选择建筑的方案数](https://leetcode.cn/problems/number-of-ways-to-select-buildings/)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220611112135.png)

#### 分析
参考：https://leetcode.cn/problems/number-of-ways-to-select-buildings/solution/by-baoya_uncle-qsr8/

对任意一个位置，以它为中心构建合法相邻建筑的数量，分两种情况讨论：
- 该位置左侧1的数量`*`该位置右侧1的数量 （若该位置为0 ）。这样可以构成101。
- 该位置左侧0的数量`*`该位置右侧0的数量 （若该位置为1 ）。这样可以构成010。
两种情况分别举个例子：

例子一：
![](https://raw.githubusercontent.com/NaisWang/images/master/20220611112325.png)

例子二：
![](https://raw.githubusercontent.com/NaisWang/images/master/20220611112338.png)

算法部分，
1. 从左往右遍历一次，统计每个位置左侧0或者1的数量。 统计0还是1取决于该位置是1还是0。
2. 再从右往左遍历一次，统计每个位置右侧侧0或者1的数量 。
3. 同一位置，左侧0或1侧数量，和右侧0或1侧数量相乘，即为以该位置贡献的答案数量，对每个位置的贡献量求和，即为返回答案。

代码：
```java
class Solution {
  public long numberOfWays(String s) {
    char[] charArray = s.toCharArray();
    int n = charArray.length;
    long[] preSumFor1 = new long[n];
    long[] preSumFor0 = new long[n];
    preSumFor1[0] = (charArray[0] == '1') ? 1 : 0;
    preSumFor0[0] = (charArray[0] == '0') ? 1 : 0;
    for (int i = 1; i < n; i++) {
      if (charArray[i] == '1') {
        preSumFor1[i] = preSumFor1[i - 1] + 1;
        preSumFor0[i] = preSumFor0[i - 1];
      } else {
        preSumFor0[i] = preSumFor0[i - 1] + 1;
        preSumFor1[i] = preSumFor1[i - 1];
      }
    }
    long res = 0;
    for (int i = 1; i < n - 1; i++) {
      if (charArray[i] == '0') {
        res += preSumFor1[i - 1] * (preSumFor1[n - 1] - preSumFor1[i]);
      } else {
        res += preSumFor0[i - 1] * (preSumFor0[n - 1] - preSumFor0[i]);
      }
    }
    return res;
  }
}
```

### 例题3: 字符串中最多数目的子字符串
[字符串中最多数目的子字符串](https://leetcode.cn/problems/maximize-number-of-subsequences-in-a-string/)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220611120412.png)

#### 分析
最优的情况下，肯定是 pattern[0] 插入到 text 开头或 pattern[1] 插入到 text 结尾。分别统计一下哪个子序列最多。

使用前缀和来统计text中pattern[0]出现的次数

代码： 
```java
class Solution {
  public long maximumSubsequenceCount(String text, String pattern) {
    
    String textTemp = pattern.charAt(0) + text;
    char[] charArray = textTemp.toCharArray();
    int[] preSum1 = new int[textTemp.length()];
    preSum1[0] = 1;
    for (int i = 1; i < charArray.length; i++) {
      preSum1[i] = preSum1[i - 1] + (charArray[i] == charArray[0] ? 1 : 0);
    }
    long res = 0;
    for (int i = 1; i < charArray.length; i++) {
      if (charArray[i] == pattern.charAt(1)) {
        res += preSum1[i - 1];
      }
    }

    String textTemp1 = text + pattern.charAt(1);
    char[] charArray1 = textTemp1.toCharArray();
    int[] preSum2 = new int[textTemp1.length()];
    preSum2[0] = (charArray1[0] == pattern.charAt(0)) ? 1 : 0;
    for (int i = 1; i < charArray1.length; i++) {
      preSum2[i] = preSum2[i - 1] + (charArray1[i] == pattern.charAt(0) ? 1 : 0);
    }
    long res2 = 0;
    for (int i = 1; i < charArray1.length; i++) {
      if (charArray1[i] == pattern.charAt(1)) {
        res2 += preSum2[i - 1];
      }
    }
    return Math.max(res, res2);
  }
}
```

## 倍增、ST表

<div class="container">
  <iframe src="https://drive.google.com/file/d/1JCC9ncNlTOYHGz0hnxigX5btGzXpRz1-/preview" width="640" height="480" allow="autoplay"></iframe>
</div>

<div class="container">
  <iframe width="560" height="315" src="https://www.youtube.com/embed/aqQToXiQ7S4" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>

### 一维ST表
#### 模版
```java
class ST {
  // F[i][j]: 表示[i, i+2^j-1]区间的最值
  int[][] F;

  public ST(int[] nums) {
    int n = nums.length;
    int k = (int) (Math.log(n) / Math.log(2));
    // 初始化F数组
    F = new int[n][k + 1];
    for (int i = 0; i < n; i++) {
      F[i][0] = nums[i];
    }
    for (int j = 1; j <= k; j++) {
      for (int i = 0; i < n - (1 << j) + 1; i++) {
        F[i][j] = Math.max(F[i][j - 1], F[i + (1 << (j - 1))][j - 1]);
      }
    }
  }

  // 求区间[l..r]的最值
  int query(int l, int r) {
    if (l > r) {
      // TODO
    }
    int k = (int) (Math.log(r - l + 1) / Math.log(2));
    return Math.max(F[l][k], F[r - (1 << k) + 1][k]);
  }

}
```

#### 例题1: 平衡的阵容
[平衡的阵容](http://poj.org/problem?id=3264)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220604142745.png)

```java
int N = cin.nextInt();
int Q = cin.nextInt();
int[] nums = new int[N];

public void solve() {
  read(nums);
  ST st = new ST(nums);
  while (Q-- != 0) {
    int l = cin.nextInt();
    int r = cin.nextInt();
    System.out.println(st.query(l - 1, r - 1));
  }
}

class ST {
  // F[i][j][0]: 表示[i, i+2^j-1]区间的最大值
  // F[i][j][1]: 表示[i, i+2^j-1]区间的最小值
  int[][][] F;

  public ST(int[] nums) {
    int n = nums.length;
    int k = (int) (Math.log(n) / Math.log(2));
    // 初始化F数组
    F = new int[n][k + 1][2];
    for (int i = 0; i < n; i++) {
      F[i][0] = new int[]{nums[i], nums[i]};
    }
    for (int j = 1; j <= k; j++) {
      for (int i = 0; i < n - (1 << j) + 1; i++) {
        F[i][j][0] = Math.max(F[i][j - 1][0], F[i + (1 << (j - 1))][j - 1][0]);
        F[i][j][1] = Math.min(F[i][j - 1][1], F[i + (1 << (j - 1))][j - 1][1]);
      }
    }
  }

  // 求区间[l..r]的最值
  int query(int l, int r) {
    int k = (int) (Math.log(r - l + 1) / Math.log(2));
    return Math.max(F[l][k][0], F[r - (1 << k) + 1][k][0]) - Math.min(F[l][k][1], F[r - (1 << k) + 1][k][1]);
  }

}
```

#### 例题2: 频繁值
[频繁值](http://poj.org/problem?id=3368)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220604155952.png)

#### 分析
因为是非降序的，所以可以从头遍历把每个相同的数字化为一个块，用`p[i]`表示第i个元素划分到哪个块里面，同时用`r[j]`和`l[j]`记第j个块的左右边界。同时freq数组用来记录每个块中数字个数，可以把freq数组处理成一个ST表

对于每个给定的查询区间，如果区间完全包含于某个块内，那么说明区间内所有数字相同，答案就是区间的长度。否则，该查询区间可以分为如下三个部分：
1. 最左侧`[i, r[p[i]]]`区间的一个块的部分
2. 最右侧`[l[p[j]], j]`区间的一个块的部分
3. 中间的`[r[p[i]] + 1, l[p[j]] - 1]`区间的某干个块
其中第1、2部分中重复的数字分别就是它们的区间长度。而第3部分可以通过ST表来求得。答案就是这三者取最大值

![](https://raw.githubusercontent.com/NaisWang/images/master/20220604162101.png)

代码： 
```java
public void solve() {
  while (true) {
    int n = cin.nextInt();
    if (n == 0) return;
    int q = cin.nextInt();
    int[] nums = new int[n];
    read(nums);
    int[] freq = new int[n];
    int[] p = new int[n]; // p[i]: 表示第i个元素位于哪个块
    int[] r = new int[n]; // r[i]: 表示第i块的右下标
    int[] l = new int[n]; // l[i]: 表示第i块的左下标
    int pId = 0; // 块编号
    int cnt = 0; // 当前块内的元素个数
    int nowP = nums[0]; // 当前块内的元素
    l[0] = 0;
    for (int i = 0; i < n; i++) {
      if (nums[i] != nowP) {
        r[pId] = i - 1;
        pId++;
        cnt = 0;
        nowP = nums[i];
        l[pId] = i;
      }
      cnt++;
      freq[i] = cnt;
      p[i] = pId;
    }
    r[pId] = n - 1;

    ST st = new ST(freq);

    while (q-- != 0) {
      int i = cin.nextInt();
      int j = cin.nextInt();
      i--;
      j--;

      // [i, j]在同一个块内时
      if (p[i] == p[j]) {
        System.out.println(j - i + 1);
      } else {
        // [i, j]不在同一个块内时
        int temp1 = r[p[i]] - i + 1;
        int temp2 = j - l[p[j]] + 1;
        int temp3 = st.query(r[p[i]] + 1, l[p[j]] - 1);
        System.out.println(Math.max((Math.max(temp1, temp2)), temp3));
      }

    }
  }
}

class ST {
  int F[][];

  public ST(int[] nums) {
    int n = nums.length;
    int k = (int) (Math.log(n) / Math.log(2));
    F = new int[n][k + 1];
    for (int i = 0; i < n; i++) {
      F[i][0] = nums[i];
    }
    for (int j = 1; j <= k; j++) {
      for (int i = 0; i < n - (1 << j) + 1; i++) {
        F[i][j] = Math.max(F[i][j - 1], F[i + (1 << (j - 1))][j - 1]);
      }
    }
  }

  int query(int l, int r) {
    if (l > r) {
      return 0;
    }
    int k = (int) (Math.log(r - l + 1) / Math.log(2));
    return Math.max(F[l][k], F[r - (1 << k) + 1][k]);
  }
}
```

假设当`nums=[-1, -1, 1, 1, 1, 1, 3, 10, 10, 10]`时：
- `freq = [1, 2, 1, 2, 3, 4, 1, 1, 2, 3]`
- `p    = [0, 0, 1, 1, 1, 1, 2, 3, 3, 3]`
- `l    = [0, 2, 6, 7, 0, 0, 0, 0, 0, 0]`
- `r    = [1, 5, 6, 9, 0, 0, 0, 0, 0, 0]`

### 二维ST表
求一个块内的最值，可以把块分成多行，每行求一次RMQ即可，因此也要对每一行建一个ST表。

#### 模版
```java
class ST {
  // F[r][i][j]: 表示第r行的[i, i+2^j-1]区间的最大值
  int F[][][];

  public ST(int[][] nums) {
    int n = nums[0].length;
    int k = (int) (Math.log(n) / Math.log(2));
    int row = nums.length;
    F = new int[row][n][k + 1];
    for (int r = 0; r < row; r++) {
      for (int c = 0; c < n; c++) {
        F[r][c][0] = nums[r][c];
      }
      for (int j = 1; j <= k; j++) {
        for (int i = 0; i < n - (1 << j) + 1; i++) {
          F[r][i][j] = Math.max(F[r][i][j - 1], F[r][i + (1 << (j - 1))][j - 1]);
        }
      }
    }
  }

  /**
   * @param row    矩阵左上顶点位于的行
   * @param col    矩阵左上顶点位于的列
   * @param width  矩阵宽度（即一行元素的个数）
   * @param height 矩阵高度（即一列元素的个数）
   * @return 矩阵范围内的最值
   */
  int query(int row, int col, int width, int height) {
    int max = Integer.MIN_VALUE;
    for (int r = row; r < height + row; r++) {
      int k = (int) (Math.log(width) / Math.log(2));
      // 右边界
      int rightCol = col + width - 1;
      max = Math.max(max, Math.max(F[r][col][k], F[r][rightCol - (1 << k) + 1][k]));
    }
    return max;
  }
}
```

#### 例题1: 玉米地
[玉米地](http://poj.org/problem?id=2019)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220604181746.png)

代码：
```java
int N = cin.nextInt();
int B = cin.nextInt();
int K = cin.nextInt();
int[][] map = new int[N][N];

public void solve() {
  read(map);
  ST st = new ST(map);
  while (K-- != 0) {
    int a = cin.nextInt();
    int b = cin.nextInt();
    System.out.println(st.query(a - 1, b - 1, B, B));
  }
}

class ST {
  // F[r][i][j][0]: 表示第r行的[i, i+2^j-1]区间的最大值
  // F[r][i][j][1]: 表示第r行的[i, i+2^j-1]区间的最小值
  int F[][][][];

  public ST(int[][] nums) {
    int n = nums[0].length;
    int k = (int) (Math.log(n) / Math.log(2));
    int row = nums.length;
    F = new int[row][n][k + 1][2];
    for (int r = 0; r < row; r++) {
      for (int c = 0; c < n; c++) {
        F[r][c][0] = new int[]{nums[r][c], nums[r][c]};
      }
      for (int j = 1; j <= k; j++) {
        for (int i = 0; i < n - (1 << j) + 1; i++) {
          F[r][i][j][0] = Math.max(F[r][i][j - 1][0], F[r][i + (1 << (j - 1))][j - 1][0]);
          F[r][i][j][1] = Math.min(F[r][i][j - 1][1], F[r][i + (1 << (j - 1))][j - 1][1]);
        }
      }
    }
  }

  int query(int row, int col, int width, int height) {
    int max = Integer.MIN_VALUE;
    int min = Integer.MAX_VALUE;
    for (int r = row; r < height + row; r++) {
      int k = (int) (Math.log(width) / Math.log(2));
      // 右边界
      int rightCol = col + width - 1;
      max = Math.max(max, Math.max(F[r][col][k][0], F[r][rightCol - (1 << k) + 1][k][0]));
      min = Math.min(min, Math.min(F[r][col][k][1], F[r][rightCol - (1 << k) + 1][k][1]));
    }
    return max - min;
  }
}
```

## 最近公共祖先LCA

<div class="container">
  <iframe width="560" height="315" src="https://www.youtube.com/embed/YFOcVHsBO78" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>

<div class="container">
  <iframe src="https://drive.google.com/file/d/1S0TDNDZpNpNBsNZm0NBEgHEUTTa-7dcL/preview" width="640" height="480" allow="autoplay"></iframe>
</div>

<div class="container">
  <iframe width="560" height="315" src="https://www.youtube.com/embed/161vSYEqJVE" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>


### 只需要求两个节点的LCA
#### 模版
```java
class LAC {
  // F[i][j]表示从i节点向上走2^j步
  int F[][];
  // 存储节点的深度
  int[] dep;
  // 使用邻接表来存储树
  List<Integer>[] tree;
  // 最多可以跳2^k步
  int k;

  /**
   * @param root 树的根节点
   */
  public LAC(List<Integer>[] tree, Integer root) {
    this.tree = tree;
    int n = tree.length;
    dep = new int[n];
    k = (int) (Math.log(n) / Math.log(2));
    F = new int[n][k + 1];
    // 初始化
    dep[root] = 1;
    dfs(root);
  }

  /**
   * @param v 当前节点
   */
  void dfs(int v) {
    for (int i = 1; (1 << i) <= dep[v]; i++) {
      F[v][i] = F[F[v][i - 1]][i - 1];
    }
    // 遍历当前当前节点的子节点
    for (int child : tree[v]) {
      dep[child] = dep[v] + 1;
      F[child][0] = v;
      dfs(child);
    }
  }

  /**
   * 查询x节点与y节点的最近公共祖先
   */
  int getLAC(int x, int y) {
    if (dep[x] < dep[y]) {
      int temp = x;
      x = y;
      y = temp;
    }
    for (int i = k; i >= 0; i--) {
      if (dep[F[x][i]] >= dep[y]) {
        x = F[x][i];
      }
      if (x == y) {
        return x;
      }
    }
    for (int i = k; i >= 0; i--) {
      if (F[x][i] != F[y][i]) {
        x = F[x][i];
        y = F[y][i];
      }
    }
    return F[x][0];
  }

}
```

#### 例题1: Nearest Common Ancestors
[Nearest Common Ancestors](http://poj.org/problem?id=1330)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220607152246.png)

代码：
```java
int T = cin.nextInt();

public void solve() {
  while (T-- != 0) {
    int N = cin.nextInt();
    List<Integer>[] tree = new List[N + 1];
    for (int i = 1; i <= N; i++) {
      tree[i] = new ArrayList();
    }
    // flag[i]==true表示有指向i节点的节点
    boolean[] flag = new boolean[N + 1];
    for (int i = 0; i < N - 1; i++) {
      int a = cin.nextInt();
      int b = cin.nextInt();
      tree[a].add(b);
      flag[b] = true;
    }
    // 查找tree的根节点
    int root = -1;
    for (int i = 1; i <= N; i++) {
      if (!flag[i]) {
        root = i;
        break;
      }
    }
    LAC lac = new LAC(tree, root);
    int x = cin.nextInt();
    int y = cin.nextInt();
    System.out.println(lac.getLAC(x, y));
  }
}

class LAC {
  // F[i][j]表示从i节点向上走2^j步
  int F[][];
  // 存储节点的深度
  int[] dep;
  // 使用邻接表来存储树
  List<Integer>[] tree;
  // 最多可以跳2^k步
  int k;

  /**
   * @param root 树的根节点
   */
  public LAC(List<Integer>[] tree, Integer root) {
    this.tree = tree;
    int n = tree.length;
    dep = new int[n];
    k = (int) (Math.log(n) / Math.log(2));
    F = new int[n][k + 1];
    // 初始化
    dep[root] = 1;
    dfs(root);
  }

  /**
   * @param v 当前节点
   */
  void dfs(int v) {
    for (int i = 1; (1 << i) <= dep[v]; i++) {
      F[v][i] = F[F[v][i - 1]][i - 1];
    }
    // 遍历当前当前节点的子节点
    for (int child : tree[v]) {
      dep[child] = dep[v] + 1;
      F[child][0] = v;
      dfs(child);
    }
  }

  /**
   * 查询x节点与y节点的最近公共祖先
   */
  int getLAC(int x, int y) {
    if (dep[x] < dep[y]) {
      int temp = x;
      x = y;
      y = temp;
    }
    for (int i = k; i >= 0; i--) {
      if (dep[F[x][i]] >= dep[y]) {
        x = F[x][i];
      }
      if (x == y) {
        return x;
      }
    }
    for (int i = k; i >= 0; i--) {
      if (F[x][i] != F[y][i]) {
        x = F[x][i];
        y = F[y][i];
      }
    }
    return F[x][0];
  }

}

}
```

### 扩展成要求任何两点之间的距离
#### 模版
```java
class LAC {
  // F[i][j]表示从i节点向上走2^j步
  int F[][];
  // 存储节点的深度
  int[] dep;
  // dist[i]表示表示节点i到根节点的距离
  int[] dist;
  // 使用邻接表来存储树
  List<int[]>[] tree;
  // 最多可以跳2^k步
  int k;

  public LAC(List<int[]>[] tree, Integer root) {
    this.tree = tree;
    int n = tree.length;
    dep = new int[n];
    dist = new int[n];
    k = (int) (Math.log(n) / Math.log(2));
    F = new int[n][k + 1];
    // 初始化
    dep[root] = 1;
    dfs(root);
  }

  /**
   * @param v 当前节点
   */
  void dfs(int v) {
    for (int i = 1; (1 << i) <= dep[v]; i++) {
      F[v][i] = F[F[v][i - 1]][i - 1];
    }
    for (int[] child : tree[v]) {
      dep[child[0]] = dep[v] + 1;
      dist[child[0]] = dist[v] + child[1];
      F[child[0]][0] = v;
      dfs(child[0]);
    }
  }

  /**
   * 查询x节点与y节点的最近公共祖先
   */
  int getLAC(int x, int y) {
    if (dep[x] < dep[y]) {
      int temp = x;
      x = y;
      y = temp;
    }
    for (int i = k; i >= 0; i--) {
      if (dep[F[x][i]] >= dep[y]) {
        x = F[x][i];
      }
      if (x == y) {
        return x;
      }
    }
    for (int i = k; i >= 0; i--) {
      if (F[x][i] != F[y][i]) {
        x = F[x][i];
        y = F[y][i];
      }
    }
    return F[x][0];
  }

  /**
   * 查询x节点与y节点的之间的距离
   */
  int getDist(int x, int y) {
    int lac = getLAC(x, y);
    return dist[x] + dist[y] - 2 * dist[lac];
  }

}
```

#### 例题1：How far away ？
[How far away ？](http://acm.hdu.edu.cn/showproblem.php?pid=2586)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220607165201.png)

代码：
```java
int T = cin.nextInt();

public void solve() {
  while (T-- != 0) {
    int n = cin.nextInt();
    int m = cin.nextInt();
    List<int[]>[] tree = new List[n + 1];
    for (int i = 1; i <= n; i++) {
      tree[i] = new ArrayList<>();
    }
    // flag[i]==true表示有指向i节点的节点
    boolean[] flag = new boolean[n + 1];
    for (int i = 1; i < n; i++) {
      int a = cin.nextInt();
      int b = cin.nextInt();
      int k = cin.nextInt();
      tree[a].add(new int[]{b, k});
      flag[b] = true;
    }
    // 查找tree的根节点
    int root = -1;
    for (int i = 1; i <= n; i++) {
      if (!flag[i]) {
        root = i;
        break;
      }
    }
    LAC lac = new LAC(tree, root);
    while (m-- != 0) {
      int x = cin.nextInt();
      int y = cin.nextInt();
      System.out.println(lac.getDist(x, y));
    }
  }
}

class LAC {
  // F[i][j]表示从i节点向上走2^j步
  int F[][];
  // 存储节点的深度
  int[] dep;
  // dist[i]表示表示节点i到根节点的距离
  int[] dist;
  // 使用邻接表来存储树
  List<int[]>[] tree;
  // 最多可以跳2^k步
  int k;

  public LAC(List<int[]>[] tree, Integer root) {
    this.tree = tree;
    int n = tree.length;
    dep = new int[n];
    dist = new int[n];
    k = (int) (Math.log(n) / Math.log(2));
    F = new int[n][k + 1];
    // 初始化
    dep[root] = 1;
    dfs(root);
  }

  /**
   * @param v 当前节点
   */
  void dfs(int v) {
    for (int i = 1; (1 << i) <= dep[v]; i++) {
      F[v][i] = F[F[v][i - 1]][i - 1];
    }
    for (int[] child : tree[v]) {
      dep[child[0]] = dep[v] + 1;
      dist[child[0]] = dist[v] + child[1];
      F[child[0]][0] = v;
      dfs(child[0]);
    }
  }

  /**
   * 查询x节点与y节点的最近公共祖先
   */
  int getLAC(int x, int y) {
    if (dep[x] < dep[y]) {
      int temp = x;
      x = y;
      y = temp;
    }
    for (int i = k; i >= 0; i--) {
      if (dep[F[x][i]] >= dep[y]) {
        x = F[x][i];
      }
      if (x == y) {
        return x;
      }
    }
    for (int i = k; i >= 0; i--) {
      if (F[x][i] != F[y][i]) {
        x = F[x][i];
        y = F[y][i];
      }
    }
    return F[x][0];
  }

  /**
   * 查询x节点与y节点的之间的距离
   */
  int getDist(int x, int y) {
    int lac = getLAC(x, y);
    return dist[x] + dist[y] - 2 * dist[lac];
  }

}
```

# 算法模版总结
## 图论
### BFS
```java
/**
* visited: 用来存储被访问过的状态。如果允许状态是能够重复访问，则不需要创建visited变量
* path: 用来存储路径。如果不需要输出路径，则不需要创建path变量
* return: 是否可以到达目标状态
**/
boolean bfs(State startState) {
  Queue<State> queue = new LinkedList();
  Map<State, Boolean> visited = new HashMap();
  Map<State, State> path = new HashMap();
  
  queue.add(startState);
  visited.put(startState, true);

  while (!queue.isEmpty()) {
    State currentState = queue.poll();
    // 如果currentState是目标状态
    if (isObjective(currentState)) {
      // 可以在这里输出path
      return visited.get(currentState);
    }

    // 获取当前状态可以转换到的所有下一个状态。此时不需要考虑这个状态是否能被添加到队列中
    List<State> nextStates = transition(currentState);

    for (State nextState : nextStates) {
      if (visited.containsKey(nextState)) continue;
      queue.add(nextState);
      visited.put(nextState, true);
      path.put(nextState, currentState); 
    }
  }
  return false;
}
```

### DFS
```java
/**
 * visited: 用来存储被访问过的状态。如果允许状态是能够重复访问，则不需要创建visited变量
 * path: 用来存储路径。如果不需要输出路径，则不需要创建path变量
 * return: 是否可以到达目标状态
 */
boolean dfs(State currentState, Map<State, Boolean> visited, LinkedList<State> path) {
	visited.put(currentState, true);

	// 如果currentState是目标状态
	if (isObjective(currentState)) {
		// 可以在这里输出path
		return true;
	}

  // 获取当前状态可以转换到的所有下一个状态。此时不需要考虑这个状态是否能被添加到队列中
	List<State> nextStates = transition(currentState);

	for (State nextState : nextStates) {
		if (visited.containsKey(nextState)) continue;
		path.push(nextState);
		if (dfs(nextState, visited, path)){
			return true;
		}
		path.pop();
	}
	return false;
}
```

### 查找连通分量-BFS
```java
int findComponents() {
  // key表示节点/状态，value表示该节点/状态所属于的连通分支。
  // 该components可以作为visited使用, 即当componets.containsKey(i) == false时，表示i节点没有被访问，反之，则被访问了
  Map<State, Integer> components = new HashMap<>();

  // 现在所求的连通分支标识
  int currentComponent = 0;

  // 遍历每个节点/状态
  for (State state : States) {
    if (!components.containsKey(state)) {
      bfs(state, components, currentComponent++);
    }
  }
  return currentComponent;
}

void bfs(State startState, Map<State, Integer> components, Integer currentComponent) {
  Queue<State> queue = new LinkedList();

  queue.add(startState);
  components.put(startState, currentComponent);

  while (!queue.isEmpty()) {
    State currentState = queue.poll();

    // 获取当前状态可以转换到的所有下一个状态。此时不需要考虑这个状态是否能被添加到队列中
    List<State> nextStates = transition(currentState);

    for (State nextState : nextStates) {
      if (components.containsKey(nextState)) continue;
      queue.add(nextState);
      components.put(nextState, currentComponent);
    }
  }
}

class State {

}
```

### 查找连通分量-DFS
```java
int findComponents() {
  // key表示节点/状态，value表示该节点/状态所属于的连通分支。
  // 该components可以作为visited使用, 即当componets.containsKey(i) == false时，表示i节点没有被访问，反之，则被访问了
  Map<State, Integer> components = new HashMap<>();

  // 现在所求的连通分支标识
  int currentComponent = 0;

  // 遍历每个节点/状态
  for (State state : States) {
    if (!components.containsKey(state)) {
      bfs(state, components, currentComponent++);
    }
  }
  return currentComponent;
}

void dfs(State startState, Map<State, Integer> components, Integer currentComponent) {
  components.put(startState, currentComponent);

  // 获取当前状态可以转换到的所有下一个状态。此时不需要考虑这个状态是否能被添加到队列中
  List<State> nextStates = transition(currentState);

  for (State nextState : nextStates) {
    if (components.containsKey(nextState)) continue;
    dfs(nextState, components, currentComponent);
  }
}

class State {

}
```

### 并查集
#### 没有权值的并查集
```java
class DisjointSet {
  int[] parent;
  // 连通分量的个数
  int cnt;

  public DisjointSet(int n) {
    cnt = n;
    // 初始化parent
    parent = new int[n];
    for (int i = 0; i < n; i++) {
      parent[i] = i;
    }
  }

  // 查找x属于哪个连通分支
  int findParent(int x) {
    if (x == parent[x]) {
      return x; 
    } 
    parent[x] = findParent(parent[x]);
    return parent[x];
  }

  // 合并2个连通分支
  void unionSets(int a, int b) {
    a = findParent(a);
    b = findParent(b);
    if (a != b) {
      parent[a] = b;
      cnt--;
    }
  }
}
```

#### 有权值的并查集
```java
class DisjointSet {
  int[] parent;
  // weight[x]表示节点x指向父节点的权值
  double[] weight;
  // 连通分量的个数
  int cnt;

  public DisjointSet(int n) {
    cnt = n;
    parent = new int[n];
    weight = new double[n];
    for (int i = 0; i < n; i++) {
      parent[i] = i;
      // 权值初始化, 如何初始化，根据情况而定
      weight[i] = 1;
    }
  }

  int findParent(int x) {
    if (x == parent[x]) {
      return x;
    } 
    // 保存节点x没有进行路径压缩时的父节点。这样做是为了方便后续获取父节点的weight来更新节点x的weight
    int origin = parent[x];
    parent[x] = findParent(parent[x]);
    // 更新weight[x], 具体如何更新，根据情况而定
    weight[x] *= weight[origin];
    return parent[x];
  }

  void unionSets(int a, int b, double value) {
    int rootA = findParent(a);
    int rootB = findParent(b);
    
    if (rootA != rootB) {
      parent[rootA] = rootB;
      // 更新weight[rootA], 具体如何更新，根据情况而定
      weight[rootA] = value * weight[b] / weight[a];
      cnt--;
    }
  }
}
```

#### 初始化时节点总数不确定的并查集
```java
class DisjointSet {
  // key：节点编号；value：该节点的父节点
  Map<Integer, Integer> parent;
  // 连通分量的个数
  int cnt;
  
  public DisjointSet() {
    parent = new HashMap();
    // 刚初始化话时，parent中节点个数为0，所以连通分量个数为0
    cnt = 0;
  }

  int findParent(int x) {
    // 如果parent没有统计当前节点x, 则将节点x添加到parent中，节点x的父节点为它自己。此时连通分量个数加1
    if (!parent.containsKey(x)) {
      parent.put(x, x);
      cnt++;
    }

    if (x == parent.get(x)) {
      return x;
    }
    parent.put(x, findParent(parent.get(x)));
    return parent.get(x);
  }

  void unionSets(int a, int b) {
    a = findParent(a);
    b = findParent(b);
    if (a != b) {
      parent.put(a, b);
      // 连通分量个数减1
      cnt--;
    }
  }
}
```

### 最短路径算法
#### Dijkstra算法
##### 模版1: 需求到达其他所有点的最短路径
```java
/**
* startState: 开始状态
* graph: 图的表示方式，这里是使用的带有的权值的邻接表的表示方式
*/
int[] dijkstra(State startState,  List<int[]>[] graph) {
  // 优先队列，distFromStart较小的排在前面
  Queue<State> pq = new PriorityQueue<>((a, b) -> {
    return a.distFromStart - b.distFromStart;
  });

  // 初始化dist
  // dist[i] 的值就是节点 start 到达节点 i 的最短路径权重
  int[] dist = new int[graph.length];
  // 起始点到各点的最短路径长度为Integer.MAX_VALUE
  Arrays.fill(dist, Integer.MAX_VALUE);
  // 节点start 到节点start的最短路径为0 
  dist[startState.id] = 0;

  // 用来标记节点是否已经被选择
  boolean[] isSelected = new boolean[graph.length];

  // 从起点start开始进bfs
  pq.add(startState);

  while (!pq.isEmpty()) {
    State currentState = pq.poll();
    
    if (isSelected[currentState.id]) {
      continue;
    }
    isSelected[currentState.id] = true;

    // 获取currentState相邻节点
    List<State> nextStates = new ArrayList();
    for (int[] neighbor : graph[currentState.id]) {
      int nextNodeID = neighbor[0];
      int distToNextNode = dist[currentState.id] + neighbor[1];
      nextStates.add(new State(nextNodeID, distToNextNode));
    }
     
    for (State nextState : nextStates) {
      if (isSelected[nextState.id]) continue;
      if (dist[nextState.id] > nextState.distFromStart) {
        dist[nextState.id] = nextState.distFromStart;
        pq.add(nextState);
      }
    }
  }
  
  return dist;
}

// 辅助类, 用于优先队列
class State {
    // 图节点的 id
    int id;
    // 从 start 节点到当前节点的距离
    int distFromStart;

    State(int id, int distFromStart) {
        this.id = id;
        this.distFromStart = distFromStart;
    }
}
```

##### 模版2: 只需求到达某个点的最短路径
```java
/**
* startState: 开始状态
* graph: 图的表示方式，这里是使用的带有的权值的邻接表的表示方式
* end: 目标点
*/
int dijkstra(State startState,  List<int[]>[] graph, int end) {
  // 优先队列，distFromStart较小的排在前面
  Queue<State> pq = new PriorityQueue<>((a, b) -> {
    return a.distFromStart - b.distFromStart;
  });

  // 初始化dist
  // dist[i] 的值就是节点 start 到达节点 i 的最短路径权重
  int[] dist = new int[graph.length];
  // 起始点到各点的最短路径长度为Integer.MAX_VALUE
  Arrays.fill(dist, Integer.MAX_VALUE);
  // 节点start 到节点start的最短路径为0 
  dist[startState.id] = 0;

  // 用来标记节点是否已经被选择
  boolean[] isSelected = new boolean[graph.length];

  // 从起点start开始进bfs
  pq.add(startState);

  while (!pq.isEmpty()) {
    State currentState = pq.poll();
    
    // 如果currentState是目标点
    if (currentState.id == end) {
      return currentState.distFromStart;
    }

    if (isSelected[currentState.id]) {
      continue;
    }
    isSelected[currentState.id] = true;


    // 获取currentState相邻节点
    List<State> nextStates = new ArrayList();
    for (int[] neighbor : graph[currentState.id]) {
      int nextNodeID = neighbor[0];
      int distToNextNode = dist[currentState.id] + neighbor[1];
      nextStates.add(new State(nextNodeID, distToNextNode));
    }
     
    for (State nextState : nextStates) {
      if (isSelected[nextState.id]) continue;
      if (dist[nextState.id] > nextState.distFromStart) {
        dist[nextState.id] = nextState.distFromStart;
        pq.add(nextState);
      }
    }
  }

  // 如果到达这里，说明从 start 开始无法到达 end，返回 -1
  return -1;
}

// 辅助类, 用于优先队列
class State {
    // 图节点的 id
    int id;
    // 从 start 节点到当前节点的距离
    int distFromStart;

    State(int id, int distFromStart) {
        this.id = id;
        this.distFromStart = distFromStart;
    }
}
```

#### Bellman-Ford算法
```java
/**
  * @param s     起点
  * @param k     得到使用小于等于k条边的最短路径
  * @param edges 边集数组存储的图
  * @param n     顶点个数
  * @return
  */
int[] bellmanFord(int s, int k, List<Edge> edges, int n) {
  int[] dist = new int[n];
  Arrays.fill(dist, 0x3f3f3f3f);
  dist[s] = 0;
  // 执行k次
  for (int i = 0; i < k; i++) {
    int[] distClone = dist.clone();
    boolean flag = false;
    for (Edge edge : edges) {
      if (dist[edge.end] > distClone[edge.begin] + edge.weight) {
        dist[edge.end] = distClone[edge.begin] + edge.weight;
        flag = true;
      }
    }
    if (!flag) {
      return dist;
    }
  }
  return dist;
}

/**
  * 使用边集数组存储图
  */
class Edge {
  int begin, end, weight;

  Edge(int begin, int end, int weight) {
    this.begin = begin;
    this.end = end;
    this.weight = weight;
  }
}
```

#### SPFA算法
```java
/**
 * @param startState 起点状态
 * @param n          节点个数
 * @param dist       用于得到起点到其它顶点之间的最短距离
 * @param graph      图
 * @return 是否存在负环，返回true，则存在负环
 */
boolean spfa(State startState, int n, int[] dist, List<int[]>[] graph) {
  Queue<State> queue = new LinkedList<>();
  // 标记顶点是否正在队列中
  boolean[] used = new boolean[n];
  // 标记顶点进入了几次队列
  int[] num = new int[n];
  Arrays.fill(dist, Integer.MAX_VALUE);
  dist[startState.id] = 0; //第s个顶点到自身距离为0
  queue.add(startState); // 第s个顶点入队
  num[startState.id] = 1; // 表示第s个顶点已进入了1次队列
  used[startState.id] = true; // 表示第s个节点正在队列中

  while (!queue.isEmpty()) {
    State currentState = queue.poll();
    used[currentState.id] = false;

    List<State> nextStates = new ArrayList<>();
    for (int[] neighbor : graph[currentState.id]) {
      nextStates.add(new State(neighbor[0], dist[currentState.id] + neighbor[1]));
    }

    for (State nextState : nextStates) {
      if (dist[nextState.id] > nextState.distFromStart) {
        dist[nextState.id] = nextState.distFromStart;
        if (!used[nextState.id]) {
          queue.add(nextState);
          num[nextState.id]++;
          if (num[nextState.id] > n) {
            return false;
          }
          used[nextState.id] = true;
        }
      }
    }
  }
  return false;
}

// 辅助类, 用于优先队列
class State {
    // 图节点的 id
    int id;
    // 从 start 节点到当前节点的距离
    int distFromStart;

    State(int id, int distFromStart) {
        this.id = id;
        this.distFromStart = distFromStart;
    }
}
```

## 搜索
### 二分查找
```java
/**
 * 二分查找转折点
 * f(left) = true
 * f(right) = false
 *
 * @param left  左边界下标
 * @param right 右边界下标
 * @return 转折点
 **/
int binarySearch(int left, int right) {
  while (left + 1 != right) {
    int mid = left + (right - left) / 2;
    if (f(mid) == true) {
      left = mid;
    } else if (f(mid) == false) {
      right = mid;
    }
  }
  return left;
}

boolean f(int index) {
  // TODO
  return false;
}
```

## 数论
### 高斯消元法求行列式
```java
/**
 * 高斯消元法求行列式。复杂度O(n^3logn)。
 * 计算|mat|
 *
 * @param mat 行列式
 * @return 行列式值
 */
Integer det(Integer[][] mat) {
  int n = mat.length;
  int ret = 1;
  for (int i = 0; i < n; i++) {
    for (int j = i + 1; j < n; j++) {
      while (mat[j][i] != 0) {
        int t = mat[i][i] / mat[j][i];
        for (int k = i; k < n; k++) {
          mat[i][k] = ((mat[i][k] - mat[j][k] * t));
          int s = mat[i][k];
          mat[i][k] = mat[j][k];
          mat[j][k] = s;
        }
        ret = -ret;
      }
    }
    if (mat[i][i] == 0) {
      return 0;
    }
    ret = ret * mat[i][i];
  }
  return ret;
}
```

### 高斯消元法求行列式取模
```java
/**
 * 高斯消元法求行列式取模。复杂度O(n^3logn)。
 * 计算|mat| % m
 *
 * @param mat 行列式
 * @param m 模
 * @return 行列式值
 */
int detMod(Integer[][] mat, int m) {
  int n = mat.length;
  for (int i = 0; i < n; i++) {
    for (int j = 0; j < n; j++) {
      mat[i][j] %= m;
    }
  }
  long ret = 1;
  for (int i = 0; i < n; i++) {
    for (int j = i + 1; j < n; j++) {
      while (mat[j][i] != 0) {
        long t = mat[i][i] / mat[j][i];
        for (int k = i; k < n; k++) {
          mat[i][k] = (int) ((mat[i][k] - mat[j][k] * t) % m);
          int s = mat[i][k];
          mat[i][k] = mat[j][k];
          mat[j][k] = s;
        }
        ret = -ret;
      }
    }
    if (mat[i][i] == 0) {
      return 0;
    }
    ret = ret * mat[i][i] % m;
  }
  if (ret < 0) {
    ret += m;
  }
  return (int) ret;
}
```

### 求最大公因数
```java
/**
 * 求最大公因数(greatest common divisor)
 */
int gcd(int a, int b) {
  if (a % b == 0) {
    return b;
  }
  return gcd(b, a % b); // 辗转相除
}
```

### 求最小公倍数
```java
/**
 * 求最小公倍数(Least Common Multiple)
 */
int lcm(int a, int b) {
  return a * b / gcd(a, b);
}
```

### 比较2个大数的大小
```java
/**
 * 比较2个大数的大小
 *
 * @param str1 字符串表示的大数1
 * @param str2 字符串表示的大数2
 * @return 返回-1：str1小于str2；返回0：str1等于ste2；返回1：str1大于str2
 */
int largeNumCompare(String str1, String str2) {

  // 首先比较字符串长度
  if (str1.length() < str2.length()) {
    return -1;
  }
  if (str1.length() > str2.length()) {
    return 1;
  }

  // 长度相等时比较字符串字典序大小
  return str1.compareTo(str2);
}
```

## 区间信息维护与查询
### 大小堆实现查找kth
```java
class FindKthByHeap {
  private int[] nums;
  // 所要找的第几大的元素
  int k;

  /**
   * 创建大根堆与小根堆。
   * 堆存储堆是元素的id。即nums的下标
   */
  Comparator<Integer> comparator = (a, b) -> nums[a] != nums[b] ? Integer.compare(nums[a], nums[b]) : a - b;
  TreeSet<Integer> maxHeap = new TreeSet<>(comparator.reversed());
  TreeSet<Integer> minHeap = new TreeSet<>(comparator);

  public FindKthByHeap(int[] nums, int k) {
    this.nums = nums;
    this.k = k;
  }

  /**
   * 往堆中添加元素
   */
  public void add(int itemId) {
    minHeap.add(itemId);
    maxHeap.add(minHeap.pollFirst());
    balance();
  }

  /**
   * 通过给定的元素id删除堆中对应的元素
   *
   * @param itemId 元素的id
   */
  public void remove(int itemId) {
    if (!maxHeap.remove(itemId)) {
      minHeap.remove(itemId);
    }
  }

  /**
   * @return 第k大元素的id
   */
  public int getKthItemId() {
    return maxHeap.first();
  }

  /**
   * @return 第k大元素
   */
  public int getKthItem() {
    return nums[maxHeap.first()];
  }


  /**
   * @return 第k+1大元素的id
   */
  public int getK1thItemId() {
    return minHeap.first();
  }

  /**
   * @return 第k+1大元素
   */
  public int getK1thItem() {
    return nums[minHeap.first()];
  }

  /**
   * 维持大根堆元素个数小于等于k
   */
  private void balance() {
    while (maxHeap.size() > k) {
      minHeap.add(maxHeap.pollFirst());
    }
  }

  }
```

### 一维ST表
```java
class ST {
  // F[i][j]: 表示[i, i+2^j-1]区间的最值
  int[][] F;

  public ST(int[] nums) {
    int n = nums.length;
    int k = (int) (Math.log(n) / Math.log(2));
    // 初始化F数组
    F = new int[n][k + 1];
    for (int i = 0; i < n; i++) {
      F[i][0] = nums[i];
    }
    for (int j = 1; j <= k; j++) {
      for (int i = 0; i < n - (1 << j) + 1; i++) {
        F[i][j] = Math.max(F[i][j - 1], F[i + (1 << (j - 1))][j - 1]);
      }
    }
  }

  // 求区间[l..r]的最值
  int query(int l, int r) {
    if (l > r) {
      // TODO
    }
    int k = (int) (Math.log(r - l + 1) / Math.log(2));
    return Math.max(F[l][k], F[r - (1 << k) + 1][k]);
  }

}
```

### 二维ST表
```java
class ST {
  // F[r][i][j]: 表示第r行的[i, i+2^j-1]区间的最大值
  int F[][][];

  public ST(int[][] nums) {
    int n = nums[0].length;
    int k = (int) (Math.log(n) / Math.log(2));
    int row = nums.length;
    F = new int[row][n][k + 1];
    for (int r = 0; r < row; r++) {
      for (int c = 0; c < n; c++) {
        F[r][c][0] = nums[r][c];
      }
      for (int j = 1; j <= k; j++) {
        for (int i = 0; i < n - (1 << j) + 1; i++) {
          F[r][i][j] = Math.max(F[r][i][j - 1], F[r][i + (1 << (j - 1))][j - 1]);
        }
      }
    }
  }

  /**
   * @param row    矩阵左上顶点位于的行
   * @param col    矩阵左上顶点位于的列
   * @param width  矩阵宽度（即一行元素的个数）
   * @param height 矩阵高度（即一列元素的个数）
   * @return 矩阵范围内的最值
   */
  int query(int row, int col, int width, int height) {
    int max = Integer.MIN_VALUE;
    for (int r = row; r < height + row; r++) {
      int k = (int) (Math.log(width) / Math.log(2));
      // 右边界
      int rightCol = col + width - 1;
      max = Math.max(max, Math.max(F[r][col][k], F[r][rightCol - (1 << k) + 1][k]));
    }
    return max;
  }
}
```

### 最近公共祖先LCA
#### 只需要求两个节点的LCA
```java
class LAC {
  // F[i][j]表示从i节点向上走2^j步
  int F[][];
  // 存储节点的深度
  int[] dep;
  // 使用邻接表来存储树
  List<Integer>[] tree;
  // 最多可以跳2^k步
  int k;

  /**
   * @param root 树的根节点
   */
  public LAC(List<Integer>[] tree, Integer root) {
    this.tree = tree;
    int n = tree.length;
    dep = new int[n];
    k = (int) (Math.log(n) / Math.log(2));
    F = new int[n][k + 1];
    // 初始化
    dep[root] = 1;
    dfs(root);
  }

  /**
   * @param v 当前节点
   */
  void dfs(int v) {
    for (int i = 1; (1 << i) <= dep[v]; i++) {
      F[v][i] = F[F[v][i - 1]][i - 1];
    }
    // 遍历当前当前节点的子节点
    for (int child : tree[v]) {
      dep[child] = dep[v] + 1;
      F[child][0] = v;
      dfs(child);
    }
  }

  /**
   * 查询x节点与y节点的最近公共祖先
   */
  int getLAC(int x, int y) {
    if (dep[x] < dep[y]) {
      int temp = x;
      x = y;
      y = temp;
    }
    for (int i = k; i >= 0; i--) {
      if (dep[F[x][i]] >= dep[y]) {
        x = F[x][i];
      }
      if (x == y) {
        return x;
      }
    }
    for (int i = k; i >= 0; i--) {
      if (F[x][i] != F[y][i]) {
        x = F[x][i];
        y = F[y][i];
      }
    }
    return F[x][0];
  }

}
```

#### 扩展成要求任何两点之间的距离
```java
class LAC {
  // F[i][j]表示从i节点向上走2^j步
  int F[][];
  // 存储节点的深度
  int[] dep;
  // dist[i]表示表示节点i到根节点的距离
  int[] dist;
  // 使用邻接表来存储树
  List<int[]>[] tree;
  // 最多可以跳2^k步
  int k;

  public LAC(List<int[]>[] tree, Integer root) {
    this.tree = tree;
    int n = tree.length;
    dep = new int[n];
    dist = new int[n];
    k = (int) (Math.log(n) / Math.log(2));
    F = new int[n][k + 1];
    // 初始化
    dep[root] = 1;
    dfs(root);
  }

  /**
   * @param v 当前节点
   */
  void dfs(int v) {
    for (int i = 1; (1 << i) <= dep[v]; i++) {
      F[v][i] = F[F[v][i - 1]][i - 1];
    }
    for (int[] child : tree[v]) {
      dep[child[0]] = dep[v] + 1;
      dist[child[0]] = dist[v] + child[1];
      F[child[0]][0] = v;
      dfs(child[0]);
    }
  }

  /**
   * 查询x节点与y节点的最近公共祖先
   */
  int getLAC(int x, int y) {
    if (dep[x] < dep[y]) {
      int temp = x;
      x = y;
      y = temp;
    }
    for (int i = k; i >= 0; i--) {
      if (dep[F[x][i]] >= dep[y]) {
        x = F[x][i];
      }
      if (x == y) {
        return x;
      }
    }
    for (int i = k; i >= 0; i--) {
      if (F[x][i] != F[y][i]) {
        x = F[x][i];
        y = F[y][i];
      }
    }
    return F[x][0];
  }

  /**
   * 查询x节点与y节点的之间的距离
   */
  int getDist(int x, int y) {
    int lac = getLAC(x, y);
    return dist[x] + dist[y] - 2 * dist[lac];
  }

}
```

# java算法小知识点
## `List<int[]>[]`初始化
```java
List<int[]>[] graph = new ArrayList[n];

// 错误写法
Arrays.fill(graph, new ArrayList()); // 这个语句会使得graph数组中的每个元素都指向的是同一地址

// 正确写法
for (int i = 0; i < n; i++) {
  graph[i] = new ArrayList();
}
```


## int数组逆序
```java
Integer[] a = { 9, 8, 7, 2, 3, 4, 1, 0, 6, 5 }; // 为Integer数组，而不能是基本类型int数组
Arrays.sort(a, Collections.reverseOrder());
```
需要注意的是 不能使用基本类型（int,double, char），如果是int型需要改成Integer，float要改成Float。对于基本类型数组，现在没有一个很好的方法来对其进行逆序
