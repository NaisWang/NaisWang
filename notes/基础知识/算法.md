做算法最好要满足：
- <font color="red">一个变量不能多意</font>

# 常用技巧
## while(n-- != 0)与while(--n != 0)
`while(n-- != 0)`循环n次
`while(--n != 0)`循环n-1次

## 时间复杂度与数据范围
在竞赛中，一般认为计算机一秒能执行$5 ×10^8$次计算，如果题目给出的时间限制为1秒，那么选择的算法执行的计算次数最多应该在$10^8$量级才有可能解决这个题目。
一般情况下：
- $O(n)$的算法能解决的数据范围在 $n≤10^8$
- $O(nlogn)$ 的算法能解决的数据范围在 $n≤10^6$
- $O(n\sqrt{n})$ 的算法能解决的数据范围在 $n≤10^5$
- $O(n^2)$ 的算法能解决的数据范围在 $n≤5000$
- $O(n^3)$ 的算法能解决的数据范围在 $n≤300$
- $O(2^n)$ 的算法能解决的数据范围在 $n≤25$
- $O(n!)$ 的算法能解决的数据范围在 $n≤11$

以上范围仅供参考，实际过程中还要考虑每种算法的常数。

### 渐渐符号

#### Θ符号
$$Θ(g(n)) = {f(n):存在正常量c_1, c_2, 和n_0，使得对所有n \geq n_0, 有0 \leq c_1g(n) \leq f(n) \leq c_2g(n)}$$

若存在正常量$c_1和c_2$，使得对于足够大的n，函数f(n)能“夹入”$c_1g(n)与c_2g(n)$之间，则f(n)属于集合Θ(g(n))。因为Θ(g(n))是一个集合，所以可以记“$f(n) \in Θ(g(n))$”，以指出f(n)是Θ(g(n))的成员。作为替代，我们通常记“f(n) = Θ(g(n))”以表达相同的概念。

#### O符号
$$O(g(n)) = {f(n):存在正常量c, 和n_0，使得对所有n \geq n_0, 有0 \leq f(n) \leq cg(n)}$$

#### Ω符号
$$Ω(g(n)) = {f(n):存在正常量c, 和n_0，使得对所有n \geq n_0, 有0 \leq cg(n) \leq f(n)}$$

![](https://raw.githubusercontent.com/NaisWang/images/master/20220119104219.png)

#### o符号
由于O符号提供的渐进上界可能是也可能不是渐近紧确的。界$2n^2=O(n^2)$是渐近紧确的,但是$2n=O(n^2)$却不是。我们使用o符号来表示一个非渐近紧确的上界。

$$o(g(n)) = {f(n):对任意正常量c, 和n_0，使得对所有n \geq n_0, 有0 \leq f(n) < cg(n)}$$

例如：$2n=o(n^2), 但是2n^2 \not= o(n^2)$

#### ω符号
ω符号与Ω符号的关系类似于o符号与O符号的关系。我们使用ω符号来表示一个非渐近紧确的下界。

$$ω(g(n)) = {f(n):对任意正常量c, 和n_0，使得对所有n \geq n_0, 有0 \leq cg(n) < f(n)}$$

### 主定理

![](https://raw.githubusercontent.com/NaisWang/images/master/20220119092909.png)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220119093008.png)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220119093033.png)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220119093356.png)


# 基本算法

## 7大查找算法

- 顺序查找
- 二分查找
- 插值查找
- 斐波那契查找
- 树表查找
- 分块查找
- 哈希查找

### 顺序查找

#### 基本思想

这个是最简单的，从头到尾一个个比较（遍历），但效率着实的低。

#### 代码实现

```java
/**
 * @param key 要查找的数
 * @param array 数组(从这个数组中查找)
 * @return 查找结果(数组的下标位置)
 */ 
public static int orderSearch(int key, int[] array) {
  if (array == null || array.length < 1) {
    return -1;
  } else {
    for (int i = 0; i < array.length; i++) {
      if (array[i] == key) {
        return i;
      }
    } 
  }
  return -1;
}
```

### 二分查找

#### 基本思想

二分查找又称折半查找，前提条件：1.必须采用顺序存储结构 2.必须按关键字大小有序排列。

#### 代码实现

```java

```

## 贪心算法

### 简介
贪心法，又称贪心算法、贪婪算法、或称贪婪法，是一种在每一步选择中都采取在当前状态下最好或最优（即最有利）的选择，从而希望导致结果是最好或最优的算法。比如在旅行推销员问题中，如果旅行员每次都选择最近的城市，那这就是一种贪心算法。
### 思想 
贪心算法的基本思路是从问题的某一个初始解出发一步一步地进行，根据某个优化测度，每一步都要确保能获得局部最优解。每一步只考虑一个数据，他的选取应该满足局部优化的条件。若下一个数据和部分最优解连在一起不再是可行解时，就不把该数据添加到部分解中，直到把所有数据枚举完，或者不能再添加算法停止

贪心算法与动态规划的不同在于它对每个子问题的解决方案都做出选择，不能回退。动态规划则会保存以前的运算结果，并根据以前的结果对当前进行选择，有回退功能。

### 过程
1. 建立数学模型来描述问题；
2. 把求解的问题分成若干个子问题；
3. 对每一子问题求解，得到子问题的局部最优解；
4. 把子问题的解局部最优解合成原来解问题的一个解。

### 总结
**贪心算法的基本思想**
- 求解最优化问题的算法包含一系列步骤
- 每一步都有一组选择
- 作出在当前看来最好的选择
- 希望通过作出局部最优选择达到全局最优选择
- 贪心算法不一定总产生最优解
- 贪心算法是否产生优化解，需严格证明

**贪心算法产生最优解的条件**
- 最优子结构(最优子结构的意思是局部最优解能决定全局最优解)
- 贪心选择性

## 递归
### 递归解题套路
#### 递归搜索树
由于<font color="red">所有的递归都可以对应到一个**递归搜索树**上，每个节点代表一个栈帧，表示一个子问题。所以在分析递归时，边分析边画`递归搜索树`</font>

<font color="red">一定要进行子问题分析，可以从如下2个方面入手</font>:
- 子问题的范围
- 子问题的属性, 即通过子问题想要得到的东西

<img src="https://gitee.com/NaisWang/images/raw/master/img/截屏2021-11-07 下午9.28.38.jpg" width="500px"/>

1. 按照以上的搜索路线来搜索树时，当节点第一次被碰到时入栈，最后一次碰到时出栈。
   对应以上图：节点的碰到顺序：1->2->3->2->4->2->1->5->6->5->1
          节点的入栈顺序：1->2->3->4->5->6
          节点的出栈顺序：3->4->2->6->5->1
2. 记录每个节点入栈、出栈时的栈帧之间共享的数据， 以及入栈时的形参值，退栈时的返回值
3. 指向子节点的有向边对应着代码中子节点入栈前父节点要执行的代码；指向父节点的有向边对应着代码中子节点出栈后父节点要执行的操作。

#### 题目
使用以上知识点完成下面三个题目，下面三个题目严格遵循上述知识点
##### 递归实现指数型枚举
- [递归实现指数型枚举](https://www.acwing.com/problem/content/94/)
**题目描述:**
从 1∼n,这 n个整数中随机选取任意多个，输出所有可能的选择方案。
输入格式: 输入一个整数 n
输出格式: 每行输出一种方案。
同一行内的数必须升序排列，相邻两个数用恰好1个空格隔开。对于没有选任何数的方案，输出空行。
数据范围: `1≤n≤15`
输入样例：`3`
输出样例：
```
3
2
2 3
1
1 3
1 2
1 2 3
```
题解：
```java
public class Main{

  private static Integer n = null;

  public static void main(String[] args){
    initInput();
    dfs(1, new LinkedList()); 
  }

  public static void initInput(){
    Scanner scan = new Scanner(System.in); 
    n = scan.nextInt();
  }

  public static void dfs(int num, List<Integer> ans){
    if(num == n+1){
      System.out.println(ans.toString().replace("[", "").replace("]", "").replace(",", ""));
      return;
    }
    ans.add(num++);
    dfs(num, ans);
    ans.remove(ans.size()-1);
    dfs(num, ans);
  }
}
```
当n=3时对应的递归搜索树如下：
<img src="https://gitee.com/NaisWang/images/raw/master/img/20211107215021.png" width="700px"/>

**子问题分析：**
- 子问题的范围: num~n
- 子问题的属性：num~n的所有选法

##### 递归实现组合型枚举
- [递归实现排列型枚举](https://www.acwing.com/problem/content/96/)
**题目描述:**
把 1∼n这 n个整数排成一行后随机打乱顺序，输出所有可能的次序。
输入格式: 一个整数 n
输出格式: 按照从小到大的顺序输出所有方案，每行 1个。
首先，同一行相邻两个数用一个空格隔开。
其次，对于两个不同的行，对应下标的数一一比较，字典序较小的排在前面。
数据范围: `1≤n≤9`
输入样例：`3`
输出样例：
```
1 2 3
1 3 2
2 1 3
2 3 1
3 1 2
3 2 1
```
代码：
```java
public class Main{

  private static Integer n = null;
  private static boolean[] flag = null; 

  public static void main(String[] args){
    initInput();    
    flag = new boolean[n+1];
    dfs(new LinkedList());
  } 

  public static void initInput(){
    Scanner scan = new Scanner(System.in);
    n = scan.nextInt(); 
  }
  
  public static void dfs(List<Integer> ans){
    if(ans.size() == n) {
      System.out.println(ans.toString().replace(",", "").replace("[", "").replace("]", ""));
      return;
    }
    for(int i = 1; i <= n; i++){
      if(!flag[i]){
        flag[i] = true;
        ans.add(i);
        dfs(ans);
        ans.remove(ans.size()-1);
        flag[i] = false;
      }
    }
  }
}
```
当n=3时对应的递归搜索树如下：
<img src="https://gitee.com/NaisWang/images/raw/master/img/20211107215900.png" width="700px"/>

##### 矩阵中的路径
- [矩阵中的路径](https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/)
给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。
单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。
例如，在下面的 3×4 的矩阵中包含单词 "ABCCED"（单词中的字母已标出）。
![](https://gitee.com/NaisWang/images/raw/master/img/20211107220302.png)
示例 1：
输入：board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCCED"
输出：true
示例 2：
输入：board = [["a","b"],["c","d"]], word = "abcd"
输出：false

代码：
```java
class Solution{
  private int[] rowDirection = {-1, 1, 0, 0};
  private int[] columnDirection = {0, 0, -1, 1};
  
  public boolean exist(char[][] board, String word){
    for(int i = 0; i < board.length; i++){
      for(int j = 0; j < board[0].length; j++){
        if(board[i][j] == word.charAt(0)){
          char temp = board[i][j];
          board[i][j] = '0';
          if(dfs(board, word, i, j, 1)){
            return true;
          }
          board[i][j] = temp;
        }
      }
    }
    return false;
  } 

  public boolean dfs(char[][] board, String word, int row, int column, int index){
    if(index == word.length()){
      return true;
    }
    for(int i = 0; i < 4; i++){
      int nextRow = row+rowDirection[i];
      int nextColumn = column+columnDirection[i];
      if(nextRow >= 0 && nextRow < board.length && nextColumn >= 0 && nextColumn < board[0].length){
        if(word.charAt(index) == board[nextRow][nextColumn]){
          index++;
          char temp = board[nextRow][nextColumn];
          board[nextRow][nextColumn] = '0';
          if(dfs(board, word, nextRow, nextColumn, index)){
            return true;
          }
          index--; 
          board[nextRow][nextColumn] = temp;
        }
      }
    }
    return false;
  }
}
```
对于输入为board = [["A","B","D"],["B","C","E"],["D","C","E"]], word = "ABDE"时，递归搜索树为：
<img src="https://gitee.com/NaisWang/images/raw/master/img/20211114172054.png" width="700px"/>

**子问题分析：**
子问题的范围：word的(index, word.length-1)范围的子字符串, 当前位置在(row, column), board中没有遍历过的地方
子问题的属性：该子字符串是否存在网格中

### 尾递归

如果一个函数中所有递归形式的调用都出现在函数的末尾，我们称这个递归函数是尾递归的。当递归调用是整个函数体中最后执行的语句且它的返回值不属于表达式的一部分时，这个递归调用就是尾递归。尾递归函数的特点是在回归过程中不用做任何操作，这个特性很重要，因为大多数现代的编译器会利用这种特点自动生成优化的代码。
#### 原理
当编译器检测到一个函数调用是尾递归的时候，它就覆盖当前的活动记录而不是在栈中去创建一个新的。编译器可以做到这点，因为递归调用是当前活跃期内最后一条待执行的语句，于是当这个调用返回时栈帧中并没有其他事情可做，因此也就没有保存栈帧的必要了。通过覆盖当前的栈帧而不是在其之上重新添加一个，这样所使用的栈空间就大大缩减了，这使得实际的运行效率会变得更高。
#### 实例
为了理解尾递归是如何工作的，让我们再次以递归的形式计算阶乘。首先，这可以很容易让我们理解为什么之前所定义的递归不是尾递归。回忆之前对计算n!的定义：在每个活跃期计算n倍的(n－1)!的值，让n=n－1并持续这个过程直到n=1为止。这种定义不是尾递归的，因为每个活跃期的返回值都依赖于用n乘以下一个活跃期的返回值，因此每次调用产生的栈帧将不得不保存在栈上直到下一个子调用的返回值确定。现在让我们考虑以尾递归的形式来定义计算n!的过程。
这种定义还需要接受第二个参数a，除此之外并没有太大区别。a（初始化为1）维护递归层次的深度。这就让我们避免了每次还需要将返回值再乘以n。然而，在每次递归调用中，令a=na并且n=n－1。继续递归调用，直到n=1，这满足结束条件，此时直接返回a即可。
代码实例3-2给出了一个C函数facttail，它接受一个整数n并以尾递归的形式计算n的阶乘。这个函数还接受一个参数a，a的初始值为1。facttail使用a来维护递归层次的深度，除此之外它和fact很相似。读者可以注意一下函数的具体实现和尾递归定义的相似之处。
示例3-2：以尾递归的形式计算阶乘的一个函数实现
```cpp
int facttail(int n, int a)
{
    if (n < 0)
        return 0;    
    else if (n == 0)
        return 1;    
    else if (n == 1)
        return a;
    else
        return facttail(n - 1, n * a);
}
```
示例3-2中的函数是尾递归的，因为对facttail的单次递归调用是函数返回前最后执行的一条语句。在facttail中碰巧最后一条语句也是对facttail的调用，但这并不是必需的。换句话说，在递归调用之后还可以有其他的语句执行，只是它们只能在递归调用没有执行时才可以执行。
尾递归是极其重要的，不用尾递归，函数的堆栈耗用难以估量，需要保存很多中间函数的堆栈。比如f(n, sum) = f(n-1) + value(n) + sum; 会保存n个函数调用堆栈，而使用尾递归f(n, sum) = f(n-1, sum+value(n)); 这样则只保留后一个函数堆栈即可，之前的可优化删去。
也许在C语言中有很多的特例，但编程语言不只有C语言，在函数式语言Erlang中（亦是栈语言），如果想要保持语言的高并发特性，就必须用尾递归来替代传统的递归。

## 前缀和
题目：
[560.和为K的子数组](https://leetcode-cn.com/problems/subarray-sum-equals-k)

---

今天来聊一道简单却十分巧妙的算法问题：算出一共有几个和为 k 的子数组。
<img src="https://gitee.com/NaisWang/images/raw/master/img/20210520142117.png" width="700px"/>

关键是，**如何快速得到某个子数组的和呢**，比如说给你一个数组 nums，让你实现一个接口 sum(i, j)，这个接口要返回`nums[i..j]` 的和，而且会被多次调用，你怎么实现这个接口呢？

因为接口要被多次调用，显然不能每次都去遍历`nums[i..j]`，有没有一种快速的方法在`O(1)`时间内算出`nums[i..j]`呢？这就需要前缀和技巧了。

### 什么是前缀和
前缀和是一种重要的预处理，能大大降低查询的时间复杂度。可以简单理解为“数列的前n项的和”。
前缀和的思路是这样的，对于一个给定的数组 nums，我们额外开辟一个前缀和数组进行预处理：
```java
int n = nums.length;
// 前缀和数组
int[] preSum = new int[n + 1];
preSum[0] = 0;
for (int i = 0; i < n; i++)
    preSum[i + 1] = preSum[i] + nums[i];
```
<img src="https://gitee.com/NaisWang/images/raw/master/img/20210520144622.png" width="700px"/>

这个前缀和数组 preSum 的含义也很好理解，`preSum[i]`就是`nums[0..i-1]`的和。那么如果我们想求`nums[i..j]`的和，只需要一步操作`preSum[j+1]-preSum[i]`即可，而不需要重新去遍历数组了。

回到这个子数组问题，我们想求有多少个子数组的和为 k，借助前缀和技巧很容易写出一个解法：
```java
int subarraySum(int[] nums, int k) {
    int n = nums.length;
    // 构造前缀和
    int[] sum = new int[n + 1];
    sum[0] = 0; 
    for (int i = 0; i < n; i++)
        sum[i + 1] = sum[i] + nums[i];
    
    int ans = 0;
    // 穷举所有子数组
    for (int i = 1; i <= n; i++)
        for (int j = 0; j < i; j++)
            // sum of nums[j..i-1]
            if (sum[i] - sum[j] == k)
                ans++;

    return ans;
}
```
这个解法的时间复杂度`O(N^2)`空间复杂度`O(N)`，并不是最优的解法。不过通过这个解法理解了前缀和数组的工作原理之后，可以使用一些巧妙的办法把时间复杂度进一步降低。

二、优化解法
前面的解法有嵌套的 for 循环：
```java
for (int i = 1; i <= n; i++)
    for (int j = 0; j < i; j++)
        if (sum[i] - sum[j] == k)
            ans++;
```
第二层 for 循环在干嘛呢？翻译一下就是，**在计算，有几个 j 能够使得 sum[i] 和 sum[j] 的差为 k。**毎找到一个这样的 j，就把结果加一。

我们可以把 if 语句里的条件判断移项，这样写：
```java
if (sum[j] == sum[i] - k)
    ans++;
```
优化的思路是：我直接记录下有几个`sum[j]`和`sum[i] - k`相等，直接更新结果，就避免了内层的 for 循环。我们可以用哈希表，在记录前缀和的同时记录该前缀和出现的次数。
```java
int subarraySum(int[] nums, int k) {
    int n = nums.length;
    // map：前缀和 -> 该前缀和出现的次数
    HashMap<Integer, Integer> 
        preSum = new HashMap<>();
    // base case
    preSum.put(0, 1);

    int ans = 0, sum0_i = 0;
    for (int i = 0; i < n; i++) {
        sum0_i += nums[i];
        // 这是我们想找的前缀和 nums[0..j]
        int sum0_j = sum0_i - k;
        // 如果前面有这个前缀和，则直接更新答案
        if (preSum.containsKey(sum0_j))
            ans += preSum.get(sum0_j);
        // 把前缀和 nums[0..i] 加入并记录出现次数
        preSum.put(sum0_i, 
            preSum.getOrDefault(sum0_i, 0) + 1);
    }
    return ans;
}
```
比如说下面这个情况，需要前缀和 8 就能找到和为 k 的子数组了，之前的暴力解法需要遍历数组去数有几个 8，而优化解法借助哈希表可以直接得知有几个前缀和为 8。
<img src="https://gitee.com/NaisWang/images/raw/master/img/20210520144845.png" width="700px"/>
这样，就把时间复杂度降到了 O(N)，是最优解法了。

### 总结
前缀和不难，却很有用，主要用于处理数组区间的问题。

比如说，让你统计班上同学考试成绩在不同分数段的百分比，也可以利用前缀和技巧：
```java
int[] scores; // 存储着所有同学的分数
// 试卷满分 150 分
int[] count = new int[150 + 1]
// 记录每个分数有几个同学
for (int score : scores)
    count[score]++
// 构造前缀和
for (int i = 1; i < count.length; i++)
    count[i] = count[i] + count[i-1];
```
这样，给你任何一个分数段，你都能通过前缀和相减快速计算出这个分数段的人数，百分比也就很容易计算了。

但是，稍微复杂一些的算法问题，不止考察简单的前缀和技巧。比如本文探讨的这道题目，就需要借助前缀和的思路做进一步的优化，借助哈希表去除不必要的嵌套循环。可见对题目的理解和细节的分析能力对于算法的优化是至关重要的。

## 双指针算法
题目
[141.环形链表](https://leetcode-cn.com/problems/linked-list-cycle)
[142.环形链表II](https://leetcode-cn.com/problems/linked-list-cycle-ii)
[167.两数之和 II - 输入有序数组](https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted)

---

我把双指针技巧再分为两类:
- 一类是「快慢指针」，主要解决链表中的问题，比如典型的判定链表中是否包含环；
- 一类是「左右指针」。主要解决数组（或者字符串）中的问题，比如二分查找。
### 快慢指针的常见算法
**1、判定链表中是否含有环**
这应该属于链表最基本的操作了，如果读者已经知道这个技巧，可以跳过。

单链表的特点是每个节点只知道下一个节点，所以一个指针的话无法判断链表中是否含有环的。

如果链表中不含环，那么这个指针最终会遇到空指针 null 表示链表到头了，这还好说，可以判断该链表不含环。
```java
boolean hasCycle(ListNode head) {
    while (head != null)
        head = head.next;
    return false;
}
```
但是如果链表中含有环，那么这个指针就会陷入死循环，因为环形数组中没有 null 指针作为尾部节点。

经典解法就是用两个指针，一个跑得快，一个跑得慢。如果不含有环，跑得快的那个指针最终会遇到 null，说明链表不含环；如果含有环，快指针最终会超慢指针一圈，和慢指针相遇，说明链表含有环。
```java
boolean hasCycle(ListNode head) {
    ListNode fast, slow;
    fast = slow = head;
    while (fast != null && fast.next != null) {
        fast = fast.next.next;
        slow = slow.next;
        
        if (fast == slow) return true;
    }
    return false;
}
```

**2、已知链表中含有环，返回这个环的起始位置**
<img src="https://gitee.com/NaisWang/images/raw/master/img/20210520153444.png" width="700px"/>

这个问题一点都不困难，有点类似脑筋急转弯，先直接看代码：
```java
ListNode detectCycle(ListNode head) {
    ListNode fast, slow;
    fast = slow = head;
    while (fast != null && fast.next != null) {
        fast = fast.next.next;
        slow = slow.next;
        if (fast == slow) break;
    }
    // 上面的代码类似 hasCycle 函数
    if (fast == null || fast.next == null) {
        // fast 遇到空指针说明没有环
        return null;
    }

    slow = head;
    while (slow != fast) {
        fast = fast.next;
        slow = slow.next;
    }
    return slow;
}
```
可以看到，当快慢指针相遇时，让其中任一个指针指向头节点，然后让它俩以相同速度前进，再次相遇时所在的节点位置就是环开始的位置。这是为什么呢？

第一次相遇时，假设慢指针 slow 走了 k 步，那么快指针 fast 一定走了 2k 步，也就是说比 slow 多走了 k 步（也就是环的长度）。
<img src="https://gitee.com/NaisWang/images/raw/master/img/20210520153513.png" width="700px"/>

设相遇点距环的起点的距离为 m，那么环的起点距头结点 head 的距离为 k - m，也就是说如果从 head 前进 k - m 步就能到达环起点。

巧的是，如果从相遇点继续前进 k - m 步，也恰好到达环起点。
<img src="https://gitee.com/NaisWang/images/raw/master/img/20210520153540.png" width="700px"/>

所以，只要我们把快慢指针中的任一个重新指向 head，然后两个指针同速前进，k - m 步后就会相遇，相遇之处就是环的起点了。

**3、寻找链表的中点**

类似上面的思路，我们还可以让快指针一次前进两步，慢指针一次前进一步，当快指针到达链表尽头时，慢指针就处于链表的中间位置。
```java
while (fast != null && fast.next != null) {
    fast = fast.next.next;
    slow = slow.next;
}
// slow 就在中间位置
return slow;
```
当链表的长度是奇数时，slow 恰巧停在中点位置；如果长度是偶数，slow 最终的位置是中间偏右：
<img src="https://gitee.com/NaisWang/images/raw/master/img/20210520153630.png" width="700px"/>

寻找链表中点的一个重要作用是对链表进行归并排序。

回想数组的归并排序：求中点索引递归地把数组二分，最后合并两个有序数组。对于链表，合并两个有序链表是很简单的，难点就在于二分。

但是现在你学会了找到链表的中点，就能实现链表的二分了。关于归并排序的具体内容本文就不具体展开了。

**4、寻找链表的倒数第 k 个元素**
我们的思路还是使用快慢指针，让快指针先走 k 步，然后快慢指针开始同速前进。这样当快指针走到链表末尾 null 时，慢指针所在的位置就是倒数第 k 个链表节点（为了简化，假设 k 不会超过链表长度）：
```java
ListNode slow, fast;
slow = fast = head;
while (k-- > 0) 
    fast = fast.next;

while (fast != null) {
    slow = slow.next;
    fast = fast.next;
}
return slow;
```

### 左右指针的常用算法
左右指针在数组中实际是指两个索引值，一般初始化为 left = 0, right = nums.length - 1 。
**1、二分查找**
这里只写最简单的二分算法，旨在突出它的双指针特性：
```java
int binarySearch(int[] nums, int target) {
    int left = 0; 
    int right = nums.length - 1;
    while(left <= right) {
        int mid = (right + left) / 2;
        if(nums[mid] == target)
            return mid; 
        else if (nums[mid] < target)
            left = mid + 1; 
        else if (nums[mid] > target)
            right = mid - 1;
    }
    return -1;
}
```
**2、两数之和**
直接看一道 LeetCode 题目吧：
<img src="https://gitee.com/NaisWang/images/raw/master/img/20210520154148.png" width="700px"/>

只要数组有序，就应该想到双指针技巧。这道题的解法有点类似二分查找，通过调节 left 和 right 可以调整 sum 的大小：

```java
int[] twoSum(int[] nums, int target) {
    int left = 0, right = nums.length - 1;
    while (left < right) {
        int sum = nums[left] + nums[right];
        if (sum == target) {
            // 题目要求的索引是从 1 开始的
            return new int[]{left + 1, right + 1};
        } else if (sum < target) {
            left++; // 让 sum 大一点
        } else if (sum > target) {
            right--; // 让 sum 小一点
        }
    }
    return new int[]{-1, -1};
}
```

**3、反转数组**
```java
void reverse(int[] nums) {
    int left = 0;
    int right = nums.length - 1;
    while (left < right) {
        // swap(nums[left], nums[right])
        int temp = nums[left];
        nums[left] = nums[right];
        nums[right] = temp;
        left++; right--;
    }
}
```

**4、滑动窗口算法**
这也许是双指针技巧的最高境界了，如果掌握了此算法，可以解决一大类子字符串匹配的问题


## 离散化
离散化本质上可以看成是一种 哈希，其保证数据在哈希以后仍然保持原来的全/偏序关系。
通俗地讲就是当有些数据因为本身很大或者类型不支持，自身无法作为数组的下标来方便地处理，而影响最终结果的只有元素之间的相对大小关系时，我们可以将原来的数据按照从大到小编号来处理问题，即离散化。
用来离散化的可以是大整数、浮点数、字符串等等。
<img src="https://gitee.com/NaisWang/images/raw/master/img/20210520160052.png" width="700px"/>

## 区间调度
### 区间合并
题目：
[56.合并区间](https://leetcode-cn.com/problems/merge-intervals)

---
LeetCode 第 56 题就是一道相关问题，题目很好理解：
<img src="https://gitee.com/NaisWang/images/raw/master/img/20210520162150.png" width="700px"/>

我们解决区间问题的一般思路是先排序，然后观察规律。

**思路**
一个区间可以表示为 [start, end]，我们选择按start大小对这些区间进行排序。
<img src="https://gitee.com/NaisWang/images/raw/master/img/20210520162304.png" width="700px"/>

显然，对于几个相交区间合并后的结果区间 x，x.start 一定是这些相交区间中 start 最小的，x.end 一定是这些相交区间中 end 最大的。
<img src="https://gitee.com/NaisWang/images/raw/master/img/20210520162322.png" width="700px"/>

由于已经排了序，x.start 很好确定，求 x.end 也很容易，

**代码：**
```java
class Solution {
    /**
     *  1. 先对区间集合进行排序（根据开始位置）
     *  2. 合并的情况一共有三种
     *    a.                        b.                   c.
     *          |---------|             |--------|             |--------|
     *              |---------|              |--|                            |--------|
     *      a和b两种情况，合并取右边界大的值，c情况不合并
     *  
     */

    private int[][] tmp;
    
    public int[][] merge(int[][] intervals) {
        if(intervals == null ||intervals.length == 0)return new int[0][0];
        int length = intervals.length;
        //将列表中的区间按照左端点升序排序
        // Arrays.sort(intervals,(v1,v2) -> v1[0]-v2[0]);
        
        this.tmp = new int[length][2];
        sort(intervals,0,length-1);

        int[][] ans = new int[length][2];
        int index = -1;
        for(int[] interval:intervals){
            // 当结果数组是空是，或者当前区间的起始位置 > 结果数组中最后区间的终止位置（即上图情况c）；
            // 则不合并，直接将当前区间加入结果数组。
            if(index == -1 || interval[0] > ans[index][1]){
                ans[++index] = interval;
            }else{
                // 反之将当前区间合并至结果数组的最后区间（即上图情况a,b）
                ans[index][1] = Math.max(ans[index][1],interval[1]);
            }
        }
        return Arrays.copyOf(ans, index + 1);
    }

    //归并排序
    public void sort(int[][] intervals,int l,int r){
        if(l >= r)return;

        int mid = l + (r-l)/2;
        sort(intervals,l,mid);
        sort(intervals,mid+1,r);

        //合并
        int i=l,j=mid+1;
        for(int k=l;k<=r;k++){
            if(i>mid)tmp[k]=intervals[j++];
            else if(j>r)tmp[k]=intervals[i++];
            else if(intervals[i][0]>intervals[j][0])tmp[k] = intervals[j++];
            else tmp[k] = intervals[i++];
        }

        System.arraycopy(tmp,l,intervals,l,r-l+1);
    }

}
```
看下动画就一目了然了：
![3](../pictures/mergeInterval/3.gif)

### 区间交集
题目：
[986.区间列表的交集](https://leetcode-cn.com/problems/interval-list-intersections)

---

先看下题目，LeetCode 第 986 题就是这个问题：
<img src="https://gitee.com/NaisWang/images/raw/master/img/20210520162714.png" width="700px"/>

题目很好理解，就是让你找交集，注意区间都是闭区间。

**思路**
解决区间问题的思路一般是先排序，以便操作，不过题目说已经排好序了，那么可以用两个索引指针在 A 和 B 中游走，把交集找出来，代码大概是这样的：
```py
# A, B 形如 [[0,2],[5,10]...]
def intervalIntersection(A, B):
    i, j = 0, 0
    res = []
    while i < len(A) and j < len(B):
        # ...
        j += 1
        i += 1
    return res
```
不难，我们先老老实实分析一下各种情况。

首先，对于两个区间，我们用`[a1,a2]`和`[b1,b2]`表示在 A 和 B 中的两个区间，那么什么情况下这两个区间没有交集呢：
<img src="https://gitee.com/NaisWang/images/raw/master/img/20210520164720.png" width="700px"/>

只有这两种情况，写成代码的条件判断就是这样：
```py
if b2 < a1 or a2 < b1:
    [a1,a2] 和 [b1,b2] 无交集
```
那么，什么情况下，两个区间存在交集呢？根据命题的否定，上面逻辑的否命题就是存在交集的条件：

```py
# 不等号取反，or 也要变成 and
if b2 >= a1 and a2 >= b1:
    [a1,a2] 和 [b1,b2] 存在交集
```
接下来，两个区间存在交集的情况有哪些呢？穷举出来：
<img src="https://gitee.com/NaisWang/images/raw/master/img/20210520164803.png" width="700px"/>

这很简单吧，就这四种情况而已。那么接下来思考，这几种情况下，交集是否有什么共同点呢？
<img src="https://gitee.com/NaisWang/images/raw/master/img/20210520164825.png" width="700px"/>

我们惊奇地发现，交集区间是有规律的！如果交集区间是`[c1,c2]`，那么 c1=max(a1,b1)，c2=min(a2,b2)！这一点就是寻找交集的核心，我们把代码更进一步：

```py
while i < len(A) and j < len(B):
    a1, a2 = A[i][0], A[i][1]
    b1, b2 = B[j][0], B[j][1]
    if b2 >= a1 and a2 >= b1:
        res.append([max(a1, b1), min(a2, b2)])
    # ...
```
最后一步，我们的指针 i 和 j 肯定要前进（递增）的，什么时候应该前进呢？
![](../pictures/intersection/4.gif)
结合动画示例就很好理解了，是否前进，只取决于 a2 和 b2 的大小关系：
```py
while i < len(A) and j < len(B):
    # ...
    if b2 < a2:
        j += 1
    else:
        i += 1
```

**代码**
```java
class Solution {
    public int[][] intervalIntersection(int[][] A, int[][] B) {
        List<int[]> res = new ArrayList<>();
        int a = 0, b = 0;
        while(a < A.length && b < B.length) {
            // 确定左边界，两个区间左边界的最大值
            int left = Math.max(A[a][0], B[b][0]);
            // 确定右边界，两个区间右边界的最小值
            int right = Math.min(A[a][1], B[b][1]);
            // 左边界小于右边界则加入结果集
            if (left <= right) 
                res.add(new int[] {left, right});
            // 右边界更大的保持不动，另一个指针移动，继续比较
            if(A[a][1] < B[b][1]) a++;
            else b++;
        }
        // 将结果转为数组
        return res.toArray(new int[0][]);
    }
}
```

## 有限状态自动机
有关视频详解：
- [有限状态自动机 001 11 1 89 有限状态机9 22](https://www.youtube.com/watch?v=5JIBhoAwpAI)
- [有限状态自动机 002 11 2 90 状态图11 09](https://www.youtube.com/watch?v=KLWH6Os3bzo&list=PL_lvW6yp7VRAzN3b_rDWSnNp-TdfmbW4l&index=3)
- [程序实现状态机](https://www.youtube.com/watch?v=_ZIpxltx5Sc)

有限状态机（英语：finite-state machine，缩写：FSM）又称有限状态自动机（英语：finite-state automaton，缩写：FSA），简称状态机，是表示有限个状态以及在这些状态之间的转移和动作等行为的数学计算模型。

### 概念和术语
状态存储关于过去的信息，就是说：它反映从系统开始到现在时刻的输入变化。转移指示状态变更，并且用必须满足确使转移发生的条件来描述它。动作是在给定时刻要进行的活动的描述。有多种类型的动作：
- 进入动作（entry action）：在进入状态时进行
- 退出动作（exit action）：在退出状态时进行
- 输入动作：依赖于当前状态和输入条件进行
- 转移动作：在进行特定转移时进行

![](https://gitee.com/NaisWang/images/raw/master/img/20211217184552.png)

FSM（有限状态机）可以使用上面图1那样的状态图（或状态转移图）来表示。此外可以使用多种类型的状态转移表。下面展示最常见的表示：当前状态（B）和条件（Y）的组合指示出下一个状态（C）。完整的动作信息可以只使用脚注来增加。包括完整动作信息的FSM定义可以使用状态表。

![](https://gitee.com/NaisWang/images/raw/master/img/20211217184705.png)

#### 初始状态与接受状态
有限状态自动机（以下简称「自动机」）是一类计算模型。它包含一系列状态，这些状态中：
- 有一个特殊的状态，被称作「初始状态」。
- 还有一系列状态被称为「接受状态」，它们组成了一个特殊的集合。其中，一个状态可能既是「初始状态」，也是「接受状态」。
起初，这个自动机处于「初始状态」。随后，它顺序地读取字符串中的每一个字符，并根据当前状态和读入的字符，按照某个事先约定好的「转移规则」，从当前状态转移到下一个状态；当状态转移完成后，它就读取下一个字符。当字符串全部读取完毕后，如果自动机处于某个「接受状态」，则判定该字符串「被接受」；否则，判定该字符串「被拒绝」。

#### 确定与非确定有限自动机
有限自动机可以分为确定有限自动机与非确定有限自动机：
- 确定有限自动机: Deterministic Finite Automaton，简称DFA，即给出一个输入，总能转移到确定的下一个状态。
- 非确定有限自动机: Nondeterministic Finite Automaton，简称NFA。即给定一个状态和一个输入，我们无法确定地转换到下一个状态。对于非确定有限自动机，我们有几种策略: 决策树、把NFA转换为DFA

### 应用
- 一个自动机，总能够回答某种形式的「对于给定的输入字符串 S，判断其是否满足条件 P」的问题。在本题中，条件 P 即为「构成合法的表示数值的字符串」。
- 自动机驱动的编程，可以被看做一种暴力枚举方法的延伸：它穷尽了在任何一种情况下，对应任何的输入，需要做的事情。
- 自动机在计算机科学领域有着广泛的应用。在算法领域，它与大名鼎鼎的字符串查找算法「KMP」算法有着密切的关联；在工程领域，它是实现「正则表达式」的基础。

### 一个例子
[LeetCode.剑指offer20](https://leetcode-cn.com/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/solution/biao-shi-shu-zhi-de-zi-fu-chuan-by-leetcode-soluti/)

有限自动机用于处理正则匹配。

我们用确定有限自动机分析这道题目。首先，我们的自动机处于未接受字符的初始状态，之后，自动机开始顺序接受一个输入字符，然后按照既定的规则转移到下一个状态。同时，如果该自动机接受字符后未找到对应的接受规则，则匹配失败。当所有字符输入完毕后，如果自动机处于接收状态，则最终字符串符合规则，被接受，否则，字符串不符合规则，即被拒绝。

#### 思路与算法
定义自动机的「状态集合」。那么怎么挖掘出所有可能的状态呢？一个常用的技巧是，用「当前处理到字符串的哪个部分」当作状态的表述。根据这一技巧，不难挖掘出所有状态：
- 起始的空格
- 符号位
- 整数部分
- 左侧有整数的小数点
- 左侧无整数的小数点（根据前面的第二条额外规则，需要对左侧有无整数的两种小数点做区分）
- 小数部分
- 字符e
- 指数部分的符号位
- 指数部分的整数部分
- 末尾的空格

下一步是找出「初始状态」和「接受状态」的集合。根据题意，「初始状态」应当为状态 1，而「接受状态」的集合则为状态 3、状态 4、状态 6、状态 9 以及状态 10。换言之，字符串的末尾要么是空格，要么是数字，要么是小数点，但前提是小数点的前面有数字。

最后，需要定义「转移规则」。结合数值字符串应当具备的格式，将自动机转移的过程以图解的方式表示出来：

![](https://gitee.com/NaisWang/images/raw/master/img/20211217185935.png)

比较上图与「预备知识」一节中对自动机的描述，可以看出有一点不同：

我们没有单独地考虑每种字符，而是划分为若干类。由于全部 10 个数字字符彼此之间都等价，因此只需定义一种统一的「数字」类型即可。对于正负号也是同理。
在实际代码中，我们需要处理转移失败的情况。例如当位于状态 1（起始空格）时，没有对应字符 e 的状态。为了处理这种情况，我们可以创建一个特殊的拒绝状态。如果当前状态下没有对应读入字符的「转移规则」，我们就转移到这个特殊的拒绝状态。一旦自动机转移到这个特殊状态，我们就可以立即判定该字符串不「被接受」。

#### 代码
```java
class Solution {
    public boolean isNumber(String s) {
        Map<State, Map<CharType, State>> transfer = new HashMap<State, Map<CharType, State>>();
        Map<CharType, State> initialMap = new HashMap<CharType, State>() {{
            put(CharType.CHAR_SPACE, State.STATE_INITIAL);
            put(CharType.CHAR_NUMBER, State.STATE_INTEGER);
            put(CharType.CHAR_POINT, State.STATE_POINT_WITHOUT_INT);
            put(CharType.CHAR_SIGN, State.STATE_INT_SIGN);
        }};
        transfer.put(State.STATE_INITIAL, initialMap);
        Map<CharType, State> intSignMap = new HashMap<CharType, State>() {{
            put(CharType.CHAR_NUMBER, State.STATE_INTEGER);
            put(CharType.CHAR_POINT, State.STATE_POINT_WITHOUT_INT);
        }};
        transfer.put(State.STATE_INT_SIGN, intSignMap);
        Map<CharType, State> integerMap = new HashMap<CharType, State>() {{
            put(CharType.CHAR_NUMBER, State.STATE_INTEGER);
            put(CharType.CHAR_EXP, State.STATE_EXP);
            put(CharType.CHAR_POINT, State.STATE_POINT);
            put(CharType.CHAR_SPACE, State.STATE_END);
        }};
        transfer.put(State.STATE_INTEGER, integerMap);
        Map<CharType, State> pointMap = new HashMap<CharType, State>() {{
            put(CharType.CHAR_NUMBER, State.STATE_FRACTION);
            put(CharType.CHAR_EXP, State.STATE_EXP);
            put(CharType.CHAR_SPACE, State.STATE_END);
        }};
        transfer.put(State.STATE_POINT, pointMap);
        Map<CharType, State> pointWithoutIntMap = new HashMap<CharType, State>() {{
            put(CharType.CHAR_NUMBER, State.STATE_FRACTION);
        }};
        transfer.put(State.STATE_POINT_WITHOUT_INT, pointWithoutIntMap);
        Map<CharType, State> fractionMap = new HashMap<CharType, State>() {{
            put(CharType.CHAR_NUMBER, State.STATE_FRACTION);
            put(CharType.CHAR_EXP, State.STATE_EXP);
            put(CharType.CHAR_SPACE, State.STATE_END);
        }};
        transfer.put(State.STATE_FRACTION, fractionMap);
        Map<CharType, State> expMap = new HashMap<CharType, State>() {{
            put(CharType.CHAR_NUMBER, State.STATE_EXP_NUMBER);
            put(CharType.CHAR_SIGN, State.STATE_EXP_SIGN);
        }};
        transfer.put(State.STATE_EXP, expMap);
        Map<CharType, State> expSignMap = new HashMap<CharType, State>() {{
            put(CharType.CHAR_NUMBER, State.STATE_EXP_NUMBER);
        }};
        transfer.put(State.STATE_EXP_SIGN, expSignMap);
        Map<CharType, State> expNumberMap = new HashMap<CharType, State>() {{
            put(CharType.CHAR_NUMBER, State.STATE_EXP_NUMBER);
            put(CharType.CHAR_SPACE, State.STATE_END);
        }};
        transfer.put(State.STATE_EXP_NUMBER, expNumberMap);
        Map<CharType, State> endMap = new HashMap<CharType, State>() {{
            put(CharType.CHAR_SPACE, State.STATE_END);
        }};
        transfer.put(State.STATE_END, endMap);

        int length = s.length();
        State state = State.STATE_INITIAL;

        for (int i = 0; i < length; i++) {
            CharType type = toCharType(s.charAt(i));
            if (!transfer.get(state).containsKey(type)) {
                return false;
            } else {
                state = transfer.get(state).get(type);
            }
        }
        return state == State.STATE_INTEGER || state == State.STATE_POINT || state == State.STATE_FRACTION || state == State.STATE_EXP_NUMBER || state == State.STATE_END;
    }

    public CharType toCharType(char ch) {
        if (ch >= '0' && ch <= '9') {
            return CharType.CHAR_NUMBER;
        } else if (ch == 'e' || ch == 'E') {
            return CharType.CHAR_EXP;
        } else if (ch == '.') {
            return CharType.CHAR_POINT;
        } else if (ch == '+' || ch == '-') {
            return CharType.CHAR_SIGN;
        } else if (ch == ' ') {
            return CharType.CHAR_SPACE;
        } else {
            return CharType.CHAR_ILLEGAL;
        }
    }

    // 定义状态
    enum State {
        STATE_INITIAL,
        STATE_INT_SIGN,
        STATE_INTEGER,
        STATE_POINT,
        STATE_POINT_WITHOUT_INT,
        STATE_FRACTION,
        STATE_EXP,
        STATE_EXP_SIGN,
        STATE_EXP_NUMBER,
        STATE_END
    }

    // 输入字符类型
    enum CharType {
        CHAR_NUMBER,
        CHAR_EXP,
        CHAR_POINT,
        CHAR_SIGN,
        CHAR_SPACE,
        CHAR_ILLEGAL
    }
}
```

# 数学知识
## a+b的巧算
a+b == (a^b)+(a&b<<1)
<img src="https://gitee.com/NaisWang/images/raw/master/img/20210415113516.png" width="700px"/>

不用加减乘除做加法
```java
public int add(int a, int b){
  while(b != 0){
    int sum = a^b;
    int carry = (a&b)<<1;
    a = sum;
    b = carry;
  }
  return b;
} 
```

## 同余
预备知识：
- $\frac{a}{b}$，a称为被除数，b是除数。记为：a被b除，或b除a
- $n | x$, 说明是n整除x，也就是x能被n整除，说明x是被除数，n是除数

数论中的重要概念。给定一个正整数m，如果两个整数a和b满足a-b能够被m整除，即(a-b)/m得到一个整数，那么就称整数a与b对模m同余，记作a≡b(mod m)。对模m同余是整数的一个等价关系，即：
$$m \mid (a-b) \iff a \equiv b\pmod {m}$$

## 位运算
题目
[191.位1的个数](https://leetcode-cn.com/problems/number-of-1-bits)
[231.2的幂](https://leetcode-cn.com/problems/power-of-two/)

---
本文分两部分，第一部分列举几个有趣的位操作，第二部分讲解算法中常用的 n & (n - 1) 操作，顺便把用到这个技巧的算法题列出来讲解一下。因为位操作很简单，所以假设读者已经了解与、或、异或这三种基本操作。

位操作（Bit Manipulation）可以玩出很多奇技淫巧，但是这些技巧大部分都过于晦涩，没必要深究，读者只要记住一些有用的操作即可。

### 几个有趣的位操作
**1. 利用或操作 | 和空格将英文字符转换为小写**
```
('a' | ' ') = 'a'
('A' | ' ') = 'a'
```
**2. 利用与操作 & 和下划线将英文字符转换为大写**
```
('b' & '_') = 'B'
('B' & '_') = 'B'
```
**3. 利用异或操作 ^ 和空格进行英文字符大小写互换**
```
('d' ^ ' ') = 'D'
('D' ^ ' ') = 'd'
```
以上操作能够产生奇特效果的原因在于 ASCII 编码。字符其实就是数字，恰巧这些字符对应的数字通过位运算就能得到正确的结果，有兴趣的读者可以查 ASCII 码表自己算算，本文就不展开讲了。
**4. 判断两个数是否异号**
```
int x = -1, y = 2;
bool f = ((x ^ y) < 0); // true

int x = 3, y = 2;
bool f = ((x ^ y) < 0); // false
```
这个技巧还是很实用的，利用的是补码编码的符号位。如果不用位运算来判断是否异号，需要使用 if else 分支，还挺麻烦的。读者可能想利用乘积或者商来判断两个数是否异号，但是这种处理方式可能造成溢出，从而出现错误。

### 算法常用操作
`n&(n-1)`这个操作是算法中常见的，作用是消除数字 n 的二进制表示中的最后一个 1。
看个图就很容易理解了：
<img src="https://gitee.com/NaisWang/images/raw/master/img/20210520155154.png" width="700px"/>
其核心逻辑就是，n - 1 一定可以消除最后一个 1，同时把其后的 0 都变成 1，这样再和 n 做一次 & 运算，就可以仅仅把最后一个 1 变成 0 了。

**1. 计算汉明权重（Hamming Weight）**
<img src="https://gitee.com/NaisWang/images/raw/master/img/20210520155309.png" width="700px"/>

就是让你返回 n 的二进制表示中有几个 1。因为 n & (n - 1) 可以消除最后一个 1，所以可以用一个循环不停地消除 1 同时计数，直到 n 变成 0 为止。
```java
int hammingWeight(uint32_t n) {
    int res = 0;
    while (n != 0) {
        n = n & (n - 1);
        res++;
    }
    return res;
}
```
**2. 判断一个数是不是 2 的指数**
一个数如果是 2 的指数，那么它的二进制表示一定只含有一个 1：
```
2^0 = 1 = 0b0001
2^1 = 2 = 0b0010
2^2 = 4 = 0b0100
```
如果使用 n&(n-1) 的技巧就很简单了（注意运算符优先级，括号不可以省略）：
```java
bool isPowerOfTwo(int n) {
    if (n <= 0) return false;
    return (n & (n - 1)) == 0;
}
```

**3. 查找只出现一次的元素**
这里就可以运用异或运算的性质：
一个数和它本身做异或运算结果为 0，即 a ^ a = 0；一个数和 0 做异或运算的结果为它本身，即 a ^ 0 = a。

对于这道题目，我们只要把所有数字进行异或，成对儿的数字就会变成 0，落单的数字和 0 做异或还是它本身，所以最后异或的结果就是只出现一次的元素：

```java
int singleNumber(vector<int>& nums) {
    int res = 0;
    for (int n : nums) {
        res ^= n;
    }
    return res;
}
```

## 快速幂
快速幂，二进制取幂（Binary Exponentiation，也称平方法），是一个在$O(logn)$的时间内计算$a^n$的小技巧，而暴力的计算需要$O(n)$的时间。而这个技巧也常常用在非计算的场景，因为它可以应用在任何具有结合律的运算中。其中显然的是它可以应用于模意义下取幂、矩阵幂等运算，我们接下来会讨论。
<img src="https://gitee.com/NaisWang/images/raw/master/img/20210419113022.png" width="700px"/>

### 模板
$求a^n$
递归版
```java
public long binpow(long a, long n){
  if(n == 0) return 1;
  long res = binpow(a, n/2);
  if(n%2 == 1) 
    return res*res*a;
  else
    return res*res;
}
```
非递归版
```java
public static long binpow(long a, long n){
  long res = 1;
  while(n > 0){
    if((n & 1) == 1) res = res * a; 
    a = a * a;
    n >>= 1;
  }
  return res;
}
```

**题目链接**
[a^b](https://www.acwing.com/problem/content/submission/91/)

## 64位整数乘法 
求(a*b)%p， 
如果直接计算a乘b这会超过long的最大范围，所以采用类似于快速幂的思想把 b写成二进制形式，然后如果某位上为1就加上它a*（2^n）次方（n与这位的位置有关）并且每次计算后取模就可以了
例如：计算3*7， 由于7的二进制为111
所以$3*7 = 3*(2^0)+3*(2^1)+3*(2^2)$

### 模板
求(a*b)%p
```java
public static long ksc(long a, long b, long p){
  long res = 0;
  while(b > 0){
    if((b&1) == 1) res = (res+a)%p;
    b >>= 1;
    a = 2*a%p;
  }
  return res;
}
```

# 搜索
## BFS
### 单向BFS
题目：
[迷宫问题](http://poj.org/problem?id=3984)

---

BFS 全称是 Breadth First Search，中文名是宽度优先搜索，也叫广度优先搜索。是图上最基础、最重要的搜索算法之一。

所谓宽度优先。就是每次都尝试访问同一层的节点。 如果同一层都访问完了，再访问下一层。
这样做的结果是，BFS 算法找到的路径是从起点开始的 最短 合法路径。换言之，这条路所包含的边数最小。
在 BFS 结束时，每个节点都是通过从起点到该点的最短路径访问的。
算法过程可以看做是图上火苗传播的过程：最开始只有起点着火了，在每一时刻，有火的节点都向它相邻的所有节点传播火苗。

**BFS核心模板**
```java
void bfs(int[][] nums) {
  int xLen = nums.length;
  int yLen = nums[0].length;
  int[] x = new int[]{-1, 1, 0, 0};
  int[] y = new int[]{0, 0, -1, 1};
  LinkedList<Point> queue = new LinkedList<>();
  queue.offerLast(new Point(0, 0));
  while (!queue.isEmpty()) {
    Point point = queue.pollFirst();
    System.out.println(point);
    for (int i = 0; i < 4; i++) {
      int curX = point.x + x[i];
      int curY = point.y + y[i];
      //如果产生的越界，就跳过本次
      if (curX < 0 || curX >= xLen || curY < 0 || curY >= yLen) continue;
      //如果已经访问过，就跳过本次
      if (nums[curX][curY] == Integer.MIN_VALUE) continue;
      //否则就入队
      queue.offerLast(new Point(curX, curY));
      //将此节点标志为已访问
      nums[curX][curY] = Integer.MIN_VALUE;
    }
  }
}
```

**应用**
- 在一个无权图上求从起点到其他所有点的最短路径。
- 在O(n+m)时间内求出所有连通块。（我们只需要从每个没有被访问过的节点开始做 BFS，显然每次 BFS 会走完一个连通块）
- 在一个边权为 0/1 的图上求最短路。（需要修改入队的过程，如果某条边权值为 0，且可以减小边的终点到图的起点的距离，那么把边的起点加到队列首而不是队列尾）
- 在一个有向无权图中找最小环。（从每个点开始 BFS，在我们即将抵达一个之前访问过的点开始的时候，就知道遇到了一个环。图的最小环是每次 BFS 得到的最小环的平均值。）

下面看一到POJ的题目，如下：
<img src="https://gitee.com/NaisWang/images/raw/master/img/20210523121706.png" width="700px"/>

```java
import java.util.*;

public class Main{
  static int[] dr = {1, -1, 0, 0};
  static int[] dc = {0, 0, -1, 1};
  static int[][] visit = new int[5][5];
  static int[][] maze = new int[5][5];
  static LinkedList<Integer> qu = new LinkedList(); 

  // pre[i] = j; 表示(i/5, i%5)点的前驱节点为(j/5, j%5)
  static int[] pre = new int[25];

  public static void main(String[] args){
    initMaze();
    pre[0] = -1;
    qu.add(0);
    bfs();
    print();
  }

  public static void initMaze(){
    Scanner sc = new Scanner(System.in); 
    for(int i = 0; i < 5; i++){
      for(int j = 0; j <  5; j++){
        maze[i][j] = sc.nextInt();
      }
    }
  }

  public static void bfs(){
    boolean flag = true;
    while(!qu.isEmpty() && flag){
      Integer in = qu.remove();
      int[] nowCoor = numToCoor(in); 
      int row = nowCoor[0];
      int col = nowCoor[1];
      for(int i = 0; i < 4; i++){
        int nextRow = row + dr[i];
        int nextCol = col + dc[i];
        if(isArea(nextRow, nextCol)){
          int preNum =coorToNum(row, col);
          int num = coorToNum(nextRow, nextCol);
          visit[nextRow][nextCol] = 1;
          if(pre[num] == 0){
            pre[num] = preNum;
          }
          qu.add(num);
        }
        if(nextRow == 4 && nextCol == 4){
          flag = false;
          break;
        }
      }
    }
  }

  //根据前驱节点输出最短路径
  public static void print(){
    Stack<String> st = new Stack();
    int nowNum = 24; 
    while(nowNum != -1){
      st.push("(" + nowNum/5 + ", " + nowNum%5 + ")");
      nowNum = pre[nowNum];
    }
    while(!st.isEmpty()){
      System.out.println(st.pop());
    }
  }

  public static boolean isArea(int row, int col){
    if(row >= 0 && row <= 4 && col >=0 && col <= 4 && visit[row][col] == 0 && maze[row][col] == 0)
      return true;
    return false;
  }

  //将坐标转化为数字
  public static int coorToNum(int r, int c){
    return 5 * r + c; 
  }

  //将数字转化为坐标
  public static int[] numToCoor(int num){
    int[] ans = new int[2];
    ans[0] = num / 5;
    ans[1] = num % 5;
    return ans;
  }
}
```

### 双向BFS
我们常常会面临这样一类搜索问题：**起点是给出的，终点也是已知的**，需要确定能否从起点到达终点，如果可以，需要多少步。
如果我们用常规的搜索方法，从起点开始往下搜，那得到的解答树可能非常庞大，这样漫无目的的搜索就像大海捞针。
<img src="https://gitee.com/NaisWang/images/raw/master/img/20210608111724.png" width="700px"/>


为了加快搜索速度，我们完全可以分别从起点和终点出发，看他们是否相遇：
<img src="https://gitee.com/NaisWang/images/raw/master/img/20210608111926.png" width="700px"/>

而这就是双向搜索，双向搜索主要有两种，分别是双向BFS与双向DFS

**如何实现一个双向BFS**
与普通的BFS不同，双向BFS维护两个而不是一个队列，然后**轮流**扩展两个队列。同时，用**数组**(如果状态可以被表示为较小的整数)或**哈希表**记录当前的搜索情况，给从两个方向扩展的节点以不同的标记。当某点被两种标记同时标记时，搜索结束。
代码如下：

## DFS
### Flood Fill
题目：
[733.图像渲染](https://leetcode-cn.com/problems/flood-fill)

---

啥是 FloodFill 算法呢，最直接的一个应用就是「颜色填充」，就是 Windows 绘画本中那个小油漆桶的标志，可以把一块被圈起来的区域全部染色。
<img src="https://gitee.com/NaisWang/images/raw/master/img/20210523095613.png" width="700px"/>

这种算法思想还在许多其他地方有应用。比如说扫雷游戏，有时候你点一个方格，会一下子展开一片区域，这个展开过程，就是 FloodFill 算法实现的。
<img src="https://gitee.com/NaisWang/images/raw/master/img/20210523095638.png" width="500px"/>

类似的，像消消乐这类游戏，相同方块积累到一定数量，就全部消除，也是 FloodFill 算法的功劳。
<img src="https://gitee.com/NaisWang/images/raw/master/img/20210523095655.png" width="700px"/>
通过以上的几个例子，你应该对 FloodFill 算法有个概念了，现在我们要抽象问题，提取共同点。

**一、构建框架**
以上几个例子，都可以抽象成一个二维矩阵（图片其实就是像素点矩阵），然后从某个点开始向四周扩展，直到无法再扩展为止。

矩阵，可以抽象为一幅「图」，这就是一个图的遍历问题，也就类似一个 N 叉树遍历的问题。几行代码就能解决，直接上框架吧：
```java
// (x, y) 为坐标位置
void fill(int x, int y) {
    fill(x - 1, y); // 上
    fill(x + 1, y); // 下
    fill(x, y - 1); // 左
    fill(x, y + 1); // 右
}
```
或
```java
let dx = {-1, 1, 0, 0}
let dy = {0, 0, -1, 1}

void fill(int x, int y) {
  for(int i = 0; i < 4; i++){
    fill(x + dx[i], y + dy[i])
  }
}
```

这个框架可以解决所有在二维矩阵中遍历的问题，说得高端一点，这就叫深度优先搜索（Depth First Search，简称 DFS），说得简单一点，这就叫四叉树遍历框架。坐标 (x, y) 就是 root，四个方向就是 root 的四个子节点。

下面看一道 LeetCode 题目，其实就是让我们来实现一个「颜色填充」功能。
<img src="https://gitee.com/NaisWang/images/raw/master/img/20210523103217.png" width="700px"/>

根据上篇文章，我们讲了「树」算法设计的一个总路线，今天就可以用到：
```java
int[][] floodFill(int[][] image,
        int sr, int sc, int newColor) {

    int origColor = image[sr][sc];
    fill(image, sr, sc, origColor, newColor);
    return image;
}

void fill(int[][] image, int x, int y,
        int origColor, int newColor) {
    // 出界：超出边界索引
    if (!inArea(image, x, y)) return;
    // 碰壁：遇到其他颜色，超出 origColor 区域
    if (image[x][y] != origColor) return;
    image[x][y] = newColor;
    
    fill(image, x, y + 1, origColor, newColor);
    fill(image, x, y - 1, origColor, newColor);
    fill(image, x - 1, y, origColor, newColor);
    fill(image, x + 1, y, origColor, newColor);
}

boolean inArea(int[][] image, int x, int y) {
    return x >= 0 && x < image.length
        && y >= 0 && y < image[0].length;
}
```
只要你能够理解这段代码，一定要给你鼓掌，给你 99 分，因为你对「框架思维」的掌控已经炉火纯青，此算法已经 cover 了 99% 的情况，仅有一个细节问题没有解决，就是当 origColor 和 newColor 相同时，会陷入无限递归。

**二、研究细节**
为什么会陷入无限递归呢，很好理解，因为每个坐标都要搜索上下左右，那么对于一个坐标，一定会被上下左右的坐标搜索。被重复搜索时，必须保证递归函数能够能正确地退出，否则就会陷入死循环。

为什么 newColor 和 origColor 不同时可以正常退出呢？把算法流程画个图理解一下：
<img src="https://gitee.com/NaisWang/images/raw/master/img/20210523103437.png" width="700px"/>

可以看到，fill(1, 1) 被重复搜索了，我们用 fill(1, 1)* 表示这次重复搜索。fill(1, 1)* 执行时，(1, 1) 已经被换成了 newColor，所以 fill(1, 1)* 会在这个 if 语句被怼回去，正确退出了。
```java
// 碰壁：遇到其他颜色，超出 origColor 区域
if (image[x][y] != origColor) return;
```
<img src="https://gitee.com/NaisWang/images/raw/master/img/20210523103457.png" width="700px"/>

但是，如果说 origColor 和 newColor 一样，这个 if 语句就无法让 fill(1, 1)* 正确退出，而是开启了下面的重复递归，形成了死循环。
<img src="https://gitee.com/NaisWang/images/raw/master/img/20210523103511.png" width="700px"/>

三、处理细节
如何避免上述问题的发生，最容易想到的就是用一个和 image 一样大小的二维 bool 数组记录走过的地方，一旦发现重复立即 return。
```java
 // 出界：超出边界索引
if (!inArea(image, x, y)) return;
// 碰壁：遇到其他颜色，超出 origColor 区域
if (image[x][y] != origColor) return;
// 不走回头路
if (visited[x][y]) return;
visited[x][y] = true;
image[x][y] = newColor;
```
完全 OK，这也是处理「图」的一种常用手段。不过对于此题，不用开数组，我们有一种更好的方法，那就是回溯算法。
```java
void fill(int[][] image, int x, int y,
        int origColor, int newColor) {
    // 出界：超出数组边界
    if (!inArea(image, x, y)) return;
    // 碰壁：遇到其他颜色，超出 origColor 区域
    if (image[x][y] != origColor) return;
    // 已探索过的 origColor 区域
    if (image[x][y] == -1) return;
    
    // choose：打标记，以免重复
    image[x][y] = -1;
    fill(image, x, y + 1, origColor, newColor);
    fill(image, x, y - 1, origColor, newColor);
    fill(image, x - 1, y, origColor, newColor);
    fill(image, x + 1, y, origColor, newColor);
    // unchoose：将标记替换为 newColor
    image[x][y] = newColor;
}
```
这种解决方法是最常用的，相当于使用一个特殊值 -1 代替 visited 数组的作用，达到不走回头路的效果。为什么是 -1，因为题目中说了颜色取值在 0 - 65535 之间，所以 -1 足够特殊，能和颜色区分开。

**四、拓展延伸：自动魔棒工具和扫雷**
大部分图片编辑软件一定有「自动魔棒工具」这个功能：点击一个地方，帮你自动选中相近颜色的部分。如下图，我想选中老鹰，可以先用自动魔棒选中蓝天背景，然后反向选择，就选中了老鹰。我们来分析一下自动魔棒工具的原理。
<img src="https://gitee.com/NaisWang/images/raw/master/img/20210523103755.png" width="700px"/>

显然，这个算法肯定是基于 FloodFill 算法的，但有两点不同：首先，背景色是蓝色，但不能保证都是相同的蓝色，毕竟是像素点，可能存在肉眼无法分辨的深浅差异，而我们希望能够忽略这种细微差异。第二，FloodFill 算法是「区域填充」，这里更像「边界填充」。

对于第一个问题，很好解决，可以设置一个阈值 threshold，在阈值范围内波动的颜色都视为 origColor：
```java
if (Math.abs(image[x][y] - origColor) > threshold)
    return;
```
对于第二个问题，我们首先明确问题：不要把区域内所有 origColor 的都染色，而是只给区域最外圈染色。然后，我们分析，如何才能仅给外围染色，即如何才能找到最外围坐标，最外围坐标有什么特点？
<img src="https://gitee.com/NaisWang/images/raw/master/img/20210523103935.png" width="700px"/>

可以发现，区域边界上的坐标，至少有一个方向不是 origColor，而区域内部的坐标，四面都是 origColor，这就是解决问题的关键。保持框架不变，使用 visited 数组记录已搜索坐标，主要代码如下：

```java
int fill(int[][] image, int x, int y,
    int origColor, int newColor) {
    // 出界：超出数组边界
    if (!inArea(image, x, y)) return 0;
    // 已探索过的 origColor 区域
    if (visited[x][y]) return 1;
    // 碰壁：遇到其他颜色，超出 origColor 区域
    if (image[x][y] != origColor) return 0;

    visited[x][y] = true;
    
    int surround = 
          fill(image, x - 1, y, origColor, newColor)
        + fill(image, x + 1, y, origColor, newColor)
        + fill(image, x, y - 1, origColor, newColor)
        + fill(image, x, y + 1, origColor, newColor);
    
    if (surround < 4)
        image[x][y] = newColor;
    
    return 1;
}
```
这样，区域内部的坐标探索四周后得到的 surround 是 4，而边界的坐标会遇到其他颜色，或超出边界索引，surround 会小于 4。如果你对这句话不理解，我们把逻辑框架抽象出来看：
```java
int fill(int[][] image, int x, int y,
    int origColor, int newColor) {
    // 出界：超出数组边界
    if (!inArea(image, x, y)) return 0;
    // 已探索过的 origColor 区域
    if (visited[x][y]) return 1;
    // 碰壁：遇到其他颜色，超出 origColor 区域
    if (image[x][y] != origColor) return 0;
    // 未探索且属于 origColor 区域
    if (image[x][y] == origColor) {
        // ...
        return 1;
    }
}
```
这 4 个 if 判断涵盖了 (x, y) 的所有可能情况，surround 的值由四个递归函数相加得到，而每个递归函数的返回值就这四种情况的一种。借助这个逻辑框架，你一定能理解上面那句话了。

这样就实现了仅对 origColor 区域边界坐标染色的目的，等同于完成了魔棒工具选定区域边界的功能。

这个算法有两个细节问题，一是必须借助 visited 来记录已探索的坐标，而无法使用回溯算法；二是开头几个 if 顺序不可打乱。读者可以思考一下原因。

同理，思考扫雷游戏，应用 FloodFill 算法展开空白区域的同时，也需要计算并显示边界上雷的个数，如何实现的？其实也是相同的思路，遇到雷就返回 true，这样 surround 变量存储的就是雷的个数。当然，扫雷的 FloodFill 算法不能只检查上下左右，还得加上四个斜向。
<img src="https://gitee.com/NaisWang/images/raw/master/img/20210523104059.png" width="700px"/>

以上详细讲解了 FloodFill 算法的框架设计，**二维矩阵中的搜索问题，都逃不出这个算法框架。**

### 单向DFS
题目：
[迷宫问题](http://poj.org/problem?id=3984)

---
这个问题在单向bfs讲解中使用bfs做过，接下来使用dfs做一遍：
题目如下：
<img src="https://gitee.com/NaisWang/images/raw/master/img/20210523121706.png" width="700px"/>

```java
public class Main{

  static int[] dr = {0, 0, -1, 1};
  static int[] dc = {-1, 1, 0, 0};

  // pre[i] = j; 表示(i/5, i%5)点的前驱节点为(j/5, j%5)
  static int[] pre = new int[25];

  public static void main(String[] args) {
    int[][] maze = new int[5][5];
    Scanner scan = new Scanner(System.in); 
    for(int i = 0; i < 5; i++){
      for(int j = 0; j < 5; j++){
        maze[i][j] = scan.nextInt();
      }
    }

    dfs(-1, 0, 0, maze);
    print(pre);
  }

  //根据前驱节点输出最短路径
  public static void print(int[] pre){
    Stack<String> st = new Stack(); 
    int num = 24;
    while(num != -1){
      st.push("("+ num / 5 + ", "+ num % 5 +")");
      num = pre[num];
    }
    while(!st.empty()){
      System.out.println(st.pop());
    }
  }

  public static void dfs(int preNum, int r, int c, int[][] maze){
    if(!isArea(r, c, maze)){
      return; 
    }

    //记录当前节点的前驱节点
    //如果当亲节点已经有了前驱节点，则不在设置其前驱节点
    int num = coorToNum(r, c);
    if(pre[num] == 0){
      pre[num] = preNum;
    }

    maze[r][c] = 1;//代表(r, c)点走过
    for(int i = 0; i < 4; i++){
      int nowNum = coorToNum(r, c);
      dfs(nowNum, r + dr[i], c + dc[i], maze);
    }
    maze[r][c] = 0; //恢复
  }
  
  public static boolean isArea(int r, int c, int[][] maze){
    if(r < 0 || r >= 5 || c < 0 || c >= 5){
      return false;
    }
    if(maze[r][c] == 1){
      return false; 
    }
    return true;
  }

  //将坐标转化为数字
  public static int coorToNum(int r, int c){
    return 5 * r + c; 
  }

  //将数字转化为坐标
  public static int[] numToCoor(int num){
    int[] ans = new int[2];
    ans[0] = num / 5;
    ans[1] = num % 5;
    return ans;
  }
}


```

# 数据结构
## 堆
不是二叉树就能叫做堆，堆必须是小根堆或者是大根堆

#### 调整堆、建堆、出堆
堆中有一个核心操作，就是调整堆。堆中的建堆、出堆操作都是基于调整堆的。调整堆的函数如下：
```java
// index为节点的下标
public void heapfiy(int index) {
  int heapItemsLength = heapItems.size();

  // index节点的左孩子
  int c1 = index * 2 + 1;
  // index节点的右孩子
  int c2 = index * 2 + 2;

  int min = index;

  // 当左孩子小于父节点时
  if (c1 < heapItemsLength && heapItems.get(c1) < heapItems.get(max)) {
    max = c1; 
  }

  // 当右孩子小于父节点时
  if (c2 < heapItemsLength && heapItems.get(c2) < heapItems.get(max)) {
    max = c2; 
  }

  // 存在子节点小于父节点时
  if (min != index) {
    swap(min, index);

    //递归调整父节点为min时的二叉树
    heapfiy(min);
  }
}
```
<font color="red">调整堆的函数思想：当传入的实参为index时，则认为index的子节点为堆。调整堆是由上向下调整</font>

基于调整堆，实现建堆操作：
```java
public void buildHeap(){
  // 获取堆中的元素个数
  int heapItemsLength = heapItems.size();

  int lastItemIndex = heapItemsLength / 2;
  for (int i = lastItemIndex; i >= 0; i--) {
    // 对以i为父节点的二叉树调整堆
    heapfiy(i); 
  }

}
```

基于调整堆，实现出堆操作：
```java
public int remove() {
  int heapItemsLength = heapItems.size();

  // 获取堆顶元素的值
  Integer ans = heapItems.get(0);
  
  // 将堆最后一个元素赋给堆顶元素
  heapItems.set(0, heapItems.get(heapItemsLength - 1));
  heapItems.remove(heapItemsLength - 1);


  // 对以堆顶为父节点的二叉树调整堆
  heapfiy(0);

  return ans;
}
```

### 入堆
由下向上调整实现入堆操作：
```java
public void add(Integer item) {
  // 添加到堆尾
  heapItems.add(item);

  // 获取入堆元素在堆中的下标
  int nowIndex = heapItems.size() - 1;

  while(nowIndex != 0) {
    int parentIndex = (nowIndex - 1) / 2;
    if (item < heapItems.get(parentIndex)) {
      swap(nowIndex, parentIndex);
      nowIndex = parentIndex;
    } else {
      return;
    }
  }
}
```


### 堆操作完整代码
```java
class Heap {

  private ArrayList<Integer> heapItems = null;

  private void swap(int a, int b) {
    Integer temp = heapItems.get(a);
    heapItems.set(a, heapItems.get(b));
    heapItems.set(b, temp);
  }

  public void heapfiy(int index) {
    int heapItemsLength = heapItems.size();
    int c1 = index * 2 + 1;
    int c2 = index * 2 + 2;
    int max = index;
    if (c1 < heapItemsLength && heapItems.get(c1) < heapItems.get(max)) {
      max = c1; 
    }
    if (c2 < heapItemsLength && heapItems.get(c2) < heapItems.get(max)) {
      max = c2; 
    }
    if (max != index) {
      swap(max, index);
      heapfiy(max);
    }
  }

  public void buildHeap(){
    int heapItemsLength = heapItems.size();
    int lastItemIndex = heapItemsLength / 2 - 1;
    for (int i = lastItemIndex; i >= 0; i--) {
      heapfiy(i); 
    }
  }

  public Heap(Integer[] heapItems) {
    this.heapItems = new ArrayList<Integer>(Arrays.asList(heapItems));
    buildHeap();
  }

  public Integer remove() {
    int heapItemsLength = heapItems.size();
    Integer ans = heapItems.get(0);
    heapItems.set(0, heapItems.get(heapItemsLength - 1));
    heapItems.remove(heapItemsLength - 1);
    heapfiy(0);
    return ans;
  }
  
  public void add(Integer item) {
    heapItems.add(item);
    int nowIndex = heapItems.size() - 1;
    while(nowIndex != 0) {
      int parentIndex = (nowIndex - 1) / 2;
      if (item < heapItems.get(parentIndex)) {
        swap(nowIndex, parentIndex);
        nowIndex = parentIndex;
      } else {
        return;
      }
    }
  }

  public String toString() {
    int heapItemsLength = heapItems.size();
    StringBuffer sb = new StringBuffer();
    for (int i = 0; i < heapItemsLength; i++) {
      sb.append(heapItems.get(i) + ", ");
    }
    return sb.toString();
  }

}
```

**例题**
- [703. 数据流中的第 K 大元素](https://leetcode-cn.com/problems/kth-largest-element-in-a-stream/)
- [1046. 最后一块石头的重量](https://leetcode-cn.com/problems/last-stone-weight/)

## 优先队列(PriorityQueue)与堆
优先级队列：正常入， 按照优先级出
优先级相同的元素按照其在优先队列中的顺序得到服务。

### 堆实现优先队列
优先队列可以利用堆来实现。

优先队列的两个基本操作：
- 出队：堆顶出队，最后一个记录代替堆顶的位置，重新调整为堆
- 入队：新记录放入最后一个记录后，重新调整为堆

java中的优先级队列为PriorityQueue类
PriorityQueue是基于优先堆的一个无界队列，这个优先队列中的元素可以默认自然排序或者通过提供的Comparator（比较器）在队列实例化的时排序。（不指定Comparator时默认为最小堆）
优先队列不允许空值，而且不支持non-comparable（不可比较）的对象，比如用户自定义的类。优先队列要求使用Java Comparable和Comparator接口给对象排序，并且在排序时会按照优先级处理其中的元素。

[例题](https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/)

## 单调队列
单调队列，顾名思义，是一种具有单调性的队列。众所周知，单调性有单调递增和单调递减两种，相应的单调队列也分为单调递增队列和单调递减队列两种。

### 常用用途
单调递增队列：保证队列头元素一定是当前队列的最小值，用于维护区间的最小值
单调递减队列：保证队列头元素一定是当前队列的最大值，用于维护区间的最大值

### 单调队列基本操作
<font color="red">每个元素**都会**进入队列，但是这个元素进入队列后，可能会影响单调性，所以这个元素在进入队列前，会先弹出影响单调性的元素</font>
例如当前单调递增队列中的值为1,2,4. 当要添加3时，为了保持单调性，需将4去掉。从而变成1,2,3

在java中常使用LinkedList来实现单调队列，因为LinkedList是Deque的子类且有如下方法，可快速构建单调队列
```
Deque<Integer> deque = new LinkedList();

void addFirst(E e)
void addLast(E e)
E removeFirst()
E removeLast()
E peekFirst()
E peekLast()
```


### 模板题
[滑动窗口的最大值](https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/)
本题大意是给出一个长度为n的数组，编程输出每k个连续的数中的最大值和最小值。
最暴力的想法很简单，对于每一段i~i+k-1的序列，逐个比较来找出最大值（和最小值），时间复杂度约为O(n*k)
很显然，这其中进行了大量重复工作，
这时所用到的就是单调队列了。

**例题分析**
要求的是每连续的k个数中的最大（最小）值，很明显，当一个数进入所要 "寻找" 最大值的范围中时，若这个数比其前面（先进队）的数要大，显然，前面的数会比这个数先出队且不再可能是最大值。
也就是说当一个数插入队列时，会先将前面比他小的数弹出
这就相当于维护了一个递减的队列，符合单调队列的定义，减少了重复的比较次数，不仅如此，由于维护出的队伍是查询范围内的且是递减的，队头必定是该查询区域内的最大值，因此输出时只需输出队头即可。
显而易见的是，在这样的算法中，每个数只要进队与出队各一次，因此时间复杂度被降到了O(n)。

例如我们构造一个单调递增的队列会如下：
原序列为：
```
1 3 -1 -3 5 3 6 7
```
因为我们始终要维护队列保证其 递增 的特点，所以会有如下的事情发生：
| 操作                                      | 队列状态 |
| ----------------------------------------- | -------- |
| 1入队                                     | {1}      |
| 3比1大，3入队                             | {1 3}    |
| -1比队列中所有元素小，所以清空队列-1入队  | {-1}     |
| -3比队列中所有元素小，所以清空队列-3入队  | {-3}     |
| 5比-3大，直接入队                         | {-3 5}   |
| 3比5小，5出队，3入队                      | {-3 3}   |
| -3已经在窗体外，所以-3出队；6比3大，6入队 | {3 6}    |
| 7比6大，7入队                             | {3 6 7}  |

代码：
```java
public class Test{
  public static void main(String[] args){
    int[] nums = {1,3,-1,-3,5,3,6,7};
    System.out.println(Arrays.toString(getMax(nums, 3))); //输出：[3, 3, 5, 5, 6, 7]
    System.out.println(Arrays.toString(getMin(nums, 3))); //输出：[-1, -3, -3, -3, 3, 3]
  }

  public static int[] getMax(int[] nums, int k){
    if(nums.length == 0 || k == 0) return new int[0];
    Deque<Integer> deque = new LinkedList();//双端队列
    int[] res = new int[nums.length-k+1]; //用来存放每个子区间中的最大值

    //i为子区间的左边界，j为子区间的右边界，即[i, j]
    for(int i = 1-k, j = 0; j < nums.length; i++, j++){
      //删除单调队列中不属于当前子区间中的元素
      if(i > 0 && deque.peekFirst() == nums[i - 1]){
        deque.removeFirst();
      } 

      //保持单调队列单调递减
      while(!deque.isEmpty() && deque.peekLast() < nums[j]) 
        deque.removeLast();
      deque.addLast(nums[j]);
      
      //记录当前子窗口的最大值
      if(i >= 0){
        res[i] = deque.peekFirst();
      }
    }
    return res;
  }

  public static int[] getMin(int[] nums, int k){
    if(nums.length == 0 || k == 0) return new int[0]; 
    Deque<Integer> deque = new LinkedList();//双端队列
    int[] res = new int[nums.length-k+1]; //用来存放每个子区间中的最大值

    //i为子区间的左边界，j为子区间的右边界，即[i, j]
    for(int i = 1-k, j = 0; j < nums.length; i++, j++){
      //删除单调队列中不属于当前子区间中的元素
      if(i > 0 && deque.peekFirst() == nums[i - 1]){
        deque.removeFirst();
      } 

      //保持单调队列单调递增
      while(!deque.isEmpty() && deque.peekLast() > nums[j]) 
        deque.removeLast();
      deque.addLast(nums[j]);
      
      //记录当前子窗口的最小值
      if(i >= 0){
        res[i] = deque.peekFirst();
      }
    }
    return res;
  }
}
```


>其他题目：
[队列的最大值](https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof/)

## 单调栈
顾名思义，单调栈即满足单调性的栈结构。与单调队列相比，其只在一端进行进出。

### 常用用途
单调递增栈：能表示入栈元素左边第一个比它大的元素
单调递减栈：能表示入栈元素左边第一个比它小的元素

### 单调栈基本操作
<font color="red">每个元素**都会**压入栈，但是这个元素压入栈后，可能会影响单调性，所以这个元素在压入栈前，会先弹出影响单调性的元素</font>
例如：栈中自顶向下的元素为1,3,5,10,30,50 ，插入元素20时为了保证单调性需要依次弹出元素1,3,5,10，操作后栈变为20,30,50。

### 模板题
**题目描述：**
给定一个长度为N的整数数列，输出每个数左边第一个比它小的数，如果不存在则输出-1
**输入样例**
```
3 4 2 7 5
```
**输出样例**
```
-1 3 -1 2 2
```
**代码**
```java
public class Te{
  public static void main(String[] args){
    int[] nums = {3,4,2,7,5};
    System.out.println(Arrays.toString(getFirstMin(nums))); //输出：[-1, 3, -1, 2, 2]
  }

  public static int[] getFirstMin(int[] nums){
    Stack<Integer> stack = new Stack();
    int[] res = new int[nums.length];
    for(int i = 0; i < nums.length; i++){
      //如果栈顶元素大于当前待入栈元素，则出栈
      while(!stack.isEmpty() && stack.peek() > nums[i])
        stack.pop();

      if(stack.isEmpty()){
        //如果栈空，则没有比该元素小的值。
        res[i] = -1;
      }
      else{
        res[i] = stack.peek();
      }

      stack.push(nums[i]);
    }
    return res; 
  }
}
```

## 滚动数组
滚动数组是DP中的一种编程思想。简单的理解就是让数组滚动起来，每次都使用固定的几个存储空间，来达到压缩，节省存储空间的作用。起到优化空间，主要应用在递推或动态规划中（如01背包问题）。因为DP题目是一个自底向上的扩展过程，我们常常需要用到的是连续的解，前面的解往往可以舍去。所以用滚动数组优化是很有效的。利用滚动数组的话在N很大的情况下可以达到压缩存储的作用。

举个简单的例子
### 一维
斐波那契数列：
```cpp
int main()
{
    int i;
    long long d[80];
    d[0]=1;
    d[1]=1;
    for(i=2;i<80;i++)
    {
        d[i]=d[i-1]+d[i-2];
    }
    printf("%lld\n",d[79]);
    return 0;
}
```
上面这个循环`d[i]`只依赖于前两个数据`d[i - 1]`和`d[i - 2]`; 为了节约空间用滚动数组的做法。
```cpp
int main()
{
    int i;
    long long d[3];
    d[1]=1;
    d[2]=1;
    for(i=2;i<80;i++)
    {
        d[0]=d[1];
        d[1]=d[2];
        d[2]=d[0]+d[1]; 
    }
    printf("%lld\n",d[2]);
    return 0;
}
```
另一种表达形式 
```cpp
int main()
{
    int i;
    long long d[3];
    d[0] = 1;
    d[1] = 1;
    for(i=2;i<80;i++)
    {
    	d[i%3]=d[(i-1)%3]+d[(i-2)%3];
    }
    printf("%lld\n",d[79%3]);
    return 0;
}
```

### 二维
1. 例子1
```cpp
int i, j, d[100][100];
for(i = 1; i < 100; i++)
    for(j = 0; j < 100; j++)
        d[i][j] = d[i - 1][j] + d[i][j - 1];
```
上面的`d[i][j]`只依赖于`d[i - 1][j]`, `d[i][j - 1]`;
运用滚动数组
```cpp
int i, j, d[2][100];
for(i = 1; i < 100; i++)
    for(j = 0; j < 100; j++)
        d[i % 2][j] = d[(i - 1) % 2][j] + d[i % 2][j - 1];
```

2. 例子2
对于`dp[i][j] = dp[i-1][j] + dp[i][j-1]`滚动过程如下：
![](https://gitee.com/NaisWang/images/raw/master/img/gif.gif)
因此使用滚动数组可以降为1维`dp[j] = dp[j] + dp[j-1]`


## Trie(字典树、前缀树)
在计算机科学中，trie，又称前缀树或字典树，是一种有序树，用于保存关联数组，其中的键通常是字符串。与二叉查找树不同，键不是直接保存在节点中，而是由节点在树中的位置决定。一个节点的所有子孙都有相同的前缀，也就是这个节点对应的字符串，而根节点对应空字符串。一般情况下，不是所有的节点都有对应的值，只有叶子节点和部分内部节点所对应的键才有相关的值。

![](https://gitee.com/NaisWang/images/raw/master/img/20211217230243.png)

### 应用
trie树常用于搜索提示。如当输入一个网址，可以自动搜索出可能的选择。当没有完全匹配的搜索结果，可以返回前缀最相似的可能。

### 实现方式
trie树实际上是一个**确定有限状态自动机(DFA);**

见例题：[208. 实现 Trie (前缀树)](https://leetcode-cn.com/problems/implement-trie-prefix-tree/)
Trie（发音类似 "try"）或者说 前缀树 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。请你实现 Trie 类：
- Trie() 初始化前缀树对象。
- void insert(String word) 向前缀树中插入字符串 word 。
- boolean search(String word) 如果字符串 word 在前缀树中，返回 true（即，在检索之前已经插入）；否则，返回 false 。
- boolean startsWith(String prefix) 如果之前已经插入的字符串 word 的前缀之一为 prefix ，返回 true ；否则，返回 false 。

示例：
```
输入
["Trie", "insert", "search", "search", "startsWith", "insert", "search"]
[[], ["apple"], ["apple"], ["app"], ["app"], ["app"], ["app"]]
输出
[null, null, true, false, true, null, true]

解释
Trie trie = new Trie();
trie.insert("apple");
trie.search("apple");   // 返回 True
trie.search("app");     // 返回 False
trie.startsWith("app"); // 返回 True
trie.insert("app");
trie.search("app");     // 返回 True
```

代码：
```java
class Trie {

  private Map<Integer, Map<Character, Integer>> transfer = new HashMap();

  // 存储‘接受状态’
  private List<Integer> acceptState = new ArrayList();
  // 当前最大状态id
  private int stateCount = 0;
  
  public Trie() {
    transfer.put(1, new HashMap<Character, Integer>());
    stateCount++;
  }

  public void insert(String word) {
    int length = word.length();
    Integer state = 1;
    for (int i = 0; i < length; i++) {
      char ch = word.charAt(i);
      /*
       * 如果缺少下一个状态，则添加状态
      */
      if (!transfer.get(state).containsKey(ch)) {
        int newState = ++stateCount;
        transfer.get(state).put(ch, newState);
        transfer.put(newState, new HashMap<Character, Integer>());
        state = newState;
      } else {
        state = transfer.get(state).get(ch);
      }
    }
    acceptState.add(state);
  }

  public boolean search(String word) {
    int length = word.length();
    Integer state = 1;
    for (int i = 0; i < length; i++) {
      char ch = word.charAt(i);
      if (!transfer.get(state).containsKey(ch)) {
        return false;
      } else {
        state = transfer.get(state).get(ch);
      }
    }
    return acceptState.contains(state);
  }

  public boolean startsWith(String prefix) {
    int length = prefix.length();
    Integer state = 1;
    for (int i = 0; i < length; i++) {
      char ch = prefix.charAt(i);
      if (!transfer.get(state).containsKey(ch)) {
        return false;
      } else {
        state = transfer.get(state).get(ch);
      }
    }
    return true;
  }
}
```

## 并查集
在计算机科学中，并查集（英文：Disjoint-set data structure，直译为不交集数据结构）是一种数据结构，用于处理一些不交集（Disjoint sets，一系列没有重复元素的集合）的合并及查询问题。并查集支持如下操作：
- 查询：查询某个元素属于哪个集合，通常是返回集合内的一个“代表元素”。这个操作是为了判断两个元素是否在同一个集合之中。
- 合并：将两个集合合并为一个。
- 添加：添加一个新集合，其中有一个新元素。添加操作不如查询和合并操作重要，常常被忽略。

由于支持查询和合并这两种操作，并查集在英文中也被称为联合-查找数据结构（Union-find data structure）或者合并-查找集合（Merge-find set）。

“并查集”可以用来指代任何支持上述操作的数据结构，但是一般来说，“并查集”特指其中最常见的一种实现：不交集森林（Disjoint-set forest）。

### 表示
不交集森林把每一个集合以一棵树表示，每一个节点即是一个元素。节点保存着到它的父节点的引用，树的根节点则保存一个空引用或者到自身的引用或者其他无效值，以表示自身为根节点。

### 并查集初始化
```java
int fa[MAXN];
voi init(int n){
  for(int i = 1; i <= n; i++){
    fa[i] = i;
  }
}
```
假如有编号为1，2，3，…，n的n个元素，我们用一个数组fa[]来存储每个元素的父节点。一开始，我们先将它们的父节点设为自己。
<img src="https://gitee.com/NaisWang/images/raw/master/img/20210419120837.png" width="700px"/>

### 查找
在不交集森林中，每个集合的代表即是集合的根节点。查询操作Find(x)从x开始，根据节点到父节点的引用向根行进，直到找到根节点。代码实现如下：
```java
int find(int x) {
  // 寻找x所在集合的根节点
  if (fa[x] == x)  // 如果x是集合根节点则返回
    return x;
  else
    return find(fa[x]);  // 如果不是，则根据x的父节点向根行进，直到找到根节点
}
```
显然这样最终会返回x所在集合的根节点。

#### 路径压缩优化
在集合很大或者树很不平衡时，上述代码的效率很差，最坏情况下（树退化成一条链时），单次查询的时间复杂度高达${\displaystyle \mathrm {O} \left(n\right)}$。一个常见的优化是路径压缩：在查询时，把被查询的节点到根节点的路径上的所有节点的父节点设置为根结点，从而减小树的高度。也就是说，在向上查询的同时，把在路径上的每个节点都直接连接到根上，以后查询时就能直接查询到根节点。代码实现：
```java
int find(int x) {
  if (fa[x] == x)
    return x;
  else {
    fa[x] = find(fa[x]);
    return fa[x];
  }
}
```

### 合并
合并操作union(x, y)把元素x所在的集合与元素y所在的集合合并为一个。合并操作首先找出节点x与节点y对应的两个根节点，如果两个根节点其实是同一个，则说明元素x与元素y已经位于同一个集合中，否则，则使其中一个根节点成为另一个的父节点。代码实现：
```java
void union(int x, int y) {
  int xRoot = find(x);
  int yRoot = find(y);
  if (xRoot != yRoot) {
    fa[xRoot] = yRoot;
  }
}
```

#### 按秩合并优化
上述代码的问题在于，可能会使得树不平衡，增大树的深度，从而增加查询的耗时。一个控制树的深度的办法是，在合并时，比较两棵树的大小，较大的一棵树的根节点成为合并后的树的根节点，较小的一棵树的根节点则成为前者的子节点。

判断树的大小有两种常用的方法，一个是以树中元素的数量作为树的大小，这被称为按大小合并。代码实现：
```java
int[] size = new int[MAXN];
Arrays.fill(size, 1); // 记录并初始化子树的大小为 1

void union(int x, int y) {
  int xRoot = find(x), 
  int yRoot = find(y);

  if (xRoot != yRoot) {
    int largeRoot;
    int smallRoot;
    if (size[xRoot] < size[yRoot]) {
      largeRoot = yRoot;
      smallRoot = xRoot;
    }else {
      largeRoot = xRoot;
      smallRoot = yRoot;
    }

    fa[smallRoot] = largeRoot;
    size[largeRoot] = size[largeRoot] + size[smallRoot];
  }
}
```

需要注意的是，上面的代码中，只有根节点的size有意义，非根节点的size是没有意义的。

另一种做法则是使用“秩”来比较树的大小。”秩“的定义如下：
- 只有根节点的树（即只有一个元素的集合），秩为0；
- 当两棵秩不同的树合并后，新的树的秩为原来两棵树的秩的较大者；
- 当两棵秩相同的树合并后，新的树的秩为原来的树的秩加一。
容易发现，在没有路径压缩优化时，树的秩等于树的深度减一。在有路径压缩优化时，树的秩仍然能反映出树的深度和大小。在合并时根据两棵树的秩的大小，决定新的根节点，这被称作按秩合并。用代码表示如下：
```java
int[] rank = new int[MAXN];
Arrays.fill(rank, 0); // 记录并初始化子树的秩为0

void union(int x, int y) {
  int xRoot = find(x), 
  int yRoot = find(y);

  if (xRoot != yRoot) {
    int largeRoot;
    int smallRoot;
    if (rank[xRoot] < rank[yRoot]) {
      largeRoot = yRoot;
      smallRoot = xRoot;
    }else {
      largeRoot = xRoot;
      smallRoot = yRoot;
    }

    fa[smallRoot] = largeRoot;
    if (rank[largeRoot] = rank[smallRoot]) {
      rank[largeRoot] = rank[largeRoot] + 1;
    }
  }
}
```
同样，上面的代码中，只有根节点的rank有意义，非根节点的rank是没有意义的。

### 例题
[合并集合-模板题](https://www.acwing.com/problem/content/838/)
[格子游戏](https://www.acwing.com/solution/content/45947/)

## 树状数组
树状数组或二元索引树（英语：Binary Indexed Tree），又以其发明者命名为Fenwick树，最早由Peter M. Fenwick于1994年以A New Data Structure for Cumulative Frequency Tables[1]为题发表在SOFTWARE PRACTICE AND EXPERIENCE。**其初衷是解决数据压缩里的累积频率（Cumulative Frequency）的计算问题，现多用于高效计算数列的前缀和， 区间和。**它可以以$O(\log n)$的时间得到任意前缀和${\displaystyle \sum _{i=1}^{j}A[i],1<=j<=N}$，并同时支持在$O(\log n)$时间内支持动态单点值的修改。空间复杂度$O(n)$。

树状数组和线段树具有相似的功能，但他俩毕竟还有一些区别：树状数组能有的操作，线段树一定有；线段树有的操作，树状数组不一定有。但是树状数组的代码要比线段树短，思维更清晰，速度也更快，在解决一些单点修改的问题时，树状数组是不二之选。

### 符号含义
- BIT: 树状数组
- MaxVal: 具有非0频率值的数组最大索引，其实就是问题规模或数组大小n
- f[i]: 索引为i的频率值，即原始数组中第i个值。i=1…MaxVal
- c[i]: 索引为i的累积频率值，c[i]=f[1]+f[2]+…+f[i]
- tree[i]: 索引为i的BIT值(下文会介绍它的定义)
- $num^-$ : 整数num的补数（注意不是补码），即在num的二进制表示中，0换为1，1换成0。如：num=10101，则 $num^–$ =01010

注意: 一般情况下，我们令$f[0]=c[0]=tree[0]=0$，**所以下面内容中的数组的索引都从１开始**。 这样会给编程带来许多方便。

### 基本思想
每个整数都能表示为一些2的幂次方的和，比如13，其二进制表示为1101，所以它能表示为： 13 = 20 + 22 + 23 .类似的，累积频率可表示为其子集合之和。在本文的例子中， 每个子集合包含一些连续的频率值，各子集合间交集为空。比如累积频率$c[13]= f[1]+f[2]+…+f[13]$，可表示为三个子集合之和(数字3是随便举例的， 下面的划分也是随便举例的)，$c[13]=s1+s2+s3$， 其中$s1=f[1]+f[2]+…+f[4]，s2=f[5]+f[6]+…+f[12]，s3=f[13]$。

idx记为BIT的索引，r记为idx的二进制表示中最右边的1后面0的个数， 比如idx=1100(即十进制的12)，那么r=2。$tree[idx]$记为f数组中， 索引从$(idx-2^r +1)$到idx的所有数的和，包含$f[idx-2^r +1]$和$f[idx]$。即： $tree[idx]=f[idx-2^r +1]+…+f[idx]$，见表1.1和1.2,你就会一目了然。 我们也可称idx对索引$(idx-2^r +1)$到索引idx负责。

![](https://gitee.com/NaisWang/images/raw/master/img/20211218141124.png)
![](https://gitee.com/NaisWang/images/raw/master/img/20211218132825.png)

假设我们要得到索引为13的累积频率(即$c[13]$)，在二进制表示中，13=1101。因此， 我们可以这样计算：$c[1101]=tree[1101]+tree[1100]+tree[1000]$

### 分离出最后的1
注意: 最后的1表示一个整数的二进制表示中，从左向右数最后的那个1。

由于我们经常需要将一个二进制数的最后的1提取出来，因此采用一种高效的方式来做这件 事是十分有必要的。令num是我们要操作的整数。在二进制表示中，num可以记为a1b, a代表最后的1前面的二进制数码，由于a1b中的1代表的是从左向右的最后一个1， 因此b全为0，当然b也可以不存在。比如说13=1101，这里最后的1右边没有0，所以b不存在。

我们知道，对一个数取负等价于对该数的二进制表示取反加1。所以-num等于(a1b)– +1= a– 0b– +1。由于b全是0，所以b– 全为1。最后，我们得到：$-num=(a1b)^– +1=a^–0b^– +1=a^–0(1…1)+1=a^–1(0…0)=a^–1b$

现在，我们可以通过与操作(在C++,java中符号为&)将num中最后的1分离出来：$num & -num = a1b & a^–1b = (0…0)1(0…0)$

lowbit的一个简便求法:（C++）
```cpp
int lowbit(int x)
{
    return x&(-x);
}
```

### 新建
根据：${\displaystyle tree_{i}=\sum _{j=i-lowbit(i)+1}^{i}f_{j}}$，进行初始化
```cpp
void build() {
  for (int idx = 1; idx <= MaxVal; idx++) {
    for (int j = idx - lowbit(idx) + 1; j <= idx; j--) {
      tree[idx] += f[j];
    }
  }
}
```

### 读取累积频率
给定索引idx，如果我们想获取累积频率即$c[idx]$，我们只需初始化sum=0, 然后当idx>0时，重复以下操作：sum加上$tree[idx]$, 然后将idx最后的1去掉。 (C++代码如下)
```cpp
int read(int idx) {
  int sum = 0;
  while (idx > 0) {
    sum += tree[idx];
    idx -= lowbit(idx);
  }
  return sum;
}
```
为什么可以这么做呢？关键是tree数组设计得好。我们知道，tree数组是这么定义的： $tree[idx] = f[idx-2r +1] +…+ f[idx]$. 上面的程序sum加上$tree[idx]$后， 去掉idx最后的1，假设变为idx1，那么有$idx1 = idx-2^r$,　sum接下来加上$tree[idx1] = f[idx1-2^{r1} +1] +…+ f[idx1] = f[idx1-2^{r1} +1] +…+ f[idx-2^r ]$， 我们可以看到$tree[idx1]$表达示的最右元素为$f[idx-2^r ]$，这与$tree[idx]$表达式的最左元素$f[idx-2^r +1]$无缝地连接了起来。所以，只需要这样操作下去，即可求得$f[1]+…+ f[idx]$，即$c[idx]$的结果。

来看一个具体的例子，当idx=13时，初始sum=0:
```
tree[1101]=f[13]
tree[1100]=f[9]+...+f[12]
tree[1000]=f[1]+...+f[8]
c[1101]=f[1]+...+f[13]=tree[1101]+tree[1100]+tree[1000]
```
![](https://gitee.com/NaisWang/images/raw/master/img/20211218142053.png)

read函数迭代的次数是idx二进制表示中位的个数，其最大值为log(MaxVal)。 在本文中MaxVal=16。

时间复杂度：O(log MaxVal)
代码长度：不到10行

### 改变某个位置的频率并且更新数组
当我们改变f数组中的某个值，比如$f[idx]$，那么tree数组中哪些元素需要改变呢？ 在读取累积频率一节，我们每累加一次$tree[idx]$，就将idx最后一个1移除， 然后重复该操作。而如果我们改变了f数组，比如$f[idx]$增加val，我们则需要为当前索引的 tree数组增加val：$tree[idx]　+= val$。然后idx更新为idx加上其最后的一个1， 当idx不大于MaxVal时，不断重复上面的两个操作。详情见以下C++函数：
```cpp
void update(int idx, int val) {
  while (idx <= MaxVal) {
    tree[idx] += val;
    idx += lowbit(idx);
  }
}
```
接下来让我们来看一个例子，当idx=5时：

![](https://gitee.com/NaisWang/images/raw/master/img/20211218143347.png)

使用上面的算法或者按照图1.6的箭头所示去操作，我们即可更新BIT。

时间复杂度：O(log MaxVal)
代码长度：不到10行

### 模版
```java
class FenwickTree {

  private int[] tree = null;
  private int[] f = null;
  private int MaxVal;

  public FenwickTree(int[] f, int MaxVal) {
    this.f = f;
    this.MaxVal = MaxVal;
    this.tree = new int[MaxVal + 1];
    build();
  }

  private int lowbit(int x) {
    return x & -x;
  }

  private void build() {
    for (int idx = 1; idx <= MaxVal; idx++) {
      for (int j = idx - lowbit(idx) + 1; j <= idx; j++) {
        tree[idx] += f[j];
      }
    }
  }

  /**
   * @param idx: f数组的下标
   * @param val: 需要增加的值
   */
  public void update(int idx, int val) {
    while (idx <= MaxVal) {
      tree[idx] += val;
      idx += lowbit(idx);
    }
  }

  /**
   * @param idx: f数组的下标
   * @return f数组前idx个元素之和，包括第idx个元素
   */
  public int read(int idx) {
    int sum = 0;
    while (idx > 0) {
      sum += tree[idx];
      idx -= lowbit(idx);
    }
    return sum;
  }
  
}
```
例题：[P3374 【模板】树状数组 1](https://www.luogu.com.cn/problem/P3374)

## 线段树
线段树（英语：Segment tree）是一种二叉树形数据结构，1977年由Jon Louis Bentley发明]，**用以存储区间或线段，并且允许快速查询结构内包含某一点的所有区间**。

### 结构
线段树是一个平衡的二叉树，它将每个长度不为1的区间划分成左右两个区间递归求解。令整个区间的长度为N，则其有N个叶节点，每个叶节点代表一个单位区间，每个内部结点代表的区间为其两个儿子代表区间的联集。这种数据结构可以方便的进行大部分的区间操作。

对于数组`[1, 3, 5, 7, 9, 11]`, 对应的线段树如下：
![](https://gitee.com/NaisWang/images/raw/master/img/20211218164856.png)

由于线段时是一个平衡二叉树，及对于前n-1层，为完全二叉树，为了方便存储，我们可以添加几个虚拟节点，使其n层为完全二叉树，对于上面的例子，虚拟出了节点4与节点6的孩子节点。为了不影响全局效果，需将这些虚拟节点的值设为0。添加虚拟节点后的线段树，使用数组存储的效果如下图所示：

![](https://gitee.com/NaisWang/images/raw/master/img/20211218165332.png)

### 模版
```java
class SegmentTree {
  private final int MAX_LEN = 1000;
  //原数组
  private int[] arr = null;
  //存储完全二叉树所有节点值的数组
  private int[] tree = new int[MAX_LEN];

  public SegmentTree(int[] arr) {
    this.arr = arr;
    buildTree(0, 0, arr.length - 1);
  } 

  /**
   * 构建操作
   * @param nodeIndexForTree: 位于tree数组中的节点下标
   * @param startIndexForArr: 当前节点所包含的原数组范围的左边界下标
   * @param endIndexForArr: 当前节点所包含的原数组范围的右边界下标
   */
  private void buildTree(int nodeIndexForTree, int startIndexForArr, int endIndexForArr) {
    if (startIndexForArr == endIndexForArr) {
      tree[nodeIndexForTree] = arr[startIndexForArr]; 
    } else {
      int midIndexForArr = (startIndexForArr + endIndexForArr) / 2;
      int leftNodeIndexForTree = 2 * nodeIndexForTree + 1; 
      int rightNodeIndexForTree = 2 * nodeIndexForTree + 2;
      buildTree(leftNodeIndexForTree, startIndexForArr, midIndexForArr);
      buildTree(rightNodeIndexForTree, midIndexForArr + 1, endIndexForArr);
      tree[nodeIndexForTree] = tree[leftNodeIndexForTree] + tree[rightNodeIndexForTree];
    }
  }

  /**
   * 更新操作
   * @param nodeIndexForTree: 位于tree数组中的节点下标
   * @param startIndexForArr: 当前节点所包含的原数组范围的左边界下标
   * @param endIndexForArr: 当前节点所包含的原数组范围的右边界下标
   * @param index: 要更新的节点的arr下标
   * @param val: 要更新的值
   */
  public void updateTree(int nodeIndexForTree, int startIndexForArr, int endIndexForArr, int index, int val) {
    if (startIndexForArr == endIndexForArr) {
      arr[index] = val;
      tree[nodeIndexForTree] = val;
    } else {
      int midIndexForArr = (startIndexForArr + endIndexForArr) / 2;
      int leftNodeIndexForTree = 2 * nodeIndexForTree + 1; 
      int rightNodeIndexForTree = 2 * nodeIndexForTree + 2;
      if (index >= startIndexForArr && index <= midIndexForArr) {
        updateTree(leftNodeIndexForTree, startIndexForArr, midIndexForArr, index, val);
      } else {
        updateTree(rightNodeIndexForTree, midIndexForArr + 1, endIndexForArr, index, val);
      }
      tree[nodeIndexForTree] = tree[leftNodeIndexForTree] + tree[rightNodeIndexForTree];
    }
  }

  /**
   * 查询区间和操作
   * @param nodeIndexForTree: 位于tree数组中的节点下标
   * @param startIndexForArr: 当前节点所包含的原数组范围的左边界下标
   * @param endIndexForArr: 当前节点所包含的原数组范围的右边界下标
   * @param L: 所要查询的区间的左边界
   * @param R: 所要查询的区间的右边界
   * @return 区间和
   */
  public int queryTree(int nodeIndexForTree, int startIndexForArr, int endIndexForArr, int L, int R) {
    if (R < startIndexForArr || L > endIndexForArr) {
      return 0;
    } else if (L <= startIndexForArr && R >= endIndexForArr) {
      return tree[nodeIndexForTree];
    } else if (startIndexForArr == endIndexForArr) {
      return tree[nodeIndexForTree];
    } else {
      int midIndexForArr = (startIndexForArr + endIndexForArr) / 2;
      int leftNodeIndexForTree = 2 * nodeIndexForTree + 1; 
      int rightNodeIndexForTree = 2 * nodeIndexForTree + 2;
      int sumLeft = queryTree(leftNodeIndexForTree, startIndexForArr, midIndexForArr, L, R);
      int sumRight = queryTree(rightNodeIndexForTree, midIndexForArr + 1, endIndexForArr, L, R);
      return sumLeft + sumRight;
    }

  }

}
```

## ST表
### 简介

![](https://gitee.com/NaisWang/images/raw/master/img/20211219112030.png)

ST 表是用于解决 可重复贡献问题 的数据结构。

> 可重复贡献问题 是指对于运算$opt$ ，满足 $x opt x = x$，则对应的区间询问就是一个可重复贡献问题。例如，最大值有$max(x, x) = x$ ，gcd() 有$gcd(x, x) = x$ ，所以 RMQ 和区间 GCD 就是一个可重复贡献问题。像区间和就不具有这个性质，如果求区间和的时候采用的预处理区间重叠了，则会导致重叠部分被计算两次，这是我们所不愿意看到的。另外， $opt$还必须满足结合律才能使用 ST 表求解。

> RMQ 是英文 Range Maximum/Minimum Query 的缩写，表示区间最大（最小）值。解决 RMQ 问题有很多种方法，可以参考 RMQ 专题。

### 引入
[ST 表模板题](https://www.luogu.com.cn/problem/P3865)

题目大意：给定n个数，有m个询问，对于每个询问，你需要回答区间[l, r]中的最大值。

考虑暴力做法。每次都对区间[l, r]扫描一遍，求出最大值。

显然，这个算法会超时。




# 动态规划
动态规划通过组合子问题的解来求解原问题，一般来说，动态规划应用于**重叠子问题**的情况，即不同的子问题具有公共的子子问题。
动态规划算法对每个子子问题**只求解一次**，将其解保存在一个表格中，从而无需每次求解一个子子问题时都重新计算，避免了这种不必要的计算工作。
动态规划有两种实现方法：
- 第一种方法称为**带备忘的自顶向下法（top-down with memoization）**, 即**带备忘录的递归**。此方法仍按自然的递归形式编写过程，但过程会保存每个子问题的解（通常保存在一个数组或散列表中）。当需要一个子问题的解时，过程首先检查是否已经保存过此解。如果是，则直接返回保存的值，从而节省了计算时间；否则，按通常方式计算这个子问题。我们称这个递归过程是带备忘的（memoized），因为它“记住”了之前已经计算出的结果。
- 第二种方法称为**自底向上法（bottom-up method）**。这种方法一般需要恰当定义子问题“规模”的概念，使得任何子问题的求解都只依赖于“更小的"子问题的求解。因而我们可以将子问题按规模排序，按由小至大的顺序进行求解。当求解某个子问题时，它所依赖的那些更小的子问题都已求解完毕，结果已经保存。每个子问题只需求解一次，当我们求解它（也是第一次遇到它）时，它的所有前提子问题都已求解完成。

## 步骤
所有动态规划都是对递归问题进行优化，所以拿到一个问题时，最先不是想其动态规划写法，而是想递归写法，再对其递归写法进行优化，优化成动态规划的2种实现方式之一(带备忘录的递归或自底向上法)。

递归搜索树中的每个节点对应一个子问题，我们分析递归搜索树中是否有子问题重复计算，如果有重复计算，则我们可以用备忘录来保存子问题的计算结果，这里的备忘录需要保存2个信息：一个是子问题的范围，二是子问题的结果。因此我们很容易想到用数组作为备忘录，数组的下标表示子问题的范围，对应的数组值表示子问题的结果。知道备忘录如何定义后，我们就需要用备忘录来简化递归搜索树。简化方式为：子问题入栈前，判断该子问题是否用备忘录记录了，如被记录，则直接用备忘录中的对应值，而无需入栈。如果该子问题没有被备忘录记录，则该子问题入栈，且当该子问题出栈时用备忘录记录该子问题的结果。用备忘录简化完递归搜索树后，分析备忘录中的各个数据之间的关系，看是否能够推出他们之间的通项公式。

![](https://gitee.com/NaisWang/images/raw/master/img/20211115153607.png)

### 例题：打家劫舍(力扣198)
你是一个小偷，现在有一排相邻的房屋等着你去偷窃。这些房子装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。给定一个代表每个房屋存放金额的正整数数组，计算你不触动警报装置的情况下，一夜之内能够偷窃到的最高金额。（不用考虑偷窃时间）
```
示例1：
输入：[1，2，3，1，3]
输出：7解释：偷窃1号房屋（金额=1），然后偷窃3号房屋（金额=3），接着偷窃5号房屋（金额=3）。偷窃到的最高金额=1+3+3=7。
示例2：
输入：[2，7，2，3，8]
输出：15解释：偷窃2号房屋（金额=7），然后偷窃5号房屋（金额=8）。偷窃到的最高金额=7+8=15。
```

#### 分析1
递归搜索树:
![](https://gitee.com/NaisWang/images/raw/master/img/20211114180752.png)
代码：
```java
public class Main {
  public static void main(String args[]) {
    Solution so = new Solution();
    System.out.println(so.rob(new int[]{1, 2, 3, 1, 3}));
  }
}

class Solution {
  private int length;

  public int rob(int[] nums) {
    length = nums.length; 
    return dfs(-2, nums);
  }

  private int dfs(int now, int[] nums) {
    if (now >= length - 2) {
      return nums[now];
    }
    int maxNum = Integer.MIN_VALUE;
    for (int i = now + 2; i < length; i++) {
      maxNum = Math.max(maxNum, dfs(i, nums));
    }
    if(now == -2) return maxNum;
    return maxNum + nums[now];
  }
}
```

**子问题分析：**
- 子问题的范围: 当第一家偷的是第now家且以后偷的家都是大于now时
- 子问题的属性：最大偷窃金额

我们发现出现子问题重复计算的情况，因此我们用备忘录来存储子问题；
此处的备忘录可以设置为`dp[i]`, 表示当第一家偷的是i时，最大偷窃金额为`dp[i]`
定义完备忘录后，简化递归搜索树:
![](https://gitee.com/NaisWang/images/raw/master/img/20211114180829.png)

代码：
```java
public class Main {
  public static void main(String args[]) {
    Solution1 so = new Solution1();
    System.out.println(so.rob(new int[]{1, 2, 3, 1, 3}));
  }
}

class Solution1 {
  private int[] dp = null;
  private int length;

  public int rob(int[] nums) {
    length = nums.length; 
    dp = new int[length];
    initDp();
    return dfs(-2, nums);
  }

  private void initDp() {
    for (int i = 0; i < length; i++) {
      dp[i] = -1; 
    }
  }

  private int dfs(int now, int[] nums) {
    if (now >= length -2) {
      return nums[now];
    }
    int maxNum = Integer.MIN_VALUE;
    for (int i = now + 2; i < length; i++) {
      if(dp[i] == -1){
        dp[i] = dfs(i, nums);
      }
      maxNum = Math.max(maxNum, dp[i]);
    }
    if(now == -2) return maxNum;
    return maxNum + nums[now];
  }
}
```

通过分析发现，无法推出备忘录中的各个数据之间的通项公式, 所以只能使用上述的带有备忘录的递归，而不能使用自底向上法

#### 分析2
递归搜索树：
![](https://gitee.com/NaisWang/images/raw/master/img/20211114183034.png)
代码
```java
public class Main {
  public static void main(String args[]) {
    Solution so = new Solution();
    System.out.println(so.rob(new int[]{1, 2, 3, 1, 3}));
  }
}

class Solution {
  public int rob(int[] nums) {
    return dfs(nums.length-1, nums);
  }

  private int dfs(int now, int[] nums) {
    if(now == 0) return nums[0];
    if(now == 1) return Math.max(nums[1], nums[0]);
    return Math.max(dfs(now-1, nums), dfs(now-2, nums) + nums[now]);
  }
}
```

**子问题分析：**
- 子问题的范围: 只在前now家（包括第now家）偷
- 子问题的属性：最大偷窃金额

我们发现出现子问题重复计算的情况，因此我们用备忘录来存储子问题；
此处的备忘录可以设置为`dp[i]`, 表示只在前i家偷时，最大偷窃金额为`dp[i]`
定义完备忘录后，简化递归搜索树:
![](https://gitee.com/NaisWang/images/raw/master/img/20211114183723.png)

代码：
```java
public class Main {
  public static void main(String args[]) {
    Solution so = new Solution();
    System.out.println(so.rob(new int[]{1, 2, 3, 1, 3}));
  }
}

class Solution {
  private int[] dp = null;

  public int rob(int[] nums) {
    int length = nums.length;
    dp = new int[length];
    initDp(length); 
    return dfs(nums.length-1, nums);
  }

  private void initDp(int length) {
    for (int i = 0; i < length; i++) {
      dp[i] = -1; 
    }
  }

  private int dfs(int now, int[] nums) {
    if(now == 0) return nums[0];
    if(now == 1) return Math.max(nums[1], nums[0]);
    if(dp[now-1] == -1) {
      dp[now-1] = dfs(now-1, nums);
    }
    if(dp[now-2] == -1) {
      dp[now-2] = dfs(now-2, nums);
    }
    return Math.max(dp[now-1], dp[now-2] + nums[now]);
  }
}
```

通过分析发现，可以推出备忘录中的各个数据之间的通项公式为
$$dp(now) = \begin{cases}
nums[0] & now = 0 \\
max(nums[0], nums[1]) & now = 1 \\
max\{dp(now-1), dp(now-2) + nums[now]\} & now \geq 2
\end{cases}$$


所以可以使用从底向上法，代码如下：
```java
public class Main {
  public static void main(String args[]) {
    Solution4 so = new Solution4();
    System.out.println(so.rob(new int[]{1, 2, 3, 1, 3}));
  }
}

class Solution4 {
  public int rob(int[] nums) {
    int length = nums.length;
    if (length == 1) return nums[0]; 
    if (length == 2) return Math.max(nums[0], nums[1]);
    int[] dp = new int[length];
    dp[0] = nums[0];
    dp[1] = Math.max(nums[0], nums[1]);
    for (int i = 2; i < length; i++) {
      dp[i] = Math.max(dp[i-1], dp[i-2] + nums[i]);
    }
    return dp[length-1];
  }
}
```

### 0-1背包问题
[0-1背包问题-模板题](https://www.acwing.com/problem/content/2/)

分析：
当输入为：
```
4 5
1 2
2 4
4 4
4 5
```
递归搜索树：
![](https://gitee.com/NaisWang/images/raw/master/img/20211116094858.png)

代码：
```java
class Solution1 {

  public int solution(int N, int V, int[] v, int[] w) {
    return dfs(N, V, v, w);
  }

  private int dfs(int nowN, int nowV, int[] v, int[] w) {
    if (nowN == 1) {
      if (nowV >= v[1]) {
        return w[1];
      }
      return 0;
    } 

    int min = Integer.MIN_VALUE;
    if (nowV >= v[nowN] ) {
      min = dfs(nowN - 1, nowV - v[nowN], v, w) + w[nowN];
    }

    return Math.max(min, dfs(nowN - 1, nowV, v, w));
  }
  
}
```
**子问题分析：**
- 子问题的范围: 当在前nowN个物品（包括第nowN个物品）中选，且背包容量为nowV时
- 子问题的属性：总价值最大


我们发现出现子问题重复计算的情况，因此我们用备忘录来存储子问题；
此处的备忘录可以设置为`dp[nowN][nowV]`, 表示当在前nowN个物品（包括第nowN个物品）中选，且背包容量为nowV时, 总价值最大为`dp[nowN][nowV]`
定义完备忘录后，简化递归搜索树:
![](https://gitee.com/NaisWang/images/raw/master/img/20211116095038.png)

代码：
```java
class Solution2 {

  private Integer[][] dp = null; 

  public int solution(int N, int V, int[] v, int[] w) {
    dp = new Integer[N+1][V+1];
    return dfs(N, V, v, w);
  }

  private int dfs(int nowN, int nowV, int[] v, int[] w) {
    if (nowN == 1) {
      if (nowV >= v[1]) {
        return w[1];
      }
      return 0;
    } 
    if (nowV >= v[nowN] ) {
      if (dp[nowN - 1][nowV - v[nowN]] == null) {
        dp[nowN - 1][nowV - v[nowN]] = dfs(nowN - 1, nowV - v[nowN], v, w);
      }
    } 
    if (dp[nowN - 1][nowV] == null) {
      dp[nowN - 1][nowV] = dfs(nowN - 1, nowV, v, w);
    } 
    return Math.max(nowV >= v[nowN] ? dp[nowN - 1][nowV - v[nowN]] + w[nowN] : 0, dp[nowN - 1][nowV]);
  }
  
}
```

通过分析发现，可以推出备忘录中的各个数据之间的通项公式为
$$dp[nowN][nowV] = \begin{cases}
dp[nowN-1][nowV] & nowV < v[nowN] \\
max(dp[nowN - 1][nowV - v[nowN]] + w[nowN], dp[nowN - 1][nowV]) & nowV \geq v[nowN] \\
\end{cases}$$


所以可以使用从底向上法，代码如下：
```java
class Solution3 {
  public int solution(int N, int V, int[] v, int[] w) {
    int[][] dp = new int[N+1][V+1];
    for (int nowN = 1; nowN <= N; nowN++) {
      for (int nowV = 0; nowV <= V; nowV++) {
        if (nowV < v[nowN]) {
          dp[nowN][nowV] = dp[nowN - 1][nowV];
        } else {
          dp[nowN][nowV] = Math.max(dp[nowN - 1][nowV - v[nowN]] + w[nowN], dp[nowN - 1][nowV]);
        }
      }
    }
    return dp[N][V]; 
  }
}
```
可以使用滚动数组讲将dp数组从二维降到一维，代码如下：
```java
class Solution {
  public int solution(int N, int V, int[] v, int[] w) {
    int[] dp = new int[V+1];
    for (int i = 1; i <= N; i++) {
      for (int j = V; j >= v[i]; j--) {
        dp[j] = Math.max(dp[j], dp[j - v[i]] + w[i]);
      }
    }
    return dp[V]; 
  }
}
```

### 完全背包问题
[完全背包问题-模板题](https://www.acwing.com/problem/content/3/)
完全背包问题与0-1背包问题的不同点在于完全背包问题中的每种物品都有无限件可用

分析：
当输入为：
```
4 5
1 2
2 4
4 4
4 5
```
递归搜索树：
![](https://gitee.com/NaisWang/images/raw/master/img/20211116101424.png)
代码：
```java
class Solution1 {
  public int solution(int N, int V, int[] v, int[] w) {
    return dfs(N, V, v, w);
  }
  
  private int dfs(int nowN, int nowV, int[] v, int[] w) {
    if (nowN == 1) {
      return nowV / v[1] * w[1];
    }
    int maxNum = nowV / v[nowN];
    int max = Integer.MIN_VALUE;
    for (int i = 0; i <= maxNum; i++) {
      max = Math.max(max, dfs(nowN - 1, nowV - i * v[nowN], v, w) + i * w[nowN]);
    }
    return max;
  }
}
```
**子问题分析：**
- 子问题的范围: 当在前nowN个物品（包括第nowN个物品）中选，且背包容量为nowV时
- 子问题的属性：总价值最大

我们发现出现子问题重复计算的情况，因此我们用备忘录来存储子问题；
此处的备忘录可以设置为`dp[nowN][nowV]`, 表示当在前nowN个物品（包括第nowN个物品）中选，且背包容量为nowV时, 总价值最大为`dp[nowN][nowV]`
定义完备忘录后，简化递归搜索树:
![](https://gitee.com/NaisWang/images/raw/master/img/20211116102353.png)

代码：
```java
class Solution2 {
  private Integer[][] dp = null;

  public int solution(int N, int V, int[] v, int[] w) {
    dp = new Integer[N + 1][V + 1];
    return dfs(N, V, v, w);
  }
  
  private int dfs(int nowN, int nowV, int[] v, int[] w) {
    if (nowN == 1) {
      return nowV / v[1] * w[1];
    }
    int maxNum = nowV / v[nowN];
    int max = Integer.MIN_VALUE;
    for (int i = 0; i <= maxNum; i++) {
      if (dp[nowN - 1][nowV - i * v[nowN]] == null) {
        dp[nowN - 1][nowV - i * v[nowN]] = dfs(nowN - 1, nowV - i * v[nowN], v, w); 
      } 
      max = Math.max(max, dp[nowN - 1][nowV - i * v[nowN]] + i * w[nowN]);
    }
    return max;
  }
}
```

通过分析发现，于是易得状态转移方程：
$dp[nowN][nowV]=max( dp[nowN−1][nowV], dp[nowN−1][nowV−v[nowN]]+w[nowN], dp[nowN-1][nowV−2*v[nowN]]+2*w[nowN],...)$

但是这个东西项数太多，想办法把它转换成两项

由上面的状态转移方程我们可以得到：
$dp[nowN][nowV−v[nowN]]=max(dp[nowN−1][nowV−v[nowN]], dp[nowN−1][nowV−2*v[nowN]]+w[nowN], dp[nowN−1][nowV−3*v[nowN]]+2*w[nowN] ,...)$
观察得到，上面的第二项后面的每一项都是下面的每一项加上一个$W_i$。

于是我们可以得到状态转移方程：
$dp[nowN][nowV]=max(dp[nowN−1][nowV] , dp[nowN][nowV-v[nowN]]+w[nowN]$

$$dp[nowN][nowV] = \begin{cases}
dp[nowN-1][nowV] & nowV < v[nowN] \\
max(dp[nowN−1][nowV] , dp[nowN][nowV-v[nowN]]+w[nowN] & nowV \geq v[nowN] \\
\end{cases}$$

代码：
```java
class Solution3 {

  private int[][] dp;

  public int solution(int N, int V, int[] v, int[] w) {
    dp = new int[N + 1][V + 1];
    for (int nowN = 1; nowN <= N; nowN++) {
      for (int nowV = 0; nowV <= V; nowV++) {
        if (nowV < v[nowN]) {
          dp[nowN][nowV] = dp[nowN - 1][nowV];
        } else {
          dp[nowN][nowV] = Math.max(dp[nowN - 1][nowV], dp[nowN][nowV -v[nowN]] + w[nowN]);
        }
      }
    }
    return dp[N][V];
  }
}
```

### 石子合并问题
[石子合并题目链接](https://www.acwing.com/problem/content/284/)

分析：
当输入为：
```
4 5
1 2
2 4
4 4
4 5
```
递归搜索树：



## 闫式dp分析法
核心思想：从集合的角度考虑
<font color="red">所有的dp问题，本质上都是有限集中的最值、数量问题</font>

<img src="https://gitee.com/NaisWang/images/raw/master/img/20211110150157.png" width="700px"/>

### 分析阶段
动态规划有两个要点：状态与状态转移
那么阶段自然也应该有两个：**状态表示**和**状态计算**
#### 状态表示
把几个具有相同点的元素合在一起考虑，成为一个状态
对于一个状态 F(i) ，考虑两个角度：
- **1.集合** ：F(i) 表示什么集合
由于 F(i) 表示的是一堆东西(这也是DP优于枚举的核心)，我们要考虑这一堆东西的共同特征，如：所有满足某个条件的元素集合
这一点请仔细考虑，到底是大于等于，大于，小于，小于等于，等于......这些的不同会导致状态计算方式的不同
- **2.属性**：F(i)的值与集合的关系：如 max,min,count,sum 等
很明显，F(i)的值大多数时候是一个数，代表这个集合的某一个属性，多是最大值、最小值、数量、总和等。题目问什么，属性一般就是什么

#### 状态计算
**三步走**
1. 先看 F(i) 表示的集合：
<img src="https://gitee.com/NaisWang/images/raw/master/img/20210418093248.png" width="700px"/>

2. 将其划分为若干个子集合，要求不重(有些情况可以重复，例如求最大值)和不漏
<img src="https://gitee.com/NaisWang/images/raw/master/img/20210418093608.png" width="700px"/>
<font color="red">划分的依据：找最后一个不同点(这个待会会讲)</font>

3. 划分过后，根据子集合来求F(i)
如：当属性为 max 时，F(i)=max(子集的max)
当属性为 count 时，F(i)=∑(子集的count)

#### 代码优化
dp问题的优化是对代码作等价变形，常用的手段是使用滚动数组

### 选择问题的dp
有关选择问题的dp，常见的就是背包问题。<font color="red">而选择问题的状态表示都是很相似的，一般状态的第一维表示我只考虑前面i个物品，后面几维一般表示限制，比如体积的限制，重量的限制</font>

#### 0-1背包问题
[0-1背包问题-模板题](https://www.acwing.com/problem/content/2/)
在上述例题中，由于每个物体只有2种可能的状态（取与不取），正如二进制中的0和1，这类问题便被称为「0-1 背包问题」。

**1. 解析**
根据乘法原理，总共的方案为$2^n$  。在所有的方案数中选择一个价值最大的方案，属于有限集的最优问题，可以用试着DP来解。

**2. 状态表示**
对于F(i,j)：
集合：所有只考虑前i个物品，且总体积不超过的j的方案
属性：题目要求我们求最大价值，则其属性就是max。

**3. 状态计算**
<img src="https://gitee.com/NaisWang/images/raw/master/img/20211110144725.png" width="700px"/>

于是我们可以得到状态转移方程：
$F(i,j)=max( F(i−1,j) , F(i−1,j−V_i)+W_i)$
这就事朴素DP的分析过程了，至于压维等时空优化从状态转移方程出发

**代码**
```java
/**
* n: 表示物品数量
* m: 表示背包容积
* v[]: 表示第 i 件物品的体积
* w[]: 表示第 i 件物品的价值
*/
public static int f(){
  int[][] dp = new int[N+1][V+1];
  for(int i = 1; i <= N; i++){
    for(int j = 0; j <= V; j++){
      dp[i][j] = dp[i-1][j];
      if(j >= v[i]) dp[i][j] = Math.max(dp[i][j], dp[i-1][j-v[i]]+w[i]);
    }
  }
  return dp[N][V];
}
```

#### 完全背包问题
[完全背包问题-模板题](https://www.acwing.com/problem/content/3/)
完全背包问题与0-1背包问题的不同点在于完全背包问题中的每种物品都有无限件可用

**1. 解析**
仍然从两个角度考虑：
设状态 F(i,j)

**2. 状态表示**
对于 F(i,j):
集合：所有只从前i个物品中选，总体积不超过j的所有方案。
属性：max。
原因和01背包相似

**3. 状态计算**
<img src="https://gitee.com/NaisWang/images/raw/master/img/20211110150129.png" width="700px"/>

于是易得状态转移方程：
$F(i,j)=max( F(i−1,j), F(i−1,j−V_i)+W_i, F(i−1,j−2*V_i)+2*W_i,...)$

但是这个东西项数太多，想办法把它转换成两项

由上面的状态转移方程我们可以得到：
$F(i,j−V_i)=max( F(i−1,j−V_i), F(i−1,j−2*V_i)+W_i, F(i−1,j−3*V_i)+2*W_i ,...)$
观察得到，上面的第二项后面的每一项都是下面的每一项加上一个$W_i$。

于是我们可以得到状态转移方程：
$F(i,j)=max(F(i−1,j) , F(i,j−V_i)+W_i)$


**代码**
```java
/**
* n: 表示物品数量
* m: 表示背包容积
* v[]: 表示第 i 件物品的体积
* w[]: 表示第 i 件物品的价值
*/
public static int f(){
  int[][] dp = new int[n+1][m+1];
  for(int i = 1; i <= n; i++){
    for(int j = 0; j <= m; j++){
      dp[i][j] = dp[i-1][j];
      if(j >= v[i]) f[i][j] = Math.max(dp[i][j], dp[i][j-v[i]]+w[i]);
    }
  }
  return f[n][m];
}
```

### 区间Dp
顾名思义：区间dp就是在区间上进行动态规划，求解一段区间上的最优解。主要是通过合并小区间的 最优解进而得出整个大区间上最优解的dp算法。

有关区间dp，常见的就是石子合并问题。<font color="red">而区间dp的状态表示都是很相似的，一般状态的第一维表示区间的左端点，第二维表示区间的右端点</font>

#### 石子合并问题
[石子合并题目链接](https://www.acwing.com/problem/content/284/)

**解析**
满足有限集最优化

**状态表示**
对于F(i,j)
集合：所有将区间`[i,j]`合并成一堆的方案集合
属性：题目求的是最小值，所以min。

**状态计算**
1. 看这个F(i,j)表示的集合：
<img src="https://gitee.com/NaisWang/images/raw/master/img/20210419085455.png" width="700px"/>

2. 将其划分若干个子集合
考虑最后一个不同点
最后一次， 也就是合并到`[i,j]`时，一定是由两个区间`[i,k]`和`[k,j]`合并而来的。显然，k∈`[i,j]`
所以我们考虑以这个分界点 k 为划分依据，分成 j−i 类。
<img src="https://gitee.com/NaisWang/images/raw/master/img/20210419091100.png" width="700px"/>
再来看一下合并的区间：
<img src="https://gitee.com/NaisWang/images/raw/master/img/20210419091134.png" width="700px"/>

3. 根据子集合求F(i, j)
以 左边`[i, i+2]`与右边`[i+3, j]`合并成一堆的子集合 为例 ，左边的`[i, i+2]`区间与右边的`[i+3, j]`区间互不干扰，所以两边取min再加上这部分石子的总质量，即为这个子集合的最小值，两边恰好是 F(i,i+2) 和 F(i+3,j)。于是这个子集合的最小代价为$F(i,i+2)+F(i+3,j)+S_j−S_{i−1}$ ，S是石子重量的前缀和。

所以状态转移方程为：
$F(i,j)=min( F(i, i)+F(i+1, j), F(i, i+1)+F(i+2, j), F(i, i+2)+F(i+3,j), ..., F(i, i+k)+F(i+k+1, j), ..., F(i, i+j-1)+F(j,j) ) + S_j-S_{i-1}$

**代码**
```java
public static int f(){
  int[][] f = new int[n+1][n+1];
  for(int len = 2; len <= n; len++){  //len表示区间的长度
    for(int i = 1; i+len-1 <= n; i++){ //i表示区间的左端点
      int j = i+len-1; //j表示区间的右端点
      f[i][j] = Integer.MAX_VALUE;
      for(int k = i; k < j; k++){
        f[i][j] = Math.min(f[i][j], f[i][k]+f[k+1][j]);
      }
      f[i][j] = f[i][j] + s[j] - s[i-1];
    }
  } 
  return f[1][n];
}
```

# 图论
## 单源最短路径
### Dijkstra单源最短路
#### 模版
权值必须非负
```java
/**
 * 单源最短路径，Dijkstra 算法, 使用优先队列实现
 */
class Dijkstra {

  PriorityQueue<PointOfDistance> priorityQueue = new PriorityQueue();

  class PointOfDistance implements Comparable<PointOfDistance> {
    // 点
    public int point;
    // 前一个节点
    public int prePoint;
    // 起点到此点的距离
    public int distance;
    
    // 例如：new PointOfDistance(3, 2, 10)表示起点到节点3的路径为10，且此时节点3点前一个节点为2
    public PointOfDistance(int point, int prePoint, int distance) {
      this.point = point;
      this.prePoint = prePoint;
      this.distance = distance;
    }
    
    @Override
    public int compareTo(PointOfDistance a) {
      return this.distance - a.distance;
    }
  }

  /**
   * @param cost: 两边之间路径花费 
   * @param lowcost: 起点到个点的最小花费
   * @param pre: pre[i]表示起点到i的最短路径中i的前一个节点
   * @param beg: 起点
   */
  public void dijkstra(int[][] cost, int[] lowcost, int[] pre, int n, int beg) {
    int[] vis = new int[n + 1];
    for (int i = 1; i <= n; i++) {
      lowcost[i] = -1;
      pre[i] = -1;
    }

    // 将起点添加到队列 
    priorityQueue.add(new PointOfDistance(beg, -1, 0));
    while (!priorityQueue.isEmpty()) {
      // 从优先队列中取出代价最小的点   
      PointOfDistance a = priorityQueue.poll(); 
      // 判断该点之前是否出过队列，如果为0，表示没有出过队列
      if (vis[a.point] == 0) {
        vis[a.point] = 1;
        lowcost[a.point] = a.distance;
        pre[a.point] = a.prePoint;
        // 遍历其他节点 
        for (int i = 1; i <= n; i++) {
          // 判断节点是否已出队列，是否存在路径
          if (vis[i] == 0 && cost[a.point][i] != 0) {
            priorityQueue.add(new PointOfDistance(i, a.point, lowcost[a.point] + cost[a.point][i]));
          } 
        } 
      } 
    }

  }

}
```
- [849. Dijkstra求最短路 I](https://www.acwing.com/problem/content/851/)



