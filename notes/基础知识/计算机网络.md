# 无线电波
## 概述
无线电波无处不在： 广播电视、移动电话、Wi-Fi、蓝牙、遥控等

# 怎么检测笔记本的网卡是否支持5G的wifi?
输入命令“netsh wlan show drivers”按Enter键执行，查看【支持的无线电 类型】一项，可以看到的无线网卡支持的类型

![](https://raw.githubusercontent.com/NaisWang/images/master/20220409125222.png)

无线网卡支持的无线协议标准（无线模式）中，
- 如果只有802.11 b/g/n，说明该网卡不支持5GHz；
- 如果包含了802.11a或者802.11ac，说明该网卡支持5GHz

# 什么是网络分层以及对应的设备
网络的分层就是就是不同层对网络传输的二进制代码做不同的处理。而这个处理过程需要软硬件来实现，这个软硬件就对应着网络设备。例如数据链路层中的交换机设备就是对物理层处理过后的网络传输的二进制代码进行处理。

> 核心观点：网络设备就是对网络传输的二进制代码进行处理加工，然后进行传送

# 冲突域和广播域的区别
<div class="contianer">
  <iframe width="560" height="315" src="https://www.youtube.com/embed/qsy333797po" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>

<div class="contianer">
  <iframe width="560" height="315" src="https://www.youtube.com/embed/BfY4xTIVPwY" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>

# 网络传输过程以及内网穿透

<div class="contianer">
  <iframe width="560" height="315" src="https://www.youtube.com/embed/-i5iKTzGTc0" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>

<div class="contianer">
  <iframe width="560" height="315" src="https://www.youtube.com/embed/qsy333797po" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>

> 路由器中的NAT对应规则，有两个实现方式。
> 一种是路由器自动配置规则，当局域网内部的主机某端口通过路由器与外界互联网进行连接时，路由器会自动配置该主机端口的相关NAT映射关系，但是当主机的该端口与外界互联网断开连接时，路由器会取消该此端口的NAT映射关系
> 另一种是手动在路由器上进行配置

# WebSocket
WebSocket 是一种网络通信协议，很多高级功能都需要它。
WebSocket 是HTML5开始提供的一种在单个TCP连接上进行全双工通讯的协议。

## 为什么需要 WebSocket？
初次接触 WebSocket 的人，都会问同样的问题：我们已经有了 HTTP 协议，为什么还需要另一个协议？它能带来什么好处？
答案很简单，因为 HTTP 协议有一个缺陷：通信只能由客户端发起。
举例来说，我们想了解今天的天气，只能是客户端向服务器发出请求，服务器返回查询结果。HTTP 协议做不到服务器主动向客户端推送信息。

这种单向请求的特点，注定了如果服务器有连续的状态变化，客户端要获知就非常麻烦。我们只能使用"轮询"：每隔一段时候，就发出一个询问，了解服务器有没有新的信息。最典型的场景就是聊天室。
轮询的效率低，非常浪费资源（因为必须不停连接，或者 HTTP 连接始终打开）。因此，工程师们一直在思考，有没有更好的方法。WebSocket 就是这样发明的。

## 简介
WebSocket 协议在2008年诞生，2011年成为国际标准。所有浏览器都已经支持了。
它的最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于服务器推送技术的一种。

![](https://raw.githubusercontent.com/NaisWang/images/master/20220409125231.png)

其他特点包括：
（1）建立在 TCP 协议之上，服务器端的实现比较容易。
（2）与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。
（3）数据格式比较轻量，性能开销小，通信高效。
（4）可以发送文本，也可以发送二进制数据。
（5）没有同源限制，客户端可以与任意服务器通信。
（6）协议标识符是ws（如果加密，则为wss），服务器网址就是 URL。
```
ws://example.com:80/some/path
```

##  WebSocket 握手
我们来看个典型的 WebSocket 握手
```
GET /chat HTTP/1.1
Host: server.example.com
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==
Sec-WebSocket-Protocol: chat, superchat
Sec-WebSocket-Version: 13
Origin: http://example.com
```
熟悉 HTTP 的童鞋可能发现了，这段类似 HTTP 协议的握手请求中，多了这么几个东西。
```
Upgrade: websocket
Connection: Upgrade
```
这个就是 WebSocket 的核心了，告诉 Apache 、 Nginx 等服务器：注意啦，我发起的请求要用 WebSocket 协议，快点帮我找到对应的助理处理~而不是那个老土的 HTTP。
```
Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==
Sec-WebSocket-Protocol: chat, superchat
Sec-WebSocket-Version: 13
```
首先， Sec-WebSocket-Key 是一个 Base64 encode 的值，这个是浏览器随机生成的，告诉服务器：泥煤，不要忽悠我，我要验证你是不是真的是 WebSocket 助理。
然后， Sec_WebSocket-Protocol 是一个用户定义的字符串，用来区分同 URL 下，不同的服务所需要的协议。简单理解：今晚我要服务A，别搞错啦~

最后， Sec-WebSocket-Version 是告诉服务器所使用的 WebSocket Draft （协议版本），在最初的时候，WebSocket 协议还在 Draft 阶段，各种奇奇怪怪的协议都有，而且还有很多期奇奇怪怪不同的东西，什么 Firefox 和 Chrome 用的不是一个版本之类的，当初 WebSocket 协议太多可是一个大难题。。不过现在还好，已经定下来啦~大家都使用同一个版本：服务员，我要的是13岁的噢

然后服务器会返回下列东西，表示已经接受到请求， 成功建立 WebSocket 啦！
```
HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk=
Sec-WebSocket-Protocol: chat
```
这里开始就是 HTTP 最后负责的区域了，告诉客户，我已经成功切换协议啦~
```
Upgrade: websocket
Connection: Upgrade
```
依然是固定的，告诉客户端即将升级的是 WebSocket 协议，而不是 mozillasocket，lurnarsocket 或者 shitsocket。
然后， Sec-WebSocket-Accept 这个则是经过服务器确认，并且加密过后的 Sec-WebSocket-Key 。服务器：好啦好啦，知道啦，给你看我的 ID CARD 来证明行了吧。
后面的， Sec-WebSocket-Protocol 则是表示最终使用的协议。
至此，HTTP 已经完成它所有工作了，接下来就是完全按照 WebSocket 协议进行了。

## 客户端的简单示例
WebSocket 的用法相当简单。
下面是一个网页脚本的例子，基本上一眼就能明白。
```js
var ws = new WebSocket("wss://echo.websocket.org");

ws.onopen = function(evt) { 
  console.log("Connection open ..."); 
  ws.send("Hello WebSockets!");
};

ws.onmessage = function(evt) {
  console.log( "Received Message: " + evt.data);
  ws.close();
};

ws.onclose = function(evt) {
  console.log("Connection closed.");
};      
```

## 客户端的 API
WebSocket 客户端的 API 如下。
###  WebSocket 构造函数
WebSocket 对象作为一个构造函数，用于新建 WebSocket 实例。
```js
var ws = new WebSocket('ws://localhost:8080');
```
执行上面语句之后，客户端就会与服务器进行连接。

### webSocket.readyState
`readyState`属性返回实例对象的当前状态，共有四种。
- CONNECTING：值为0，表示正在连接。
- OPEN：值为1，表示连接成功，可以通信了。
- CLOSING：值为2，表示连接正在关闭。
- CLOSED：值为3，表示连接已经关闭，或者打开连接失败。
下面是一个示例。
```js
switch (ws.readyState) {
  case WebSocket.CONNECTING:
    // do something
    break;
  case WebSocket.OPEN:
    // do something
    break;
  case WebSocket.CLOSING:
    // do something
    break;
  case WebSocket.CLOSED:
    // do something
    break;
  default:
    // this never happens
    break;
}
```

### webSocket.onopen
实例对象的onopen属性，用于指定连接成功后的回调函数。
```js
ws.onopen = function () {
  ws.send('Hello Server!');
}
如果要指定多个回调函数，可以使用addEventListener方法。

ws.addEventListener('open', function (event) {
  ws.send('Hello Server!');
});
```

### webSocket.onclose
实例对象的onclose属性，用于指定连接关闭后的回调函数。
```js
ws.onclose = function(event) {
  var code = event.code;
  var reason = event.reason;
  var wasClean = event.wasClean;
  // handle close event
};

ws.addEventListener("close", function(event) {
  var code = event.code;
  var reason = event.reason;
  var wasClean = event.wasClean;
  // handle close event
});
```

### webSocket.onmessage
实例对象的onmessage属性，用于指定收到服务器数据后的回调函数。
```js
ws.onmessage = function(event) {
  var data = event.data;
  // 处理数据
};

ws.addEventListener("message", function(event) {
  var data = event.data;
  // 处理数据
});
```
注意，服务器数据可能是文本，也可能是二进制数据（blob对象或Arraybuffer对象）。
```js
ws.onmessage = function(event){
  if(typeof event.data === String) {
    console.log("Received data string");
  }

  if(event.data instanceof ArrayBuffer){
    var buffer = event.data;
    console.log("Received arraybuffer");
  }
}
```
除了动态判断收到的数据类型，也可以使用binaryType属性，显式指定收到的二进制数据类型。
```js
// 收到的是 blob 数据
ws.binaryType = "blob";
ws.onmessage = function(e) {
  console.log(e.data.size);
};

// 收到的是 ArrayBuffer 数据
ws.binaryType = "arraybuffer";
ws.onmessage = function(e) {
  console.log(e.data.byteLength);
};
```
### webSocket.send()
实例对象的send()方法用于向服务器发送数据。
发送文本的例子。
```js
ws.send('your message');
```
发送 Blob 对象的例子。
```js
var file = document
  .querySelector('input[type="file"]')
  .files[0];
ws.send(file);
```
发送 ArrayBuffer 对象的例子。
```js
// Sending canvas ImageData as ArrayBuffer
var img = canvas_context.getImageData(0, 0, 400, 320);
var binary = new Uint8Array(img.data.length);
for (var i = 0; i < img.data.length; i++) {
  binary[i] = img.data[i];
}
ws.send(binary.buffer);
```
### webSocket.bufferedAmount
实例对象的bufferedAmount属性，表示还有多少字节的二进制数据没有发送出去。它可以用来判断发送是否结束。
```js
var data = new ArrayBuffer(10000000);
socket.send(data);

if (socket.bufferedAmount === 0) {
  // 发送完毕
} else {
  // 发送还没结束
}
```
### webSocket.onerror
实例对象的onerror属性，用于指定报错时的回调函数。
```js
socket.onerror = function(event) {
  // handle error event
};

socket.addEventListener("error", function(event) {
  // handle error event
});
```

## WebSocket多人在线聊天室
### 新建工程
我们新建一个SpringBoot2的项目工程，在默认依赖中，添加websocket依赖：
```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-websocket</artifactId>
</dependency>
```

### WebSocket 配置
```java
@Configuration
@EnableWebSocketMessageBroker //@EnableWebSocketMessageBroker用于启用我们的WebSocket服务器。
public class WebSocketConfig implements WebSocketMessageBrokerConfigurer {

	@Value("{jwt.tokenHead}")
	private String tokenHead;
	@Autowired
	private JwtTokenUtil jwtTokenUtil;
	@Autowired
	private UserDetailsService userDetailsService;

	/**
	 * 添加这个Endpoint, 这样在网页可以通过websocket连接上服务
	 * 也就是我们配置websocket的服务地址，并且可以指定是否使用socketJS
	 *
	 * 方法名中的STOMP是来自Spring框架STOMP实现。 STOMP代表简单文本导向的消息传递协议。它是一种消息传递协议，用于定义数据交换的格式和规则。为啥我们需要这个东西？因为WebSocket只是一种通信协议。它没有定义诸如以下内容：如何仅向订阅特定主题的用户发送消息，或者如何向特定用户发送消息。我们需要STOMP来实现这些功能。
	 * @param registry
	 */
	@Override
	public void registerStompEndpoints(StompEndpointRegistry registry) {
		/**
		 * 1. addEndpoint("/ws/ep"): 将ws/ep路径注册为stomp的端点，用户连接了这个端点就可以进行websocket通讯，支持socketJS
		 * 2. setAllowedOrigins("*")：设置有哪些地址能访问，‘*’表示所有地址都能
		 * 3. withSockJS()：支持socketJS访问
		 */
		registry.addEndpoint("/ws/ep").setAllowedOrigins("*").withSockJS();
	}

	/**
	 * 使用了jwt时，需要进行这个配置
	 * 输入通道参数配置
	 * @param registration
	 */
	@Override
	public void configureClientInboundChannel(ChannelRegistration registration) {
		registration.interceptors(new ChannelInterceptor() {
			@Override
			public Message<?> preSend(Message<?> message, MessageChannel channel) {
				StompHeaderAccessor accessor = MessageHeaderAccessor.getAccessor(message, StompHeaderAccessor.class);

				//判断是否为连接，如果是，需要获取token，并且设置用户对象
				if(StompCommand.CONNECT.equals(accessor.getCommand())){
					String token = accessor.getFirstNativeHeader("Auth-Token");
					if(token != null && !token.equals("")){
						String autoToken = token.substring(tokenHead.length());
						String username = jwtTokenUtil.getUserNameFromToken(autoToken);
						//如果token中存在用户名
						if(username != null && !username.equals("")){
							//登陆
							UserDetails userDetails = userDetailsService.loadUserByUsername(username);
							//验证token是否有效，如果有效，则重新设置用户对象, 并且将该用户对象添加到accessor中
							if(jwtTokenUtil.validateToken(autoToken, userDetails)){
								UsernamePasswordAuthenticationToken usernamePasswordAuthenticationToken = new UsernamePasswordAuthenticationToken(userDetails, null, userDetails.getAuthorities());
								SecurityContextHolder.getContext().setAuthentication(usernamePasswordAuthenticationToken);
								accessor.setUser(usernamePasswordAuthenticationToken);
							}
						}
					}
				}
				return message;
			}
		});
	}

	/**
	 * 配置消息代理, 用于将消息从一个客户端路由到另一个客户端。
	 * @param registry
	 */
	@Override
	public void configureMessageBroker(MessageBrokerRegistry registry) {
		//定义了以“/queue”开头的消息目的地消息应该路由到消息代理。消息代理向订阅特定主题的所有连接客户端广播消息
		registry.enableSimpleBroker("/queue");
	}
}

```
### 创建 ChatMessage 实体
```java
@Data
@EqualsAndHashCode(callSuper = false)
@Accessors(chain = true)
public class ChatMsg {
	//信息来自哪
	private String from;
	//信息发往哪
	private String to;
	//信息的内容
	private String content;
	//时间
	private LocalDateTime date;
	//昵称
	private String formNickName;
}
```
### 创建Controller来接收和发送消息
```java
@Controller
public class WsController {
	@Autowired
	private SimpMessagingTemplate simpMessagingTemplate;

	@MessageMapping("/ws/chat")
	public void handleMsg(Authentication authentication, ChatMsg chatMsg){
		Admin admin = (Admin) authentication.getPrincipal();
		chatMsg.setFrom(admin.getUsername());
		chatMsg.setFormNickName(admin.getName());
		chatMsg.setDate(LocalDateTime.now());

		//第二个参数表示信息的目的地，其中前缀"queue"是我们在WebSocketConfig中配置消息代理中设置的
		simpMessagingTemplate.convertAndSendToUser(chatMsg.getTo(), "/queue/chat", chatMsg);
	}
}
```

# session域
## java后端的session域
用户请求服务器有下列2种情况
- **请求头中没有cookie或者是cookie中没有JSESSIONID时**：服务器会为用户生成一个独一无二的session对象，并且每个session对象都会有一个唯一的sessionId(用于区分其他的session对象)，服务器也会因此产生一个cookie，并且该cookie的中属性名为JSESSIONED的属性值为服务端sessionID的值；然后服务器会在响应客户端的同时，将该cookie发送给客户端；至此客户端就有了一个cookie(JESEESIONID)；因此从而达到客户端的cookie就可以和服务端的session对象一一对应起来( JSESSIONID <--> sessionID )；
- **请求头含有cookie且有JSESSIONID属性时**：服务器会先用客户端的cookies中的JSESSIONID去和服务端中的sessionID匹配，如果匹配成功，则说明用户在服务端就能使用该sessionID对应的sessionID域
 
![](https://raw.githubusercontent.com/NaisWang/images/master/20220409125243.png)

> 注：浏览器是不会自动设置cookie的。所以当Response Header中含有Set-Cookie时，浏览器不会自动根据Set-Cookie来设置Cookie，而是需要写相对应的代码来设置Cookie

# HTTP
## HTTP幂等
一个HTTP方法是幂等的，指的是同样的请求被执行一次与连续执行多次的效果是一样的，服务器的状态也是一样的。换句话说就是，幂等方法不应该具有副作用（统计用途除外）。在正确实现的条件下， GET ， HEAD ， PUT 和 DELETE  等方法都是幂等的，而  POST  方法不是。所有的 safe 方法也都是幂等的。

幂等性只与后端服务器的实际状态有关，而每一次请求接收到的状态码不一定相同。例如，第一次调用 DELETE 方法有可能返回 200 ，但是后续的请求可能会返回 404 。 DELETE 的言外之意是，开发者不应该使用 DELETE 法实现具有删除最后条目功能的 RESTful API。

需要注意的是，服务器不一定会确保请求方法的幂等性，有些应用可能会错误地打破幂等性约束。

GET /pageX HTTP/1.1 幂等的。连续调用多次，客户端接收到的结果都是一样的：
```
GET /pageX HTTP/1.1
GET /pageX HTTP/1.1
GET /pageX HTTP/1.1
GET /pageX HTTP/1.1
```

POST /add_row HTTP/1.1 不是幂等的。如果调用多次，就会增加多行记录：
```
POST /add_row HTTP/1.1
POST /add_row HTTP/1.1   -> Adds a 2nd row
POST /add_row HTTP/1.1   -> Adds a 3rd row
```

DELETE /idX/delete HTTP/1.1 是幂等的，即便是不同请求之间接收到的状态码不一样：
```
DELETE /idX/delete HTTP/1.1   -> Returns 200 if idX exists
DELETE /idX/delete HTTP/1.1   -> Returns 404 as it just got deleted
DELETE /idX/delete HTTP/1.1   -> Returns 404
```

## HTTP报文
用于HTTP协议交互的信息被称为HTTP报文, 是HTTP通信基本单位，由8位组字节流组成，通过HTTP通信传输。请求端的叫请求报文，服务端的叫响应报文。是由多行(CR+LF作为换行符)数据构成的字符串文本
```
HTTP报文= 报文首部 + 报文主体(非必要)
```
- 请求行： 包含请求的方法，请求的URI, HTTP 版本
- 响应行： 响应结果的状态码，原因短语，HTTP 版本
- 首部字段： 包含表示请求和响应的各种条件和属性的各类首部（通用首部，响应首部，请求首部和实体首部）, RFC2616中定义了47种首部字段
- 其他：在HTTP协议通信交互中使用到的首部字段不限于RFC2616中定义的47种，还有一些非正式的首部字段，比如Cookie、Set-Cookie和Content-Disposition等，统一归纳在RFC4229 HTTP Header Field Registrations中。
- 报文主体：即请求体与响应体

![](https://raw.githubusercontent.com/NaisWang/images/master/20220409125253.png)

## HTTP实体
`实体(entity)`: 作为请求和响应的有效载荷数据(补充项)被传输，其内容由实体首部+实体主体组成。

HTTP实体的组成：实体首部和实体主体 
报文实体的组成：
- 实体头部：描述了HTTP报文的内容 
- 实体主体：实体主体即http报文原始数据 

**报文主体和实体主体的区别：**
- HTTP报文的主体：用于传输请求和响应的实体主体。
- 报文主体通常等于实体主体，如果传输过程中进行了编码操作，实体内容发生变化，才回导致和报文主体产生差异

## HTTP请求报文结构
HTTP请求报文 一个HTTP请求报文由请求行（request line）、请求头部（header）、空行和请求数据/请求体(request-body)4个部分组成,下图给出了请求报文的一般格式。

![](https://raw.githubusercontent.com/NaisWang/images/master/20220409125302.png)

**1. 请求行(request-line)**
请求行由请求方法字段、URL字段和HTTP协议版本字段3个字段组成，它们用空格分隔。例如，GET /index.html HTTP/1.1。

**2. 请求头部(request-header)**
请求头部由关键字/值对组成，每行一对，关键字和值用英文冒号“:”分隔。请求头部通知服务器有关于客户端请求的信息，典型的请求头有：
- User-Agent：产生请求的浏览器类型。
- Accept：客户端可识别的内容类型列表。

**3. 空行(blank-line)**
最后一个请求头之后是一个空行，发送回车符和换行符，通知服务器以下不再有请求头

**4. 请求数据/请求体(request-body)**
请求数据不在GET方法中使用，而是在POST方法中使用。POST方法适用于需要客户填写表单的场合。与请求数据相关的最常使用的请求头是Content-Type和Content-Length。
<font color="red">请求参数格式为`Form Data`与`Request Payload`的数据都是放在请求体中</font>

## HTTP响应报文结构
HTTP响应也由四个部分组成，分别是：状态行(status-line)、响应头部(response-headers)、空行和响应数据/响应体(response-body)。
下图给出了响应报文的一般格式

![](https://raw.githubusercontent.com/NaisWang/images/master/20220409125312.png)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220409125330.png)

正如你所见，响应报文与请求报文的唯一区别在于第一行中用状态信息代替了请求信息。状态行（status line）通过提供一个状态码来说明所请求的资源情况。

状态行由3部分组成，分别为：协议版本，状态码，状态码描述，之间由空格分隔, 例如：HTTP/1.1 200 OK

## HTTP请求方式method
HTTP协议中的请求方法（有时也叫“动作”），用来表明对Request-URL指定的资源的不同操作方式。
HTTP1.0中定义了三种请求方法：GET，POST和HEAD。
HTTP1.1中新增了六种请求方法：OPTIONS，PUT，DELETE，TRACE和CONNECT，PATCH。

- `GET`: 请求指定页面信息，并返回实体主体
- `HEAD`: 类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头
- `POST`: 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。
- `PUT`: 从客户端向服务器传送的数据取代指定的文档的内容。
- `DELETE`: 请求服务器删除指定的数据。
- `CONNECT`: HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。
- `OPTIONS`: 允许客户端查看服务器的性能
- `TRACE`: 回显服务器收到的请求，主要用于测试或诊断。
- `PATCH`: 是对PUT方法的补充，用来对已知资源进行局部更新 。

**post、put与patch之间的区别**
POST和PUT的区别容易被简单地误认为“POST表示创建资源，PUT表示更新资源.但实际上两者都可以用来创建或是更新数据.单从技术上来说,他们并没有什么区别.但是在HTTP规范中POST是非等幂的,多次调用会产生不同的结果,比如:创建一个用户,由于网络原因或是其他原因多创建了几次,那么将会有多个用户被创建.而PUT id/456则会创建一个id为456的用户,多次调用还是会创建的结果是一样的,所以PUT是等幂的.
PATCH一般是用来局部更新资源的,假设我们有一个UserInfo，里面有userId， userName， userGender等10个字段。可你的编辑功能因为需求，在某个特别的页面里只能修改userName，这时候的更新怎么做？
人们通常(为徒省事)把一个包含了修改后userName的完整userInfo对象传给后端，做完整更新。但仔细想想，这种做法感觉有点二，而且真心浪费带宽(纯技术上讲，你不关心带宽那是你土豪)。
于是PATCH诞生，只传一个userName到指定资源去，表示该请求是一个局部更新，后端仅更新接收到的字段。
而PUT虽然也是更新资源，但要求前端提供的一定是一个完整的资源对象，理论上说，如果你用了PUT，但却没有提供完整的UserInfo，那么缺了的那些字段应该被清空.另外PUT会有一个create操作,加入更新的id不存在,会进行创建,而PATCH则没有这个.

**注意：**
- 当某个资源被请求，但该资源不支持其使用的请求方法时，服务器应当返回状态码405（Mothod Not Allowed）；当服务器不认识或者不支持对应的请求方法时，应返回状态码501（Not Implemented）。
- HTTP服务器至少应该实现GET和HEAD/POST方法，其他方法都是可选的，此外除上述方法，特定的HTTP服务器支持扩展自定义的方法。
- 大部分时候，我们需要使用的只有GET和POST，但是在REST风格的框架中，就需要根据对资源所要做的操作而选择使用POST、DELETE、PUT、GET，对应CURD（增删改查四种基本操作Create、Update、Read、Delete）。

## HTTP请求参数格式
HTTP请求的参数格式有三种：`Query String Parameters`、`Form Data`、`Request Payload`
请求参数格式受 请求方法 与 content-type 影响

### Query String Parameters
get请求的请求参数格式**一定**是`Query String Parameters`, 无论content-type设置成什么，都不会改变请求参数格式
当发起一次GET请求时，参数会以url string的形式进行传递。即?后的字符串则为其请求参数，并以&作为分隔符。如下http请求报文：

![](https://raw.githubusercontent.com/NaisWang/images/master/20220409125338.png)

**此时的请求中的请求体为空**

### Form Data
当发起一次POST请求时，若未指定content-type，则默认content-type为application/x-www-form-urlencoded。即参数会以Form Data的形式进行传递，不会显式出现在请求url中。

![](https://raw.githubusercontent.com/NaisWang/images/master/20220409125347.png)

**此时的请求中的请求体中的数据是一个个键值对**

### Request Payload
当发起一次POST请求时，若content-type为application/json，则参数会以Request Payload的形式进行传递（显然的，数据格式为JSON），不会显式出现在请求url中。

![](https://raw.githubusercontent.com/NaisWang/images/master/20220409125357.png)

**此时的请求中的请求体中的数据就是一个json数据**

### 同时发送不同类型的请求参数
同时发送Query String Parameters与Request Payload类型参数
```js
$.ajax({
  url: 'http://www.baidu.coff?name=aaa',
  type: 'post',
  dataType: 'json',
  data: JSON.stringify({data: {status: "start"}}),
  headers: {
    'Content-Type': 'application/json'
  }
});
```
![](https://raw.githubusercontent.com/NaisWang/images/master/20220323100334.png)

同时发送Query String Parameters与Form Data类型参数
```js
$.ajax({
  url: 'http://www.baidu.coff?name=aaa',
  type: 'post',
  data: {status: "start"},
});
```
![](https://raw.githubusercontent.com/NaisWang/images/master/20220323100647.png)


**注意：get请求的请求参数格式一定有且只为Query String Parameters。如下:**
```js
$.ajax({
  url: 'http://www.baidu.coff?name=aaa',
  type: 'get',
  data: {status: "start"},
});
```
![](https://raw.githubusercontent.com/NaisWang/images/master/20220323100913.png)

```js
$.ajax({
  url: 'http://www.baidu.coff?name=aaa',
  type: 'get',
  data: JSON.stringify({data: {status: "start"}}),
  headers: {
    'Content-Type': 'application/json'
  }
});
```
![](https://raw.githubusercontent.com/NaisWang/images/master/20220323101032.png)

## HTTP响应状态码 
状态码由三位数字组成，第一个数字定义了响应的类别，且有五种可能取值
- 1xx：指示信息--服务器收到请求，需要请求者继续执行操作
- 2xx：成功--表示请求已被成功接收、理解、接受。
- 3xx：重定向--要完成请求必须进行更进一步的操作。
- 4xx：客户端错误--请求有语法错误或请求无法实现。
- 5xx：服务器端错误--服务器在处理请求的过程中发生了错误

常见状态码、状态描述的说明如下：
- `200 OK`：客户端请求成功
- `204 No Content`：无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档
- `206 Partial Content`：部分内容。服务器成功处理了部分GET请求
- `301 Moved Permanently`：永久性重定向。 表示请求的资源已被永久分配了新的URI。 可以简单理解为该资源已经被永久改变了位置
- `302 Found`：临时性重定向。表示资源被临时改变位置并分配了新的URI
- `304 Not Modified`：如果客户端发送了一个带条件的GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个304状态码
- `400 Bad Request`：客户端请求有语法错误，不能被服务器所理解
- `401 Unauthorized`：请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用
- `403 Forbidden`：服务器收到请求，但是拒绝提供服务（认证失败）
- `404 Not Found`：请求资源不存在，举个例子：输入了错误的URL
- `405	Method Not Allowed`: 客户端请求中的方法被禁止
- `407 Proxy Authentication Required`: 与401响应类似，只不过客户端必须在代理服务器上进行身份验证。代理服务器必须返回一个 Proxy-Authenticate 用以进行身份询问。客户端可以返回一个 Proxy-Authorization 信息头用以验证。
- `500 Internal Server  Error`：服务器发生错误
- `503 Server Unavailable`：服务器当前不能处理客户端的请求，一段时间后可能恢复正常

更多状态码见：https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status

## HTTP报文头
HTTP1.1规定的首部字段，其细分可分为`通用报头字段`、`请求报头字段`、`响应报头字段`、`实体报头字段`与`其他报头字段`
http请求报文的报头结构：通用报头|请求报头|实体报头|其他报头字段
http响应报文的报头结构：通用报头|响应报头|实体报头|其他报头字段

### 通用报头字段
通用报头字段(共9种)在请求头和响应头都会使用到
| 首部字段            | 解释                       |
| ------------------- | -------------------------- |
| 1.Cache-Control     | 控制缓存的行为             |
| 2.Connection        | 逐跳首部、连接的管理       |
| 3.Date              | 创建报文的日期和时间       |
| 4.Pragma            | 报文指令                   |
| 5.Trailer           | 报文未端的首部一览         |
| 6.Transfer-Encoding | 指定报文主体的传输编码方式 |
| 7.Upgrade           | 升级为其他协议             |
| 8.Via               | 代理服务器的相关信息       |
| 9.Warning           | 错误通知                   |

下面我们来看挑几个重要的属性来看下~
#### Cache-Control
用来操作缓存的工作机制，下方截图响应头中的的Cache-Control的参数为private和max-age=10。private缓存是私有的，仅像特定用户提供相应的缓存信息。如果是public，那么就意味着可向任意方提供相应的缓存信息。max-age = 10表示缓存有效期为10秒。从下方的Expires(过期时间)和Last-Modified(最后修改时间)就可以看出，这两者之间的差值正好是10秒。

该字段还可以对应其他的参数：
- `no-cache`：如果是客户端的话，说明客户端不会接收缓存过的响应，要请求最新的内容。而服务器端则表示缓存服务器不能对相应的资源进行缓存。
- `no-store`：表示缓存不能在本地存储。
- `max-age`：该参数后方会被赋值上相应的秒数，在请求头中表示如果缓存时间没有超过这个值就返回给我。而在响应头中时，则表示资源在缓存服务器中缓存的最大时间。
- `only-if-cached`：表示客户端仅仅请求缓存服务器上的内容，如果缓存服务器上没有请求的内容，那么返回504 Gateway Timeout。
- `must-revalidata`：表示缓存服务器在返回资源是，必须向资源服务器确认其缓存的有效性。
- `no-transform`：无论请求还是响应，都不能在传输的过程中改变报文体的媒体类型。

![](https://raw.githubusercontent.com/NaisWang/images/master/20220409125410.png)

#### Connection
Connection 他有两个作用
1. 作用1：控制不再转发给代理的首部字段
```
GET / HTTP/1.1
Upgrade: HTTP/1.1    // 就会把次字段删除后再从代理服务器转发出去
Connection: Upgrade   // 不再转发的首部字段名
```

![](https://raw.githubusercontent.com/NaisWang/images/master/20220409125420.png)

2. 作用2：管理持久链接（这个比较常见）
下方这个响应报文头中的Connection就是用来管理持久连接的，其参数为keep-alive，就是保持持久连接的意思。可以使用close参数将其关闭。

![](https://raw.githubusercontent.com/NaisWang/images/master/20220409125429.png)


#### Transfer-Encoding
该字段表示报文在传输过程中采用的编码方式，在HTTP/1.1的报文传输过程中仅对分块编码有效。下方这个截图就是Transfer-Encoding在Response Header中的使用，后边根的chunked(分块)的参数，说明报文是分块进行传输的。

![](https://raw.githubusercontent.com/NaisWang/images/master/20220409125438.png)

#### Via
该字段是为了追踪请求和响应报文测传输路径，报文经过代理或者网关是会在Via字段添加该服务器的信息，然后再进行转发。

![](https://raw.githubusercontent.com/NaisWang/images/master/20220409125446.png)

#### Pragme
Pragme是HTTP/1.1之前版本遗留的字段，仅仅是为了与HTTP/1.0向后兼容而定义

例如`Pragme：no-cache`:表示所有的中间服务器不返回缓存的资源
可是如果所有的中间服务器都以HTTP/1.1为基准的话，可以直接采用 Cache-Control：no-cache
所以一般会发送两个字段`Cache-Control：no-cache`, `Pragme：no-cache`

### 请求报头字段
顾名思义，请求报头字段当然是在请求头中才使用的字段(共19种)。该字段用于补充请求的附加信息，客户端信息等。
| 首部字段            | 解释                                          |
| ------------------- | --------------------------------------------- |
| Accept              | 客户端希望接收的媒体类型                      |
| Accept-Charset      | 优先的字符集                                  |
| Accept-Encoding     | 优先的内容编码                                |
| Accept-Language     | 优先的语言（自然语言）                        |
| Authorization       | web认证信息                                   |
| Expect              | 期待服务器的特定行为                          |
| From                | 用户的电子邮箱地址                            |
| Host                | 请求资源所在服务器                            |
| If-Match            | 比较实体标记（ETag）                          |
| If-Modified-since   | 比较资源的更新时间                            |
| If-None-Match       | 比较实体标记（与If-Match相反）                |
| If-Range            | 资源未更新时发送实体Byte的范围请求            |
| If-Unmodified-Since | 比较资源的更新时间（与If-Modified-since相反） |
| Max-Forwards        | 最大传输逐跳数                                |
| Proxy-Authorization | 代理服务器要求客户端的认证信息                |
| Range               | 实体的字节范围要求                            |
| Referer             | 对请求中URI的原始获取方                       |
| TE                  | 传输编码的优先级                              |
| User-Agent          | HTTP客户端程序的信息                          |

#### Accept
该字段首部列举了浏览器希望接收的媒体资源的 MIME 类型。其中不同的 MIME 类型之间用逗号分隔，同时每一种 MIME 类型会配有一个品质因数（quality factor），该参数明确了不同 MIME 类型之间的相对优先级

**语法**
```
Accept: <MIME_type>/<MIME_subtype>
Accept: <MIME_type>/*
Accept: */*

// Multiple types, weighted with the quality value syntax:
Accept: text/html, application/xhtml+xml, application/xml;q=0.9, */*;q=0.8
```

**指令**
- `<MIME_type>/<MIME_subtype>`: 单一精确的 MIME 类型, 例如text/html.
- `<MIME_type>/*`: 一类 MIME 类型, 但是没有指明子类。 `image/*` 可以用来指代 image/png, image/svg, image/gif 以及任何其他的图片类型。
- `*/*`: 任意类型的 MIME 类型
- `;q= (q因子权重)`: 值代表优先顺序，用相对质量价值表示，又称作权重。

**示例**
```
Accept: text/html

Accept: image/*

Accept: text/html, application/xhtml+xml, application/xml;q=0.9, */*;q=0.8
```

#### Accept-Encoding
该字段用来告知服务器，客户端这边可支持的内容编码以及相应内容编码的优先级, 下方就是Accept-Encoding的用法。gzip表示由文件压缩程序gzip(GNU zip)生成的编码格式。compress表示UNIX文件压缩程序compress生成的编码格式。deflate表示组合使用zlib格式以及有deflate压缩算法生成的编码格式。identity表示不执行压缩或者使用一致的默认编码格式。

![](https://raw.githubusercontent.com/NaisWang/images/master/20220409125454.png)

#### Accept-Language
该字段用来告知服务器，客户端可处理的自然语言集，以及对应语言集的优先级。以下方的截图为例，Accept-Language后方跟了三个属性，分别是“zh-CN”, "zh;q=0.8"，“en;q=0.6”。也就是说客户端可处理三种自然预言集，zh-CN，其优先级是1（最高）。第二种是zh ，其优先级是0.8，次之。第三个是en，优先级为0.6，优先级在三者之间最低。

![](https://raw.githubusercontent.com/NaisWang/images/master/20220409125517.png)

#### Authorization
用来告知服务器，客户端的认证信息，下方就是连接公司内部SVN系统时需要认证时的请求头部信息。
如果你没有填写认证信息的话，那么就会返回401 Unauthorized。如下所示：

![](https://raw.githubusercontent.com/NaisWang/images/master/20220409125527.png)

#### If-Match 与If-None-Match
上面这两个请求头部字段都是带有逻辑判断的，从上面的英文我们不难看出两者恰好相反。两者后方都跟着串字符串，如If-Match "xcsldjh49773hce", 后边这个字符的匹配对象是ETag(稍后会介绍)。If-Match的请求是如果后方的字符串与ETag相等则服务器端进行请求，否则不进行处理。If-None-Match是If-Match的非操作，同样是匹配ETag, 如果Etag没有匹配成功就处理请求，否则不处理。

#### If-Modified-Since与If-Unmodified-Since
If-Modified-Since也是带有逻辑判断的请求头部字段，该字段后方跟的是一个日期，意思是在该日期后发生了资源更新，那么服务器就会处理该请求。If-Unmodified-Since就是 If-Modified-Since的非操作。

![](https://raw.githubusercontent.com/NaisWang/images/master/20220409125535.png)


#### If-Range
if-Range字段后方也是跟的Etag, 该字段要结合着Range字段进行使用。其所代表的意思就是如果Etag匹配成功，请求的内容就按照Range字段所规定的范围进行返回，否则返回全部的内容。用法如下所示：
```
If-Range: "etag_code" 
Range: bytes=1000-5000
```

#### Referer
其实Referer是一个错误的拼写，但是一直在使用。正确的英文单词应该是Referrer(此处可翻译为:来历、来路)。Referer字段后方跟的是一个URI, 该URI就是发起请求的URI，具体如下所示：

![](https://raw.githubusercontent.com/NaisWang/images/master/20220409125544.png)

#### User-Agent
该字段会将请求方的浏览器和用户代理名称等信息传达给服务器。下方就是从我当前笔记本的Chrome浏览器请求网络时的User-Agent信息

![](https://raw.githubusercontent.com/NaisWang/images/master/20220409125556.png)

### 响应报头字段
聊完请求报文头部字段后，我们接下来来聊一下响应报文头部字段(共9种)。响应头是由Server向Client返回响应报文中使用的头部信息。用户补充响应的附加信息、服务信息等。
| 首部字段名         | 解释                         |
| ------------------ | ---------------------------- |
| Accept-Ranges      | 是否接受字节范围请求         |
| Age                | 推算资源创建经过时间         |
| ETag               | 资源的匹配信息               |
| Location           | 令客户端重定向至指定URI      |
| Proxy-Authenticate | 代理服务器对客户端的认证信息 |
| Retry-After        | 对再次发起请求的时机要求     |
| Server             | HTTP服务器的安装信息         |
| Vary               | 代理服务器缓存的管理信息     |
| WWW-Authenticate   | 服务器对客户端的认证信息     |

#### Accept-Ranges
该字段用来告知客户端服务器那边是否支持范围请求（请求部分内容，请求头中使用Range字段）。Accept-Ranges的值为bytes时，就说明服务器支持范围请求，为none时，说明服务器不支持客户端的范围请求。下方是博客园的页面的加载，从下方可以看出是支持范围请求的，如下所示：

![](https://raw.githubusercontent.com/NaisWang/images/master/20220409125634.png)

#### Age
该字段告知客户端，源服务器在多久前创建了该响应。

![](https://raw.githubusercontent.com/NaisWang/images/master/20220409125608.png)

#### Etag
Etag是服务器当前请求的服务器资源（图片，HTML页面等）所对应的一个独有的字符串。不同资源间的Etag是不同的，当资源更新时Etag也会进行更新, 并没有统一的算法规则，而是由服务器来分配
所以结合着请求头中的If-Match等逻辑请求头，可以判断当前Client端已经加载的资源在服务器端是否已经更新了。当初次请求一个资源，如图片时，我们可以将其Etag进行保存，在此请求时，可放在If-None-Match后方，进行资源更新。如果服务器资源并未修改，就不对该请求做出响应。下方就是网页中某张图片对应着的Etag，如下所示。

![](https://raw.githubusercontent.com/NaisWang/images/master/20220409125619.png)

#### Location
Location字段一般与重定向结合着使用。下方是我访问“www.baidu.com/hello”这个连接的响应报文。因为服务器上并没有/hello这个资源路径，所以给我重定向了error.html页面，这个重定向的URL就存储在Location字段中，如下所示：

![](https://raw.githubusercontent.com/NaisWang/images/master/20220409125643.png)

#### Server
该响应字段表明了服务器端使用的服务器型号，下方是博客园某张图片的响应头，使用的Web服务器是Tengine, Tengin是淘宝发起的Web服务器项目，是基于Nginx的，关于Tengin的相关内容，请自行Google吧。

![](https://raw.githubusercontent.com/NaisWang/images/master/20220409125652.png)

#### Vary 
Vary 首部字段vary可对缓存进行控制，源服务器会向代理服务器传达关于本地缓存使用方法的命令
当代理服务器接收到服务器返回包含Vary指定项的响应后，仅对请求中含有相同Vary指定首部字段的请求返回缓存
即使对相同资源发起请求，但是由于Vary指定的首部字段不相同，因此必须从源服务器重新获取资源
下方就是Vary的使用，Vary后方的参数是Accept-Encoding。其意思是返回的缓存要以Accept-Encoding为准。当请求的Accept-Encoding的参数与缓存内容的Accept-Encoding参数一致时就返回缓存内容，否则就请求源服务器。

![](https://raw.githubusercontent.com/NaisWang/images/master/20220409125700.png)

再例如下面这个，如果使用的Accept-Language：en-us字段的值相同，那么直接从缓存返回响应，否则从源服务器请求资源后再返回响应

![](https://raw.githubusercontent.com/NaisWang/images/master/20220409125710.png)


#### WWW-Authenticate
该字段用于HTTP的访问认证，在状态码401 Unauthorized中肯定带有此字段，该字段用来指定客户端的认证方案（Basic或者Digest）。参数realm的字符串是为了辨别请求URL指定资源所受到的保护策略。如下所示：

![](https://raw.githubusercontent.com/NaisWang/images/master/20220409125722.png)

### 实体报头字段
实体报头字段(共10种)是报文实体所使用的头部，用来补充与报文实体相关的信息。
| 首部字段名       | 解释                           |
| ---------------- | ------------------------------ |
| Allow            | 资源可支持的HTTP方法           |
| Content-Encoding | 实体主体适用的编码方式         |
| Content-Language | 实体主体的自然语言             |
| Content-Length   | 实体主体的大小（单位：字节）   |
| Content-Location | 代替对应资源的URI              |
| Content-MD5      | 实体主体的报文摘要             |
| Content-Range    | 实体主体的位置范围             |
| Content-Type     | 实体主体的媒体类型             |
| Expires          | 实体主体过期的日期时间         |
| Last-Modified    | 资源的最后修改最期时间）不要加 |

#### Allow
该字段用于服务器通知客户端服务器这边所支持的所有请求方法（GET、POST等）。如果服务器找不到客户端请求中所提到的方法的话，就会返回405 Method Not Allowed，于此同时还会把所有能支持的HTTP方法写入到首部字段Allow后返回。
```
Allow : GET, POST, HEAD, PUT, DELETE 
```

#### content-type
Content-Type 实体头部用于指示资源的MIME类型[media type](#mediaType)。

- **在响应中**，Content-Type标头告诉客户端实际返回的内容的内容类型
- **在请求中 (如POST 或 PUT)**，客户端告诉服务器实际发送的数据类型。

**句法**
```
Content-Type: text/html; charset=utf-8
Content-Type: multipart/form-data; boundary=something
```

**指令**
- `media-type`:资源或数据的[MIME type](#mediaType)。
- `charset`: 字符编码标准。
- `boundary`：对于多部分实体，boundary 是必需的，其包括来自一组字符的1到70个字符，已知通过电子邮件网关是非常健壮的，而不是以空白结尾。它用于封装消息的多个部分的边界。


**例子**
Content-Type 在HTML表单中
在通过HTML form提交生成的POST请求中，请求头的Content-Type由`<form>`元素上的enctype属性指定
```html
<form action="/" method="post" enctype="multipart/form-data">
  <input type="text" name="description" value="some text">
  <input type="file" name="myFile">
  <button type="submit">Submit</button>
</form>
```
请求头看起来像这样（在这里省略了一些 headers）：
```
POST /foo HTTP/1.1
Content-Length: 68137
Content-Type: multipart/form-data; boundary=---------------------------974767299852498929531610575

---------------------------974767299852498929531610575
Content-Disposition: form-data; name="description"

some text
---------------------------974767299852498929531610575
Content-Disposition: form-data; name="myFile"; filename="foo.txt"
Content-Type: text/plain

(content of the uploaded file foo.txt)
---------------------------974767299852498929531610575
```

#### Content-Encoding
该字段用来说明报文实体的编码方式，下方这段报文头中的Content-Encoding的参数为gzip，说明是使用gzip对报文实体进行压缩的。

![](https://raw.githubusercontent.com/NaisWang/images/master/20220409125732.png)

####  Content-Language
该字段表示报文实体使用的自然语言，使用方式如下所示：
```
Content-Language: zh-CN
```

#### Content-Length
顾名思义，该字段用来指定报文实体的字节长度，如下所示：

![](https://raw.githubusercontent.com/NaisWang/images/master/20220409125742.png)

#### Content-MD5
该字段中存储的是报文实体进行MD5加密然后再使用Base64进行编码的字符串。客户端收到响应报文后，可以对报文实体进行MD5加密，然后再对其进行Base64编码，然后与Content-MD5中的字符串进行比较来确定报文是否进行修改，可以说这是一个简单的验签功能。但是此方法并不能确定报文是否被修改了，因为Content-MD5这个值也有可能被篡改。

### 其他报头字段
#### Set-Cookie
因为HTTP协议本身是无状态的，在Web站点中使用Cookie来管理服务器与客户端之间的状态。

响应报文中会使用到该字段。当服务器准备开始管理客户端的状态时，会事先告知其各种信息。
| 属性           | 解释                                                                                                                   |
| -------------- | ---------------------------------------------------------------------------------------------------------------------- |
| NAME=VALUE     | 赋予Cookie的名称和其值（必需项）                                                                                       |
| expires = DATE | cookie的有效期（若不指定则默认为浏览器关闭为止）                                                                       |
| path=PATH      | 将服务器上的文件目录作为Cookie的适用对象（若不指定则默认为文档所在的文件目录）                                         |
| domin=域名     | 作为cookie适用对象的域名（若不指定则默认为创建Cookie的服务器域名）                                                     |
| Secure         | 仅在HTTPS安全通信时才会发送Cookie                                                                                      |
| HttpOnly       | 加以限制，使cookie不能被Js脚本访问，主要目的是为了防止跨站脚本攻击（Cross Httponly site Scripting，XSS）对cookie的窃取 |

![](https://raw.githubusercontent.com/NaisWang/images/master/20220409125753.png)

**谷歌浏览器控制台查看cookie**

![](https://raw.githubusercontent.com/NaisWang/images/master/20220409125802.png)

cookie中的thor和JSESSIONID这两个key的后HttpOnly属性被打上了√，就表明，此key无法被js脚本访问，防止跨站脚本攻击（Cross Site Scripting，XSS）对cookie的窃取 我们来看下再console控制台输入document.cookie 得出的cookie无法找到这两个key

![](https://raw.githubusercontent.com/NaisWang/images/master/20220409125811.png)

因为这个属性JSESSIONID比较重要，存储的是sessionId，这个要是被别人拿到的话，别人就可以冒充我在网站上做某些事情了，像我自己一样请求某些数据了

#### Cookie
请求报文头中会使用该字段，用于将本地存储的Cookie信息发送给服务端。

#### Content-disposition
在常规的 HTTP 应答中，Content-Disposition 响应头指示回复的内容该以何种形式展示，是以内联的形式（即网页或者页面的一部分），还是以附件的形式下载并保存到本地。
在 multipart/form-data 类型的应答消息体中，Content-Disposition 消息头可以被用在 multipart 消息体的子部分中，用来给出其对应字段的相关信息。各个子部分由在Content-Type 中定义的分隔符分隔。用在消息体自身则无实际意义。

**语法**
**1. 作为消息主体中的消息头**
在 HTTP 场景中，第一个参数或者是 inline（默认值，表示回复中的消息体会以页面的一部分或者整个页面的形式展示），或者是 attachment（意味着消息体应该被下载到本地；大多数浏览器会呈现一个“保存为”的对话框，将 filename 的值预填为下载后的文件名，假如它存在的话）。
```
Content-Disposition: inline
Content-Disposition: attachment
Content-Disposition: attachment; filename="filename.jpg"
```

**2. 作为multipart body中的消息头**
在 HTTP 场景中。第一个参数总是固定不变的 form-data；附加的参数不区分大小写，并且拥有参数值，参数名与参数值用等号('=')连接，参数值用双引号括起来。参数之间用分号(';')分隔。
```
Content-Disposition: form-data
Content-Disposition: form-data; name="fieldName"
Content-Disposition: form-data; name="fieldName"; filename="filename.jpg"
```

**指令**
- `name`: 后面是一个表单字段名的字符串，每一个字段名会对应一个子部分。在同一个字段名对应多个文件的情况下（例如，带有 multiple 属性的`<input type=file>`元素），则多个子部分共用同一个字段名。如果 name 参数的值为 `_charset_` ，意味着这个子部分表示的不是一个 HTML 字段，而是在未明确指定字符集信息的情况下各部分使用的默认字符集。
- `filename`: 后面是要传送的文件的初始名称的字符串。这个参数总是可选的，而且不能盲目使用：路径信息必须舍掉，同时要进行一定的转换以符合服务器文件系统规则。这个参数主要用来提供展示性信息。当与 Content-Disposition: attachment 一同使用的时候，它被用作"保存为"对话框中呈现给用户的默认文件名。
- `filename*`: "filename" 和 "filename*" 两个参数的唯一区别在于，"filename*" 采用了  RFC 5987 中规定的编码方式。当 "filename" 和 "filename*" 同时出现的时候，应该优先采用 "filename*"，假如二者都支持的话。

**示例**
以下是一则可以触发"保存为"对话框的服务器应答：
```
200 OK
Content-Type: text/html; charset=utf-8
Content-Disposition: attachment; filename="cool.html"
Content-Length: 22

<HTML>Save me!</HTML>
```

这个简单的 HTML 文件会被下载到本地而不是在浏览器中展示。大多数浏览器默认会建议将 cool.html 作为文件名。

以下是一个HTML表单的示例，展示了在 multipart/form-data 格式的报文中使用Content-Disposition 消息头的情况：
```
POST /test.html HTTP/1.1
Host: example.org
Content-Type: multipart/form-data;boundary="boundary"

--boundary
Content-Disposition: form-data; name="field1"

value1
--boundary
Content-Disposition: form-data; name="field2"; filename="example.txt"

value2
--boundary--
```

## MIME类型
媒体类型（通常称为 Multipurpose Internet Mail Extensions 或 MIME 类型 ）是一种标准，用来表示文档、文件或字节流的性质和格式。它在IETF RFC 6838中进行了定义和标准化。

>重要：浏览器通常使用MIME类型（而不是文件扩展名）来确定如何处理URL，因此Web服务器在响应头中添加正确的MIME类型非常重要。如果配置不正确，浏览器可能会曲解文件内容，网站将无法正常工作，并且下载的文件也会被错误处理。

### 语法
**通用结构**
```
type/subtype
```
MIME的组成结构非常简单；由类型与子类型两个字符串中间用'/'分隔而组成。不允许空格存在。type 表示可以被分多个子类的独立类别。subtype 表示细分后的每个类型。

MIME类型对大小写不敏感，但是传统写法都是小写。

### 独立类型
```
text/plain
text/html
image/jpeg
image/png
audio/mpeg
audio/ogg
audio/*
video/mp4
application/*
application/json
application/javascript
application/ecmascript
application/octet-stream
…
```

独立类型表明了对文件的分类，可以是如下之一：
| 类型        | 描述                                                                                                                                                                 | 典型示例 |
| ----------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------- |
| text        | 表明文件是普通文本，理论上是人类可读	text/plain, text/html, text/css, text/javascript                                                                                |
| image       | 表明是某种图像。不包括视频，但是动态图（比如动态gif）也使用image类型	image/gif, image/png, image/jpeg, image/bmp, image/webp, image/x-icon, image/vnd.microsoft.icon |
| audio       | 表明是某种音频文件	audio/midi, audio/mpeg, audio/webm, audio/ogg, audio/wav                                                                                          |
| video       | 表明是某种视频文件	video/webm, video/ogg                                                                                                                             |
| application | 表明是某种二进制数据	application/octet-stream, application/pkcs12, application/vnd.mspowerpoint, application/xhtml+xml, application/xml,  application/pdf            |

对于text文件类型若没有特定的subtype，就使用 text/plain。类似的，二进制文件没有特定或已知的 subtype，即使用 application/octet-stream。

### Multipart 类型
```
multipart/form-data
multipart/byteranges
```
Multipart 类型表示细分领域的文件类型的种类，经常对应不同的 MIME 类型。这是复合文件的一种表现方式。multipart/form-data 可用于联系 HTML Forms 和 POST 方法，此外 multipart/byteranges使用状态码206 Partial Content来发送整个文件的子集，而HTTP对不能处理的复合文件使用特殊的方式：将信息直接传送给浏览器（这时可能会建立一个“另存为”窗口，但是却不知道如何去显示内联文件。）


### 两种主要的MIME类型
#### application/octet-stream
这是**应用程序文件的默认值**。意思是未知的应用程序文件 ，响应体的形式为文件流，浏览器一般不会自动执行或询问执行。 前端获取到响应体中的文件流后可用对其进行一些操作，比如下载等

有关具体过程，可以到js笔记中看`前端下载文件方式`


#### text/plain
**文本文件默认值**。即使它意味着未知的文本文件，但浏览器认为是可以直接展示的。

text/plain并不是意味着某种文本数据。如果浏览器想要一个文本文件的明确类型，浏览器并不会考虑他们是否匹配。比如说，如果通过一个表明是下载CSS文件的`<link>`链接下载了一个 text/plain 文件。如果提供的信息是text/plain，浏览器并不会认出这是有效的CSS文件。CSS类型需要使用text/css。

## Accept与Content-Type的区别
1. 类型不同
Accept属于请求报头中的字段， Content-Type属于实体报头中的字段。
2. 作用不同
Accept代表发送端（客户端）希望接受的数据类型。 比如：Accept：text/xml; 代表客户端希望接受的数据类型是xml类型。
Content-Type代表发送端（客户端|服务器）发送的实体数据的数据类型。 比如：Content-Type：text/html; 代表发送端发送的数据格式是html。

二者合起来，例如请求报头中为`Accept:text/xml； Content-Type:text/html`，即代表希望接受的数据类型是xml格式，本次请求发送的数据的数据格式是html。

**如果服务器响应的content-type值不在浏览器请求的Accept中，则响应失败**

# URL中的hash(#号)
**#的含义**
#代表网页中的一个位置，其右边的字符，就是该位置的标识符，比如：
```
http://example.com/index.html#print
```
就是代表index.html中的print位置，浏览器会自动把print位置滚动到页面可视区域内

**http请求不包含#**
#号用来指导浏览器动作的，对服务器端完全无用，所以，http请求中不包含#
比如，访问下面的网址：
```
http://jquery.com#hello
```
浏览器实际发出的请求是这样的：
```
Request URL: http://jquery.com/
Request Method: GET
```
可以看到，只是请求了http://jquery.com，没有请求"#hello"的部分

**#后面的字符**
在第一个#后面出现的任何字符，都会被浏览器解读为位置标识符，这意味着，这些字符都不会被发送到服务器端。比如，下面的url的意愿是指定一个颜色值：
```
http://jquery.com/?color=#fff
```
但浏览器实际发送的请求是：
```
Request URL: http://jquery.com/?color=
Request Method: GET
```
可以看到，"#fff"被忽略掉了，只有将#转码为%23，浏览器才会将其作为实义字符处理，也就是说，上面的网站应该被写成：`http://jquery.com/?color=%23fff`

**改变#后的内容不触发网页重载**
单单改变#后的内容，浏览器只会滚动到相应位置，不会重新加载网页
浏览器不会重新向服务器请求页面

**改变#会改变浏览器的访问历史**
每一次改变#后的部分，都会在浏览器的访问历史中增加一个记录，使用回退按钮，就可以回到上一个位置
这对于ajax应用程序特别有用，可以用不同的#值，表示不同的访问状态，然后让用户给出可以访问某个状态的链接
值得注意的是，上述规则对IE 6和IE 7不成立，它们不会因为#的改变而增加历史记录
 
**window.location.hash读取#值**
`window.location.hash`这个属性可读可写，读取时，可以用来判断网页状态是否改变，写入时，则会在不重载网页的前提下，创造一条访问历史记录

**onhashchange事件**
这是一个HTML5新增的事件，当#值发送变化时，就会触发这个事件，IE8+,Firefox 3.6+,chrome 5+支持该事件，它的使用方法有三种：
- `window.onhashchange=func`
- `<body onhashchange="func()">`
- `window.addEventListener("hashchange", func, false)`

**Google抓取#的机制**
默认情况下，Google的网络蜘蛛会忽略URL的#部分
但是，Google还规定，如果你希望Ajax生成内容被浏览器引擎读取，那么url中可以使用`#!`, Google会自动将后面的内容转成查询字符串`_escaped_fragment_`的值
比如：Google发现新版twitter的url如下
```
http://twitter.com/#!/username
```
就会自动抓取另一个url:
```
http://twitter.com/?_escaped_fragment_=/username
```
通过这种机制，Google就可以索引动态的ajax内容

# mediaType
> media type规范官网：https://www.iana.org/assignments/media-types/media-types.xhtml

Internet Media Type，即互联网媒体类型，也叫做于MIME类型，它使用两部分标识符来确定一个类型。

MIME(Multipurpose Internet Mail Extensions)多用途互联网邮件扩展类型。是设定某种扩展名的文件用一种应用程序来打开的方式类型，当该扩展名文件被访问的时候，浏览器会自动使用指定应用程序来打开。多用于指定一些客户端自定义的文件名，以及一些媒体文件打开方式。

## 常见的mediaType
常见的媒体格式类型如下：
- text/html ： HTML格式
- text/plain ：纯文本格式
- text/xml ： XML格式
- image/gif ：gif图片格式
- image/jpeg ：jpg图片格式
- image/png：png图片格式

以application开头的媒体格式类型：
- application/xhtml+xml ：XHTML格式
- application/xml： XML数据格式
- application/atom+xml ：Atom XML聚合格式
- application/json： JSON数据格式
- application/pdf：pdf格式
- application/msword ： Word文档格式
-application/octet-stream ： 二进制流数据（如常见的文件下载）
- application/x-www-form-urlencoded ：`<form encType="">`中默认的encType，form表单数据被编码为key/value格式发送到服务器（表单默认的提交数据的格式）

另外一种常见的媒体格式是上传文件之时使用的：
- multipart/form-data ： 需要在表单中进行文件上传时，就需要使用该格式

# 跨域
## 为什么会出现跨域问题
出于浏览器的同源策略限制。同源策略（Sameoriginpolicy）是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，则浏览器的正常功能可能都会受到影响。可以说Web是构建在同源策略基础之上的，浏览器只是针对同源策略的一种实现。同源策略会阻止一个域的javascript脚本和另外一个域的内容进行交互。所谓同源（即指在同一个域）就是两个页面具有相同的协议（protocol），主机（host）和端口号（port）

<font color="red">跨域问题是在浏览器上的，即只有浏览器访问一个资源时，才会发生跨域问题。
当一个服务器不是通过浏览器来访问另一个服务器资源时，是不会发生跨域问题的。</font>

## 解决跨域问题
### CORS
这是最常用的方法。
CORS 是跨域资源分享（Cross-Origin Resource Sharing）的缩写。它是 W3C 标准，属于跨源 AJAX 请求的根本解决方法。
- 普通跨域请求：只需服务器端设置Access-Control-Allow-Origin
- 带cookie跨域请求：前后端都需要进行设置

# CORS
CORS是一个W3C标准，全称是"跨域资源共享"（Cross-origin resource sharing）。
它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。
## 简介
CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。

整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。

因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。

## 两种请求
浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。

只要同时满足以下两大条件，就属于简单请求。

1. 请求方法是以下三种方法之一：
- HEAD
- GET
- POST

2. HTTP请求头中只允许下面字段被修改或被设置
- Accept
- Accept-Language
- Content-Language
- Last-Event-ID
- Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain

凡是不同时满足上面两个条件，就属于非简单请求。

浏览器对这两种请求的处理，是不一样的。

### 简单请求
#### 基本流程
对于简单请求，浏览器直接发出CORS请求。具体来说，就是在头信息之中，增加一个Origin字段。

下面是一个例子，浏览器发现这次跨源AJAX请求是简单请求，就自动在头信息之中，添加一个Origin字段。
```
GET /cors HTTP/1.1
Origin: http://api.bob.com
Host: api.alice.com
Accept-Language: en-US
Connection: keep-alive
User-Agent: Mozilla/5.0...
```
上面的头信息中，Origin字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。

如果Origin指定的源，不在许可范围内，服务器会返回一个正常的HTTP回应。浏览器发现，这个回应的头信息没有包含Access-Control-Allow-Origin字段（详见下文），就知道出错了，从而抛出一个错误，被XMLHttpRequest的onerror回调函数捕获。注意，这种错误无法通过状态码识别，因为HTTP回应的状态码有可能是200。

如果Origin指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。
```
Access-Control-Allow-Origin: http://api.bob.com
Access-Control-Allow-Credentials: true
Access-Control-Expose-Headers: FooBar
Content-Type: text/html; charset=utf-8
```
上面的头信息之中，有三个与CORS请求相关的字段，都以Access-Control-开头。

**1. Access-Control-Allow-Origin**
该项控制数据的可见范围，如果希望数据对任何人都可见，可以填写`"*"`

**2. Access-Control-Allow-Credentials**
该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为true，如果服务器不要浏览器发送Cookie，删除该字段即可，而不是填写false

**3. Access-Control-Expose-Headers**
该字段可选。CORS请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，例如Cookie, 就必须在Access-Control-Expose-Headers里面指定。上面的例子指定，getResponseHeader('FooBar')可以返回FooBar字段的值。


#### withCredentials 属性
> - 不跨域的时候，HTTP 携带 cookie 是协议里规定的，换言之，你不需要主动操作
> - 跨域的时候，如果服务器包含 CORS 头，那么 withCredentials=true 可以携带 cookie。

上面说到，CORS请求默认不发送Cookie和HTTP认证信息。如果要把Cookie发到服务器，一方面要服务器同意，指定Access-Control-Allow-Credentials字段。
```
Access-Control-Allow-Credentials: true
```
另一方面，开发者必须在AJAX请求中打开withCredentials属性。
```
var xhr = new XMLHttpRequest();
xhr.withCredentials = true;
```
否则如果withCredentials的值为false时，即使服务器同意发送Cookie，浏览器也不会发送。或者，服务器要求设置Cookie，浏览器也不会处理。

但是，如果省略withCredentials设置，有的浏览器还是会一起发送Cookie。这时，可以显式关闭withCredentials。
```
xhr.withCredentials = false;
```

需要注意的是，**如果要发送Cookie，Access-Control-Allow-Origin就不能设为星号，必须指定明确的、与请求网页一致的域名**。同时，Cookie依然遵循同源政策，只有用服务器域名设置的Cookie才会上传，其他域名的Cookie并不会上传，且（跨源）原网页代码中的document.cookie也无法读取服务器域名下的Cookie。

> 注：axios发送post请求时，withCredentials默认是false, 即不携带cookie, 我们可以使用下面方法来使其携带cookie
```js
 axios({
        method: "post",
        url: apiConfig.getCoupon,
        withCredentials: true,
        data: {
          type: x
        }
```

### 非简单请求
#### 预检请求(preflight request)
非简单请求是那种对服务器有特殊要求的请求，比如请求方法是PUT或DELETE，或者Content-Type字段的类型是application/json。

非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为"预检"请求（preflight）。

![](https://raw.githubusercontent.com/NaisWang/images/master/20220409125829.png)

浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。

下面是一段浏览器的JavaScript脚本。
```
var url = 'http://api.alice.com/cors';
var xhr = new XMLHttpRequest();
xhr.open('PUT', url, true);
xhr.setRequestHeader('X-Custom-Header', 'value');
xhr.send();
```
上面代码中，HTTP请求的方法是PUT，并且发送一个自定义头信息X-Custom-Header。

浏览器发现，这是一个非简单请求，就自动发出一个"预检"请求，要求服务器确认可以这样请求。下面是这个"预检"请求的HTTP头信息。
```
OPTIONS /cors HTTP/1.1
Origin: http://api.bob.com
Access-Control-Request-Method: PUT
Access-Control-Request-Headers: X-Custom-Header
Host: api.alice.com
Accept-Language: en-US
Connection: keep-alive
User-Agent: Mozilla/5.0...
```

"预检"请求用的请求方法是OPTIONS，表示这个请求是用来询问的。头信息里面，关键字段是Origin，表示请求来自哪个源。

除了Origin字段，"预检"请求的头信息包括两个特殊字段。
**1. Access-Control-Request-Method**
该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法，上例是PUT。
**2. Access-Control-Request-Headers**
该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段，上例是X-Custom-Header


#### 预检请求的回应
服务器收到"预检"请求以后，检查了Origin、Access-	Control-Request-Method和Access-Control-Request-Headers字段以后，确认允许跨源请求，就可以做出回应。
```
HTTP/1.1 200 OK
Date: Mon, 01 Dec 2008 01:15:39 GMT
Server: Apache/2.0.61 (Unix)
Access-Control-Allow-Origin: http://api.bob.com
Access-Control-Allow-Methods: GET, POST, PUT
Access-Control-Allow-Headers: X-Custom-Header
Content-Type: text/html; charset=utf-8
Content-Encoding: gzip
Content-Length: 0
Keep-Alive: timeout=2, max=100
Connection: Keep-Alive
Content-Type: text/plain
```
上面的HTTP回应中，关键的是Access-Control-Allow-Origin字段，表示http://api.bob.com可以请求数据。该字段也可以设为星号，表示同意任意跨源请求。
```
Access-Control-Allow-Origin: *
```
如果服务器否定了"预检"请求，会返回一个正常的HTTP回应，但是没有任何CORS相关的头信息字段。这时，浏览器就会认定，服务器不同意预检请求，因此触发一个错误，被XMLHttpRequest对象的onerror回调函数捕获。控制台会打印出如下的报错信息。

![](https://raw.githubusercontent.com/NaisWang/images/master/20220409125841.png)

服务器回应的其他CORS相关字段如下。
```
Access-Control-Allow-Methods: GET, POST, PUT
Access-Control-Allow-Headers: X-Custom-Header
Access-Control-Allow-Credentials: true
Access-Control-Max-Age: 1728000
```
**Access-Control-Allow-Methods**
该字段必需，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次"预检"请求。

**Access-Control-Allow-Headers**
如果浏览器请求包括Access-Control-Request-Headers字段，则Access-Control-Allow-Headers字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在"预检"中请求的字段。
如果一个跨域请求的请求头中包含的字段不在`Access-Control-Allow-Headers`中，则会报如下错误：

![](https://raw.githubusercontent.com/NaisWang/images/master/20220409125853.png)


**Access-Control-Allow-Credentials**
该字段与简单请求时的含义相同。

**Access-Control-Max-Age**
该字段可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是20天（1728000秒），即允许缓存该条回应1728000秒（即20天），在此期间，不用发出另一条预检请求。

#### 浏览器的正常请求和回应
一旦服务器通过了"预检"请求，以后每次浏览器正常的CORS请求，就都跟简单请求一样，会有一个Origin头信息字段。服务器的回应，也都会有一个Access-Control-Allow-Origin头信息字段。

下面是"预检"请求之后，浏览器的正常CORS请求。
```
PUT /cors HTTP/1.1
Origin: http://api.bob.com
Host: api.alice.com
X-Custom-Header: value
Accept-Language: en-US
Connection: keep-alive
User-Agent: Mozilla/5.0...
```
上面头信息的Origin字段是浏览器自动添加的。

下面是服务器正常的回应。
```
Access-Control-Allow-Origin: http://api.bob.com
Content-Type: text/html; charset=utf-8
```
上面头信息中，Access-Control-Allow-Origin字段是每次回应都必定包含的

## 与JSONP的比较
CORS与JSONP的使用目的相同，但是比JSONP更强大。
JSONP只支持GET请求，CORS支持所有类型的HTTP请求。JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。

# 防火墙技术
防火墙：一种高级访问控制设备，置于不同网络安全域之间，它通过相关的安全策略来控制（允许、拒绝、监视、记录）进出网络的访问行为。

![](https://raw.githubusercontent.com/NaisWang/images/master/20220409125903.png)

## 防火墙的核心技术

![](https://raw.githubusercontent.com/NaisWang/images/master/20220409125912.png)

### 包过滤防火墙技术原理

![](https://raw.githubusercontent.com/NaisWang/images/master/20220409125921.png)

### 应用代理防火墙技术原理

![](https://raw.githubusercontent.com/NaisWang/images/master/20220409125933.png)

### 状态检测防火墙技术原理

![](https://raw.githubusercontent.com/NaisWang/images/master/20220409125945.png)

### 完全内容检测防火墙技术原理

![](https://raw.githubusercontent.com/NaisWang/images/master/20220409125957.png)

## 防火墙体系结构
防火墙体系结构分为过滤路由器，多宿主主机，被屏蔽主机，被屏蔽子网

### 过滤路由器（Filtering Router）

![](https://raw.githubusercontent.com/NaisWang/images/master/20220409130007.png)

### 双宿主主机（Dual Homed Gateway）

![](https://raw.githubusercontent.com/NaisWang/images/master/20220409130018.png)

### 被屏蔽主机（Screened Host Gateway ）

![](https://raw.githubusercontent.com/NaisWang/images/master/20220409130028.png)

### 被屏蔽子网（Screened Subnet）

![](https://raw.githubusercontent.com/NaisWang/images/master/20220409130037.png)

## 防火墙技术原理
### 防火墙基本功能
1. 访问控制（防火墙是一种高级的访问控制设备）
2. 地址转换（都会部署在内外网之间，尤其是互联网出口，因此会涉及到地址转换问题）
3. 网络环境支持（2层或3层之间的内部连接）
4. 带宽管理功能（如观看视频时，同时其它人要去炒股，）
5. 入侵检测和攻击防御
6. 用户认证
7. 高可用性

#### 访问控制

![](https://raw.githubusercontent.com/NaisWang/images/master/20220409130047.png)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220409130116.png)

#### 地址转换

![](https://raw.githubusercontent.com/NaisWang/images/master/20220409130125.png)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220409130135.png)

#### 网络环境支持

![](https://raw.githubusercontent.com/NaisWang/images/master/20220409130145.png)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220409130154.png)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220409130203.png)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220409130216.png)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220409130227.png)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220409130237.png)

#### 宽带管理
可以根据业务进行不同的流量分配，以保证重要业务的应用

![](https://raw.githubusercontent.com/NaisWang/images/master/20220409130248.png)

#### 入侵检测和攻击防御

![](https://raw.githubusercontent.com/NaisWang/images/master/20220409130258.png)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220409130307.png)

#### 用户认证

![](https://raw.githubusercontent.com/NaisWang/images/master/20220409130316.png)

#### 高可用性

![](https://raw.githubusercontent.com/NaisWang/images/master/20220409130333.png)


![](https://raw.githubusercontent.com/NaisWang/images/master/20220409130343.png)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220409130352.png)

### 防火墙典型应用

![](https://raw.githubusercontent.com/NaisWang/images/master/20220409130402.png)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220409130412.png)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220409130424.png)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220409130437.png)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220409130446.png)

# 翻墙中的墙是什么
首先墙是防火长城(Great Fire Wall ,GFW)。08年以前，我国的网络审查制度还不是很健全，现在无法访问的这些网站和服务，当时都是可以正常访问的。后来因为一些政治原因，我国建立起审查制度，部署了GFW，来阻挡大陆互联网用户访问某些境外网站和服务。这里注意：网络审查制度不等同于GFW。审查制度针对的是所有的互联网流量，国内的网站也会受到政治的直接干预，被要求自我审查、自我监管甚至关闭,。大陆的所有网站都要强制配合。GFW的作用主要在于分析和过滤境外资讯和互相访问。所以很多人认为，墙的目的就是为了洗脑、愚化民众，不让外界的声音传进来。曾经一度，基本上所有人都这么想的。可能确实有这部分原因，但是真正的导火索，其实很多人都不知道。08年前奥运会前夕，恐怖组织在FaceBook上策划、协调并且实施了对我西部地区的一个恐怖袭击。中国政府当时就要求FaceBook配合审查，以防再次出现此类事件。但是FaceBook以尊重保护用户隐私，这样的一个理由来拒绝了。同时Google也以同样的理由拒绝了中国政府的要求。所以很简单，大陆政府就不让你们这些不愿意配合的外国公司在中国开展业务。于是，FaceBook海还有Google的一系类服务都被封了。同期被陆陆续续封锁的还有Twitter Tumblr这些比较大的互联网服务商。经过一段时间的审查制度和GFW的越来越规范，导致甚至一些不涉及到政治和国民安全的互联网服务，比如说成人网站也被封了。墙由政治时间而起，却最后连带一起这些色情网站也躺枪了

## GFW的原理
人们对于GFW工作原理的猜猜从来没有停息过，因此尽管其真实的实现细节仍然无从知晓，但一些有着强烈好奇心的学者以及国内的翻墙爱好者还是瞥见了一些端倪。普遍的看法是，GFW的工作机制主要包括IP黑名单、内容审查和DNS劫持等三种，下面我们逐一举例探讨

### IP黑名单
#### 一个例子
视频分享网站Youtube在国内遭到封禁己是众所周知的事实，由于使用域名访问会存在DNS劫持问题，这里直接以其IP地址之一 208.65.153.238 来举例说明GFW的IP黑名单机制。
用浏览器访间http://208.65.153.238有如下结果：

![](https://raw.githubusercontent.com/NaisWang/images/master/20220409130457.png)

执行ping命令也有超时现象:

![](https://raw.githubusercontent.com/NaisWang/images/master/20220409130508.png)

上面两幅图均表明，目标主机未能(或无法）及时响应我们的请求，为了一探究竞，我
们进一步执行`tracert`命令如下：

![](https://raw.githubusercontent.com/NaisWang/images/master/20220409130517.png)

结果易示，路径断在了主机 202.112.61.214 的地方

#### 另一个例子
访问网站牛博国际存在同样的问题，对其IP地址执行`tracert`也有类似结果：

![](https://raw.githubusercontent.com/NaisWang/images/master/20220409130528.png)

#### 猜测
根据以上结果我们猜测，GFW 很有可能维护了一张IP黑名单，一旦发现发往黑名单中
地址的请求数据包，就直接将其丢弃，这将导致源主机得不到目标主机的及时响应而引发超时，从而达到屏蔽对目标主机的访问的目的。

进一步，我们有理由认为主机 202.112.61.214 就是 GFW 的设备之一，为了证实这一猜测，我们用Nmap对其进行了扫描:

![](https://raw.githubusercontent.com/NaisWang/images/master/20220409130538.png)

扫描结果显示，设备 202.112.61.214 很有可能是一台 Cisco 的路由器，这与 GFW的设备构成是吻合的

#### 黑名单的缺点
显而易见，这种对被封禁的网站采用黑名单而不是对被介许访问的网站采用白名单的过滤机制，难免会有漏网之鱼的存在，Youtube的另外一个地址208.117.240.37 就是-个很好的例子：

![](https://raw.githubusercontent.com/NaisWang/images/master/20220409130547.png)

### 内容审查
#### 一个简单的例子
用 Google.com 搜索关键词 “freegate”，起初我们还能够得到搜索结果：

![](https://raw.githubusercontent.com/NaisWang/images/master/20220409130558.png)

但是与此同时，我们收到了大量“从 Google 发来的“TCP 连接重置包。下图是使用Wireshark抓包的结果。

![](https://raw.githubusercontent.com/NaisWang/images/master/20220409130608.png)

刷新页面会发现已经无法访问：

![](https://raw.githubusercontent.com/NaisWang/images/master/20220409130621.png)

并且Google.com也变得无法访问:

![](https://raw.githubusercontent.com/NaisWang/images/master/20220409130631.png)

#### 一个极瑞的例子
与前面的例子类似，访问http:///chinagtw.or/search/label/anti-censorship会收到数以百计的TCP连接重置包：

![](https://raw.githubusercontent.com/NaisWang/images/master/20220409130645.png)

#### 猜测
我们猜测，GFW 对 HTTP 数据包进行了扫描，并目 GFW 内部可能包含有一些敏感词汇列表, 一旦发现被扫描数据包中出现敏感词汇，就会立即向源主机和目标主机发送伪装成对方地址的 TCP 连接重置包，以实现断开连接的目的。
进一步，GFW 还会在一个临时的黑名单中记录遭到封禁的源主机和目标主机的地址，并保存一段有限长的时间。一旦发现被封禁的源主机在封禁期间再次请求目标主机，将直接返回 TCP 连接重置包（此时可能是单向的)，而无需扫描新的请求数据包。
另一个发现是，这种内容审查机制并非对所有站点起作用，例如，使用 Google.cn 搜索,同样的关健词 “freegate”就不会出现被盾的现象。一种可能的原因是，GFW 启用了一张IP监视名单，而Google.com 的地址正是其中之一：另一种可能是，访间 Google.cn 不会经过GFW 设备，也就不会触发 TCP 连接重置，而位于 GFW 之外的 Google.com 则难逃此劫。

### DNS 劫持
#### 一个例子
除IP黑名单技术外，GFW还采用了DNS劫持的手段来达到对youtube的封禁目的。
为了说明这一点，我们执行`nslookup`命令如下：

![](https://raw.githubusercontent.com/NaisWang/images/master/20220409130659.png)

上图的结果表明"www.youtube.com”经过DNS服务器 166.111.8.28 被解析到地址 202.106.1.2，但是事实上，该地址并非Youtube真实地址中的任何一个
进一步，即使使用国外的DNS服务器，如OpenDNS来进行解析，也不能得到youtube的真实地址

![](https://raw.githubusercontent.com/NaisWang/images/master/20220409130708.png)

并且每次返回的结果可能大相径庭:

![](https://raw.githubusercontent.com/NaisWang/images/master/20220409130718.png)

然而，如果使用在线nslookup服务，例如http://www.kloth.net/services/nslookup.phe，则可以得到youtube的直实地址：

![](https://raw.githubusercontent.com/NaisWang/images/master/20220409130729.png)

#### 猜测
GFW至少使用了两种DNS劫持机制：
一方面，GFW对国内DNS服务器进行了缓存污染，这种污染体现在使用国内DNS服务器对youtube进行解析会得到稳定的、虛假的IP地址
另一方面，GFW会拦截和应答试图从时内发往国外的DNS解析请求（也可能是对国外DNS服务器的应答进行了算改），这体现在使用OpenDNS进行解析时观察到的可变的、虚假的IP地址。

## 翻墙的工作原理
GFW部署之后，我们根据它的工作原理判断出只要GFW不能探明我发送的数据包的真实意图，那么GFW就不会中断我们的请求。为了实现这个，我们可以通过连接一台符合GFW认为合理的服务器作为中转，来替代我去做想做的事情，然后把结果告诉我。这套逻辑也正是很多初期htpp代理、VPN、SSH代理这些突破封锁的实现方式

### SSH代理工作原理

![](https://raw.githubusercontent.com/NaisWang/images/master/20220409130739.png)

1. 本地网络上的计算机PC发送一个请求建立加密通道的数据包，接入骨干网，域名解析
2. GFW发现我访问的并非Google或者是Facebook，而是一台GFW允许访问的国外的服务器，此时GFW放行
3. 数据包经过中转服务器SSH server解密出我真实想要访问的地址,并且对其真实地址进行访问
4. 真实地址服务器返回响应数据给中转服务器SSH server
5. 中站服务器SSH Server将响应数据再经过墙传回到本地计算机PC

你会发现这样一来就完美规避了GFW一切有效探测手段。首先我的数据流量不再是明文，而是加密数据，因此GFW看不到我的关键字。第二是DNS解析的时候，发现我访问的对象是GFW允许的服务器，而不是Google, 那么DSN也正常解析。

然而这里有一个问题， 那就是GFW逐渐发现，越来越多的流量都是这种类型的模式，即先发送一个数据包请求和一个服务器建立这种加密连接，然后紧跟着一个代理请求。这个就是传说中的特征。
由于太多用户使用这种方式来翻墙，所以GFW根据这些特别有特征明显的这种流量做了两件事。第一，屏蔽掉vpn用的端口，以后你再想用vpn，需要申请报备，审核通过了，你才可以使用。第二，慢慢积累这些提供vpn服务的主机的ip，然后屏蔽掉这些ip。经过这些打压，vpn这种翻墙的方式就慢慢死掉了

> 注：vpn本身不是根据翻墙的这个需求被开发出来的，只是恰好vpn这种流量加密的方式，能使得GFW无法探测

### Shadowsocks(SS)工作原理
SS的出现，可以说是一个拐点。SS引出了一个把代理服务器拆分成本地和远程两个的这种概念。实现经过GFW的流量全部加密，从而消除明显的这个流量的特征的这个概念。后来衍生出来的SSR、v2ray这些都是基于类似的这个原理。

一些为具体原理解析：

![](https://raw.githubusercontent.com/NaisWang/images/master/20220409130749.png)

1. 本地计算机PC发出一个数据包给本地的SS服务器SS Local(这里说的SS服务器，指的是你电脑或者手机上装的Shadowsocks翻墙软件，或者是你的翻墙路由器)发送数据加密请求。
2. 由于本地网络在本地，所以不过墙，而且瞬间能完成加密，然后发送加密数据，经过DNS解析，通过骨干网到达国际出口。
3. GFW因为探测不到具有特别明显特征的这个流量，所以也放行，到达你的远程中转服务器(SS Server)，也就是你的远程的Shadowsocks服务器，这个可以是你自己的vps，也可以是机场的服务器。
4. 远程中转服务器解密你的数据，然后转发到google
5. google回应数据给远程中转服务器
6. 远程中转服务器加密数据，发送加密数据到达GFW
7. 因为GFW探测不到特别明显的流量，并且数据包也不是http的明文数据，所以GFW无法嗅探到敏感词，那么只好放行，到达你的本地Shadowsocks服务器
8. 本地Shadowsocks服务器经过解密，将数据包发送到本地计算机

以上一套流程，就是Shadowsocks的基本工作原理和逻辑，后面出现的SSR和V2ray技术，虽然具体细节上有一些微小的差异，但是都是基于这种基础的这种逻辑。目前各种各样的这种加密方式与算法基本都是在GFW这个位置，用于伪装和消除特征。

至于为什么GFW不封锁所有的国际加密流量，是因为相比翻墙的流量，超过99%的这些通信流量都是正常的需求。如果把这些所有的国际加密流量都封锁掉，那中国真就成了局域网。所以说，目前来说，这就是为什么Shadowsocks这种实现原理是相对安全可靠的。 和刚才的vpn、SSH代理的翻墙模式最大区别在于VPN、SSH代理的特征很明显，过墙的数据很遵循一个固定的一个套路，都是先发送一个建立加密通道的数据包。Shadowsocks则是在本地完成加密，过墙的数据已经是加密数据了，所以GFW无法探测到固定的模式和特征。

# 代理、vpn、SS、SSR、V2Ray、加速器与vps
## 正向代理与反向代理
### 正向代理
正向代理（forward proxy）：是一个位于客户端和目标服务器之间的服务器(代理服务器)，为了从目标服务器取得内容，客户端向代理服务器发送一个请求并指定目标，然后代理服务器向目标服务器转交请求并将获得的内容返回给客户端。

这种代理其实在生活中是比较常见的，比如访问外国网站技术（翻墙），其用到的就是代理技术。

有时候，用户想要访问某国外网站，该网站无法在国内直接访问，但是我们可以访问到一个代理服务器，这个代理服务器可以访问到这个国外网站。这样呢，用户对该国外网站的访问就需要通过代理服务器来转发请求，并且该代理服务器也会将请求的响应再返回给用户。这个上网的过程就是用到了正向代理。

![](https://raw.githubusercontent.com/NaisWang/images/master/20220409130759.png)

**所以，正向代理，其实是"代理服务器"代理了"客户端"，去和"目标服务器"进行交互。**
通过正向代理服务器访问目标服务器，目标服务器是不知道真正的客户端是谁的，甚至不知道访问自己的是一个代理

#### 正向代理的用途
**1. 突破访问限制**
通过代理服务器，可以突破自身IP访问限制，访问国外网站，教育网等。
**2. 提高访问速度**
通常代理服务器都设置一个较大的硬盘缓冲区，会将部分请求的响应保存到缓冲区中，当其他用户再访问相同的信息时， 则直接由缓冲区中取出信息，传给用户，以提高访问速度。
**3. 隐藏客户端真实IP**
上网者也可以通过这种方法隐藏自己的IP，免受攻击。

### 反向代理
反向代理（reverse proxy）：是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。

对于常用的场景，就是我们在Web开发中用到的负载均衡服务器，客户端发送请求到负载均衡服务器上，负载均衡服务器再把请求转发给一台真正的服务器来执行，再把执行结果返回给客户端。

![](https://raw.githubusercontent.com/NaisWang/images/master/20220409130808.png)

**所以，反向代理，其实是"代理服务器"代理了"目标服务器"，去和"客户端"进行交互。**
通过反向代理服务器访问目标服务器时，客户端是不知道真正的目标服务器是谁的，甚至不知道自己访问的是一个代理。

#### 反向代理的用途
**1. 隐藏服务器真实IP**
使用反向代理，可以对客户端隐藏服务器的IP地址。
**2. 负载均衡**
反向代理服务器可以做负载均衡，根据所有真实服务器的负载情况，将客户端请求分发到不同的真实服务器上。
**3. 提高访问速度**
反向代理服务器可以对于静态内容及短时间内有大量访问请求的动态内容提供缓存服务，提高访问速度。
**4. 提供安全保障**
反向代理服务器可以作为应用层防火墙，为网站提供对基于Web的攻击行为（例如DoS/DDoS）的防护，更容易排查恶意软件等。还可以为后端服务器统一提供加密和SSL加速（如SSL终端代理），提供HTTP访问认证等。

### 正向代理和反向代理的区别
虽然正向代理服务器和反向代理服务器所处的位置都是客户端和真实服务器之间，所做的事情也都是把客户端的请求转发给服务器，再把服务器的响应转发给客户端，但是二者之间还是有一定的差异的。
1. **正向代理其实是客户端的代理**，帮助客户端访问其无法访问的服务器资源。**反向代理则是服务器的代理**，帮助服务器做负载均衡，安全防护等。
2. **正向代理一般是客户端架设的**，比如在自己的机器上安装一个代理软件。**而反向代理一般是服务器架设的**，比如在自己的机器集群中部署一个反向代理服务器。
3. **正向代理中，服务器不知道真正的客户端到底是谁**，以为访问自己的就是真实的客户端。而在**反向代理中，客户端不知道真正的服务器是谁**，以为自己访问的就是真实的服务器。
4. 正向代理和反向代理的作用和目的不同。**正向代理主要是用来解决访问限制问题。而反向代理则是提供负载均衡、安全防护等作用。二者均能提高访问速度。**


## PN与VPN
### 专用网络PN(Private Networks)
#### 定义
专用网络是两个企业间的专线连接，这种连接是两个企业的内部网之间的物理连接。专线是两点之间永久的专用电话线连接。**和一般的拨号连接不同，专线是一直连通的。这种连接的最大优点就是安全。除了这两个合法连入专用网络的企业，其他任何人和企业都不能进入该网络**。所以，专用网络保证了信息流的安全性和完整性。

![](https://raw.githubusercontent.com/NaisWang/images/master/20220409130823.png)

#### 缺陷
专用网络的最大缺陷是成本太高，因为专线非常昂贵。每对想要专用网络的企业都需要一条独立的专用(电话)线把它们连到一起，而不是建立在公用网络上。
例如，如果一个企业想通过专用网络与7个企业建立外部网连接，企业必须支付7条专线的费用。企业一般把这个问题称为“伸缩”问题：增加专用网络的数目很困难、昂贵且耗时。那么企业到底该如何在它们的内部网之间建立紧密和专用的联系呢?答案可能就是根据虚拟专用网络设计的外部网。

### 虚拟专用网络VPN(Virtual Private Networks)
#### 简介
VPN属于远程访问技术, **简单地说就是在公用网络上建立专用网络，进行加密通讯**。在企业网络中有广泛应用。VPN网关通过对数据包的加密和数据包目标地址的转换实现远程访问。VPN可通过服务器、硬件、软件等多种方式实现

由于VPN是建立在公用网络上，所以要想实现与专用网络类似的安全性能，我们可以通过隧道技术、加密技术、密钥管理、认证和访问控制等方式来增强数据的安全性

例如某公司员工出差到外地，他想访问企业内网的服务器资源，这种访问就属于远程访问。
在传统的企业网络配置中，要进行远程访问，传统的方法是租用DDN（数字数据网）专线或帧中继，这样的通讯方案必然导致高昂的网络通讯和维护费用。对于移动用户（移动办公人员）与远端个人用户而言，一般会通过拨号线路（Internet）进入企业的局域网，但这样必然带来安全上的隐患。
**让外地员工访问到内网资源，利用VPN的解决方法就是在内网中架设一台VPN服务器。外地员工在当地连上互联网后，通过互联网连接VPN服务器，然后通过VPN服务器进入企业内网**。为了保证数据安全，VPN服务器和客户机之间的通讯数据都进行了加密处理。有了数据加密，就可以认为数据是在一条专用的数据链路上进行安全传输，就如同专门架设了一个专用网络一样，但实际上VPN使用的是互联网上的公用链路，因此VPN称为虚拟专用网络，其实质上就是利用加密技术在公网上封装出一个数据通讯隧道。有了VPN技术，用户无论是在外地出差还是在家中办公，只要能上互联网就能利用VPN访问内网资源，这就是VPN在企业中应用得如此广泛的原因。

## SS、SSR
Shadowsocks(简称SS)是一种基于Socks5代理方式的加密传输协议, Shadowsocks应该是最为人熟知的代理工具之一了，由于其软件logo是飞机的形状，所以也称作小飞机，而在服务器上搭建Shadowsocks供他人使用，也就称为`机场`。Shadowsocks原作者Clowwindy最开始只是为了方便自己科学上网，而开发了协议。并且将源代码放在Github上供大家开源使用，由于其开创性的中转服务器代理原理，使得翻墙效果非常好，很多个人以及开发商都在使用Shadowsocks搭建翻墙软件。
也是因为这个原因，Clowwindy最后被请喝茶，随后Clowwindy在Github移除了相关代码，之后Shadowsocks无人维护，并且已经能被防火长城精准识别，目前已经很少人用Shadowsocks进行翻墙。
之后，ShadowsocksR原作者breakwa11发起了新的分支，也称作SSR，也就是说在原Shadowsocks的基础上继续进行开发。关于ShadowsocksR以及其作者，中途发生了很多事，最后也删除了代码并解散了交流群组，同样的，任然有人在SSR基础继续进行开发，目前叫做SSRR。相关搭建教程可以[参考SSR一键安装](https://qiangwaikan.com/ssr/)

## V2Ray
简单的理解来说，V2Ray就是类似ShadowsocksR的代理翻墙协议，这是他们共通之处，也是大多数人使用V2Ray的原因。当然，V2Ray的作用可能并不是简单的一个翻墙协议，V2Ray严格上来说应该是一个工具箱，它甚至可以集成ShadowsocksR一起使用，而V2Ray用于翻墙的协议是其默认的VMess。
V2Ray与SSR区别还是很多，总的来说V2Ray要比SSR要强大的多。但由于SSR要比V2Ray更早发布，所以也使得更多的人使用SSR，并且相关教程以及及客户端软件也更加丰富，也就是说SSR的生态更加完善。
V2Ray的相对要更新一些，相关教程比较少，并且配置上要比SSR更加复杂，对新手来说不太容易上手，[参考V2Ray一键安装](https://qiangwaikan.com/v2ray/)。就翻墙效果来说，V2Ray可能要比SSR更好一些，V2Ray内置的VMess相对更加隐蔽性更好，并且提供了自定义协议的功能，对于有一定技术能力的人来说，自己开发一些扩展协议。
至于V2Ray和SSR那个更好？个人觉得看自己的需求，如果你是想配置简单容易上手，那么SSR肯定更好用。如果你具备已经技术能力，那么V2Ray可能更适合你。翻墙稳定性来说，个人用下来差别不是很大。

## 加速器
加速器就其技术原理来说，就等同于VPN，只不过与翻墙VPN的用途不同而已。
加速器的主要用户群体是国外网游玩家，他们在玩国外网友的时候，经常出现卡顿或者登不上等情况，这就是由于网络延迟较高。那么为什么会出现如此高的延迟呢？主要原因就是线路不同，运营商转发用户的数据有很多种线路，而通常来讲这些线路可能不是最优的，加速器服务商则租用了协议服务器，使得用户转发用户的数据线路更优，并且还会租用协议私有线路，降低高峰期网络拥堵问题。
那么加速器可以用来翻墙吗？很遗憾，不能。就国内正规的网络加速器来说，都不能用于翻墙，这些加速器服务商都是有严格备案的，包括Google在内的很多黑名单网站都不能打开。

## VPS
VPS就是虚拟专用服务器(Virtual private server)的英文缩写，简单的理解就是一台服务器被分成了很多台，当然这里的”分”并不是说砍成几半的，而是利用一些技术手段，使得多个用户可共享这台服务器。
通常，租用一台服务器费用是比较高的，而且对于用户来说，一台服务器的CPU计、内存、磁盘空间大多数时候是过剩的，这样非常浪费资源，并且用于又承担了较高的价格。而如果是购买VPS，价格则要划算得多，你相当于和其他多个用户一起在使用同一台服务器，你们共同分摊成本。当然你不用担心和其他用户在使用时产生冲突，这些问题通过虚拟化技术已经得到了很好的解决。
不管是个人还是中小型企业，其实VPS都是不二之选，你不需要请专人维护服务器，也不会造成资源浪费，嫌太贵就降低配置，觉得资源不够就充钱升配，非常简单省事并且稳定。
总的来说VPS就是一台小型的服务器，既然是服务器，那么利用前面介绍的Shadowsocks(SSR)或者V2Ray等开源软件，然后购买国外的VPS，在上面搭建翻墙软件。不过，如果是用来翻墙的VPS，那么线路是个很重要的指标，并不是所有VPS用来翻墙效果都好，首先要考虑延迟和带宽，而我用过很多VPS其实效果都不太理想，比如大家比较知名的搬瓦工、Vultr等。很多人在这上面搭建机场，导致这些VPS服务商很多IP段都被防火长城拉黑了。
我不推荐用VPS搭建梯子的另外一个原因是，VPS只提供的一个IP，要明白没有万能的协议，以上所有的协议都不是绝对稳定，并且防火长城封IP有时候是玄学问题，一旦这个IP被封，那么只能花钱换IP，这只是其中一个问题，总的来说你要花费一些时间来维护你的梯子。

## VPN 和代理的区别
### 概念区别
以下是维基百科对VPN 和代理的中文权威解释：
“（英语：virtual private network，缩写：VPN）是常用于连接中、大型企业或团体间私人网络的通讯方法。它利用隧道协议（Tunneling Protocol）来达到发送端认证、消息保密与准确性等功能。”
“代理（英语：Proxy）也称网络代理，是一种特殊的网络服务，允许一个（一般为客户端）通过这个服务与另一个网络终端（一般为服务器）进行非直接的连接。一般认为代理服务有利于保障网络终端的隐私或安全，防止攻击。”
显而易见，单从定义我们就可以看出 VPN 的最大特点是采取隧道协议进行数据传输和保护。而代理使用的则是对应的代理协议。说到协议，以下是一些 VPN 和代理的常用协议：

||加密协议名称|
|--|--|
|VPN|	OpvenVPN、IPsec、IKEv2、PPTP、L2TP、WireGuard等|
|代理|	HTTP、HTTPS、SOCKS、FTP、RTSP等|

注：不同的VPN 或代理协议会给用户带来不同的安全，隐私和速度体验。此处就不详说了

### 流程区别
因为协议引出了 VPN 和代理两者的工作流程区别，为了方便普通用户理解，我们将以流程图的方式展示它们各自的大致工作流程。

![](https://raw.githubusercontent.com/NaisWang/images/master/20220409130834.png)

VPN：VPN 需要登录客户端来获取使用许可。然后，VPN 服务通过隧道协议分别在用户端和 VPN 服务器之间以及VPN 服务器和目标网络地址之间建立隧道，对流量进行加密传输，从而达到不可穿透的效果。
代理 / Proxy：代理跟 VPN 类似，中间会有一个代理服务器（Proxy Server）的存在。但是用户不用安装客户端，可直接通过在浏览器或具体 app 内进行代理地址和端口设置来创建连接到代理服务器。连接成功后，代理服务器就会使用代理协议来对目标网络地址或者服务器资源进行连接请求。

![](https://raw.githubusercontent.com/NaisWang/images/master/20220409130843.png)

VPN与代理复杂性对比结果：VPN 比代理工作流程更复杂，但对于用户来说更易用，不用进行参数配置，使用客户端登录即可。

### 安全 & 隐私区别
VPN：VPN 具有很高的安全性，因为它不仅可以给你分配 IP 地址轻松匿名，还会采用加密技术（如军攻级AES-256/128 和ECC加密）保护所有流量和数据，任何诸如机构、政府、广告商、网络服务商、黑客这样的的第三方均无法对你的真实数据进行采集。VPN 服务商一般也会采取零日志政策，不会去主动搜集贩卖用户信息。（当然免费 VPN 就不一定了，它可能会记录日志或者推送广告，所以一般不建议使用免费 VPN。）

代理/ Proxy：代理的最大用处是回避过滤，突破上级对网站的屏蔽。上面我们列出了代理协议中， HTTP 代理，HTTPS代理和 SOCKS 代理这三种是主要用来访问网页的，安全性和价格依次递增。虽然在代理的整个过程也隐藏了使用者的真实 IP，但是由于使用代理类型和协议的不同，你的行为数据不仅不会被加密保护，还会被代理商保存为日志，潜在安全风险很高，因为你的网络行为依然能像往常一样被政府等机构监管，重要私人信息依然可能被网络犯罪分子轻易获取。另外，部分代理还会展示自己的广告，相当影响用户体验。

VPN与代理安全/隐私性对比结果：VPN 比代理更安全，更能保证隐私。如果一定要使用代理，建议使用安全匿名系数最高的SOCKS5代理。

### 速度区别
VPN：VPN 的速度不好一概而论，因为它会受 VPN 协议、协议加密等级、VPN 服务器位置/负载/带宽、本地网络服务提供商（ISP）的 网络情况等因素的影响。简单来说，加密等级越低、距离VPN 服务器地址越近、服务器负载越小、服务器和本地网络宽带越充裕，VPN 访问速度越快，反之亦然。

代理：跟 VPN 一样，代理的快慢也会受协议、距离、服务器性能、实际负载和本地网络情况的影响。但由于代理跟 VPN 不一样，并未进行复杂的加密处理和隧道保护，只是对源流量进行转发，其速度理论上说是要比 VPN 快的。而且，一般代理服务器都会有缓冲区（Cache）来对已请求的信息内容进行存储记忆，当再有用户访问同样的信息时，可以直接从缓冲区中将信息传给用户，进而提高访问速度。

VPN与代理速度对比结果：在同样的外部环境和使用条件下，单从速度来说，代理比 VPN 更快。

### VPN与代理对比总结
1、VPN 和代理相比，谁更好？
毫无疑问，VPN 比代理更好。
首先，VPN 不仅具有代理的所有功能 – 实现匿名和突破地理访问限制，还会对数据进行强加密，防止被监管、窥视和二次利用。其次，高质量的消费级 VPN 软件服务商支持多种 VPN协议（包括代理协议），一般会在全球范围内分国家、地区和具体用途提供数千个服务器节点供用户选择，灵活度高。最后，很多 VPN 还会同步内置很多实用功能，比如测速工具，IP 地址检测工具，网络终止开关工具（又叫 Kill Switch），广告屏蔽工具等，可谓是“一具多用”。

2、VPN 和代理相比，我应该选谁？
无标准答案，按需选择即可。
虽然 VPN无论从易用性和安全性来说都是优于代理的，但是从以上对比可以看出，代理的速度还是占有一席优势。这里给出的建议是：如果你对数据保护需求不大，只为了隐藏真实 IP 或者绕过一些诸如图书馆、学校、公司和国家地区设置的网络“墙”，进行快速翻墙上网，代理是可以作为首选的。如果你的工作或者生活需要一个稳定且可靠的翻墙工具保护你的在线数据，付费的优质 VPN 则是不二之选，比如熊猫VPN。

### 什么时候应该使用VPN？
总的来说我更推荐你使用VPN，因为VPN不仅能用来翻墙，并且还提供很好的安全匿名保护，并且使用简单，这些情况你应该使用VPN：
- 翻墙看视频
利用VPN的虚拟隧道技术，在连接上VPN服务器之后，播放音视频会比代理更加稳定。

- 保持完全匿名
如果你想在网上保持匿名和隐私安全，那么使用VPN是个不错的选择。大多数VPN提供商都有严格的无日志记录政策，这意味着它们不仅会隐藏你的IP地址，而且也没有将其存储，这使得没人能追溯到你的网络活动数据。

- 访问受地理限制的内容
使用VPN绕过地理限制要简单得多。由于VPN在全球分布有各种各样的服务器，因此你可以轻松地连接到一台服务器，这将帮助你绕过地区版权限制，很多海外华人就是利用VPN翻墙回国听歌刷剧。

- 全局翻墙
VPN不仅可以用于浏览器翻墙，而是可以将你电脑或手机上的所有应用翻墙。由于你的计算机上安装了VPN，因此网络上的任何活动都将通过VPN转发。这包括下载和上传文件，安装更新等。
另外，即使在不稳定的条件下，你也将得到保护。假设你使用的是弱连接的公共Wi-Fi网络。即使连接断开，VPN仍将继续为你提供保护。另外，如果有人要拦截该连接，由于高度的加密，他们获得的任何信息都不可能被破解。

- 用于种子下载
大多数ISP如果检测到用户利用VPN进行种子下载，他们可能会将其限速。通过分析你的连接发送的数据包，它们可以确定你是使用连接进行种子下载还是常规的Web浏览。但是，由于VPN会加密通过连接发送的所有数据，因此它们无法检测你是否正在种子下载。

### 什么时候应该使用代理？
通常，利用代理进行翻墙是主要目的，这些情况下你可能需要用到代理：
- 浏览器翻墙
由于代理的技术原理，使得你可以利用它来进行翻墙，但在电脑上，你只能用在浏览器上翻墙，其他应用程序则需要配置。

- 基本的隐私保护
代理提供基本级别的隐私保护。你的网络流量将通过代理服务器转发，因此你尝试访问的网站将看到代理的IP地址，而不是你的真实IP地址。此过程提供了一些基本的保护。
但是，由于代理服务器通常会记录用户活动日志，因此可以轻松发现你的真实IP地址和其他信息。

- 减少定向广告
也许你正试图摆脱每天看到的广告。如果你使用代理服务器进行常规的网络浏览，则这些广告将不会与你的IP地址绑定，也就无法定向推送给你。

- 访问受地理限制的内容
代理服务器另外一项有用的功能，是它能解锁受地理限制的网站内容。只需启动代理服务器，你就可以快速查看被封锁的站点。但是，当你要访问受地理限制的内容时，你需要使用正确位置的代理服务器。例如，如果你要观看在中国遭到封锁的Netflix系列节目，则需要使用基于美国的代理服务器。
总体而言，代理是一种轻量级的翻墙工具，它没有提供更多附加的功能，而VPN提供的功能则更加完善。

# ping中的TTL详解
以下就是ping曙光博客的返回值：
```
C:\Documents and Settings\user>ping www.ezloo.com
Pinging www.ezloo.com [66.235.202.42] with 32 bytes of data:
Reply from 66.235.202.42: bytes=32 time=254ms TTL=51
Reply from 66.235.202.42: bytes=32 time=256ms TTL=51
Request timed out.
Reply from 66.235.202.42: bytes=32 time=260ms TTL=51

Ping statistics for 66.235.202.42:
Packets: Sent = 4, Received = 3, Lost = 1 (25% loss),
Approximate round trip times in milli-seconds:
Minimum = 254ms, Maximum = 260ms, Average = 256ms
```

从结果中我们可以看出曙光博客的服务器的IP地址是：66.235.202.42，所用的时间是256ms等，那TTL等与51是什么意思呢？

TTL是生存时间的意思，就是说这个ping的数据包能在网络上存在多少时间。当我们对网络上的主机进行ping操作的时候，我们本地机器会发出一个数据包，数据包经过一定数量的路由器传送到目的主机，但是由于很多的原因，一些数据包不能正常传送到目的主机，那如果不给这些数据包一个生存时间的话，这些数据包会一直在网络上传送，导致网络开销的增大。当数据包传送到一个路由器之后，TTL就自动减1，如果减到0了还是没有传送到目的主机，那么就自动丢失。就像上面ping曙光博客的时候第三次那样，出现Request timed out的情况，增加TTL来减少网络资源的消耗。默认情况下，Linux系统的TTL值为64或255，Windows NT/2000/XP系统的TTL值为128，Windows 98系统的TTL值为32，UNIX主机的TTL值为255。（这个是从网络上找到的），曙光博客的目的主机是采用FreeBSD系统的，在这里可能TTL值是64，而不是UNIX主机的255，所以在从我这里到目的主机经过了64-51=13个路由。当我们不知道目的主机的操作系统的时候我们可以根据TTL来猜测，但是不一定100%准确，如果目的主机是windows，但是经过了比如75个路由器，那么TTL的返回值是128-75=53，那么你可能认为这个目的主机是Linux系统，但是一般不会经过那么多的路由器，所以通过TTL来判断目的主机的操作系统还是有一定的依据的。


<font color="red">注： 我们在window系统上使用ping时， 由于window的TTL默认为128, 所以在window上发的数据包可以经过127个路由器， 但是在终端上回显的TTL的值是目的主机上的TTL默认值减去数据包经过的路由器数, 因为目的主机回复数据包中的TTL字段初始值为目的主机的TTL初始值</font>

# VLAN
## VLAN产生的原因
VLAN的产生是为了解决广播域的问题， 由于使用路由器可以隔离广播域， 但是路由器的成本高， 所以产生了VLAN技术
## 交换机实现VLAN

![](https://raw.githubusercontent.com/NaisWang/images/master/20220409130853.png)

VLAN的实现机制： IEEE 802.1Q帧(用来区分数据帧是属于哪个VLAN)、 交换机端口类型(对帧进行打标签成为IEEE 802.1Q帧， 对IEEE 802.1Q帧去标签称为普通帧)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220409130902.png)

## 交换机端口类型
交接接口类型包括： Access、Trunk、Hybrid
端口的缺省VLAN ID:
1. 在思科交换机上称为Native VLAN, 即本征VLAN
2. 在华为交换机上称为PVID(Port VLAN ID),即端口VLAN ID
3. 思科交换机支持Access、Trunk端口
4. 华为交换机支持Access、Trunk、Hybrid端口

**Access**

![](https://raw.githubusercontent.com/NaisWang/images/master/20220409130916.png)

**Trunk**

![](https://raw.githubusercontent.com/NaisWang/images/master/20220409130949.png)

**Hybrid**

hybrid端口是换位交换机所特有的

![](https://raw.githubusercontent.com/NaisWang/images/master/20220409130959.png)


# 开热点访问设备
**情景：**
打开手机热点， 然后电脑连接该热点， 此时电脑如何访问该手机

**方法：**
首先要知道开热点的机器的能与外网访问的网卡地址， 而连接到该热点的机器都能访问到这个网卡地址， 并且也是通过这个网卡来与外网进行通信的
由于是手机开的热点， 所以找到手机本身的ip地址

![](https://raw.githubusercontent.com/NaisWang/images/master/20220409131024.png)

注： 这个地址会在手机重启后发生变换
电脑直接访问该ip地址即可访问手机， 手机也可以通过访问电脑的无线网卡的ip地址来访问电脑


# arp欺骗
ARP 欺骗是一种以 ARP 地址解析协议为基础的一种网络攻击方式, 那么什么是 ARP 地址解析协议: 首先我们要知道, 一台电脑主机要把以太网数据帧发送到同一局域网的另外一台主机, 它的底层是通过 48bit 的 Mac 地址来确定目的接口的, 但是我们在应用层是使用 IP 地址来访问目标主机的, 所以 ARP 的作用就是当一台主机访问一个目标 IP 地址的时候, 它为该主机返回目标 IP 主机的 Mac 地址, 并且这个过程是自动完成的, 应用层的程序是不用关心这件事的.

在讲 ARP 欺骗之前我们先来了解一下正常情况下一台主机是如何通过路由器上网的:

![](https://raw.githubusercontent.com/NaisWang/images/master/20220409131035.png)

如上图, 我们以 A 主机 ping 8.8.8.8 为例:
1. 主机 A 上执行 ping 8.8.8.8
2. 主机 A 准备根据默认路由将数据包发送给 192.168.0.1, 但是最开始的时候主机 A 不知道 192.168.0.1 的 Mac 地址, 所以主机 A 广播一条 ARP Request, 询问 192.168.0.1 的 Mac 地址是什么
3. 路由器收到该 ARP 请求, 发现自己是 192.168.0.1 于是向主机 A 回复一条 ARP Reply, 告诉主机 A 192.168.0.1 的 Mac 地址是 xxxGW.
4. 主机 A 收到该 ARP Reply, 并使用该 Reply 中的 MAC 地址封一个 ICMP Request 包, 然后将包发出去
5. 路由器收到该 ICMP 包, 发现目标 IP 是公网 IP, 便将该包放送到公网, 公网返回 ICMP Reply 给路由器
6. 路由器准备将 ICMP Reply 发送给 192.168.0.100, 但是同第2步, 路由器最开始的时候也不知道 192.168.0.100 的 Mac 地址是多少, 所以路由器会广播一条 ARP Request, 询问 192.168.0.100 的 Mac 地址是什么
7. 主机 A 收到 ARP Request, 发现自己是 192.168.0.100, 于是向路由器回复 ARP Reply, 告诉路由器 192.168.0.100 的 Mac 地址是 xxxA.
8. 路由器收到 ARP Reply, 并使用该 Reply 中的 MAC 地址将第5步收到 ICMP Reply 包重新封包, 并发送出去
9. 主机 A 收到 ICMP Reply

至此, 正常的上网流程结束. 然后对照上面的流程回答下面两个问题:
1. 如果主机 B 无脑的向主机 A 发送 ARP Reply, 告诉 A 192.168.0.1 的 MAC 是 xxxB, 会发生什么?
2. 如果主机 B 无脑的向路由器 GW 发送 ARP Reply, 告诉 GW 192.168.0.100 的 MAC 是 xxxB, 会发生什么?

答案如下图:

![](https://raw.githubusercontent.com/NaisWang/images/master/20220409131046.png)

如果主机 B 做了上面说的两件事的话, 那么主机 A 访问网络的所有数据都会先经过主机 B, 并且回来的数据也都会经过 B, 至此, 整个 ARP 欺骗完成.

## 实战
1. 首先获取当前局域网的网络

![](https://raw.githubusercontent.com/NaisWang/images/master/20220409131057.png)

所以当前网络为192.168.1.0/24

然后使用如下命令来探测当前局域网的主机
```
nmap -sP 192.168.1.0/24
```

![](https://raw.githubusercontent.com/NaisWang/images/master/20220409131121.png)

2. 接下使用主机B来arp欺骗主机A与默认路由
至于实际操作, 在自己的机器上安装一个 arpspoof 工具便可以, Ubuntu 下可以直接使用如下命令安装:
```
apt install dsniff
```

安装好之后先打开 IP 转发(如果为关闭(即填写0)， 则主机A发给主机B的数据不会转发出去， 从而导致主机A无法与外界联系，  注： 关闭主机B的ip转发，对自己访问路由器是没有影响的，依然能访问网络):
```
echo 1 > /proc/sys/net/ipv4/ip_forward
```

然后使用 arpspoof 命令进行欺骗, 命令使用方法如下:
```
arpspoof -i <网卡名> -t <欺骗的目标> <我是谁>
```

比如上面我举得例子, 分别开两个终端:
终端1, 欺骗主机 A 我是网关
```
arpspoof -i eth0 -t 192.168.0.100 192.168.0.1
```

终端2, 欺骗网关我是主机 A
```
arpspoof -i eth0 -t 192.168.0.1 192.168.0.100
```
欺骗成功之后可以通过抓包工具查看主机 A 所有的流量, 这里不再多说.


## 使用arp嗅探来拦截图片
主机B想要拦截主机A的图片，  那么主机B只需要告诉默认路由器我是主机A即可
```
arpspoof -i eth0 -t 192.168.0.1 192.168.0.100
```

然后在终端中输入如下命令即可
```
driftnet -i eth0
```

# 暗网
暗网并不是专门架设的一个独立的互联网，它使用的就是我们正常互联网的传输线路的网络服务器，之所以能隔绝于正常的互联网中而自成一派，就是因为暗网使用的一套费尽心机的工作原理。
在我们日常使用的互联网中，访客通过域名访问一个网站时，访问请求会首先到达域名解析服务器DNS，该服务器会把域名转换为对应的网站ip地址，再发送给访客，然后访客端通过网络上的若干个节点服务器，连接到网站ip地址所在的服务器。这个访问过程，网络上所有的节点服务器都会得知并记录访客信息和网站的ip地址，所以我们的访问过程会在网络上留下印记。

![](https://raw.githubusercontent.com/NaisWang/images/master/20220409131132.png)

而暗网的访问过程则不同，比如暗网中的老大Tor网络，它由全球数前台加入了Tor网络的服务器组成。在Tor网络里如果要访问一个正常的网站，同样由DNS服务器将域名转换为ip地址发送给客户端，当客户端发出连接网站ip的请求时，就会连接到`Tor网络的目录服务器`，这台服务器将访客身份和网站ip等信息加密打包3次并随机选择Tor网络里的3台节点服务器依次解密信息来完成连接。首先目录服务器将打包信息发送给`入口节点`，这台服务器解密最外层的加密信息后，会得知访客身份并和用户端连接，同时还得知需要将剩下的信息发送给`中间节点`，中间节点收到信息后又将最外层解密得知需要连接`入口节点`，并将剩下的信息发送给`汇合点`，而汇合点收到信息后解密得知需要连接中间节点，同时还需要连接网站的ip，然后汇合点通过正常的网络节点连接到网站ip所在的服务器。这个过程中，3台节点服务器都无法完全得知用户信息和网站ip，因此Tor网络的访客访问网站的过程无法追踪。

![](https://raw.githubusercontent.com/NaisWang/images/master/20220409131146.png)

虽然上述过程中，访客被隐藏了，但访客要访问的网站的ip仍然会被正常网络的节点服务器记录到，所以在Tor网络里的网站服务器ip地址也需要被隐藏。方法是当网站建好以后，需要把网站ip等信息发送给Tor网络里的`分布式散列表服务器`，该服务器就会启用3个节点服务器准备连接，同时生成一个以`.onion`结尾的域名，当访客访问到这个域名时，访问请求就会被目录服务器打包加密3次，然后经过3个节点依次解密，最后由汇合点连接到分布式散列表服务器，该服务器将域名对应的ip地址和访问请求进行三层加密，发送给网站`出口节点服务器`	，出口节点解密后，得知需要与汇合点连接，并将其余信息发送给网站中间节点，当中间节点收到信息并解密后，得知需要连接出口节点，并将剩下的信息发送给网站入口节点，入口节点解密最后一层信息后，得知需要连接中间节点，同时知道网站的ip地址然后与网站连接，经过一番折腾，访客通过入口节点、中间节点、汇合点、网站出口节点、网站中间节点、网站入口节点一共6台服务器，终于和网站进行了连接。**这个过程只有与访客连接的入口节点知道访客的身份, 只有与网站连接的入口节点知道网站的ip，剩下的节点对网站和访客都一无所知。**

![](https://raw.githubusercontent.com/NaisWang/images/master/20220409131156.png)

其实Tor就是一种代理，不过它比比一般的一重代理要高明得多，它是一种多重代理。用一重代理有一个坏处：如果一重代理本身是恶意的（想象一下你的VPN提供商是恶意的），那么它就可以知道你访问过什么网站。显然，这不能满足我们的“谁都不能知道是我访问了网站”的隐私需求。

# CDN
CDN的全称是Content Delivery Network，即内容分发网络。CDN是构建在现有网络基础之上的智能虚拟网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户**就近**获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN的关键技术主要有内容存储和分发技术。

![](https://raw.githubusercontent.com/NaisWang/images/master/20220409131012.png)

# NAS
NAS（Network Attached Storage：网络附属存储）按字面简单说就是连接在网络上，具备资料存储功能的装置，因此也称为“网络存储器”。它是一种专用数据存储服务器。它以数据为中心，将存储设备与服务器彻底分离，集中管理数据，从而释放带宽、提高性能、降低总拥有成本、保护投资。其成本远远低于使用服务器存储，而效率却远远高于后者。目前国际著名的NAS企业有Netapp、EMC、OUO等

# 带宽与宽带的区别 
带宽是量词，指的是网速的大小，比如1Mbps的意思是一兆比特每秒，这个数值就是指带宽。
宽带是名词，说明网络的传输速率速很高 。宽带的标准各不相同，最初认为128kbps以上带宽的就是宽带，而以下的就是窄带。但现在国内运营商一般提供至少512kbps带宽的宽带服务。也就是说，带宽是一个具体的数值，而宽带则是满足一定带宽数值的一种传输标准(服务)。


# 上行带宽和下行带宽

![](https://raw.githubusercontent.com/NaisWang/images/master/20220115225919.png)

常用带宽传输，分为上行、下行宽带，也就是常说的“上传”和“下载”。那么上行宽带和下行宽带是什么？

![](https://raw.githubusercontent.com/NaisWang/images/master/20211224165851.png)


## 对于用户来说 
对于用户来说，上行带宽即上行速率一般是指从你的电脑上传的速度，别人从你的电脑进行通讯的速率。下行带宽即下行速率是指网络向用户电脑发送信息时的传输速率，从网上下载文件，影响下载速度的就是“下行速率”。

上行宽带(速度)和下行宽带(速度)是不对称的，一般是下行速度大于上行的速度。我们平时所使用的宽带说多少M，都是指的下行宽带，因为我们上网主要是从互联网上下载数据，而上传的数据量要少很多。

## 对于服务器来说
而对于服务器而言，上行宽带即上传数据速率，就是服务器对外发送数据所占用的带宽速率。服务器作为服务终端。很多文件、网站图片，等放在服务器上。当用户打开服务器上的网站，获取网站源文件、网站图片等，其实就是服务器对外发送数据的一个过程。所以，在服务器上放网站，做代理等，使用的都是上行带宽。

下行宽带即下载数据速率，就是服务器从外部下载文件，服务器打开其他网站，所使用的带宽速度。服务器本机，从外部下载文件，下载软件，是使用下行带宽。

客户端下载资源消耗的是服务器的上行流量，客户端上传资源消耗的是服务器的下行流量。

一般买的带宽指的是上行带宽，下行通常是不限的。而且流量的计算一般都是以上行的来计算的。所以，客户端上传资源，对服务器的带宽基本没有影响，因为服务器的下行基本不限的，跟客户端本身网络的带宽有影响；而客户端下载资源，除了跟服务器的带宽有影响，跟客户端本身的网络带宽也有影响的。可以联想到百度网盘的上传与下载

# 前端路由与后端路由
## 什么是路由
路由是根据不同的 url 地址展示不同的内容或页面；

## 什么是前端路由？
很重要的一点是页面不刷新，前端路由就是把不同路由对应不同的内容或页面的任务交给前端来做，每跳转到不同的URL都是使用前端的锚点路由。随着（SPA）单页应用的不断普及，前后端开发分离，目前项目基本都使用前端路由，在项目使用期间页面不会重新加载。

优点：
- 用户体验好，和后台网速没有关系，不需要每次都从服务器全部获取，快速展现给用户
- 可以再浏览器中输入指定想要访问的url路径地址。
- 实现了前后端的分离，方便开发。有很多框架都带有路由功能模块。

缺点:
- 使用浏览器的前进，后退键的时候会重新发送请求，没有合理地利用缓存
- 单页面无法记住之前滚动的位置，无法在前进，后退的时候记住滚动的位置

### 主要实现方式
在单页面web网页中, 单纯的浏览器地址改变, 网页不会重载，如单纯的hash网址改变网页不会变化，因此我们的路由主要是通过监听事件，并利用js实现动态改变网页内容，有两种实现方式：
- `hash模式`：监听浏览器地址hash值变化，执行相应的js切换网页；
- `history模式`：利用history API实现url地址改变，网页内容改变；
它们的区别最明显的就是hash会在浏览器地址后面增加#号，而history可以自定义地址。

#### hash模式
使用window.location.hash属性及窗口的onhashchange事件，可以实现监听浏览器地址hash值变化，执行相应的js切换网页。下面具体介绍几个使用过程中必须理解的要点：
- hash指的是地址中#号以及后面的字符，也称为散列值。hash也称作锚点，本身是用来做页面跳转定位的。如`http://localhost/index.html#abc`，这里的#abc就是hash；
- 散列值是不会随请求发送到服务器端的，所以改变hash，不会重新加载页面；
- 监听 window 的 hashchange 事件，当散列值改变时，可以通过 location.hash 来获取和设置hash值；
- location.hash值的变化会直接反应到浏览器地址栏；

**触发hashchange事件的几种情况：**
- 浏览器地址栏散列值的变化（包括浏览器的前进、后退）会触发window.location.hash值的变化，从而触发onhashchange事件；
- 当浏览器地址栏中URL包含哈希如`http://www.baidu.com/#home`，这时按下输入，浏览器发送`http://www.baidu.com/`请求至服务器，请求完毕之后设置散列值为#home，进而触发onhashchange事件；
- 当只改变浏览器地址栏URL的哈希部分，这时按下回车，浏览器不会发送任何请求至服务器，这时发生的只是设置散列值新修改的哈希值，并触发onhashchange事件；
- html中`<a>`标签的属性 href 可以设置为页面的元素ID如 #top，当点击该链接时页面跳转至该id元素所在区域，同时浏览器自动设置 window.location.hash 属性，地址栏中的哈希值也会发生改变，并触发onhashchange事件；

```js
//设置 url 的 hash，会在当前url后加上'#abc'
window.location.hash='abc';
let hash = window.location.hash //'#abc'

window.addEventListener('hashchange',function(){
	//监听hash变化，点击浏览器的前进后退会触发
})
```

#### history模式
window.history 属性指向 History 对象，它表示当前窗口的浏览历史。当发生改变时，只会改变页面的路径，不会刷新页面。History 对象保存了当前窗口访问过的所有页面网址。通过 history.length 可以得出当前窗口一共访问过几个网址。由于安全原因，浏览器不允许脚本读取这些地址，但是允许在地址之间导航。浏览器工具栏的“前进”和“后退”按钮，其实就是对 History 对象进行操作。

#### 属性
History 对象主要有两个属性。
- `History.length`：当前窗口访问过的网址数量（包括当前网页）
- `History.state`：History 堆栈最上层的状态值（详见下文）
```js
// 当前窗口访问过多少个网页
history.length // 1

// History 对象的当前状态
// 通常是 undefined，即未设置
history.state // undefined
```

#### 方法
History.back()、History.forward()、History.go()这三个方法用于在历史之中移动。
- `History.back()`：移动到上一个网址，等同于点击浏览器的后退键。对于第一个访问的网址，该方法无效果。
- `History.forward()`：移动到下一个网址，等同于点击浏览器的前进键。对于最后一个访问的网址，该方法无效果。
- `History.go()`：接受一个整数作为参数，以当前网址为基准，移动到参数指定的网址。如果参数超过实际存在的网址范围，该方法无效果；如果不指定参数，默认参数为0，相当于刷新当前页面。
```js
history.back();
history.forward();
history.go(1);//相当于history.forward()
history.go(-1);//相当于history.back()
history.go(0); // 刷新当前页面
```

<font color="red">注意：移动到以前访问过的页面时，页面通常是从浏览器缓存之中加载，而不是重新要求服务器发送新的网页。</font>


#### history.pushState 
该方法用于在历史中添加一条记录。pushState()方法不会触发页面刷新，只是导致 History 对象发生变化，地址栏会有变化。语法：`history.pushState(object, title, url)`

该方法接受三个参数，依次为：
- object：是一个对象，通过 pushState 方法可以将该对象内容传递到新页面中。如果不需要这个对象，此处可以填 null。
- title：指标题，几乎没有浏览器支持该参数，传一个空字符串比较安全。
- url：新的网址，必须与当前页面处在同一个域。不指定的话则为当前的路径，如果设置了一个跨域网址，则会报错。
```js
var data = { foo: 'bar' };
history.pushState(data, '', '2.html');
console.log(history.state) // {foo: "bar"}
```
注意：如果 pushState 的 URL 参数设置了一个新的锚点值（即 hash），并不会触发 hashchange 事件。反过来，如果 URL 的锚点值变了，则会在 History 对象创建一条浏览记录。

如果 pushState() 方法设置了一个跨域网址，则会报错。
```js
// 报错
// 当前网址为 http://example.com
history.pushState(null, '', 'https://twitter.com/hello');
```
上面代码中，pushState 想要插入一个跨域的网址，导致报错。这样设计的目的是，防止恶意代码让用户以为他们是在另一个网站上，因为这个方法不会导致页面跳转。

#### history.replaceState
该方法用来修改 History 对象的当前记录，用法与 pushState() 方法一样。

假定当前网页是 example.com/example.html。
```js
history.pushState({page: 1}, '', '?page=1')
// URL 显示为 http://example.com/example.html?page=1

history.pushState({page: 2}, '', '?page=2');
// URL 显示为 http://example.com/example.html?page=2

history.replaceState({page: 3}, '', '?page=3');
// URL 显示为 http://example.com/example.html?page=3

history.back()
// URL 显示为 http://example.com/example.html?page=1

history.back()
// URL 显示为 http://example.com/example.html

history.go(2)
// URL 显示为 http://example.com/example.html?page=3
```

#### popstate 事件
每当 history 对象出现变化时，就会触发 popstate 事件。

注意：仅仅调用pushState()方法或replaceState()方法 ，并不会触发该事件;只有用户点击浏览器倒退按钮和前进按钮，或者使用 JavaScript 调用History.back()、History.forward()、History.go()方法时才会触发。另外，该事件只针对同一个文档，如果浏览历史的切换，导致加载不同的文档，该事件也不会触发。页面第一次加载的时候，浏览器不会触发popstate事件。使用的时候，可以为popstate事件指定回调函数，回调函数的参数是一个 event 事件对象，它的 state 属性指向当前的 state 对象。
```js
window.addEventListener('popstate', function(e) {
	//e.state 相当于 history.state
	console.log('state: ' + JSON.stringify(e.state));
	console.log(history.state);
});
```
点击查看 通过history.pushState 实现页面 tab 切换的功能。

history 致命的缺点就是当改变页面地址后，强制刷新浏览器时，（如果后端没有做准备的话）会报错，因为刷新是拿当前地址去请求服务器的，如果服务器中没有相应的响应，会出现 404 页面。


## 什么是后端路由？
浏览器在地址栏中切换不同的url时，每次都向后台服务器发出请求，服务器响应请求，在后台拼接html文件传给前端显示, 返回不同的页面，意味着浏览器会刷新页面，网速慢的话说不定屏幕全白再有新内容。后端路由的另外一个极大的问题就是 前后端不分离。

优点：
- 分担了前端的压力，html和数据的拼接都是由服务器完成。

缺点：
- 当项目十分庞大时，加大了服务器端的压力，同时在浏览器端不能输入制定的url路径进行指定模块的访问。
- 如果当前网速过慢，那将会延迟页面的加载，对用户体验不是很友好。

# 四种幂等性解决方案

## 什么是幂等性？
`幂等`是一个数学与计算机学概念，在数学中某一元运算为幂等时，其作用在任一元素两次后会和其作用一次的结果相同。

> 在计算机中编程中，一个幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同。

幂等函数或幂等方法是指可以使用相同参数重复执行，并能获得相同结果的函数。这些函数不会影响系统状态，也不用担心重复执行会对系统造成改变。

## 什么是接口幂等性？
在`HTTP/1.1`中，对幂等性进行了定义。**它描述了一次和多次请求某一个资源对于资源本身应该具有同样的结果**（网络超时等问题除外），即第一次请求的时候对资源产生了副作用，但是以后的多次请求都不会再对资源产生副作用。

这里的副作用是不会对结果产生破坏或者产生不可预料的结果。也就是说，其任意多次执行对资源本身所产生的影响均与一次执行的影响相同。

## 为什么需要实现幂等性？
在接口调用时一般情况下都能正常返回信息不会重复提交，不过在遇见以下情况时可以就会出现问题，如：
1. **前端重复提交表单**： 在填写一些表格时候，用户填写完成提交，很多时候会因网络波动没有及时对用户做出提交成功响应，致使用户认为没有成功提交，然后一直点提交按钮，这时就会发生重复提交表单请求。
2. **用户恶意进行刷单**： 例如在实现用户投票这种功能时，如果用户针对一个用户进行重复提交投票，这样会导致接口接收到用户重复提交的投票信息，这样会使投票结果与事实严重不符。
3. **接口超时重复提交**：很多时候 HTTP 客户端工具都默认开启超时重试的机制，尤其是第三方调用接口时候，为了防止网络波动超时等造成的请求失败，都会添加重试机制，导致一个请求提交多次。
4. **消息进行重复消费**： 当使用 MQ 消息中间件时候，如果发生消息中间件出现错误未及时提交消费信息，导致发生重复消费。

> 使用幂等性最大的优势在于使接口保证任何幂等性操作，免去因重试等造成系统产生的未知的问题。

## 引入幂等性后对系统有什么影响？
幂等性是为了简化客户端逻辑处理，能放置重复提交等操作，但却增加了服务端的逻辑复杂性和成本，其主要是：
1. 把并行执行的功能改为串行执行，降低了执行效率。
2. 增加了额外控制幂等的业务逻辑，复杂化了业务功能；

所以在使用时候需要考虑是否引入幂等性的必要性，根据实际业务场景具体分析，除了业务上的特殊要求外，一般情况下不需要引入的接口幂等性。

## 方案一：数据库唯一主键如何实现幂等性？
数据库`唯一主键`的实现主要是利用数据库中主键唯一约束的特性，一般来说唯一主键比较适用于“插入”时的幂等性，其能保证一张表中只能存在一条带该唯一主键的记录。

使用数据库唯一主键完成幂等性时需要注意的是，该主键一般来说并不是使用数据库中自增主键，而是使用分布式 ID 充当主键，这样才能能保证在分布式环境下 ID 的全局唯一性。

### 适用操作
- 插入操作
- 删除操作

### 使用限制
- 需要生成全局唯一主键 ID；

### 主要流程
主要流程如下：
1. 客户端执行创建请求，调用服务端接口。
2. 服务端执行业务逻辑，生成一个分布式 ID，将该 ID 充当待插入数据的主键，然

后执数据插入操作，运行对应的 SQL 语句。
3. 服务端将该条数据插入数据库中，如果插入成功则表示没有重复调用接口。如果抛出主键重复异常，则表示数据库中已经存在该条记录，返回错误信息到客户端。

## 方案二：数据库乐观锁如何实现幂等性？
数据库乐观锁方案一般只能适用于执行`更新操作`的过程，我们可以提前在对应的数据表中多添加一个字段，充当当前数据的版本标识。

这样每次对该数据库该表的这条数据执行更新时，都会将该版本标识作为一个条件，值为上次待更新数据中的版本标识的值。

### 适用操作
- 更新操作

### 使用限制
- 需要数据库对应业务表中添加额外字段

### 描述示例

例如，存在如下的数据表中：

为了每次执行更新时防止重复更新，确定更新的一定是要更新的内容，我们通常都会添加一个`version`字段记录当前的记录版本，这样在更新时候将该值带上，那么只要执行更新操作就能确定一定更新的是某个对应版本下的信息。

这样每次执行更新时候，都要指定要更新的版本号，如下操作就能准确更新`version=5`的信息：
```sql
UPDATE my_table SET price=price+50,version=version+1 WHERE id=1 AND version=5
```
上面`WHERE` 后面跟着条件 `id=1 AND version=5` 被执行后，`id=1` 的 `version` 被更新为 `6`，所以如果重复执行该条 SQL 语句将不生效，因为 `id=1 AND version=5` 的数据已经不存在，这样就能保住更新的幂等，多次更新对结果不会产生影响。

## 方案三：防重 Token 令牌如何实现幂等性？
针对客户端连续点击或者调用方的超时重试等情况，例如提交订单，此种操作就可以用 `Token` 的机制实现防止重复提交。

简单的说就是调用方在调用接口的时候先向后端请求一个全局 `ID（Token）`，请求的时候携带这个全局 `ID` 一起请求（`Token` 最好将其放到 `Headers` 中），后端需要对这个 `Token` 作为 `Key`，用户信息作为 `Value` 到 `Redis` 中进行键值内容校验，如果 `Key` 存在且 `Value` 匹配就执行删除命令，然后正常执行后面的业务逻辑。如果不存在对应的 `Key` 或 `Value` 不匹配就返回重复执行的错误信息，这样来保证幂等操作。

### 适用操作
- 插入操作
- 更新操作
- 删除操作

### 使用限制
- 需要生成全局唯一 `Token`串
- 需要使用第三方组件 `Redis` 进行数据效验

### 主要流程：
1. 服务端提供获取 Token 的接口，该 Token 可以是一个序列号，也可以是一个分布式 ID 或者 UUID 串。
2. 客户端调用接口获取 Token，这时候服务端会生成一个 Token 串。
3. 然后将该串存入 Redis 数据库中，以该 Token 作为 Redis 的键（注意设置过期时间）。
4. 将 Token 返回到客户端，客户端拿到后应存到表单隐藏域中。
5. 客户端在执行提交表单时，把 Token 存入到 Headers 中，执行业务请求带上该 Headers。
6. 服务端接收到请求后从 Headers 中拿到 Token，然后根据 Token 到 Redis 中查找该 key 是否存在。
7. 服务端根据 Redis 中是否存该 key 进行判断，如果存在就将该 key 删除，然后正常执行业务逻辑。如果不存在就抛异常，返回重复提交的错误信息。

> 注意，在并发情况下，执行 Redis 查找数据与删除需要保证原子性，否则很可能在并发下无法保证幂等性。其实现方法可以使用分布式锁或者使用 Lua 表达式来注销查询与删除操作。

## 方案四: 下游传递唯一序列号如何实现幂等性？
所谓`请求序列号`，其实就是每次向服务端请求时候附带一个短时间内唯一不重复的序列号，该序列号可以是一个`有序 ID`，也可以是一个`订单号`，一般由下游生成，在调用上游服务端接口时附加该序列号和用于认证的 `ID`。

当上游服务器收到请求信息后拿取该 `序列号` 和下游 `认证ID` 进行组合，形成用于操作 Redis 的 `Key`，然后到 Redis 中查询是否存在对应的 `Key` 的键值对，根据其结果：
1. 如果存在，就说明已经对该下游的该序列号的请求进行了业务处理，这时可以直接响应重复请求的错误信息。
2. 如果不存在，就以该 Key 作为 Redis 的键，以下游关键信息作为存储的值（例如下游商传递的一些业务逻辑信息），将该键值对存储到 Redis 中 ，然后再正常执行对应的业务逻辑即可。

### 适用操作
- 插入操作
- 更新操作
- 删除操作

### 使用限制
- 要求第三方传递唯一序列号；
- 需要使用第三方组件 Redis 进行数据效验；

### 主要流程
1. 下游服务生成分布式`ID` 作为序列号，然后执行请求调用上游接口，并附带`唯一序列号`与请求的`认证凭据ID`。
2. 上游服务进行安全效验，检测下游传递的参数中是否存在`序列号`和`凭据ID`。
3. 上游服务到 Redis 中检测是否存在对应的`序列号`与`认证ID`组成的 `Key`，如果存在就抛出重复执行的异常信息，然后响应下游对应的错误信息。如果不存在就以该`序列号`和`认证ID`组合作为 `Key`，以下游关键信息作为 `Value`，进而存储到 Redis 中，然后正常执行接来来的业务逻辑。

> 上面步骤中插入数据到 Redis 一定要设置过期时间。这样能保证在这个时间范围内，如果重复调用接口，则能够进行判断识别。如果不设置过期时间，很可能导致数据无限量的存入 Redis，致使 Redis 不能正常工作。

## 实现接口幂等示例
这里使用防重 Token 令牌方案，该方案能保证在不同请求动作下的幂等性，实现逻辑可以看上面写的”防重 Token 令牌”方案，接下来写下实现这个逻辑的代码。

### 1. Maven 引入相关依赖
这里使用 Maven 工具管理依赖，这里在 pom.xml 中引入 SpringBoot、Redis、lombok 相关依赖。
```xml
<dependencies>
        <!--springboot web-->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <!--springboot data redis-->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-redis</artifactId>
        </dependency>
        <dependency>
            <groupId>org.apache.commons</groupId>
            <artifactId>commons-pool2</artifactId>
        </dependency>
        <!--lombok-->
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
        </dependency>
    </dependencies>
```
### 2. 配置连接 Redis 的参数
在 application 配置文件中配置连接 Redis 的参数，如下:
```yml
spring:
  redis:
    ssl: false
    host: 127.0.0.1
    port: 6379
    database: 0
    timeout: 1000
    password:
    lettuce:
      pool:
        max-active: 100
        max-wait: -1
        min-idle: 0
        max-idle: 20
```

### 3. 创建与验证 Token 工具类
创建用于操作 Token 相关的 Service 类，里面存在 Token 创建与验证方法，其中：
1. `Token` 创建方法： 使用 `UUID` 工具创建 `Token` 串，设置以 `“idempotent_token:“+“Token串”` 作为 `Key`，以用户信息当成 `Value`，将信息存入 `Redis` 中。
2. `Token` 验证方法： 接收 Token 串参数，加上 Key 前缀形成 Key，再传入 value 值，执行 Lua 表达式（Lua 表达式能保证命令执行的原子性）进行查找对应 Key 与删除操作。执行完成后验证命令的返回结果，如果结果不为空且非0，则验证成功，否则失败。

```java
@Slf4j
@Service
public class TokenUtilService {

    @Autowired
    private StringRedisTemplate redisTemplate;

    /**
     * 存入 Redis 的 Token 键的前缀
     */
    private static final String IDEMPOTENT_TOKEN_PREFIX = "idempotent_token:";

    /**
     * 创建 Token 存入 Redis，并返回该 Token
     *
     * @param value 用于辅助验证的 value 值
     * @return 生成的 Token 串
     */
    public String generateToken(String value) {
        // 实例化生成 ID 工具对象
        String token = UUID.randomUUID().toString();
        // 设置存入 Redis 的 Key
        String key = IDEMPOTENT_TOKEN_PREFIX + token;
        // 存储 Token 到 Redis，且设置过期时间为5分钟
        redisTemplate.opsForValue().set(key, value, 5, TimeUnit.MINUTES);
        // 返回 Token
        return token;
    }

    /**
     * 验证 Token 正确性
     *
     * @param token token 字符串
     * @param value value 存储在Redis中的辅助验证信息
     * @return 验证结果
     */
    public boolean validToken(String token, String value) {
        // 设置 Lua 脚本，其中 KEYS[1] 是 key，KEYS[2] 是 value
        String script = "if redis.call('get', KEYS[1]) == KEYS[2] then return redis.call('del', KEYS[1]) else return 0 end";
        RedisScript<Long> redisScript = new DefaultRedisScript<>(script, Long.class);
        // 根据 Key 前缀拼接 Key
        String key = IDEMPOTENT_TOKEN_PREFIX + token;
        // 执行 Lua 脚本
        Long result = redisTemplate.execute(redisScript, Arrays.asList(key, value));
        // 根据返回结果判断是否成功成功匹配并删除 Redis 键值对，若果结果不为空和0，则验证通过
        if (result != null && result != 0L) {
            log.info("验证 token={},key={},value={} 成功", token, key, value);
            return true;
        }
        log.info("验证 token={},key={},value={} 失败", token, key, value);
        return false;
    }

}
```
### 4、创建测试的 Controller 类
创建用于测试的 Controller 类，里面有获取 Token 与测试接口幂等性的接口，内容如下：

```java
@Slf4j
@RestController
public class TokenController {

    @Autowired
    private TokenUtilService tokenService;

    /**
     * 获取 Token 接口
     *
     * @return Token 串
     */
    @GetMapping("/token")
    public String getToken() {
        // 获取用户信息（这里使用模拟数据）
        // 注：这里存储该内容只是举例，其作用为辅助验证，使其验证逻辑更安全，如这里存储用户信息，其目的为:
        // - 1)、使用"token"验证 Redis 中是否存在对应的 Key
        // - 2)、使用"用户信息"验证 Redis 的 Value 是否匹配。
        String userInfo = "mydlq";
        // 获取 Token 字符串，并返回
        return tokenService.generateToken(userInfo);
    }

    /**
     * 接口幂等性测试接口
     *
     * @param token 幂等 Token 串
     * @return 执行结果
     */
    @PostMapping("/test")
    public String test(@RequestHeader(value = "token") String token) {
        // 获取用户信息（这里使用模拟数据）
        String userInfo = "mydlq";
        // 根据 Token 和与用户相关的信息到 Redis 验证是否存在对应的信息
        boolean result = tokenService.validToken(token, userInfo);
        // 根据验证结果响应不同信息
        return result ? "正常调用" : "重复调用";
    }

}
```
## 最后总结
幂等性是开发当中很常见也很重要的一个需求，尤其是支付、订单等与金钱挂钩的服务，保证接口幂等性尤其重要。在实际开发中，我们需要针对不同的业务场景我们需要灵活的选择幂等性的实现方式：
1. 对于下单等存在唯一主键的，可以使用“`唯一主键方案`”的方式实现。
2. 对于更新订单状态等相关的更新场景操作，使用“`乐观锁方案`”实现更为简单。
3. 对于上下游这种，下游请求上游，上游服务可以使用“`下游传递唯一序列号方案`”更为合理。
4. 类似于`前端重复提交`、`重复下单`、`没有唯一ID号`的场景，可以通过 `Token` 与 `Redis` 配合的“`防重 Token 方案`”实现更为快捷。

上面只是给与一些建议，再次强调一下，实现幂等性需要先理解自身业务需求，根据业务逻辑来实现这样才合理，处理好其中的每一个结点细节，完善整体的业务流程设计，才能更好的保证系统的正常运行。

# Know your public and private IP addresses
You might have used `ifconfig` command on your linux terminal to know different network configurations of your system.

ifconfig command shows hardware address(HWaddr) and network address(inet addr) for Ethernet or your wifi connection.

ifconfig command don’t show your public IP address(if public and private are different). For that purpose, you can simple type in google search : what is my ip address, it will show your public IP address.

On linux terminal, you can use following commands to know your IP addresses:

Public IP :
```shell
curl ifconfig.me
      or 
curl ipinfo.io/ip
```

Private IP :
```
hostname -I
```

# Chrome之Network控制面板
<div class="contianer">
  <iframe src="https://drive.google.com/file/d/1XmzN9qBr2c3khKRGgoQ2Xr4ncRbqklKb/preview" width="640" height="480" allow="autoplay"></iframe>
</div>

<div class="contianer">
  <iframe width="560" height="315" src="https://www.youtube.com/embed/KVIVvPnHsM8" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>
