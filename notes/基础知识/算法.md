![](https://raw.githubusercontent.com/NaisWang/images/master/20220604110723.png)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220604110827.png)

# 算法入门
## 算法的伪码编写
### 分支语句
```
if a = b then
  ...
else
  ...
end if
```

### 循环语句
```
while a != b do
  ...
end while


for i=1 to k do
  ...
end for
```

### 集合表示
```
a = {v}
b = a - {i};
c = a + {i};
```

### 方法
```
function a(s, x)
  ...
end fun
```

## 命名习惯
- `res`: 局部使用
- `ans`: 全局使用
- `r` : 行
- `c` : 列
- `nr` : 下一行
- `nc` : 下一列
- `cnt` : 计数

## 算法常用技巧
### 子序列、子数组、子串区别
- 子序列 是不要求连续的
- 子数组和子串一样，是需要连续的

### 循环n次
```java
while (n-- != 0) {
  ...
}
```

### 字符串常用技巧
#### 判断字符串中是否只有一种元素
没有什么比较快捷的方式来判断字符串中是否只有一种元素。常用的是下面2中方法。

字符串长度较少时：
```java
if (str[0] == str[1] && str[1] == str[2] && str[2] == str[3] ...) {
  ...
}
```

字符串长度较长时：
```java
for (int i = 0; i < str.length() - 1; i++) {
  if (str[i] != str[i + 1]) {
    // 不只有一个元素
  }
}
```

##### 例题1: 字符串中最大的3位相同数字
[字符串中最大的3位相同数字](https://leetcode.cn/problems/largest-3-same-digit-number-in-string/)

此处判断子字符串是否由唯一一个数字组成的方式可以使用`if(str[0] == str[1] && str[1] == str[2])`来判断

代码：
```java
class Solution {
  public String largestGoodInteger(String num) {
    String ans = "";
    for (int i = 0; i < num.length() - 2; i++) {
      String sub = num.substring(i, i + 3);
      char[] charArray = sub.toCharArray();
      if (charArray[0] == charArray[1] && charArray[1] == charArray[2]) {
        if (ans.equals("") || Integer.parseInt(ans) < Integer.parseInt(sub)) {
          ans = sub;
        }
      }
    }
    return ans;
  }
}
```

#### substring左闭右开
```java
String a = "ab";

// substring为左闭右开
System.out.println(a.substring(0, 1)); //输出a
System.out.println(a.substring(0, 2)); //输出ab
```

#### 获取所有子串
```java
// 假设str的长度的为n，则时间复杂度为O(n^2); 
for (int i = 0; i < str.length(); i++) {
  for (int j = i + 1; j <= str.length(); j++) {
    System.out.println(str.substring(i, j));
  }
}
```

#### 在字符串中间插入/删除字符串
```java
// 方式一
String str = "abcdefg";
str = str.substring(0, 2) + "123" + str.substring(2);
System.out.println(str); // 输出：ab123cdefg
str = str.substring(0, 2) + str.substring(5);
System.out.println(str); // 输出：abcdefg

// 方式二
StringBuffer str = new StringBuffer("abcdefg");
str.insert(2, "123"); 
System.out.println(str); // 输出：ab123cdefg
// 左闭右开
str.delete(2, 5); 
System.out.println(str); // 输出：abcdefg
```

**当插入删除操作次数大时，方式一比方式二耗时地多**。例图下面例图，使用方式一会超时，而使用方式二不会

![](https://raw.githubusercontent.com/NaisWang/images/master/20220605143453.png)

使用方式一的代码：
```java
class TextEditor {
  int cursorIndex = 0;
  String str;

  public TextEditor() {
    str = "";
  }

  public void addText(String text) {
    str = str.substring(0, cursorIndex) + text + str.substring(cursorIndex);
    cursorIndex += text.length();
  }

  public int deleteText(int k) {
    int temp = cursorIndex;
    cursorIndex = cursorIndex - k < 0 ? 0 : cursorIndex - k;
    str = str.substring(0, cursorIndex) + str.substring(temp);
    return Math.min(k, temp);
  }

  public String cursorLeft(int k) {
    cursorIndex -= k;
    if (cursorIndex < 0) {
      cursorIndex = 0;
    }
    int left = cursorIndex - 10 < 0 ? 0 : cursorIndex - 10;
    return str.substring(left, cursorIndex);
  }

  public String cursorRight(int k) {
    cursorIndex += k;
    if (cursorIndex > str.length()) {
      cursorIndex = str.length();
    }
    int left = cursorIndex - 10 < 0 ? 0 : cursorIndex - 10;
    return str.substring(left, cursorIndex);
  }
}
```
上升代码会超时，此时只更改在字符串中间插入/删除字符串的操作为使用StringBuffer时，不会超时，代码如下：

使用方式二：
```java
class TextEditor {
  int cursorIndex = 0;
  StringBuffer str;

  public TextEditor() {
    str = new StringBuffer();
  }

  public void addText(String text) {
    str.insert(cursorIndex, text);
    cursorIndex += text.length();
  }

  public int deleteText(int k) {
    int temp = cursorIndex;
    cursorIndex = cursorIndex - k < 0 ? 0 : cursorIndex - k;
    str.delete(cursorIndex, temp);
    return Math.min(k, temp);
  }

  public String cursorLeft(int k) {
    cursorIndex -= k;
    if (cursorIndex < 0) {
      cursorIndex = 0;
    }
    int left = cursorIndex - 10 < 0 ? 0 : cursorIndex - 10;
    return str.substring(left, cursorIndex);
  }

  public String cursorRight(int k) {
    cursorIndex += k;
    if (cursorIndex > str.length()) {
      cursorIndex = str.length();
    }
    int left = cursorIndex - 10 < 0 ? 0 : cursorIndex - 10;
    return str.substring(left, cursorIndex);
  }
}
```

#### 反转字符串
```java
String reverse = new StringBuffer(string).reverse().toString();
```

### 字符常用操作
#### 判断一个字符的大小写
- `Character.isLowerCase(ch)` 方法用于判断指定字符ch是否为小写字母。
- `Character.isUpperCase(ch)` 方法用于判断指定字符ch是否为大写字母。

#### 字符大小写转换
- `Character.toLowerCase(ch)` 
- `Character.toUpperCase(ch)` 

#### 依次遍历26个字符
```java
for (char ch = 'a'; ch <= 'z'; ch++) {

}
```

##### 例题1: 兼具大小写的最好英文字母
[兼具大小写的最好英文字母](https://leetcode.cn/contest/weekly-contest-298/problems/greatest-english-letter-in-upper-and-lower-case/)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220619212609.png)

代码：
```java
class Solution {
    public String greatestLetter(String s) {
      char[] charArray = s.toCharArray();
      Set<Character> set = new HashSet();
      for (int i = 0; i < charArray.length; i++) {
        set.add(charArray[i]);
      }
      for (char ch = 'Z'; ch >= 'A'; ch--) {
        if (set.contains(ch) && set.contains(Character.toLowerCase(ch))) {
          return ch + "";
        }
      }
      return "";
    }
}
```

### 数字数组常用技巧
#### 多个数字数组判重
假设给你多个数字数组，让你判重。此时有多个方法可以实现，比较常见的是使用`Set<String>`类型。将数字数组转换成能唯一标识的字符串存入`Set<String>`中。

例如现在有`[2, 3]`, `[2, 12]`, `[2, 3]`, `[2, 1, 2]`, `[2]`数组。将这些数组转换能唯一标识的字符串的方式主要如下2种方式：

方式一：使用数组的`toString()`方法, 例如上述数组分别可以转换成`"[2, 3]"`, `"[2, 12]"`, `"[2, 3]"`, `"[2, 1, 2]"`, `"[2]"`

方式二：循环遍历每个元素，在元素后加逗号`,`，然后将其拼接。例如上述数组分别可以转换成`"2,3"`, `"2,12"`, `"2,3"`, `"2,1,2"`, `"2"`

#### 例题1: 含最多 K 个可整除元素的子数组
[含最多 K 个可整除元素的子数组](https://leetcode.cn/problems/k-divisible-elements-subarrays/)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220606223706.png)


##### 分析
分析1: 由于子数组是连续的，所以穷举所有子数组的时间复杂度为O(n^2)，其中n为原数组的长度。这题中的原数组的长度为`1 <= nums.length <= 200`，显然可以使用O(n^2)的时间复杂度来穷举所有子数组

分析2: 由于需要对数组进行去重，所以可以使用`Set<String>`

代码:
```java
public int countDistinct(int[] nums, int k, int p) {
  Set<String> set = new HashSet<>();
  for (int i = 0; i < nums.length; i++) {
    int cnt = 0;
    StringBuffer sb = new StringBuffer();
    for (int j = i; j < nums.length; j++) {
      sb.append(nums[j] + ",");
      if (nums[j] % p == 0) {
        cnt++;
      }
      if (cnt > k) {
        break;
      }
      if (!set.contains(sb)) {
        set.add(sb.toString());
      }
    }
  }
  return set.size();
}
```

#### java中判断2个数组的内容是否相等
使用`Arrays.equals(a, b)`方法
```java
int[] a = {1, 2, 3};
int[] b = {1, 2, 3};
System.out.println(Arrays.equals(a, b));
```

#### 基本类型数组自定义排序
不能使用`Arrays.sort()`方法来对基本类型数组自定义排序，因为Arrays类的自定义排序方法的参数如下：
```java
public static <T> void sort(T[] a, Comparator<? super T> c) {
  ...
}
```
是一个泛型方法，接受`T[]`类型，所以方法无法处理`int`类型数组。如果想要对`int`数组进行自定义排序，可以先将int[]转换为Integer类型数组，再使用Arrays.sort来自定义排序，自定义排序后再将Intege类型数组转换为int类型数组，方法如下：
```java
int[] nums = {3, 1, 2, 3};
Integer[] numsIn = Arrays.stream(nums).boxed().toArray(Integer[]::new);
Arrays.sort(numsIn, (a, b) -> {
    ...
});
nums = Arrays.stream(numsIn).mapToInt(p -> p).toArray();
```
以上步骤可以简便写成如下形式：
```java
int[] nums = {3, 1, 2, 3};
nums = Arrays.stream(nums).boxed().sorted((a, b) -> {
  ...
}).mapToInt(p -> p).toArray();
```

##### 逆序排序数组
```java
Integer[] a = {10, 23, 42, 12, 20, 6};
Arrays.sort(a, Collections.reverseOrder());
```
注意：此方法不适用于`int[]`。对于`int[]`, 没有很简洁的方法来实现逆序排序，比较简洁的方式如下：
```java
nums = Arrays.stream(nums).boxed().sorted((a, b) -> b - a).mapToInt(p -> p).toArray();
```

#### Stream流求数组和
```java
// 基本数组
int[] a = new int[]{2,3,5};
long[] b = new long[]{2,3,5};
System.out.println(Arrays.stream(a).sum());
System.out.println(Arrays.stream(b).sum());

// 引用类型数组
Integer[] a = new Integer[]{2,3,5};
System.out.println(Arrays.stream(a).mapToInt(Integer::intValue).sum());
```

#### 找出数组中最值
使用`int res = Arrays.stream(nums).max().getAsInt()`方法
```java
int[] nums = {1,2,3,2};
int res = Arrays.stream(nums).max().getAsInt();
System.out.println(res); // 3
System.out.println(Arrays.toString(nums)); // [1, 2, 3, 2]
```

#### 判断某个所在行与列是否相等
```java

// 如何判断坐标(2, 3)所在的行与列是否相等。
for (int i = 0; i < 4; i++) {
  if (nums[2][j] != nums[i][3]) {
    // 不相等
    return false;
  }
}
// 相等
return true;
```

##### 例题1：相等行列对
[相等行列对](https://leetcode.cn/problems/equal-row-and-column-pairs/)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220724152035.png)

代码：
```java
class Solution {
  public int equalPairs(int[][] grid) {
    int res = 0;
    for (int i = 0; i < grid.length; i++) {
      for (int j = 0; j < grid.length; j++) {
        boolean flag = true;
        for (int z = 0; z < grid.length; z++) {
          if (grid[i][z] != grid[z][j]) {
            flag = false;
            break;
          }
        }
        if (flag) {
          res++;
        }
      }
    }
    return res;
  }
}
```

### 区间常用技巧
#### 获取区间的mid
获取[left, right]区间的mid下标
```java
// 方式一
int mid = (left + right) / 2;

// 方式二: 可以防止数据溢出
int mid = left + (right - left) / 2;
```

![](https://raw.githubusercontent.com/NaisWang/images/master/20220605135921.png)

### 循环结构的写法技巧
一个循环结构可以分为4个部分：
- 循环变量初始化
- 循环条件
- 循环体
- 循环变量迭代

其中循环体又可以分为2个部分：
- 为当前循环做处理的代码
- 为下一次循环做准备的代码

```java
for (循环变量初始化1; 循环条件2; 循环变量迭代4) {
  循环体3;
}


// 对应while循环

循环变量初始化1;
while (循环条件2) {
  循环体3;
  循环变量迭代4;
}
```

#### 例题1: 螺旋矩阵 IV
[螺旋矩阵 IV](https://leetcode.cn/problems/spiral-matrix-iv/)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220713221751.png)

![](https://raw.githubusercontent.com/NaisWang/images/master/Screen11.jpg)

### 对Map中key的值重新计算的写法技巧
需求：对Map中指定key对应的value值进行重新计算，如果不存在这个key，则添加到Map中。
实现：常用的写法技巧可以分为如下2种
- Map中的value为基本类型: `map.put(key, map.getOrDefault(key, 0) + 1)`
- Map中的value为引用类型: `map.computeIfAbsent`

#### Map中的value为基本类型
使用`map.put(num, map.getOrDefault(num, 0) + 1)`方法。例如统计某个元素出现的次数可以使用`map.put(num, map.getOrDefault(num, 0) + 1)`
```java
Map<Integer, Integer> map = new HashMap<>();
for (int num : nums) {
  map.put(num, map.getOrDefault(num, 0) + 1);
}
```

##### 例题1: 数组能形成多少数对
[数组能形成多少数对](https://leetcode.cn/contest/weekly-contest-302/problems/maximum-number-of-pairs-in-array/)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220717135410.png)

代码：
```java
class Solution {
    public int[] numberOfPairs(int[] nums) {
      Map<Integer, Integer> map = new HashMap<>();
      for (int num : nums) {
        map.put(num, map.getOrDefault(num, 0) + 1);
      }
      int[] res = new int[2];
      for (Integer value : map.values()) {
        res[0] += value / 2; 
        res[1] += value % 2; 
      }
      return res;

    }
}
```

#### Map中的value为引用类型
使用`map.computeIfAbsent`方法，具体该方法的使用，可参考：https://www.runoob.com/java/java-hashmap-computeifabsent.html

##### 例题1: 数位和相等数对的最大和
[数位和相等数对的最大和](https://leetcode.cn/contest/weekly-contest-302/problems/max-sum-of-a-pair-with-equal-sum-of-digits/)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220717154617.png)

代码：
```java
class Solution {
      public int maximumSum(int[] nums) {
      Map<Integer, List<Integer>> map = new HashMap<>();
      for (int num : nums) {
        map.computeIfAbsent(getSum(num), a -> new ArrayList<>()).add(num);
      }
      int res = -1;
      for (List<Integer> value : map.values()) {
        if (value.size() < 2) continue;
        value.sort(Collections.reverseOrder());
        res = Math.max(res, value.get(0) + value.get(1));
      }
      return res;
    }

    int getSum(int num) {
      int res = 0;
      while (num != 0) {
        res += num % 10;
        num = num / 10;
      }
      return res;
    }

}
```

### 模拟C++中的Pair
pair是将2个数据组合成一组数据，当需要这样的需求时就可以使用pair，如stl中的map就是将key和value放在一起来保存。另一个应用是，当一个函数需要返回2个数据的时候，可以选择pair。

在java中可以使用`Map.Entry`来实现Pair效果。例如在实现保留原本的下标进行排序的方法中就使用到了`Map.Entry`

### 保留原本的下标进行排序
#### 方式一：另开数组存储下标
```java
int[] nums = {1, 3, 2, 4, 2, 5};
Integer[] index = new Integer[nums.length];
for (int j = 0; j < index.length; j++) {
  index[j] = j;
}
Arrays.sort(index, (a, b) -> {
  return nums[a] - nums[b];
});
```

#### 方式二：使用Map.Entry
```java
int[] nums = {1, 3, 2, 4, 2, 5};
Map.Entry<Integer, Integer>[] items = new Map.Entry[nums.length];
for (int j = 0; j < nums.length; j++) {
  items[j] = Map.entry(j, nums[j]);
}
Arrays.sort(items, (a, b) -> {
  return a.getValue() - b.getValue();
});
System.out.println(Arrays.toString(items)); // 输出：[0=1, 2=2, 4=2, 1=3, 3=4, 5=5]
```

#### 例题1: 裁剪数字后查询第 K 小的数字
[裁剪数字后查询第 K 小的数字](https://leetcode.cn/contest/weekly-contest-302/problems/query-kth-smallest-trimmed-number/)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220717164034.png)

方式一：另开数组存储下标
```java
class Solution {
    public int[] smallestTrimmedNumbers(String[] nums, int[][] queries) {
      int[] res = new int[queries.length];
      for (int i = 0; i < queries.length; i++) {
        int[] query = queries[i];
        int k = nums[0].length() - query[1];
        Integer[] index = new Integer[nums.length];
        for (int j = 0; j < index.length; j++) {
          index[j] = j;
        }
        Arrays.sort(index, (a, b) -> {
          return nums[a].substring(k).compareTo(nums[b].substring(k));
        });
        res[i] = index[query[0] - 1];
      }
      return res;
    }
}
```

方式二：使用`Map.Entry`
```java
class Solution {
    public int[] smallestTrimmedNumbers(String[] nums, int[][] queries) {
      int[] res = new int[queries.length];
      for (int i = 0; i < queries.length; i++) {
        int[] query = queries[i];
        int k = nums[0].length() - query[1];
        Map.Entry<Integer, String>[] items = new Map.Entry[nums.length];
        for (int j = 0; j < nums.length; j++) {
          items[j] = Map.entry(j, nums[j].substring(k)); 
        }
        Arrays.sort(items, (a, b) -> {
          return a.getValue().compareTo(b.getValue());
        });
        res[i] = items[query[0] - 1].getKey();
      }
      return res;
    }
}
```


## 时间复杂度与数据范围

![](https://raw.githubusercontent.com/NaisWang/images/master/20220414115008.png)

在竞赛中，一般认为计算机一秒能执行$5 ×10^8$次计算，如果题目给出的时间限制为1秒，那么选择的算法执行的计算次数最多应该在$10^8$量级才有可能解决这个题目。
一般情况下：
- $O(n)$的算法能解决的数据范围在 $n≤10^8$
- $O(nlogn)$ 的算法能解决的数据范围在 $n≤10^6$
- $O(n\sqrt{n})$ 的算法能解决的数据范围在 $n≤10^5$
- $O(n^2)$ 的算法能解决的数据范围在 $n≤5000$; $5000^2 = 25000000 ≈ 3 * 10^8 $
- $O(n^3)$ 的算法能解决的数据范围在 $n≤300$; $300^3 = 27000000 ≈ 3 * 10^8 $
- $O(2^n)$ 的算法能解决的数据范围在 $n≤25$; $2^25 = 33554432 ≈ 3 * 10^8$$
- $O(n!)$ 的算法能解决的数据范围在 $n≤11$; $11! = 39916800 ≈ 4 * 10^8$

以上范围仅供参考，实际过程中还要考虑每种算法的常数。


### 渐渐符号

#### Θ符号
$$Θ(g(n)) = {f(n):存在正常量c_1, c_2, 和n_0，使得对所有n \geq n_0, 有0 \leq c_1g(n) \leq f(n) \leq c_2g(n)}$$

若存在正常量$c_1和c_2$，使得对于足够大的n，函数f(n)能“夹入”$c_1g(n)与c_2g(n)$之间，则f(n)属于集合Θ(g(n))。因为Θ(g(n))是一个集合，所以可以记“$f(n) \in Θ(g(n))$”，以指出f(n)是Θ(g(n))的成员。作为替代，我们通常记“f(n) = Θ(g(n))”以表达相同的概念。

#### O符号
$$O(g(n)) = {f(n):存在正常量c, 和n_0，使得对所有n \geq n_0, 有0 \leq f(n) \leq cg(n)}$$

#### Ω符号
$$Ω(g(n)) = {f(n):存在正常量c, 和n_0，使得对所有n \geq n_0, 有0 \leq cg(n) \leq f(n)}$$

![](https://raw.githubusercontent.com/NaisWang/images/master/20220119104219.png)

#### o符号
由于O符号提供的渐进上界可能是也可能不是渐近紧确的。界$2n^2=O(n^2)$是渐近紧确的,但是$2n=O(n^2)$却不是。我们使用o符号来表示一个非渐近紧确的上界。

$$o(g(n)) = {f(n):对任意正常量c, 和n_0，使得对所有n \geq n_0, 有0 \leq f(n) < cg(n)}$$

例如：$2n=o(n^2), 但是2n^2 \not= o(n^2)$

#### ω符号
ω符号与Ω符号的关系类似于o符号与O符号的关系。我们使用ω符号来表示一个非渐近紧确的下界。

$$ω(g(n)) = {f(n):对任意正常量c, 和n_0，使得对所有n \geq n_0, 有0 \leq cg(n) < f(n)}\\\$$

### 主方法

<div class="container">
  <iframe src="https://docs.google.com/document/d/e/2PACX-1vROjB7rSJrDTeE8SPvqcjH0x7q0Z0NOSDotAduN8ihLBAUVaGdacHq-Z9ToHB4HQLOpgSzTPq0ITzeW/pub?embedded=true"></iframe>
</div>

## 枚举
<div class="container">
  <iframe src="https://drive.google.com/file/d/14BqjQi3YcamJgb1tzUMgj7Ltvv9lKpA4/preview" width="640" height="480" allow="autoplay"></iframe>
</div>

### OpenJudge-NOI/2.1基本算法之枚举-1816：拨钟问题
总时间限制: 1000ms 内存限制: 65536kB

描述

有9个时钟，排成一个`3*3`的矩阵。
```
|-------|    |-------|    |-------|
|       |    |       |    |   |   |
|---O   |    |---O   |    |   O   |
|       |    |       |    |       |
|-------|    |-------|    |-------|
    A            B            C    

|-------|    |-------|    |-------|
|       |    |       |    |       |
|   O   |    |   O   |    |   O   |
|   |   |    |   |   |    |   |   |
|-------|    |-------|    |-------|
    D            E            F    

|-------|    |-------|    |-------|
|       |    |       |    |       |
|   O   |    |   O---|    |   O   |
|   |   |    |       |    |   |   |
|-------|    |-------|    |-------|
    G            H            I    
```
              (图 1)
现在需要用最少的移动，将9个时钟的指针都拨到12点的位置。共允许有9种不同的移动。如下表所示，每个移动会将若干个时钟的指针沿顺时针方向拨动90度。
```
移动    影响的时钟

 1         ABDE
 2         ABC
 3         BCEF
 4         ADG
 5         BDEFH
 6         CFI
 7         DEGH
 8         GHI
 9         EFHI    
```
输入

9个整数，表示各时钟指针的起始位置，相邻两个整数之间用单个空格隔开。其中，0=12点、1=3点、2=6点、3=9点。

输出

输出一个最短的移动序列，使得9个时钟的指针都指向12点。按照移动的序号从小到大输出结果。相邻两个整数之间用单个空格隔开。

样例输入
```
3 3 0 
2 2 2 
2 1 2 
```
样例输出

```
4 5 8 9
```

#### 题解
由题可知，一共有9种不同的移动，那么我们将每一种移动对应于一种操作(operation),简写成op。每种操作都会影响若干个时钟，那么我们将每种操作影响的时钟转换为每个时钟受哪些操作的影响。如下所示：
```
A 1 2 4
B 1 2 3 5
C 2 3 6
D 1 4 5 7
E 1 3 5 7 9
F 3 5 6 9
G 4 7 8
H 5 7 8 9
I 6 8 9
```
又因为每次操作会将若干个时钟转动90度，所以当同一个操作进行4次，其实就是旋转了360度，相当于没有操作。(**一种操作做四次和不做是一样的**)所以每种操作做的次数为：0，1，2，3。一共有9种操作，所以枚举次数为4的9次方，暴力枚举就是一个9重循环。最后用一个变量sum来累加每个时钟被操作后的指向，如果累加完后sum=0，那么说明找到了一个移动序列使得9个时钟的指针都指向12点。但此时我们并不知道找到的是否就是最短的序列，所以还要进行比较取操作次数的最小值。

##### 方法一 暴力枚举
代码如下：
```cpp
#include<iostream>
using namespace std;
int ori[10];
int op[10];
int result[10];
int main()
{
    int sum,min=28,moves;
    for(int i=1; i<10; ++i)
      cin >> ori[i];
    for(op[1]=0; op[1]<4; ++op[1])
      for(op[2]=0; op[2]<4; ++op[2])
        for(op[3]=0; op[3]<4; ++op[3])
          for(op[4]=0; op[4]<4; ++op[4])
            for(op[5]=0; op[5]<4; ++op[5])
              for(op[6]=0; op[6]<4; ++op[6])
                for(op[7]=0; op[7]<4; ++op[7])
                  for(op[8]=0; op[8]<4; ++op[8])
                    for(op[9]=0; op[9]<4; ++op[9])
                    {
                        sum=0;
                        sum+=(ori[1]+op[1]+op[2]+op[4])%4;
                        sum+=(ori[2]+op[1]+op[2]+op[3]+op[5])%4;
                        sum+=(ori[3]+op[2]+op[3]+op[6])%4;
                        sum+=(ori[4]+op[1]+op[4]+op[5]+op[7])%4;
                        sum+=(ori[5]+op[1]+op[3]+op[5]+op[7]+op[9])%4;
                        sum+=(ori[6]+op[3]+op[5]+op[6]+op[9])%4;
                        sum+=(ori[7]+op[4]+op[7]+op[8])%4;
                        sum+=(ori[8]+op[5]+op[7]+op[8]+op[9])%4;
                        sum+=(ori[9]+op[6]+op[8]+op[9])%4;
                        if(sum==0)
                        {   
                            moves=0;
                            for(int i=1; i<10; ++i)
                                moves+=op[i];
                            if(moves<min)
                            {
                                min=moves;
                                for(int i=1; i<10; ++i)
                                    result[i]=op[i];
                            }   
                        }
                    }
    for(int i=1; i<10; ++i)
    {
        while(result[i]--)
        {
            cout << i << " ";
        }
    }
    return 0;
}
```

枚举的核心问题就是：
1. 怎样去枚举？
2. 在答案正确的情况下，怎么减少枚举次数？

所以这道题怎么减少枚举次数呢？

枚举中有一个十分重要的思想—<font color="red">局部思想法</font>，它的基本思路如下：

所以我们来看这道题，看能不能找到一个局部使得枚举的次数减少。不难发现操作1，2，3为一个局部。例如，当我们确定了操作1，2，3的次数以后，得到A,B,C这三个时钟的指针的指向，此时只有操作4能够改变A时钟的的指针方向，使它能指向12点。同理，只有操作5才能够改变B时钟的指针方向，只有操作6才能够改变C时钟的指针方向。那么操作4-6的次数也就确定了。同样，继续往下，现在操作1-6的次数都确定了，只有操作7才能改变D时钟的指针方向，只有操作8才能改变G时钟的指针方向,只有操作9才能改变F时钟的指针方向。

这样操作1-9的次数都被确定了，A,B,C,D,G,F这6个时钟的指针都指向了12点，只有E,H,I这三个时钟指针方向还没有确定。所以剩下只用判断E,H,I这三个时钟的指针指向12点没有，如果都指向了12点，那说明找到了一个序列使得9个时钟的指针都指向了12点。

所以根据局部思想的方法，我们只需对操作1，2，3进行枚举，枚举的次数为4的3次方=64次。

##### 方法二 局部枚举
代码如下：
```cpp
#include<iostream>
using namespace std;
int ori[10];
int op[10];
int result[10];
int main()
{
    int min=28,moves,e,h,i;
    for(int i=1; i<10; ++i)
      cin >> ori[i];
    for(op[1]=0; op[1]<4; ++op[1])
      for(op[2]=0; op[2]<4; ++op[2])
        for(op[3]=0; op[3]<4; ++op[3])
        {
            op[4]=(4-(ori[1]+op[1]+op[2])%4)%4;//确定A
            op[5]=(4-(ori[2]+op[1]+op[2]+op[3])%4)%4;//确定B
            op[6]=(4-(ori[3]+op[2]+op[3])%4)%4;//确定C
            op[7]=(4-(ori[4]+op[1]+op[4]+op[5])%4)%4;//确定D
            op[8]=(4-(ori[7]+op[4]+op[7])%4)%4;//确定G
            op[9]=(4-(ori[6]+op[3]+op[5]+op[6])%4)%4;//确定F
            e=(ori[5]+op[1]+op[3]+op[5]+op[7]+op[9])%4;
            h=(ori[8]+op[5]+op[7]+op[8]+op[9])%4;
            i=(ori[9]+op[6]+op[8]+op[9])%4;
            if((e+h+i)==0)//判断E,H,I这三个时钟指针都指向12点没有
            {
                moves=0;
                for(int i=1; i<10; ++i)
                    moves+=op[i];
                if(moves<min)
                {
                    min=moves;
                    for(int i=1; i<10; ++i)
                        result[i]=op[i];
                }       
            }
        }
    for(int i=1; i<10; ++i)
    {
        while(result[i]--)
        {
            cout << i << " ";
        }
    }
    return 0;               
}
```

### 枚举总结
#### 枚举流程图

![](https://raw.githubusercontent.com/NaisWang/images/master/20220515194653.png)

#### 枚举遍历方法
枚举**由n个节点状态组合搭配而成的集合**，常见有如下4种方法：
- 使用for循环
- 使用进位
- 使用dfs

例如：现在有3个节点，分别是A、B、C。这三个节点都有4个状态，分别是0、1、2、3。现在需要枚举由这3个节点状态组合搭配而成的集合{(i, j, z) | i, j, z∈(0, 1, 2, 3) }。

##### 使用for循环
```java
for (int i = 0; i < 4; i++) {
  for (int j = 0; j < 4; j++) {
    for (int z = 0; z < 4; z++) {
      System.out.println(i + "," + j + "," + z);
    }
  }
}
```

##### 使用进位
```java
// base长度表示节点个数；base的元素表示节点的状态
int[] base = new int[3];

// 4 * 4 * 4 表示集合元素个数
for (int times = 0; times < 4 * 4 * 4; times++) {
  System.out.println(Arrays.toString(base));

  base[0]++;
  int i = 0;
  // 进位操作
  while (base[i] == 4) {
    base[i] = 0;
    i++;
    if (i != 3) {
      base[i]++;
    } else {
      break;
    }
  }
}
```

##### 使用dfs

方式一：
```java
int[] nodes = new int[3];
dfs(nodes, 0);

/**
* nodes：节点集合
* nowNode: 当前节点
*/
public void dfs(int[] nodes, int nowNode) {

  for (int status = 0; status < 4; status++) {
    nodes[nowNode] = status;
    if (nowNode != 2) {
      dfs(nodes, nowNode + 1);
    } else {
      System.out.println(Arrays.toString(nodes));
    }
  }

}
```

方式二:
```java
class Node {

  private String name;
  private int status;

  public Node(String name) {
    this.name = name;
  }

  @Override
  public String toString() {
    return status + "";
  }

}

private Node A = new Node("A");
private Node B = new Node("B");
private Node C = new Node("C");
private Node[] nodes = new Node[]{A, B, C};

/**
* nodeIndex: 节点下标
*/
public void dfs(int nodeIndex) {
  for (int status = 0; status < 4; status++) {
    nodes[nodeIndex].status = status;
    if (nodeIndex != 2) {
      dfs(nodeIndex + 1);
    } else {
      System.out.println(Arrays.toString(nodes));
    }
  }
}
```


# 递归
递归（英语：Recursion），又译为递回, 在数学与计算机科学中，是指在函数的定义中使用函数自身的方法。递归最主要的应用有2个：**搜索&回溯**、**分治法**。所以我们在写递归时，可以先判断该递归是应用在哪个方面，是**搜索&回溯**，还是**分治法**

在讲解递归是如何应用在搜索&回溯与分治法之前，我们需要了解什么是递归树。

## 递归树
由于<font color="red">所有的递归都可以对应到一个**递归树**上，每个节点代表一个栈帧，表示递归函数。</font>

![](https://raw.githubusercontent.com/NaisWang/images/master/20220408161854.png)

1. 按照以上的搜索路线来搜索树时，当节点第一次被碰到时入栈，最后一次碰到时出栈。
   对应以上图：节点的碰到顺序：1->2->3->2->4->2->1->5->6->5->1
          节点的入栈顺序：1->2->3->4->5->6
          节点的出栈顺序：3->4->2->6->5->1
2. 记录每个节点入栈、出栈时的栈帧之间共享的数据， 以及入栈时的形参值，退栈时的返回值
3. 指向子节点的有向边对应着代码中子节点入栈前父节点要执行的代码；指向父节点的有向边对应着代码中子节点出栈后父节点要执行的操作。

<font color="red">所以我们在思考如何使用递归时，只需要搞清3件事：</font>
1. 节点对应的函数
2. 父子节点之间的关系
3. 节点不能生成子节点的情况

如果能搞清上述3件事，就能使用递归

### 题目
使用以上知识点完成下面三个题目，下面三个题目严格遵循上述知识点

#### 递归实现指数型枚举

![](https://raw.githubusercontent.com/NaisWang/images/master/20221201125614.png)

分析：
1. 节点的作用：给定一个数num与一个列表，做2种处理，分别是将这num添加到列表中、不添加到列表中
2. 父子节点之间的关系： 子节点的num比父节点的num大1
3. 节点不能生成子节点的情况: 节点的num等于输入的n

当n=3时对应的递归树如下：

![](https://raw.githubusercontent.com/NaisWang/images/master/20220408161907.png)

代码:
```java
public class Main{

  private static Integer n = null;

  public static void main(String[] args){
    initInput();
    dfs(1, new LinkedList()); 
  }

  public static void initInput(){
    Scanner scan = new Scanner(System.in); 
    n = scan.nextInt();
  }

  public static void dfs(int num, List<Integer> ans){
    if(num == n+1){
      System.out.println(ans.toString().replace("[", "").replace("]", "").replace(",", ""));
      return;
    }
    ans.add(num++);
    dfs(num, ans);
    ans.remove(ans.size()-1);
    dfs(num, ans);
  }
}
```

DFS模版解法代码
```java
public class Main {
  static int n;
  public static void main(String[] args) {
    Scanner scan = new Scanner(System.in);
    n = scan.nextInt();
    dfs(new State(0, new ArrayList()));
  }
  
  public static void dfs(State currentState) {
  
    if (currentState.i == n) {
      System.out.println(currentState.ans.toString().replace("[", "").replace("]", "").replace(",", ""));
      return;
    }
    
    List<State> nextStateList = new ArrayList();
    List<Integer> tempAns = new ArrayList(currentState.ans);
    nextStateList.add(new State(currentState.i + 1, tempAns));
    List<Integer> tempAns1 = new ArrayList(currentState.ans);
    tempAns1.add(currentState.i + 1);
    nextStateList.add(new State(currentState.i + 1, tempAns1));
    
    for (State nextState : nextStateList) {
      dfs(nextState);
    }
  }
  
}

class State {
  int i;
  List<Integer> ans;
  
  public State(int i, List<Integer> ans) {
    this.i = i;
    this.ans = ans;
  }
}
```

#### 递归实现组合型枚举
- [递归实现排列型枚举](https://www.acwing.com/problem/content/96/)

![](https://raw.githubusercontent.com/NaisWang/images/master/20221201125643.png)

分析:
1. 节点的作用：将1～n中为被访问到的数字添加或不添加到答案列表中
2. 父子节点之间的关系：父节点访问了一个数字, 子节点不能再访问这个数字
3. 节点不能生成子节点的情况:  1～n的数全部被访问

当n=3时对应的递归树如下：

![](https://raw.githubusercontent.com/NaisWang/images/master/20220408161919.png)

代码：
```java
public class Main{

  private static Integer n = null;
  private static boolean[] flag = null; 

  public static void main(String[] args){
    initInput();    
    flag = new boolean[n+1];
    dfs(new LinkedList());
  } 

  public static void initInput(){
    Scanner scan = new Scanner(System.in);
    n = scan.nextInt(); 
  }
  
  public static void dfs(List<Integer> ans){
    if(ans.size() == n) {
      System.out.println(ans.toString().replace(",", "").replace("[", "").replace("]", ""));
      return;
    }
    for(int i = 1; i <= n; i++){
      if(!flag[i]){
        flag[i] = true;
        ans.add(i);
        dfs(ans);
        ans.remove(ans.size()-1);
        flag[i] = false;
      }
    }
  }
}
```

DFS模版解法代码
```java
import java.util.*;

public class Main{

  private static Integer n = null;

  public static void main(String[] args){
    initInput();    
    dfs(new State(new boolean[n + 1], new ArrayList()));
  } 

  public static void initInput(){
    Scanner scan = new Scanner(System.in);
    n = scan.nextInt(); 
  }
  
  public static void dfs(State state){
    if (state.ans.size() == n) {
      System.out.println(state.ans.toString().replace("[", "").replace("]", "").replace(",", ""));
      return;
    }
    
    List<State> nextStateList = new ArrayList();
    for (int i = 1; i <= n; i++) {
      if (!state.flag[i]) {
        boolean[] tempFlag = state.flag.clone();
        tempFlag[i] = true;
        List<Integer> tempAns = new ArrayList(state.ans);
        tempAns.add(i);
        State nextState = new State(tempFlag, tempAns);
        nextStateList.add(nextState);
      }
    }
    for (State nextState : nextStateList) {
      dfs(nextState);   
    }
  }
  
}

class State {
  boolean[] flag; 
  List<Integer> ans;
  
  public State(boolean[] flag, List<Integer> ans) {
    this.flag = flag;
    this.ans = ans;
  }
}
```

#### 矩阵中的路径
- [矩阵中的路径](https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/)

![](https://raw.githubusercontent.com/NaisWang/images/master/20221201125728.png)

分析:
1. 节点的作用：判断从当前坐标出发，是否能够找到从index到最后字符的字符串
2. 父子节点之间的关系：子节点的index比父节点大1
3. 节点不能生成子节点的情况: index等于目标字符串的长度

对于输入为board = [["A","B","D"],["B","C","E"],["D","C","E"]], word = "ABDE"时，递归树为：

![](https://raw.githubusercontent.com/NaisWang/images/master/20220408161942.png)

代码：
```java
class Solution{
  private int[] rowDirection = {-1, 1, 0, 0};
  private int[] columnDirection = {0, 0, -1, 1};
  
  public boolean exist(char[][] board, String word){
    for(int i = 0; i < board.length; i++){
      for(int j = 0; j < board[0].length; j++){
        if(board[i][j] == word.charAt(0)){
          char temp = board[i][j];
          board[i][j] = '0';
          if(dfs(board, word, i, j, 1)){
            return true;
          }
          board[i][j] = temp;
        }
      }
    }
    return false;
  } 

  public boolean dfs(char[][] board, String word, int row, int column, int index){
    if(index == word.length()){
      return true;
    }
    for(int i = 0; i < 4; i++){
      int nextRow = row+rowDirection[i];
      int nextColumn = column+columnDirection[i];
      if(nextRow >= 0 && nextRow < board.length && nextColumn >= 0 && nextColumn < board[0].length){
        if(word.charAt(index) == board[nextRow][nextColumn]){
          index++;
          char temp = board[nextRow][nextColumn];
          board[nextRow][nextColumn] = '0';
          if(dfs(board, word, nextRow, nextColumn, index)){
            return true;
          }
          index--; 
          board[nextRow][nextColumn] = temp;
        }
      }
    }
    return false;
  }
}
```

DFS模版解法代码
```java
class Solution {
  char[][] board;
  public boolean exist(char[][] board, String word) {
    this.board = board; 
    for (int r = 0; r < board.length; r++) {
      for (int c = 0; c < board[r].length; c++) {
        if (board[r][c] == word.charAt(0)) {
          boolean[] visited = new boolean[board[r].length * board.length];
          visited[r * board[r].length + c ] = true;
          if (dfs(new State(new int[]{r, c}, word.substring(1), visited))) {
            return true;
          }
        }
      }
    }
    return false;
  }

  public boolean dfs(State state) {
    if (state.word.length() == 0) return true;
    
    int[] dr = {-1, 1, 0, 0}, dc = {0, 0, -1, 1};
    List<State> nextStateList = new ArrayList();
    for (int i = 0; i < 4; i++) {
      int nr = dr[i] + state.cor[0], nc = dc[i] + state.cor[1];
      if (nr >= 0 && nr < board.length && nc >= 0 && nc < board[0].length && !state.visited[nr * board[0].length + nc] && board[nr][nc] == state.word.charAt(0))  {
        boolean[] tempVisited = state.visited.clone();
        tempVisited[nr * board[0].length + nc] = true;
        nextStateList.add(new State(new int[]{nr, nc}, state.word.substring(1), tempVisited));
      } 
    }

    for (State nextSate : nextStateList) {
      if (dfs(nextSate)) {
        return true;
      }
    }
    return false;
  }

  class State {
    String word;
    int[] cor;
    boolean[] visited;

    public State(int[] cor, String word, boolean[] visited) {
      this.cor = cor;
      this.word = word;
      this.visited = visited;
    }
  } 
}
```

## 递归应用
我们前面介绍到递归主要有2个应用，分别是**搜索&回溯**以及**分治法**。在详细讲解是如何应用之前，我们先需要了解搜索&回溯、分治法之间的区别

### 搜索&回溯与分治法之间的区别
#### 分治算法
##### 基本思想
分治法的设计思想是： 将一个难以直接解决的大问题，分割成一些规模较小的**相同**问题，以便各个击破，分而治之 。

在计算机科学中，分治法是一种很重要的算法。字面上的解释是“分而治之”，就是 把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并 。这个技巧是很多高效算法的基础，如排序算法(快速排序，归并排序)，傅立叶变换(快速傅立叶变换)……

任何一个可以用计算机求解的问题所需的计算时间都与其规模有关。问题的规模越小，越容易直接求解，解题所需的计算时间也越少。例如，对于n个元素的排序问题，当n=1时，不需任何计算。n=2时，只要作一次比较即可排好序。n=3时只要作3次比较即可，…。而当n较大时，问题就不那么容易处理了。要想直接解决一个规模较大的问题，有时是相当困难的。

##### 分治法的基本步骤
分治法在每一层递归上都有三个步骤：
- step1 分解：将原问题分解为若干个规模较小, 与原问题形式相同的子问题；
- step2 解决：若子问题规模较小而容易被解决则直接解，否则递归地解各个子问题
- step3 合并：将各个子问题的解合并为原问题的解。

##### 使用分治法的经典案例
- 二分查找
- 归并排序
- 快速排序

> 注意：如果用递归来现实分治法，则递归树上父节点的问题规模一定是要大于子节点的问题规模i的

#### 回溯法
回溯是一种通用的算法，把问题分步解决，在每一步都试验所有的可能，当发现已经找到一种方式或者目前这种方式不可能是结果的时候，退回上一步继续尝试其他可能。很多时候每一步的处理都是一致的，这时候用递归来实现就很自然。回溯有点类似于穷举，但是和穷举不同的是回溯会“剪枝”。

##### 使用回溯法的经典案例
- DFS
- 全排列

#### 隐式图上的DFS算法与分治法中的DFS的区别
隐式图上的DFS算法适用的问题：
- 隐式图上的DFS算法可以用来**模拟一个状态到达目标状态的过程**。
- 状态与状态之间的关系是呈**图形**的

分治法中的DFS适用的问题
- 分治法中的DFS是用来实现分治法的
- 状态与状态之间的关系是呈**树形**的

### 搜索&回溯
有关搜索&回溯的应用可以参考**隐式图上的DFS和BFS算法**、**无向图的连通性之静态图的算法-DFS**章节

### 分治法
有关分治法的应用可以参考**动态规划**章节

## 递归编写技巧
在编写递归时，我们需要知道如下几点：
- **递归节点的状态是什么。**
  - 如果状态很复杂，由多个变量值组成，我们可以定义一个State类来表示状态, 
  - 如果节点状态是由若干个整型变量值组成，则我们可以用**一维**数组来表示State，一维数组的长度就是节点状态的组成部分个数，state[0]表示节点状态第一个组成部分的取值，state[1]表示节点状态第二个组成部分的取值,依次类推下去
- **当前节点的下一个状态有哪些。**
  - 如果能获取一次性获取，则一次性获取，存储在`List<State> nextStateList`变量中。
  - 如果不能一次性，则分开获取。**这种情况只出现在分治法中**。
    - 情况一：一个状态的下一个状态们之间不是独立的，例如第2个状态是什么状态与第1个状态遍历后息息相关，即如果你想要知道第2个状态是什么状态，则你必须要先遍历第1个状态，通过判断第1个状态遍历完后的结果来判断第2个状态是什么状态。
    - 情况二：父状态要根据不同子状态所返回的内容做不同的处理，例如对于子状态1返回的内容要做A处理，对于子状态2返回的内容做B处理。例题：[最长公共子序列](https://leetcode.cn/problems/longest-common-subsequence/), [编辑距离](https://leetcode.cn/problems/edit-distance/)
- **如何处理递归的出口**。递归的出口即当前节点没有下一个状态可以入栈了。
  - 我们一般会在节点入栈后，首先判断该节点是否为出口，如果是，则直接做处理，例如返回内容。
- **判断是否需要记录节点入栈时的一些信息。**如果需要，我们可以定义一个`pushStackInfo`全局变量
  - 1. `Set<State> pushStackInfo`或`Integer[]... pushStackInfo`：用来记录某节点是否入过栈
  - 2. `Map<State, T> pushStackInfo`或`Integer[]... pushStackInfo`：用来记录某节点**入栈时**的一些信息。例如：走了多少步；该节点属于哪个连通分量
  - 如果节点状态使用数组表示的，则pushStackInfo也需要用数组表示，数组的每个下标的取值代表节点状态的某个组成部分的取值，**或者是将数组转化为字符串，用`Map<String, T> pushStackInfo`来表示**
- **判断是否需要记录节点出栈时的一些信息。**如果需要，我们可以定义一个`popStackInfo`全局变量
  - 1. `Map<State, T> popStackInfo`或`Integer[]... popStackInfo`: 用来记录某节点**出栈时**的一些信息。例如：该节点的返回值
  - 如果节点状态使用数组表示的，则popStackInfo也需要用数组表示，数组的每个下标的取值代表节点状态的某个组成部分的取值，**或者是将数组转化为字符串，用`Map<String, T> pushStackInfo`来表示**


下面给出递归的具体应用搜索&回溯以及分治法的代码模版:

### 搜索&回溯
我们上述说过搜索&回溯主要就是**隐式图上的DFS算法**, 即解决的是一个状态能否到达另一个状态等问题

由于图是存在环的。所以我们需要使用pushStackInfo变量记录哪些节点是已入栈的，防止出现循环遍历现象

模版：

**使用类表示节点状态:**
```java
Map<State, T> pushStackInfo = new HashMap();

V dfs(State currentState) {

  // 判断当前节点是否为递归出口，如果是，则做处理。这里目标状态就是一个递归出口
  // 如果当前节点是目标状态
  if (isObjective(currentState)) {
    ...
  }
  
  List<State> nextStateList = getNextStateList();

  for (State nextState : nextStateList) {
    if (!pushStackInfo.containsKey(nextState)) {
      pushStackInfo.put(nextState, ..);
      dfs(nextState);
    }
  }
  
  return ...
}
```

**使用数组表示节点状态:**
```java
Integer[]...  pushStackInfo = new Integer[]...;

V dfs(int[] currentState) {

  // 判断当前节点是否为递归出口，如果是，则做处理。这里目标状态就是一个递归出口
  // 如果当前节点是目标状态
  if (isObjective(currentState)) {
    ...
  }
  
  List<int[]> nextStateList = getNextStateList();

  for (int[] nextState : nextStateList) {
    if (pushStackInfo[nextState[0]]... == null) {
      pushStackInfo[nextState[0]]... = ...
      dfs(nextState);
    }
  }
  
  return ...
}
```

### 分治法
分治法中每个节点之间是树型关系, 由于树是不存在环的，且在分治法中一般不会记录入栈时一些信息，所以一般不会使用visited变量。

模版：

**使用类表示节点状态:**
```java
Map<State, T> popStackInfo = new HashMap();

V dfs(State currentState) {
  if (popStackInfo.containsKey(currentState)) {
    return popStackInfo.get(currentState);
  } 

  ... // 判断当前节点是否为递归出口，如果是，则做处理

  List<State> nextStateList = getNextStateList();

  for (State nextState : nextStateList) {
    dfs(nextState); 
    ... // 拿到nextState节点返回信息作一些处理
  }

  popStackInfo.put(currentState, V);
  return V;
}
```

**使用数组表示节点状态:**
```java
Integer[]... popStackInfo = new Integer[]...;

V dfs(int[] currentState) {
  if (popStackInfo[nextState[0]]... != null) {
    return popStackInfo[nextState[0]];
  }

  ... // 判断当前节点是否为递归出口，如果是，则做处理

  List<int[]> nextStateList = getNextStateList();

  for (int[] nextState : nextStateList) {
    dfs(nextState); 
    ... // 拿到nextState节点返回信息作一些处理
  }
  
  return popStackInfo[nextState[0]]... = V;
}
```

## 优化
在打acm时，使用Map可能会超时，这是我们需要将Map换成数组。下面验证数组与Map之间的性能差距

```java
public class Main1 {
  public static void main(String[] args) {
    System.out.println(test1()); // 280
    System.out.println(test2()); // 454
    System.out.println("------------");
    System.out.println(test3()); // 12
    System.out.println(test4()); // 715
  }

  public static long test1() {
    long startTime = System.currentTimeMillis();
    List<int[]> temp = new ArrayList<>();
    for (int i = 0; i < 10000000; i++) {
      temp.add(new int[]{i, i});
    }
    long endTime = System.currentTimeMillis();
    return endTime - startTime;
  }

  public static long test2() {
    long startTime = System.currentTimeMillis();
    List<Map.Entry<Integer, Integer>> temp = new ArrayList<>();
    for (int i = 0; i < 10000000; i++) {
      temp.add(Map.entry(i, i));
    }
    long endTime = System.currentTimeMillis();
    return endTime - startTime;
  }

  public static long test3() {
    long startTime = System.currentTimeMillis();
    int[] temp = new int[10000000];
    for (int i = 0; i < 10000000; i++) {
      temp[i] = i;
    }
    for (int i = 0; i < 10000000; i++) {
      if (temp[i] == i) {

      }
    }
    long endTime = System.currentTimeMillis();
    return endTime - startTime;
  }

  public static long test4() {
    long startTime = System.currentTimeMillis();
    Map<Integer, Integer> map = new HashMap<>();
    for (int i = 0; i < 10000000; i++) {
      map.put(i, i);
    }
    for (int i = 0; i < 10000000; i++) {
      if (map.get(i) == i) {
      }
    }
    long endTime = System.currentTimeMillis();
    return endTime - startTime;
  }
}
```

我们可以发现使用Map所用的时间要远远大于使用数组。**所以在写递归时，如果节点状态是由若干个整型变量组成，且知道它们的取值范围时，则我们可以用数组来替换map，从而提高速度。**

# 栈与队列
## 栈
### 递归函数转非递归
首先，递归的本质就是函数调用，我们都知道函数调用是依靠栈来完成，调用函数就入栈，函数结束是出栈。

在 Java 代码中可以自定义一个类来模拟一个栈帧，我们模拟的栈帧必须要含有如下基本信息：
- 局部变量表：用于存放方法参数和方法内部定义的局部变量。 可以用`HashMap<String, Object>`类型来存储，key为变量名，value为值
- 方法返回地址: 方法被调用的位置。可以用`int`类型来存储
- 操作数栈: 在此处只有一个作用，就是用来存放被调用者返回的返回值。可以用`Stack<Object>`类型来存储

#### 模版
```java
int dfsBystack(int n) {

  // 定义函数栈
  Stack<Frame> stack = new Stack();

  // 压入main函数的栈帧, 用于接收main函数中调用这个递归函数后的返回值
  stack.push(new Frame(new HashMap())); 

  // 压入当前函数的栈帧
  HashMap<String, Integer> locals = new HashMap(); 
  locals.put("n", n);
  stack.push(new Frame(locals)); 

  // 当函数栈中只有main函数栈帧时，退出循环
  while(stack.size() != 1) {

    // 获取当前函数栈栈顶元素  
    Frame currentFrame = stack.peek();

    // 将代码定位到方法返回地址处执行相应后续代码
    if (currentFrame.flag == 0) {
      ... //
    } else if (currentFrame.flag == 1) {
      ... // 
    } 
    ...
    else {
      ... //
    }

  }

  // 将函数栈中的操作数栈的栈顶元素返回
  return stack.peek().operand.peek();

}

class Frame {
  // 局部变量表
  HashMap<String, Integer> locals; 

  // 方法返回地址
  int flag; 

  // 操作数栈
  Stack<Integer> operand;  
  
  public Frame (HashMap<String, Integer> locals) {
    this.locals = locals;
    flag = 0;
    operand = new Stack();
  }
  
}
```

#### 例子1: 斐波拉契数列
[斐波拉契数列](https://leetcode.cn/problems/fibonacci-number/)

以斐波拉契数列生成为例，典型的递归版本如下
```java
int fibonacci(int n) {
  if (n == 0 || n == 1) {
    return 1;
  } else {
    return fibonacci(n - 1) + fibonacci(n - 2);
  }
}
```

该函数对于到class字节码文件内容如下：
```
 0: iload_0
 1: ifeq          9
 4: iload_0
 5: iconst_1
 6: if_icmpne     11
 9: iconst_1           
10: ireturn
11: iload_0                           // 把第一个局部变量，即n压入操作数栈
12: iconst_1                          // 把1(int型)压入操作数栈
13: isub                              // 将操作数栈栈顶两int类型数弹出进行相减，并将结果压入操作数栈
14: invokestatic  #2                  // Method fibonacci:(I)I ，会把返回值压入操作数栈
17: iload_0                           // 把第一个局部变量，即n压入操作数栈 
18: iconst_2                          // 把2(int型)压入操作数栈
19: isub                              // 将操作数栈栈顶两int类型数弹出进行相减，并将结果压入操作数栈
20: invokestatic  #2                  // Method fibonacci:(I)I, 会把返回值压入操作数栈
23: iadd                              // 将操作数栈栈顶两int类型数弹出并进行相加，并将结果压入操作数栈
24: ireturn                           // 返回操作数栈栈顶元素
```

找到其中的方法调用，标记上flag，即方法返回地址标识
```java
int fibonacci(int n) {
  // flag 0 函数入口
  if (n == 0 || n == 1) {
    return 1;
  } else {
    // 在调用fibonacci(n - 1)后有一个方法返回地址标识，记做flag 1
    // 在调用fibonacci(n - 2)后有一个方法返回地址标识，记做flag 2
    return fibonacci(n - 1) + fibonacci(n - 2);
  }
}
```

代码: 
```
class Solution {
  public int fib(int n) {
    return dfsByStack(n);
  }
  
  int dfsByStack(int n) {
    Stack<Frame> stack = new Stack();
    stack.push(new Frame(new HashMap()));

    HashMap<String, Integer> locals = new HashMap(); 
    locals.put("n", n);
    stack.push(new Frame(locals));

    while(stack.size() != 1) {
      Frame currentFrame = stack.peek();
      // 将代码定位到方法返回地址处
      if (currentFrame.flag == 0) {
        if (currentFrame.locals.get("n") == 0 || currentFrame.locals.get("n") == 1) {
          stack.pop();
          stack.peek().operand.push(currentFrame.locals.get("n"));
        } else {
           locals = new HashMap(); 
           locals.put("n", currentFrame.locals.get("n") - 1);
           Frame nextFrame = new Frame(locals);
           stack.push(nextFrame);
           currentFrame.flag = 1;
        }
      } else if (currentFrame.flag == 1) {
        locals = new HashMap(); 
        locals.put("n", currentFrame.locals.get("n") - 2);
        Frame nextFrame = new Frame(locals);
        stack.push(nextFrame);
        currentFrame.flag = 2;
      } else if (currentFrame.flag == 2) {
        int returnValue = currentFrame.operand.push(currentFrame.operand.pop() + currentFrame.operand.pop());
        stack.pop();
        stack.peek().operand.push(returnValue);
      }
    }

    return stack.peek().operand.peek();
  }

  class Frame {
    HashMap<String, Integer> locals; // 局部变量表
    int flag; // 方法返回地址
    Stack<Integer> operand;  // 操作数栈
    
    public Frame (HashMap<String, Integer> locals) {
      this.locals = locals;
      flag = 0;
      operand = new Stack();
    }
  }
}
```

#### 例子2: 二叉树的中序遍历
[二叉树的中序遍历](https://leetcode.cn/problems/binary-tree-inorder-traversal/)

代码：
```java
class Solution {

  List<Integer> ans = new ArrayList();

  public List<Integer> inorderTraversal(TreeNode root) {
    dfsByStack(root);
    return ans;
  }
  
  void dfsByStack(TreeNode root) {
    Stack<Frame> stack = new Stack();
    stack.push(new Frame(new HashMap()));

    HashMap<String, TreeNode> locals = new HashMap();
    locals.put("root", root);
    stack.push(new Frame(locals));

    while (stack.size() != 1) {
      Frame currentFrame = stack.peek();
      if (currentFrame.flag == 0) {
        if (currentFrame.locals.get("root") == null) {
          stack.pop();
        } else {
          locals = new HashMap();
          locals.put("root", currentFrame.locals.get("root").left);
          stack.push(new Frame(locals));
          currentFrame.flag = 1;
        }
      } else if (currentFrame.flag == 1) {
        ans.add(currentFrame.locals.get("root").val);
        locals = new HashMap();
        locals.put("root", currentFrame.locals.get("root").right);
        stack.push(new Frame(locals));
        currentFrame.flag = 2;
      } else {
        stack.pop();
      }
    }
    
  }

  class Frame {
    HashMap<String, TreeNode> locals;
    int flag;
    
    public Frame (HashMap<String, TreeNode> locals) {
      this.locals = locals;
      flag = 0;
    }
  }
}
```

### 栈在表达式求值中的应用

![](https://raw.githubusercontent.com/NaisWang/images/master/20220524194225.png)

#### 例题1: 逆波兰表达式求值
[逆波兰表达式求值](https://leetcode.cn/problems/evaluate-reverse-polish-notation/)

根据 逆波兰表示法，求表达式的值。

有效的算符包括 `+、-、*、/` 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。

注意 两个整数之间的除法只保留整数部分。

可以保证给定的逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。


示例 1：
```txt
输入：tokens = ["2","1","+","3","*"]
输出：9
解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9
```


```java
class Solution {
  public int evalRPN(String[] tokens) {
    Stack<Integer> operand = new Stack();

    for (String token : tokens) {
      if (token.equals("+")) {
        operand.push(operand.pop() + operand.pop());
      }else if (token.equals("-")) {
        operand.push(-1 * operand.pop() + operand.pop());
      }else if (token.equals("*")) {
        operand.push(operand.pop() * operand.pop());
      }else if (token.equals("/")) {
        operand.push((int)(1.0 / operand.pop() * operand.pop()));
      } else {
        operand.push(Integer.valueOf(token));
      }
    }

    return operand.peek();
  }
}
```

### 用栈实现队列
例题： [用栈实现队列](https://leetcode.cn/problems/implement-queue-using-stacks/)

分析：https://leetcode.cn/problems/implement-queue-using-stacks/solution/yong-zhan-shi-xian-dui-lie-by-leetcode/

代码：
```java
class MyQueue {

  Stack<Integer> stack1; 
  Stack<Integer> stack2;

  public MyQueue() {
    stack1 = new Stack();
    stack2 = new Stack();
  }
  
  public void push(int x) {
    while (!stack1.isEmpty()) {
      stack2.push(stack1.pop());
    }
    stack1.push(x);
    while (!stack2.isEmpty()) {
      stack1.push(stack2.pop());
    }
  }
  
  public int pop() {
    return stack1.pop();
  }
  
  public int peek() {
    return stack1.peek();
  }
  
  public boolean empty() {
    return stack1.isEmpty();
  }
}
```


## 单调栈
单调栈是一种特殊的栈。栈本来就是一种受限的数据结构了，单调栈在此基础上又受限了一次（受限++）。即要往栈中添加数据A时，要先判断添加数据A后，是否影响了单调性，若影响了则弹出栈顶元素，直到插入数据A后不会影响栈的单调性后，再插入数据A。

单调递增栈：栈顶到栈底，元素单调递增
单调递减栈：栈顶到栈底，元素单调递减

比如：
```txt
 \  9  /      \  1  /
 |  7  |      |  3  |
 |  5  |      |  5  |
 |  3  |      |  7  |
 |  2  |      |  9  |
 -------      -------
单调递减栈     单调递增栈
```

### 适用场景一
给一个数组或序列，如果想要知道每个元素的右边第一个比它大（小）的元素是哪个。如果用暴力算法来做的话，复杂度是O(n^2)。而使用单调栈可以将复杂度降到只有O(n); 这是单调栈的主要应用场景。 具体过程如下：

当给一个数组或序列，如果想要知道每个元素的右边第一个比它大（小）的元素是哪个，则我们可以从数组右边界开始往左遍历，将这些元素插入单调递增栈（单调递减栈）中。往单调递增栈（单调递减栈）中插入元素时，可以先需要弹出一些元素，因为要使得元素插入后，依然是单调递增栈（单调递减栈）。在弹出一些元素后，如果此时元素可以插入了，那么此时栈顶元素就是要插入元素的右边第一个比它大（小）的元素。

因为是要知道一个元素A的右边第一个比它大（小）的元素是哪个，所以我们肯定是要先遍历到这个元素A的右边，从而我们是从数组的右边界开始往左遍历。又因为A元素右边第一个比它大（小）的元素B一定是先到栈底，而且元素A插入栈时元素B是没有弹出来的，即后入栈的元素A小于（大于）现入栈的B，所以我们需要维护的是单调递增栈（单调递减栈）

例子：现在有一个数组`[2,1,2,4,3]`, 我先需要知道该数组中的每个元素的左边第一个比它大的元素是哪个? 我们从数组右边界开始往左遍历，维护一个单调递增栈。然后维护一个res数组，这个数组就是存储`[2,1,2,4,3]`数组中的每个元素的左边第一个比它大的元素是哪个。 过程如下：

|第i步|操作|单调栈(栈顶->栈底)|res数组|
|--|--|--|--|
|1|3进栈|3|[0,0,0,0,-1]|
|2|3出栈，4进栈|4|[0,0,0,-1,-1]|
|3|2进栈|2->4|[0,0,4,-1,-1]|
|4|1进栈|1->2->4|[0,2,4,-1,-1]|
|5|1,2出栈，2进栈|2->4|[4,2,4,-1,-1]|

所以最终`res=[4,2,4,-1,-1]`

#### 模版
**获取右边第一个更大元素的元素值**
```java
int[] rightFirstGreater(int[] nums) {
  int[] res = new int[nums.length];
  Stack<Integer> stack = new Stack(); 
  for (int i = nums.length - 1; i >= 0; i--) {
    while (!stack.isEmpty() && nums[i] >= stack.peek()) {
      stack.pop();
    }
    res[i] = stack.isEmpty() ? -1 : stack.peek(); 
    stack.push(nums[i]);
  }
  return res;
}
```

**获取右边第一个更大元素的下标**, 见例题2
```java
int[] rightFirstGreater(int[] nums) {
  int[] res = new int[nums.length];
  Stack<Integer> stack = new Stack();
  for (int i = nums.length - 1; i >= 0; i--) {
    while (!stack.isEmpty() && nums[i] >= nums[stack.peek()]) {
      stack.pop();
    }
    res[i] = stack.isEmpty() ? -1 : stack.peek();
    stack.push(i);
  }
  return res;
}
```

#### 例题1: 下一个更大元素 I
[下一个更大元素 I](https://leetcode.cn/problems/next-greater-element-i/)

nums1 中数字 x 的 下一个更大元素 是指 x 在 nums2 中对应位置 右侧 的 第一个 比 x 大的元素。

给你两个 没有重复元素 的数组 nums1 和 nums2 ，下标从 0 开始计数，其中nums1 是 nums2 的子集。

对于每个 0 <= i < nums1.length ，找出满足 nums1[i] == nums2[j] 的下标 j ，并且在 nums2 确定 nums2[j] 的 下一个更大元素 。如果不存在下一个更大元素，那么本次查询的答案是 -1 。

返回一个长度为 nums1.length 的数组 ans 作为答案，满足 ans[i] 是如上所述的 下一个更大元素 。

示例 1：
```txt
输入：nums1 = [4,1,2], nums2 = [1,3,4,2].
输出：[-1,3,-1]
解释：nums1 中每个值的下一个更大元素如下所述：
- 4 ，用加粗斜体标识，nums2 = [1,3,4,2]。不存在下一个更大元素，所以答案是 -1 。
- 1 ，用加粗斜体标识，nums2 = [1,3,4,2]。下一个更大元素是 3 。
- 2 ，用加粗斜体标识，nums2 = [1,3,4,2]。不存在下一个更大元素，所以答案是 -1 。
```

示例 2：
```txt
输入：nums1 = [2,4], nums2 = [1,2,3,4].
输出：[3,-1]
解释：nums1 中每个值的下一个更大元素如下所述：
- 2 ，用加粗斜体标识，nums2 = [1,2,3,4]。下一个更大元素是 3 。
- 4 ，用加粗斜体标识，nums2 = [1,2,3,4]。不存在下一个更大元素，所以答案是 -1 。
```

代码：
```java
class Solution {
  public int[] nextGreaterElement(int[] nums1, int[] nums2) {
    int[] res = rightFirstGreater(nums2);
    int[] ans = new int[nums1.length];
    for (int i = 0; i < nums1.length; i++) {
      for (int j = 0; j < nums2.length; j++) {
        if (nums1[i] == nums2[j]) {
          ans[i] = res[j];
        }
      }
    }
    return ans;
  }
  
  int[] rightFirstGreater(int[] nums) {
    int[] res = new int[nums.length];
    Stack<Integer> stack = new Stack(); 
    for (int i = nums.length - 1; i >= 0; i--) {
      while (!stack.isEmpty() && nums[i] >= stack.peek()) {
        stack.pop();
      }
      res[i] = stack.isEmpty() ? -1 : stack.peek(); 
      stack.push(nums[i]);
    }
    return res;
  }
}
```

#### 例题2: 每日温度
[每日温度](https://leetcode.cn/problems/daily-temperatures/)

给定一个整数数组 temperatures ，表示每天的温度，返回一个数组 answer ，其中 answer[i] 是指在第 i 天之后，才会有更高的温度。如果气温在这之后都不会升高，请在该位置用 0 来代替。

示例 1:
```java
输入: temperatures = [73,74,75,71,69,72,76,73]
输出: [1,1,4,2,1,1,0,0]
```

代码：
```java
class Solution {
  public int[] dailyTemperatures(int[] temperatures) {
    int[] nextGreaterElement = rightFirstGreater(temperatures); 
    int[] ans = new int[temperatures.length];
    for (int i = 0; i < nextGreaterElement.length; i++) {
      if (nextGreaterElement[i] == -1) {
        ans[i] = 0;
      } else {
        ans[i] = nextGreaterElement[i] - i;
      }
    }
    return ans;
  }

  int[] rightFirstGreater(int[] nums) {
    int[] res = new int[nums.length];
    Stack<Integer> stack = new Stack();
    for (int i = nums.length - 1; i >= 0; i--) {
      while (!stack.isEmpty() && nums[i] >= nums[stack.peek()]) {
        stack.pop();
      }
      res[i] = stack.isEmpty() ? -1 : stack.peek();
      stack.push(i);
    }
    return res;
  }

}
```

#### 例题3: 链表中的下一个更大节点
[链表中的下一个更大节点](https://leetcode.cn/problems/next-greater-node-in-linked-list/)

给定一个长度为 n 的链表 head

对于列表中的每个节点，查找下一个 更大节点 的值。也就是说，对于每个节点，找到它旁边的第一个节点的值，这个节点的值 严格大于 它的值。

返回一个整数数组 answer ，其中 answer[i] 是第 i 个节点( 从1开始 )的下一个更大的节点的值。如果第 i 个节点没有下一个更大的节点，设置 answer[i] = 0 。

代码：
```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
  public int[] nextLargerNodes(ListNode head) {
    List<Integer> numsList = new ArrayList();
    ListNode p = head;
    while (p != null) {
      numsList.add(p.val);
      p = p.next;
    }
    Integer[] nums = numsList.toArray(new Integer[numsList.size()]);
    return rightFirstGreater(nums);
  }

  int[] rightFirstGreater(Integer[] nums) {
    int[] res = new int[nums.length];
    Stack<Integer> stack = new Stack();
    for (int i = nums.length - 1; i >= 0; i--) {
      while (!stack.isEmpty() && nums[i] >= stack.peek()) {
        stack.pop();
      }
      res[i] = stack.isEmpty() ? 0 : stack.peek();
      stack.push(nums[i]);
    }
    return res;
  }
  
}
```

#### 例题4: 接雨水
[接雨水](https://leetcode.cn/problems/trapping-rain-water/)

给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。


##### 分析

<div class="container">
  <iframe width="560" height="315" src="https://www.youtube.com/embed/x9uvA-Rd1vI" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>

![](https://raw.githubusercontent.com/NaisWang/images/master/20220526143029.png)

过程：
- 第2块：左边没有比它高的柱子，跳过
- 第3块：左边第一个比它高的柱子为第2块，高度为1；右边第一个不比它矮的柱子左边第一个比它高的柱子为第2块，高度为1；右边第一个不比它矮的柱子为第4块，高度为2；所以可以积水`（(min(2, 1) - 0) * （4 - 2 - 1））= 1`
- 第4块：左边没有比它高的柱子，跳过
- 第5块：左边第一个比它高的柱子为第4块，高度为2；但是右边存在一个不比它矮的柱子为第7块，且高度相等，所以第5块与第7块的积水范围是同一范围，为了避免重复计算，可以把第5块的积水放在计算第7块的积水上
- 第6块：左边第一个比它高的柱子为第5块，高度为1；右边第一个不比它矮的柱子为第7块，高度为1；所以可以积水`（(min(1, 1) - 0 )* (7 - 5 - 1)） = 1`
- 第7块：左边第一个比它高的柱子为第4块，高度为2；右边第一个不比它矮的柱子为第8块，高度为3；所以可以积水`（(min(2, 3) - 1) * (8 - 4 - 1)） = 3`
- 第8块：左边没有比它高的柱子，跳过
- 第9块：左边第一个比它高的柱子为第8块，高度为3；但是右边存在一个不比它矮的柱子为第11块，且高度相等，所以第9块与第11块的积水范围是同一范围，为了避免重复计算，可以把第9块的积水放在计算第11块的积水上
- 第10块：左边第一个比它的柱子为第9块，高度为2；右边第一个不比它矮的柱子为第11块，高度为2；所以可以积水`（(min(2, 2) - 1) * (11 - 9 - 1)）= 1`
- 第11块：右边不存在一个不比它矮的柱子，跳过

所以一共可以积水：1 + 1 + 3 + 1 = 6

代码：
```java
class Solution {
  public int trap(int[] height) {
    int[] res = rightFirstGreater(height);
    int[] resReverse = leftFirstGreater(height);
    int ans = 0;
    for (int i = 1; i < height.length - 1; i++) {
      if (res[i] != -1 && resReverse[i] != -1 && height[i] != height[res[i]]) {
        ans += (Math.min(height[res[i]], height[resReverse[i]]) - height[i]) * (res[i] - resReverse[i] - 1);
      }
    } 
    return ans;
  }

  int[] leftFirstGreater(int[] nums) {
    Stack<Integer> stack = new Stack();
    int[] res = new int[nums.length];
    for (int i = 0; i < nums.length; i++) {
      while (!stack.isEmpty() && nums[i] >= nums[stack.peek()]) {
        stack.pop(); 
      }
      res[i] = stack.isEmpty() ? -1 : stack.peek();
      stack.push(i);
    }
    return res;
  }

  int[] rightFirstGreater(int[] nums) {
    Stack<Integer> stack = new Stack();
    int[] res = new int[nums.length];
    for (int i = nums.length - 1; i >= 0; i--) {
      while (!stack.isEmpty() && nums[i] > nums[stack.peek()]) {
        stack.pop(); 
      }
      res[i] = stack.isEmpty() ? -1 : stack.peek();
      stack.push(i);
    }
    return res;
  } 

}
```

#### 例题5: 柱状图中最大的矩形
[柱状图中最大的矩形](https://leetcode.cn/problems/largest-rectangle-in-histogram/)

给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。

求在该柱状图中，能够勾勒出来的矩形的最大面积。

示例 1:

![](https://raw.githubusercontent.com/NaisWang/images/master/20220526152849.png)
```txt
输入：heights = [2,1,5,6,2,3]
输出：10
解释：最大的矩形为图中红色区域，面积为 10
```

代码:
```java
class Solution {
  public int largestRectangleArea(int[] heights) {
    int[] leftFirstLess = leftFirstLess(heights);
    int[] rightFirstLess = rightFirstLess(heights);
    int ans = Integer.MIN_VALUE;
    for (int i = 0; i < heights.length; i++) {
      int left = leftFirstLess[i] == -1 ? 0 : leftFirstLess[i] + 1;
      int right = rightFirstLess[i] == -1 ? heights.length - 1 : rightFirstLess[i] - 1;
      int width = right - left + 1; 
      ans = Math.max(ans, width * heights[i]); 
    }
    return ans;
  }

  int[] leftFirstLess(int[] nums) {
    Stack<Integer> stack = new Stack();
    int[] res = new int[nums.length];
    for (int i = 0; i < nums.length; i++) {
      while (!stack.isEmpty() && nums[i] <= nums[stack.peek()]) {
        stack.pop();
      }
      res[i] = stack.isEmpty() ? -1 : stack.peek();
      stack.push(i);
    }
    return res;
  }

  int[] rightFirstLess(int[] nums) {
    Stack<Integer> stack = new Stack();
    int[] res = new int[nums.length];
    for (int i = nums.length - 1; i >= 0; i--) {
      while (!stack.isEmpty() && nums[i] <= nums[stack.peek()]) {
        stack.pop();
      }
      res[i] = stack.isEmpty() ? -1 : stack.peek();
      stack.push(i);
    }
    return res;
  }
  
}
```

### 适用场景二
这种场景用下面几个例题来说明

#### 例题1: 移掉 K 位数字
给你一个以字符串表示的非负整数 num 和一个整数 k ，移除这个数中的 k 位数字，使得剩下的数字最小。请你以字符串形式返回这个最小的数字。

示例 1 ：
```txt
输入：num = "1432219", k = 3
输出："1219"
解释：移除掉三个数字 4, 3, 和 2 形成一个新的最小的数字 1219 。
```

示例 2 ：
```txt
输入：num = "10200", k = 1
输出："200"
解释：移掉首位的 1 剩下的数字为 200. 注意输出不能有任何前导零。
```

##### 分析

视频讲解:
<div class="container">
  <iframe width="560" height="315" src="https://www.youtube.com/embed/qWL2KS_Hxic" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>

```java
class Solution {
  public String removeKdigits(String num, int k) {
    Stack<Character> stack = new Stack();
    char[] numChar = num.toCharArray();
    for (int i = 0; i < numChar.length; i++) {
      while (!stack.isEmpty() && k >  0 && numChar[i] < stack.peek()) {
        stack.pop();
        k--;
      }
      stack.push(numChar[i]);
    }
    while (k != 0) {
      stack.pop();
      k--;
    }
    StringBuffer sb = new StringBuffer();
    while (!stack.isEmpty()) {
      sb.append(stack.pop());
    }
    for (int i = sb.length() - 1; i >= 0; i--) {
      if (sb.charAt(i) == '0') {
        sb.deleteCharAt(i);
      } else {
        break;
      }
    }
    if (sb.length() == 0) {
      return "0";
    }
    return sb.reverse().toString();
  }
}
```

#### 例题2: 去除重复字母
[去除重复字母](https://leetcode.cn/problems/remove-duplicate-letters/)

给你一个字符串 s ，请你去除字符串中重复的字母，使得每个字母只出现一次。需保证 返回结果的字典序最小（要求不能打乱其他字符的相对位置）。

示例 1：
```txt
输入：s = "bcabc"
输出："abc"
```

示例 2：
```txt
输入：s = "cbacdcbc"
输出："acdb"
```

##### 分析
视频讲解:
<div class="container">
  <iframe width="560" height="315" src="https://www.youtube.com/embed/QpZFxXa-hnE" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>

代码：
```java
class Solution {
  public String removeDuplicateLetters(String s) {
    HashMap<Character, Integer> map = new HashMap();
    char[] ch = s.toCharArray();
    for (int i = 0; i < ch.length; i++) {
      if (map.containsKey(ch[i])) {
        map.put(ch[i], map.get(ch[i]) + 1); 
      } else {
        map.put(ch[i], 1);
      }
    }
    Stack<Character> stack = new Stack();
    boolean[] visited = new boolean[26];
    for (int i = 0; i < ch.length; i++) {
      if (visited[ch[i] - 'a']) {
        map.put(ch[i], map.get(ch[i]) - 1);
        continue;
      }
      while (!stack.isEmpty() && map.get(stack.peek()) != 1 && ch[i] < stack.peek()) {
        map.put(stack.peek(), map.get(stack.peek()) - 1);
        visited[stack.peek() - 'a'] = false;
        stack.pop();
      }
      visited[ch[i] - 'a'] = true;
      stack.push(ch[i]);
    }
    
    StringBuffer sb = new StringBuffer();
    while (!stack.isEmpty()) {
      sb.append(stack.pop());
    }
    return sb.reverse().toString();

  }

}
```

## 队列
### 设计循环队列
例题： [设计循环队列](https://leetcode.cn/problems/design-circular-queue/)

设计你的循环队列实现。 循环队列是一种线性数据结构，其操作表现基于 FIFO（先进先出）原则并且队尾被连接在队首之后以形成一个循环。它也被称为“环形缓冲器”。

循环队列的一个好处是我们可以利用这个队列之前用过的空间。在一个普通队列里，一旦一个队列满了，我们就不能插入下一个元素，即使在队列前面仍有空间。但是使用循环队列，我们能使用这些空间去存储新的值。

你的实现应该支持如下操作：
- MyCircularQueue(k): 构造器，设置队列长度为 k 。
- Front: 从队首获取元素。如果队列为空，返回 -1 。
- Rear: 获取队尾元素。如果队列为空，返回 -1 。
- enQueue(value): 向循环队列插入一个元素。如果成功插入则返回真。
- deQueue(): 从循环队列中删除一个元素。如果成功删除则返回真。
- isEmpty(): 检查循环队列是否为空。
- isFull(): 检查循环队列是否已满。

示例：
```txt
MyCircularQueue circularQueue = new MyCircularQueue(3); // 设置长度为 3
circularQueue.enQueue(1);  // 返回 true
circularQueue.enQueue(2);  // 返回 true
circularQueue.enQueue(3);  // 返回 true
circularQueue.enQueue(4);  // 返回 false，队列已满
circularQueue.Rear();  // 返回 3
circularQueue.isFull();  // 返回 true
circularQueue.deQueue();  // 返回 true
circularQueue.enQueue(4);  // 返回 true
circularQueue.Rear();  // 返回 4
```

#### 分析

![](https://raw.githubusercontent.com/NaisWang/images/master/20220526221306.png)

该题难点在于如何设计循环队列初始时front与rear的指向以及如何判断队列为空或满

代码：
```java
class MyCircularQueue {
  Integer[] items;
  int head;
  int tail;
  int k;
  
  public MyCircularQueue(int k) {
    items = new Integer[k];
    head = 0;
    tail = 0;
    this.k = k;
  }
  
  public boolean enQueue(int value) {
    if (isFull()) return false;
    items[tail] = value;
    tail = (tail + 1) % k;
    return true;
  }
  
  public boolean deQueue() {
    if (isEmpty()) return false;
    items[head] = null;
    head = (head + 1) % k;
    return true;
  }
  
  public int Front() {
    if (isEmpty()) {
      return -1;
    }
    return items[head];
  }
  
  public int Rear() {
    if (isEmpty()) {
      return -1;
    }
    return items[(tail - 1 + k) % k]; 
  }
  
  public boolean isEmpty() {
    return head == tail && items[head] == null;
  }
  
  public boolean isFull() {
    return head == tail && items[head] != null;
  }
}
```

### 用队列实现栈
例题：[用队列实现栈](https://leetcode.cn/problems/implement-stack-using-queues/) 

分析：https://leetcode.cn/problems/implement-stack-using-queues/solution/yong-dui-lie-shi-xian-zhan-by-leetcode-solution/

代码：
```java
class MyStack {

  Deque<Integer> deque1;
  Deque<Integer> deque2;

  public MyStack() {
    deque1 = new LinkedList();
    deque2 = new LinkedList();
  }
  
  public void push(int x) {
    if (deque1.isEmpty()) {
      deque1.add(x);
      transfer(deque2, deque1);
    } else {
      deque2.add(x);
      transfer(deque1, deque2);
    }
  }
  
  private void transfer(Deque a, Deque b) {
    while (!a.isEmpty()) {
      b.add(a.poll());
    }
  }
  
  public int pop() {
    if (deque1.isEmpty()) {
      return deque2.poll();
    } 
    return deque1.poll();
  }
  
  public int top() {
    if (deque1.isEmpty()) {
      return deque2.peek();
    } 
    return deque1.peek();
  }
  
  public boolean empty() {
    return deque1.isEmpty() && deque2.isEmpty();
  }
}
```

## 单调队列
<div class="container">
  <iframe src="https://docs.google.com/document/d/e/2PACX-1vTXVQTof9bfXfioACZ9_UyYv4_JREankuTIlwD2Pz60geTts3dxM0aKiwRpkyyU4taXIkCW9gSTQI2O/pub?embedded=true"></iframe>
</div>
### 模版
```java
public int[] maxSlidingWindow(int[] nums, int k) {
  Deque<Integer> deque = new ArrayDeque();
  int[] res = new int[nums.length - k + 1];
  for (int i = 0; i < nums.length; i++) {
    // 窗口标识
    int startWindowIndex = i - k + 1;

    // 左出q，保证窗口大小为k-1
    while (!deque.isEmpty() && i - deque.peekFirst() >= k){
      deque.pollFirst();
    }

    // 右出q，保证为递增队列
    while (!deque.isEmpty() && nums[deque.peekLast()] <= nums[i]) {
      deque.pollLast();
    }

    // 进q，此时q.size == k
    deque.offerLast(i);

    // 此时q队首为此窗口的最大值
    if (startWindowIndex >= 0) res[startWindowIndex] = nums[deque.peekFirst()];
  }
  return res;
}
```

### 例题1: 滑动窗口最大值
[滑动窗口最大值](https://leetcode.cn/problems/sliding-window-maximum/)

给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。

返回 滑动窗口中的最大值 。

示例 1：
```txt
输入：nums = [1,3,-1,-3,5,3,6,7], k = 3
输出：[3,3,5,5,6,7]
解释：
滑动窗口的位置                最大值
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7
```

**代码：**
```java
class Solution {
  public int[] maxSlidingWindow(int[] nums, int k) {
    Deque<Integer> deque = new ArrayDeque();
    int[] res = new int[nums.length - k + 1];
    for (int i = 0; i < nums.length; i++) {
      int startWindowIndex = i - k + 1;
      while (!deque.isEmpty() && i - deque.peekFirst() >= k){
        deque.pollFirst();
      }
      while (!deque.isEmpty() && nums[deque.peekLast()] <= nums[i]) {
        deque.pollLast();
      }
      deque.offerLast(i);
      if (startWindowIndex >= 0) res[startWindowIndex] = nums[deque.peekFirst()];
    }
    return res;
  }
}
```

# 排序

<div class="container">
  <iframe width="560" height="315" src="https://www.youtube.com/embed/dzyD4PS9w9Q" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>

<div class="container">
  <iframe width="560" height="315" src="https://www.youtube.com/embed/itFMGehVi30" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>

<div class="container">
  <iframe width="560" height="315" src="https://www.youtube.com/embed/bxiul-IrPEk" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>

<div class="container">
  <iframe src="https://drive.google.com/file/d/1gPxamLqyi-HClqEg7ca1jqJwNMI08DOZ/preview" width="640" height="480" allow="autoplay"></iframe>
</div>

## 模版
[排序数组](https://leetcode.cn/problems/sort-an-array/)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220718104009.png)

### 冒泡排序
代码：
```java
class Solution {
  public int[] sortArray(int[] nums) {
    bubbleSort(nums);
    return nums;
  }

  void bubbleSort(int[] nums) {
    int n = nums.length;
    for (int i = 0; i < n - 1; i++) {
      for (int j = i + 1; j < n; j++) {
        if (nums[i] > nums[j]) {
          int temp = nums[i];
          nums[i] = nums[j];
          nums[j] = temp;
        }
      }
    }
  }
}
```

### 选择排序
```java
class Solution {
  public int[] sortArray(int[] nums) {
    selectionSort(nums);
    return nums;
  }

  void selectionSort(int[] nums) {
    int n = nums.length;
    for (int i = 0; i < nums.length - 1; i++) {
      int minIndex = i;
      for (int j = i + 1; j < nums.length; j++) {
        if (nums[minIndex] > nums[j]) {
          minIndex = j;
        }
      }
      if (minIndex != i) {
        int temp = nums[i];
        nums[i] = nums[minIndex];
        nums[minIndex] = temp;
      }
    }
  }
  
}
```

### 插入排序
```java
class Solution {
  public int[] sortArray(int[] nums) {
    insertionSort(nums);
    return nums;
  }
  
  void insertionSort(int[] nums) {
    int n = nums.length;
    for (int i = 0; i < n; i++) {
      int temp = nums[i];
      int j = i;
      while (j > 0 && nums[j - 1] > temp) {
        nums[j] = nums[j - 1];
        j--;
      }
      nums[j] = temp;
    }
  }
}
```

### 快速排序
可以使用滑动窗口来实现。移动窗口时，要保证窗口内的元素都是大于或等于pivot元素
```java
class Solution {
  public int[] sortArray(int[] nums) {
    quickSort(nums, 0, nums.length - 1);
    return nums;
  }
  
  int partition(int[] nums, int begin, int end) {
    int left = begin + 1, right = begin + 1;
    while (right <= end) {
      right++;
      if (nums[right - 1] < nums[begin]) {
        int temp = nums[right - 1];
        nums[right - 1] = nums[left];
        nums[left] = temp;

        left++;
      }
    }
    int temp = nums[left - 1];
    nums[left - 1] = nums[begin];
    nums[begin] = temp;

    return left - 1;
  }

  void quickSort(int[] nums, int begin, int end) {
    if (begin >= end) {
      return;
    }
    int p = partition(nums, begin, end);
    quickSort(nums, begin, p - 1); 
    quickSort(nums, p + 1, end); 
  }
}
```

### 归并排序

![](https://raw.githubusercontent.com/NaisWang/images/master/20220718153140.png)

```java
class Solution {
  public int[] sortArray(int[] nums) {
    return mergeSort(nums, 0, nums.length - 1);
  }
  
  int[] mergeSort(int[] nums, int begin, int end) {
    return devide(nums, begin, end);
  }

  int[] devide(int[] nums, int left, int right) {
    if (left >= right) return new int[]{nums[left]};
    int mid = left + (right - left) / 2;
    int[] leftResult = devide(nums, left, mid);
    int[] rightResult = devide(nums, mid + 1, right);
    return merge(leftResult, rightResult);
  }

  int[] merge(int[] left, int[] right) {
    int[] res = new int[left.length + right.length];
    int i = 0, j = 0, k = 0;
    while (i < left.length && j < right.length) {
      if (left[i] <= right[j]) res[k++] = left[i++];
      else res[k++] = right[j++];
    } 
    while (i < left.length) res[k++] = left[i++];
    while (j < right.length) res[k++] = right[j++];
    return res;
  }
}
```

# 搜索
## 二分搜索
视频：
<div class="container">
  <iframe width="560" height="315" src="https://www.youtube.com/embed/Smu6LsYERJg" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>

<div class="container">
  <iframe width="560" height="315" src="https://www.youtube.com/embed/nrBMGE0KtzQ" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>

文字版：https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/solution/lan-hong-hua-fen-fa-dan-mo-ban-miao-sha-e7r40/

二分搜索有两种定义：
- 第一种：在一个有序的数组中折半查找一个数
- 第二种：在一个有序的`boolean function f(v)`中找到转折点
  - 有序的：表示$f(v_i) = true, i <= k 且 f(v_j) = false, j > k$
  - 转折点：假如$f(v_k) = true 且 f(v_(k+1)) = false$, 则$v_k$与$v_(k+1)$为转折点

例如: 假如`f(0)=f(1)=...=f(3)=true,f(4)=f(5)=..=f(7)=false`, 则此时`3`与`4`为转折点

| v    | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 |
|------|---|---|---|---|---|---|---|---|
| f(v) | T | T | T | T | F | F | F | F |

其实二分搜索的第一种定义就是第二种的定义的一种特殊情况

### 二分搜索模版
```java
// 初始化时left为列表的左边界-1，right为列表的右边界+1
int binarySearch(int left, int right) {
  while(left + 1 != right) {
    int mid = left + (right - left) / 2;
    if (f(mid) == true) {
      left = mid;
    } else if (f(mid) == false){
      right = mid;
    }
  }
  return left;
}
```

关键点：
- 无论什么时候，`f(left)`都是为true, `f(right)`都是为false
- 最后返回left还是right，看你是想要获取哪个转折点。据需求而定
- 要进行二分查找时，left的值为列表的左边界-1，right为列表的右边界+1

### 解题流程

![](https://raw.githubusercontent.com/NaisWang/images/master/20220520163540.png)

### 例题
#### 例题1: 猜数字大小
[猜数字大小](https://leetcode.cn/problems/guess-number-higher-or-lower/)

猜数字游戏的规则如下：

每轮游戏，我都会从 1 到 n 随机选择一个数字。 请你猜选出的是哪个数字。
如果你猜错了，我会告诉你，你猜测的数字比我选出的数字是大了还是小了。
你可以通过调用一个预先定义好的接口 int guess(int num) 来获取猜测结果，返回值一共有 3 种可能的情况（-1，1 或 0）：

- -1：我选出的数字比你猜的数字小 pick < num
- 1：我选出的数字比你猜的数字大 pick > num
- 0：我选出的数字和你猜的数字一样。恭喜！你猜对了！pick == num
返回我选出的数字。

示例 1：
```
输入：n = 10, pick = 6
输出：6
```

代码：
```java
/** 
 * Forward declaration of guess API.
 * @param  num   your guess
 * @return 	     -1 if num is lower than the guess number
 *			      1 if num is higher than the guess number
 *               otherwise return 0
 * int guess(int num);
 */
public class Solution extends GuessGame {
  public int guessNumber(int n) {
    return binarySearch(0, (long) n + 1);
  }
  
  int binarySearch(int left,  long right) {
    while((long)left + 1 != right) {
      int mid = left + (int)((right - left) / 2);
      if (guess(mid) == -1) {
        right = mid;
      } else if (guess(mid) == 1 || guess(mid) == 0){
        left = mid;
      }
    }
    return left;
  }
}

```

#### 例题2: x 的平方根
[x 的平方根 ](https://leetcode.cn/problems/sqrtx/)

给你一个非负整数 x ，计算并返回 x 的 算术平方根 。

由于返回类型是整数，结果只保留 整数部分 ，小数部分将被 舍去 。

注意：不允许使用任何内置指数函数和算符，例如 pow(x, 0.5) 或者 `x ** 0.5`。

示例 1：
```txt
输入：x = 4
输出：2
```

示例 2：
```txt
输入：x = 8
输出：2
解释：8 的算术平方根是 2.82842..., 由于返回类型是整数，小数部分将被舍去。
```

代码：
```java
class Solution {
    public int mySqrt(int x) {
        return binarySearch(-1, (long)x + 1, x);
    }
    
    int binarySearch(int left, long right, int x) {
        while ((long)left + 1 != right) {
            int mid = left + (int) ((right - left) / 2);
            if (f(mid, x)) {
                left = mid;
            } else {
                right = mid;
            }
        }
        return left;
    }
    
    boolean f(int index, int x) {
        if ((long)index * index <= x) {
            return true;
        }
        return false;
    }
}
```

#### 例题3: 第一个错误的版本
[第一个错误的版本](https://leetcode.cn/problems/first-bad-version/)

你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。

假设你有 n 个版本 [1, 2, ..., n]，你想找出导致之后所有版本出错的第一个错误的版本。

你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。

示例 1：
```txt
输入：n = 5, bad = 4
输出：4
解释：
调用 isBadVersion(3) -> false 
调用 isBadVersion(5) -> true 
调用 isBadVersion(4) -> true
所以，4 是第一个错误的版本。
```

示例 2：
```
输入：n = 1, bad = 1
输出：1
```

代码:
```java
/* The isBadVersion API is defined in the parent class VersionControl.
      boolean isBadVersion(int version); */

public class Solution extends VersionControl {
    public int firstBadVersion(int n) {
       return binarySearch(0, (long)n + 1);
    }

    int binarySearch(int left, long right) {
        while((long)left + 1 != right) {
            int mid = left + (int) ((right - left) / 2);
            if (isBadVersion(mid)) {
                right = mid;
            } else {
                left = mid;
            }
        }
        return (int)right;
    }
    
}
```

#### 例题4: 寻找旋转排序数组中的最小值
[寻找旋转排序数组中的最小值](https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/)

已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums = [0,1,2,4,5,6,7] 在变化后可能得到：
- 若旋转 4 次，则可以得到 [4,5,6,7,0,1,2]
- 若旋转 7 次，则可以得到 [0,1,2,4,5,6,7]
注意，数组 [a[0], a[1], a[2], ..., a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], ..., a[n-2]] 。

给你一个元素值 互不相同 的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。

你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。

示例 1：
```txt
输入：nums = [3,4,5,1,2]
输出：1
解释：原数组为 [1,2,3,4,5] ，旋转 3 次得到输入数组。
```

示例 2：
```txt
输入：nums = [4,5,6,7,0,1,2]
输出：0
解释：原数组为 [0,1,2,4,5,6,7] ，旋转 4 次得到输入数组。
```

示例 3：
```txt
输入：nums = [11,13,15,17]
输出：11
解释：原数组为 [11,13,15,17] ，旋转 4 次得到输入数组。
```

代码:
```java
class Solution {
  public int findMin(int[] nums) {
    int ansIndex = binarySearch(0, nums.length, nums);
    if (ansIndex == nums.length) {
      return nums[0];
    }
    return nums[ansIndex];
  }

  int binarySearch(int left, int right, int[] nums) {
    while (left + 1 != right) {
      int mid = left + (right - left) / 2;
      if (nums[mid] >= nums[0]) {
        left = mid;
      } else {
        right = mid;
      }
    }
    return right;
  }
}
```

#### 例题5: 寻找旋转排序数组中的最小值 II
[寻找旋转排序数组中的最小值 II](https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array-ii/)

已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums = [0,1,4,4,5,6,7] 在变化后可能得到：
- 若旋转 4 次，则可以得到 [4,5,6,7,0,1,4]
- 若旋转 7 次，则可以得到 [0,1,4,4,5,6,7]
注意，数组 [a[0], a[1], a[2], ..., a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], ..., a[n-2]] 。

给你一个可能存在 **重复** 元素值的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。

你必须尽可能减少整个过程的操作步骤。

示例 1：
```txt
输入：nums = [1,3,5]
输出：1
```

示例 2：
```txt
输入：nums = [2,2,2,0,1]
输出：0
```

代码：
```java
class Solution {
  public int findMin(int[] nums) {
    // 使其符合二分查找模版 
    int i = nums.length - 1;
    while (i > 0 && nums[i] == nums[0]) {
        nums[i--] = nums[0] - 1;
        if (i == 0) {
          return nums[0]; 
        }
    }
    if (nums[0] < nums[i]) {
      return nums[0];
    }
    int ansIndex = binarySearch(0, nums.length, nums);
    if (ansIndex == nums.length) {
      return nums[0];
    }
    return nums[ansIndex];
  }

  int binarySearch(int left, int right, int[] nums) {
    while (left + 1 != right) {
      int mid = left + (right - left) / 2;
      if (nums[mid] >= nums[0]) {
        left = mid;
      } else {
        right = mid;
      }
    }
    return right;
  }
 
}
```

#### 例题6: 在排序数组中查找元素的第一个和最后一个位置
[在排序数组中查找元素的第一个和最后一个位置](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/)

给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。

如果数组中不存在目标值 target，返回 [-1, -1]。

进阶：
- 你可以设计并实现时间复杂度为 O(log n) 的算法解决此问题吗？

示例 1：
```txt
输入：nums = [5,7,7,8,8,10], target = 8
输出：[3,4]
```

示例 2：
```txt
输入：nums = [5,7,7,8,8,10], target = 6
输出：[-1,-1]
```

示例 3：
```txt
输入：nums = [], target = 0
输出：[-1,-1]
```

代码:
```java
class Solution {
  public int[] searchRange(int[] nums, int target) {
    if (nums.length == 0) return new int[]{-1, -1};
    int left = binarySearch1(-1, nums.length, nums, target);
    if (left == nums.length || nums[left] != target) {
      left = -1; 
      return new int[]{-1, -1};
    }
    int right = binarySearch2(-1, nums.length, nums, target);
    return new int[]{left, right};
  }

  int binarySearch1(int left, int right, int[] nums, int target) {
    while (left + 1 != right) {
      int mid = left + (right - left) / 2;
      if (nums[mid] < target) {
        left = mid;
      } else {
        right = mid;
      }
    } 
    return right;
  }

  int binarySearch2(int left, int right, int[] nums, int target) {
    while (left + 1 != right) {
      int mid = left + (right - left) / 2;
      if (nums[mid] <= target) {
        left = mid;
      } else {
        right = mid;
      }
    } 
    return left;
  }
  
}
```

#### K-th object problems
K-th object problems问题可以归纳为：有一堆objects，让你找出将这些objects按其某属性A的值排序后的第k个object的属性值

这类问题的解题步骤：
1. 列出所有可能解：object的属性A的所有可能值
2. 找到boolean function f(v)能把所有可能解划分成2部分：这里function为，将这些objects排好序后，如果位于属性值v前面的object个数大于等于k个，则返回true，反之，返回false

##### 例题7: 乘法表中第k小的数
[乘法表中第k小的数](https://leetcode.cn/problems/kth-smallest-number-in-multiplication-table/)

<div class="container">
  <iframe width="560" height="315" src="https://www.youtube.com/embed/mUOuMmt5gEY" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>

几乎每一个人都用 乘法表。但是你能在乘法表中快速找到第k小的数字吗？

给定高度m 、宽度n 的一张 m * n的乘法表，以及正整数k，你需要返回表中第k 小的数字。

例 1：
```txt
输入: m = 3, n = 3, k = 5
输出: 3
解释: 
乘法表:
1	2	3
2	4	6
3	6	9

第5小的数字是 3 (1, 2, 2, 3, 3).
```

例 2：
```txt
输入: m = 2, n = 3, k = 6
输出: 6
解释: 
乘法表:
1	2	3
2	4	6

第6小的数字是 6 (1, 2, 2, 3, 4, 6).
```

###### 题目分析
1. 这一堆objects就是乘法表中元素
2. 属性：乘法表中元素的大小值
3. 所有可能解是`[1, m*n]`;
4. `boolean f(v)`是将objects按大小排好序后，如果大小小于value的个数大于等于k，则返回true，反之，返回false

代码：
```java
class Solution {
  public int findKthNumber(int m, int n, int k) {
    return binearySearch(0, m * n + 1, m, n, k);
  }

  // 如果矩阵中元素小于value的个数大于等于k，则返回true，反之，返回false
  boolean f(int m, int n, int k, int value) {
    int cnt = 0;
    for (int i = 1; i <= m; i++) {
      cnt += Math.min(value / i, n);
    }
    return cnt >= k;
  }

  int binearySearch(int left, int right, int m, int n, int k) {
    while (left + 1 != right) {
      int mid = left + (right - left) / 2;
      if (f(m, n, k, mid)) {
        right = mid;
      } else {
        left = mid;
      }
    }
    return right;
  }
}
```

##### 例题8: 第 N 个神奇数字
[第 N 个神奇数字](https://leetcode.cn/problems/nth-magical-number/)

<div class="container">
  <iframe width="560" height="315" src="https://www.youtube.com/embed/mwIge6NXAyQ" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>

一个正整数如果能被 a 或 b 整除，那么它是神奇的。

给定三个整数 n , a , b ，返回第 n 个神奇的数字。因为答案可能很大，所以返回答案 对 109 + 7 取模 后的值。

示例 1：
```txt
输入：n = 1, a = 2, b = 3
输出：2
```

示例 2：
```txt
输入：n = 4, a = 2, b = 3
输出：6
```

###### 题目分析
1. 这一堆objects就是a与b的神奇数字
2. 属性：神奇数字大小
3. 所有可能解是`[0, n * Math.min(a, b)]`;
4. `boolean f(v)`是将objects排好序后，如果大小小于value的个数大于等于k，则返回true，反之，返回false

代码：
```java
class Solution {
  public int nthMagicalNumber(int n, int a, int b) {
    return binarySearch(0, (long)n * Math.min(a, b), n, a, b);
  }
  
  int binarySearch(long left, long right, int n, int a, int b) {
    while (left + 1 != right) {
      long mid = left + (right - left) / 2;
      if (f(n, a, b, mid)) {
        right = mid;
      } else {
        left = mid;
      }
    }
    return (int)(right % (1e9 + 7));
  }

  // 如果a与b的神奇数字小于value的个数大于或等于n，则返回true，反之返回false
  boolean f(int n, int a, int b, long value) {
    return value / a + value / b - value / lcm(a, b) >= n;
  }

  int gcd(int a, int b) {
    // 辗转相除
    return b ==0 ? a : gcd(b, a % b);
  }
  
  int lcm(int a, int b) {
    return a * b / gcd(a, b);
  }
}
```

##### 例题9: 找出第 K 小的数对距离
[找出第 K 小的数对距离](https://leetcode.cn/problems/find-k-th-smallest-pair-distance/)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220603211022.png)

##### 分析

<div class="container">
  <iframe width="560" height="315" src="https://www.youtube.com/embed/2YtgPABdeHE" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>

代码：
```java
class Solution {
  int[] nums;
  public int smallestDistancePair(int[] nums, int k) {
    this.nums = nums;
    Arrays.sort(this.nums);
    int res = binearySearch(-1, 1000001, k);
    return res;
  }
  
  // 如果数组中对距离小于value的个数大于或等于k，则返回true，反之返回false
  boolean f(int value, int k) {
    int cnt = 0;
    int rloc = 0;
    for (int i = 0; i < nums.length; i++) {
      while (rloc < nums.length && nums[rloc] - nums[i] <= value) {
         rloc++;
      }
      cnt += rloc - i - 1;
    }
    return cnt >= k;
  }

  int binearySearch(int left, int right, int k) {
    while (left + 1 != right) {
      int mid = left + (right - left) / 2;
      if (f(mid, k)) {
        right = mid; 
      } else {
        left = mid;
      }
    }
    return right;
  }
  
}
```

##### 例题10: 有序矩阵中第 K 小的元素
[有序矩阵中第 K 小的元素](https://leetcode.cn/problems/kth-smallest-element-in-a-sorted-matrix/)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220604100441.png)

代码：
```java
class Solution {
  int[][] matrix;
  public int kthSmallest(int[][] matrix, int k) {
    this.matrix = matrix;
    return binearySearch((int)-1e9, (int)1e9+1, k);
  }

  boolean f(int value, int k) {
    int cnt = 0;
    for (int r = 0; r < matrix.length; r++) {
      for (int c = 0; c < matrix[0].length; c++) {
        if (matrix[r][c] > value) {
          break;
        }
        cnt++;
      }
    }
    return cnt >= k;
  }

  int binearySearch(int left, int right, int k) {
    while (left + 1 != right) {
      int mid = left + (right - left) / 2;
      if (f(mid, k)) {
        right = mid;
      } else {
        left = mid;
      }
    }
    return right;
  }

}
```

## 隐式图上的DFS和BFS算法

<div class="container">
  <iframe width="560" height="315" src="https://www.youtube.com/embed/g9SOQIKspaw" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>

<div class="container">
  <iframe width="560" height="315" src="https://www.youtube.com/embed/xdmyuHKsTYU" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>

<div class="container">
  <iframe src="https://drive.google.com/file/d/179HorlJSGlAwA-c-FV6b-JsYovjfpjb9/preview" width="640" height="480" allow="autoplay"></iframe>
</div>

### 模版
<font color="red">状态：由一组变量来表示。每个变量都有特定的含义。由不同的变量值组成不同的状态</font>

#### DFS模版
```java
/**
* visited: 用来存储被访问过的状态。如果允许状态是能够重复访问，则不需要创建visited变量
* path: 用来存储路径。如果不需要输出路径，则不需要创建path变量
* return: 是否可以到达目标状态
*/
boolean dfs(State currentState, Set<State> visited, LinkedList<State> path) {
  
  // 如果currentState是目标状态
  if (isObjective(currentState)) {
    // 可以在这里输出path
    return true;
  }

  // 获取当前状态可以转换到的所有下一个状态。此时不需要考虑这个状态是否能被添加到队列中
  List<State> nextStates = transition(currentState);

  for (State nextState : nextStates) {
    if (!visited.contains(nextState)) {
      visited.add(nextState);
      path.push(nextState);
      if (dfs(nextState, visited, path)){
        return true;
      }
      path.pop();
    }
  }
  return false;
}
```

#### BFS模版
##### 模版1：求路径是否存在
```java
/**
* visited: 用来存储被访问过的状态。如果允许状态是能够重复访问，则不需要创建visited变量
* path: 用来存储路径。如果不需要输出路径，则不需要创建path变量
* return: 是否可以到达目标状态
*/
boolean bfs(State startState) {
  Queue<State> queue = new LinkedList();
  Map<State, Boolean> visited = new HashMap();
  Map<State, State> path = new HashMap();
  
  queue.add(startState);
  visited.put(startState, true);

  while (!queue.isEmpty()) {
    State currentState = queue.poll();
    // 如果currentState是目标状态
    if (isObjective(currentState)) {
      // 可以在这里输出path
      return visited.get(currentState);
    }

    // 获取当前状态可以转换到的所有下一个状态。此时不需要考虑这个状态是否能被添加到队列中
    List<State> nextStates = transition(currentState);

    for (State nextState : nextStates) {
      if (visited.containsKey(nextState)) continue;
      queue.add(nextState);
      visited.put(nextState, true);
      path.put(nextState, currentState); 
    }
  }
  return false;
}
```

##### 模版2：求最短路径
```java
/**
* visited: 用来存储被访问过的状态。如果允许状态是能够重复访问，则不需要创建visited变量
* path: 用来存储路径。如果不需要输出路径，则不需要创建path变量
*/
boolean bfs(State startState) {
  Queue<State> queue = new LinkedList();
  Map<State, Integer> visited = new HashMap();
  Map<State, State> path = new HashMap();
  
  queue.add(startState);
  visited.put(startState, true);

  while (!queue.isEmpty()) {
    State currentState = queue.poll();
    // 如果currentState是目标状态
    if (isObjective(currentState)) {
      // 可以在这里输出path
      return true;
    }

    // 获取当前状态可以转换到的所有下一个状态。此时不需要考虑下一个状态是否被访问过
    List<State> nextStates = transition(currentState);
    for (State nextState : nextStates) {
      if (visited.containsKey(nextState)) continue;
      queue.add(nextState);
      visited.put(nextState, visited.get(currentState) + 1);
      path.put(nextState, currentState); 
    }
  }
  return false;
}
```

###### visited妙用
用BFS求最短路径时visited不但可以用来存储被访问过的状态，还可以用来存储到达此状态的最短路径。见例题2: 完全平方数、例题4: 滑动谜题、例题5: 零钱兑换

### 总结
使用模版前，需要思考下面2点：
1. 是否允许状态被重复访问?
  - 允许，不需要创建visited。见例题3：N皇后 II
  - 不允许，需要创建visited
2. 是否要求出最短路径?
  - 是，推荐使用BFS。由于DFS复杂度高，所以不推荐使用。见例题2: 完全平方数
  - 不是，既能使用BFS，也能使用DFS

### 例题
#### 例题1: 水壶问题
[水壶问题](https://leetcode.cn/problems/water-and-jug-problem/)

有两个水壶，容量分别为 jug1Capacity 和 jug2Capacity 升。水的供应是无限的。确定是否有可能使用这两个壶准确得到 targetCapacity 升。

如果可以得到 targetCapacity 升水，最后请用以上水壶中的一或两个来盛放取得的 targetCapacity 升水。

你可以：
- 装满任意一个水壶
- 清空任意一个水壶
- 从一个水壶向另外一个水壶倒水，直到装满或者倒空

示例 1: 
```txt
输入: jug1Capacity = 3, jug2Capacity = 5, targetCapacity = 4
输出: true
```

示例 2:
```
输入: jug1Capacity = 2, jug2Capacity = 6, targetCapacity = 5
输出: false
```

代码：
DFS实现
```java
class Solution {
  int jug1 = 0;
  int jug2 = 0;
  int target = 0;
  Set<State> visited = new HashSet();
  public boolean canMeasureWater(int jug1Capacity, int jug2Capacity, int targetCapacity) {
    jug1 = jug1Capacity;
    jug2 = jug2Capacity;
    target = targetCapacity;
    State startState = new State(0, 0);
    visited.add(startState);
    return dfs(startState);
  }

  boolean dfs(State currentState) {
    if (currentState.x == target || 
    currentState.y == target || 
    currentState.x + currentState.y == target) {
      return true;
    }

    List<State> nextStates = transition(currentState);
    for (State nextState : nextStates) {
      if (!visited.contains(nextState)) {
        visited.add(nextState);
        if (dfs(nextState)){
          return true;
        }
      }
    }
    return false;
  }

  List<State> transition(State state) {
    List<State> res = new ArrayList();
    if (state.x < jug1) {
      res.add(new State(jug1, state.y)); // 把第一个壶倒满
    }
    if (state.y < jug2) {
      res.add(new State(state.x, jug2)); // 把第二个壶倒满
    }
    if (state.x > 0) {
      res.add(new State(0, state.y)); // 清空第一个壶
    }
    if (state.y > 0) {
      res.add(new State(state.x, 0)); // 清空第二个壶
    }
    if (state.x < jug1 && state.y > 0) {
      res.add(new State(Math.min(jug1, state.x + state.y), Math.max(0, state.y - (jug1 - state.x)))); // 将第二个壶中的水倒入第一个壶中
    }
    if (state.y < jug2 && state.x > 0) {
      res.add(new State(Math.max(0, state.x - (jug2 - state.y)), Math.min(jug2, state.y + state.x))); // 将第一个壶中的水倒入第二个壶中
    }
    return res;
  }

  class State {
    int x;
    int y;

    public State(int x, int y) {
      this.x = x; 
      this.y = y;
    }

    public boolean equals(Object o) {
      if (this == o) return true;
      if (o == null) return false;
      State a = (State) o;
      return x == a.x && y == a.y;
    }

    public int hashCode() {
      return Objects.hash(x, y);
    } 

  }


}
```

BFS实现
```java
class Solution {
  int jug1 = 0;
  int jug2 = 0;
  int target = 0;

  public boolean canMeasureWater(int jug1Capacity, int jug2Capacity, int targetCapacity) {
    jug1 = jug1Capacity;
    jug2 = jug2Capacity;
    target = targetCapacity;
    return bfs(new State(0, 0));
  }

  boolean bfs(State startState) {
    Queue<State> queue = new LinkedList();
    Map<State, Boolean> visited = new HashMap();
    Map<State, State> path = new HashMap();
    
    queue.add(startState);
    visited.put(startState, true);

    while (!queue.isEmpty()) {
      State currentState = queue.poll();
      if (currentState.x == target || 
        currentState.y == target || 
        currentState.x + currentState.y == target) {
      return true;
      }

      List<State> nextStates = transition(currentState);
      for (State nextState : nextStates) {
        if (visited.containsKey(nextState)) continue;
        queue.add(nextState);
        visited.put(nextState, true);
        path.put(nextState, currentState); 
      }
    }
    return false;

  }

  List<State> transition(State state) {
    List<State> res = new ArrayList();
    if (state.x < jug1) {
      res.add(new State(jug1, state.y)); // 把第一个壶倒满
    }
    if (state.y < jug2) {
      res.add(new State(state.x, jug2)); // 把第二个壶倒满
    }
    if (state.x > 0) {
      res.add(new State(0, state.y)); // 清空第一个壶
    }
    if (state.y > 0) {
      res.add(new State(state.x, 0)); // 清空第二个壶
    }
    if (state.x < jug1 && state.y > 0) {
      res.add(new State(Math.min(jug1, state.x + state.y), Math.max(0, state.y - (jug1 - state.x)))); // 将第二个壶中的水倒入第一个壶中
    }
    if (state.y < jug2 && state.x > 0) {
      res.add(new State(Math.max(0, state.x - (jug2 - state.y)), Math.min(jug2, state.y + state.x))); // 将第一个壶中的水倒入第二个壶中
    }
    return res;
  }

  class State {
    int x;
    int y;

    public State(int x, int y) {
      this.x = x; 
      this.y = y;
    }

    public boolean equals(Object o) {
      if (this == o) return true;
      if (o == null) return false;
      State a = (State) o;
      return x == a.x && y == a.y;
    }

    public int hashCode() {
      return Objects.hash(x, y);
    } 

  }

}
```

#### 例题2: 完全平方数

[完全平方数](https://leetcode.cn/problems/perfect-squares/)

给你一个整数 n ，返回 和为 n 的完全平方数的最少数量 。

完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。

示例 1：
```txt
输入：n = 12
输出：3 
解释：12 = 4 + 4 + 4
```

示例 2：
```txt
输入：n = 13
输出：2
解释：13 = 4 + 9
```

##### 分析
此题是最短路径问题，可以用BFS来做，但是不能用DFS来做

代码：
```java
class Solution {
  public int numSquares(int n) {
    return bfs(n);    
  }
  
  int bfs(Integer startState) {
    Queue<Integer> queue = new LinkedList(); 
    Map<Integer, Integer> visited = new HashMap(); // 技巧： 可以用visited表示是否被访问过，也表示访问此状态所经过的步数

    queue.add(startState);
    visited.put(startState, 0);
    
    while(!queue.isEmpty()) {
      Integer currentState = queue.poll();
      if (currentState == 0) {
        return visited.get(currentState);
      }

      List<Integer> nextStates = new ArrayList();
      for (int i = 1; i * i <= currentState; i++) {
        nextStates.add(currentState - i * i); 
      }
      for (Integer nextState : nextStates) {
        if (visited.containsKey(nextState)) continue;;
        queue.add(nextState);
        visited.put(nextState, visited.get(currentState) + 1);
      }  
    }
    return -1;
  }
}
```

#### 例题2: N皇后
[N皇后](https://leetcode.cn/problems/n-queens/description/)

![](https://raw.githubusercontent.com/NaisWang/images/master/20230206170353.png)

##### 分析
`int[] state = new int[10]`中`state[0], state[1], state[2],...,state[8]`表示第1行到第9行皇后所放的位置。`state[9]`表示当前皇后已放在哪行了

代码:
```java
class Solution {
  int n;
  String str = "";
  List<List<String>> ans = new ArrayList();
  public List<List<String>> solveNQueens(int n) {
    this.n = n;
    for (int i = 0; i < n; i++) {
      str += ".";
    }
    int[] state = new int[10];
    state[9] = -1;
    dfs(state);
    return ans;
  }


  void dfs(int[] state) {
    if (state[9] == n - 1) {
      List<String> res = new ArrayList();
      for (int i = 0; i < n; i++) {
        StringBuffer sb = new StringBuffer(str);
        sb.replace(state[i], state[i] + 1, "Q");
        res.add(sb.toString());
      }
      ans.add(res);
      return;
    }

    List<int[]> nextStateList = new ArrayList();
    for (int c = 0; c < n; c++) {
      boolean conflict = false;
      for (int i = 0; i <= state[9]; i++) {
        if (state[i] == c || Math.abs(c - state[i]) == Math.abs(state[9] + 1 - i)) {
          conflict = true;
          break;
        }
      }
      if (!conflict) {
        int[] nextState = state.clone();
        nextState[state[9] + 1] = c; 
        nextState[9]++;
        nextStateList.add(nextState);
      }
    }

    for (int[] nextState : nextStateList) {
      dfs(nextState);
    }
    
  }
}
```

#### 例题3：N皇后 II
[N皇后 II](https://leetcode.cn/problems/n-queens-ii/)

n 皇后问题 研究的是如何将 n 个皇后放置在 n × n 的棋盘上，并且使皇后彼此之间不能相互攻击。

给你一个整数 n ，返回 n 皇后问题 不同的解决方案的数量。

示例 1：
```txt
输入：n = 4
输出：2
```

##### 分析
DFS代码：
```java
class Solution {

  int n; 
  int cnt = 0; 

  public int totalNQueens(int n) {
    this.n = n;
    dfs(new State(new int[9], 0));
    return cnt;
  }
  
  void dfs(State currentState) {
    if (currentState.nowRow == n) {
      cnt++;
      return;
    }

    List<State> nextStates = new ArrayList();
    for (int col = 0; col < n; col++) {
      boolean conflict = false;
      for (int row = 0; row < currentState.nowRow; row++) {
        if (col == currentState.preRows[row] || currentState.nowRow - row  == Math.abs(currentState.preRows[row] - col)) {
          conflict = true; 
          break;
        }
      }
      if (!conflict) {
        int[] temp =  Arrays.copyOf(currentState.preRows, n);
        temp[currentState.nowRow] = col; 
        nextStates.add(new State(temp,  currentState.nowRow + 1));
      }
    }
    
    for (State nextState : nextStates) {
      dfs(nextState);
    }

  }

  class State {
    int[] preRows; // 存放位于nowRow前面的每行中皇后所在列
    int nowRow; // 当前需要摆放皇后的行

    public State(int[] preRows, int nowRow) {
      this.preRows = preRows;
      this.nowRow = nowRow;
    }


    public boolean equals(Object o) {
      if (this == o) return true;
      if (o == null || getClass() != o.getClass()) return false;
      State state = (State) o;
      return nowRow == state.nowRow && Arrays.equals(preRows, state.preRows);
    }
  
    public int hashCode() {
      int result = Objects.hash(nowRow);
      result = 31 * result + Arrays.hashCode(preRows);
      return result;
    }
  }

}
```

BFS代码：
```java
class Solution {

  int n; 
  int cnt = 0; 

  public int totalNQueens(int n) {
    this.n = n;
    //dfs(new State(new int[9], 0));
    bfs(new State(new int[9], 0));
    return cnt;
  }

  void bfs(State startState) {
    Queue<State> queue = new LinkedList();
    queue.add(startState);

    while(!queue.isEmpty()) {
      State currentState = queue.poll();

      if (currentState.nowRow == n) {
        cnt++;
        continue;
      }

      List<State> nextStates = new ArrayList();
      for (int col = 0; col < n; col++) {
        boolean conflict = false;
        for (int row = 0; row < currentState.nowRow; row++) {
          if (col == currentState.preRows[row] || currentState.nowRow - row  == Math.abs(currentState.preRows[row] - col)) {
            conflict = true; 
            break;
          }
        }

        if (!conflict) {
          int[] temp =  Arrays.copyOf(currentState.preRows, n);
          temp[currentState.nowRow] = col; 
          nextStates.add(new State(temp,  currentState.nowRow + 1));
        }
      }

      for (State nextState : nextStates) {
        queue.add(nextState); 
      }
    }
  }

  class State {
    int[] preRows; // 存放位于nowRow前面的每行中皇后所在列
    int nowRow; // 当前需要摆放皇后的行

    public State(int[] preRows, int nowRow) {
      this.preRows = preRows;
      this.nowRow = nowRow;
    }


    public boolean equals(Object o) {
      if (this == o) return true;
      if (o == null || getClass() != o.getClass()) return false;
      State state = (State) o;
      return nowRow == state.nowRow && Arrays.equals(preRows, state.preRows);
    }
  
    public int hashCode() {
      int result = Objects.hash(nowRow);
      result = 31 * result + Arrays.hashCode(preRows);
      return result;
    }
  }

}
```

##### 判断棋盘中的两个点是否在同一斜线上
假如现在有两个点(x1, y1), (x2, y2); 则其两个在同一斜线上点充要条件是：$abs(x1 - x2) == abs(y1 - y2)$

#### 例题4: 滑动谜题
[滑动谜题](https://leetcode.cn/problems/sliding-puzzle/)

![](https://raw.githubusercontent.com/NaisWang/images/master/20230207160750.png)

##### 分析

代码1:
```java
class Solution {

  public int slidingPuzzle(int[][] board) {
    return bfs(new State(board)); 
  }

  int bfs(State startState) {
    Queue<State> queue = new LinkedList();
    Map<State, Integer> visited = new HashMap();

    queue.add(startState);
    visited.put(startState, 0);

    while (!queue.isEmpty()) {
      State currentState = queue.poll();
      if (Arrays.deepEquals(currentState.board, new int[][]{ {1,2,3}, {4,5,0} })) {
        return visited.get(currentState);
      }

      List<State> nextStates = transition(currentState);
      for(State nextState : nextStates) {
        if (visited.containsKey(nextState)) continue;    
        queue.add(nextState);
        visited.put(nextState, visited.get(currentState) + 1);
      }
    }
    return -1;
  }

  List<State> transition(State currentState) {
    int[] now = currentState.now;
    int[][] board = currentState.board;
    List<State> res = new ArrayList();
    int[] dc = new int[]{0, 0, -1, 1};
    int[] dr = new int[]{-1, 1, 0, 0};
    for (int i = 0; i < 4; i++) {
      int nr = now[0] + dr[i];
      int nc = now[1] + dc[i];
      if (nr >= 0 && nr <= 1 && nc >= 0 && nc <= 2) {
        int[][] newBoard = new int[2][3];
        for (int j = 0; j < 2; j++) {
          newBoard[j] = Arrays.copyOf(board[j], 3);
        }
        newBoard[now[0]][now[1]] = newBoard[nr][nc];
        newBoard[nr][nc] = 0;
        res.add(new State(newBoard, new int[]{nr, nc}));
      }
    }
    return res;
  }

  class State {
    int[][] board = new int[2][3];
    int[] now; // 现在空缺块坐标

    public State(int[][] board, int[] now) {
      this.board = board;
      this.now = now;
    }

    public State(int[][] board) {
      this.board = board;
      for (int r = 0; r < 2; r++) {
        for (int c = 0; c < 3; c++) {
          if (board[r][c] == 0) {
            this.now = new int[]{r, c};
            return;
          }
        }
      }
    }

    @Override
    public boolean equals(Object o) {
      if (this == o) return true;
      if (o == null || getClass() != o.getClass()) return false;
      State state = (State) o;
      return Arrays.deepEquals(board, state.board) && Arrays.equals(now, state.now);
    }

    @Override
    public int hashCode() {
      int result = Arrays.deepHashCode(board);
      result = 31 * result + Arrays.hashCode(now);
      return result;
    }

  }
 
}
```

代码二：

`int[] state = new int[7]`中`state[0] ~ state[5]`表示各个方块上是什么数值，`state[6]`表示空缺块位于那个位置

```java
class Solution {
  public int slidingPuzzle(int[][] board) {
    int[] state = new int[7];
    for (int r = 0; r < board.length; r++) {
      for (int c = 0; c < board[r].length; c++) {
        state[r * 3 + c] = board[r][c];
        if (state[r * 3 + c] == 0) {
          state[6] = r * 3 + c;
        } 
      }
    }
    return bfs(state);
  }

  int bfs(int[] state) {
    Map<String, Integer> visited = new HashMap();
    visited.put(Arrays.toString(state), 0); 
    Queue<int[]> queue = new LinkedList();
    queue.add(state);

    while (!queue.isEmpty()) {
      int[] currentState = queue.poll();

      if (Arrays.equals(new int[]{1, 2, 3, 4, 5, 0, 5}, currentState)) {
        return visited.get(Arrays.toString(currentState));
      }

      List<int[]> nextStateList = getNextStateList(currentState);
      for (int[] nextState : nextStateList) {
        if (!visited.containsKey(Arrays.toString(nextState))) {
          visited.put(Arrays.toString(nextState), visited.get(Arrays.toString(currentState)) + 1); 
          queue.add(nextState);
        }
      }
    }
    return -1;
  }

  List<int[]> getNextStateList(int[] state) {
    List<int[]> res = new ArrayList();
    // 空缺在第2行, 可进行向上移动
    if (state[6] > 2) {
      int[] nextState = state.clone();
      nextState[state[6]] = nextState[state[6] - 3];
      nextState[state[6] - 3] = 0;
      nextState[6] = state[6] - 3;
      res.add(nextState);
    }
    // 空缺在第一行，可进行向下移动
    if (state[6] <= 2) {
      int[] nextState = state.clone();
      nextState[state[6]] = nextState[state[6] + 3];
      nextState[state[6] + 3] = 0;
      nextState[6] = state[6] + 3;
      res.add(nextState);
    }
    // 空缺在第一二列，可进行向右移动
    if (state[6] != 2 && state[6] != 5) {
      int[] nextState = state.clone();
      nextState[state[6]] = nextState[state[6] + 1];
      nextState[state[6] + 1] = 0;
      nextState[6] = state[6] + 1;
      res.add(nextState);
    }
    // 空缺在第二三列，可进行向左移动
    if (state[6] != 0 && state[6] != 3) {
      int[] nextState = state.clone();
      nextState[state[6]] = nextState[state[6] - 1];
      nextState[state[6] - 1] = 0;
      nextState[6] = state[6] - 1;
      res.add(nextState);
    }
    return res;
  }
}
```

#### 例题5: 零钱兑换
[零钱兑换](https://leetcode.cn/problems/coin-change/)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220711103547.png)

代码：
```java
class Solution {
  int[] coins;
  public int coinChange(int[] coins, int amount) {
    this.coins = coins;
    return bfs(amount);
  }
  
  int bfs(Integer state) {
    Map<Integer, Integer> visted = new HashMap(); 
    visted.put(state, 0);
    Queue<Integer> queue = new LinkedList();
    queue.add(state);

    while (!queue.isEmpty()) {
      Integer currentState = queue.poll();
      if (currentState == 0) return visted.get(currentState);
      
      List<Integer> nextStateList = new ArrayList();
      for (int coin : coins) {
        if (currentState >= coin) nextStateList.add(currentState - coin);
      }
      
      for (Integer nextState : nextStateList) {
        if (!visted.containsKey(nextState)) {
          visted.put(nextState, visted.get(currentState) + 1);
          queue.add(nextState);
        }
      } 
    }
    return -1;
  }
}
```

#### 例题6: 跳跃游戏 III
[跳跃游戏 III](https://leetcode.cn/problems/jump-game-iii/)

![](https://raw.githubusercontent.com/NaisWang/images/master/20230207163232.png)

##### 分析
BFS代码：
```java
class Solution {
  int[] arr;

  public boolean canReach(int[] arr, int start) {
    this.arr = arr;
    return bfs(start); 
  }

  boolean bfs(Integer startState) {
    Queue<Integer> queue = new LinkedList();
    Map<Integer, Boolean> visited = new HashMap();
    
    queue.add(startState);
    visited.put(startState, true); 

    while (!queue.isEmpty()) {
      Integer currentState = queue.poll();
      if (arr[currentState] == 0) {
        return true; 
      }

      List<Integer> nextStates = new ArrayList();  
      for (int i : new int[]{currentState + arr[currentState], currentState - arr[currentState]}) {
        if (i < arr.length && i >= 0) {
          nextStates.add(i);
        }
      }

      for (Integer nextState : nextStates) {
        if (visited.containsKey(nextState)) continue;
        queue.add(nextState);
        visited.put(nextState, true);
      }
    }
    return false;
  }
}
```

DFS代码：
```java
class Solution {
  int[] arr;
  Set<Integer> visited = new HashSet();
  public boolean canReach(int[] arr, int start) {
    this.arr = arr;
    visited.add(start);
    return dfs(start);
  }

  boolean dfs(Integer state) {
    if (arr[state] == 0) return true;

    List<Integer> nextStateList = new ArrayList();
    if (state + arr[state] < arr.length) nextStateList.add(state + arr[state]);
    if (state - arr[state] >= 0) nextStateList.add(state - arr[state]);

    for (Integer nextState : nextStateList) {
      if (!visited.contains(nextState)) {
        visited.add(nextState);
        if (dfs(nextState)) return true;
      }
    }
    return false;
  } 

}
```

#### 例题7: 被围绕的区域
[被围绕的区域](https://leetcode.cn/problems/surrounded-regions/)

给你一个 m x n 的矩阵 board ，由若干字符 'X' 和 'O' ，找到所有被 'X' 围绕的区域，并将这些区域里所有的 'O' 用 'X' 填充。

##### 分析
BFS代码：
```java
class Solution {

  int row;
  int col;
  int[] dr = new int[]{-1, 1, 0, 0};
	int[] dc = new int[]{0, 0, -1, 1};
  char[][] board;
  Map<State, Boolean> visited = new HashMap();
  List<State> change = new LinkedList();
  List<State> tempChange = new LinkedList();
  boolean flag = true; // 用来标记当前连通块是否被‘x’围绕
  
  public void solve(char[][] board) {
    this.board = board;
    row = board.length;
    col = board[0].length;
    for (int r = 0; r < row; r++) {
      for (int c = 0; c < col; c++) {
        State state = new State(new int[]{r, c});
        if (board[r][c] == 'O' && !visited.containsKey(state)) {
          tempChange = new LinkedList();
          flag = true;
          bfs(state);
          if (flag) {
            change.addAll(tempChange);
          }
        }
      }
    } 

    for (State state : change) {
      board[state.coor[0]][state.coor[1]] = 'X';
    }

  }
  
  void bfs(State startState) {
    Queue<State> queue = new LinkedList();
    queue.add(startState); 
    visited.put(startState, true);
    tempChange.add(startState);

    while (!queue.isEmpty()) {
      State currentState = queue.poll();

      List<State> nextStates = new ArrayList();
      for (int i = 0; i < 4; i++) {
        int nr = currentState.coor[0] + dr[i];
        int nc = currentState.coor[1] + dc[i];
        if (nr < 0 || nr >= row || nc < 0 || nc >= col) {
          flag = false;  // 当前连通块没有被‘x’围绕
        } else if (board[nr][nc] == 'O'){
          nextStates.add(new State(new int[]{nr, nc}));
        }
      }
      for (State nextState : nextStates) {
        if (visited.containsKey(nextState)) continue;
        queue.add(nextState);
        visited.put(nextState, true);
        tempChange.add(nextState);
      }
    }

  }

  class State {
    int[] coor;

    public State(int[] coor) {
      this.coor = coor;
    }

    @Override
    public boolean equals(Object o) {
      if (this == o) return true;
      if (o == null || getClass() != o.getClass()) return false;
      State state = (State) o;
      return Arrays.equals(coor, state.coor);
    }

    @Override
    public int hashCode() {
      return Arrays.hashCode(coor);
    }
  }

}
```

DFS代码：
```java
class Solution {
  int row;
  int col;
  int[] dr = new int[]{-1, 1, 0, 0};
	int[] dc = new int[]{0, 0, -1, 1};
  char[][] board;
  Set<State> visited = new HashSet();
  List<State> change = new LinkedList();
  List<State> tempChange = new LinkedList();
  boolean flag = true; // 用来标记当前连通块是否被‘x’围绕
  
  public void solve(char[][] board) {
    this.board = board;
    row = board.length;
    col = board[0].length;
    for (int r = 0; r < row; r++) {
      for (int c = 0; c < col; c++) {
        State state = new State(new int[]{r, c});
        if (board[r][c] == 'O' && !visited.contains(state)) {
          tempChange = new LinkedList();
          flag = true;
          visited.add(state);
          tempChange.add(state);
          dfs(state);
          if (flag) {
            change.addAll(tempChange);
          }
        }
      }
    } 

    for (State state : change) {
      board[state.coor[0]][state.coor[1]] = 'X';
    }

  }
  

  void dfs(State currentState) {
    List<State> nextStates = new ArrayList();
    for (int i = 0; i < 4; i++) {
      int nr = currentState.coor[0] + dr[i];
      int nc = currentState.coor[1] + dc[i];
      if (nr < 0 || nr >= row || nc < 0 || nc >= col) {
        flag = false;  // 当前连通块没有被‘x’围绕
      } else if (board[nr][nc] == 'O'){
        nextStates.add(new State(new int[]{nr, nc}));
      }
    }

    for (State nextState : nextStates) {
      if (!visited.contains(nextState)) {
        visited.add(nextState);
        tempChange.add(nextState);
        dfs(nextState);
      }
    }
  }
  
  class State {
    int[] coor;

    public State(int[] coor) {
      this.coor = coor;
    }

    @Override
    public boolean equals(Object o) {
      if (this == o) return true;
      if (o == null || getClass() != o.getClass()) return false;
      State state = (State) o;
      return Arrays.equals(coor, state.coor);
    }

    @Override
    public int hashCode() {
      return Arrays.hashCode(coor);
    }
  }


  

}
```

# 树
## 结构转换+序列化
### 例题1: 二叉树的序列化与反序列化
[二叉树的序列化与反序列化](https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220726151612.png)

#### 方法一：中序遍历
```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Codec {

  // Encodes a tree to a single string.
  public String serialize(TreeNode root) {
    if (root == null) return "";
    StringBuffer sb = new StringBuffer();
    Queue<TreeNode> queue = new LinkedList();
    queue.add(root);
    sb.append(root.val + ",");

    while (!queue.isEmpty()) {
      TreeNode currentNode = queue.poll();
      if (currentNode.left != null) {
        queue.add(currentNode.left);
        sb.append(currentNode.left.val + ","); 
      } else {
        sb.append("null,");
      }
      if (currentNode.right != null) {
        queue.add(currentNode.right);
        sb.append(currentNode.right.val + ",");
      } else {
        sb.append("null,");
      }
    }
    return sb.toString();
  }

  // Decodes your encoded data to tree.
  public TreeNode deserialize(String data) {
    if (data.equals("")) return null;
    String[] nodes = data.split(",");
    Queue<TreeNode> queue = new LinkedList();
    TreeNode root = new TreeNode(Integer.valueOf(nodes[0]));
    queue.add(root);
    int i = 0;
    while (!queue.isEmpty()) {
      TreeNode currentNode = queue.poll();
      TreeNode child = nodes[++i].equals("null") ? null : new TreeNode(Integer.valueOf(nodes[i]));
      if (child != null) {
        queue.add(child);
      }
      currentNode.left = child;
      child = nodes[++i].equals("null") ? null : new TreeNode(Integer.valueOf(nodes[i]));
      if (child != null) {
        queue.add(child);
      }
      currentNode.right = child;
    }
    return root;
  }
}
```

#### 方法二：先序遍历
```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Codec {

  // Encodes a tree to a single string.
  public String serialize(TreeNode root) {
    if (root == null) return "#";
    StringBuffer sb = new StringBuffer();
    return sb.append(root.val).append(",").append(serialize(root.left)).append(",").append(serialize(root.right)).toString();
  }

  // Decodes your encoded data to tree.
  public TreeNode deserialize(String data) {
    Queue<String> queue = new LinkedList(Arrays.asList(data.split(","))); 
    return helper(queue);
  }

  TreeNode helper(Queue<String> queue) {
    String current = queue.poll();
    if (current.equals("#")) return null;
    TreeNode currentNode = new TreeNode(Integer.valueOf(current));
    currentNode.left = helper(queue);
    currentNode.right = helper(queue);
    return currentNode;
  }
}
```

### 例题2: 前序遍历构造二叉搜索树
[前序遍历构造二叉搜索树](https://leetcode.cn/problems/construct-binary-search-tree-from-preorder-traversal/)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220726153602.png)

代码：
```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
  int[] preorder;
  int index = 0;
  public TreeNode bstFromPreorder(int[] preorder) {
    this.preorder = preorder;
    return helper(Integer.MIN_VALUE, Integer.MAX_VALUE);
  }
  
  TreeNode helper(int lower, int upper) {
    if (index == preorder.length) return null;
    int val = preorder[index];
    if (val < lower || val > upper) return null; 
    index++;
    TreeNode node = new TreeNode(val);
    node.left = helper(lower, val); 
    node.right = helper(val, upper); 
    return node;
  }
}
```

### 例题3: 从前序与中序遍历序列构造二叉树
[从前序与中序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220726162709.png)

#### 分析

<div class="container">
  <iframe width="560" height="315" src="https://www.youtube.com/embed/A3nsjkhlj2s" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
  int[] preorder, inorder;
  public TreeNode buildTree(int[] preorder, int[] inorder) {
    this.preorder = preorder;
    this.inorder = inorder;
    return helper(0, 0, inorder.length - 1);
  }
  
  TreeNode helper(int preStart, int inStart, int inEnd) {
    if (inStart > inEnd) return null;
    int val = preorder[preStart];
    TreeNode node = new TreeNode(val);
    int inIndex = 0;
    for (int i = inStart; i <= inEnd; i++) {
      if (inorder[i] == val) {
        inIndex = i;
      }
    }
    int size = inIndex - inStart;
    node.left = helper(preStart + 1, inStart, inIndex - 1);
    node.right = helper(preStart + size + 1, inIndex + 1, inEnd);
    return node;
  }

}
```

### 例题4: 从中序与后序遍历序列构造二叉树
[从中序与后序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220726165511.png)

代码：
```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
  int[] inorder;
  int[] postorder;
  public TreeNode buildTree(int[] inorder, int[] postorder) {
    this.inorder = inorder;
    this.postorder = postorder;
    return helper(postorder.length - 1 , 0, inorder.length - 1);
  }

  TreeNode helper(int postStart, int inStart, int inEnd) {
    if (inStart > inEnd) return null;
    int val = postorder[postStart];
    TreeNode node = new TreeNode(val);
    int inIndex = 0;
    for (int i = inStart; i <= inEnd; i++) {
      if (inorder[i] == val) {
        inIndex = i;
      }
    }
    int size = inEnd - inIndex;
    node.right = helper(postStart - 1, inIndex + 1, inEnd);
    node.left = helper(postStart - size - 1, inStart, inIndex -1);
    return node;
  }

}
```

### 例题5: 根据前序和后序遍历构造二叉树
[根据前序和后序遍历构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-postorder-traversal/)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220726191753.png)

基本思路：preorder左子树第一个孩子，就是postorder左子树的最后一个孩子

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
  int[] preorder, postorder;
  int n;
  Map<Integer, Integer> map = new HashMap();
  public TreeNode constructFromPrePost(int[] preorder, int[] postorder) {
    this.preorder = preorder;
    this.postorder = postorder;
    n = preorder.length;
    for (int i = 0; i < n; i++) {
      map.put(postorder[i], i);
    }
    return helper(0, 0, n - 1);
  }
  
  TreeNode helper(int preStart, int postStart, int postEnd) {
    if (preStart > n || postStart > postEnd) return null;
    TreeNode node = new TreeNode(preorder[preStart++]);
    if (preStart == n || postStart == postEnd) return node;
    int postIndex = map.get(preorder[preStart]);
    node.left = helper(preStart, postStart, postIndex);
    node.right = helper(preStart + postIndex - postStart + 1, postIndex + 1, postEnd - 1);
    return node;
  }
}
```


## 完全二叉树
### 例题1: 完全二叉树插入器
[完全二叉树插入器](https://leetcode.cn/problems/complete-binary-tree-inserter/)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220725143911.png)

#### 分析 
参考引用：https://leetcode.cn/problems/complete-binary-tree-inserter/solution/wan-quan-er-cha-shu-cha-ru-qi-by-leetcod-lf8t/

对于一棵完全二叉树而言，其除了最后一层之外都是完全填充的，并且最后一层的节点全部在最左侧。那么，只有倒数第二层（如果存在）最右侧的若干个节点，以及最后一层的全部节点可以再添加子节点，其余的节点都已经拥有两个子节点。

因此，我们可以使用一个队列存储上述提到的这些可以添加子节点的节点。队列中的存储顺序为：首先「从左往右」存储倒数第二层最右侧的节点，再「从左往右」存储最后一层的全部节点。这一步可以使用广度优先搜索来完成，因为广度优先搜索就是按照层优先进行遍历的。

随后，当我们每次调用 insert(val) 时，我们就创建出一个节点 child，并将它最为队列的队首节点的子节点。在这之后，我们需要把child加入队尾，并且如果对队首节点已经有两个子节点，我们需要将其从队列中移除。

代码：
```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class CBTInserter {
  
  Queue<TreeNode> candidate = new LinkedList();
  TreeNode root;

  public CBTInserter(TreeNode root) {
    this.root = root;
    Queue<TreeNode> queue = new LinkedList();
    queue.add(root);
    
    while (!queue.isEmpty()) {
      TreeNode currentNode = queue.poll();
      if (currentNode.left != null) {
        queue.add(currentNode.left);
      }
      if (currentNode.right != null) {
        queue.add(currentNode.right);
      }
      if (currentNode.left == null || currentNode.right == null) {
        candidate.add(currentNode);
      }
    }

  }
  
  public int insert(int val) {
    TreeNode currentNode = candidate.peek();
    TreeNode newNode = new TreeNode(val);
    if (currentNode.left == null) {
      currentNode.left = newNode;
    } else if (currentNode.right == null) {
      currentNode.right = newNode;
      candidate.poll();
    }
    candidate.add(newNode);
    return currentNode.val;
  }
  
  public TreeNode get_root() {
    return root;
  }
}
```

### 例题2: 完全二叉树的节点个数
[完全二叉树的节点个数](https://leetcode.cn/problems/count-complete-tree-nodes/)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220725153009.png)

#### 分析
- 参考链接：https://labuladong.github.io/algo/2/21/48/

如何求一棵完全二叉树的节点个数呢？如果是一个普通二叉树，显然只要向下面这样遍历一边即可，时间复杂度 O(N)：
```java
public int countNodes(TreeNode root) {
    if (root == null) return 0;
    return 1 + countNodes(root.left) + countNodes(root.right);
}
```
那如果是一棵满二叉树，节点总数就和树的高度呈指数关系：
```java
public int countNodes(TreeNode root) {
    int h = 0;
    // 计算树的高度
    while (root != null) {
        root = root.left;
        h++;
    }
    // 节点总数就是 2^h - 1
    return (int)Math.pow(2, h) - 1;
}
```
完全二叉树比普通二叉树特殊，但又没有满二叉树那么特殊，计算它的节点总数，可以说是普通二叉树和完全二叉树的结合版，先看代码：
```java
public int countNodes(TreeNode root) {
    TreeNode l = root, r = root;
    // 沿最左侧和最右侧分别计算高度
    int hl = 0, hr = 0;
    while (l != null) {
        l = l.left;
        hl++;
    }
    while (r != null) {
        r = r.right;
        hr++;
    }
    // 如果左右侧计算的高度相同，则是一棵满二叉树
    if (hl == hr) {
        return (int)Math.pow(2, hl) - 1;
    }
    // 如果左右侧的高度不同，则按照普通二叉树的逻辑计算
    return 1 + countNodes(root.left) + countNodes(root.right);
}
```

#### 复杂度分析
这个算法的时间复杂度是`O(logN*logN)`，这是怎么算出来的呢？

直觉感觉好像最坏情况下是 `O(N*logN)` 吧，因为之前的 while 需要 logN 的时间，最后要 O(N) 的时间向左右子树递归：
```java
return 1 + countNodes(root.left) + countNodes(root.right);
```
关键点在于，这两个递归只有一个会真的递归下去，另一个一定会触发 `hl == hr` 而立即返回，不会递归下去。

为什么呢？原因如下：

**一棵完全二叉树的两棵子树，至少有一棵是满二叉树：**

![](https://raw.githubusercontent.com/NaisWang/images/master/20220725153405.png)

看图就明显了吧，由于完全二叉树的性质，其子树一定有一棵是满的，所以一定会触发 `hl == hr`，只消耗 `O(logN)` 的复杂度而不会继续递归。

综上，算法的递归深度就是树的高度 `O(logN)`，每次递归所花费的时间就是 while 循环，需要 `O(logN)`，所以总体的时间复杂度是 `O(logN*logN)`。

所以说，「完全二叉树」这个概念还是有它存在的原因的，不仅适用于数组实现二叉堆，而且连计算节点总数这种看起来简单的操作都有高效的算法实现。

## 二叉搜索树

<div class="container">
  <iframe src="https://drive.google.com/file/d/1tepmYvCdcaZCt1YVoLi4pcJd30dNTaND/preview" width="640" height="480" allow="autoplay"></iframe>
</div>

### 例题1: 二叉搜索树中第K小的元素
[二叉搜索树中第K小的元素](https://leetcode.cn/problems/kth-smallest-element-in-a-bst/)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220727102955.png)

代码：
```java
class Solution {
  int ans = 0;
  int k = 0;
  public int kthSmallest(TreeNode root, int k) {
    this.k = k;
    dfs(root);
    return ans;
  }

  void dfs(TreeNode root) {
    if (root == null) return;
    dfs(root.left);
    k--;
    if (k == 0) {
      ans = root.val; 
      return;
    }
    dfs(root.right);
  }
}
```

### 例题2: 把二叉搜索树转换为累加树
[把二叉搜索树转换为累加树](https://leetcode.cn/problems/convert-bst-to-greater-tree/)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220727103830.png)

代码：
```java
class Solution {
  int sum = 0;
  public TreeNode convertBST(TreeNode root) {
    traversal(root);
    return root;
  }

  void traversal(TreeNode root) {
    if (root == null) return;
    traversal(root.right);
    sum += root.val;
    root.val = sum;
    traversal(root.left);
  }
  
}
```

### 例题3: 二叉搜索树中的搜索
[二叉搜索树中的搜索](https://leetcode.cn/problems/search-in-a-binary-search-tree/)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220727113221.png)

这题可以看成隐式图上的DFS算法，直接套模版

代码：
```java
class Solution {
  public TreeNode searchBST(TreeNode root, int val) {
    if (root.val == val) return root;
    List<TreeNode> nextNodes = new ArrayList();
    if (root.left != null) {
      nextNodes.add(root.left);
    }
    if (root.right != null) {
      nextNodes.add(root.right);
    }
    for (TreeNode nextNode : nextNodes) {
      TreeNode temp = searchBST(nextNode, val);
      if (temp != null) return temp;
    }
    return null;
  }
}
```

### 例题4: 删除二叉搜索树中的节点
[删除二叉搜索树中的节点](https://leetcode.cn/problems/delete-node-in-a-bst/)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220726222457.png)

#### 分析

<div class="container">
  <iframe width="560" height="315" src="https://www.youtube.com/embed/2hahrf3K8o4" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>

代码：
```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
  // 该函数的功能：返回删除指定节点后的树的根节点
  public TreeNode deleteNode(TreeNode root, int key) {
    if (root == null) return null; 
    if (root.val > key) root.left = deleteNode(root.left, key);
    else if (root.val < key) root.right = deleteNode(root.right, key);
    else if (root.left == null) return root.right;
    else if (root.right == null) return root.left;
    else {
      root.val = getMin(root.right);
      root.right = deleteNode(root.right, root.val);
    }
    return root;
  }

  int getMin(TreeNode node) {
    while (node.left != null) node = node.left;
    return node.val;
  }
}
```

### 例题5: 验证二叉搜索树
[验证二叉搜索树](https://leetcode.cn/problems/validate-binary-search-tree/)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220727093717.png)

代码：
```java
class Solution {

  public boolean isValidBST(TreeNode root) {
    return isValidBST(root, Long.MAX_VALUE, Long.MIN_VALUE);
  }

  boolean isValidBST(TreeNode root, long max, long min) {
    if (root == null) return true;
    if (root.val <= min || root.val >= max) return false;
    return isValidBST(root.left, root.val, min) && isValidBST(root.right, max, root.val);
  }
}
```

### 例题6: 二叉搜索树迭代器
[二叉搜索树迭代器](https://leetcode.cn/problems/binary-search-tree-iterator/)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220727095401.png)

#### 分析
此题的难点在于只能使用O(h)内存。而解决方法就是用栈保存所有最左的节点

![](https://raw.githubusercontent.com/NaisWang/images/master/20220727095542.png)

代码：
```java
class BSTIterator {

  Stack<TreeNode> stack;

  public BSTIterator(TreeNode root) {
    stack = new Stack();
    pushAllLeft(root);
  }

  void pushAllLeft(TreeNode node) {
    while (node != null) {
      stack.push(node);
      node = node.left;
    }
  }
  
  public int next() {
    TreeNode node = stack.pop();
    pushAllLeft(node.right);
    return node.val;
  }
  
  public boolean hasNext() {
    return !stack.isEmpty();
  }
}
```

### 例题7: 不同的二叉搜索树
[不同的二叉搜索树](https://leetcode.cn/problems/unique-binary-search-trees/)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220727143858.png)

#### 分析
参考链接：
- https://mp.weixin.qq.com/s/kcwz2lyRxxOsC3n11qdVSw
- https://leetcode.cn/problems/unique-binary-search-trees/solution/bu-tong-de-er-cha-sou-suo-shu-by-leetcode-solution/

给定一个有序序列`1...n`，为了构建出一棵二叉搜索树，我们可以遍历每个数字i，将该数字作为树根，将`1...(i−1)` 序列作为左子树，将 `(i+1)...n` 序列作为右子树。接着我们可以按照同样的方式递归构建左子树和右子树。

在上述构建的过程中，由于根的值不同，因此我们能保证每棵二叉搜索树是唯一的。

由此可见，原问题可以分解成规模较小的两个子问题，且子问题的解可以复用。因此，我们可以想到使用分治法来求解本题。

状态：`dp[i,j]`: 表示闭区间[i, j]组成的BST个数

代码：
```java
class Solution {

  public int numTrees(int n) {
    return dfs(1, n);
  }

  int dfs(int i, int j) {
    if (i >= j) return 1;
    int res = 0;
    for (int root = i; root <= j; root++) {
      // root的值作为根节点的root
      int leftCnt = dfs(i, root - 1);
      int rightCnt= dfs(root + 1, j);
      // 左右子树的组合数乘积是 BST 的总数
      res += leftCnt * rightCnt;
    }
    return res;
  }

}
```

### 例题8: 不同的二叉搜索树 II
[不同的二叉搜索树 II](https://leetcode.cn/problems/unique-binary-search-trees-ii/)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220727150940.png)

#### 分析
参考链接：
- https://mp.weixin.qq.com/s/kcwz2lyRxxOsC3n11qdVSw
- https://leetcode.cn/problems/unique-binary-search-trees-ii/solution/bu-tong-de-er-cha-sou-suo-shu-ii-by-leetcode-solut/

代码：
```java
class Solution {

  boolean[] visited;
  public List<TreeNode> generateTrees(int n) {
    return dfs(1, n);
  }

  List<TreeNode> dfs(int i, int j) {
    List<TreeNode> res = new ArrayList();
    if (i > j) {
      res.add(null);
      return res;
    }
    for (int root = i; root <= j; root++) {
      List<TreeNode> leftTrees = dfs(i, root - 1);
      List<TreeNode> rightTrees = dfs(root + 1, j);
      for (TreeNode leftTree : leftTrees) {
        for (TreeNode rightTree : rightTrees) {
          TreeNode rootNode = new TreeNode(root);
          rootNode.left = leftTree;
          rootNode.right = rightTree;
          res.add(rootNode);
        }
      }
    }
    return res;
  }
}
```

## 最近公共祖先LCA
### 例题1: 二叉搜索树的最近公共祖先
[二叉搜索树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220724203652.png)

代码：
```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */

class Solution {
  public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
    if (root.val > p.val && root.val > q.val) return lowestCommonAncestor(root.left, p, q);
    if (root.val < p.val && root.val < q.val) return lowestCommonAncestor(root.right, p, q);
    return root;
  }
}
```

### 例题2: 二叉树的最近公共祖先
[二叉树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220724203747.png)

代码：
```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
  // 在root为根的二叉树中找到A, B的LCA
  // 如果找到了就返回这个LCA
  // 如果只碰到A，就返回A
  // 如果只碰到B，就返回B
  // 如果没有，就返回null
  public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
    if (root == null || p == root || q == root) return root;
    TreeNode left = lowestCommonAncestor(root.left, p, q);
    TreeNode right = lowestCommonAncestor(root.right, p, q);
    if (left != null && right != null) return root;
    if (left != null) return left;
    if (right != null) return right;
    return null;
  }
}
```

### 例题3: 最深叶节点的最近公共祖先
[最深叶节点的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-deepest-leaves/)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220726202101.png)

#### 分析
<div class="container">
  <iframe width="560" height="315" src="https://www.youtube.com/embed/9zQHDE5wvbU" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>

代码：
```java
class Solution {
  public TreeNode lcaDeepestLeaves(TreeNode root) {
    return dfs(root, 0).getKey();
  }

  Map.Entry<TreeNode, Integer> dfs(TreeNode root, Integer height) {
    if (root == null) return Map.entry(new TreeNode(-1), height);
    Map.Entry<TreeNode, Integer> left = dfs(root.left, height + 1);
    Map.Entry<TreeNode, Integer> right = dfs(root.right, height + 1);
    if (left.getValue() == right.getValue()) {
      return Map.entry(root, left.getValue());
    }
    return left.getValue() > right.getValue() ? left : right;
  }
}
```

### 倍增法求LCA
<div class="container">
  <iframe width="560" height="315" src="https://www.youtube.com/embed/YFOcVHsBO78" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>

<div class="container">
  <iframe src="https://drive.google.com/file/d/1S0TDNDZpNpNBsNZm0NBEgHEUTTa-7dcL/preview" width="640" height="480" allow="autoplay"></iframe>
</div>

<div class="container">
  <iframe width="560" height="315" src="https://www.youtube.com/embed/161vSYEqJVE" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>


#### 只需要求两个节点的LCA
##### 模版
```java
class LCA {
  // F[i][j]表示从i节点向上走2^j步
  int F[][];
  // 存储节点的深度
  int[] dep;
  // 使用邻接表来存储树
  List<Integer>[] tree;
  // 最多可以跳2^k步
  int k;

  /**
   * @param root 树的根节点
   */
  public LCA(List<Integer>[] tree, Integer root) {
    this.tree = tree;
    int n = tree.length;
    dep = new int[n];
    k = (int) (Math.log(n) / Math.log(2));
    F = new int[n][k + 1];
    // 初始化
    dep[root] = 1;
    dfs(root);
  }

  /**
   * @param v 当前节点
   */
  void dfs(int v) {
    for (int i = 1; (1 << i) <= dep[v]; i++) {
      F[v][i] = F[F[v][i - 1]][i - 1];
    }
    // 遍历当前当前节点的子节点
    for (int child : tree[v]) {
      dep[child] = dep[v] + 1;
      F[child][0] = v;
      dfs(child);
    }
  }

  /**
   * 查询x节点与y节点的最近公共祖先
   */
  int getLCA(int x, int y) {
    if (dep[x] < dep[y]) {
      int temp = x;
      x = y;
      y = temp;
    }
    for (int i = k; i >= 0; i--) {
      if (dep[F[x][i]] >= dep[y]) {
        x = F[x][i];
      }
      if (x == y) {
        return x;
      }
    }
    for (int i = k; i >= 0; i--) {
      if (F[x][i] != F[y][i]) {
        x = F[x][i];
        y = F[y][i];
      }
    }
    return F[x][0];
  }

}
```

##### 例题1: Nearest Common Ancestors
[Nearest Common Ancestors](http://poj.org/problem?id=1330)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220607152246.png)

代码：
```java
int T = cin.nextInt();

public void solve() {
  while (T-- != 0) {
    int N = cin.nextInt();
    List<Integer>[] tree = new List[N + 1];
    for (int i = 1; i <= N; i++) {
      tree[i] = new ArrayList();
    }
    // flag[i]==true表示有指向i节点的节点
    boolean[] flag = new boolean[N + 1];
    for (int i = 0; i < N - 1; i++) {
      int a = cin.nextInt();
      int b = cin.nextInt();
      tree[a].add(b);
      flag[b] = true;
    }
    // 查找tree的根节点
    int root = -1;
    for (int i = 1; i <= N; i++) {
      if (!flag[i]) {
        root = i;
        break;
      }
    }
    LCA lac = new LCA(tree, root);
    int x = cin.nextInt();
    int y = cin.nextInt();
    System.out.println(lac.getLCA(x, y));
  }
}

class LCA {
  // F[i][j]表示从i节点向上走2^j步
  int F[][];
  // 存储节点的深度
  int[] dep;
  // 使用邻接表来存储树
  List<Integer>[] tree;
  // 最多可以跳2^k步
  int k;

  /**
   * @param root 树的根节点
   */
  public LCA(List<Integer>[] tree, Integer root) {
    this.tree = tree;
    int n = tree.length;
    dep = new int[n];
    k = (int) (Math.log(n) / Math.log(2));
    F = new int[n][k + 1];
    // 初始化
    dep[root] = 1;
    dfs(root);
  }

  /**
   * @param v 当前节点
   */
  void dfs(int v) {
    for (int i = 1; (1 << i) <= dep[v]; i++) {
      F[v][i] = F[F[v][i - 1]][i - 1];
    }
    // 遍历当前当前节点的子节点
    for (int child : tree[v]) {
      dep[child] = dep[v] + 1;
      F[child][0] = v;
      dfs(child);
    }
  }

  /**
   * 查询x节点与y节点的最近公共祖先
   */
  int getLCA(int x, int y) {
    if (dep[x] < dep[y]) {
      int temp = x;
      x = y;
      y = temp;
    }
    for (int i = k; i >= 0; i--) {
      if (dep[F[x][i]] >= dep[y]) {
        x = F[x][i];
      }
      if (x == y) {
        return x;
      }
    }
    for (int i = k; i >= 0; i--) {
      if (F[x][i] != F[y][i]) {
        x = F[x][i];
        y = F[y][i];
      }
    }
    return F[x][0];
  }

}

}
```

#### 扩展成要求任何两点之间的距离
##### 模版
```java
class LCA {
  // F[i][j]表示从i节点向上走2^j步
  int F[][];
  // 存储节点的深度
  int[] dep;
  // dist[i]表示表示节点i到根节点的距离
  int[] dist;
  // 使用邻接表来存储树
  List<int[]>[] tree;
  // 最多可以跳2^k步
  int k;

  public LCA(List<int[]>[] tree, Integer root) {
    this.tree = tree;
    int n = tree.length;
    dep = new int[n];
    dist = new int[n];
    k = (int) (Math.log(n) / Math.log(2));
    F = new int[n][k + 1];
    // 初始化
    dep[root] = 1;
    dfs(root);
  }

  /**
   * @param v 当前节点
   */
  void dfs(int v) {
    for (int i = 1; (1 << i) <= dep[v]; i++) {
      F[v][i] = F[F[v][i - 1]][i - 1];
    }
    for (int[] child : tree[v]) {
      dep[child[0]] = dep[v] + 1;
      dist[child[0]] = dist[v] + child[1];
      F[child[0]][0] = v;
      dfs(child[0]);
    }
  }

  /**
   * 查询x节点与y节点的最近公共祖先
   */
  int getLCA(int x, int y) {
    if (dep[x] < dep[y]) {
      int temp = x;
      x = y;
      y = temp;
    }
    for (int i = k; i >= 0; i--) {
      if (dep[F[x][i]] >= dep[y]) {
        x = F[x][i];
      }
      if (x == y) {
        return x;
      }
    }
    for (int i = k; i >= 0; i--) {
      if (F[x][i] != F[y][i]) {
        x = F[x][i];
        y = F[y][i];
      }
    }
    return F[x][0];
  }

  /**
   * 查询x节点与y节点的之间的距离
   */
  int getDist(int x, int y) {
    int lac = getLCA(x, y);
    return dist[x] + dist[y] - 2 * dist[lac];
  }

}
```

##### 例题1：How far away ？
[How far away ？](http://acm.hdu.edu.cn/showproblem.php?pid=2586)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220607165201.png)

代码：
```java
int T = cin.nextInt();

public void solve() {
  while (T-- != 0) {
    int n = cin.nextInt();
    int m = cin.nextInt();
    List<int[]>[] tree = new List[n + 1];
    for (int i = 1; i <= n; i++) {
      tree[i] = new ArrayList<>();
    }
    // flag[i]==true表示有指向i节点的节点
    boolean[] flag = new boolean[n + 1];
    for (int i = 1; i < n; i++) {
      int a = cin.nextInt();
      int b = cin.nextInt();
      int k = cin.nextInt();
      tree[a].add(new int[]{b, k});
      flag[b] = true;
    }
    // 查找tree的根节点
    int root = -1;
    for (int i = 1; i <= n; i++) {
      if (!flag[i]) {
        root = i;
        break;
      }
    }
    LCA lac = new LCA(tree, root);
    while (m-- != 0) {
      int x = cin.nextInt();
      int y = cin.nextInt();
      System.out.println(lac.getDist(x, y));
    }
  }
}

class LCA {
  // F[i][j]表示从i节点向上走2^j步
  int F[][];
  // 存储节点的深度
  int[] dep;
  // dist[i]表示表示节点i到根节点的距离
  int[] dist;
  // 使用邻接表来存储树
  List<int[]>[] tree;
  // 最多可以跳2^k步
  int k;

  public LCA(List<int[]>[] tree, Integer root) {
    this.tree = tree;
    int n = tree.length;
    dep = new int[n];
    dist = new int[n];
    k = (int) (Math.log(n) / Math.log(2));
    F = new int[n][k + 1];
    // 初始化
    dep[root] = 1;
    dfs(root);
  }

  /**
   * @param v 当前节点
   */
  void dfs(int v) {
    for (int i = 1; (1 << i) <= dep[v]; i++) {
      F[v][i] = F[F[v][i - 1]][i - 1];
    }
    for (int[] child : tree[v]) {
      dep[child[0]] = dep[v] + 1;
      dist[child[0]] = dist[v] + child[1];
      F[child[0]][0] = v;
      dfs(child[0]);
    }
  }

  /**
   * 查询x节点与y节点的最近公共祖先
   */
  int getLCA(int x, int y) {
    if (dep[x] < dep[y]) {
      int temp = x;
      x = y;
      y = temp;
    }
    for (int i = k; i >= 0; i--) {
      if (dep[F[x][i]] >= dep[y]) {
        x = F[x][i];
      }
      if (x == y) {
        return x;
      }
    }
    for (int i = k; i >= 0; i--) {
      if (F[x][i] != F[y][i]) {
        x = F[x][i];
        y = F[y][i];
      }
    }
    return F[x][0];
  }

  /**
   * 查询x节点与y节点的之间的距离
   */
  int getDist(int x, int y) {
    int lac = getLCA(x, y);
    return dist[x] + dist[y] - 2 * dist[lac];
  }

}
```

# 图论

<div class="container">
  <iframe src="https://drive.google.com/file/d/1tR9QKcnBXvdVaQQOByffi8BKGjrXuxIA/preview" width="640" height="480" allow="autoplay"></iframe>
</div>

<div class="container">
  <iframe width="560" height="315" src="https://www.youtube.com/embed/OBEHTlAdUrI" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>

<div class="container">
  <iframe width="560" height="315" src="https://www.youtube.com/embed/w89GTZApgIs" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>

## 图的逻辑结构和具体实现
### 邻接表与邻接矩阵
参考：
- https://labuladong.gitee.io/algo/2/20/47/

---

一幅图是由节点和边构成的，逻辑结构如下：

![](https://raw.githubusercontent.com/NaisWang/images/master/20220531152018.png)


**什么叫「逻辑结构」？就是说为了方便研究，我们把图抽象成这个样子。**

根据这个逻辑结构，我们可以认为每个节点的实现如下：
```java
/* 图节点的逻辑结构 */
class Vertex {
    int id;
    Vertex[] neighbors;
}
```

看到这个实现，你有没有很熟悉？它和我们之前说的多叉树节点几乎完全一样：
```java
/* 基本的 N 叉树节点 */
class TreeNode {
    int val;
    TreeNode[] children;
}
```

所以说，图真的没啥高深的，本质上就是个高级点的多叉树而已，适用于树的 DFS/BFS 遍历算法，全部适用于图。

不过呢，上面的这种实现是「逻辑上的」，实际上我们很少用这个`Vertex`类实现图，而是用常说的邻接表和邻接矩阵来实现。

比如还是刚才那幅图：

![](https://raw.githubusercontent.com/NaisWang/images/master/20220531152313.png)

用邻接表和邻接矩阵的存储方式如下：

![](https://raw.githubusercontent.com/NaisWang/images/master/20220531152338.png)

邻接表很直观，我把每个节点`x`的邻居都存到一个列表里，然后把`x`和这个列表关联起来，这样就可以通过一个节点`x`找到它的所有相邻节点。

邻接矩阵则是一个二维布尔数组，我们权且称为`matrix`，如果节点`x` 和 `y` 是相连的，那么就把 `matrix[x][y]` 设为 `true`（上图中绿色的方格代表 `true`）。如果想找节点 `x` 的邻居，去扫一圈 `matrix[x][..]` 就行了。

如果用代码的形式来表现，邻接表和邻接矩阵大概长这样：

```java
// 邻接表
// graph[x] 存储节点x 的所有邻居节点
List<Integer>[] graph;

// 邻接矩阵
// matrix[x][y] 记录节点x 是否有一条指向 y 的边
boolean[][] matrix;
```

**那么，为什么有这两种存储图的方式呢？肯定是因为他们各有优劣。**

对于邻接表，好处是占用的空间少。

你看邻接矩阵里面空着那么多位置，肯定需要更多的存储空间。

但是，邻接表无法快速判断两个节点是否相邻。

比如说我想判断节点 1 是否和节点 3 相邻，我要去邻接表里 1 对应的邻居列表里查找 3 是否存在。但对于邻接矩阵就简单了，只要看看 `matrix[1][3]` 就知道了，效率高。

所以说，使用哪一种方式实现图，要看具体情况。

> PS：在常规的算法题中，邻接表的使用会更频繁一些，主要是因为操作起来较为简单，但这不意味着邻接矩阵应该被轻视。矩阵是一个强有力的数学工具，图的一些隐晦性质可以借助精妙的矩阵运算展现出来。不过本文不准备引入数学内容，所以有兴趣的读者可以自行搜索学习。

那你可能会问，我们上面说的这个图的模型仅仅是「有向无权图」，不是还有什么加权图，无向图，等等……

其实，这些更复杂的模型都是基于这个最简单的图衍生出来的。

有向加权图怎么实现？很简单呀：

如果是邻接表，我们不仅仅存储某个节点 x 的所有邻居节点，还存储 x 到每个邻居的权重，不就实现加权有向图了吗？

如果是邻接矩阵，`matrix[x][y]` 不再是布尔值，而是一个 int 值，0 表示没有连接，其他值表示权重，不就变成加权有向图了吗？

如果用代码的形式来表现，大概长这样：

```java
// 邻接表
// graph[x] 存储节点x 的所有邻居节点以及对应的权重
// from -> List<(to, weight)>
// graph[from].add(new int[]{to, weight}); 
List<int[]>[] graph;

// 邻接矩阵
// matrix[x][y] 记录 x 指向 y 的边的权重，0 表示不相邻
int[][] matrix;
```

无向图怎么实现？也很简单，所谓的「无向」，是不是等同于「双向」？

![](https://raw.githubusercontent.com/NaisWang/images/master/20220531152900.png)

如果连接无向图中的节点 x 和 y，把`matrix[x][y]`和`matrix[y][x]` 都变成 true 不就行了；邻接表也是类似的操作，在 x 的邻居列表里添加 y，同时在 y 的邻居列表里添加 x。

把上面的技巧合起来，就变成了无向加权图

### 边集数组
边集数组由两个一维数组构成：
- 一个存储顶点信息。
- 一个存储边的信息，这个边数组每个数据元素由一条边的起点下标（begin）、终点下标（end）、和权（weight）组成。

![](https://raw.githubusercontent.com/NaisWang/images/master/20220602095849.png)

实现方式：
```java
int[][] edges =  { {0,1,100}, {1,2,100}, {0,2,500} }
```

```java
Edge[] edges = new ArrayList();
edges.add(new Edge(0, 1, 100));
edges.add(new Edge(1, 2, 100));
edges.add(new Edge(0, 2, 500));

class Edge {
  int begin, end, weight;

  Edge(int begin, int end, int weight) {
    begin = begin;
    end = end;
    weight = weight;
  }
}
```

边集数组适用场景：
- 边集数组关注的是边的集合，在边集数组中要查找一个顶点的度需要扫描整个边数组，效率并不高。
- 因此它更适合对边依次进行处理的操作，而不适合对顶点相关的操作。

例如： Bellman-Ford算法中使用了边集数组来存储图

### 链式前向星

<div class="container">
  <iframe width="560" height="315" src="https://www.youtube.com/embed/CrQSuA9JibU" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>

<div class="container">
  <iframe width="560" height="315" src="https://www.youtube.com/embed/fNPI5UQeJjU" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>

<div class="container">
  <iframe src="https://docs.google.com/document/d/e/2PACX-1vSE5-XNTFLefwz5oVJlJh21f_K5cGuikjhPQghcZZgmxqQV0GktdWsjTq3FhD3Ib8bABMLkv8awhsMb/pub?embedded=true"></iframe>
</div>

## 无向图的连通性
### 静态图的算法 -- DFS/BFS

在使用DFS/BFS来解决无向图的连通性问题时，第一步要做的就是**构建图的逻辑结构**。如果一个题目没有帮你构建好了图的逻辑结构，那么你还得需要自己构建图的逻辑结构，这就比较麻烦了，所以此时推荐使用并查集来实现。

#### BFS实现模版
```java
// key表示节点/状态，value表示该节点/状态所属于的连通分支。
// 该stateToComponentId可以作为visited使用, 即当stateToComponentId.containsKey(i) == false时，表示i节点没有被访问，反之，则被访问了
Map<State, Integer> stateToComponentId = new HashMap<>();

int findComponents() {
  // 现在所求的连通分支标识
  int currentComponentId = 0;

  // 遍历每个节点/状态
  for (State state : States) {
    if (!stateToComponentId.containsKey(state)) {
      bfs(state, ++currentComponentId);
    }
  }
  return currentComponentId;
}

void bfs(State startState, Integer currentComponentId) {
  Queue<State> queue = new LinkedList();

  queue.add(startState);
  stateToComponentId.put(startState, currentComponentId);

  while (!queue.isEmpty()) {
    State currentState = queue.poll();

    List<int[]> nextStateList = getNextStateList();

    for (State nextStateList : nextStateList) {
      if (!stateToComponentId.containsKey(nextState)) {
        stateToComponentId.put(nextState, currentComponentId);
        queue.add(nextState);
      }
    }
  }
}

class State {

}
```


#### DFS实现模版
**使用类表示节点状态：**
```java
// key表示节点/状态，value表示该节点/状态所属于的连通分支。
// 该stateToComponentId可以作为visited使用, 即当stateToComponentId.containsKey(i) == false时，表示i节点没有被访问，反之，则被访问了
Map<State, Integer> stateToComponentId = new HashMap<>();

int findComponents() {

  // 现在所求的连通分支标识
  int currentComponentId = 0;

  // 遍历每个节点/状态
  for (State state : States) {
    if (!stateToComponentId.containsKey(state)) {
      dfs(state, ++currentComponentId);
    }
  }
  return currentComponentId;
}

void dfs(State startState, Integer currentComponentId) {

  List<int[]> nextStateList = getNextStateList();

  for (State nextState : nextStateList) {
    if (!stateToComponentId.containsKey(nextState)) {
      stateToComponentId.put(nextState, currentComponentId);
      dfs(nextState, currentComponentId);
    }
  }
}

class State {

}
```

**使用数组表示节点状态：**
```
// 数组下标表示状态，value表示该节点/状态所属于的连通分支。
// 该stateToComponentId可以作为visited使用, 即当stateToComponentId[]... == null时，表示该状态没有被访问，反之，则被访问了
Integer[]... stateToComponentId = new Integer[]...;

int findComponent() {

  // 现在所求的连通分支标识
  int currentCompoentId = 0;

  // 遍历每个节点/状态
  for (int[] state : States) {
    if (stateToComponentId[state[0]]... == null) {
      dfs(state, ++currentCompoentId);
    }
  }

  return currentCompoentId;
}

void dfs(int[] currentState, int currentCompoentId) {

  List<int[]> nextStateList = getNextStateList();

  for (int[] nextState : nextStateList) {
    if (stateToComponentId[nextState[0]]... == null) {
      stateToComponentId[nextState[0]]... = currentCompoentId
      dfs(nextState, currentCompoentId);
    }
  }
}
```


#### 例题1: 省份数量
[省份数量](https://leetcode.cn/problems/number-of-provinces/)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220605223032.png)

DFS代码:
```java
class Solution {
  int[][] isConnected;
  int[] visited;
  public int findCircleNum(int[][] isConnected) {
    this.visited = new int[isConnected.length];
    this.isConnected = isConnected;
    return findComponent();
  }

  int findComponent() {
    int res = 0;
    for (int i = 0; i < isConnected.length; i++) {
      if (visited[i] == 0) {
        dfs(i);
        res++;
      }
    }
    return res;
  }

  void dfs(Integer state) {
    List<Integer> nextStateList = new ArrayList();
    for (int i = 0; i < isConnected.length; i++) {
      if (state != i && isConnected[state][i] == 1) {
        nextStateList.add(i);
      }
    }
    for (Integer nextState : nextStateList) {
      if (visited[nextState] == 0) {
        visited[nextState] = 1;
        dfs(nextState);
      }
    }
  }
}
```

#### 例题2: 岛屿数量
[岛屿数量](https://leetcode.cn/problems/number-of-islands/)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220605230048.png)

DFS代码：
```java
class Solution {
  char[][] grid;
  Integer[][] stateToComponentId;
  public int numIslands(char[][] grid) {
    this.grid = grid;
    stateToComponentId = new Integer[grid.length][grid[0].length];
    return findComponent();
  }
  

  int findComponent() {
    int currentCompoentId = 0;

    for (int r = 0; r < grid.length; r++) {
      for (int c = 0; c < grid[r].length; c++) {
        if (stateToComponentId[r][c] == null && grid[r][c] == '1') {
          stateToComponentId[r][c] = ++currentCompoentId;
          dfs(new int[]{r, c}, currentCompoentId);
        }
      }
    }

    return currentCompoentId;
  }

  void dfs(int[] currentState, int currentCompoentId) {
    List<int[]> nextStateList = new ArrayList();
    int[] dr = {-1, 1, 0, 0};  
    int[] dc = {0, 0, -1, 1};
    for (int i = 0; i < 4; i++) {
      int nr = currentState[0] + dr[i];
      int nc = currentState[1] + dc[i];
      if (nr >= 0 && nr < grid.length && nc >= 0 && nc < grid[0].length && grid[nr][nc] == '1') {
        nextStateList.add(new int[]{nr, nc}); 
      } 
    }

    for (int[] nextState : nextStateList) {
      if (stateToComponentId[nextState[0]][nextState[1]] == null) {
        stateToComponentId[nextState[0]][nextState[1]] = currentCompoentId;
        dfs(nextState, currentCompoentId);
      }
    }

  }
}
```

#### 例题3：统计无向图中无法互相到达点对数
[统计无向图中无法互相到达点对数](https://leetcode.cn/problems/count-unreachable-pairs-of-nodes-in-an-undirected-graph/)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220718160200.png)

<div class="container">
  <iframe width="560" height="315" src="https://www.youtube.com/embed/P8cpKzUJP_Q" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>

- 对于无向图，有`n(n-1)/2`条边的无向图称为完全图，在完全图中任意两个顶点之间都存在边
- 对于有向图，有`n(n-1)`条边的有向图称为有向完全图，在有向完全图中任意两个顶点之间都存在方向相反的两条弧

DFS代码：
```java
class Solution {
  List<Integer>[] graph;
  public long countPairs(int n, int[][] edges) {
    graph = new List[n];
    stateToComponentId = new Integer[n];
    for (int i = 0; i < n; i++) {
      graph[i] = new ArrayList();
    }
    for (int[] edge : edges) {
      graph[edge[0]].add(edge[1]);
      graph[edge[1]].add(edge[0]);
    }

    long count = findComponents(); 

    return n * (n - 1L) / 2 - count;
   
  }

  long cnt = 1;
  Integer[] stateToComponentId ;
  long findComponents() {
    int currentComponentId = 0;
    long res = 0;

    for (int i = 0; i < graph.length; i++) {
      if (stateToComponentId[i] == null) {
        stateToComponentId[i] = ++currentComponentId;
        cnt = 1;
        dfs(i, currentComponentId);
        System.out.println(cnt);
        res += cnt * (cnt - 1) / 2;
      }
    } 

    return res;

  }

  void dfs(Integer currentState, int currentComponentId) {
    for (int nextState : graph[currentState]) {
      if (stateToComponentId[nextState] == null) {
        stateToComponentId[nextState] = currentComponentId;
        cnt++;
        dfs(nextState, currentComponentId);
      }
    }
  }
}
```

### 动态(递增)图的算法 - 并查集
#### 没有权值的并查集
##### 模版
```java
class DisjointSet {
  int[] parent;
  // 连通分量的个数
  int cnt;

  public DisjointSet(int n) {
    cnt = n;
    // 初始化parent
    parent = new int[n];
    for (int i = 0; i < n; i++) {
      parent[i] = i;
    }
  }

  // 查找x属于哪个连通分支
  int findParent(int x) {
    if (x == parent[x]) {
      return x; 
    } 
    parent[x] = findParent(parent[x]);
    return parent[x];
  }

  // 合并2个连通分支
  void unionSets(int a, int b) {
    a = findParent(a);
    b = findParent(b);
    if (a != b) {
      parent[a] = b;
      cnt--;
    }
  }
}
``` 

##### 例题1: 等式方程的可满足性
[等式方程的可满足性](https://leetcode.cn/problems/satisfiability-of-equality-equations/)

给定一个由表示变量之间关系的字符串方程组成的数组，每个字符串方程 equations[i] 的长度为 4，并采用两种不同的形式之一："a==b" 或 "a!=b"。在这里，a 和 b 是小写字母（不一定不同），表示单字母变量名。

只有当可以将整数分配给变量名，以便满足所有给定的方程时才返回 true，否则返回 false。 

示例 1：
```txt
输入：["a==b","b!=a"]
输出：false
解释：如果我们指定，a = 1 且 b = 1，那么可以满足第一个方程，但无法满足第二个方程。没有办法分配变量同时满足这两个方程。
```

示例 2：
```txt
输入：["b==a","a==b"]
输出：true
解释：我们可以指定 a = 1 且 b = 1 以满足满足这两个方程。
```

示例 3：
```txt
输入：["a==b","b==c","a==c"]
输出：true
```

###### 分析
- "a==b"可以看成a与b属于同一分支
- "a!=b"可以看成a与b不属于同一分支

如果一个等式中"a==b", "a!=b", 则表明a与b属于同一分支, 也不属于同一分支。这显然是矛盾的

代码1：
```java
class Solution {

  public boolean equationsPossible(String[] equations) {
    DisjointSet disjointSet = new DisjointSet(26);
    for (String equation : equations) {
      if (equation.charAt(1) == '=') {
        disjointSet.unionSets(equation.charAt(0) - 'a', equation.charAt(3) - 'a');
      }
    }

    for (String equation : equations) {
      if (equation.charAt(1) == '!') {
        if (disjointSet.findParent(equation.charAt(0) - 'a') == disjointSet.findParent(equation.charAt(3)- 'a')) return false;
      }
    }
    return true;
  }

  class DisjointSet {
    int[] parent;

    public DisjointSet(int n) {
      parent = new int[n];
      for (int i = 0; i < n; i++) {
        parent[i] = i;
      }
    }

    int findParent(int x) {
      if (x == parent[x]) {
        return x; 
      } 
      parent[x] = findParent(parent[x]);
      return parent[x];
    }
  
    void unionSets(int a, int b) {
      a = findParent(a);
      b = findParent(b);
      if (a != b) {
        parent[a] = b;
      }
    }
  }

}
```

##### 例题2: 连通网络的操作次数
[连通网络的操作次数](https://leetcode.cn/problems/number-of-operations-to-make-network-connected/)

用以太网线缆将 n 台计算机连接成一个网络，计算机的编号从 0 到 n-1。线缆用 connections 表示，其中 connections[i] = [a, b] 连接了计算机 a 和 b。

网络中的任何一台计算机都可以通过网络直接或者间接访问同一个网络中其他任意一台计算机。

给你这个计算机网络的初始布线 connections，你可以拔开任意两台直连计算机之间的线缆，并用它连接一对未直连的计算机。请你计算并返回使所有计算机都连通所需的最少操作次数。如果不可能，则返回 -1 。

示例 1：
![](https://raw.githubusercontent.com/NaisWang/images/master/20220528101836.png)

输入：n = 6, connections = [[0,1],[0,2],[0,3],[1,2],[1,3]]
输出：2

###### 分析
将m个连通分支相连至少需要m-1个边

代码:
```java
class Solution {
  public int makeConnected(int n, int[][] connections) {
    DisjointSet disjointSet = new DisjointSet(n);
    // 多余的缆线个数
    int redundancy = 0;
    for (int i = 0; i < connections.length; i++) {
      if (disjointSet.findParent(connections[i][0]) == disjointSet.findParent(connections[i][1])) {
        redundancy++;
      } else {
        disjointSet.unionSet(connections[i][0], connections[i][1]);
      }
    }

    if (redundancy >= disjointSet.cnt - 1) {
      return disjointSet.cnt - 1;
    } 
    return -1;
    
  }
  
  class DisjointSet {
    int[] parent;
    int cnt;
    
    public DisjointSet(int n) {
      cnt = n;
      parent = new int[n];
      for (int i = 0; i < n; i++) {
        parent[i] = i;
      }
    } 

    int findParent(int x) {
      if (x == parent[x]) return x;
      parent[x] = findParent(parent[x]);
      return parent[x];
    }

    void unionSet(int a, int b) {
      a = findParent(a);
      b = findParent(b);
      if (a != b) {
        parent[a] = b;
        cnt--;
      }
    }
  }
    
}
```

##### 例题3: 交换字符串中的元素
[交换字符串中的元素](https://leetcode.cn/problems/smallest-string-with-swaps/)

给你一个字符串 s，以及该字符串中的一些「索引对」数组 pairs，其中 pairs[i] = [a, b] 表示字符串中的两个索引（编号从 0 开始）。

你可以 任意多次交换 在 pairs 中任意一对索引处的字符。

返回在经过若干次交换后，s 可以变成的按字典序最小的字符串。

示例 1:
```txt
输入：s = "dcab", pairs = [[0,3],[1,2]]
输出："bacd"
解释： 
交换 s[0] 和 s[3], s = "bcad"
交换 s[1] 和 s[2], s = "bacd"
```

###### 分析

参考：https://leetcode.cn/problems/smallest-string-with-swaps/solution/1202-jiao-huan-zi-fu-chuan-zhong-de-yuan-wgab/

<div class="container">
  <iframe width="560" height="315" src="https://www.youtube.com/embed/f4I4FGDFKRc" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>

代码：
```java
class Solution {
  public String smallestStringWithSwaps(String s, List<List<Integer>> pairs) {
    DisjointSet disjointSet = new DisjointSet(s.length());
    for (List<Integer> pair : pairs) {
      disjointSet.unionSet(pair.get(0), pair.get(1));
    }

    Map<Integer, PriorityQueue<Character>> map = new HashMap();

    char[] sCh = s.toCharArray();
    for (int i = 0; i < sCh.length; i++) {
      int component = disjointSet.findParent(i);
      map.computeIfAbsent(component, p -> new PriorityQueue()).add(sCh[i]);
    }

    StringBuffer res = new StringBuffer();
    for (int i = 0; i < sCh.length; i++) {
      res.append(map.get(disjointSet.findParent(i)).poll());
    }
    return res.toString();
  }
  
  class DisjointSet {
    int[] parent;
    
    public DisjointSet(int n) {
      parent = new int[n];
      for (int i = 0; i < n; i++) {
        parent[i] = i;
      }
    }

    int findParent(int x) {
      if (x == parent[x]) return x; 
      parent[x] = findParent(parent[x]);
      return parent[x];
    }

    void unionSet(int a, int b) {
      a = findParent(a);
      b = findParent(b);
      if (a != b) {
        parent[a] = b;
      }
    }
  }
}
```
##### 例题4: 由斜杠划分区域
[由斜杠划分区域](https://leetcode.cn/problems/regions-cut-by-slashes/)

在由 1 x 1 方格组成的 n x n 网格 grid 中，每个 1 x 1 方块由 `'/'`、`'\'` 或空格构成。这些字符会将方块划分为一些共边的区域。

给定网格 grid 表示为一个字符串数组，返回 区域的数量 。

请注意，反斜杠字符是转义的，因此 `'\'` 用 `'\\'` 表示。

###### 分析
文字讲解：https://leetcode.cn/problems/regions-cut-by-slashes/solution/you-xie-gang-hua-fen-qu-yu-by-leetcode-67xb/

<div class="container">
  <iframe width="560" height="315" src="https://www.youtube.com/embed/1XptDhgm4KE" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>

代码：
```java
class Solution {
  public int regionsBySlashes(String[] grid) {
    int n = grid.length;
    DisjointSet disjointSet = new DisjointSet(4 * n * n);
    
    for (int r = 0; r < n; r++) {
      char[] rowStr = grid[r].toCharArray();
      for (int c = 0; c < n; c++) {
        int index = 4 * (n * r + c);

        // 单元格内合并
        if (rowStr[c] == '/'){
          // 合并0, 3 
          disjoinkSet.unionSets(index, index + 3); 
          // 合并1, 2
          disjointSet.unionSets(index + 1, index + 2); 
        } else if (rowStr[c] == '\\') {
          // 合并0， 1
          disjointSet.unionSets(index, index + 1);
          // 合并2， 3
          disjointSet.unionSets(index + 2, index + 3);
        } else {
          // 合并0,1,2,3
          disjointSet.unionSets(index, index + 1);
          disjointSet.unionSets(index + 1, index + 2);
          disjointSet.unionSets(index + 2, index + 3);
        }
        
        // 单元格间合并
        // 合并1， 3  
        if (c + 1 < n) {
          disjointSet.unionSets(index + 1, index + 4 + 3);
        }
        // 合并2, 0
        if (r + 1 <n) {
          disjointSet.unionSets(index + 2, 4 * (n * (r + 1) + c)); 
        }
        
      }
    }
    return disjointSet.cnt;
  }

  class DisjointSet {
    int[] parent;
    int cnt;
    
    public DisjointSet(int n) {
      cnt = n;
      parent = new int[n];
      for (int i = 0; i < n; i++) {
        parent[i] = i;
      }
    }

    int findParent(int x) {
      if (x == parent[x]) {
        return x;
      }
      return parent[x] = findParent(parent[x]);
    }
    
    void unionSets(int a, int b) {
      a = findParent(a);
      b = findParent(b);
      if (a != b) {
        parent[a] = b;
        cnt--;
      }
    }
  }
}
```

#### 节点类型不是数字的并查集
##### 模版
```java
class DisjointSet {
  Map<String, String> parent = new HashMap();
  Map<String, Double> weight = new HashMap();
  int cnt = 0;

  String findParent(String x) {
    if (!parent.containsKey(x)) {
      parent.put(x, x);
      weight.put(x, 1D);
      cnt++;
    }
    if (x.equals(parent.get(x))) {
      return x;
    }
    String origin = parent.get(x);
    parent.put(x, findParent(origin));
    weight.put(x, weight.get(x) * weight.get(origin)); 
    return parent.get(x);
  }

  void unionSet(String a, String b, Double value) {
    String rootA = findParent(a);
    String rootB = findParent(b);
    if (!rootA.equals(rootB)) {
      parent.put(rootA, rootB);
      cnt--;
    }
    weight.put(rootA, value * weight.get(b) / weight.get(a));
  }
}
```

例题：

[除法求值](https://leetcode.cn/problems/evaluate-division/)

代码：
```java
class Solution {
  public double[] calcEquation(List<List<String>> equations, double[] values, List<List<String>> queries) {
    DisjointSet disjointSet = new DisjointSet();
    for (int i = 0; i < equations.size(); i++) {
      List<String> equation = equations.get(i);
      disjointSet.unionSet(equation.get(0), equation.get(1), values[i]);
    }

    double[] res = new double[queries.size()];
    for (int i = 0; i < queries.size(); i++) {
      List<String> query = queries.get(i);
      if (disjointSet.parent.containsKey(query.get(0)) !disjointSet.findParent(query.get(0)).equals(disjointSet.findParent(query.get(1)))) {
        res[i] = -1;
      } else {
        res[i] = disjointSet.weight.get(query.get(0)) / disjointSet.weight.get(query.get(1));
      }
    }
    return res;
  }

  class DisjointSet {
    Map<String, String> parent = new HashMap();
    Map<String, Double> weight = new HashMap();
    int cnt = 0;

    String findParent(String x) {
      if (!parent.containsKey(x)) {
        parent.put(x, x);
        weight.put(x, 1D);
        cnt++;
      }
      if (x.equals(parent.get(x))) {
        return x;
      }
      String origin = parent.get(x);
      parent.put(x, findParent(origin));
      weight.put(x, weight.get(x) * weight.get(origin)); 
      return parent.get(x);
    }

    void unionSet(String a, String b, Double value) {
      String rootA = findParent(a);
      String rootB = findParent(b);
      if (!rootA.equals(rootB)) {
        parent.put(rootA, rootB);
        cnt--;
      }
      weight.put(rootA, value * weight.get(b) / weight.get(a));
    }

     
  }
}
```


#### 有权值的并查集
##### 模版
```java
class DisjointSet {
  int[] parent;
  // weight[x]表示节点x指向父节点的权值
  double[] weight;
  // 连通分量的个数
  int cnt;

  public DisjointSet(int n) {
    cnt = n;
    parent = new int[n];
    weight = new double[n];
    for (int i = 0; i < n; i++) {
      parent[i] = i;
      // 权值初始化, 如何初始化，根据情况而定
      weight[i] = 1;
    }
  }

  int findParent(int x) {
    if (x == parent[x]) {
      return x;
    } 
    // 保存节点x没有进行路径压缩时的父节点。这样做是为了方便后续获取父节点的weight来更新节点x的weight
    int origin = parent[x];
    parent[x] = findParent(parent[x]);
    // 更新weight[x], 具体如何更新，根据情况而定
    weight[x] *= weight[origin];
    return parent[x];
  }

  void unionSets(int a, int b, double value) {
    int rootA = findParent(a);
    int rootB = findParent(b);
    
    if (rootA != rootB) {
      parent[rootA] = rootB;
      // 更新weight[rootA], 具体如何更新，根据情况而定
      weight[rootA] = value * weight[b] / weight[a];
      cnt--;
    }
  }
}
```

##### 例题1: 除法求值

[除法求值](https://leetcode.cn/problems/evaluate-division/)

给你一个变量对数组 equations 和一个实数值数组 values 作为已知条件，其中 $equations[i] = [A_i, B_i]$ 和 values[i] 共同表示等式 $A_i / B_i = values[i]$ 。每个 $A_i$ 或 $B_i$ 是一个表示单个变量的字符串。

另有一些以数组 queries 表示的问题，其中 $queries[j] = [C_j, D_j]$ 表示第 j 个问题，请你根据已知条件找出 $C_j / D_j = ?$ 的结果作为答案。

返回 所有问题的答案 。如果存在某个无法确定的答案，则用 -1.0 替代这个答案。如果问题中出现了给定的已知条件中没有出现的字符串，也需要用 -1.0 替代这个答案。

注意：输入总是有效的。你可以假设除法运算中不会出现除数为 0 的情况，且不存在任何矛盾的结果。

示例 1：
```txt
输入：equations = [["a","b"],["b","c"]], values = [2.0,3.0], queries = [["a","c"],["b","a"],["a","e"],["a","a"],["x","x"]]
输出：[6.00000,0.50000,-1.00000,1.00000,-1.00000]
解释：
条件：a / b = 2.0, b / c = 3.0
问题：a / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ?
结果：[6.0, 0.5, -1.0, 1.0, -1.0 ]
```

###### 分析
文字解释： https://leetcode.cn/problems/evaluate-division/solution/399-chu-fa-qiu-zhi-nan-du-zhong-deng-286-w45d/

<div class="container">
  <iframe width="560" height="315" src="https://www.youtube.com/embed/948WwjXili4" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>


代码：
```java
class Solution {
  public double[] calcEquation(List<List<String>> equations, double[] values, List<List<String>> queries) {

    DisjointSet disjointSet = new DisjointSet(equations.size() * 2);
    // 第 1 步：预处理，将变量的值与 id 进行映射，使得并查集的底层使用数组实现，方便编码
    Map<String, Integer> map = new HashMap();
    int id = 0;
    for (int i = 0; i < equations.size(); i++) {
      List<String> equation = equations.get(i);
      String a = equation.get(0);
      String b = equation.get(1);
      if (!map.containsKey(a)) {
        map.put(a, id++); 
      }
      if (!map.containsKey(b)) {
        map.put(b, id++); 
      }
      disjointSet.unionSets(map.get(a), map.get(b), values[i]);
    }
    
    // 第 2 步：做查询 
    double[] res = new double[queries.size()];
    for (int i = 0; i < queries.size(); i++) {
      List<String> querie = queries.get(i);
      String c = querie.get(0);
      String d = querie.get(1);
      Integer cId = map.get(c);
      Integer dId = map.get(d);
      if (cId == null || dId == null) {
        res[i] = -1; 
        continue;
      }
      if (disjointSet.findParent(cId) != disjointSet.findParent(dId)) {
        res[i] = -1;
        continue;
      }
      res[i] = disjointSet.weight[cId] / disjointSet.weight[dId];
    }
    return res;
  }

  class DisjointSet {
    int[] parent;
    // 指向的父结点的权值
    double[] weight;

    public DisjointSet(int n) {
      parent = new int[n];
      weight = new double[n];
      for (int i = 0; i < n; i++) {
        parent[i] = i;
        weight[i] = 1;
      }
    }

    int findParent(int x) {
      if (x == parent[x]) {
        return x;
      } 
      int origin = parent[x];
      parent[x] = findParent(parent[x]);
      weight[x] *= weight[origin];
      return parent[x];
    }

    void unionSets(int a, int b, double value) {
      int rootA = findParent(a);
      int rootB = findParent(b);
      
      if (rootA != rootB) {
        parent[rootA] = rootB;
        weight[rootA] = value * weight[b] / weight[a];
      }
    }
  }

}
```

#### 初始化时节点总数不确定的并查集
当初始化时节点总数不确定或者是可能被选择的节点个数太多时，例如可能被选中的节点编号为1~100000，但是需要用到的节点个数只有500个，远小于100000个。此时用`int[] parent`就显得不合适，因为我们需要开辟长度100000的数组。为了提高效率，我们可以使用`Map<Integer, Integer> parent`来存储，key为节点编号；value为该节点的父节点。

在这种情况下, 在并查集里我们需要维护连通分量的个数，新创建顶点的时候连通分量加 1；合并不在同一个连通分量中的两个并查集的时候，连通分量减 1。

模版：
```java
class DisjointSet {
  // key：节点编号；value：该节点的父节点
  Map<Integer, Integer> parent = new HashMap();
  // 连通分量的个数
  int cnt = 0;

  int findParent(Integer x) {
    // 如果parent没有统计当前节点x, 则将节点x添加到parent中，节点x的父节点为它自己。此时连通分量个数加1
    if (!parent.containsKey(x)) {
      parent.put(x, x);
      cnt++;
    }
    if (x.equals(parent.get(x))) return x;
    parent.put(x, findParent(parent.get(x)));
    return parent.get(x);
  }

  void unionSet(Integer a, Integer b) {
    a = findParent(a);
    b = findParent(b);
    if (!a.equals(b)) {
      parent.put(a, b);
      // 连通分量个数减1
      cnt--;
    }
  }
}
```

##### 例题1: 移除最多的同行或同列石头
[移除最多的同行或同列石头](https://leetcode.cn/problems/most-stones-removed-with-same-row-or-column/)

n 块石头放置在二维平面中的一些整数坐标点上。每个坐标点上最多只能有一块石头。

如果一块石头的 同行或者同列 上有其他石头存在，那么就可以移除这块石头。

给你一个长度为 n 的数组 stones ，其中 $stones[i] = [x_i, y_i]$ 表示第 i 块石头的位置，返回 可以移除的石子 的最大数量。

示例 1：
```txt
输入：stones = [[0,0],[0,1],[1,0],[1,2],[2,1],[2,2]]
输出：5
解释：一种移除 5 块石头的方法如下所示：
1. 移除石头 [2,2] ，因为它和 [2,1] 同行。
2. 移除石头 [2,1] ，因为它和 [0,1] 同列。
3. 移除石头 [1,2] ，因为它和 [1,0] 同行。
4. 移除石头 [1,0] ，因为它和 [0,0] 同列。
5. 移除石头 [0,1] ，因为它和 [0,0] 同行。
石头 [0,0] 不能移除，因为它没有与另一块石头同行/列。
```

###### 分析
文字解析：https://leetcode.cn/problems/most-stones-removed-with-same-row-or-column/solution/947-yi-chu-zui-duo-de-tong-xing-huo-tong-ezha/

<div class="container">
  <iframe width="560" height="315" src="https://www.youtube.com/embed/ZvY-1X0gN2I" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>

代码：
```java
class Solution {
  public int removeStones(int[][] stones) {
    DisjointSet disjointSet = new DisjointSet();
    for (int[] stone : stones) {
      disjointSet.unionSet(stone[0] + 10001, stone[1]);
    }
    return stones.length - disjointSet.cnt;
  }
  
  class DisjointSet {
    Map<Integer, Integer> parent = new HashMap();
    int cnt = 0;

    int findParent(Integer x) {
      if (!parent.containsKey(x)) {
        parent.put(x, x);
        cnt++;
      }
      if (x.equals(parent.get(x))) return x;
      parent.put(x, findParent(parent.get(x)));
      return parent.get(x);
    }

    void unionSet(Integer a, Integer b) {
      a = findParent(a);
      b = findParent(b);
      if (!a.equals(b)) {
        parent.put(a, b);
        cnt--;
      }
    }
  }
}
```

#### 需要记录每个连通分量中节点个数
##### 模版
```java
class DisjointSet {
  int[] parent;
  // 记录每个连通分量中的节点个数
  int[] size;
  // 连通分量的个数
  int cnt;

  public DisjointSet(int n) {
    cnt = n;
    // 初始化parent
    parent = new int[n];
    size = new int[n];
    for (int i = 0; i < n; i++) {
      parent[i] = i;
      size[i] = 1;
    }
  }

  // 查找x属于哪个连通分支
  int findParent(int x) {
    if (x == parent[x]) {
      return x;
    }
    parent[x] = findParent(parent[x]);
    return parent[x];
  }

  // 合并2个连通分支
  void unionSets(int a, int b) {
    a = findParent(a);
    b = findParent(b);
    if (a != b) {
      parent[a] = b;
      size[b] += size[a];
      cnt--;
    }
  }

  // 返回x节点所在连通分量的大小
  int getSize(int x) {
    return size[findParent(x)];
  }
}
```

##### 例题1: 统计无向图中无法互相到达点对数
[统计无向图中无法互相到达点对数](https://leetcode.cn/problems/count-unreachable-pairs-of-nodes-in-an-undirected-graph/)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220717100319.png)

###### 分析
<div class="container">
  <iframe width="560" height="315" src="https://www.youtube.com/embed/P8cpKzUJP_Q" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>

- 对于无向图，有`n(n-1)/2`条边的无向图称为完全图，在完全图中任意两个顶点之间都存在边
- 对于有向图，有`n(n-1)`条边的有向图称为有向完全图，在有向完全图中任意两个顶点之间都存在方向相反的两条弧

###### 代码
```java
class Solution {
      public long countPairs(int n, int[][] edges) {
      DisjointSet disjointSet = new DisjointSet(n);
      for (int i = 0; i < edges.length; i++) {
        int[] edge = edges[i];
        disjointSet.unionSets(edge[0], edge[1]);
      }
      long res = (long) n * (n - 1) / 2;
      for (int i = 0; i < n; i++) {
        if (disjointSet.findParent(i) == i) {
          int size = disjointSet.getSize(i);
          res -= (long) size * (size - 1) / 2;
        }
      }
      return res;
    }

    class DisjointSet {
      int[] parent;
      int[] size;
      // 连通分量的个数
      int cnt;

      public DisjointSet(int n) {
        cnt = n;
        // 初始化parent
        parent = new int[n];
        size = new int[n];
        for (int i = 0; i < n; i++) {
          parent[i] = i;
          size[i] = 1;
        }
      }

      // 查找x属于哪个连通分支
      int findParent(int x) {
        if (x == parent[x]) {
          return x;
        }
        parent[x] = findParent(parent[x]);
        return parent[x];
      }

      // 合并2个连通分支
      void unionSets(int a, int b) {
        a = findParent(a);
        b = findParent(b);
        if (a != b) {
          parent[a] = b;
          size[b] += size[a];
          cnt--;
        }
      }

      // 返回x节点所在连通分量的大小
      int getSize(int x) {
        return size[findParent(x)];
      }
    }
}
```

##### 例题2: 元素值大于变化阈值的子数组
[元素值大于变化阈值的子数组](https://leetcode.cn/problems/subarray-with-elements-greater-than-varying-threshold/)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220720102510.png)

###### 分析
<div class="container">
  <iframe width="560" height="315" src="https://www.youtube.com/embed/nv_fXU3wFqI" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>

代码：
```java
class Solution {
      public int validSubarraySize(int[] nums, int threshold) {
      int n = nums.length;
      DisjointSet disjointSet = new DisjointSet(n + 1);
      Integer[] index = new Integer[n];
      for (int i = 0; i < n; i++) {
        index[i] = i; 
      }
      Arrays.sort(index, (a, b) -> nums[b] - nums[a]);
      for (int k = 1, i = 0; k <= n; k++) {
        while (i < n && nums[index[i]] > threshold / k) {
          disjointSet.unionSets(index[i], index[i] + 1);
          if (disjointSet.getSize(index[i]) - 1 >= k) return k;
          i++;
        }
      }
      return -1;
    }

    class DisjointSet {
      private int[] parent;
      private int[] size;
      // 连通分量的个数
      int cnt;

      public DisjointSet(int n) {
        cnt = n;
        // 初始化parent
        parent = new int[n];
        size = new int[n];
        for (int i = 0; i < n; i++) {
          parent[i] = i;
          size[i] = 1;
        }
      }

      // 查找x属于哪个连通分支
      int findParent(int x) {
        if (x == parent[x]) {
          return x;
        }
        parent[x] = findParent(parent[x]);
        return parent[x];
      }

      // 合并2个连通分支
      void unionSets(int a, int b) {
        a = findParent(a);
        b = findParent(b);
        if (a != b) {
          parent[a] = b;
          size[b] += size[a];
          cnt--;
        }
      }

      // 返回x节点所在连通分量的大小
      int getSize(int x) {
        return size[findParent(x)];
      }
    }

}
```

## 最短路径算法
### 最短路径中的松弛技术
松弛(relaxation):指对于图 G = (V, E) 中 每个顶点v ∈ V，都设置一个属性dist[v]，用来描述从源点s到v的最短路径上权值的上界。

在开始进行一个最短路径算法时,只知道图中边和权值.随着算法的进行,逐渐得到各对顶点的最短路径的信息.算法会逐渐更新这些信息,每步都会检查是否可以找到一条路径比当前给定路径更短.这一过程通常称为松弛.

下面这两张图即为对边`<u, v>`的松弛操作, 即尝试能否通过 `<u, v>`, 对迄今为止找到的 v 的最短路径进行改进.在这里源点为点 S, 用 dist[i] 表示点 i 到源点 S 的最短路径,现对于边权为 60 的边 `<u, v>`进行松弛操作,如第一副图所示,现到顶点 v, u的最短路径分别为 100 和 30, 即 dist[v] = 100,那么 `dist[v] > dist[u] + W<u, v>`, 所以对于 dist[v] 需要更新,则 S 到 v 的最短路径为 S 到 u 的最短路径经过`<u, v>`到 v, 即 `dist[u] = dist[v] + W<u, v> = 90`.

![](https://raw.githubusercontent.com/NaisWang/images/master/20220602115627.png)

写成伪代码:
```java
Relax( u,  v,  W<u, v> ) { //W<u, v>代表边<u, v> 的权值
    if ( dist[v] > dist[u] + W<u, v> ) {
        dist[v] = dist[u] + W<u, v>;
    }
}
```

- Dijkstra是通过遍历**顶点**来进行松弛操作
- Bellman-Ford是通过遍历**边**来进行松弛操作

### 单源最短路径
#### Dijkstra算法
参考：
- https://zhuanlan.zhihu.com/p/409121513

<div class="container">
  <iframe width="560" height="315" src="https://www.youtube.com/embed/VRQL664Oesk" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>

---

首先，我们先看一下 Dijkstra 算法的签名：
```java
// 输入一幅图和一个起点 start，计算 start 到其他节点的最短距离
int[] dijkstra(int start, int[] path, List<int[]>[] graph);
```
输入是一幅图 graph 和一个起点 start，返回是一个记录最短路径权重的数组。

比方说，输入起点 start = 3，函数返回一个`int[]`数组，假设赋值给`distTo`变量，那么从起点 3 到节点 6 的最短路径权重的值就是 `distTo[6]`。

是的，标准的 Dijkstra 算法会把从起点 start 到所有其他节点的最短路径都算出来。

当然，如果你的需求只是计算从起点 start 到某一个终点 end 的最短路径，那么在标准 Dijkstra 算法上稍作修改就可以更高效地完成这个需求，这个我们后面再说。

其次，我们也需要一个 State 类来辅助算法的运行：
```java
class State {
    // 图节点的 id
    int id;
    // 从 start 节点到当前节点的距离
    int distFromStart;

    State(int id, int distFromStart) {
        this.id = id;
        this.distFromStart = distFromStart;
    }
}
```

类似刚才二叉树的层序遍历，我们也需要用 State 类记录一些额外信息，也就是使用 distFromStart 变量记录从起点 start 到当前这个节点的距离。

刚才说普通 BFS 算法中，根据 BFS 的逻辑和无权图的特点，第一次遇到某个节点所走的步数就是最短距离，所以用一个 visited 数组防止走回头路，每个节点只会经过一次。

加权图中的 Dijkstra 算法和无权图中的普通 BFS 算法不同，在 Dijkstra 算法中，你第一次经过某个节点时的路径权重，不见得就是最小的，所以对于同一个节点，我们可能会经过多次，而且每次的 distFromStart 可能都不一样，比如下图：

![](https://raw.githubusercontent.com/NaisWang/images/master/20220601134025.png)

我会经过节点 5 三次，每次的 distFromStart 值都不一样，那我取 distFromStart 最小的那次，不就是从起点 start 到节点 5 的最短路径权重了么？

<font color="red">Dijkstra的核心思想就是贪心，即每次从队列中找到dist最小的点，即为从起点到该点的最短路径长度。</font>所以我们在不知道是否能使用Dijkstra时，可以判断一下这个贪心策略是否成立，如果成立，则可以使用Dijkstra。

而Dijkstra的贪心过程可以使用BFS（优先队列版）来实现
- 元素出队：由于是优先队列，所以出队的元素是当前队列中最优先的元素。由于这个元素的id可能出过队列，即这个元素的id是已经确定好了最短路径。对于这种情况，我们是不做任何处理的。我们可能通过判断State.distFromStart 是否大于 dist[State.id]来判断是否为这种情况，如果大于，则是这种情况。
- 元素入队：没确定一个节点的最短路径后，都需要更新这个节点相邻的节点的dist值, 而这个更新是通过创建一个新的State,并将该State入队来实现的。

##### 时间复杂度分析
Dijkstra 算法的时间复杂度是多少？你去网上查，可能会告诉你是 `O(ElogV)`，其中 E 代表图中边的条数，V 代表图中节点的个数。

因为理想情况下优先级队列中最多装 V 个节点，对优先级队列的操作次数和 E 成正比，所以整体的时间复杂度就是 `O(ElogV)`。

不过这是理想情况，Dijkstra 算法的代码实现有很多版本，不同编程语言或者不同数据结构 API 都会导致算法的时间复杂度发生一些改变。

比如本文实现的 Dijkstra 算法，使用了 Java 的 PriorityQueue 这个数据结构，这个容器类底层使用二叉堆实现，但没有提供通过索引操作队列中元素的 API，所以队列中会有重复的节点，最多可能有 E 个节点存在队列中。

所以本文实现的 Dijkstra 算法复杂度并不是理想情况下的 `O(ElogV)`，而是 `O(ElogE)`，可能会略大一些，因为图中边的条数一般是大于节点的个数的。

不过就对数函数来说，就算真数大一些，对数函数的结果也大不了多少，所以这个算法实现的实际运行效率也是很高的，以上只是理论层面的时间复杂度分析，供大家参考。

##### 模版1: 需求到达其他所有点的最短路径
```java
/**
* startState: 开始状态
* graph: 图的表示方式，这里是使用的带有的权值的邻接表的表示方式
*/
int[] dijkstra(State startState,  List<int[]>[] graph) {
  // 优先队列，distFromStart较小的排在前面
  Queue<State> pq = new PriorityQueue<>((a, b) -> {
    return a.distFromStart - b.distFromStart;
  });

  // 初始化dist
  // dist[i] 的值就是节点 start 到达节点 i 的最短路径权重
  int[] dist = new int[graph.length];
  // 起始点到各点的最短路径长度为Integer.MAX_VALUE
  Arrays.fill(dist, Integer.MAX_VALUE);
  // 节点start 到节点start的最短路径为0 
  dist[startState.id] = 0;

  // 用来标记节点是否已经被选择
  boolean[] isSelected = new boolean[graph.length];

  // 从起点start开始进bfs
  pq.add(startState);

  while (!pq.isEmpty()) {
    State currentState = pq.poll();
    
    if (isSelected[currentState.id]) {
      continue;
    }
    isSelected[currentState.id] = true;

    // 获取currentState相邻节点
    List<State> nextStates = new ArrayList();
    for (int[] neighbor : graph[currentState.id]) {
      int nextNodeID = neighbor[0];
      int distToNextNode = dist[currentState.id] + neighbor[1];
      nextStates.add(new State(nextNodeID, distToNextNode));
    }
     
    for (State nextState : nextStates) {
      if (isSelected[nextState.id]) continue;
      if (dist[nextState.id] > nextState.distFromStart) {
        dist[nextState.id] = nextState.distFromStart;
        pq.add(nextState);
      }
    }
  }
  
  return dist;
}

// 辅助类, 用于优先队列
class State {
    // 图节点的 id
    int id;
    // 从 start 节点到当前节点的距离
    int distFromStart;

    State(int id, int distFromStart) {
        this.id = id;
        this.distFromStart = distFromStart;
    }
}
```

###### 例题1: 网络延迟时间
[网络延迟时间](https://leetcode.cn/problems/network-delay-time/)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220601134440.png)

让你求所有节点都收到信号的时间，你把所谓的传递时间看做距离，实际上就是问你「从节点 k 到其他所有节点的最短路径中，最长的那条最短路径距离是多少」，说白了就是让你算从节点 k 出发到其他所有节点的最短路径，就是标准的 Dijkstra 算法。

在用 Dijkstra 之前，别忘了要满足一些条件，加权有向图，没有负权重边，OK，可以用 Dijkstra 算法计算最短路径。

根据我们之前 Dijkstra 算法的框架，我们可以写出下面代码：

代码：
```java
class Solution {
  public int networkDelayTime(int[][] times, int n, int k) {
    // 构造图。节点编号是从1开始的，所以要一个大小为n + 1的邻接表
    List<int[]>[] graph = new LinkedList[n + 1];
    for (int i = 1; i <= n; i++) {
      graph[i] = new LinkedList();
    }
    for (int[] edge : times) {
      int from = edge[0];
      int to = edge[1];
      int weight = edge[2];
      // from -> List<(to, weight)>
      // 邻接表存储图结构，同时存储权重信息
      graph[from].add(new int[]{to, weight});
    }

    // 启动 dijkstra 算法计算以节点 k 为起点到其他节点的最短路径
    int[] dist = dijkstra(new State(k, 0), graph);

    // 找到最长的那一条最短路径
    int res = 0;
    for (int i = 1; i < dist.length; i++) {
      if (dist[i] == Integer.MAX_VALUE) {
        // 有节点不可达，返回-1
        return -1;
      }
      res = Math.max(res, dist[i]);
    }
    return res;
  }
  
  int[] dijkstra(State startState,  List<int[]>[] graph) {
    // 优先队列，distFromStart较小的排在前面
    Queue<State> pq = new PriorityQueue<>((a, b) -> {
      return a.distFromStart - b.distFromStart;
    });

    // 初始化dist
    // dist[i] 的值就是节点 start 到达节点 i 的最短路径权重
    int[] dist = new int[graph.length];
    // 起始点到各点的最短路径长度为Integer.MAX_VALUE
    Arrays.fill(dist, Integer.MAX_VALUE);
    // 节点start 到节点start的最短路径为0 
    dist[startState.id] = 0;

    // 用来标记节点是否已经被选择
    boolean[] isSelected = new boolean[graph.length];

    // 从起点start开始进bfs
    pq.add(startState);

    while (!pq.isEmpty()) {
      State currentState = pq.poll();

      if (isSelected[currentState.id]) {
        continue;
      }
      isSelected[currentState.id] = true;

      // 获取currentState相邻节点
      List<State> nextStates = new ArrayList();
      for (int[] neighbor : graph[currentState.id]) {
        int nextNodeID = neighbor[0];
        int distToNextNode = dist[currentState.id] + neighbor[1];
        nextStates.add(new State(nextNodeID, distToNextNode));
      }
       
      for (State nextState : nextStates) {
        if (isSelected[nextState.id]) continue;
        if (dist[nextState.id] > nextState.distFromStart) {
          dist[nextState.id] = nextState.distFromStart;
          pq.add(nextState);
        }
      }
    }
    
    return dist;
  }

  // 辅助类, 用于优先队列
  class State {
      // 图节点的 id
      int id;
      // 从 start 节点到当前节点的距离
      int distFromStart;
  
      State(int id, int distFromStart) {
          this.id = id;
          this.distFromStart = distFromStart;
      }
  }
}
```

###### 例题2: 阈值距离内邻居最少的城市
[阈值距离内邻居最少的城市](https://leetcode.cn/problems/find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance/)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220602201121.png)

对每个点进行Dijkstra

代码：
```java
class Solution {
  public int findTheCity(int n, int[][] edges, int distanceThreshold) {
    List<int[]>[] graph = new ArrayList[n];
    for (int i = 0; i < n; i++) {
      graph[i] = new ArrayList();
    }
    for (int i = 0; i < edges.length; i++) {
      graph[edges[i][0]].add(new int[]{edges[i][1], edges[i][2]});
      graph[edges[i][1]].add(new int[]{edges[i][0], edges[i][2]});
    }
    int res = 0;
    int minCnt = Integer.MAX_VALUE;
    for (int i = 0; i < n; i++) {
      int[] dist = dijkstra(new State(i, 0), graph);
      int cnt = 0;
      for (int j = 0; j < n; j++) {
        if (dist[j] <= distanceThreshold) {
          cnt++;
        }
      }
      if (cnt != 0 && minCnt >= cnt) {
        res = i;
        minCnt = cnt;
      }
    }
    return res;
  }

  int[] dijkstra(State startState, List<int[]>[] graph) {
    Queue<State> pq = new PriorityQueue<>((a, b) -> {
      return a.distFromStart - b.distFromStart;
    });
    
    int[] dist = new int[graph.length];
    Arrays.fill(dist, Integer.MAX_VALUE);
    dist[startState.id] = 0;

    boolean[] isSelected = new boolean[graph.length];

    pq.add(startState);
    while (!pq.isEmpty()) {
      State currentState = pq.poll();

      if (isSelected[currentState.id]) {
        continue;
      }
      isSelected[currentState.id] = true;

      List<State> nextStates = new ArrayList();
      for (int[] neighbor : graph[currentState.id]) {
        nextStates.add(new State(neighbor[0], dist[currentState.id] + neighbor[1]));
      }

      for (State nextState : nextStates) {
        if (isSelected[nextState.id]) continue;
        if (dist[nextState.id] > nextState.distFromStart) {
          dist[nextState.id] = nextState.distFromStart;
          pq.add(nextState);
        }
      }
      
    }
    return dist;
  }
    
  class State {
    int id;
    int distFromStart;
    public State(int id, int distFromStart) {
      this.id = id;
      this.distFromStart = distFromStart;
    }
  }

}
```

###### 例题3: 细分图中的可到达结点
[细分图中的可到达结点](https://leetcode.cn/problems/reachable-nodes-in-subdivided-graph/)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220602212459.png)

```代码
class Solution {

  public int reachableNodes(int[][] edges, int maxMoves, int n) {
    List<int[]>[] graph = new ArrayList[n];
    for (int i = 0; i < n; i++) {
      graph[i] = new ArrayList();
    }
    for (int i = 0; i < edges.length; i++) {
      graph[edges[i][0]].add(new int[]{edges[i][1], edges[i][2]});
      graph[edges[i][1]].add(new int[]{edges[i][0], edges[i][2]});
    } 
    int res = 0; 
    int[] dist = dijkstra(new State(0, 0), graph);
    for (int i = 0; i < edges.length; i++) {
      // 这条边点起点还能在这条边上走多少个顶点
      int right = maxMoves - dist[edges[i][0]] < 0 ? 0 : maxMoves - dist[edges[i][0]];
      // 这条边点终点还能在这条边上走多少个顶点
      int left = maxMoves - dist[edges[i][1]] < 0 ? 0 : maxMoves - dist[edges[i][1]];
      res += (right + left) > edges[i][2] ? edges[i][2] : right + left;
    }
    for (int i = 0; i < n; i++) {
      if (dist[i] <= maxMoves) {
        res++;
      }
    }
    return res;
  }

  int[] dijkstra(State startState,  List<int[]>[] graph) {
    // 优先队列，distFromStart较小的排在前面
    Queue<State> pq = new PriorityQueue<>((a, b) -> {
      return a.distFromStart - b.distFromStart;
    });

    // 初始化dist
    // dist[i] 的值就是节点 start 到达节点 i 的最短路径权重
    int[] dist = new int[graph.length];
    // 起始点到各点的最短路径长度为Integer.MAX_VALUE
    Arrays.fill(dist, Integer.MAX_VALUE);
    // 节点start 到节点start的最短路径为0 
    dist[startState.id] = 0;

    boolean[] isSelected = new boolean[graph.length];

    // 从起点start开始进bfs
    pq.add(startState);

    while (!pq.isEmpty()) {
      State currentState = pq.poll();

      if (isSelected[currentState.id]) {
        continue;
      }
      isSelected[currentState.id] = true;

      // 获取currentState相邻节点
      List<State> nextStates = new ArrayList();
      for (int[] neighbor : graph[currentState.id]) {
        int nextNodeID = neighbor[0];
        int distToNextNode = dist[currentState.id] + neighbor[1] + 1;
        nextStates.add(new State(nextNodeID, distToNextNode));
      }
       
      for (State nextState : nextStates) {
        if (isSelected[nextState.id]) continue;
        if (dist[nextState.id] > nextState.distFromStart) {
          dist[nextState.id] = nextState.distFromStart;
          pq.add(nextState);
        }
      }
    }
    //System.out.println(Arrays.toString(dist)); 
    return dist;
  }



  class State {
    int id;
    int distFromStart;
    public State(int id, int distFromStart) {
      this.id = id;
      this.distFromStart = distFromStart;
    }
  }
}
```


##### 模版2: 只需求到达某个点的最短路径
```java
/**
* startState: 开始状态
* graph: 图的表示方式，这里是使用的带有的权值的邻接表的表示方式
* end: 目标点
*/
int dijkstra(State startState,  List<int[]>[] graph, int end) {
  // 优先队列，distFromStart较小的排在前面
  Queue<State> pq = new PriorityQueue<>((a, b) -> {
    return a.distFromStart - b.distFromStart;
  });

  // 初始化dist
  // dist[i] 的值就是节点 start 到达节点 i 的最短路径权重
  int[] dist = new int[graph.length];
  // 起始点到各点的最短路径长度为Integer.MAX_VALUE
  Arrays.fill(dist, Integer.MAX_VALUE);
  // 节点start 到节点start的最短路径为0 
  dist[startState.id] = 0;

  // 用来标记节点是否已经被选择
  boolean[] isSelected = new boolean[graph.length];

  // 从起点start开始进bfs
  pq.add(startState);

  while (!pq.isEmpty()) {
    State currentState = pq.poll();
    
    // 如果currentState是目标点
    if (currentState.id == end) {
      return currentState.distFromStart;
    }

    if (isSelected[currentState.id]) {
      continue;
    }
    isSelected[currentState.id] = true;


    // 获取currentState相邻节点
    List<State> nextStates = new ArrayList();
    for (int[] neighbor : graph[currentState.id]) {
      int nextNodeID = neighbor[0];
      int distToNextNode = dist[currentState.id] + neighbor[1];
      nextStates.add(new State(nextNodeID, distToNextNode));
    }
     
    for (State nextState : nextStates) {
      if (isSelected[nextState.id]) continue;
      if (dist[nextState.id] > nextState.distFromStart) {
        dist[nextState.id] = nextState.distFromStart;
        pq.add(nextState);
      }
    }
  }

  // 如果到达这里，说明从 start 开始无法到达 end，返回 -1
  return -1;
}

// 辅助类, 用于优先队列
class State {
    // 图节点的 id
    int id;
    // 从 start 节点到当前节点的距离
    int distFromStart;

    State(int id, int distFromStart) {
        this.id = id;
        this.distFromStart = distFromStart;
    }
}
```

###### 例题1: 到达角落需要移除障碍物的最小数目
[到达角落需要移除障碍物的最小数目](https://leetcode.cn/problems/minimum-obstacle-removal-to-reach-corner/)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220601161114.png)

代码：
```java
class Solution {
  public int minimumObstacles(int[][] grid) {
    return dijkstra(new State(0, 0, 0), grid);
  }

  int dijkstra(State startState, int[][] graph) {
    Queue<State> pq = new PriorityQueue<>((a, b) -> {
      return a.distFromStart - b.distFromStart;
    });

    int[][] dist = new int[graph.length][graph[0].length];
    for (int i = 0; i < dist.length; i++) {
      Arrays.fill(dist[i], Integer.MAX_VALUE);
    }
    dist[startState.row][startState.col] = 0;

    boolean[][] isSelected = new boolean[graph.length][graph[0].length]; 

    pq.add(startState);
    
    while (!pq.isEmpty()) {
      State currentState = pq.poll();
      
      if (currentState.row == graph.length - 1 && currentState.col == graph[0].length - 1) {
        return currentState.distFromStart;
      }

      if (isSelected[currentState.row][currentState.col]) {
        continue;
      }
      isSelected[currentState.row][currentState.col] = true;
      
      List<State> nextStates = new ArrayList();
      
			int[] dr = new int[]{-1, 1, 0, 0};
			int[] dc = new int[]{0, 0, -1, 1};
      
			for (int i = 0; i < 4; i++) {
				int nr = currentState.row + dr[i];
				int nc = currentState.col + dc[i];
        if (nr >= 0 && nr < graph.length && nc >= 0 && nc < graph[0].length) {
          nextStates.add(new State(nr, nc, graph[nr][nc] == 1 ? currentState.distFromStart + 1 : currentState.distFromStart));
        }
			}
      
      for (State nextState : nextStates) {
        if (isSelected[nextState.row][nextState.col]) continue;
        if (dist[nextState.row][nextState.col] > nextState.distFromStart) {
          dist[nextState.row][nextState.col] = nextState.distFromStart;
          pq.add(nextState);
        }   
      }
    }
    return -1;
  }

  class State{
    int row;
    int col;
    int distFromStart;
    public State(int row, int col, int distFromStart) {
      this.row = row;
      this.col = col;
      this.distFromStart = distFromStart;
    }
  }
}
```
###### 例题2: 概率最大的路径
[概率最大的路径](https://leetcode.cn/problems/path-with-maximum-probability/)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220601194923.png)

代码：
```java
class Solution {
  int end;
  public double maxProbability(int n, int[][] edges, double[] succProb, int start, int end) {
    this.end = end;
    // 构建图
    List<double[]>[] graph = new LinkedList[n];
    for (int i = 0; i < n; i++) {
      graph[i] = new LinkedList();
    }
    for (int i = 0; i < edges.length; i++) {
      int[] edge = edges[i]; 
      int from = edge[0];
      int to = edge[1];
      double weight = succProb[i];
      graph[from].add(new double[]{to, weight});
      graph[to].add(new double[]{from, weight});
    }
    return dijkstra(new State(start, 1), graph);
  
  }
  
  double dijkstra(State startState, List<double[]>[] graph) {
    Queue<State> pq = new PriorityQueue<>((a, b) -> {
      return Double.compare(b.distFromStart, a.distFromStart);
    });

    double[] dist = new double[graph.length];
    Arrays.fill(dist, -1);
    dist[startState.id] = 1;

    boolean[] isSelected = new boolean[graph.length];

    pq.add(startState); 
    
    while(!pq.isEmpty()) {
      State currentState = pq.poll();
      
      // 如果当前点为end点
      if (currentState.id == end) {
        return currentState.distFromStart;
      }

      if (isSelected[currentState.id]) {
        continue;
      }
      isSelected[currentState.id] = true;

      List<State> nextStates = new ArrayList();
      for (double[] neighbor : graph[currentState.id]) {
        double nextNodeId = neighbor[0];
        double distToNextNode = dist[currentState.id] * neighbor[1];
        nextStates.add(new State((int)nextNodeId, distToNextNode));
      }

      for (State nextState : nextStates) {
        if (isSelected[nextState.id]) continue;
        if (dist[nextState.id] < nextState.distFromStart) {
          dist[nextState.id] = nextState.distFromStart;
          pq.add(nextState);
        }
      }
    }
    return 0;
  }

  class State {
    int id;
    double distFromStart;
    public State(int id, double distFromStart) {
      this.id = id;
      this.distFromStart = distFromStart;
    }
  }
  
}
```

###### 例题3: 最小体力消耗路径
[最小体力消耗路径](https://leetcode.cn/problems/path-with-minimum-effort/)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220601224956.png)

代码：
```java
class Solution {
  public int minimumEffortPath(int[][] heights) {
    return dijkstra(new State(0, 0, 0), heights);
  }

  int dijkstra(State startState, int[][] heights) {
    Queue<State> pq = new PriorityQueue<>((a, b) -> {
      return a.distFromStart - b.distFromStart;
    });

    int[][] dist = new int[heights.length][heights[0].length];
    for (int i = 0; i < heights.length; i++) {
      Arrays.fill(dist[i], Integer.MAX_VALUE);
    }
    dist[startState.row][startState.col] = 0;

    boolean[][] isSelected = new boolean[heights.length][heights[0].length]; 

    pq.add(startState);
    
    while (!pq.isEmpty()) {
      State currentState = pq.poll();
      
      if (currentState.row == heights.length - 1 && currentState.col == heights[0].length - 1) {
        return currentState.distFromStart;
      }

      if (isSelected[currentState.row][currentState.col]) {
        continue;
      }
      isSelected[currentState.row][currentState.col] = true;

      List<State> nextStates = new ArrayList();
      int[] dr = new int[]{-1, 1, 0, 0};
			int[] dc = new int[]{0, 0, -1, 1};
			for (int i = 0; i < 4; i++) {
				int nr = currentState.row + dr[i];
				int nc = currentState.col + dc[i];
        if (nr >= 0 && nr < heights.length && nc >= 0 && nc < heights[0].length) {
          nextStates.add(new State(nr, nc, Math.max(dist[currentState.row][currentState.col], Math.abs(heights[currentState.row][currentState.col] - heights[nr][nc]))));
        }
			}

      for (State nextState : nextStates) {
        if (isSelected[nextState.row][nextState.col]) continue;
        if (dist[nextState.row][nextState.col] > nextState.distFromStart) {
          dist[nextState.row][nextState.col] = nextState.distFromStart;
          pq.add(nextState);
        }
      }
    }
    return -1;
  }
  
  class State {
    int row;
    int col;
    int distFromStart;
    public State(int row, int col, int distFromStart) {
      this.row = row;
      this.col = col;
      this.distFromStart = distFromStart;
    }
  }

}
```

#### Bellman-Ford算法

<div class="container">
  <iframe width="560" height="315" src="https://www.youtube.com/embed/c0aFMkpW5Lo" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>

<div class="container">
  <iframe width="560" height="315" src="https://www.youtube.com/embed/bxC1y6MsNlQ" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>

需要注意的是，在遍历所有的边来进行松弛操作前，需要先对 dist 进行备份，否则会出现「本次松弛操作所使用到的边，也是在同一次迭代所更新的」，从而不满足边数限制的要求。

举个例子，例如本次松弛操作使用了从 a 到 b 的当前最短距离来更新 dist[b]，直接使用 dist[a] 的话，不能确保 dist[a] 不是在同一次迭代中所更新，如果 dist[a] 是同一次迭代所更新的话，那么使用的边数将会大于 k 条。

因此在每次迭代开始前，我们都应该对 dist 进行备份，在迭代时使用备份来进行松弛操作。

##### 模版
```java
/**
 * @param s     起点
 * @param k     得到使用小于等于k条边的最短路径
 * @param edges 边集数组存储的图
 * @param dist  用于得到第s个顶点到其它顶点之间的最短距离
 * @return 是否存在负环，返回true，则存在负环
 */
boolean bellmanFord(int s, int k, List<Edge> edges, int[] dist) {
  // 初始化dist。此处不使用Integer.MAX_VALUE，而是除2的原因：防止 distClone[edge.begin] + edge.weight 数据溢出
  Arrays.fill(dist, Integer.MAX_VALUE / 2);
  dist[s] = 0;

  // 执行k次
  for (int i = 0; i < k; i++) {
    // 对 dist 进行备份，在迭代时使用备份来进行松弛操作
    int[] distClone = dist.clone();
    // 用来标记此轮操作中是否对顶点进行了松弛操作
    boolean flag = false;
    for (Edge edge : edges) {
      if (dist[edge.end] > distClone[edge.begin] + edge.weight) {
        dist[edge.end] = distClone[edge.begin] + edge.weight;
        flag = true;
      }
    }
    if (!flag) {
      // 此时flag为false, 说明此轮操作中没有顶点进行松弛操作，说明已经找到了所有顶点的做短路径, 且不存在负环
      return false;
    }
  }

  // 再执行1次，用来判断是否有负环；如果还能松弛, 则说明有负环
  for (Edge edge : edges) {
    if (dist[edge.end] > dist[edge.begin] + edge.weight) {
      return true;
    }
  }
  return false;
}


/**
 * 使用边集数组存储图
 */
class Edge {
  int begin, end, weight;

  Edge(int begin, int end, int weight) {
    this.begin = begin;
    this.end = end;
    this.weight = weight;
  }
}
```

##### 例题1: K 站中转内最便宜的航班
[K 站中转内最便宜的航班](https://leetcode.cn/problems/cheapest-flights-within-k-stops/)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220602124644.png)

代码：
```java
class Solution {
  public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {
    List<Edge> edges = new ArrayList();
    for (int i = 0; i < flights.length; i++) {
      edges.add(new Edge(flights[i][0], flights[i][1], flights[i][2]));
    }
    int[] dist = new int[n];
    bellmanFord(src, k + 1, edges, dist);
    return dist[dst] == Integer.MAX_VALUE / 2 ? -1 : dist[dst];
  }

 		/**
		 * @param s     起点
		 * @param k     得到使用小于等于k条边的最短路径
		 * @param edges 边集数组存储的图
		 * @param dist  用于得到第s个顶点到其它顶点之间的最短距离
		 * @return 是否存在负环，返回true，则存在负环
		 */
		boolean bellmanFord(int s, int k, List<Edge> edges, int[] dist) {
			// 初始化dist
			Arrays.fill(dist, Integer.MAX_VALUE / 2);
			dist[s] = 0;

			// 执行k次
			for (int i = 0; i < k; i++) {
				// 对 dist 进行备份，在迭代时使用备份来进行松弛操作
				int[] distClone = dist.clone();
				// 用来标记此轮操作中是否对顶点进行了松弛操作
				boolean flag = false;
				for (Edge edge : edges) {
					if (dist[edge.end] > distClone[edge.begin] + edge.weight) {
						dist[edge.end] = distClone[edge.begin] + edge.weight;
						flag = true;
					}
				}
				if (!flag) {
					// 此时flag为false, 说明此轮操作中没有顶点进行松弛操作，说明已经找到了所有顶点的做短路径, 且不存在负环
					return false;
				}
			}

			// 在执行1次，还能松弛则说明有负环
			for (Edge edge : edges) {
				if (dist[edge.end] > dist[edge.begin] + edge.weight) {
					return true;
				}
			}
			return false;
		}


		/**
		 * 使用边集数组存储图
		 */
		class Edge {
			int begin, end, weight;

			Edge(int begin, int end, int weight) {
				this.begin = begin;
				this.end = end;
				this.weight = weight;
			}
		}
}
```

#### SPFA算法

<div class="container">
  <iframe width="560" height="315" src="https://www.youtube.com/embed/r4MSAJ9Y0Ek" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>

##### 模版:
```java
/**
 * @param startState 起点状态
 * @param n          节点个数
 * @param dist       用于得到起点到其它顶点之间的最短距离
 * @param graph      图
 * @return 是否存在负环，返回true，则存在负环
 */
boolean spfa(State startState, int n, int[] dist, List<int[]>[] graph) {
  Queue<State> queue = new LinkedList<>();
  // 标记顶点是否正在队列中
  boolean[] used = new boolean[n];
  // 标记顶点进入了几次队列
  int[] num = new int[n];
  Arrays.fill(dist, Integer.MAX_VALUE);
  dist[startState.id] = 0; //第s个顶点到自身距离为0
  queue.add(startState); // 第s个顶点入队
  num[startState.id] = 1; // 表示第s个顶点已进入了1次队列
  used[startState.id] = true; // 表示第s个节点正在队列中

  while (!queue.isEmpty()) {
    State currentState = queue.poll();
    used[currentState.id] = false;

    List<State> nextStates = new ArrayList<>();
    for (int[] neighbor : graph[currentState.id]) {
      nextStates.add(new State(neighbor[0], dist[currentState.id] + neighbor[1]));
    }

    for (State nextState : nextStates) {
      if (dist[nextState.id] > nextState.distFromStart) {
        dist[nextState.id] = nextState.distFromStart;
        if (!used[nextState.id]) {
          queue.add(nextState);
          num[nextState.id]++;
          if (num[nextState.id] > n) {
            return false;
          }
          used[nextState.id] = true;
        }
      }
    }
  }
  return false;
}

// 辅助类, 用于优先队列
class State {
    // 图节点的 id
    int id;
    // 从 start 节点到当前节点的距离
    int distFromStart;

    State(int id, int distFromStart) {
        this.id = id;
        this.distFromStart = distFromStart;
    }
}
```

## 最小生成树
最小生成树与最短路径的区别:
- 最短路径是求两个点之间的最短距离
- 最小生成树是求生成树中所有边上的权值之和最小

![](https://raw.githubusercontent.com/NaisWang/images/master/20220603094800.png)

### Prim算法
Prim的算法执行与Dijkstra算法十分相似。都是使用了贪心策略。Prim与Dijkstra只有贪心策略不同，其他部分代码逻辑一样。Prim的贪心策略为：每次从集合中选取**边**权值最小的节点。

#### 模版
```java
/**
 * @param startState 开始状态
 * @param graph      图的表示方式，这里是使用的带有的权值的邻接表的表示方式
 * @return 最小生成树中的每个节点边的权值
 */
int[] prim(State startState, List<int[]>[] graph) {
  Queue<State> pq = new PriorityQueue<>((a, b) -> {
    return a.distValue - b.distValue;
  });

  int[] dist = new int[graph.length];
  Arrays.fill(dist, Integer.MAX_VALUE);
  dist[startState.id] = 0;

  boolean[] isSelected = new boolean[graph.length];

  pq.add(startState);
  while (!pq.isEmpty()) {
    State currentState = pq.poll();

    if (isSelected[currentState.id]) {
      continue;
    }
    isSelected[currentState.id] = true;

    List<State> nextStates = new ArrayList();
    for (int[] neighbor : graph[currentState.id]) {
      nextStates.add(new State(neighbor[0], neighbor[1]));
    }

    for (State nextState : nextStates) {
      if (isSelected[nextState.id]) continue;
      if (dist[nextState.id] > nextState.distValue) {
        dist[nextState.id] = nextState.distValue;
        pq.add(nextState);
      }
    }

  }
  return dist;
}

class State {
  // 节点的id
  int id;
  // 节点相连的边的权值
  int distValue;

  public State(int id, int distValue) {
    this.id = id;
    this.distValue = distValue;
  }
}
```

你会发现此模版与Dijkstra模版几乎一摸一样

#### 例题1: 连接所有点的最小费用
[连接所有点的最小费用](https://leetcode.cn/problems/min-cost-to-connect-all-points/)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220603113058.png)

代码:
```java
class Solution {
  public int minCostConnectPoints(int[][] points) {
    int n = points.length;

    // 构建图
    List<int[]>[] graph = new ArrayList[n];
    for (int i = 0; i < n; i++) {
      graph[i] = new ArrayList();  
    }
    for (int i = 0; i < n; i++) {
      for (int j = i + 1; j < n; j++) {
        graph[i].add(new int[]{j, Math.abs(points[i][0] - points[j][0]) + Math.abs(points[i][1] - points[j][1])});
        graph[j].add(new int[]{i, Math.abs(points[i][0] - points[j][0]) + Math.abs(points[i][1] - points[j][1])});
      }
    }
    
    int res = 0;
    int[] dist = prim(new State(0, 0), graph); 
    for (int i = 0; i < dist.length; i++) {
      res += dist[i];
    }
    return res;
  }

  /**
  * @param startState 开始状态
  * @param graph      图的表示方式，这里是使用的带有的权值的邻接表的表示方式
  * @return 最小生成树中的每个节点边的权值
  */
  int[] prim(State startState, List<int[]>[] graph) {
    Queue<State> pq = new PriorityQueue<>((a, b) -> {
      return a.distValue - b.distValue;
    });
  
    int[] dist = new int[graph.length];
    Arrays.fill(dist, Integer.MAX_VALUE);
    dist[startState.id] = 0;
  
    boolean[] isSelected = new boolean[graph.length];
  
    pq.add(startState);
    while (!pq.isEmpty()) {
      State currentState = pq.poll();
  
      if (isSelected[currentState.id]) {
        continue;
      }
      isSelected[currentState.id] = true;
  
      List<State> nextStates = new ArrayList();
      for (int[] neighbor : graph[currentState.id]) {
        nextStates.add(new State(neighbor[0], neighbor[1]));
      }
  
      for (State nextState : nextStates) {
        if (isSelected[nextState.id]) continue;
        if (dist[nextState.id] > nextState.distValue) {
          dist[nextState.id] = nextState.distValue;
          pq.add(nextState);
        }
      }
  
    }
    return dist;
  }
  
  class State {
    // 节点的id
    int id;
    // 节点相连的边的权值
    int distValue;
  
    public State(int id, int distValue) {
      this.id = id;
      this.distValue = distValue;
    }
  }

}
```

## 拓扑排序

<div class="container">
  <iframe width="560" height="315" src="https://www.youtube.com/embed/ncT9q9Astr4" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>

<div class="container">
  <iframe src="https://drive.google.com/file/d/1NWqA9dpe9K42qQhKA6qhjlw-C7tCM0QA/preview" width="640" height="480" allow="autoplay"></iframe>
</div>

![](https://raw.githubusercontent.com/NaisWang/images/master/20220724225118.png)

### 模版
BFS入度表法（Kahn算法）模版4步骤
1. 建图
2. 建入度
3. 找入口
4. BFS拓扑排序

代码： 
```java
/**
 * 是否能生成拓扑排序
 * @param n 顶点个数
 * @return
 */
public boolean canFinish(int n, int[][] edges) {
  // 1. 建图
  List<Integer>[] graph = new List[n];
  for (int i = 0; i < n; i++) {
    graph[i] = new ArrayList<>();
  }
  // 2. 建入度
  int[] indegree = new int[n];
  for (int[] edge : edges) {
    graph[edge[0]].add(edge[1]);
    indegree[edge[1]]++;
  }
  // 3. 找到有向图的入口，即入度为0的点
  Queue<Integer> q = new LinkedList<>();
  for (int i = 0; i < n; i++) {
    if (indegree[i] == 0) {
      q.add(i);
    }
  }
  // 4. BFS拓扑排序
  int cnt = 0; // 以排序的节点
  while (!q.isEmpty()) {
    int cur = q.poll();
    cnt++;

    for (int next : graph[cur]) {
      if (--indegree[next] == 0) q.add(next);
    }
  }
  return cnt == n;
}
```

### 例题1: 课程表
[课程表](https://leetcode.cn/problems/course-schedule/)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220724222745.png)

代码：
```java
class Solution {
  public boolean canFinish(int n, int[][] edges) {
    // 1. 建图
    List<Integer>[] graph = new List[n];
    for (int i = 0; i < n; i++) {
      graph[i] = new ArrayList<>();
    }
    // 2. 建入度
    int[] indegree = new int[n];
    for (int[] edge : edges) {
      graph[edge[1]].add(edge[0]);
      indegree[edge[0]]++;
    }
    // 3. 找到有向图的入口，即入度为0的点
    Queue<Integer> q = new LinkedList<>();
    for (int i = 0; i < n; i++) {
      if (indegree[i] == 0) {
        q.add(i);
      }
    }
    // 4. BFS拓扑排序
    int cnt = 0; // 以排序的节点
    while (!q.isEmpty()) {
      int cur = q.poll();
      cnt++;
      for (int next : graph[cur]) {
        if (--indegree[next] == 0) q.add(next);
      }
    }
    return cnt == n;
  }
}
```

### 例题2: 课程表 II
[课程表 II](https://leetcode.cn/problems/course-schedule-ii/)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220724232120.png)

代码：
```java
class Solution {
  public int[] findOrder(int numCourses, int[][] prerequisites) {
    // 1. 建图
    List<Integer>[] graph = new List[numCourses];
    for (int i = 0; i < numCourses; i++) {
      graph[i] = new ArrayList();
    }
    // 2. 建入度
    int[] indegree = new int[numCourses];
    for (int[] prerequisite : prerequisites) {
      graph[prerequisite[1]].add(prerequisite[0]);
      indegree[prerequisite[0]]++;
    }
    // 3. 找到有向图的入口，即入度为0的点
    Queue<Integer> queue = new LinkedList();
    for (int i = 0; i < numCourses; i++) {
      if (indegree[i] == 0) {
        queue.add(i);
      }
    }
    // 拓扑排序
    int cnt = 0;
    int[] res = new int[numCourses];
    while (!queue.isEmpty()) {
      int cur = queue.poll();
      res[cnt++] = cur;
      for (int next : graph[cur]) {
        if (--indegree[next] == 0) queue.add(next);
      }
    }

    if (cnt == numCourses) {
      return res;
    }
    return new int[0];
  }
}
```

# 动态规划
动态规划通过组合子问题的解来求解原问题，一般来说，动态规划应用于**重叠子问题**的情况，即不同的子问题具有公共的子子问题。

动态规划算法对每个子子问题**只求解一次**，将其解保存在一个表格中，从而无需每次求解一个子子问题时都重新计算，避免了这种不必要的计算工作。

动态规划有两种实现方法：
- 第一种方法称为**带备忘的自顶向下法（top-down with memoization）**, 即**带备忘录的递归**。此方法仍按自然的递归形式编写过程，但过程会保存每个子问题的解（通常保存在一个数组或散列表中）。当需要一个子问题的解时，过程首先检查是否已经保存过此解。如果是，则直接返回保存的值，从而节省了计算时间；否则，按通常方式计算这个子问题。我们称这个递归过程是带备忘的（memoized），因为它“记住”了之前已经计算出的结果。
- 第二种方法称为**自底向上法（bottom-up method）**。这种方法一般需要恰当定义子问题“规模”的概念，使得任何子问题的求解都只依赖于“更小的"子问题的求解。因而我们可以将子问题按规模排序，按由小至大的顺序进行求解。当求解某个子问题时，它所依赖的那些更小的子问题都已求解完毕，结果已经保存。每个子问题只需求解一次，当我们求解它（也是第一次遇到它）时，它的所有前提子问题都已求解完成。

以上两个实现方法的核心思想就是**保存子问题的值，解决重叠子问题重复计算的问题**。 而我们常用一个数组来保存子问题的值，而这个数组就是备忘录或dp数组。这个备忘录或dp数组能表达如下2中意思：
- `状态`， 由数组的下标确定, 不同的数组下标对应不同的状态
- `状态对应的值`, 由数组的值确定

所以我们在使用备忘录或dp数组时，一定要深知该表达的 状态以及该状态对应的值 所表达的含义

## 动态规划的三个特征
”三个特征“分别为最优子结构、无后效性和重复子问题

#### 最优子结构
最优子结构指的是，问题的最优解包含子问题的最优解。反过来说就是，可以通过子问题的最优解，推导出问题的最优解。

若把最优子结构对应到前面定义的动态规划问题模型上，可以理解为，后面阶段的状态可以通过前面阶段的状态推导出来。

例如，现在有`min_dist(i, j) = w[i][j] + min(min_dist(i, j-1), min_dist(i-1, j))`状态转移方程，即`dp(i, j)` 可以通过 `dp(i, j-1)` 和 `dp(i-1, j)` 两个状态推导出来。这就说明，这个问题符合“最优子结构”。

### 无后效性
无后效性有两层含义
- 第一层含义是，在推导后面阶段的状态的时候，只关心前面阶段的状态值，不关心这个状态是怎么一步一步推导出来的。
- 第二层含义是，某阶段状态一旦确定，就不受之后阶段的决策影响。

例如在求最长上升子序列中，如果把子问题定义为"求序列的前n个元素的最长上升子序列的长度"。这个子问题是不具有“无后效性”的。分析如下：

假设F(n) = x, 但可能有多个序列满足F(n) = x。有的序列的最后一个元素比$a_(n+1)$小, 则加上$a_(n+1)$就能形成更长上升子序列；有的序列最后一个元素不比$a_(n+1)$小...以后的事情受如何达到状态n的影响，不符合“无后效性”

**递归中子问题可以不是无后效性的, 但是如果能将递归转换成自底向上的动态规划, 此时的子问题一定是无后效性的。当我们选取子问题时 最好选择无后效性是子问题, 因为无后效性的子问题比有后效性的易处理**

### 重复子问题
不同的决策序列，到达某个相同的阶段时，可能会产生重复的状态。

## 步骤

![](https://raw.githubusercontent.com/NaisWang/images/master/20220408163551.png)

### 例题：打家劫舍(力扣198)
你是一个小偷，现在有一排相邻的房屋等着你去偷窃。这些房子装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。给定一个代表每个房屋存放金额的正整数数组，计算你不触动警报装置的情况下，一夜之内能够偷窃到的最高金额。（不用考虑偷窃时间）
```
示例1：
输入：[1，2，3，1，3]
输出：7解释：偷窃1号房屋（金额=1），然后偷窃3号房屋（金额=3），接着偷窃5号房屋（金额=3）。偷窃到的最高金额=1+3+3=7。
示例2：
输入：[2，7，2，3，8]
输出：15解释：偷窃2号房屋（金额=7），然后偷窃5号房屋（金额=8）。偷窃到的最高金额=7+8=15。
```

#### 分析1
递归分析：
1. 节点的作用: 当第一家偷的是第now家且以后偷的家都是大于now时的最大偷窃金额
2. 父子节点之间的关系: 子节点表示在父节点情况下第二家偷的情况
3. 节点不能生成子节点的情况: 没有下一家可以偷了

递归树:

![](https://raw.githubusercontent.com/NaisWang/images/master/20220408163642.png)

代码：
```java
public class Main {
  public static void main(String args[]) {
    Solution so = new Solution();
    System.out.println(so.rob(new int[]{1, 2, 3, 1, 3}));
  }
}

class Solution {
  private int length;

  public int rob(int[] nums) {
    length = nums.length; 
    return dfs(-2, nums);
  }

  private int dfs(int now, int[] nums) {
    if (now >= length - 2) {
      return nums[now];
    }
    int maxNum = Integer.MIN_VALUE;
    for (int i = now + 2; i < length; i++) {
      maxNum = Math.max(maxNum, dfs(i, nums));
    }
    if(now == -2) return maxNum;
    return maxNum + nums[now];
  }
}
```

我们发现出现子问题重复计算的情况，因此我们用备忘录来存储子问题；此处的备忘录可以设置为`dp[i]`, 表示当第一家偷的是i时，最大偷窃金额为`dp[i]`。定义完备忘录后，简化递归树:

![](https://raw.githubusercontent.com/NaisWang/images/master/20220408163820.png)

代码：
```java
public class Main {
  public static void main(String args[]) {
    Solution1 so = new Solution1();
    System.out.println(so.rob(new int[]{1, 2, 3, 1, 3}));
  }
}

class Solution1 {
  private int[] dp = null;
  private int length;

  public int rob(int[] nums) {
    length = nums.length; 
    dp = new int[length];
    initDp();
    return dfs(-2, nums);
  }

  private void initDp() {
    for (int i = 0; i < length; i++) {
      dp[i] = -1; 
    }
  }

  private int dfs(int now, int[] nums) {
    if (now >= length -2) {
      return nums[now];
    }
    int maxNum = Integer.MIN_VALUE;
    for (int i = now + 2; i < length; i++) {
      if(dp[i] == -1){
        dp[i] = dfs(i, nums);
      }
      maxNum = Math.max(maxNum, dp[i]);
    }
    if(now == -2) return maxNum;
    return maxNum + nums[now];
  }
}
```

通过分析发现，无法推出备忘录中的各个数据之间的通项公式, 所以只能使用上述的带有备忘录的递归，而不能使用自底向上法

#### 分析2

递归分析：
1. 节点的作用: 求自在前now家（包括第now家）偷时，最大的偷窃金额
2. 父子节点之间的关系: 子节点表示在父节点情况下第二家偷的情况
3. 节点不能生成子节点的情况: 没有下一家可以偷了

递归树：

![](https://raw.githubusercontent.com/NaisWang/images/master/20220408163831.png)

代码
```java
public class Main {
  public static void main(String args[]) {
    Solution so = new Solution();
    System.out.println(so.rob(new int[]{1, 2, 3, 1, 3}));
  }
}

class Solution {
  public int rob(int[] nums) {
    return dfs(nums.length-1, nums);
  }

  private int dfs(int now, int[] nums) {
    if(now == 0) return nums[0];
    if(now == 1) return Math.max(nums[1], nums[0]);
    return Math.max(dfs(now-1, nums), dfs(now-2, nums) + nums[now]);
  }
}
```

**子问题分析：**
- 子问题的范围: 只在前now家（包括第now家）偷
- 子问题的属性：最大偷窃金额

我们发现出现子问题重复计算的情况，因此我们用备忘录来存储子问题；此处的备忘录可以设置为`dp[i]`, 表示只在前i家偷时，最大偷窃金额为`dp[i]`。定义完备忘录后，简化递归树:

![](https://raw.githubusercontent.com/NaisWang/images/master/20220408164255.png)

代码：
```java
public class Main {
  public static void main(String args[]) {
    Solution so = new Solution();
    System.out.println(so.rob(new int[]{1, 2, 3, 1, 3}));
  }
}

class Solution {
  private int[] dp = null;

  public int rob(int[] nums) {
    int length = nums.length;
    dp = new int[length];
    initDp(length); 
    return dfs(nums.length-1, nums);
  }

  private void initDp(int length) {
    for (int i = 0; i < length; i++) {
      dp[i] = -1; 
    }
  }

  private int dfs(int now, int[] nums) {
    if(now == 0) return nums[0];
    if(now == 1) return Math.max(nums[1], nums[0]);
    if(dp[now-1] == -1) {
      dp[now-1] = dfs(now-1, nums);
    }
    if(dp[now-2] == -1) {
      dp[now-2] = dfs(now-2, nums);
    }
    return Math.max(dp[now-1], dp[now-2] + nums[now]);
  }
}
```

通过分析发现，可以推出备忘录中的各个数据之间的通项公式为
$$dp(now) = \begin{cases}
nums[0] & now = 0 \\
max(nums[0], nums[1]) & now = 1 \\
max\{dp(now-1), dp(now-2) + nums[now]\} & now \geq 2
\end{cases}$$


所以可以使用从底向上法，代码如下：
```java
public class Main {
  public static void main(String args[]) {
    Solution4 so = new Solution4();
    System.out.println(so.rob(new int[]{1, 2, 3, 1, 3}));
  }
}

class Solution4 {
  public int rob(int[] nums) {
    int length = nums.length;
    if (length == 1) return nums[0]; 
    if (length == 2) return Math.max(nums[0], nums[1]);
    int[] dp = new int[length];
    dp[0] = nums[0];
    dp[1] = Math.max(nums[0], nums[1]);
    for (int i = 2; i < length; i++) {
      dp[i] = Math.max(dp[i-1], dp[i-2] + nums[i]);
    }
    return dp[length-1];
  }
}
```

### 0-1背包问题
[0-1背包问题-模板题](https://www.acwing.com/problem/content/2/)

分析：
当输入为：
```
4 5
1 2
2 4
4 4
4 5
```
递归树：

![](https://raw.githubusercontent.com/NaisWang/images/master/20220408164308.png)

代码：
```java
class Solution1 {

  public int solution(int N, int V, int[] v, int[] w) {
    return dfs(N, V, v, w);
  }

  private int dfs(int nowN, int nowV, int[] v, int[] w) {
    if (nowN == 1) {
      if (nowV >= v[1]) {
        return w[1];
      }
      return 0;
    } 

    int min = Integer.MIN_VALUE;
    if (nowV >= v[nowN] ) {
      min = dfs(nowN - 1, nowV - v[nowN], v, w) + w[nowN];
    }

    return Math.max(min, dfs(nowN - 1, nowV, v, w));
  }
  
}
```
**子问题分析：**
- 子问题的范围: 当在前nowN个物品（包括第nowN个物品）中选，且背包容量为nowV时
- 子问题的属性：总价值最大

经过分析：发现子问题符合`无后效性`

我们发现出现子问题重复计算的情况，因此我们用备忘录来存储子问题；
此处的备忘录可以设置为`dp[nowN][nowV]`, 表示当在前nowN个物品（包括第nowN个物品）中选，且背包容量为nowV时, 总价值最大为`dp[nowN][nowV]`
定义完备忘录后，简化递归树:

![](https://raw.githubusercontent.com/NaisWang/images/master/20220408164321.png)

代码：
```java
class Solution2 {

  private Integer[][] dp = null; 

  public int solution(int N, int V, int[] v, int[] w) {
    dp = new Integer[N+1][V+1];
    return dfs(N, V, v, w);
  }

  private int dfs(int nowN, int nowV, int[] v, int[] w) {
    if (nowN == 1) {
      if (nowV >= v[1]) {
        return w[1];
      }
      return 0;
    } 
    if (nowV >= v[nowN] ) {
      if (dp[nowN - 1][nowV - v[nowN]] == null) {
        dp[nowN - 1][nowV - v[nowN]] = dfs(nowN - 1, nowV - v[nowN], v, w);
      }
    } 
    if (dp[nowN - 1][nowV] == null) {
      dp[nowN - 1][nowV] = dfs(nowN - 1, nowV, v, w);
    } 
    return Math.max(nowV >= v[nowN] ? dp[nowN - 1][nowV - v[nowN]] + w[nowN] : 0, dp[nowN - 1][nowV]);
  }
  
}
```

通过分析发现，可以推出备忘录中的各个数据之间的通项公式为
$$dp[nowN][nowV] = \begin{cases}
dp[nowN-1][nowV] & nowV < v[nowN] \\
max(dp[nowN - 1][nowV - v[nowN]] + w[nowN], dp[nowN - 1][nowV]) & nowV \geq v[nowN] \\
\end{cases}$$


所以可以使用从底向上法，代码如下：
```java
class Solution3 {
  public int solution(int N, int V, int[] v, int[] w) {
    int[][] dp = new int[N+1][V+1];
    for (int nowN = 1; nowN <= N; nowN++) {
      for (int nowV = 0; nowV <= V; nowV++) {
        if (nowV < v[nowN]) {
          dp[nowN][nowV] = dp[nowN - 1][nowV];
        } else {
          dp[nowN][nowV] = Math.max(dp[nowN - 1][nowV - v[nowN]] + w[nowN], dp[nowN - 1][nowV]);
        }
      }
    }
    return dp[N][V]; 
  }
}
```
可以使用滚动数组讲将dp数组从二维降到一维，代码如下：
```java
class Solution {
  public int solution(int N, int V, int[] v, int[] w) {
    int[] dp = new int[V+1];
    for (int i = 1; i <= N; i++) {
      for (int j = V; j >= v[i]; j--) {
        dp[j] = Math.max(dp[j], dp[j - v[i]] + w[i]);
      }
    }
    return dp[V]; 
  }
}
```

### 完全背包问题
[完全背包问题-模板题](https://www.acwing.com/problem/content/3/)
完全背包问题与0-1背包问题的不同点在于完全背包问题中的每种物品都有无限件可用

分析：
当输入为：
```
4 5
1 2
2 4
4 4
4 5
```
递归树：

![](https://raw.githubusercontent.com/NaisWang/images/master/20220408164333.png)

代码：
```java
class Solution1 {
  public int solution(int N, int V, int[] v, int[] w) {
    return dfs(N, V, v, w);
  }
  
  private int dfs(int nowN, int nowV, int[] v, int[] w) {
    if (nowN == 1) {
      return nowV / v[1] * w[1];
    }
    int maxNum = nowV / v[nowN];
    int max = Integer.MIN_VALUE;
    for (int i = 0; i <= maxNum; i++) {
      max = Math.max(max, dfs(nowN - 1, nowV - i * v[nowN], v, w) + i * w[nowN]);
    }
    return max;
  }
}
```
**子问题分析：**
- 子问题的范围: 当在前nowN个物品（包括第nowN个物品）中选，且背包容量为nowV时
- 子问题的属性：总价值最大

经过分析：发现子问题符合`无后效性`

我们发现出现子问题重复计算的情况，因此我们用备忘录来存储子问题；
此处的备忘录可以设置为`dp[nowN][nowV]`, 表示当在前nowN个物品（包括第nowN个物品）中选，且背包容量为nowV时, 总价值最大为`dp[nowN][nowV]`
定义完备忘录后，简化递归树:

![](https://raw.githubusercontent.com/NaisWang/images/master/20220408164352.png)

代码：
```java
class Solution2 {
  private Integer[][] dp = null;

  public int solution(int N, int V, int[] v, int[] w) {
    dp = new Integer[N + 1][V + 1];
    return dfs(N, V, v, w);
  }
  
  private int dfs(int nowN, int nowV, int[] v, int[] w) {
    if (nowN == 1) {
      return nowV / v[1] * w[1];
    }
    int maxNum = nowV / v[nowN];
    int max = Integer.MIN_VALUE;
    for (int i = 0; i <= maxNum; i++) {
      if (dp[nowN - 1][nowV - i * v[nowN]] == null) {
        dp[nowN - 1][nowV - i * v[nowN]] = dfs(nowN - 1, nowV - i * v[nowN], v, w); 
      } 
      max = Math.max(max, dp[nowN - 1][nowV - i * v[nowN]] + i * w[nowN]);
    }
    return max;
  }
}
```

通过分析发现，于是易得状态转移方程：
`$dp[nowN][nowV]=max( dp[nowN−1][nowV], dp[nowN−1][nowV−v[nowN]]+w[nowN], dp[nowN-1][nowV−2*v[nowN]]+2*w[nowN],...)$`

但是这个东西项数太多，想办法把它转换成两项

由上面的状态转移方程我们可以得到：
`$dp[nowN][nowV−v[nowN]]=max(dp[nowN−1][nowV−v[nowN]], dp[nowN−1][nowV−2*v[nowN]]+w[nowN], dp[nowN−1][nowV−3*v[nowN]]+2*w[nowN] ,...)$`
观察得到，上面的第二项后面的每一项都是下面的每一项加上一个$W_i$。

于是我们可以得到状态转移方程：
$dp[nowN][nowV]=max(dp[nowN−1][nowV] , dp[nowN][nowV-v[nowN]]+w[nowN]$

$$dp[nowN][nowV] = \begin{cases}
dp[nowN-1][nowV] & nowV < v[nowN] \\
max(dp[nowN−1][nowV] , dp[nowN][nowV-v[nowN]]+w[nowN] & nowV \geq v[nowN] \\
\end{cases}$$

代码：
```java
class Solution3 {

  private int[][] dp;

  public int solution(int N, int V, int[] v, int[] w) {
    dp = new int[N + 1][V + 1];
    for (int nowN = 1; nowN <= N; nowN++) {
      for (int nowV = 0; nowV <= V; nowV++) {
        if (nowV < v[nowN]) {
          dp[nowN][nowV] = dp[nowN - 1][nowV];
        } else {
          dp[nowN][nowV] = Math.max(dp[nowN - 1][nowV], dp[nowN][nowV -v[nowN]] + w[nowN]);
        }
      }
    }
    return dp[N][V];
  }
}
```

### 最长公共子序列
[最长公共子序列](https://leetcode.cn/problems/qJnOS7/)

给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0 。

一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。
- 例如，"ace" 是 "abcde" 的子序列，但 "aec" 不是 "abcde" 的子序列。
两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。

示例 1：
```txt
输入：text1 = "abcde", text2 = "ace" 
输出：3  
解释：最长公共子序列是 "ace" ，它的长度为 3 。
```

示例 2：
```txt
输入：text1 = "abc", text2 = "abc"
输出：3
解释：最长公共子序列是 "abc" ，它的长度为 3 。
```

示例 3：
```txt
输入：text1 = "abc", text2 = "def"
输出：0
解释：两个字符串没有公共子序列，返回 0 。
```

#### 分析

递归树：

![](https://raw.githubusercontent.com/NaisWang/images/master/20220511200641.png)

代码:

```java
class Solution {

	public int longestCommonSubsequence(String text1, String text2) {
		return dfs(0, 0, text1, text2);
	}

	private int dfs(int i, int j, String text1, String text2) {
		if (i == text1.length() || j == text2.length()) {
			return 0;
		}
		if (text1.charAt(i) == text2.charAt(j)) {
			int temp = dfs(i + 1, j + 1, text1, text2) + 1;
			return temp;
		}
		int temp = Math.max(dfs(i + 1, j, text1, text2), dfs(i, j + 1, text1, text2));
		return temp;
	}

}

public class MainOfferII095 {
	public static void main(String[] args) {
		Solution solution = new Solution();
		System.out.println(solution.longestCommonSubsequence("abcde", "ace"));
	}
}
```

子问题分析：
- 子问题的范围: 第一个字符串从第i个字符到最后一个字符的子串与第二个字符串从第j个字符开始到最后一个字符到子串之间的最长公共子序列
- 子问题的属性：最长公共子序列的长度

经过分析：发现子问题符合`无后效性`

我们发现出现重复计算的情况，因此我们用备忘录来存储子问题；

此处的备忘录可以设置为`dp[i][j]`, 表示第一个字符串从第i个字符到最后一个字符的子串与第二个字符串从第j个字符开始到最后一个字符到子串之间的最长公共子序列的长度为`dp[i][j]`

定义完备忘录后，简化递归树:

![](https://raw.githubusercontent.com/NaisWang/images/master/20220511203152.png)

代码：
```java
class SolutionOfferII095 {

	private Integer[][] dp;

	public int longestCommonSubsequence(String text1, String text2) {
		dp = new Integer[text1.length() + 1][text2.length() + 1];
		return dfs(0, 0, text1, text2);
	}

	private int dfs(int i, int j, String text1, String text2) {
		if (i == text1.length() || j == text2.length()) {
			return 0;
		}
		if (text1.charAt(i) == text2.charAt(j)) {
			if (dp[i + 1][j + 1] == null) {
				dp[i + 1][j + 1] = dfs(i + 1, j + 1, text1, text2);
			}
			return dp[i + 1][j + 1] + 1;
		}
		if (dp[i + 1][j] == null) {
			dp[i + 1][j] = dfs(i + 1, j, text1, text2);
		} 
		if (dp[i][j + 1] == null) {
			dp[i][j + 1] = dfs(i, j + 1, text1, text2);
		} 
		int temp = Math.max(dp[i + 1][j], dp[i][j + 1]);
		return temp;
	}

}

public class MainOfferII095 {
	public static void main(String[] args) {
		SolutionOfferII095 solution = new SolutionOfferII095();
		System.out.println(solution.longestCommonSubsequence("abcde", "ace"));
	}
}
```

通过分析发现，可以推出备忘录中的各个数据之间的通项公式为

$$dp[i][j] = \begin{cases}
dp[i + 1][j + 1] + 1& text1[i] = text2[j] \\
max(dp[i + 1][j] , dp[i][j + 1] & text1[i] != text2[j] \\
\end{cases}$$

代码：
```java
class SolutionOfferII095 {
	private Integer[][] dp;

	public int longestCommonSubsequence(String text1, String text2) {
		dp = new Integer[text1.length() + 1][text2.length() + 1];
		return dp(text1, text2);
	}

	private int dp(String text1, String text2) {

		dpInit(text1, text2);

		for (int i = text1.length() - 1; i > -1; i--) {
			for (int j = text2.length() - 1; j > -1; j--) {
				if (text1.charAt(i) == text2.charAt(j)) {
					dp[i][j] = dp[i + 1][j + 1] + 1;
				} else {
					dp[i][j] = Math.max(dp[i + 1][j], dp[i][j + 1]);
				}
			}
		}
		return dp[0][0];
	}

	private void dpInit(String text1, String text2) {
		for (int i = 0; i <= text1.length(); i++) {
			dp[i][text2.length()] = 0;
		}

		for (int i = 0; i <= text2.length(); i++) {
			dp[text1.length()][i] = 0;
		}
	}
}

public class MainOfferII095 {
	public static void main(String[] args) {
		SolutionOfferII095 solution = new SolutionOfferII095();
		System.out.println(solution.longestCommonSubsequence("abcde", "ace"));
	}
}
```

## 分类

<div class="container">
  <iframe src="https://drive.google.com/file/d/1eUgyZnhG-hzndjY6eGhgQBQrBpx8q_I5/preview" width="640" height="480" allow="autoplay"></iframe>
</div>

<div class="container">
  <iframe src="https://drive.google.com/file/d/1JfH11RG_lcWEsJil6HXQyoVM408PN1QW/preview" width="640" height="480" allow="autoplay"></iframe>
</div>

视频链接：
- https://www.youtube.com/watch?v=0t9Dnc2rOz4
- https://www.youtube.com/watch?v=oN3jLuYTWKc
- https://www.youtube.com/watch?v=F_FOlOTStWE
- https://www.youtube.com/watch?v=jBOz9NTJ-Ko

### 序列上按结尾位置规划之单序列
#### 分析模版
- 状态：dp[i]="所有在i位置（选中第i位置）结束的对象中"，最优的解
- 下一个状态：dp[i - 1], dp[i - 2], ... , dp[0] 

#### 例题1: 最长递增子序列
[最长递增子序列](https://leetcode.cn/problems/longest-increasing-subsequence/)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220614102644.png)

##### 分析

- 状态：dp[i]="**以arr[i]结尾**的最长递增子序列的长度"
- 下一个状态：dp[j], if 0 <= j < i && arr[j] < arr[i]
- 父子状态之间的递推关系：dp[i] = max{dp[j] + 1, if 0 <= j < i && arr[j] < arr[i]}
- 初始条件：dp[0] = 1
- 最后的解答：dp数组中最大值

##### 分治法之递归树
以`nums = [0,1,0,3,2,3]`为例：

![](https://raw.githubusercontent.com/NaisWang/images/master/20220619181240.png)

##### 递归
```java
class Solution {
  int[] nums;
  public int lengthOfLIS(int[] nums) {
    this.nums = nums;
    return dfs(nums.length);
  }

  int dfs(int i) {
    int res = 0;
    for (int j = i - 1; j >= 0; j--) {
      if (i == nums.length || nums[j] < nums[i]) {
        res = Math.max(res, dfs(j) + 1);
      }
    }
    return res;
  }
}
```

##### 带有备忘录的递归
```java
class Solution {
  Integer[] dp;
  int[] nums;
  public int lengthOfLIS(int[] nums) {
    this.dp = new Integer[nums.length + 1]; 
    this.nums = nums; 
    return dfs(nums.length) - 1;
  }
  
  int dfs(Integer state) {
    if (dp[state] != null) {
      return dp[state];
    }
    List<Integer> nextStateList = new ArrayList();
    for (int i = state - 1; i >= 0; i--) {
      if (state == nums.length || nums[state] > nums[i]) {
        nextStateList.add(i); 
      }
    }

    int res = 1;
    for (Integer nextState : nextStateList) {
      res = Math.max(res, dfs(nextState) + 1); 
    }
    return dp[state] = res;
  }
}
```

#### 例题2: 最大子数组和
[最大子数组和](https://leetcode.cn/problems/maximum-subarray/)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220614104309.png)

##### 分析

- 状态：dp[i]="**以nums[i]结尾**的连续子数组中，可以产生的最大和"
- 下一个状态：dp[i - 1] 
- 父子状态之间的递推关系：dp[i] = max{nums[i], dp[i - 2] + nums[i]};
- 初始条件：dp[0] = nums[0]
- 最后的解答：dp数组中最大值

##### 分治法之递归树
以`nums = [-2,1,-3,4,-1,2,1,-5,4]`为例：

![](https://raw.githubusercontent.com/NaisWang/images/master/20220619164944.png)

##### 递归

```java
class Solution {
  Integer[] dp;
  int[] nums;
  public int maxSubArray(int[] nums) {
    this.nums = nums;
    this.dp = new Integer[nums.length];
    int res = Integer.MIN_VALUE;
    for (int i = nums.length - 1; i >= 0; i--) {
      res = Math.max(res, dfs(i));
    }
    return res; 
  }
  
  int dfs(Integer state) {
    if (dp[state] != null) return dp[state];
    int res = nums[state];
    if (state == 0) return res;
    res = Math.max(res, dfs(state - 1) + nums[state]); 
    return dp[state] = res;
  }
}
```

##### 递推式动态规划

代码：
```java
class Solution {
  Integer[] dp;
  int[] nums;
  public int maxSubArray(int[] nums) {
    this.nums = nums;
    this.dp = new Integer[nums.length];
    int res = Integer.MIN_VALUE;
    for (int i = nums.length - 1; i >= 0; i--) {
      res = Math.max(res, dfs(i));
    }
    return res; 
  }
  
  int dfs(Integer state) {
    if (dp[state] != null) return dp[state];
    int res = nums[state];
    if (state == 0) return res;
    res = Math.max(res, dfs(state - 1) + nums[state]); 
    dp[state] = res;
    return res;
  }
}
```

#### 例题3: 乘积最大子数组
[乘积最大子数组](https://leetcode.cn/problems/maximum-product-subarray/)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220614110829.png)

##### 分析
- 状态：dp[i]="**以nums[i]结尾**的连续子数组中，可以产生的最大乘积`dp[i][0]`与最小乘积`dp[i][1]`"
- 下一个状态：dp[i - 1]
- 父子状态之间的递推关系：
  - `dp[i][0] = Math.max(nums[i], Math.max(dp[i - 1][0] * nums[i], dp[i - 1][1] * nums[i]));`
  - `dp[i][1] = Math.min(nums[i], Math.min(dp[i - 1][0] * nums[i], dp[i - 1][1] * nums[i]));`
- 初始条件：dp[0] = new int[]{nums[0], nums[0]}
- 最后的解答：dp数组中最大值

##### 分治法之递归树
以`nums = [2,3,-2,4]`为例：

![](https://raw.githubusercontent.com/NaisWang/images/master/20220619193928.png)

##### 递归
```java
class Solution {
  int ans = Integer.MIN_VALUE;
  int[] nums;

  public int maxProduct(int[] nums) {
    this.nums = nums;
    dfs(nums.length - 1);
    return ans;
  }

  int[] dfs(int i) {
    if (i == 0) {
      ans = Math.max(ans, nums[i]);
      return new int[]{nums[i], nums[i]};
    }
    int[] res = new int[]{nums[i], nums[i]};
    int[] temp = dfs(i - 1);
    res[0] = Math.max(nums[i], Math.max(nums[i] * temp[0], nums[i] * temp[1]));
    res[1] = Math.min(nums[i], Math.min(nums[i] * temp[0], nums[i] * temp[1]));
    ans = Math.max(ans, res[0]);
    return res;
  }

}
```
##### 带有备忘录的动态规划
代码：
```java
class Solution {
  Integer[][] dp;
  int[] nums;
  public int maxProduct(int[] nums) {
    this.dp = new Integer[nums.length][2]; 
    this.nums = nums;
    int res = Integer.MIN_VALUE;
    for (int i = nums.length - 1; i >= 0; i--) {
      Integer[] temp = dfs(i);
      res = Math.max(res, temp[0]);
    }
    return res;
  }

  Integer[] dfs(int state) {
    if (dp[state][0] != null) return dp[state]; 
    Integer[] res = {nums[state], nums[state]}; 
    if (state == 0) return res;
    Integer[] temp = dfs(state - 1);
    res[0] = Math.max(res[0], Math.max(nums[state] * temp[0], nums[state] * temp[1]));
    res[1] = Math.min(res[1], Math.min(nums[state] * temp[0], nums[state] * temp[1]));
    return dp[state] = res;
  }

}
```

##### 递推式动态规划

代码：
```java
class Solution {
  public int maxProduct(int[] nums) {
    int[][] dp = new int[nums.length][2];
    dp[0] = new int[]{nums[0], nums[0]};
    int res = dp[0][0];
    for (int i = 1; i < nums.length; i++) {
      dp[i][0] = Math.max(nums[i], Math.max(dp[i - 1][0] * nums[i], dp[i - 1][1] * nums[i]));
      dp[i][1] = Math.min(nums[i], Math.min(dp[i - 1][0] * nums[i], dp[i - 1][1] * nums[i]));
      res = Math.max(res, dp[i][0]);
    }
    return res;
  }
}
```

#### 例题4: 单词拆分
[单词拆分](https://leetcode.cn/problems/word-break/)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220614141710.png)

##### 分析
- 状态：dp[i]="字符串s前i+1个字符组成的字符串`s[0..i]`是否能被空格拆分成若干个字典中出现的单词"
- 下一个状态：dp[j - 1]
- 父子状态之间的递推关系：dp[i] = (j == 0 || dp[j - 1]) && wordDictSet.contains(s.substring(j, i + 1))
- 最后的解答：dp[s.length - 1]

##### 分治法之递归树
以`s = "applepenapple", wordDict = ["apple", "pen"]`为例

![](https://raw.githubusercontent.com/NaisWang/images/master/20220619201528.png)

##### 递归
```java
class Solution {
  Set<String> wordDictSet;
  String s;
  public boolean wordBreak(String s, List<String> wordDict) {
    this.s = s;
    wordDictSet = new HashSet(wordDict);
    return dfs(s.length() - 1);
  }

  boolean dfs(int i) {
    for (int j = i; j >= 0; j--) {
      if (wordDictSet.contains(s.substring(j, i + 1))) {
        if (j == 0 || dfs(j - 1)) {
          return true;
        }  
      }
    }
    return false;
  }
}
```

##### 带有备忘录的递归
```java
class Solution {
  Boolean[] dp;
  StringBuilder sb;
  String s;
  List<String> wordDict;
  public boolean wordBreak(String s, List<String> wordDict) {
    this.dp = new Boolean[s.length()];
    sb = new StringBuilder(s);
    this.s = s;
    this.wordDict = wordDict;
    return dfs(s.length() - 1);
  }
  
  boolean dfs(Integer state) {
    if (state == -1) return true;
    if (dp[state] != null) return dp[state];
    List<Integer> nextStateList = new ArrayList();
    for (String word : wordDict) {
      if (state - word.length() + 1 >= 0 && sb.subSequence(state - word.length() + 1, state + 1).equals(word)) {
        nextStateList.add(state - word.length());
      }
    }
    for (Integer nextState : nextStateList) {
      if (dfs(nextState)) {
        return dp[state] = true;
      }
    }
    return dp[state] = false;
  }
}
```

##### 递推式动态规划

代码：
```java
class Solution {
  public boolean wordBreak(String s, List<String> wordDict) {
    Set<String> wordDictSet = new HashSet(wordDict);
    boolean[] dp = new boolean[s.length()];
    for (int i = 0; i < s.length(); i++) {
      for (int j = 0; j <= i; j++) {
        if ( (j == 0 || dp[j - 1]) && wordDictSet.contains(s.substring(j, i + 1))) {
          dp[i] = true;
          break;
        }
      }
    }
    return dp[s.length() - 1];
  }
}
```

#### 例题5: 单词拆分 II
[单词拆分 II](https://leetcode.cn/problems/word-break-ii/)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220615141745.png)

##### 分析

- 状态：dp[i]="字符串s前i+1个字符组成的字符串`s[0..i]`是否能被空格拆分成若干个字典中出现的单词"
- 下一个状态：dp[j - 1]
- 父子状态之间的递推关系：dp[i] = (j == 0 || dp[j - 1]) && wordDictSet.contains(s.substring(j, i + 1))
- 最后的解答：dp[s.length - 1]

##### 递归
```java
class Solution {
  
  List<String> ans = new ArrayList();
  String s;
  Set<Integer>[] prev;
  Set<String> wordDictSet;

  public List<String> wordBreak(String s, List<String> wordDict) {
    this.s = s;
    wordDictSet = new HashSet(wordDict);
    prev = new Set[s.length()];
    for (int i = 0; i < s.length(); i++) {
      prev[i] = new HashSet();
    }
    dfs(s.length() - 1);
    print(s.length() - 1, "");
    return ans;
  }


  boolean dfs(int i) {
    boolean flag  = false;
    for (int j = i; j >= 0; j--) {
      if (wordDictSet.contains(s.substring(j, i + 1))) {
        if (j == 0 || dfs(j - 1)) {
          prev[i].add(j - 1);
          flag = true;
        }
      }
    }
    return flag;
  }

  void print(Integer index, String str) {
    if (index == -1) {
      ans.add(str.trim()); 
      return;
    }

    for (Integer nextIndex : prev[index]) {
      print(nextIndex, s.substring(nextIndex + 1, index + 1) + " " + str);
    }
  }
  
}
```

##### 递推式动态规划

代码：
```java
class Solution {
  
  List<String> ans = new ArrayList();
  String s;
  List<Integer>[] dp;

  public List<String> wordBreak(String s, List<String> wordDict) {
    this.s = s;
    Set<String> wordDictSet = new HashSet(wordDict);
    dp = new List[s.length()];
    for (int i = 0; i < dp.length; i++) {
      dp[i] = new ArrayList();
    }
    for (int i = 0; i < s.length(); i++) {
      for (int j = 0; j <= i; j++) {
        if ((j == 0 || !dp[j - 1].isEmpty()) && wordDictSet.contains(s.substring(j, i + 1))) {
          dp[i].add(j - 1);
        }
      }
    }
    dfs(s.length() - 1, "");
    return ans;
  }

  void dfs(Integer index, String str) {
    if (index == -1) {
      ans.add(str.trim()); 
      return;
    }

    for (Integer nextIndex : dp[index]) {
      dfs(nextIndex, s.substring(nextIndex + 1, index + 1) + " " + str);
    }
  }
}
```

#### 例题6: 爬楼梯
[爬楼梯](https://leetcode.cn/problems/climbing-stairs/)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220614152002.png)

##### 分析
- 状态：dp[i]="爬到第i阶的方法种数"
- 下一个状态：dp[i - 1], dp[i - 2]
- 父子状态之间的递推关系：dp[i] = dp[i - 1] + dp[i - 2];
- 初始问题：dp[1] = 1, dp[2] = 2
- 最后的解答：dp[n]

##### 分治法之递归树
以`n = 10`为例：

![](https://raw.githubusercontent.com/NaisWang/images/master/20220619214508.png)

##### 递归
```java
class Solution {
  public int climbStairs(int n) {
    return dfs(n);
  }

  int dfs(int i) {
    int res = 0;
    if (i == 1 || i == 2) {
      return i;
    }
    for (int j = 1; j <= 2; j++) {
      res += dfs(i - j);
    }
    return res;
  }
}
```

##### 带有备忘录的递归
```java
class Solution {
  Integer[] dp;
  public int climbStairs(int n) {
    dp = new Integer[n + 1];
    return dfs(n);
  }

  int dfs(int n) {
    if (n == 0) return 1;
    if (n < 0) return 0;
    if (dp[n] != null) return dp[n];
    return dp[n] = dfs(n - 1) + dfs(n - 2);
  }
}
```

##### 递推式动态规划
代码：
```java
class Solution {
  public int climbStairs(int n) {
    int[] dp = new int[n + 1];
    dp[1] = 1;
    if (n == 1) return dp[n];
    dp[2] = 2;
    for (int i = 3; i <= n; i++) {
      dp[i] = dp[i - 1] + dp[i - 2];
    }
    return dp[n];
  }
}
```

#### 例题7: 解码方法
[解码方法](https://leetcode.cn/problems/decode-ways/)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220614172954.png)

##### 分析
- 状态：dp[i]="字符串s前i+1个字符组成的字符串`s[0..i]`的编码方法个数"
- 下一个状态：dp[i - 1], dp[i - 2]

##### 递归
```java
class Solution {
  char[] sCh;
  public int  numDecodings(String s) {
    sCh = s.toCharArray();
    return dfs(sCh.length - 1);
  }

  int dfs(int i) {
    if (i < 0) {
      return 1;
    }
    int res = 0;
    if (sCh[i] > '0') {
      res += dfs(i - 1);
    }
    if (i >= 1) {
      int temp = Integer.valueOf(sCh[i - 1] + "" + sCh[i]);
      if (temp >= 10 && temp <= 26) {
        res += dfs(i - 2);
      }
    }
    return res;
  }
}
```

##### 带有备忘录的递归
```java
class Solution {
  char[] sChs;
  Integer[] dp;
  public int numDecodings(String s) {
    sChs = s.toCharArray(); 
    dp = new Integer[sChs.length];
    return dfs(s.length() - 1);
  }

  int dfs(Integer state) {
    if (state == -1) return 1;
    if (dp[state] != null) return dp[state];
    List<Integer> nextStateList = new ArrayList();
    if (sChs[state] - '0' != 0) {
      nextStateList.add(state - 1);
    }
    if (state >= 1) {
      int temp = Integer.valueOf(sChs[state - 1] + "" +sChs[state]);
      if (temp >= 10 && temp <= 26) {
        nextStateList.add(state - 2);
      }
    }
    int res = 0;
    for (Integer nextState : nextStateList) {
      res += dfs(nextState);
    }
    return dp[state] = res;
  }

}
```

#### 例题8: 打家劫舍
[打家劫舍](https://leetcode.cn/problems/house-robber/)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220615144422.png)

##### 分析
- 状态：dp[i]="抢了第i家且只能抢前i家时的最高金额"
- 下一个状态：dp[j]
- 父子状态之间的递推关系：dp[i] = Math.max(dp[i], dp[j] + nums[i]);
- 初始化：dp[0] = nums[0]
- 最后的解答：dp数组中最大值

##### 递归
```java
class Solution {
  int[] nums;
  public int rob(int[] nums) {
    int n = nums.length;
    this.nums = nums; 
    int res = Integer.MIN_VALUE;
    for (int i = n - 1; i >= 0; i--) {
      res = Math.max(res, dfs(i));
    }
    return res;
  }
  
  int dfs(int i) {
    int res = nums[i];
    for (int j = i - 2; j >= 0; j--) {
      res = Math.max(res, dfs(j) + nums[i]);
    }
    return res;
  }
}
```

##### 带有备忘录的递归
```java
class Solution {
  int[] nums;
  Integer[] dp;
  public int rob(int[] nums) {
    this.nums = nums;
    dp = new Integer[nums.length];
    int res = Integer.MIN_VALUE;
    for (int i = nums.length - 1; i >= 0; i--) {
      res = Math.max(res, dfs(i));
    }
    return res;
  }

  int dfs(Integer state) {
    if (dp[state] != null) return dp[state];
    int res = nums[state];
    int temp = 0;
    for (int i = state - 2; i >= 0; i--) {
      temp = Math.max(temp, dfs(i));  
    }
    return dp[state] = res + temp;
  }
}
```

#### 例题9: 最长等差数列
[最长等差数列](https://leetcode.cn/problems/longest-arithmetic-subsequence/)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220706095756.png)

##### 分析

- 状态：`dp[i][d]`=以nums[i]结尾的，并且公差为d的最长子序列的长度。当d为501时表示还没有确定公差
- 下一个状态：见递归代码
- 父子状态之间的递推关系：见递归代码
- 最后的解答：dp数组中的最大值

##### 递归
```java
class Solution {
  int[] nums;
  int ans = 0;
  public int longestArithSeqLength(int[] nums) {
    this.nums = nums; 
    dfs(nums.length, 501);
    return ans;
  }
  
  int dfs(int i, int d) {
    int res = 0;
    for (int j = i - 1; j >= 0; j--) {
      if (d == 501) {
        // 还没有确定公差
        res = Math.max(res, dfs(j, i == nums.length ? 501 : nums[i] - nums[j]) + 1);
      } else {
        // 确定了公差
        if (nums[i] - nums[j] == d) {
          res = Math.max(res, dfs(j, d) + 1);
        }
      }
    }
    ans = Math.max(ans, res);
    return res;
  }
}
```

##### 带有备忘录的递归
```java
class Solution {
  int[] nums;
  Integer[][] dp;
  public int longestArithSeqLength(int[] nums) {
    this.nums = nums;
    int res = 0;
    dp = new Integer[nums.length + 1][1005];
    for (int i = nums.length - 1; i >= 0; i--) {
      res = Math.max(res, dfs(new int[]{i, 1004}));
    }
    return res;
  }

  int dfs(int[] state) {
    if (dp[state[0]][state[1]] != null) return dp[state[0]][state[1]];
    List<int[]> nextStateList = new ArrayList();
    for (int i = state[0] - 1; i >= 0; i--) {
      if (state[1] == 1004 || nums[state[0]] - nums[i] + 500 == state[1]) {
        nextStateList.add(new int[]{i, nums[state[0]] - nums[i] + 500});
      } 
    }
    int res = 1, temp = 0;
    for (int[] nextState : nextStateList) {
      temp = Math.max(temp, dfs(nextState)); 
    }
    return dp[state[0]][state[1]] = res + temp;
  }
}
```

关于d范围的技巧：由于 `0 <= nums[i] <= 500`, 综合递增和递减的两个极端，得到 d 的范围 `-500<=d<=500` 我们需要 d 作为下标，而现在 d 又可能是负值，对此，我们统一增加一个偏移量 500，把负的抵消掉，`0<=d’<=1000`。

### 序列上按结尾位置规划之双序列
#### 分析模版
- 状态：`dp[i][j]`: 第一个序列的前i个(可以不选中第i位置)配上第二个序列的前j个(可以不选中第j位置)的最优解
- 下一个状态：`dp[i - 1][j - 1]`, `dp[i - 1][j]`, `dp[i][j - 1]`

#### 例题1: 最长公共子序列
[最长公共子序列](https://leetcode.cn/problems/longest-common-subsequence/)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220620103350.png)

##### 分析
- 状态：`dp[i][j]`: 第一个序列的前i个配上第二个序列的前j个的最长公共子序列
- 下一个状态：`dp[i - 1][j - 1]`, `dp[i - 1][j]`, `dp[i][j - 1]`
- 父子状态之间的递推关系：`dp[i][j] = max{dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1] + 1 if A[i] == B[j]}`
- 最后的解答：`dp[A.length - 1][B.length - 1]`

##### 递归
```java
class Solution {
  
  char[] text1Ch;
  char[] text2Ch;
  public int longestCommonSubsequence(String text1, String text2) {
    text1Ch = text1.toCharArray();  
    text2Ch = text2.toCharArray();  
    return dfs(text1Ch.length - 1, text2Ch.length - 1);
  }
  
  int dfs(int i, int j) {
    if (i == -1 || j == -1) {
      return 0;
    }
    int res = Integer.MIN_VALUE;
    if (text1Ch[i] == text2Ch[j]) {
      res = Math.max(res, dfs(i - 1, j - 1) + 1);
    } else {
      res = Math.max(res, dfs(i - 1, j));
      res = Math.max(res, dfs(i, j - 1));
    }
    return res;
  }
}
```

##### 带有备忘录的递归
```java
class Solution {
  char[] text1Chs, text2Chs;
  Integer[][] dp;
  public int longestCommonSubsequence(String text1, String text2) {
    text1Chs = text1.toCharArray(); 
    text2Chs = text2.toCharArray(); 
    dp = new Integer[text1Chs.length][text2Chs.length];
    return dfs(new int[]{text1Chs.length - 1, text2Chs.length - 1});
  }
  
  int dfs(int[] state) {
    int res = 0;
    if (state[0] == -1 || state[1] == -1) return res;
    if (dp[state[0]][state[1]] != null) return dp[state[0]][state[1]];
    res = Math.max(res, dfs(new int[]{state[0] - 1, state[1]}));
    res = Math.max(res, dfs(new int[]{state[0], state[1] - 1}));
    if (text1Chs[state[0]] == text2Chs[state[1]]) {
      res = Math.max(res, dfs(new int[]{state[0] - 1, state[1] - 1}) + 1);
    }
    return dp[state[0]][state[1]] = res;
  }
}
```

##### 递推式动态规划
```java
class Solution {
  public int longestCommonSubsequence(String text1, String text2) {
    int text1Length = text1.length();
    int text2Length = text2.length();
    int[][] dp = new int[text1Length + 1][text2Length + 1];
    for (int i = 0; i < text1Length; i++) {
      for (int j = 0; j < text2Length; j++) {
        if (text1.charAt(i) == text2.charAt(j)) {
          dp[i + 1][j + 1] = dp[i][j] + 1;
        } else {
          dp[i + 1][j + 1] = Math.max(dp[i][j + 1], dp[i + 1][j]);
        }
      }
    }
    return dp[text1Length][text2Length];
  }
}
```
##### 最长公共子序列应用
###### 例题1: 让字符串成为回文串的最少插入次数
[让字符串成为回文串的最少插入次数](https://leetcode.cn/problems/minimum-insertion-steps-to-make-a-string-palindrome/)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220704163428.png)

分析:
<div class="container">
  <iframe width="560" height="315" src="https://www.youtube.com/embed/qZHjSrmB9iI" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>

代码：
```java
class Solution {
  public int minInsertions(String s) {
    String r = new StringBuffer(s).reverse().toString();
    return s.length() - lcs(s, r);
  }

  int lcs(String s1, String s2) {
    int s1Length = s1.length(); 
    int s2Length = s2.length(); 
    int[][] dp = new int[s1Length + 1][s2Length + 1];
    for (int i = 0; i < s1Length; i++) {
      for (int j = 0; j < s2Length; j++) {
        if (s1.charAt(i) == s2.charAt(j)) {
          dp[i + 1][j + 1] = dp[i][j] + 1;
        } else {
          dp[i + 1][j + 1] = Math.max(dp[i][j + 1], dp[i + 1][j]);
        }
      }
    }
    return dp[s1Length][s2Length];
  }
}
```

###### 例题2: 最长回文子序列
[最长回文子序列](https://leetcode.cn/problems/longest-palindromic-subsequence/)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220704164440.png)

代码：
```java
class Solution {
  char[] sChs, sReverseChs;
  Integer[][] dp;
  public int longestPalindromeSubseq(String s) {
    sChs = s.toCharArray();
    sReverseChs = new StringBuilder(s).reverse().toString().toCharArray();
    dp = new Integer[sChs.length][sReverseChs.length];
    return dfs(new int[]{sChs.length - 1, sReverseChs.length - 1});
  }

  int dfs(int[] state) {
    int res = 0;
    if (state[0] == -1 || state[1] == -1) return res;
    if (dp[state[0]][state[1]] != null) return dp[state[0]][state[1]];
    res = Math.max(res, dfs(new int[]{state[0] - 1, state[1]}));
    res = Math.max(res, dfs(new int[]{state[0], state[1] - 1}));
    if (sChs[state[0]] == sReverseChs[state[1]]) {
      res = Math.max(res, dfs(new int[]{state[0] - 1, state[1] - 1}) + 1);
    }
    return dp[state[0]][state[1]] = res;
  }
}
```


#### 例题2: 交错字符串
[交错字符串](https://leetcode.cn/problems/interleaving-string/)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220620134848.png)

##### 分析
- 状态：`dp[i][j]`：表示的s3前i+j+2个字符s3[0, i+j+1]是否由s1前i+1个字符s1[0...i]和s2前j个字符s2[0...j]交错形成。
- 下一个状态：`dp[i - 1][j]`, `dp[i][j-1]`
- 父子状态之间的递推关系：`dp[i][j] = (dp[i-1][j] if s1[i] == s3[i+j+1]) || (dp[i][j-1] if s2[j] == s3[i+j+1])`

##### 递归
```java
class Solution {
  char[] s1Ch;
  char[] s2Ch;
  char[] s3Ch;
  public boolean isInterleave(String s1, String s2, String s3) {
    s1Ch = s1.toCharArray();
    s2Ch = s2.toCharArray();
    s3Ch = s3.toCharArray();
    if (s1Ch.length == 0 && s2Ch.length == 0) {
      if (s3Ch.length == 0) return true;
      return false;
    }
    if (s1Ch.length + s2Ch.length != s3Ch.length) return false;
    return dfs(s1Ch.length - 1, s2Ch.length - 1);
  }

  boolean dfs(int i, int j) {
    if (i == -1 && j == -1) {
      return true;
    }
    if (i != -1 && s1Ch[i] == s3Ch[i + j + 1]) {
      if (dfs(i - 1, j)) return true;
    }
    if (j != -1 && s2Ch[j] == s3Ch[i + j + 1]) {
      if ((dfs(i, j - 1)) return true;
    }
    return false;
  }
}
```

##### 带有备忘录的递归
```java
class Solution {
  char[] s1Chs, s2Chs, s3Chs;
  Boolean[][] dp;
  public boolean isInterleave(String s1, String s2, String s3) {
    s1Chs = s1.toCharArray(); 
    s2Chs = s2.toCharArray();
    s3Chs = s3.toCharArray();
    dp = new Boolean[s1Chs.length + 1][s2Chs.length + 1];
    if (s1Chs.length + s2Chs.length != s3Chs.length) return false;
    return dfs(new int[]{s1Chs.length - 1, s2Chs.length - 1});
  }
  
  boolean dfs(int[] state) {
    if (state[0] == -1 && state[1] == -1) return true;
    if (dp[state[0] + 1][state[1] + 1] != null) return dp[state[0] + 1][state[1] + 1];
    List<int[]> nextStateList = new ArrayList();
    if (state[0] >= 0 && s1Chs[state[0]] == s3Chs[state[0] + state[1] + 1]) {
      nextStateList.add(new int[]{state[0] - 1, state[1]});
    }
    if (state[1] >= 0 && s2Chs[state[1]] == s3Chs[state[0] + state[1] + 1]) {
      nextStateList.add(new int[]{state[0], state[1] - 1});
    }
    for (int[] nextState : nextStateList) {
      if (dfs(nextState)) {
        dp[state[0] + 1][state[1] + 1] = true;
        return true; 
      }
    }
    return dp[state[0] + 1][state[1] + 1] = false;
  }
}
```
此处用了一个技巧来处理dp的状态, 因为i与j都可能为-1，会越过dp数组的边界。为了避免这种情况，统一把dp数组里的状态进行+1处理

#### 例题3: 编辑距离
[编辑距离](https://leetcode.cn/problems/edit-distance/)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220704111340.png)

##### 分析
- 状态：`dp[i][j]`：表示的`word1[0...i]`最少经过多少操作能变成`word2[0...j]`
- 下一个状态：`dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]`
- 父子状态之间的递推关系：`dp[i][j] = min{dp[i][j - 1] + 1, dp[i - 1][j - 1] + 1, dp[i - 1][j] + 1, dp[i - 1][j -1] if word1[i] == word2[j]}`

<div class="container">
  <iframe width="560" height="315" src="https://www.youtube.com/embed/QTfM718GuBA" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>

##### 递归
```java
class Solution {
  char[] word1Ch;
  char[] word2Ch;
  public int minDistance(String word1, String word2) {
    word1Ch = word1.toCharArray();  
    word2Ch = word2.toCharArray();
    return dfs(word1Ch.length - 1, word2Ch.length - 1);
  }

  int dfs(int i, int j) {
    if (i == -1) return j + 1;
    if (j == -1) return i + 1;
    int res = Integer.MAX_VALUE;
    if (word1Ch[i] == word2Ch[j]) {
      res = Math.min(res, dfs(i - 1, j - 1));
    }
    // 删除word1[i]字符
    res = Math.min(res, dfs(i - 1, j) + 1);
    // 在word1[i]后面插入word2[j]字符
    res = Math.min(res, dfs(i, j - 1) + 1);
    // 替换word1[i]为word2[j]字符
    res = Math.min(res, dfs(i - 1, j - 1) + 1);
    return res;
  }
}
```

##### 带有备忘录的递归
```java
class Solution {
  char[] words1Chs, words2Chs;
  Integer[][] dp;
  public int minDistance(String word1, String word2) {
    this.words1Chs = word1.toCharArray();
    this.words2Chs = word2.toCharArray();
    dp = new Integer[words1Chs.length][words2Chs.length];
    return dfs(new int[]{words1Chs.length - 1, words2Chs.length - 1});
  }
  
  int dfs(int[] state) {
    if (state[0] == -1) return state[1] + 1;
    if (state[1] == -1) return state[0] + 1;
    if (dp[state[0]][state[1]] != null) return dp[state[0]][state[1]]; 
    int res = Integer.MAX_VALUE;
    if (words1Chs[state[0]] == words2Chs[state[1]]) {
      res = Math.min(res, dfs(new int[]{state[0] - 1, state[1] - 1}));
    }
    // 插入一个字符
    res = Math.min(res, dfs(new int[]{state[0], state[1] - 1}) + 1);
    // 删除一个字符
    res = Math.min(res, dfs(new int[]{state[0] - 1, state[1]}) + 1);
    // 替换一个字符
    res = Math.min(res, dfs(new int[]{state[0] - 1, state[1] - 1}) + 1);
    return dp[state[0]][state[1]] = res;
  }
}
```

#### 例题4: 不同的子序列
[不同的子序列](https://leetcode.cn/problems/distinct-subsequences/)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220704134838.png)

##### 分析
- 状态：`dp[i][j]`：表示`s[0...i]`的子序列中`t[0..j]`出现的个数
- 下一个状态：`dp[i - 1][j - 1], dp[i - 1][j]`
- 父子状态之间的递推关系：`dp[i][j] = dp[i][j - 1] + (dp[i - 1][j - 1] if s[i] == t[j])`

##### 递归
```java
class Solution {
  char[] sCh;
  char[] tCh;
  public int numDistinct(String s, String t) {
    sCh = s.toCharArray();
    tCh = t.toCharArray();
    return dfs(sCh.length - 1, tCh.length - 1);
  }

  int dfs(int i, int j) {
    if (j == -1) return 1;
    if (i == -1) return 0;
    int res = 0;
    if (sCh[i] == tCh[j]) {
      res += dfs(i - 1, j - 1);
    }
    res += dfs(i - 1, j);
    return res;
  }
}
```

##### 带有备忘录的递归
```java
class Solution {
  char[] sChs, tChs;
  Integer[][] dp;
  public int numDistinct(String s, String t) {
    sChs = s.toCharArray();
    tChs = t.toCharArray();
    dp = new Integer[sChs.length][tChs.length];
    return dfs(new int[]{sChs.length - 1, tChs.length - 1}); 
  }

  int dfs(int[] state) {
    int res = 0;
    if (state[1] == -1) return 1;
    if (state[0] == -1) return res;
    if (dp[state[0]][state[1]] != null) return dp[state[0]][state[1]];
    List<int[]> nextStateList = new ArrayList();
    if (sChs[state[0]] == tChs[state[1]]) {
      nextStateList.add(new int[]{state[0] - 1, state[1] - 1});
    }
    nextStateList.add(new int[]{state[0] - 1, state[1]});
    for (int[] nextState : nextStateList) {
      res += dfs(nextState);
    }
    return dp[state[0]][state[1]] = res;
  }
}
```

#### 例题5：正则表达式匹配
[正则表达式匹配](https://leetcode.cn/problems/regular-expression-matching/)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220704144920.png)

##### 分析
- 状态：`dp[i][j]`：表示`p[0...j]`是否可以匹配`s[0...i]`
- 下一个状态：`dp[i - 1][j - 1], dp[i - 1][j]`
- 父子状态之间的递推关系：见递归代码

##### 递归
```java
class Solution {
  char[] sCh;
  char[] pCh;
  public boolean isMatch(String s, String p) {
    sCh = s.toCharArray();
    pCh = p.toCharArray();
    return dfs(sCh.length - 1, pCh.length - 1);
  }

  boolean dfs(int i, int j) {
    if (i == -1 && j == -1) return true;
    if (j == -1) return false; 
    if (i != -1) {
      if (sCh[i] == pCh[j] || pCh[j] == '.' || (pCh[j] == '*' && j >= 1 && (pCh[j - 1] == sCh[i] || pCh[j - 1] == '.'))) {
        if (dfs(i - 1, j - 1)) return true;
      }
      if (pCh[j] == '*' && j >= 1 && (pCh[j - 1] == sCh[i] || pCh[j - 1] == '.')) {
        if (dfs(i - 1, j)) return true;
      }
    }
    if (pCh[j] == '*') {
      if (dfs(i, j - 2)) return true;
    }
    return false;
  } 
}
```

##### 带有备忘录的递归
```java
class Solution {
  char[] sCh;
  char[] pCh;
  Boolean[][] dp;
  public boolean isMatch(String s, String p) {
    sCh = s.toCharArray();
    pCh = p.toCharArray();
    dp = new Boolean[sCh.length + 1][pCh.length + 1];
    return dfs(sCh.length - 1, pCh.length - 1);
  }

  boolean dfs(int i, int j) {
    if (i == -1 && j == -1) return true;
    if (j == -1) return false; 
    if (i != -1) {
      if (sCh[i] == pCh[j] || pCh[j] == '.' || (pCh[j] == '*' && j >= 1 && (pCh[j - 1] == sCh[i] || pCh[j - 1] == '.'))) {
        if (dp[i][j] == null) {
          dp[i][j] = dfs(i - 1, j - 1);
        }
        if (dp[i][j]) return true;
      }
      if (pCh[j] == '*' && j >= 1 && (pCh[j - 1] == sCh[i] || pCh[j - 1] == '.')) {
        if (dp[i][j + 1] == null) {
          dp[i][j + 1] = dfs(i - 1, j);
        }
        if (dp[i][j + 1]) return true;
      }
    }
    if (pCh[j] == '*') {
      if (dp[i + 1][j - 1] == null) {
        dp[i + 1][j - 1] = dfs(i, j - 2);
      }
      if (dp[i + 1][j - 1]) return true;
    }
    return false;
  } 
}
```

#### 例题6: 通配符匹配
[通配符匹配](https://leetcode.cn/problems/wildcard-matching/)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220704153750.png)

##### 分析
- 状态：`dp[i][j]`：表示`p[0...j]`是否可以匹配`s[0...i]`
- 下一个状态：`dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]`
- 父子状态之间的递推关系：见递归代码

##### 递归
```java
class Solution {
  char[] sCh;
  char[] pCh;
  public boolean isMatch(String s, String p) {
    sCh = s.toCharArray();
    pCh = p.toCharArray();
    return dfs(sCh.length - 1, pCh.length - 1);
  }

  boolean dfs(int i, int j) {
    if (i == -1 && j == -1) return true;
    if (j == -1) return false; 
    if (i >= 0) {
      if (sCh[i] == pCh[j] || pCh[j] == '?' || pCh[j] == '*') {
        if (dfs(i - 1, j - 1)) return true; 
      }
      if (pCh[j] == '*') {
        if (dfs(i - 1, j)) return true;
      }
    }
    if (pCh[j] == '*') {
      if (dfs(i, j - 1)) return true;
    }
    return false;
  } 
}
```

##### 带有备忘录的递归
```java
class Solution {
  char[] sCh;
  char[] pCh;
  Boolean[][] dp;
  public boolean isMatch(String s, String p) {
    sCh = s.toCharArray();
    pCh = p.toCharArray();
    dp = new Boolean[sCh.length + 1][pCh.length + 1];
    return dfs(sCh.length - 1, pCh.length - 1);
  }

  boolean dfs(int i, int j) {
    if (i == -1 && j == -1) return true;
    if (j == -1) return false; 
    if (i >= 0) {
      if (sCh[i] == pCh[j] || pCh[j] == '?' || pCh[j] == '*') {
        if (dp[i][j] == null) {
          dp[i][j] = dfs(i - 1, j - 1);
        }
        if (dp[i][j]) return true; 
      }
      if (pCh[j] == '*') {
        if (dp[i][j + 1] == null) {
          dp[i][j + 1] = dfs(i - 1, j);
        }
        if (dp[i][j + 1]) return true;
      }
    }
    if (pCh[j] == '*') {
      if (dp[i + 1][j] == null) {
        dp[i + 1][j] = dfs(i, j - 1);
      } 
      if (dp[i + 1][j]) return true;
    }
    return false;
  } 
}
```

#### 例题7: 两个字符串的最小ASCII删除和
[两个字符串的最小ASCII删除和](https://leetcode.cn/problems/minimum-ascii-delete-sum-for-two-strings/)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220704170724.png)

##### 分析
- 状态：`dp[i][j]`：表示使`s1[0...i]`与`s2[0...j]`相等所需删除字符的 ASCII 值的最小和 
- 下一个状态：`dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]`
- 父子状态之间的递推关系：见递归代码

##### 递归
```java
class Solution {
  char[] s1Ch;
  char[] s2Ch;
  public int minimumDeleteSum(String s1, String s2) {
    s1Ch = s1.toCharArray();
    s2Ch = s2.toCharArray();
    return dfs(s1Ch.length - 1, s2Ch.length - 1);
  }

  int dfs(int i, int j) {
    int res = Integer.MAX_VALUE;
    if (i == -1) {
      res = 0;
      for (int z = 0; z <= j; z++) {
        res += s2Ch[z];
      }
      return res;
    }
    if (j == -1) {
      res = 0;
      for (int z = 0; z <= i; z++) {
        res += s1Ch[z];
      }
      return res;
    }
    if (s1Ch[i] == s2Ch[j]) {
      res = Math.min(res, dfs(i - 1, j - 1));
    }
    res = Math.min(res, dfs(i - 1, j) + s1Ch[i]);
    res = Math.min(res, dfs(i, j - 1) + s2Ch[j]);
    return res; 
  }
  
}
```

##### 带有备忘录的递归
```java
class Solution {
  char[] s1Chs, s2Chs;
  Integer[][] dp;
  public int minimumDeleteSum(String s1, String s2) {
    s1Chs = s1.toCharArray();
    s2Chs = s2.toCharArray();
    dp = new Integer[s1Chs.length + 1][s2Chs.length + 1];
    return dfs(new int[]{s1Chs.length - 1, s2Chs.length - 1});
  }

  int dfs(int[] state) {
    if (dp[state[0] + 1][state[1] + 1] != null) return dp[state[0] + 1][state[1] + 1];
    int res = Integer.MAX_VALUE;
    if (state[0] == -1) {
      res = 0;
      for (int i = 0; i <= state[1]; i++) {
        res += s2Chs[i];
      }
      
      return dp[state[0] + 1][state[1] + 1] = res;
    }
    if (state[1] == -1) {
      res = 0;
      for (int i = 0; i <= state[0]; i++) {
        res += s1Chs[i];
      }
      return dp[state[0] + 1][state[1] + 1] = res;
    }
    if (s1Chs[state[0]] == s2Chs[state[1]]) {
      res = Math.min(res, dfs(new int[]{state[0] - 1, state[1] - 1})); 
    }
    res = Math.min(res, dfs(new int[]{state[0] - 1, state[1]}) + s1Chs[state[0]]);
    res = Math.min(res, dfs(new int[]{state[0], state[1] - 1}) + s2Chs[state[1]]);
    return dp[state[0] + 1][state[1] + 1] = res;
  }
}
```

### 序列上按区间规划
#### 分析模版
- 状态: `dp[i][j]`: 表示在下表i,j这个区间范围内的最优解
- 下一个状态: 可以是更小的一个区间`dp[i + 1, j - 1]`, 也可以是不同的切割区间位置dp[i, k], dp[k, j]

#### 例题1: 最长回文子串
[最长回文子串](https://leetcode.cn/problems/longest-palindromic-substring/)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220709140806.png)

##### 分析
- 状态：`dp[i][j]`: 表示`s[i..j]`是否为一个回文子串

##### 递归
```java
class Solution {
  int start = 0;
  int end = 0;
  char[] sCh;
  
  public String longestPalindrome(String s) {
    int sLength = s.length();
    sCh = s.toCharArray();
    for (int i = 0; i < sLength; i++) {
      for (int j = sLength - 1; j >= 0; j--) {
        if (j - i  > end - start && dfs(i, j)) {
          start = i;
          end = j;
        }
      }
    }
    return s.substring(start, end + 1);
  }

  boolean dfs(int l, int r) {
    if (l == r) return true;
    if (sCh[l] != sCh[r]) return false;
    if (l + 1 == r) return true;
    return dfs(l + 1, r - 1);
  }

}
```

##### 带有备忘录的递归
```java
class Solution {
  int start = 0;
  int end = 0;
  char[] sCh;
  Boolean[][] dp;
  
  public String longestPalindrome(String s) {
    int sLength = s.length();
    sCh = s.toCharArray();
    dp = new Boolean[sLength][sLength];
    for (int i = 0; i < sLength; i++) {
      for (int j = sLength - 1; j >= 0; j--) {
        if (j - i  > end - start && dfs(i, j)) {
          start = i;
          end = j;
        }
      }
    }
    return s.substring(start, end + 1);
  }

  boolean dfs(int l, int r) {
    if (l == r) return true;
    if (sCh[l] != sCh[r]) return false;
    if (l + 1 == r) return true;
    if (dp[l + 1][r - 1] == null) {
      dp[l + 1][r - 1] = dfs(l + 1, r - 1);
    }
    return dp[l + 1][r - 1];
  }

}
```

#### 例题2: 最长回文子序列
[最长回文子序列](https://leetcode.cn/problems/longest-palindromic-subsequence/)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220709143620.png)

##### 分析
- 状态：`dp[i][j]`: 表示`s[i..j]`的最长的回文子序列的长度
- 下一个状态：`dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]`
- 父子状态之间的递推关系：见递归代码

##### 递归
```java
class Solution {
  char[] sCh;
  public int longestPalindromeSubseq(String s) {
    sCh = s.toCharArray();
    return dfs(0, sCh.length - 1);
  }

  int dfs(int i, int j) {
    if (i == j) return 1;
    if (i > j) return 0;
    int res = 0;
    if (sCh[i] == sCh[j]) {
      res = Math.max(res, dfs(i + 1, j - 1) + 2);
    }
    res = Math.max(res, dfs(i + 1, j));
    res = Math.max(res, dfs(i, j - 1));
    return res; 
  }
}
```

##### 带有备忘录的递归
```java
class Solution {
  char[] sCh;
  Integer[][] dp;
  public int longestPalindromeSubseq(String s) {
    sCh = s.toCharArray();
    dp = new Integer[sCh.length][sCh.length];
    return dfs(0, sCh.length - 1);
  }

  int dfs(int i, int j) {
    if (i == j) return 1;
    if (i > j) return 0;
    int res = 0;
    if (sCh[i] == sCh[j]) {
      if (dp[i + 1][j - 1] == null) {
        dp[i + 1][j - 1] = dfs(i + 1, j - 1);
      }
      res = Math.max(res, dp[i + 1][j - 1]+ 2);
    }
    if (dp[i + 1][j] == null) {
      dp[i + 1][j] = dfs(i + 1, j);
    }
    res = Math.max(res, dp[i + 1][j]);
    if (dp[i][j - 1] == null) {
      dp[i][j - 1] = dfs(i, j - 1);
    }
    res = Math.max(res, dp[i][j - 1]);
    return res; 
  }
}
```

#### 例题3: 戳气球
[戳气球](https://leetcode.cn/problems/burst-balloons/)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220710142746.png)

##### 分析

文字解答：https://leetcode.cn/problems/burst-balloons/solution/

<div class="container">
  <iframe width="560" height="315" src="https://www.youtube.com/embed/M7wQ0YpdiEk" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>

##### 递归
```java
class Solution {
  int[] points;
  public int maxCoins(int[] nums) {
    int n = nums.length;
    points = new int[n + 2]; 
    points[0] = points[n + 1] = 1;
    for (int i = 1; i <= n; i++) {
      points[i] = nums[i - 1];
    }
    return dfs(0, n + 1);
  }
  
  int dfs(int i, int j) {
    if (i >= j - 1) {
      return 0;
    }
    int res = -1;
    for (int k = i + 1; k < j; k++) {
      res = Math.max(res, dfs(i, k) + dfs(k, j) + points[i] * points[j] * points[k]);
    }
    return res;
  }
}
```

##### 带有备忘录的递归
```java
class Solution {
  int[] points;
  Integer[][] dp;
  public int maxCoins(int[] nums) {
    int n = nums.length;
    points = new int[n + 2]; 
    dp = new Integer[n + 2][n + 2];
    points[0] = points[n + 1] = 1;
    for (int i = 1; i <= n; i++) {
      points[i] = nums[i - 1];
    }
    return dfs(0, n + 1);
  }
  
  int dfs(int i, int j) {
    if (i >= j - 1) {
      return 0;
    }
    int res = -1;
    for (int k = i + 1; k < j; k++) {
      if (dp[i][k] == null) dp[i][k] = dfs(i, k);
      if (dp[k][j] == null) dp[k][j] = dfs(k, j);
      res = Math.max(res, dp[i][k] + dp[k][j] + points[i] * points[j] * points[k]);
    }
    return res;
  }
}
```

#### 例题4: 多边形三角剖分的最低得分
[多边形三角剖分的最低得分](https://leetcode.cn/problems/minimum-score-triangulation-of-polygon/)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220710145116.png)

##### 分析
这题是例题3:戳气球的套娃题，解题思路一样

##### 递归
```java
class Solution {
  int[] values;
  public int minScoreTriangulation(int[] values) {
    this.values = values;
    return dfs(0, values.length - 1);
  }

  int dfs(int i, int j) {
    if (i >= j - 1) {
      return 0; 
    }
    int res = Integer.MAX_VALUE;
    for (int k = i + 1; k < j; k++) {
      res = Math.min(res, dfs(i, k) + dfs(k, j) + values[i] * values[k] * values[j]); 
    } 
    return res;
  }
}
```

##### 带有备忘录的递归
```java
class Solution {
  int[] values;
  Integer[][] dp;
  public int minScoreTriangulation(int[] values) {
    int n = values.length;
    this.values = values;
    dp = new Integer[n][n];
    return dfs(0, n - 1);
  }

  int dfs(int i, int j) {
    if (i >= j - 1) {
      return 0; 
    }
    int res = Integer.MAX_VALUE;
    for (int k = i + 1; k < j; k++) {
      if (dp[i][k] == null) dp[i][k] = dfs(i, k); 
      if (dp[k][j] == null) dp[k][j] = dfs(k, j);
      res = Math.min(res, dp[i][k] + dp[k][j] + values[i] * values[k] * values[j]); 
    } 
    return res;
  }
}
```

#### 例题5: 切棍子的最小成本
[切棍子的最小成本](https://leetcode.cn/problems/minimum-cost-to-cut-a-stick/)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220710154846.png)

##### 分析
这题与例题3：戳气球类似

##### 递归
```java
class Solution {
  int[] cuts;
  public int minCost(int n, int[] cuts) {
    this.cuts = cuts;
    return dfs(0, n);
  }

  int dfs(int i, int j) {
    if (i >= j - 1) {
      return 0;
    }
    int res = Integer.MAX_VALUE;
    for (int k = 0; k < cuts.length; k++) {
      if (cuts[k] < j && cuts[k] > i) {
        res = Math.min(res, dfs(i, cuts[k]) + dfs(cuts[k], j) + j - i);
      }
    }
    return res == Integer.MAX_VALUE ? 0 : res;
  }
}
```

##### 带有备忘录的递归
```java
class Solution {
  int[] cuts;
  Integer[][] dp;
  public int minCost(int n, int[] cuts) {
    this.cuts = cuts;
    dp = new Integer[n + 1][n + 1];
    return dfs(0, n);
  }

  int dfs(int i, int j) {
    if (i >= j - 1) {
      return 0;
    }
    int res = Integer.MAX_VALUE;
    for (int k = 0; k < cuts.length; k++) {
      if (cuts[k] < j && cuts[k] > i) {
        if (dp[i][cuts[k]] == null) dp[i][cuts[k]] = dfs(i, cuts[k]); 
        if (dp[cuts[k]][j] == null) dp[cuts[k]][j] = dfs(cuts[k], j); 
        res = Math.min(res, dp[i][cuts[k]] + dp[cuts[k]][j] + j - i);
      }
    }
    return res == Integer.MAX_VALUE ? 0 : res;
  }
}
```

由于n最大可以为1e6，所以dp[n+1][n+1]会超出内存限制。所以需要将dfs中的状态换成另一种表示，经过分析发现，可以将dfs中的状态i，j从表示1~n换成表示cuts的下标。代码如下：

递归：
```java
class Solution {
  int[] points;
  public int minCost(int n, int[] cuts) {
    int m = cuts.length;
    points = new int[m + 2];
    points[0] = 0;
    points[m + 1] = n;
    for (int i = 1; i <= m; i++) {
      points[i] = cuts[i - 1];
    }
    return dfs(0, m + 1);
  }

  int dfs(int i, int j) {
    if (points[i] >= points[j] - 1) {
      return 0;
    }
    int res = Integer.MAX_VALUE;
    for (int k = 1; k < points.length - 1; k++) {
      if (points[k] < points[j] && points[k] > points[i]) {
        res = Math.min(res, dfs(i, k) + dfs(k, j) + points[j] - points[i]);
      }
    }
    return res == Integer.MAX_VALUE ? 0 : res;
  }

}
```

带有备忘录的递归:
```java
class Solution {
  int[] points;
  Integer[][] dp;
  public int minCost(int n, int[] cuts) {
    int m = cuts.length;
    points = new int[m + 2];
    dp = new Integer[m + 2][m + 2];
    points[0] = 0;
    points[m + 1] = n;
    for (int i = 1; i <= m; i++) {
      points[i] = cuts[i - 1];
    }
    return dfs(0, m + 1);
  }

  int dfs(int i, int j) {
    if (points[i] >= points[j] - 1) {
      return 0;
    }
    int res = Integer.MAX_VALUE;
    for (int k = 1; k < points.length - 1; k++) {
      if (points[k] < points[j] && points[k] > points[i]) {
        if (dp[i][k] == null) dp[i][k] = dfs(i, k);
        if (dp[k][j] == null) dp[k][j] = dfs(k, j);
        res = Math.min(res, dp[i][k] + dp[k][j] + points[j] - points[i]);
      }
    }
    return res == Integer.MAX_VALUE ? 0 : res;
  }

}
```

### 在取值范围上动态规划
#### 分析模版
- 状态：`dp[i][j]`: 如果只处理前i个物品，且某个状态值为j的情况下的最优解
  - 例如：01背包中的`dp[i][j]`表示如果只处理前i个物品，且容量为j的情况下的最多可以装的物品都价值
- 下一个状态：`dp[i - 1][j - x]`、`dp[i - 1][j]`
  - `dp[i - 1][j - x]`表示当从`dp[i][j]`时，选择了第i个物品时的下个状态
  - `dp[i - 1][j]`表示当从`dp[i][j]`时，没有选择第i个物品时的下个状态

#### 例题1: 01背包问题
[01背包问题](https://www.acwing.com/problem/content/2/)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220711155701.png)

##### 分析
- 状态：`dp[i][j]`: 表示如果只处理前i个物品，且容量为j的情况下的最多可以装的物品都价值
- 下一个状态：`dp[i - 1][j - v[i]]`、`dp[i - 1][j]`
- 父子状态之间的递推关系：`dp[i][j] = Math.max(dp[i - 1][j - v[i]] + w[i], dp[i - 1][j])`

##### 递归
```java
int N = cin.nextInt();
int V = cin.nextInt();
int[] v = new int[N];
int[] w = new int[N];

public void solve() {
  for (int i = 0; i < N; i++) {
    v[i] = cin.nextInt();
    w[i] = cin.nextInt();
  }
  System.out.println(dfs(N - 1, V));
}

int dfs(int i, int j) {
  if (i < 0) {
    return 0;
  }
  return Math.max(j >= v[i] ? dfs(i - 1, j - v[i]) + w[i] : 0, dfs(i - 1, j));
}
```

##### 带有备忘录的递归
```java
int N = cin.nextInt();
int V = cin.nextInt();
int[] v = new int[N];
int[] w = new int[N];
Integer[][] dp = new Integer[N + 1][V + 1];

public void solve() {
  for (int i = 0; i < N; i++) {
    v[i] = cin.nextInt();
    w[i] = cin.nextInt();
  }
  System.out.println(dfs(N - 1, V));
}

int dfs(int i, int j) {
  if (i < 0 || j <= 0) {
    return 0;
  }
  if (j >= v[i] && dp[i][j - v[i]] == null) {
    dp[i][j - v[i]] = dfs(i - 1, j - v[i]);
  }
  if (dp[i][j] == null) {
    dp[i][j] = dfs(i - 1, j);
  }
  return Math.max(j >= v[i] ? dp[i][j - v[i]] + w[i] : 0, dp[i][j]);
}
```

#### 例题2: 分割等和子集
[分割等和子集](https://leetcode.cn/problems/partition-equal-subset-sum/)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220711162835.png)

##### 分析
- 状态：`dp[i][j]`: 表示从`nums[0...i]`中是否可以取出几个数（也可以不取）加起来为j
- 下一个状态：`dp[i - 1][j - nums[i]]`、`dp[i - 1][j]`
- 父子状态之间的递推关系：`dp[i][j] = dp[i - 1][j - nums[i]] + w[i] || dp[i - 1][j]`

##### 递归
```java
class Solution {
  int[] nums;
  public boolean canPartition(int[] nums) {
    this.nums = nums;
    int sum = 0;
    for (int num : nums) {
      sum += num;
    }
    if (sum % 2 != 0) return false;
    return dfs(nums.length - 1, sum / 2);
  }

  boolean dfs(int i, int j) {
    if (j == 0) return true;
    if (i < 0) {
      return false;
    }
    return (j >= nums[i] ? dfs(i - 1, j - nums[i]) : false) || (dfs(i - 1, j));
  }

}
```

##### 带有备忘录的递归
```java
class Solution {
  int[] nums;
  Boolean[][] dp;
  public boolean canPartition(int[] nums) {
    int n = nums.length;
    this.nums = nums;
    int sum = 0;
    for (int num : nums) {
      sum += num;
    }
    if (sum % 2 != 0) return false;
    dp = new Boolean[n + 1][sum / 2 + 1];
    return dfs(n - 1, sum / 2);
  }

  boolean dfs(int i, int j) {
    if (j == 0) return true;
    if (i < 0) {
      return false;
    }
    if (j >= nums[i] && dp[i][j - nums[i]] == null) {
      dp[i][j - nums[i]] = dfs(i - 1, j - nums[i]);
    }
    if (dp[i][j] == null) {
      dp[i][j] = dfs(i - 1, j);
    }
    return (j >= nums[i] ? dp[i][j - nums[i]] : false) || (dp[i][j]);
  }

}
```

#### 例题3: 零钱兑换
[零钱兑换](https://leetcode.cn/problems/coin-change/)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220711170002.png)

##### 分析
- 状态：`dp[i][j]`: 表示从`nums[0...i]`中取出几个数加起来为j
- 下一个状态：`dp[i - 1][j - cnt * nums[i]]`、`dp[i - 1][j]`
- 父子状态之间的递推关系：见递归代码

##### 递归
```java
class Solution {
  int[] coins;
  public int coinChange(int[] coins, int amount) {
    this.coins = coins;  
    int res = dfs(coins.length - 1, amount);
    if (res >= 1e6) return -1;
    return res;
  }
  
  int dfs(int i, int j) {
    if (j == 0) return 0;
    if (i < 0) return (int)1e6;
    int cnt = 1;
    int res = (int)1e6;
    while (j - cnt * coins[i] >= 0) {
      res = Math.min(res, dfs(i - 1, j - cnt * coins[i]) + cnt);
      cnt++;
    }
    res = Math.min(res, dfs(i - 1, j));
    return res;
  }

}
```

##### 带有备忘录的递归
```java
class Solution {
  int[] coins;
  Integer[][] dp;
  public int coinChange(int[] coins, int amount) {
    this.coins = coins;  
    dp = new Integer[coins.length][amount + 1];
    int res = dfs(coins.length - 1, amount);
    if (res >= 1e6) return -1;
    return res;
  }
  
  int dfs(int i, int j) {
    if (j == 0) return 0;
    if (i < 0) return (int)1e6;
    int cnt = 1;
    int res = (int)1e6;
    while (j - cnt * coins[i] >= 0) {
      if (dp[i][j - cnt * coins[i]] == null) {
        dp[i][j - cnt * coins[i]] = dfs(i - 1, j - cnt * coins[i]);
      }
      res = Math.min(res, dp[i][j - cnt * coins[i]] + cnt);
      cnt++;
    }
    if (dp[i][j] == null) {
      dp[i][j] = dfs(i - 1, j);
    }
    res = Math.min(res, dp[i][j]);
    return res;
  }

}
```

#### 例题4: 一和零
[一和零](https://leetcode.cn/problems/ones-and-zeroes/)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220712095839.png)

##### 分析
- 状态：`dp[i][j][z]`: 表示如果只处理前i个字符串，且子集中最多有j个1和z个0时，最大子集的长度
- 下一个状态：`dp[i - 1][j - oneCnt[i]][z - zeroCnt[i]]`、`dp[i - 1][j][z]`
- 父子状态之间的递推关系：见递归代码

##### 递归
```java
class Solution {
  int[] oneCnt;
  int[] zeroCnt;
  public int findMaxForm(String[] strs, int m, int n) {
    oneCnt = new int[strs.length];
    zeroCnt = new int[strs.length];
    for (int i = 0; i < strs.length; i++) {
      int[] temp = getOneAndZeroCnt(strs[i]);
      oneCnt[i] = temp[0];
      zeroCnt[i] = temp[1];
    }
    return dfs(strs.length - 1, n, m);
  }

  int[] getOneAndZeroCnt(String s) {
    int[] res = new int[2];
    for (int i = 0; i < s.length(); i++) {
      if (s.charAt(i) == '1') res[0]++;
      if (s.charAt(i) == '0') res[1]++;
    }
    return res;
  }
  
  int dfs(int i, int j, int z) {
    if (i < 0) return 0;
    return Math.max(j >= oneCnt[i] && z >= zeroCnt[i] ? dfs(i - 1, j - oneCnt[i], z - zeroCnt[i]) + 1 : 0, dfs(i - 1, j, z));
  }
}
```

##### 带有备忘录的递归
```java
class Solution {
  int[] oneCnt;
  int[] zeroCnt;
  Integer[][][] dp;
  public int findMaxForm(String[] strs, int m, int n) {
    oneCnt = new int[strs.length];
    zeroCnt = new int[strs.length];
    for (int i = 0; i < strs.length; i++) {
      int[] temp = getOneAndZeroCnt(strs[i]);
      oneCnt[i] = temp[0];
      zeroCnt[i] = temp[1];
    }
    dp = new Integer[strs.length][n + 1][m + 1];
    return dfs(strs.length - 1, n, m);
  }

  int[] getOneAndZeroCnt(String s) {
    int[] res = new int[2];
    for (int i = 0; i < s.length(); i++) {
      if (s.charAt(i) == '1') res[0]++;
      if (s.charAt(i) == '0') res[1]++;
    }
    return res;
  }
  
  int dfs(int i, int j, int z) {
    if (i < 0) return 0;
    if (j >= oneCnt[i] && z >= zeroCnt[i] && dp[i][j - oneCnt[i]][z - zeroCnt[i]] == null) {
      dp[i][j - oneCnt[i]][z - zeroCnt[i]] = dfs(i - 1, j - oneCnt[i], z - zeroCnt[i]) ;
    }
    if (dp[i][j][z] == null) {
      dp[i][j][z] = dfs(i - 1, j, z);
    }
    return Math.max(j >= oneCnt[i] && z >= zeroCnt[i] ? dp[i][j - oneCnt[i]][z - zeroCnt[i]] + 1 : 0, dp[i][j][z]);
  }
}
```

#### 例题5: 目标和
[目标和](https://leetcode.cn/problems/target-sum/)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220713094619.png)

##### 分析

<div class="container">
  <iframe width="560" height="315" src="https://www.youtube.com/embed/nyWst3hzgXM" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>

设变量a是nums中变量相加后的结果。设变量b是nums中变量相减后的结果。变量sum为nums中所有数相加后的结果。因此有如下式子：
```txt
a + b = target
a - b = sum
==>  a = (target + sum) / 2
```
因此我们可以将问题转化为从nums中选择几个数相加后的结果为a的选法个数

- 状态：`dp[i][j]`: 表示如果只处理前i个数，且要求相加结果为j的选法个数
- 下一个状态：`dp[i - 1][j - nums[i]]`、`dp[i - 1][j]`
- 父子状态之间的递推关系：`(j >= nums[i] ? dfs(i - 1, j - nums[i] : 0) + dfs(i - 1, j)`

##### 递归
```java
class Solution {
  int[] nums;
  public int findTargetSumWays(int[] nums, int target) {
    this.nums = nums;
    int sum = 0;
    for (int num : nums) {
      sum += num;
    }
    int a = sum + target;
    if (a < 0 || a % 2 != 0) return 0;
    return dfs(nums.length - 1, a / 2);
  }

  int dfs(int i, int j) {
    if (i < 0) {
      if (j == 0) return 1; 
      return 0;
    } 
    return (j >= nums[i] ? dfs(i - 1, j - nums[i]) : 0) + dfs(i - 1, j);
  }
}
```

##### 带有备忘录的递归
```java
class Solution {
  int[] nums;
  Integer[][] dp;
  public int findTargetSumWays(int[] nums, int target) {
    this.nums = nums;
    int sum = 0;
    for (int num : nums) {
      sum += num;
    }
    int a = sum + target;
    if (a < 0 || a % 2 != 0) return 0;
    dp = new Integer[nums.length][a / 2 + 1];
    return dfs(nums.length - 1, a / 2);
  }

  int dfs(int i, int j) {
    if (i < 0) {
      if (j == 0) return 1; 
      return 0;
    } 
    if (j >= nums[i] && dp[i][j - nums[i]] == null) {
      dp[i][j - nums[i]] = dfs(i - 1, j - nums[i]);
    }
    if (dp[i][j] == null) {
      dp[i][j] = dfs(i - 1, j);
    } 
    return (j >= nums[i] ? dp[i][j - nums[i]] : 0) + dp[i][j];
  }
}
```

#### 例题6: 最后一块石头的重量 II
[最后一块石头的重量 II](https://leetcode.cn/problems/last-stone-weight-ii/)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220713103952.png)

##### 分析

<div class="container">
  <iframe width="560" height="315" src="https://www.youtube.com/embed/bP_hX3-fcqw" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>


问题转换为，把石头分为两堆,分别是a、b，使a、b差值最小。有如下式子
```txt
a + b = sum
a - b = diff
==> 2*a = sum + diff
==> diff = sum - 2 * a
```
所以让diff值最小的话，就是让a最接近sum/2

- 状态：`dp[i][j]`: 表示如果只处理前i个数，且选出几个数相加不超过j的最大值
- 下一个状态：`dp[i - 1][j - stones[i]]`、`dp[i - 1][j]`
- 父子状态之间的递推关系：`Math.max(j >= stones[i] ? dp[i][j - stones[i]] + stones[i] : 0, dp[i][j])`

##### 递归
```java
class Solution {
  int[] stones;
  public int lastStoneWeightII(int[] stones) {
    this.stones = stones;
    int sum = Arrays.stream(stones).sum();
    int a = dfs(stones.length - 1, sum / 2);
    return sum - 2 * a;
  }
  
  int dfs(int i, int j) {
    if (i < 0) return 0;
    return Math.max(j >= stones[i] ? dfs(i - 1, j - stones[i]) + stones[i] : 0, dfs(i - 1, j));
  }
}
```

##### 带有备忘录的递归
```java
class Solution {
  int[] stones;
  Integer[][] dp;
  public int lastStoneWeightII(int[] stones) {
    this.stones = stones;
    int sum = Arrays.stream(stones).sum();
    dp = new Integer[stones.length][sum / 2 + 1];
    int a = dfs(stones.length - 1, sum / 2);
    return sum - 2 * a;
  }
  
  int dfs(int i, int j) {
    if (i < 0) return 0;
    if (j >= stones[i] && dp[i][j - stones[i]] == null) {
      dp[i][j - stones[i]] = dfs(i - 1, j - stones[i]);
    }
    if (dp[i][j] == null) {
      dp[i][j] = dfs(i - 1, j);
    }
    return Math.max(j >= stones[i] ? dp[i][j - stones[i]] + stones[i] : 0, dp[i][j]);
  }
}
```

#### 例题7: 完全背包问题
[完全背包问题](https://www.acwing.com/problem/content/3/)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220713110320.png)

- 状态：`dp[i][j]`: 表示如果只处理前i个物品，且容量为j的情况下的最多可以装的物品都价值
- 下一个状态：`dp[i - 1][j - cnt * v[i]]`、`dp[i - 1][j]`
- 父子状态之间的递推关系：见递归

##### 递归
```java
int N = cin.nextInt();
int V = cin.nextInt();
int[] v = new int[N];
int[] w = new int[N];

public void solve() {
  for (int i = 0; i < N; i++) {
    v[i] = cin.nextInt();
    w[i] = cin.nextInt();
  }
  System.out.println(dfs(N - 1, V));
}

int dfs(int i, int j) {
  if (i < 0) return 0;
  int res = 0;
  for (int cnt = 0; j >= cnt * v[i]; cnt++) {
    res = Math.max(res, dfs(i - 1, j - cnt * v[i]) + cnt * w[i]);
  }
  return res;
}
```

##### 带有备忘录的递归
```java
int N = cin.nextInt();
int V = cin.nextInt();
int[] v = new int[N];
int[] w = new int[N];
Integer[][] dp = new Integer[N][V + 1];

public void solve() {
  for (int i = 0; i < N; i++) {
    v[i] = cin.nextInt();
    w[i] = cin.nextInt();
  }
  System.out.println(dfs(N - 1, V));
}

int dfs(int i, int j) {
  if (i < 0) return 0;
  int res = 0;
  for (int cnt = 0; j >= cnt * v[i]; cnt++) {
    if (dp[i][j - cnt * v[i]] == null) {
      dp[i][j - cnt * v[i]] = dfs(i - 1, j - cnt * v[i]);
    }
    res = Math.max(res, dp[i][j - cnt * v[i]] + cnt * w[i]);
  }
  return res;
}
```

#### 例题8: 零钱兑换 II
[零钱兑换 II](https://leetcode.cn/problems/coin-change-2/)

- 状态：`dp[i][j]`: 表示从`coins[0...i]`中取出几个数加起来为j的选法个数
- 下一个状态：`dp[i - 1][j - cnt * coins[i]]`、`dp[i - 1][j]`
- 父子状态之间的递推关系：见递归

##### 递归
```java
class Solution {
  int[] coins;
  public int change(int amount, int[] coins) {
    this.coins = coins; 
    return dfs(coins.length - 1, amount); 
  }
  
  int dfs(int i, int j) {
    if (i < 0) {
      if (j == 0) return 1;
      return 0;
    }
    int res = 0;
    for (int cnt = 0; j >= cnt * coins[i]; cnt++) {
      res += dfs(i - 1, j - cnt * coins[i]);
    }
    return res;
  }
}
```

##### 带有备忘录的递归
```java
class Solution {
  int[] coins;
  Integer[][] dp;
  public int change(int amount, int[] coins) {
    this.coins = coins; 
    dp = new Integer[coins.length][amount + 1];
    return dfs(coins.length - 1, amount); 
  }
  
  int dfs(int i, int j) {
    if (i < 0) {
      if (j == 0) return 1;
      return 0;
    }
    int res = 0;
    for (int cnt = 0; j >= cnt * coins[i]; cnt++) {
      if (dp[i][j - cnt * coins[i]] == null) {
        dp[i][j - cnt * coins[i]] = dfs(i - 1, j - cnt * coins[i]);
      }
      res += dp[i][j - cnt * coins[i]];
    }
    return res;
  }
}
```

### 博弈类动态规划
#### 什么是博弈
链接：https://www.zhihu.com/question/48241066/answer/115476949

问题描述得有点过于简单了，但我认为更多人关注这个问题可能不是为了学习博弈论或者说希望在日常生活中有意识地去应用它，而是仅仅为了通过博弈论中的一些有趣的例子来初步理解。

简单地说，**有多个人进行互动的地方就有博弈**。从这个角度来看，博弈基本是无处不在的。

在回答这个问题的时候，我也是在与各位观众进行一个博弈：怎么去回答才能获得各位的称赞呢？考虑到绝大部分人喜欢听故事、看例子，我找一些比较典型的博弈案例进行回答是不是会比较合适呢？目前的高票答案便是典型：讲述自身的故事，加强认同感和真实性，再加上典型案例。

再比如说，玩游戏、赌博，甚至是决斗，都是一场博弈。有人的地方就有江湖，有多个人互动的地方就有博弈。博弈论研究的是高手间那些看不见的对决，他们往往还没出刀就已经知道了胜负。

#### 分析模版
一般的模型：`dp[玩家A][状态S]` = `max { Reward[行动X]  + (RemainReward[行动X] - dp[玩家B][状态T])，假设玩家A采取行动X到达状态T }`。

- `dp[玩家A][状态S]`：表示玩家A面对状态S时的最优解
- `Reward[行动X]`: 表示玩家A采取行动X时所获取到的奖励
- `RemainReward[行动X]`: 表示玩家A采取行动X后还剩下的奖励
- `dp[玩家B][状态T]`：表示玩家A采取行动X后到达了状态T时，玩家B面对状态T时的最优解

注意：如果是只有2个玩家的话，可以是不需要存储当前是什么玩家的，因为dfs递归树中父节点与子字节就分别代表着2个不同的玩家。例如：例题3:Nim 游戏

#### 例题1: 石子游戏 II
[石子游戏 II](https://leetcode.cn/problems/stone-game-ii/)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220713170724.png)

##### 分析
<div class="container">
  <iframe width="560" height="315" src="https://www.youtube.com/embed/rupxUQrTc3o" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>

- 状态：`dp[i][m]`: 表示当第i堆为当前最前面的一堆，并且M=m时，当前玩家可以得到的最多石头
- 下一个状态：见递归代码
- 父子状态之间的递推关系：见递归代码

##### 递归
```java
class Solution {
  int[] piles;
  int[] preSum;
  public int stoneGameII(int[] piles) {
    int n = piles.length;
    this.piles = piles;
    preSum = new int[n];
    preSum[0] = piles[0];
    for (int i = 1; i < n; i++) {
      preSum[i] = preSum[i - 1] + piles[i];
    }
    return dfs(0, 1);
  }

  int dfs(int i, int m) {
    if (i >= piles.length) return 0;
    int temp = Integer.MAX_VALUE;
    for (int cnt = 1; cnt <= 2 * m && cnt + i <= piles.length; cnt++) {
      temp = Math.min(temp, dfs(i + cnt, Math.max(m, cnt)));
    }
    return preSum[piles.length - 1] - preSum[i] + piles[i] - temp;
  }
}
```

##### 带有备忘录的递归
```java
class Solution {
  int[] piles;
  int[] preSum;
  Integer[][] dp;
  public int stoneGameII(int[] piles) {
    int n = piles.length;
    this.piles = piles;
    preSum = new int[n];
    preSum[0] = piles[0];
    for (int i = 1; i < n; i++) {
      preSum[i] = preSum[i - 1] + piles[i];
    }
    dp = new Integer[n + 1][n + 1];
    return dfs(0, 1);
  }

  int dfs(int i, int m) {
    if (i >= piles.length) return 0;
    int temp = Integer.MAX_VALUE;
    for (int cnt = 1; cnt <= 2 * m && cnt + i <= piles.length; cnt++) {
      if (dp[i + cnt][Math.max(m, cnt)] == null) {
        dp[i + cnt][Math.max(m, cnt)] = dfs(i + cnt, Math.max(m, cnt));
      } 
      temp = Math.min(temp, dp[i + cnt][Math.max(m, cnt)]);
    }
    return preSum[piles.length - 1] - preSum[i] + piles[i] - temp;
  }
}
```

#### 例题2: 预测赢家
[预测赢家](https://leetcode.cn/problems/predict-the-winner/)  

##### 分析
- 状态：`dp[i][j]`: 表示当前玩家面临着nums[i...j]区间的分数时，所能选择的最大分数
- 下一个状态：`dp[i + 1][j]`、`dp[i][j - 1]`
- 父子状态之间的递推关系：见递归代码

##### 递归
```java
class Solution {
  int[] preSum;
  int[] nums;
  public boolean PredictTheWinner(int[] nums) {
    int n = nums.length;
    this.nums = nums;
    preSum = new int[n + 1];
    preSum[0] = nums[0];
    for (int i = 1; i < n; i++) {
      preSum[i] = preSum[i - 1] + nums[i];
    }
    int temp = dfs(0, n - 1);
    return preSum[n - 1] - preSum[0] + nums[0] - temp <= temp;
  }
  
  int dfs(int i, int j) {
    if (i > j) return 0;
    return preSum[j] - preSum[i] + nums[i] - Math.min(dfs(i + 1, j), dfs(i, j - 1));
  }
}
```

##### 带有备忘录的递归
```java
class Solution {
  int[] preSum;
  int[] nums;
  Integer[][] dp;
  public boolean PredictTheWinner(int[] nums) {
    int n = nums.length;
    this.nums = nums;
    preSum = new int[n + 1];
    preSum[0] = nums[0];
    for (int i = 1; i < n; i++) {
      preSum[i] = preSum[i - 1] + nums[i];
    }
    dp = new Integer[n + 1][n + 1];
    int temp = dfs(0, n - 1);
    return preSum[n - 1] - preSum[0] + nums[0] - temp <= temp;
  }
  
  int dfs(int i, int j) {
    if (i > j) return 0;
    if (dp[i + 1][j + 1] == null) {
      dp[i + 1][j + 1] = dfs(i + 1, j);
    }
    if (dp[i][j] == null) {
      dp[i][j] = dfs(i, j - 1);
    }
    return preSum[j] - preSum[i] + nums[i] - Math.min(dp[i + 1][j + 1], dp[i][j]);
  }
}
```

#### 例题3: Nim 游戏
[Nim 游戏](https://leetcode.cn/problems/nim-game/)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220713145113.png)

##### 分析
- 状态：`dp[i]`: 表示当前玩家面临着i个石头时，是否能赢得游戏
- 下一个状态：`dp[i - 1]`、`dp[i - 2]`、`dp[i - 3]`
- 父子状态之间的递推关系：`dp[i] |= !dfs(i - cnt);`

##### 递归
```java
class Solution {
  public boolean canWinNim(int n) {
    return dfs(n);
  }

  boolean dfs(int i) {
    if (i <= 0) return false;
    boolean res = false;
    for (int cnt = 1; cnt < 4; cnt++) {
      res |= !dfs(i - cnt);
    }
    return res;
  }
}
```

##### 带有备忘录的递归
```java
class Solution {
  Boolean[] dp;
  public boolean canWinNim(int n) {
    dp = new Boolean[n + 4];
    return dfs(n);
  }

  boolean dfs(int i) {
    if (i <= 0) return false;
    boolean res = false;
    for (int cnt = 1; cnt < 4; cnt++) {
      if (dp[i - cnt + 4] == null) {
        dp[i - cnt + 4] = dfs(i - cnt);
      }
      res |= !dp[i - cnt + 4];
    }
    return res;
  }
}
```

#### 例题4: 除数博弈
[除数博弈](https://leetcode.cn/problems/divisor-game/)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220713172910.png)

##### 分析
- 状态：`dp[n]`: 表示当前玩家面临着黑板上的数字为n时，是否能赢得游戏
- 下一个状态：见递归代码
- 父子状态之间的递推关系：见递归代码

##### 递归
```java
class Solution {
  public boolean divisorGame(int n) {
    return dfs(n);
  }
  
  boolean dfs(int n) {
    boolean res = false;
    for (int x = 1; x < n; x ++) {
      if (n % x == 0) {
        res |= !dfs(n - x);
      }
    }
    return res;
  }
}
```

##### 带有备忘录的递归
```java
class Solution {
  Boolean[] dp;
  public boolean divisorGame(int n) {
    dp = new Boolean[n + 1];
    return dfs(n);
  }
  
  boolean dfs(int n) {
    boolean res = false;
    for (int x = 1; x < n; x ++) {
      if (n % x == 0) {
        if (dp[n - x] == null) {
          dp[n - x] = dfs(n - x);
        }
        res |= !dp[n - x];
      }
    }
    return res;
  }
}
```

#### 例题5: 石子游戏
[石子游戏](https://leetcode.cn/problems/stone-game/)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220713185427.png)

##### 分析
- 状态：`dp[i][j]`: 表示当前玩家面临着piles[i...j]区间的石子时，所能选择的最多石子
- 下一个状态：`dp[i + 1][j]`、`dp[i][j - 1]`
- 父子状态之间的递推关系：见递归代码

##### 递归
```java
class Solution {
  int[] piles;
  int[] preSum;
  public boolean stoneGame(int[] piles) {
    int n = piles.length;
    this.piles = piles;
    preSum = new int[n];
    preSum[0] = piles[0];
    for (int i = 1; i < n; i++) {
      preSum[i] = preSum[i - 1] + piles[i];
    }
    int temp = dfs(0, n - 1);
    return 2 * temp > preSum[n - 1];
  }
  
  int dfs(int i, int j) {
    if (i > j) return 0;
    return preSum[j] - preSum[i] + piles[i] - Math.min(dfs(i + 1, j), dfs(i, j - 1));
  }
  
}
```

##### 带有备忘录的递归
```java
class Solution {
  int[] piles;
  int[] preSum;
  Integer[][] dp;
  public boolean stoneGame(int[] piles) {
    int n = piles.length;
    this.piles = piles;
    preSum = new int[n];
    preSum[0] = piles[0];
    for (int i = 1; i < n; i++) {
      preSum[i] = preSum[i - 1] + piles[i];
    }
    dp = new Integer[n + 1][n + 1];
    int temp = dfs(0, n - 1);
    return 2 * temp > preSum[n - 1];
  }
  
  int dfs(int i, int j) {
    if (i > j) return 0;
    if (dp[i + 1][j + 1] == null) {
      dp[i + 1][j + 1] = dfs(i + 1, j);
    }
    if (dp[i][j] == null) {
      dp[i][j] = dfs(i, j - 1);
    }
    return preSum[j] - preSum[i] + piles[i] - Math.min(dp[i + 1][j + 1], dp[i][j]);
  }
  
}
```

### 在树上或DAG上动态规划
#### 分析模版
- 状态：`dp[状态A]`: 表示从状态A开始所能获取到的最优解
- 下一个状态：状态A所能到达的所有下一个状态

#### 例题1:网格图中递增路径的数目
[网格图中递增路径的数目](https://leetcode.cn/problems/number-of-increasing-paths-in-a-grid/)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220714163050.png)

##### 分析
<div class="container">
  <iframe width="560" height="315" src="https://www.youtube.com/embed/BbbnnoE-NqY" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>

- 状态：`dp[i][j]`: 表示从坐标(i, j)开始所能获取所有严格递增路径的个数
- 下一个状态：见递归代码

##### 递归
```java
class Solution {
  int n;
  int m;
  int[][] grid;
  public int countPaths(int[][] grid) {
    n = grid.length;
    m = grid[0].length;
    this.grid = grid;
    int res = 0;
    for (int r = 0; r < n; r++) {
      for (int c = 0; c < m; c++) {
        res += dfs(r, c);
      }
    }
    return res;
  }

  int dfs(int r, int c) {
    int res = 1;
    int[] dr = new int[]{0, 1, 0, -1};
    int[] dc = new int[]{1, 0, -1, 0};
    for (int i = 0; i < 4; i++) {
      int nr = r + dr[i];
      int nc = c + dc[i];
      if (nr >= 0 && nr < n && nc >= 0 && nc < m && grid[r][c] < grid[nr][nc]) {
        res += dfs(nr, nc);
      }
    }
    return res;
  }
}
```

##### 带有备忘录的递归
```java
class Solution {
  int n;
  int m;
  int[][] grid;
  Integer[][] dp;
  public int countPaths(int[][] grid) {
    n = grid.length;
    m = grid[0].length;
    this.grid = grid;
    dp = new Integer[n][m];
    int res = 0;
    for (int r = 0; r < n; r++) {
      for (int c = 0; c < m; c++) {
        res = (int)(res % (1e9 + 7) + dfs(r, c) % (1e9 + 7));
      }
    }
    return (int)(res % (1e9 + 7));
  }

  int dfs(int r, int c) {
    int res = 1;
    int[] dr = new int[]{0, 1, 0, -1};
    int[] dc = new int[]{1, 0, -1, 0};
    for (int i = 0; i < 4; i++) {
      int nr = r + dr[i];
      int nc = c + dc[i];
      if (nr >= 0 && nr < n && nc >= 0 && nc < m && grid[r][c] < grid[nr][nc]) {
        if (dp[nr][nc] == null) {
          dp[nr][nc] = dfs(nr, nc);
        }
        res += dp[nr][nc];
      }
    }
    return (int)(res % (1e9 + 7));
  }
}
```

#### 例题2: 二叉树中的最长交错路径
[二叉树中的最长交错路径](https://leetcode.cn/problems/longest-zigzag-path-in-a-binary-tree/)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220714182726.png)

##### 递归
```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
  int ans = 0;
  public int longestZigZag(TreeNode root) {
    traverse(root);
    return ans;
  }

  void traverse(TreeNode node) {
    if (node.left != null) {
      ans = Math.max(ans, dfs(node.left, 0));
      traverse(node.left);
    }
    if (node.right != null) {
      ans = Math.max(ans, dfs(node.right, 1));
      traverse(node.right);
    }
  }

  int dfs(TreeNode node, Integer flag) {
    int res = 1;
    if (flag == 0 && node.right != null) {
      return dfs(node.right, 1) + 1;
    }
    if (flag == 1 && node.left != null) {
      return dfs(node.left, 0) + 1;
    }
    return res;
  }
}
```

##### 带有备忘录的递归
```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
  int ans = 0;
  Map<State, Integer> dp = new HashMap(); 
  public int longestZigZag(TreeNode root) {
    traverse(root);
    return ans;
  }

  void traverse(TreeNode node) {
    if (node.left != null) {
      ans = Math.max(ans, dfs(node.left, 0));
      traverse(node.left);
    }
    if (node.right != null) {
      ans = Math.max(ans, dfs(node.right, 1));
      traverse(node.right);
    }
  }

  int dfs(TreeNode node, Integer flag) {
    int res = 1;
    if (flag == 0 && node.right != null) {
      if (!dp.containsKey(new State(node.right, 1))) {
        dp.put(new State(node.right, 1), dfs(node.right, 1));
      }
      return dp.get(new State(node.right, 1)) + 1;
    }
    if (flag == 1 && node.left != null) {
      if (!dp.containsKey(new State(node.left, 0))) {
        dp.put(new State(node.left, 0), dfs(node.left, 0));
      }
      return dp.get(new State(node.left, 0)) + 1;
    }
    return res;
  }

  class State {
    TreeNode node;
    Integer flag;

    public State(TreeNode node, Integer flag) {
      this.node = node; 
      this.flag = flag;
    }

    public int hashCode() {
      return Objects.hash(node, flag);
    }

    public boolean equals(Object o) {
      if (o == null) return false;
      State state = (State) o;
      return node == state.node && flag == state.flag;
    }

  }
}
```

#### 例题3: 最长字符串链
[最长字符串链](https://leetcode.cn/problems/longest-string-chain/)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220715104817.png)

##### 分析
首先将words中个个元素用在图中表示出来，表示方式为：如果s1是s2的前身，则s1指向s2。例如以`words = ["a","b","ba","bca","bda","bdca"]`为例，用图表示如下:

![](https://raw.githubusercontent.com/NaisWang/images/master/20220715111312.png)

- 状态：`dp[i]`: 表示从words[i]开始所能获取到的最长单词链长度
- 下一个状态：words[i]在图中所能到达的所有下一个的状态

##### 递归
```java
class Solution {
  int ans = 1;
  String[] words;
  List<Integer>[] graph;
  public int longestStrChain(String[] words) {
    this.words = words;

    // 转换为图
    graph = new List[words.length]; 
    for (int i = 0; i < words.length; i++) {
      graph[i] = new ArrayList();
    }
    for (int i = 0; i < words.length; i++) {
      for (int j = 0; j < words.length; j++) {
        if (judge(words[i], words[j])) {
          graph[i].add(j);
        }
      }
    }
    
    for (int i = 0; i < words.length; i++) {
      ans = Math.max(ans, dfs(i)); 
    }
    return ans;
  }

  int dfs(int i) {
    int res = 1;
    for (Integer item : graph[i]) {
      res = Math.max(res, dfs(item) + 1);
    }
    return res;
  }

  // 判断s是否为s1的前身
  boolean judge(String s, String s1) {
    if (s1.length() - s.length() != 1) return false;
    int i = s.length() - 1;
    int j = s1.length() - 1;
    char[] sCh = s.toCharArray();
    char[] s1Ch = s1.toCharArray();
    boolean flag = true;
    while (i >= 0 && j >= 0) {
      if (sCh[i] == s1Ch[j]) {
        i--;
        j--;
      } else {
        if (flag) {
          j--;
          flag = false;
        } else {
          return false;
        }
      }
    }
    return true;
  }

}
```

##### 带有备忘录的递归
```java
class Solution {
  int ans = 1;
  String[] words;
  List<Integer>[] graph;
  Integer[] dp;
  public int longestStrChain(String[] words) {
    this.words = words;

    // 转换为图
    graph = new List[words.length]; 
    for (int i = 0; i < words.length; i++) {
      graph[i] = new ArrayList();
    }
    for (int i = 0; i < words.length; i++) {
      for (int j = 0; j < words.length; j++) {
        if (judge(words[i], words[j])) {
          graph[i].add(j);
        }
      }
    }
    
    dp = new Integer[words.length];
    for (int i = 0; i < words.length; i++) {
      ans = Math.max(ans, dfs(i)); 
    }
    return ans;
  }

  int dfs(int i) {
    int res = 1;
    for (Integer item : graph[i]) {
      if (dp[item] == null) dp[item] = dfs(item);
      res = Math.max(res, dp[item] + 1);
    }
    return res;
  }

  // 判断s是否为s1的前身
  boolean judge(String s, String s1) {
    if (s1.length() - s.length() != 1) return false;
    int i = s.length() - 1;
    int j = s1.length() - 1;
    char[] sCh = s.toCharArray();
    char[] s1Ch = s1.toCharArray();
    boolean flag = true;
    while (i >= 0 && j >= 0) {
      if (sCh[i] == s1Ch[j]) {
        i--;
        j--;
      } else {
        if (flag) {
          j--;
          flag = false;
        } else {
          return false;
        }
      }
    }
    return true;
  }

}
```

### 总结
动态规划就是分治法的优化版。

![](https://raw.githubusercontent.com/NaisWang/images/master/20220718233141.png)

如上图中，分治法中递归树中的节点其实表达的都是同一种意思，即`f(状态) -> 值`，含义是：将某个状态带入转换式中得到对应的值

所以在写分治法时，最关键的一步就是确定`f(状态) -> 值`

<font color="red">在递归树中，当一个子节点压入函数栈时，如果没有携带父节点当状态当话，子节点是无法访问父节点的状态的，所以此时子节点返回的值肯定与父节点的状态无关。而分治法中节点一般是不需要携带父节点中的状态的。所以当分治法中的子节点没有携带父节点中的状态时，**每个节点的返回值跟其父节点是什么状态没有任何关系，即节点的返回值不受父节点影响**。该结论十分十分重要!!!</font>

**例如下面例题吃水果中子节点是没有携带父节点中的状态的，所以dp[i - 1][k]的值与第i个小朋友选了什么样的水果无关，同理dp[i - 1][k - 1]的值也与第i个小朋友选了什么样的水果无关**

#### 例题: 吃水果
[吃水果](https://www.acwing.com/problem/content/4499/)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220718231439.png)

##### 分析
- 状态：dp[i][k]: 表示前i+1个小朋友中恰好有k个小朋友拿到的水果和其左边相邻小朋友拿到的水果不同的分发水果的方案数
- 下一个状态：dp[i - 1][k]、dp[i - 1][k - 1]

**由于子节点是没有携带父节点中的状态的，在写递归出口时，即求叶子节点的返回值时，不需要考虑其父节点是什么状态。**直接分析叶子节点的状态，将其状态代入`f(状态) -> 值`中即可。例如此题中的`f(状态) -> 值`为前i+1个小朋友中恰好有k个小朋友拿到的水果和其左边相邻小朋友拿到的水果不同的分发水果的方案数。所以dp[0][0]表示前1个小朋友中恰好有0个小朋友拿到的水果和其左边相邻小朋友拿到的水果不同的分发水果的方案数, 所以dp[0][0]等于0，

##### 递归
```java
int n = cin.nextInt(), m = cin.nextInt(), k = cin.nextInt();
public void solve() {
  System.out.println(dfs(n - 1, k));
}

long dfs(int i, int k) {
  if (i == 0 && k == 0) return m;
  if (i == 0 || k < 0) return 0;
  return (dfs(i - 1, k) + dfs(i - 1, k - 1) * (m - 1)) % 998244353;
}
```

##### 带有备忘录的递归
```java
int n = cin.nextInt(), m = cin.nextInt(), k = cin.nextInt();
Long[][] dp;
public void solve() {
  dp = new Long[n + 2][k + 2];
  System.out.println(dfs(n - 1, k));
}

long dfs(int i, int k) {
  if (i == 0 && k == 0) return m;
  if (i == 0 || k < 0) return 0;
  if (dp[i][k + 1] == null) {
    dp[i][k + 1] = dfs(i - 1, k);
  }
  if (dp[i][k] == null) {
    dp[i][k] = dfs(i - 1, k - 1);
  }
  return (dp[i][k + 1] + dp[i][k] * (m - 1)) % 998244353;
}
```

## 闫式dp分析法
核心思想：从集合的角度考虑
<font color="red">所有的dp问题，本质上都是有限集中的最值、数量问题</font>

![](https://raw.githubusercontent.com/NaisWang/images/master/20220408164542.png)

### 分析阶段
动态规划有两个要点：状态与状态转移
那么阶段自然也应该有两个：**状态表示**和**状态计算**
#### 状态表示
把几个具有相同点的元素合在一起考虑，成为一个状态
对于一个状态 F(i) ，考虑两个角度：
- **1.集合** ：F(i) 表示什么集合
由于 F(i) 表示的是一堆东西(这也是DP优于枚举的核心)，我们要考虑这一堆东西的共同特征，如：所有满足某个条件的元素集合
这一点请仔细考虑，到底是大于等于，大于，小于，小于等于，等于......这些的不同会导致状态计算方式的不同
- **2.属性**：F(i)的值与集合的关系：如 max,min,count,sum 等
很明显，F(i)的值大多数时候是一个数，代表这个集合的某一个属性，多是最大值、最小值、数量、总和等。题目问什么，属性一般就是什么

#### 状态计算
**三步走**
1. 先看 F(i) 表示的集合：

![](https://raw.githubusercontent.com/NaisWang/images/master/20220408182417.png)

2. 将其划分为若干个子集合，要求不重(有些情况可以重复，例如求最大值)和不漏

![](https://raw.githubusercontent.com/NaisWang/images/master/20220408182430.png)

<font color="red">划分的依据：找最后一个不同点(这个待会会讲)</font>

3. 划分过后，根据子集合来求F(i)
如：当属性为 max 时，F(i)=max(子集的max)
当属性为 count 时，F(i)=∑(子集的count)

#### 代码优化
dp问题的优化是对代码作等价变形，常用的手段是使用滚动数组

### 选择问题的dp
有关选择问题的dp，常见的就是背包问题。<font color="red">而选择问题的状态表示都是很相似的，一般状态的第一维表示我只考虑前面i个物品，后面几维一般表示限制，比如体积的限制，重量的限制</font>

#### 0-1背包问题
[0-1背包问题-模板题](https://www.acwing.com/problem/content/2/)
在上述例题中，由于每个物体只有2种可能的状态（取与不取），正如二进制中的0和1，这类问题便被称为「0-1 背包问题」。

**1. 解析**
根据乘法原理，总共的方案为$2^n$  。在所有的方案数中选择一个价值最大的方案，属于有限集的最优问题，可以用试着DP来解。

**2. 状态表示**
对于F(i,j)：
集合：所有只考虑前i个物品，且总体积不超过的j的方案
属性：题目要求我们求最大价值，则其属性就是max。

**3. 状态计算**

![](https://raw.githubusercontent.com/NaisWang/images/master/20220408182442.png)

于是我们可以得到状态转移方程：
$F(i,j)=max( F(i−1,j) , F(i−1,j−V_i)+W_i)$
这就事朴素DP的分析过程了，至于压维等时空优化从状态转移方程出发

**代码**
```java
/**
* n: 表示物品数量
* m: 表示背包容积
* v[]: 表示第 i 件物品的体积
* w[]: 表示第 i 件物品的价值
*/
public static int f(){
  int[][] dp = new int[N+1][V+1];
  for(int i = 1; i <= N; i++){
    for(int j = 0; j <= V; j++){
      dp[i][j] = dp[i-1][j];
      if(j >= v[i]) dp[i][j] = Math.max(dp[i][j], dp[i-1][j-v[i]]+w[i]);
    }
  }
  return dp[N][V];
}
```

#### 完全背包问题
[完全背包问题-模板题](https://www.acwing.com/problem/content/3/)
完全背包问题与0-1背包问题的不同点在于完全背包问题中的每种物品都有无限件可用

**1. 解析**
仍然从两个角度考虑：
设状态 F(i,j)

**2. 状态表示**
对于 F(i,j):
集合：所有只从前i个物品中选，总体积不超过j的所有方案。
属性：max。
原因和01背包相似

**3. 状态计算**

![](https://raw.githubusercontent.com/NaisWang/images/master/20220408182455.png)

于是易得状态转移方程：
`$F(i,j)=max( F(i−1,j), F(i−1,j−V_i)+W_i, F(i−1,j−2*V_i)+2*W_i,...)$`

但是这个东西项数太多，想办法把它转换成两项

由上面的状态转移方程我们可以得到：
`$F(i,j−V_i)=max( F(i−1,j−V_i), F(i−1,j−2*V_i)+W_i, F(i−1,j−3*V_i)+2*W_i ,...)$`
观察得到，上面的第二项后面的每一项都是下面的每一项加上一个$W_i$。

于是我们可以得到状态转移方程：
$F(i,j)=max(F(i−1,j) , F(i,j−V_i)+W_i)$


**代码**
```java
/**
* n: 表示物品数量
* m: 表示背包容积
* v[]: 表示第 i 件物品的体积
* w[]: 表示第 i 件物品的价值
*/
public static int f(){
  int[][] dp = new int[n+1][m+1];
  for(int i = 1; i <= n; i++){
    for(int j = 0; j <= m; j++){
      dp[i][j] = dp[i-1][j];
      if(j >= v[i]) f[i][j] = Math.max(dp[i][j], dp[i][j-v[i]]+w[i]);
    }
  }
  return f[n][m];
}
```

### 区间Dp
顾名思义：区间dp就是在区间上进行动态规划，求解一段区间上的最优解。主要是通过合并小区间的 最优解进而得出整个大区间上最优解的dp算法。

有关区间dp，常见的就是石子合并问题。<font color="red">而区间dp的状态表示都是很相似的，一般状态的第一维表示区间的左端点，第二维表示区间的右端点</font>

#### 石子合并问题
[石子合并题目链接](https://www.acwing.com/problem/content/284/)

**解析**
满足有限集最优化

**状态表示**
对于F(i,j)
集合：所有将区间`[i,j]`合并成一堆的方案集合
属性：题目求的是最小值，所以min。

**状态计算**
1. 看这个F(i,j)表示的集合：

![](https://raw.githubusercontent.com/NaisWang/images/master/20220408162412.png)

2. 将其划分若干个子集合
考虑最后一个不同点
最后一次， 也就是合并到`[i,j]`时，一定是由两个区间`[i,k]`和`[k,j]`合并而来的。显然，k∈`[i,j]`
所以我们考虑以这个分界点 k 为划分依据，分成 j−i 类。

![](https://raw.githubusercontent.com/NaisWang/images/master/20220408162422.png)

再来看一下合并的区间：

![](https://raw.githubusercontent.com/NaisWang/images/master/20220408162433.png)

3. 根据子集合求F(i, j)
以 左边`[i, i+2]`与右边`[i+3, j]`合并成一堆的子集合 为例 ，左边的`[i, i+2]`区间与右边的`[i+3, j]`区间互不干扰，所以两边取min再加上这部分石子的总质量，即为这个子集合的最小值，两边恰好是 F(i,i+2) 和 F(i+3,j)。于是这个子集合的最小代价为$F(i,i+2)+F(i+3,j)+S_j−S_{i−1}$ ，S是石子重量的前缀和。

所以状态转移方程为：
$F(i,j)=min( F(i, i)+F(i+1, j), F(i, i+1)+F(i+2, j), F(i, i+2)+F(i+3,j), ..., F(i, i+k)+F(i+k+1, j), ..., F(i, i+j-1)+F(j,j) ) + S_j-S_{i-1}$

**代码**
```java
public static int f(){
  int[][] f = new int[n+1][n+1];
  for(int len = 2; len <= n; len++){  //len表示区间的长度
    for(int i = 1; i+len-1 <= n; i++){ //i表示区间的左端点
      int j = i+len-1; //j表示区间的右端点
      f[i][j] = Integer.MAX_VALUE;
      for(int k = i; k < j; k++){
        f[i][j] = Math.min(f[i][j], f[i][k]+f[k+1][j]);
      }
      f[i][j] = f[i][j] + s[j] - s[i-1];
    }
  } 
  return f[1][n];
}
```

# 数论
## 常用数的整除特征

<div class="container">
  <iframe width="560" height="315" src="https://www.youtube.com/embed/d2ziUoPM9rE" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>

### 方法

#### 末位法
- 能否被`2`，`5`整除，看末一位能否被2，5整除
- 能否被`4`，`25`整除，看末二位能否被4，25整除
- 能否被`8`，`125`整除，看末三位能否被8，125整除
- 能否被$2^n$，$5^n$整除，看末n位能否被$2^n$，$5^n$整除

例如：
- 2025的为末一位能被5整除，则2025能被5整除
- 2025的为末二位能被25整除，则2025能被25整除

#### 数和法
判断数A能否被`3`，`9`整除：把各位数字加起来，如果能被3，9整除，则数A能被3，9整除

例如：
- 2019的各位数字加起来为12，12能被3整除，所以2019能被3整除

#### 数差法
判断数A能否被`11`整除：如果`奇数位数字和`与`偶数位数字和`之差能被11整除，则数A能被11整除

例如：
- 4356中的奇数位和为9，偶数位数字和为9，它们差为0，0能被11整除，则4356能被11整除

#### 截尾法
判断数A能否被`7`,`11`,`13` 整除：截掉后面3位，如果截断后的数字与后面3位数字之差能被7，11，13整除，则数A能被7，11，13整除

例如：
- 2023截掉后面3位后值为2，2与023之差为21，21能被7整除，所以2023能被7整除


#### 例题1: 整除子串
[整除子串](https://www.acwing.com/problem/content/4429/)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220718165705.png)

##### 分析
<div class="container">
  <iframe width="560" height="315" src="https://www.youtube.com/embed/SwneFgy_MxU" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>

在acm中，会出现让你计算一个字符串中能被$2^n$或$5^n$整除的子串个数。如果暴力枚举每个子串进行统计的话，时间复杂度为$O(n^2)$,会TLE。

我们可以使用末尾法来进行统计能被$2^n$或$5^n$整除的子串个数。

代码：
```java
String str = cin.nextLine();

public void solve() {
  Long res = 0l;
  char[] charArray = str.toCharArray();
  for (int i = 0; i < charArray.length; i++) {
    if (Integer.valueOf(charArray[i]) % 4 == 0) {
      res++;
    }
    if (i != 0 && Integer.valueOf(charArray[i - 1] + "" + charArray[i]) % 4 == 0) {
      res += i;
    }
  }
  System.out.println(res);
}
```

## 最大公因数(约数)
想要搞懂什么是最大公因数，就要先搞懂什么是`因数`、`整除`
- 整除：`a|b`（“|”是整除符号），读作“a整除b, 或者b能被a整除”, 表示`b%a == 0`。例如10能被2整除；2整除10
- 因数: 若`a|b`，则a是b的因数。例如10的所有因数为1、2、5、10

最大公因数的性质:
- 最大公因数能够被所有公因数整除，例如：45与15的公因数为1、3、5、15，其中最大公因数为15，15能够被公因数1、3、5、15整除
- 最大因数能够被所有因数整除，例如45因数为1、3、5、9、15、45，其中最大公因数为45，45能够被所有因数1、3、5、9、15、45整除

### 模版
```java
/**
 * 求最大公因数(greatest common divisor)
 */
int gcd(int a, int b) {
  // 辗转相除
  return b ==0 ? a : gcd(b, a % b);
}
```

### 求数字数组的最大公约数
- 0除以任何一个数都得0, 所以0与一个数的最大公约数是这个数本身。
- 注意0和0没有最大公约数
```java
int[] nums = {9, 6, 9, 3, 15};
int d = 0;
for (int num : nums) {
  d = gcd(d, num);
}
```

##### 例题1: 使数组可以被整除的最少删除次数
[使数组可以被整除的最少删除次数](https://leetcode.cn/problems/minimum-deletions-to-make-array-divisible/)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220721113106.png)

<div class="container">
  <iframe width="560" height="315" src="https://www.youtube.com/embed/yv39FuCv0uk" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>

代码：
```java
class Solution {
     public int minOperations(int[] nums, int[] numsDivide) {
      int b = 0;
      for (int num : numsDivide) {
        b = gcd(b, num);
      }
      Arrays.sort(nums);
      int res = 0;
      for (int num : nums) {
        if (b % num != 0) {
          res++;
        } else {
          break;
        }
      }
      return res == nums.length ? -1 : res;
    }

    /**
     * 求最大公因数(greatest common divisor)
     */
    int gcd(int a, int b) {
      // 辗转相除
      return b == 0 ? a : gcd(b, a % b);
    }
}
```

## 位运算
### 消除二进制表示中的最后一个1
`n&(n-1)`这个操作是算法中常见的，作用是消除数字 n 的二进制表示中的最后一个1。
看个图就很容易理解了：

![](https://raw.githubusercontent.com/NaisWang/images/master/20220408162504.png)

其核心逻辑就是，`n-1` 一定可以消除最后一个 1，同时把其后的 0 都变成 1，这样再和 n 做一次 & 运算，就可以仅仅把最后一个 1 变成 0 了。

#### 例题1: 位1的个数
[位1的个数](https://leetcode.cn/problems/number-of-1-bits/)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220718164245.png)

代码：
```java
public class Solution {
  // you need to treat n as an unsigned value
  public int hammingWeight(int n) {
    int res = 0;
    while (n != 0) {
      n = n & (n - 1);
      res++;
    }
    return res;
  }
}
```

### 只保留二进制中的最后一个1
使用`n & (-n)`就能只保留n的二进制中的最后一个1。这个技巧在树状数组中使用了

例如20的二进制表示为`10100`, `20 & (-20)`的值为4，4的二进制表示为`100`

### 判断一个数是不是2的指数

![](https://raw.githubusercontent.com/NaisWang/images/master/20220718165023.png)

一个数如果是 2 的指数，那么它的二进制表示一定只含有一个 1：
```
2^0 = 1 = 0b0001
2^1 = 2 = 0b0010
2^2 = 4 = 0b0100
```
如果使用 n&(n-1) 的技巧就很简单了（注意运算符优先级，括号不可以省略）：
```java
public boolean isPowerOfTwo(int n) {
  return n > 0 && (n & (n - 1)) == 0;
} 
```

### 查找只出现一次的元素

![](https://raw.githubusercontent.com/NaisWang/images/master/20220718165319.png)

这里就可以运用异或运算的性质：一个数和它本身做异或运算结果为 0，即`a ^ a = 0`；一个数和 0 做异或运算的结果为它本身，即`a ^ 0 = a`。

对于这道题目，我们只要把所有数字进行异或，成对儿的数字就会变成 0，落单的数字和 0 做异或还是它本身，所以最后异或的结果就是只出现一次的元素：

```java
class Solution {
    public int singleNumber(int[] nums) {
        int res = nums[0];
        for (int i = 1; i < nums.length; i++) res ^= nums[i];
        return res;
    }
}
```

### 例题1:操作后的最大异或和
[操作后的最大异或和](https://leetcode.cn/problems/maximum-xor-after-operations/)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220718183103.png)

#### 分析
<div class="container">
  <iframe width="560" height="315" src="https://www.youtube.com/embed/rwZ7a21Ygy4" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>

代码：
```java
class Solution {
  public int maximumXOR(int[] nums) {
    int res = 0;
    for (int num : nums) {
      res |= num;
    }
    return res;
  }
}
```

## 快速幂
快速幂，二进制取幂（Binary Exponentiation，也称平方法），是一个在$O(logn)$的时间内计算$a^n$的小技巧，而暴力的计算需要$O(n)$的时间。而这个技巧也常常用在非计算的场景，因为它可以应用在任何具有结合律的运算中。其中显然的是它可以应用于模意义下取幂、矩阵幂等运算，我们接下来会讨论。

![](https://raw.githubusercontent.com/NaisWang/images/master/20220408162524.png)

### 模板
$求a^n$
递归版
```java
public long binpow(long a, long n){
  if(n == 0) return 1;
  long res = binpow(a, n/2);
  if(n%2 == 1) 
    return res*res*a;
  else
    return res*res;
}
```
非递归版
```java
public static long binpow(long a, long n){
  long res = 1;
  while(n > 0){
    if((n & 1) == 1) res = res * a; 
    a = a * a;
    n >>= 1;
  }
  return res;
}
```

**题目链接**
[a^b](https://www.acwing.com/problem/content/submission/91/)

## 64位整数乘法 
求`(a*b)%p`，

如果直接计算a乘b这会超过long的最大范围，所以采用类似于快速幂的思想把 b写成二进制形式，然后如果某位上为1就加上它`a*（2^n）`次方（n与这位的位置有关）并且每次计算后取模就可以了

例如：计算`3*7`， 由于7的二进制为111, 所以`$3*7 = 3*(2^0)+3*(2^1)+3*(2^2)$`

### 模板
求`(a*b)%p`

```java
public static long ksc(long a, long b, long p){
  long res = 0;
  while(b > 0){
    if((b&1) == 1) res = (res+a)%p;
    b >>= 1;
    a = 2*a%p;
  }
  return res;
}
```


# 区间信息维护与查询

## Heap和BST的应用

<div class="container">
  <iframe src="https://drive.google.com/file/d/15qVlx2wnt89JZWzfGKQ3P43IbK4UNJF1/preview" width="640" height="480" allow="autoplay"></iframe>
</div>

<div class="container">
  <iframe width="560" height="315" src="https://www.youtube.com/embed/zxPdekOBfTo" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>

<div class="container">
  <iframe width="560" height="315" src="https://www.youtube.com/embed/MocAQVJfJOQ" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>

- 如果只需要找最值，就用`二分堆(PrioityQueue)`。
- 如果我不止需要找到最值，还要进行搜索、删除指定元素、`lower_bound`或`upper_bound`操作，就用`二叉搜索树(TreeSet/TreeMap)`。

### TreeSet vs PrioityQueue
**PrioityQueue:**
- O(n): remove(Object o), contains(Object o)
- O(logN): add(E e), offer(E e), poll()
- O(1): peek()

**TreeSet:**
- O(logN): add(), ceiling(), contains(), floor(), headSet(), higher(), lower(), remove(), subSet(), tailSet() 
- O(1): comparator(), iterator(), clear(), first(), isEMpty(), size(), last(), pollFirst(), pollLast()

**通过上述我们可以发现PrioityQueue的remove的时间复杂度高于TreeSet。**所以我们使用PriorityQueue时，如果要进行大量的remove操作，我们需要考虑是否能够将PrioirtyQueue替换成TreeSet。例如下面的例题`设计数字容器系统`中，就需要将PriorityQueue替换成TreeSet才不会超时

#### 例题1: 设计数字容器系统
[设计数字容器系统](https://leetcode.cn/problems/design-a-number-container-system/)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220726101857.png)

使用PrioityQueue，代码如下：
```java
class NumberContainers {

  Map<Integer, Integer> IndexToNumber = new HashMap<>();
  Map<Integer, PriorityQueue<Integer>> numberToIndex = new HashMap<>();
  public NumberContainers() {

  }

  public void change(int index, int number) {
    Integer preNum = IndexToNumber.get(index);
    IndexToNumber.put(index, number);
    if (preNum != null) {
      numberToIndex.get(preNum).remove(index);
    }
    numberToIndex.computeIfAbsent(number, p -> new PriorityQueue<>()).add(index);
  }

  public int find(int number) {
    PriorityQueue<Integer> integers = numberToIndex.get(number);
    if (integers == null || integers.size() == 0) return -1;
    return integers.peek();
  }
}
```
上述代码会超时，那是因为PriorityQueue进行remove操作的时间复杂度度为O(n)，而我们需要大量进行Remove操作，所以我们需要换成一个remove操作的时间复杂度低的数据结构TreeSet。TreeSet的remove操作的时间复杂度为O(logN)。代码如下：

```java
class NumberContainers {

  Map<Integer, Integer> IndexToNumber = new HashMap<>();
  Map<Integer, TreeSet<Integer>> numberToIndex = new HashMap<>();
  public NumberContainers() {

  }

  public void change(int index, int number) {
    Integer preNum = IndexToNumber.get(index);
    IndexToNumber.put(index, number);
    if (preNum != null) {
      numberToIndex.get(preNum).remove(index);
    }
    numberToIndex.computeIfAbsent(number, p -> new TreeSet<>()).add(index);
  }

  public int find(int number) {
    TreeSet<Integer> integers = numberToIndex.get(number);
    if (integers == null || integers.size() == 0) return -1;
    return integers.first();
  }
}
```
换成TreeSet后，没有出现超时的情况，提交成功

### 动态排行问题 (Heap和BST的应用)
#### K是固定值时
##### 实现方式一: 大根堆加小根堆
维护一个最大(映射)堆A和一个最小(映射)堆B，A里面维护当前数据集合的前K大的元素，B里面维护其他的元素，那么A的根就是当前集合里的第k大元素。

此算法的复杂度为O(nlogk);

##### 模版
```java
class FindKthByHeap {
  private int[] nums;
  // 所要找的第几大的元素
  int k;

  /**
   * 创建大根堆与小根堆。
   * 堆存储堆是元素的id。即nums的下标
   */
  Comparator<Integer> comparator = (a, b) -> nums[a] != nums[b] ? Integer.compare(nums[a], nums[b]) : a - b;
  TreeSet<Integer> maxHeap = new TreeSet<>(comparator.reversed());
  TreeSet<Integer> minHeap = new TreeSet<>(comparator);

  public FindKthByHeap(int[] nums, int k) {
    this.nums = nums;
    this.k = k;
  }

  /**
   * 往堆中添加元素
   */
  public void add(int itemId) {
    minHeap.add(itemId);
    maxHeap.add(minHeap.pollFirst());
    balance();
  }

  /**
   * 通过给定的元素id删除堆中对应的元素
   *
   * @param itemId 元素的id
   */
  public void remove(int itemId) {
    if (!maxHeap.remove(itemId)) {
      minHeap.remove(itemId);
    }
  }

  /**
   * @return 第k大元素的id
   */
  public int getKthItemId() {
    return maxHeap.first();
  }

  /**
   * @return 第k大元素
   */
  public int getKthItem() {
    return nums[maxHeap.first()];
  }


  /**
   * @return 第k+1大元素的id
   */
  public int getK1thItemId() {
    return minHeap.first();
  }

  /**
   * @return 第k+1大元素
   */
  public int getK1thItem() {
    return nums[minHeap.first()];
  }

  /**
   * 维持大根堆元素个数小于等于k
   */
  private void balance() {
    while (maxHeap.size() > k) {
      minHeap.add(maxHeap.pollFirst());
    }
  }

  }
```
注意的比较器不能写成下面形式： 
```java
Comparator<Integer> comparator = (a, b) -> Integer.compare(nums[a], nums[b]);
```
之所以不写成上述形式的原因是因为TreeSet存的是元素的id。如果a与b分别是2个不同的元素的id的话，那么a与b是不会相同的。 但是按照上述比较器的话，a与b是会相同的。例如当a=1, b=2,且num[1]等于num[2]时，如果按照上述比较器的话，`Integer.compare(nums[a], nums[b])`返回0，表示a等于b，由于TreeSet中是无重复元素的, 所以TreeSet中不会同时出现a与b。而这显然与需求不符合。所以比较器应该写成如下形式： 
```java
Comparator<Integer> comparator = (a, b) -> nums[a] != nums[b] ? Integer.compare(nums[a], nums[b]) : a - b;
```

###### 例题1: 滑动窗口中位数
[滑动窗口中位数](https://leetcode.cn/problems/sliding-window-median/)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220603194139.png)

代码：
```java
class Solution {
  public double[] medianSlidingWindow(int[] nums, int k) {
    FindKthByHeap findKthByHeap = new FindKthByHeap(nums, (int)Math.ceil(k / 2.0));
    double[] res = new double[nums.length - k + 1];
    for (int i = 0; i < k; i++) {
      findKthByHeap.add(i);
    }
    if (k % 2 == 0) {
      res[0] = ((double) findKthByHeap.getKthItem() + findKthByHeap.getK1thItem()) / 2.0;
    } else {
      res[0] = (double) findKthByHeap.getKthItem();
    }
    
    int j = 1;
    for (int i = k; i < nums.length; i++) {
      findKthByHeap.remove(i - k);
      findKthByHeap.add(i);
      if (k % 2 == 0) {
        res[j++] = ((double) findKthByHeap.getKthItem() + findKthByHeap.getK1thItem()) / 2.0;
      } else {
        res[j++] = (double) findKthByHeap.getKthItem();
      }
    }
    return res;
  }


  class FindKthByHeap {
    private int[] nums;
    // 所要找的第几大的元素
    int k;

    /**
      * 创建大根堆与小根堆。
      * 堆存储堆是元素的id。即nums的下标
      */
    Comparator<Integer> comparator = (a, b) -> nums[a] != nums[b] ? Integer.compare(nums[a], nums[b]) : a - b;
    TreeSet<Integer> maxHeap = new TreeSet<>(comparator.reversed());
    TreeSet<Integer> minHeap = new TreeSet<>(comparator);

    public FindKthByHeap(int[] nums, int k) {
      this.nums = nums;
      this.k = k;
    }

    public void add(int itemId) {
      minHeap.add(itemId);
      maxHeap.add(minHeap.pollFirst());
      balance();
    }

    /**
      * @return 第k大元素的id
      */
    public int getKthItemId() {
      return maxHeap.first();
    }

    /**
      * @return 第k大元素
      */
    public int getKthItem() {
      return nums[maxHeap.first()];
    }


    /**
      * @return 第k+1大元素的id
      */
    public int getK1thItemId() {
      return minHeap.first();
    }

    /**
      * @return 第k+1大元素
      */
    public int getK1thItem() {
      return nums[minHeap.first()];
    }

    /**
      * 通过给定的元素id删除堆中对应的元素
      *
      * @param itemId 元素的id
      */
    public void remove(int itemId) {
      if (!maxHeap.remove(itemId)) {
        minHeap.remove(itemId);
      }
    }

    /**
      * 维持大根堆元素个数小于等于k
      */
    private void balance() {
      while (maxHeap.size() > k) {
        minHeap.add(maxHeap.pollFirst());
      }
    }

  }

} 
```

###### 例题2: 找出数组中的第 K 大整数
[找出数组中的第 K 大整数](https://leetcode.cn/problems/find-the-kth-largest-integer-in-the-array/)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220603231915.png)

注意：这里的第K大正数的定义有点不同

```java
class Solution {
  public String kthLargestNumber(String[] nums, int k) {
    FindKthByHead findKthByHead = new FindKthByHead(k, nums);
    for (int i = 0; i < nums.length; i++) {
      findKthByHead.add(i);
    }
    return findKthByHead.getKthItem();
  }

  class FindKthByHead {
    String[] nums;
    int k; 

    Comparator<Integer> comparator = (a, b) -> {

      // 注意：nums[a]等于nums[b]时不能返回0
      if (nums[a].equals(nums[b])) {
        return a - b;
      }

      if (nums[a].length() < nums[b].length()) {
        return -1;
      }
      if (nums[a].length() > nums[b].length()) {
        return 1;
      }
      return nums[a].compareTo(nums[b]);
    };
    TreeSet<Integer> maxHeap = new TreeSet<>(comparator.reversed());
    TreeSet<Integer> minHeap = new TreeSet<>(comparator); 

    public FindKthByHead(int k, String[] nums) {
      this.k = k;
      this.nums = nums;
    } 

    public void add(int itemId) {
      maxHeap.add(itemId);
      minHeap.add(maxHeap.pollFirst());
      balance();
    }
    
    public String getKthItem() {
      return nums[minHeap.first()];
    }

    private void balance() {
      while (minHeap.size() > k) {
        maxHeap.add(minHeap.pollFirst());
      }
    }
  }
}
```

## 区间和

### 静态数据区间和

#### 前缀和
前缀和的思路是这样的，对于一个给定的数组 nums，我们额外开辟一个前缀和数组进行预处理：
```java
int n = nums.length;
// 前缀和数组
int[] preSum = new int[n];
for (int i = 0; i < n; i++) {
  preSum[i] = i == 0 ? nums[i] : preSum[i - 1] + nums[i];
}
```

##### 例题1: 转角路径的乘积中最多能有几个尾随零
[转角路径的乘积中最多能有几个尾随零](https://leetcode.cn/problems/maximum-trailing-zeros-in-a-cornered-path/)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220609164612.png)

###### 分析
因子分解：尾数0的个数由乘积因子中10的个数所决定，而10又由`2*5`组成。
- 两个2和两个5可组成两个10：`2 * 5 * 2 * 5 = 100`
- 三个2和两个5可组成两个10：`2 * 5 * 2 * 5 * 2 = 200`

可发现，对于一个整数num而言，其质因子中2和5的数目的较小值即为尾数0的数目。

因此，一条路径的乘积中尾数0的个数，即为该条路径中各个乘数所包含的因子2的个数和与因子5的个数和的较小者。

因此先用前缀和维护每一行和每一列因子2与因子5的数量，再枚举拐点计算答案即可。

代码：
```java
class Solution {
  
    static int[][] c25 = new int[1001][2];
    static {
        // 预处理：递推算出每个数的因子 2 的个数和因子 5 的个数
        for (int i = 2; i <= 1000; i++) {
            if (i % 2 == 0) c25[i][0] = c25[i / 2][0] + 1;
            if (i % 5 == 0) c25[i][1] = c25[i / 5][1] + 1;
        }
    }

    public int maxTrailingZeros(int[][] grid) {
      // 不同行的前缀和
      // rowPreSum[i][j][0]的第i行中前j列中能被2整除的个数
      // rowPreSum[i][j][1]的第i行中前j列中能被5整除的个数
      int[][][] rowPreSum = new int[grid.length][grid[0].length][2];
      // 不同列的前缀和
      // colPreSum[i][j][0]的第i列中前j行中能被2整除的个数
      // colPreSum[i][j][1]的第i列中前j行中能被5整除的个数
      int[][][] colPreSum = new int[grid[0].length][grid.length][2];
      
      for (int r = 0; r < grid.length; r++) {
        rowPreSum[r][0][0] = c25[grid[r][0]][0];
        rowPreSum[r][0][1] = c25[grid[r][0]][1];
        for (int c = 1; c < grid[0].length; c++) {
          rowPreSum[r][c][0] = rowPreSum[r][c - 1][0] + c25[grid[r][c]][0];
          rowPreSum[r][c][1] = rowPreSum[r][c - 1][1] + c25[grid[r][c]][1];
        }
      }
      
      for (int c = 0; c < grid[0].length; c++) {
        colPreSum[c][0][0] = c25[grid[0][c]][0];
        colPreSum[c][0][1] = c25[grid[0][c]][1];
        for (int r = 1; r < grid.length; r++) {
          colPreSum[c][r][0] = colPreSum[c][r - 1][0] + c25[grid[r][c]][0];
          colPreSum[c][r][1] = colPreSum[c][r - 1][1] + c25[grid[r][c]][1];
        }
      }
      
      int res = Integer.MIN_VALUE;
      for (int r = 0; r < grid.length; r++) {
        for (int c = 0; c < grid[0].length; c++) {
          
          int tempRowLeftFor2 = rowPreSum[r][c][0];
          int tempRowRightFor2 = rowPreSum[r][grid[0].length -1][0] - rowPreSum[r][c][0] + c25[grid[r][c]][0];
          int tempColUpFor2 = colPreSum[c][r][0];
          int tempColDownFor2 = colPreSum[c][grid.length - 1][0] - colPreSum[c][r][0] + c25[grid[r][c]][0];
          
          int tempRowLeftFor5 = rowPreSum[r][c][1];
          int tempRowRightFor5 = rowPreSum[r][grid[0].length -1][1] - rowPreSum[r][c][1] + c25[grid[r][c]][1];
          int tempColUpFor5 = colPreSum[c][r][1];
          int tempColDownFor5 = colPreSum[c][grid.length - 1][1] - colPreSum[c][r][1] + c25[grid[r][c]][1];
          
          int leftUpFor2 = tempRowLeftFor2 + tempColUpFor2 - c25[grid[r][c]][0];
          int leftUpFor5 = tempRowLeftFor5 + tempColUpFor5 - c25[grid[r][c]][1];
          int leftUp = Math.min(leftUpFor2, leftUpFor5);
          
          res = Math.max(res, leftUp);
          
          int leftDownFor2 = tempRowLeftFor2 + tempColDownFor2 - c25[grid[r][c]][0];
          int leftDownFor5 = tempRowLeftFor5 + tempColDownFor5 - c25[grid[r][c]][1];
          int leftDown = Math.min(leftDownFor2, leftDownFor5);
          res = Math.max(res, leftDown);
          
          int rightUpFor2 = tempRowRightFor2 + tempColUpFor2 - c25[grid[r][c]][0];
          int rightUpFor5 = tempRowRightFor5 + tempColUpFor5 -c25[grid[r][c]][1]; 
          int rightUp = Math.min(rightUpFor2, rightUpFor5);
          res = Math.max(res, rightUp);
          
          int rightDownFor2 = tempRowRightFor2 + tempColDownFor2 - c25[grid[r][c]][0];
          int rightDownFor5 = tempRowRightFor5 + tempColDownFor5 - c25[grid[r][c]][1];
          int rightDown = Math.min(rightDownFor2, rightDownFor5);
          res = Math.max(res, rightDown);
           
        }
      }
      return res;  
    }

}
```

##### 例题2：选择建筑的方案数
[选择建筑的方案数](https://leetcode.cn/problems/number-of-ways-to-select-buildings/)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220611112135.png)

###### 分析
参考：https://leetcode.cn/problems/number-of-ways-to-select-buildings/solution/by-baoya_uncle-qsr8/

对任意一个位置，以它为中心构建合法相邻建筑的数量，分两种情况讨论：
- 该位置左侧1的数量`*`该位置右侧1的数量 （若该位置为0 ）。这样可以构成101。
- 该位置左侧0的数量`*`该位置右侧0的数量 （若该位置为1 ）。这样可以构成010。
两种情况分别举个例子：

例子一：
![](https://raw.githubusercontent.com/NaisWang/images/master/20220611112325.png)

例子二：
![](https://raw.githubusercontent.com/NaisWang/images/master/20220611112338.png)

算法部分，
1. 从左往右遍历一次，统计每个位置左侧0或者1的数量。 统计0还是1取决于该位置是1还是0。
2. 再从右往左遍历一次，统计每个位置右侧侧0或者1的数量 。
3. 同一位置，左侧0或1侧数量，和右侧0或1侧数量相乘，即为以该位置贡献的答案数量，对每个位置的贡献量求和，即为返回答案。

代码：
```java
class Solution {
  public long numberOfWays(String s) {
    char[] charArray = s.toCharArray();
    int n = charArray.length;
    long[] preSumFor1 = new long[n];
    long[] preSumFor0 = new long[n];
    preSumFor1[0] = (charArray[0] == '1') ? 1 : 0;
    preSumFor0[0] = (charArray[0] == '0') ? 1 : 0;
    for (int i = 1; i < n; i++) {
      if (charArray[i] == '1') {
        preSumFor1[i] = preSumFor1[i - 1] + 1;
        preSumFor0[i] = preSumFor0[i - 1];
      } else {
        preSumFor0[i] = preSumFor0[i - 1] + 1;
        preSumFor1[i] = preSumFor1[i - 1];
      }
    }
    long res = 0;
    for (int i = 1; i < n - 1; i++) {
      if (charArray[i] == '0') {
        res += preSumFor1[i - 1] * (preSumFor1[n - 1] - preSumFor1[i]);
      } else {
        res += preSumFor0[i - 1] * (preSumFor0[n - 1] - preSumFor0[i]);
      }
    }
    return res;
  }
}
```

##### 例题3: 字符串中最多数目的子字符串
[字符串中最多数目的子字符串](https://leetcode.cn/problems/maximize-number-of-subsequences-in-a-string/)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220611120412.png)

###### 分析
最优的情况下，肯定是 pattern[0] 插入到 text 开头或 pattern[1] 插入到 text 结尾。分别统计一下哪个子序列最多。

使用前缀和来统计text中pattern[0]出现的次数

代码： 
```java
class Solution {
  public long maximumSubsequenceCount(String text, String pattern) {
    
    String textTemp = pattern.charAt(0) + text;
    char[] charArray = textTemp.toCharArray();
    int[] preSum1 = new int[textTemp.length()];
    preSum1[0] = 1;
    for (int i = 1; i < charArray.length; i++) {
      preSum1[i] = preSum1[i - 1] + (charArray[i] == charArray[0] ? 1 : 0);
    }
    long res = 0;
    for (int i = 1; i < charArray.length; i++) {
      if (charArray[i] == pattern.charAt(1)) {
        res += preSum1[i - 1];
      }
    }

    String textTemp1 = text + pattern.charAt(1);
    char[] charArray1 = textTemp1.toCharArray();
    int[] preSum2 = new int[textTemp1.length()];
    preSum2[0] = (charArray1[0] == pattern.charAt(0)) ? 1 : 0;
    for (int i = 1; i < charArray1.length; i++) {
      preSum2[i] = preSum2[i - 1] + (charArray1[i] == pattern.charAt(0) ? 1 : 0);
    }
    long res2 = 0;
    for (int i = 1; i < charArray1.length; i++) {
      if (charArray1[i] == pattern.charAt(1)) {
        res2 += preSum2[i - 1];
      }
    }
    return Math.max(res, res2);
  }
}
```

##### 例题4: 和为 K 的子数组
[和为 K 的子数组](https://leetcode.cn/problems/subarray-sum-equals-k/description/)

![](https://raw.githubusercontent.com/NaisWang/images/master/20230209153410.png)

代码：
```java
class Solution {
  public int subarraySum(int[] nums, int k) {
    Map<Integer, Integer> preSumMap = new HashMap();
    preSumMap.put(0, 1);
    int res = 0;
    int[] preSum = new int[nums.length];
    for (int i = 0; i < nums.length; i++) {
      preSum[i] = i == 0 ? nums[0] : preSum[i - 1] + nums[i];
      res += preSumMap.getOrDefault(preSum[i] - k, 0);
      preSumMap.put(preSum[i], preSumMap.getOrDefault(preSum[i], 0) + 1);
    }
    return res;
  }
}
```

### 动态数据区间和
#### 树状数组

<div class="container">
  <iframe src="https://drive.google.com/file/d/1M7R5H2gUKRU9D_290V7CJJfQ-zbvc8ZO/preview" width="640" height="480" allow="autoplay"></iframe>
</div>

**数组树状不能用来求区间最值问题，求区间最值问题用线段树或ST表**

##### 模版
```java
class BIT {
  int[] a, c;

  public BIT(int[] nums) {
    int n = nums.length;
    a = new int[n];
    c = new int[n + 1];
    for (int i = 0; i < n; i++) update(i, nums[i]);
  }

  // 更新a[i]为val
  public void update(int i, int val) {
    int diff = val - a[i];
    a[i] = val;
    for (i++; i < c.length; i += (i & -i)) {
      c[i] += diff;
    }
  }

  // 求a[0...i]之和
  public int preSum(int i) {
    int sum = 0;
    for (i++; i > 0; i -= (i & -i)) sum += c[i];
    return sum;
  }
}
```
注意：update以及preSum方法中的for循环中必须要写`i++`的原因是c数组下标必须要是1开始的。上述模版中a数组与c数组的关系如下

![](https://raw.githubusercontent.com/NaisWang/images/master/Screen%20Shot%202022-07-21%20at%2021.08.18.jpg)


#### 线段树

<div class="container">
  <iframe width="560" height="315" src="https://www.youtube.com/embed/p2ofSLrK9HM" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>

<div class="container">
  <iframe src="https://drive.google.com/file/d/1mA9vfd8xsiVjDFoYk_Il6Jm3Z9Y-XORD/preview" width="640" height="480" allow="autoplay"></iframe>
</div>

##### zkw线段树
###### 模版
模版：
```java
class SegmentTree {
  int n;
  int[] st;

  public SegmentTree(int[] nums) {
    n = nums.length;
    st = new int[2 * n];
    for (int i = n; i < n * 2; i++) st[i] = nums[i - n];
    for (int i = n - 1; i > 0; i--) st[i] = st[2 * i] + st[2 * i + 1];
  }

  // 将nums[i]更新为val
  void update(int i, int val) {
    int diff = val - st[i + n];
    for (i += n; i > 0; i /= 2) st[i] += diff;
  }

  // 求nums[i..j]之和
  int sumRange(int i, int j) {
    int res = 0;
    for (i += n, j += n; i <= j; i /= 2, j /= 2) {
      // s[i]是右子节点
      if (i % 2 == 1) res += st[i++];
      // s[j]是左子节点
      if (j % 2 == 0) res += st[j--];
    }
    return res;
  }
}
```

**示例1:**以nums=[4, 6, 7, 3]为例。

1. `new SegmentTree(nums)`后，st内容如下：

![](https://raw.githubusercontent.com/NaisWang/images/master/20220721145844.png)

我们可以发现所有叶子节点存储的是nums中的元素

2. 调用`update(2, 5)`时，具体操作如下：

![](https://raw.githubusercontent.com/NaisWang/images/master/20220721150329.png)

3. 调用`sumRange(1, 3)`时，具体操作如下：

![](https://raw.githubusercontent.com/NaisWang/images/master/20220721150813.png)

**示例2:** 以nums=[2, 4, 1, 5, 8]为例。

1. `new SegmentTree(nums)`后，st内容如下：

![](https://raw.githubusercontent.com/NaisWang/images/master/20220721151700.png)

2. 调用`update(2, 5)`时，具体操作如下：

![](https://raw.githubusercontent.com/NaisWang/images/master/20220721151840.png)

3. 调用`sumRange(1, 3)`时，具体操作如下：

![](https://raw.githubusercontent.com/NaisWang/images/master/20220721152311.png)

##### 基于tree的线段树
###### 模版
```java
class Node {
  int start, end, sum;
  Node left, right;

  Node(int start, int end) {
    this.start = start;
    this.end = end;
  }
}

class SegmentTree {
  int[] nums;
  Node root;

  public SegmentTree(int[] nums) {
    this.nums = nums;
    this.root = buildTree(nums, 0, nums.length - 1);
  }

  private Node buildTree(int[] nums, int start, int end) {
    if (start > end) return null;
    Node node = new Node(start, end);
    if (start == end) {
      node.sum = nums[start];
    } else {
      int mid = start + (end - start) / 2;
      node.left = buildTree(nums, start, mid);
      node.right = buildTree(nums, mid + 1, end);
      node.sum = node.left.sum + node.right.sum;
    }
    return node;
  }

  // 更新nums[i]为val
  public void update(Node node, int i, int val) {
    if (node.start == node.end) {
      node.sum = val;
      return;
    }
    int mid = node.start + (node.end - node.start) / 2;
    if (i <= mid) update(node.left, i, val);
    else if (i > mid) update(node.right, i, val);
    node.sum = node.left.sum + node.right.sum;
  }

  // 求nums[start...end]之和
  public int sumRange(Node node, int start, int end) {
    if (start > end) return 0;
    if (node.start == start && node.end == end) return node.sum;
    int mid = node.start + (node.end - node.start) / 2;
    if (end <= mid) return sumRange(node.left, start, end);
    else if (start > mid) return sumRange(node.right, start, end);
    else return sumRange(node.left, start, mid) + sumRange(node.right, mid + 1, end);
  }

}
```

#### 例题1: 计算右侧小于当前元素的个数
[计算右侧小于当前元素的个数](https://leetcode.cn/problems/count-of-smaller-numbers-after-self/)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220722093645.png)

##### 分析

参考链接：https://leetcode.cn/problems/count-of-smaller-numbers-after-self/solution/ji-suan-you-ce-xiao-yu-dang-qian-yuan-su-de-ge-s-7/

记题目给定的序列为a，我们规定 $a_i$的取值集合为a的「值域」。我们用桶来表示值域中的每一个数，桶中记录这些数字出现的次数。假设a={5,5,2,3,6}，那么遍历这个序列得到的桶是这样的：
```txt
index  ->  1 2 3 4 5 6 7 8 9
value  ->  0 1 1 0 2 1 0 0 0
```

转化为动态维护前缀和问题: 记 value 序列为 v，我们可以看出它第i−1 位的前缀和表示「有多少个数比 i 小」。那么我们可以从后往前遍历序列 a，记当前遍历到的元素为 $a_i$，我们把 $a_i$对应的桶的值自增1，记 $a_i$ = p，把 v 序列p−1位置的前缀和加入到答案中算贡献。为什么这么做是对的呢，因为我们在循环的过程中，我们把原序列分成了两部分，后半部部分已经遍历过（已入桶），前半部分是待遍历的（未入桶），那么我们求到的p−1 位置的前缀和就是「已入桶」的元素中比p小的元素的个数总和。这种动态维护前缀和的问题我们可以用「树状数组」来解决。

代码：
```java
class Solution {
  public List<Integer> countSmaller(int[] nums) {
    BIT bit = new BIT(20001);
    List<Integer> res = new ArrayList();
    for (int i = nums.length - 1; i >= 0; i--) {
      int temp = nums[i] + 10000;
      bit.update(temp, bit.a[temp] + 1);
      res.add(bit.preSum(temp - 1));
    }
    Collections.reverse(res);
    return res;
  }
}

class BIT {
  int[] a, c;
  
  public BIT(int n) {
    a = new int[n];
    c = new int[n + 1];
  }

  public void update(int i, int val) {
    int diff = val - a[i];
    a[i] = val;
    for (i++; i < c.length; i += (i & -i)) c[i] += diff;
  }

  public int preSum(int i) {
    int sum = 0;
    for (i++; i > 0; i-= (i & -i)) sum += c[i];
    return sum;
  }

}
```

#### 例题2: 通过指令创建有序数组
[通过指令创建有序数组](https://leetcode.cn/problems/create-sorted-array-through-instructions/)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220722100901.png)

这题与例题`计算右侧小于当前元素的个数`的思考方式一样

代码：
```java
class Solution {
  public int createSortedArray(int[] instructions) {
    BIT bit = new BIT(100001);
    int res = 0;
    for (int i = 0; i < instructions.length; i++) {
      res = (res + Math.min(bit.preSum(instructions[i] - 1), bit.preSum(100000) - bit.preSum(instructions[i])) % (int)(1e9+7)) % (int)(1e9+7);
      bit.update(instructions[i], bit.a[instructions[i]] + 1); 
    }
    return res;
  }
}

class BIT {
  int[] a, c;
  
  public BIT(int n) {
    a = new int[n];
    c = new int[n + 1];
  }

  public void update(int i, int val) {
    int diff = val - a[i];
    a[i] = val;
    for (i++; i < c.length; i += (i & -i)) c[i] += diff;
  }

  public int preSum(int i) {
    int sum = 0;
    for (i++; i > 0; i -= (i & -i)) sum += c[i];
    return sum;
  }

}
```

#### 例题3: 数字流的秩
[数字流的秩](https://leetcode.cn/problems/rank-from-stream-lcci/)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220722111819.png)

代码：
```java
class StreamRank {

  BIT bit;
  public StreamRank() {
    bit = new BIT(50001);
  }
  
  public void track(int x) {
    bit.update(x, 1);
  }
  
  public int getRankOfNumber(int x) {
    return bit.preSum(x);
  }
}

class BIT {
  int[] a, c;

  public BIT(int n) {
    a = new int[n];
    c = new int[n + 1];
  }

  public void update(int i, int val) {
    int diff = val - a[i];
    a[i] = val;
    for (i++; i < c.length; i += (i & -i)) c[i] += val;
  }
  
  public int preSum(int i) {
    int sum = 0;
    for (i++; i > 0; i -= (i & -i)) sum += c[i];
    return sum;
  }
}
```


## RMQ
### 倍增、ST表

<div class="container">
  <iframe src="https://drive.google.com/file/d/1JCC9ncNlTOYHGz0hnxigX5btGzXpRz1-/preview" width="640" height="480" allow="autoplay"></iframe>
</div>

<div class="container">
  <iframe width="560" height="315" src="https://www.youtube.com/embed/aqQToXiQ7S4" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>

#### 一维ST表
##### 模版
```java
class ST {
  // F[i][j]: 表示[i, i+2^j-1]区间的最值
  int[][] F;

  public ST(int[] nums) {
    int n = nums.length;
    int k = (int) (Math.log(n) / Math.log(2));
    // 初始化F数组
    F = new int[n][k + 1];
    for (int i = 0; i < n; i++) {
      F[i][0] = nums[i];
    }
    for (int j = 1; j <= k; j++) {
      for (int i = 0; i < n - (1 << j) + 1; i++) {
        F[i][j] = Math.max(F[i][j - 1], F[i + (1 << (j - 1))][j - 1]);
      }
    }
  }

  // 求区间[l..r]的最值
  int query(int l, int r) {
    if (l > r) {
      // TODO
    }
    int k = (int) (Math.log(r - l + 1) / Math.log(2));
    return Math.max(F[l][k], F[r - (1 << k) + 1][k]);
  }

}
```

##### 例题1: 平衡的阵容
[平衡的阵容](http://poj.org/problem?id=3264)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220604142745.png)

```java
int N = cin.nextInt();
int Q = cin.nextInt();
int[] nums = new int[N];

public void solve() {
  read(nums);
  ST st = new ST(nums);
  while (Q-- != 0) {
    int l = cin.nextInt();
    int r = cin.nextInt();
    System.out.println(st.query(l - 1, r - 1));
  }
}

class ST {
  // F[i][j][0]: 表示[i, i+2^j-1]区间的最大值
  // F[i][j][1]: 表示[i, i+2^j-1]区间的最小值
  int[][][] F;

  public ST(int[] nums) {
    int n = nums.length;
    int k = (int) (Math.log(n) / Math.log(2));
    // 初始化F数组
    F = new int[n][k + 1][2];
    for (int i = 0; i < n; i++) {
      F[i][0] = new int[]{nums[i], nums[i]};
    }
    for (int j = 1; j <= k; j++) {
      for (int i = 0; i < n - (1 << j) + 1; i++) {
        F[i][j][0] = Math.max(F[i][j - 1][0], F[i + (1 << (j - 1))][j - 1][0]);
        F[i][j][1] = Math.min(F[i][j - 1][1], F[i + (1 << (j - 1))][j - 1][1]);
      }
    }
  }

  // 求区间[l..r]的最值
  int query(int l, int r) {
    int k = (int) (Math.log(r - l + 1) / Math.log(2));
    return Math.max(F[l][k][0], F[r - (1 << k) + 1][k][0]) - Math.min(F[l][k][1], F[r - (1 << k) + 1][k][1]);
  }

}
```

##### 例题2: 频繁值
[频繁值](http://poj.org/problem?id=3368)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220604155952.png)

###### 分析
因为是非降序的，所以可以从头遍历把每个相同的数字化为一个块，用`p[i]`表示第i个元素划分到哪个块里面，同时用`r[j]`和`l[j]`记第j个块的左右边界。同时freq数组用来记录每个块中数字个数，可以把freq数组处理成一个ST表

对于每个给定的查询区间，如果区间完全包含于某个块内，那么说明区间内所有数字相同，答案就是区间的长度。否则，该查询区间可以分为如下三个部分：
1. 最左侧`[i, r[p[i]]]`区间的一个块的部分
2. 最右侧`[l[p[j]], j]`区间的一个块的部分
3. 中间的`[r[p[i]] + 1, l[p[j]] - 1]`区间的某干个块
其中第1、2部分中重复的数字分别就是它们的区间长度。而第3部分可以通过ST表来求得。答案就是这三者取最大值

![](https://raw.githubusercontent.com/NaisWang/images/master/20220604162101.png)

代码： 
```java
public void solve() {
  while (true) {
    int n = cin.nextInt();
    if (n == 0) return;
    int q = cin.nextInt();
    int[] nums = new int[n];
    read(nums);
    int[] freq = new int[n];
    int[] p = new int[n]; // p[i]: 表示第i个元素位于哪个块
    int[] r = new int[n]; // r[i]: 表示第i块的右下标
    int[] l = new int[n]; // l[i]: 表示第i块的左下标
    int pId = 0; // 块编号
    int cnt = 0; // 当前块内的元素个数
    int nowP = nums[0]; // 当前块内的元素
    l[0] = 0;
    for (int i = 0; i < n; i++) {
      if (nums[i] != nowP) {
        r[pId] = i - 1;
        pId++;
        cnt = 0;
        nowP = nums[i];
        l[pId] = i;
      }
      cnt++;
      freq[i] = cnt;
      p[i] = pId;
    }
    r[pId] = n - 1;

    ST st = new ST(freq);

    while (q-- != 0) {
      int i = cin.nextInt();
      int j = cin.nextInt();
      i--;
      j--;

      // [i, j]在同一个块内时
      if (p[i] == p[j]) {
        System.out.println(j - i + 1);
      } else {
        // [i, j]不在同一个块内时
        int temp1 = r[p[i]] - i + 1;
        int temp2 = j - l[p[j]] + 1;
        int temp3 = st.query(r[p[i]] + 1, l[p[j]] - 1);
        System.out.println(Math.max((Math.max(temp1, temp2)), temp3));
      }

    }
  }
}

class ST {
  int F[][];

  public ST(int[] nums) {
    int n = nums.length;
    int k = (int) (Math.log(n) / Math.log(2));
    F = new int[n][k + 1];
    for (int i = 0; i < n; i++) {
      F[i][0] = nums[i];
    }
    for (int j = 1; j <= k; j++) {
      for (int i = 0; i < n - (1 << j) + 1; i++) {
        F[i][j] = Math.max(F[i][j - 1], F[i + (1 << (j - 1))][j - 1]);
      }
    }
  }

  int query(int l, int r) {
    if (l > r) {
      return 0;
    }
    int k = (int) (Math.log(r - l + 1) / Math.log(2));
    return Math.max(F[l][k], F[r - (1 << k) + 1][k]);
  }
}
```

假设当`nums=[-1, -1, 1, 1, 1, 1, 3, 10, 10, 10]`时：
- `freq = [1, 2, 1, 2, 3, 4, 1, 1, 2, 3]`
- `p    = [0, 0, 1, 1, 1, 1, 2, 3, 3, 3]`
- `l    = [0, 2, 6, 7, 0, 0, 0, 0, 0, 0]`
- `r    = [1, 5, 6, 9, 0, 0, 0, 0, 0, 0]`

#### 二维ST表
求一个块内的最值，可以把块分成多行，每行求一次RMQ即可，因此也要对每一行建一个ST表。

##### 模版
```java
class ST {
  // F[r][i][j]: 表示第r行的[i, i+2^j-1]区间的最大值
  int F[][][];

  public ST(int[][] nums) {
    int n = nums[0].length;
    int k = (int) (Math.log(n) / Math.log(2));
    int row = nums.length;
    F = new int[row][n][k + 1];
    for (int r = 0; r < row; r++) {
      for (int c = 0; c < n; c++) {
        F[r][c][0] = nums[r][c];
      }
      for (int j = 1; j <= k; j++) {
        for (int i = 0; i < n - (1 << j) + 1; i++) {
          F[r][i][j] = Math.max(F[r][i][j - 1], F[r][i + (1 << (j - 1))][j - 1]);
        }
      }
    }
  }

  /**
   * @param row    矩阵左上顶点位于的行
   * @param col    矩阵左上顶点位于的列
   * @param width  矩阵宽度（即一行元素的个数）
   * @param height 矩阵高度（即一列元素的个数）
   * @return 矩阵范围内的最值
   */
  int query(int row, int col, int width, int height) {
    int max = Integer.MIN_VALUE;
    for (int r = row; r < height + row; r++) {
      int k = (int) (Math.log(width) / Math.log(2));
      // 右边界
      int rightCol = col + width - 1;
      max = Math.max(max, Math.max(F[r][col][k], F[r][rightCol - (1 << k) + 1][k]));
    }
    return max;
  }
}
```

##### 例题1: 玉米地
[玉米地](http://poj.org/problem?id=2019)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220604181746.png)

代码：
```java
int N = cin.nextInt();
int B = cin.nextInt();
int K = cin.nextInt();
int[][] map = new int[N][N];

public void solve() {
  read(map);
  ST st = new ST(map);
  while (K-- != 0) {
    int a = cin.nextInt();
    int b = cin.nextInt();
    System.out.println(st.query(a - 1, b - 1, B, B));
  }
}

class ST {
  // F[r][i][j][0]: 表示第r行的[i, i+2^j-1]区间的最大值
  // F[r][i][j][1]: 表示第r行的[i, i+2^j-1]区间的最小值
  int F[][][][];

  public ST(int[][] nums) {
    int n = nums[0].length;
    int k = (int) (Math.log(n) / Math.log(2));
    int row = nums.length;
    F = new int[row][n][k + 1][2];
    for (int r = 0; r < row; r++) {
      for (int c = 0; c < n; c++) {
        F[r][c][0] = new int[]{nums[r][c], nums[r][c]};
      }
      for (int j = 1; j <= k; j++) {
        for (int i = 0; i < n - (1 << j) + 1; i++) {
          F[r][i][j][0] = Math.max(F[r][i][j - 1][0], F[r][i + (1 << (j - 1))][j - 1][0]);
          F[r][i][j][1] = Math.min(F[r][i][j - 1][1], F[r][i + (1 << (j - 1))][j - 1][1]);
        }
      }
    }
  }

  int query(int row, int col, int width, int height) {
    int max = Integer.MIN_VALUE;
    int min = Integer.MAX_VALUE;
    for (int r = row; r < height + row; r++) {
      int k = (int) (Math.log(width) / Math.log(2));
      // 右边界
      int rightCol = col + width - 1;
      max = Math.max(max, Math.max(F[r][col][k][0], F[r][rightCol - (1 << k) + 1][k][0]));
      min = Math.min(min, Math.min(F[r][col][k][1], F[r][rightCol - (1 << k) + 1][k][1]));
    }
    return max - min;
  }
}
```


# 双指针
## 同向双指针
同向双指针问题，例如滑动窗口、快慢指针问题等都可以套用下面模版。
```java
void slidingWindow(int[] nums) {
  // left, right表示2个指针的指向 
  // 例如在2个链表中，left表示指向第一个链表的下标；right表示执行第二个链表的下标
  int left = ..., right = ...;

  while (right < nums.length) {

    // 判断是否需要需要移动左指针
    while (left <= right && needMoveLeft(left, right)) {
      left++;
      // ... 
    }

    // 移动右指针
    right++;
  }
}
```

<font color="red">我们在做双指针问题时，只需要关心什么时候需要移动左指针，而不需要关心什么时候移动右指针。因为在停止移动左指针后，会立即开始移动右指针</font>

### 滑动窗口

<div class="container">
  <iframe width="560" height="315" src="https://www.youtube.com/embed/RWZAv-PUMs4" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>

<div class="container">
  <iframe width="560" height="315" src="https://www.youtube.com/embed/lVXO55Dcjg0" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>

参考链接：https://labuladong.gitee.io/algo/1/12/


#### 代码模版
```java
void slidingWindow(int[] nums) {
  int left = 0, right = 0;

  while (right < nums.length) {
    // TODO 根据窗口内容进行处理

    // 缩小窗口
    while (left <= right && windowNeedsShrink(left, right)) {
      // TODO 根据窗口内容发生的变化进行处理
      left++;
    }

    //增大窗口
    right++;
  }
}

// 判断左侧窗口是否要收缩
boolean windowNeedsShrink(int left, int right) {
  // TODO
  return false;
}
```

**根据代码模版可以看出，在写滑动窗口时，<font color="red">关键是分析在什么情况下需要移动左指针来收缩窗口，而不需要考虑什么时候扩大窗口，因为在停止缩小窗口后会立即扩大窗口</font>**

#### 例题1: 长度最小的子数组
[长度最小的子数组](https://leetcode.cn/problems/minimum-size-subarray-sum/)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220715164453.png)

代码：
```java
class Solution {
  public int minSubArrayLen(int target, int[] nums) {
    int left = 0, right = 0;
    int sum = 0, res = Integer.MAX_VALUE;
    while (right < nums.length) {
      sum += nums[right];
      while (left <= right && sum >= target) {
        res = Math.min(res, right - left + 1);
        sum -= nums[left];
        left++;
      }
      right++;
    }
    return res == Integer.MAX_VALUE ? 0 : res;
  }
}
```

#### 例题2: 无重复字符的最长子串
[无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220715201456.png)

代码：
```java
class Solution {
  public int lengthOfLongestSubstring(String s) {
    Set<Character> set = new HashSet();
    char[] sCh = s.toCharArray();
    int left = 0, right = 0;
    int res = 0;
    while (right < sCh.length) {
      while (left <= right && set.contains(sCh[right])) {
        set.remove(sCh[left]);
        left++;
      }
      set.add(sCh[right]);
      res = Math.max(res, set.size()); 
      right++;
    }
    return res;
  }
}
```

#### 例题3: 字符串的排列
[字符串的排列](https://leetcode.cn/problems/permutation-in-string/)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220715202755.png)

代码：
```java 
class Solution {
  public boolean checkInclusion(String s1, String s2) {
    char[] s1ChArr = s1.toCharArray(), s2ChArr = s2.toCharArray();
    int[] targetChCnt = new int[26], nowChCnt = new int[26];
    for (char ch : s1ChArr) {
      targetChCnt[ch - 'a']++;
    }
    int left = 0, right = 0;
    while (right < s2ChArr.length) {
      nowChCnt[s2ChArr[right] - 'a']++;
      while (left <= right && nowChCnt[s2ChArr[right] - 'a'] > targetChCnt[s2ChArr[right] - 'a']) {
        nowChCnt[s2ChArr[left] - 'a']--;
        left++;
      }
      if (Arrays.equals(targetChCnt, nowChCnt)) {
        return true;
      }
      right++;
    }
    return false;
  }
}
``` 

#### 例题4：找到字符串中所有字母异位词
[找到字符串中所有字母异位词](https://leetcode.cn/problems/find-all-anagrams-in-a-string/)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220715201558.png)

参考链接：https://leetcode.cn/problems/find-all-anagrams-in-a-string/solution/zhao-dao-zi-fu-chuan-zhong-suo-you-zi-mu-xzin/

代码：
```java
class Solution {
  public List<Integer> findAnagrams(String s, String p) {
    char[] sChArr = s.toCharArray(), pChArr = p.toCharArray();
    int[] targetChCnt = new int[26], nowChCnt = new int[26];
    for (char ch : pChArr) {
      targetChCnt[ch - 'a']++;
    }
    List<Integer> res = new ArrayList();
    int left = 0, right = 0;
    while (right < sChArr.length) {
      nowChCnt[sChArr[right] - 'a']++;
      while (left <= right && nowChCnt[sChArr[right] - 'a'] > targetChCnt[sChArr[right] - 'a']) {
        nowChCnt[sChArr[left] - 'a']--;
        left++;
      }
      if (Arrays.equals(nowChCnt, targetChCnt)) {
        res.add(left);
      }
      right++;
    }
    return res;
  }
}
```

#### 例题5: 最小覆盖子串
[最小覆盖子串](https://leetcode.cn/problems/minimum-window-substring/)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220719202340.png)

##### 分析
用validCnt来存储当前窗口中有几种字符达到了要求。例如t="ABC", 当窗口中字符串为"ADOB"时，validCnt等于2，因为窗口中A、B两中字符出现次数都不少于t中该对应字符出现的次数，所以窗口中达到要求的字符有A、B两种。

窗口要求：

代码：
```java
class Solution {
  public String minWindow(String s, String t) {
    char[] sChArr = s.toCharArray(), tChArr = t.toCharArray();
    Map<Character, Integer> now = new HashMap(), target = new HashMap();
    for (char ch : tChArr) {
      target.put(ch, target.getOrDefault(ch, 0) + 1);
    }
    int validCnt = 0;
    int[] res = {0, Integer.MAX_VALUE};
    int left = 0, right = 0;
    while (right < sChArr.length) {
      now.put(sChArr[right], now.getOrDefault(sChArr[right], 0) + 1);
      if (now.get(sChArr[right]).equals(target.get(sChArr[right]))) {
        validCnt++;
      }
      while (left <= right && validCnt == target.size() && !now.get(sChArr[left]).equals(target.get(sChArr[left]))) {
        now.put(sChArr[left], now.get(sChArr[left]) - 1);
        left++;
      }
      if (validCnt == target.size() && res[1] - res[0] > right - left) {
        res[1] = right;
        res[0] = left;
      }
      right++;
    }
    return res[1] == Integer.MAX_VALUE ? "" : s.substring(res[0], res[1] + 1);
  }
}

```

#### 例题6: 至少有 K 个重复字符的最长子串
[至少有 K 个重复字符的最长子串](https://leetcode.cn/problems/longest-substring-with-at-least-k-repeating-characters/)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220719191845.png)

##### 分析 

<div class="container">
  <iframe width="560" height="315" src="https://www.youtube.com/embed/j6hIrGX8iIA" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>

用validCnt来存储当前窗口中有几种字符达到了要求

```java
class Solution {
  public int longestSubstring(String s, int k) {
    char[] sChArr = s.toCharArray();
    int res = 0;
    for (int i = 1; i < 27; i++) {
      Map<Character, Integer> map = new HashMap();
      int left = 0, right = 0, validCnt = 0;
      while (right < sChArr.length) {
        map.put(sChArr[right], map.getOrDefault(sChArr[right], 0) + 1);
        if (map.get(sChArr[right]) == k) {
          validCnt++;
        }
        while (left <= right && map.size() > i) {
          if (map.get(sChArr[left]) == k) {
            validCnt--;
          }
          map.put(sChArr[left], map.get(sChArr[left]) - 1);
          if (map.get(sChArr[left]) == 0) {
            map.remove(sChArr[left]);
          }
          left++;
        }
        if (validCnt == i) {
          res = Math.max(res, right - left + 1);
        }
        right++;
      }
    }
    return res;
  }
}
```

#### 例题7: 替换后的最长重复字符
[替换后的最长重复字符](https://leetcode.cn/problems/longest-repeating-character-replacement/)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220720194852.png)

##### 分析

<div class="container">
  <iframe width="560" height="315" src="https://www.youtube.com/embed/zGgEJetsqYs" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>

代码：
```java
class Solution {
  public int characterReplacement(String s, int k) {
    char[] sChArr = s.toCharArray();
    int[] chCnt = new int[26];
    int left = 0, right = 0, res = 0;
    while (right < sChArr.length) {
      chCnt[sChArr[right] - 'A']++;
      while (left <= right && right - left + 1 - Arrays.stream(chCnt).max().getAsInt() > k) {
        chCnt[sChArr[left] - 'A']--;
        left++; 
      }
      res = Math.max(res, right - left + 1);
      right++;
    }
    return res;
  }
}
```

### 快慢指针

![](https://raw.githubusercontent.com/NaisWang/images/master/20220720223656.png)

#### 找出链表上某个点
##### 例题1: 链表的中间结点
[链表的中间结点](https://leetcode.cn/problems/middle-of-the-linked-list/)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220720213323.png)

代码：
```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
  public ListNode middleNode(ListNode head) {
    ListNode left = head, right = head;
    while (right != null && right.next != null) {
      right = right.next.next;
      left = left.next;
    }
    return left;
  }
}
```

##### 例题2: 删除链表的倒数第 N 个结点
[删除链表的倒数第 N 个结点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220720210009.png)

代码：
```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
  public ListNode removeNthFromEnd(ListNode head, int n) {
    ListNode left = head, right = head;
    while (n-- != 0) {
      right = right.next;
    } 
    if (right == null) {
      return head.next;
    }
    while (right.next != null) {
      right = right.next;
      left = left.next;
    }
    left.next = left.next.next;
    return head;
  }
}
```

#### 原地修改数组
数组问题中比较常见的快慢指针技巧，是让你原地修改数组。

##### 例题1: 删除有序数组中的重复项
[删除有序数组中的重复项](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220720215621.png)

###### 分析

<div class="container">
  <iframe width="560" height="315" src="https://www.youtube.com/embed/vVTo_VKRGus" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>

代码：
```java
class Solution {
  public int removeDuplicates(int[] nums) {
    int left = -1, right = 0;
    while (right < nums.length) {
      if (left == -1 || nums[left] != nums[right]) {
        nums[++left] = nums[right];
      }
      right++;
    }
    return left + 1;
  }
}
```

##### 例题2: 删除排序链表中的重复元素
[删除排序链表中的重复元素](https://leetcode.cn/problems/remove-duplicates-from-sorted-list/)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220720220519.png)

做法与`例题:删除有序数组中的重复项`相似

代码：
```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
  public ListNode deleteDuplicates(ListNode head) {
    ListNode left = null, right = head;
    while (right != null) {
      if (left == null) {
        left = right;
      } else if (left.val != right.val) {
        left.next = right;
        left = right;
      }
      right = right.next;
    }
    if (left != null) {
      left.next = null;
    }
    return head;
  }
}
```

##### 例题3: 移除元素
[移除元素](https://leetcode.cn/problems/remove-element/)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220720221536.png)

代码：
```java
class Solution {
  public int removeElement(int[] nums, int val) {
    int left = -1, right = 0; 
    while (right < nums.length) {
      if (nums[right] != val) {
        nums[++left] = nums[right];
      }
      right++;
    }
    return left + 1;
  }
}
```

##### 例题4: 移动零
[移动零](https://leetcode.cn/problems/move-zeroes/)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220720222510.png)

代码：
```java
class Solution {
  public void moveZeroes(int[] nums) {
    int left = 0, right = -1;
    while (right + 1 < nums.length) {
      right++;
      if (nums[right] != 0) {
        int temp = nums[left];
        nums[left] = nums[right];
        nums[right] = temp;
        left++;
      }
    }
  }
}
```

#### Floyd判圈算法
##### 算法简述
Floyd判圈算法（Floyd Cycle Detection Algorithm），又称龟兔赛跑算法（Tortoise and Hare Algorithm），是一个可以在有限状态机、迭代函数或者链表上判断是否存在环，以及判断环的起点与长度的算法。

##### 基本思路
在某种关系下，顶点 i 到 k 拓扑有序，顶点 k 到 j 也是相同的顺序，那么 i 和 j 也存在这个顺序。要是某一个顶点出现了自己到自己的环，那么图中就有环，但是这种方法复杂度高一些，没有检测顶点出度或者DFS的方法快，但是非常简单。

##### 判断是否有环？
龟兔解法的基本思想可以用我们跑步的例子来解释，如果两个人同时出发，如果赛道有环，那么快的一方总能追上慢的一方。进一步想，追上时快的一方肯定比慢的一方多跑了几圈，即多跑的路的长度是圈的长度的倍数。

基于上面的想法，Floyd用两个指针，一个慢指针（龟）每次前进一步，快指针（兔）指针每次前进两步（两步或多步效果时等价的，只要一个比另一个快就行）。如果两者在链表头以外的某一点相遇（即相等）了，那么说明链表有环，否则，如果（快指针）到达了链表的结尾，那么说明没坏。

##### 求环的长度
假设相遇点为B点,让其中一个指针停在B不动，另一个一步一步向前走并记录步数，再次相遇时步数即为环的长度。

##### 如何确定环的起点
假设相遇点为B点。方法是将其中一个指针移到链表起点，另一个指针为B点,两者同时移动，每次移动一步，那么两者相遇的地方就是环的起点。


##### 例题1：环形链表
[环形链表](https://leetcode.cn/problems/linked-list-cycle/)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220720210813.png)

代码：
```java
/**
 * Definition for singly-linked list.
 * class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
  public boolean hasCycle(ListNode head) {
    ListNode left = head, right = head;
    while (right != null && right.next != null) {
      right = right.next.next;
      left  = left.next;
      if (left == right) {
        return true;
      }
    }
    return false;
  }
}
```

##### 例题2：环形链表 II
[环形链表 II](https://leetcode.cn/problems/linked-list-cycle-ii/)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220720211432.png)

文字讲解：https://leetcode.cn/problems/linked-list-cycle-ii/solution/142-huan-xing-lian-biao-ii-jian-hua-gong-shi-jia-2/

代码：
```java
/**
 * Definition for singly-linked list.
 * class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
  public ListNode detectCycle(ListNode head) {
    ListNode left = head, right = head;
    while (right != null && right.next != null) {
      right = right.next.next;
      left = left.next;
      if (right == left) {
        return getCircleStartNode(right, head);
      }
    }
    return null;
  }

  public ListNode getCircleStartNode(ListNode meetNode, ListNode head) {
    while (meetNode != head) {
      head = head.next;
      meetNode = meetNode.next;
    }
    return head; 
  }
}
```

## 反向双指针

![](https://raw.githubusercontent.com/NaisWang/images/master/20220721105057.png)

### NSUM 问题

参考链接：https://mp.weixin.qq.com/s/fSyJVvggxHq28a0SdmZm6Q

经常刷力扣的读者肯定知道鼎鼎有名的 twoSum 问题，不过除了 twoSum 问题，力扣上面还有 3Sum，4Sum 问题，以后如果想出个 5Sum，6Sum 也不是不可以。

总结来说，这类 nSum 问题就是给你输入一个数组 nums 和一个目标和 target，让你从 nums 选择 n 个数，使得这些数字之和为 target。

#### twoSum问题

力扣上的 twoSum 问题，题目要求返回的是索引，这里我来编一道 twoSum 题目，不要返回索引，返回元素的值：

如果假设输入一个数组 nums 和一个目标和 target，请你返回 nums 中能够凑出 target 的两个元素的值，比如输入 nums = [5,3,1,6], target = 9，那么算法返回两个元素 [3,6]。可以假设只有且仅有一对儿元素可以凑出 target。

我们可以先对 nums 排序，然后利用前文「双指针技巧汇总」写过的左右双指针技巧，从两端相向而行就行了：
```cpp
vector<int> twoSum(vector<int>& nums, int target) {
    // 先对数组排序
    sort(nums.begin(), nums.end());
    // 左右指针
    int lo = 0, hi = nums.size() - 1;
    while (lo < hi) {
        int sum = nums[lo] + nums[hi];
        // 根据 sum 和 target 的比较，移动左右指针
        if (sum < target) {
            lo++;
        } else if (sum > target) {
            hi--;
        } else if (sum == target) {
            return {nums[lo], nums[hi]};
        }
    }
    return {};
}
```
这样就可以解决这个问题，不过我们要继续魔改题目，把这个题目变得更泛化，更困难一点：

nums 中可能有多对儿元素之和都等于 target，请你的算法返回所有和为 target 的元素对儿，其中不能出现重复。

函数签名如下：
```cpp
vector<vector<int>> twoSumTarget(vector<int>& nums, int target);
```
比如说输入为 nums = [1,3,1,2,2,3], target = 4，那么算法返回的结果就是：[[1,3],[2,2]]。

对于修改后的问题，关键难点是现在可能有多个和为 target 的数对儿，还不能重复，比如上述例子中 [1,3] 和 [3,1] 就算重复，只能算一次。

首先，基本思路肯定还是排序加双指针：
```cpp
vector<vector<int>> twoSumTarget(vector<int>& nums, int target {
    // 先对数组排序
    sort(nums.begin(), nums.end());
    vector<vector<int>> res;
    int lo = 0, hi = nums.size() - 1;
    while (lo < hi) {
        int sum = nums[lo] + nums[hi];
        // 根据 sum 和 target 的比较，移动左右指针
        if      (sum < target) lo++;
        else if (sum > target) hi--;
        else {
            res.push_back({lo, hi});
            lo++; hi--;
        }
    }
    return res;
}
```
但是，这样实现会造成重复的结果，比如说 nums = [1,1,1,2,2,3,3], target = 4，得到的结果中 [1,3] 肯定会重复。

出问题的地方在于 sum == target 条件的 if 分支，当给 res 加入一次结果后，lo 和 hi 不应该改变 1 的同时，还应该跳过所有重复的元素：

![](https://raw.githubusercontent.com/NaisWang/images/master/20220721092944.png)

所以，可以对双指针的 while 循环做出如下修改：
```cpp
while (lo < hi) {
    int sum = nums[lo] + nums[hi];
    // 记录索引 lo 和 hi 最初对应的值
    int left = nums[lo], right = nums[hi];
    if (sum < target)      lo++;
    else if (sum > target) hi--;
    else {
        res.push_back({left, right});
        // 跳过所有重复的元素
        while (lo < hi && nums[lo] == left) lo++;
        while (lo < hi && nums[hi] == right) hi--;
    }
}
```
这样就可以保证一个答案只被添加一次，重复的结果都会被跳过，可以得到正确的答案。不过，受这个思路的启发，其实前两个 if 分支也是可以做一点效率优化，跳过相同的元素：
```cpp
vector<vector<int>> twoSumTarget(vector<int>& nums, int target) {
    // nums 数组必须有序
    sort(nums.begin(), nums.end());
    int lo = 0, hi = nums.size() - 1;
    vector<vector<int>> res;
    while (lo < hi) {
        int sum = nums[lo] + nums[hi];
        int left = nums[lo], right = nums[hi];
        if (sum < target) {
            while (lo < hi && nums[lo] == left) lo++;
        } else if (sum > target) {
            while (lo < hi && nums[hi] == right) hi--;
        } else {
            res.push_back({left, right});
            while (lo < hi && nums[lo] == left) lo++;
            while (lo < hi && nums[hi] == right) hi--;
        }
    }
    return res;
}
```
这样，一个通用化的 twoSum 函数就写出来了，请确保你理解了该算法的逻辑，我们后面解决 3Sum 和 4Sum 的时候会复用这个函数。

这个函数的时间复杂度非常容易看出来，双指针操作的部分虽然有那么多 while 循环，但是时间复杂度还是 O(N)，而排序的时间复杂度是 O(NlogN)，所以这个函数的时间复杂度是 O(NlogN)。

#### 3Sum问题
这是力扣第 15 题「三数之和」：

![](https://raw.githubusercontent.com/NaisWang/images/master/20220721100103.png)

题目就是让我们找 nums 中和为 0 的三个元素，返回所有可能的三元组（triple），函数签名如下：
```cpp
vector<vector<int>> threeSum(vector<int>& nums);
```
这样，我们再泛化一下题目，不要光和为 0 的三元组了，计算和为 target 的三元组吧，同上面的 twoSum 一样，也不允许重复的结果：
```cpp
vector<vector<int>> threeSum(vector<int>& nums) {
    // 求和为 0 的三元组
    return threeSumTarget(nums, 0);
}

vector<vector<int>> threeSumTarget(vector<int>& nums, int target) {
    // 输入数组 nums，返回所有和为 target 的三元组
}
```

这个问题怎么解决呢？很简单，穷举呗。现在我们想找和为 target 的三个数字，那么对于第一个数字，可能是什么？nums 中的每一个元素 nums[i] 都有可能！

那么，确定了第一个数字之后，剩下的两个数字可以是什么呢？其实就是和为 target - nums[i] 的两个数字呗，那不就是 twoSum 函数解决的问题么🤔

可以直接写代码了，需要把 twoSum 函数稍作修改即可复用：
```cpp
/* 从 nums[start] 开始，计算有序数组
 * nums 中所有和为 target 的二元组 */
vector<vector<int>> twoSumTarget(
    vector<int>& nums, int start, int target) {
    // 左指针改为从 start 开始，其他不变
    int lo = start, hi = nums.size() - 1;
    vector<vector<int>> res;
    while (lo < hi) {
        ...
    }
    return res;
}

/* 计算数组 nums 中所有和为 target 的三元组 */
vector<vector<int>> threeSumTarget(vector<int>& nums, int target) {
    // 数组得排个序
    sort(nums.begin(), nums.end());
    int n = nums.size();
    vector<vector<int>> res;
    // 穷举 threeSum 的第一个数
    for (int i = 0; i < n; i++) {
        // 对 target - nums[i] 计算 twoSum
        vector<vector<int>> 
            tuples = twoSumTarget(nums, i + 1, target - nums[i]);
        // 如果存在满足条件的二元组，再加上 nums[i] 就是结果三元组
        for (vector<int>& tuple : tuples) {
            tuple.push_back(nums[i]);
            res.push_back(tuple);
        }
        // 跳过第一个数字重复的情况，否则会出现重复结果
        while (i < n - 1 && nums[i] == nums[i + 1]) i++;
    }
    return res;
}
```
需要注意的是，类似 twoSum，3Sum 的结果也可能重复，比如输入是 nums = [1,1,1,2,3], target = 6，结果就会重复。

关键点在于，不能让第一个数重复，至于后面的两个数，我们复用的 twoSum 函数会保证它们不重复。所以代码中必须用一个 while 循环来保证 3Sum 中第一个元素不重复。

至此，3Sum 问题就解决了，时间复杂度不难算，排序的复杂度为 O(NlogN)，twoSumTarget 函数中的双指针操作为 O(N)，threeSumTarget 函数在 for 循环中调用 twoSumTarget 所以总的时间复杂度就是 O(NlogN + N^2) = O(N^2)。

#### 4Sum问题
这是力扣第 18 题「四数之和」：

![](https://raw.githubusercontent.com/NaisWang/images/master/20220721101131.png)

函数签名如下：
```cpp
vector<vector<int>> fourSum(vector<int>& nums, int target);
```
都到这份上了，4Sum 完全就可以用相同的思路：穷举第一个数字，然后调用 3Sum 函数计算剩下三个数，最后组合出和为 target 的四元组。
```cpp
vector<vector<int>> fourSum(vector<int>& nums, int target) {
    // 数组需要排序
    sort(nums.begin(), nums.end());
    int n = nums.size();
    vector<vector<int>> res;
    // 穷举 fourSum 的第一个数
    for (int i = 0; i < n; i++) {
        // 对 target - nums[i] 计算 threeSum
        vector<vector<int>> 
            triples = threeSumTarget(nums, i + 1, target - nums[i]);
        // 如果存在满足条件的三元组，再加上 nums[i] 就是结果四元组
        for (vector<int>& triple : triples) {
            triple.push_back(nums[i]);
            res.push_back(triple);
        }
        // fourSum 的第一个数不能重复
        while (i < n - 1 && nums[i] == nums[i + 1]) i++;
    }
    return res;
}

/* 从 nums[start] 开始，计算有序数组
 * nums 中所有和为 target 的三元组 */
vector<vector<int>> 
    threeSumTarget(vector<int>& nums, int start, int target) {
        int n = nums.size();
        vector<vector<int>> res;
        // i 从 start 开始穷举，其他都不变
        for (int i = start; i < n; i++) {
            ...
        }
        return res;
```
这样，按照相同的套路，4Sum 问题就解决了，时间复杂度的分析和之前类似，for 循环中调用了 threeSumTarget 函数，所以总的时间复杂度就是 O(N^3)。

#### 100Sum问题？
在 LeetCode 上，4Sum 就到头了，但是回想刚才写 3Sum 和 4Sum 的过程，实际上是遵循相同的模式的。我相信你只要稍微修改一下 4Sum 的函数就可以复用并解决 5Sum 问题，然后解决 6Sum 问题……

那么，如果我让你求 100Sum 问题，怎么办呢？其实我们可以观察上面这些解法，统一出一个 nSum 函数：

```cpp
/* 注意：调用这个函数之前一定要先给 nums 排序 */
vector<vector<int>> nSumTarget(
    vector<int>& nums, int n, int start, int target) {

    int sz = nums.size();
    vector<vector<int>> res;
    // 至少是 2Sum，且数组大小不应该小于 n
    if (n < 2 || sz < n) return res;
    // 2Sum 是 base case
    if (n == 2) {
        // 双指针那一套操作
        int lo = start, hi = sz - 1;
        while (lo < hi) {
            int sum = nums[lo] + nums[hi];
            int left = nums[lo], right = nums[hi];
            if (sum < target) {
                while (lo < hi && nums[lo] == left) lo++;
            } else if (sum > target) {
                while (lo < hi && nums[hi] == right) hi--;
            } else {
                res.push_back({left, right});
                while (lo < hi && nums[lo] == left) lo++;
                while (lo < hi && nums[hi] == right) hi--;
            }
        }
    } else {
        // n > 2 时，递归计算 (n-1)Sum 的结果
        for (int i = start; i < sz; i++) {
            vector<vector<int>> 
                sub = nSumTarget(nums, n - 1, i + 1, target - nums[i]);
            for (vector<int>& arr : sub) {
                // (n-1)Sum 加上 nums[i] 就是 nSum
                arr.push_back(nums[i]);
                res.push_back(arr);
            }
            while (i < sz - 1 && nums[i] == nums[i + 1]) i++;
        }
    }
    return res;
}
```
嗯，看起来很长，实际上就是把之前的题目解法合并起来了，n == 2 时是 twoSum 的双指针解法，n > 2 时就是穷举第一个数字，然后递归调用计算 (n-1)Sum，组装答案。

需要注意的是，调用这个 nSum 函数之前一定要先给 nums 数组排序，因为 nSum 是一个递归函数，如果在 nSum 函数里调用排序函数，那么每次递归都会进行没有必要的排序，效率会非常低。

比如说现在我们写 LeetCode 上的 4Sum 问题：
```cpp
vector<vector<int>> fourSum(vector<int>& nums, int target) {
    sort(nums.begin(), nums.end());
    // n 为 4，从 nums[0] 开始计算和为 target 的四元组
    return nSumTarget(nums, 4, 0, target);
}
```
再比如 LeetCode 的 3Sum 问题，找 target == 0 的三元组：
```cpp
vector<vector<int>> threeSum(vector<int>& nums) {
    sort(nums.begin(), nums.end());
    // n 为 3，从 nums[0] 开始计算和为 0 的三元组
    return nSumTarget(nums, 3, 0, 0);        
}
```
那么，如果让你计算 100Sum 问题，直接调用这个函数就完事儿了。

#### NSum模版
```java
/**
 *
 * @param nums 由小到大排序好的数组
 * @param n n数之和
 * @param start 开始坐标
 * @param target 目标和
 */
List<List<Integer>> nSumTarget(int[] nums, int n, int start, long target) {
  int N = nums.length;
  List<List<Integer>> res = new ArrayList();
  // 至少是 2Sum，且数组大小不应该小于 n
  if (n < 2 || N < n) return res;
  if (n == 2) {
    int left = start, right = N - 1;
    while (left < right) {
      long sum = (long) nums[left] + nums[right];
      if (sum > target) {
        right--;
      } else if (sum < target) {
        left++;
      } else {
        List<Integer> temp = new ArrayList();
        temp.add(nums[left]);
        temp.add(nums[right]);
        res.add(temp);
        left++;
        right--;
        while (left < right && nums[left] == nums[left - 1]) left++;
        while (left < right && nums[right] == nums[right + 1]) right--;
      }
    }
  } else {
    // n > 2 时，递归计算 (n-1)Sum 的结果
    for (int i = start; i < N; i++) {
      List<List<Integer>> sub = nSumTarget(nums, n - 1, i + 1, target - nums[i]);
      for (List<Integer> item : sub) {
        item.add(nums[i]);
        res.add(item);
      }
      while (i + 1 < N && nums[i + 1] == nums[i]) i++;
    }
  }
  return res;
}
```

#### 例题1: 两数之和 II - 输入有序数组
[两数之和 II - 输入有序数组](https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220721104439.png)

代码：
```java
class Solution {
  public int[] twoSum(int[] numbers, int target) {
    Arrays.sort(numbers);
    int n = numbers.length;
    int left = 0, right = n - 1;
    while (left < right) {
      int sum = numbers[left] + numbers[right];
      if (sum < target) {
        left++;
      } else if (sum > target) {
        right--;
      } else {
        return new int[]{left + 1, right + 1};
      }
    }
    return null;
  }
}
```

#### 例题2: 三数之和
[三数之和](https://leetcode.cn/problems/3sum/)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220721104541.png)

代码：
```java
class Solution {
  public List<List<Integer>> threeSum(int[] nums) {
    Arrays.sort(nums);
    List<List<Integer>> res = new ArrayList();
    for (int i = 0; i < nums.length - 2; i++) {
      List<int[]> temp = twoSum(nums, i + 1, -nums[i]);
      for (int[] item : temp) {
        List<Integer> subRes = new ArrayList(); 
        subRes.add(nums[i]);
        subRes.add(item[0]);
        subRes.add(item[1]);
        res.add(subRes);
      }
      while (i + 1 < nums.length && nums[i + 1] == nums[i]) i++;
    }
    return res;
  }
  
  List<int[]> twoSum(int[] nums, int start, int target) {
    List<int[]> res = new ArrayList();
    int n = nums.length;
    int left = start, right = n - 1;
    while (left < right) {
      int sum = nums[left] + nums[right];
      if (sum > target) {
        right--;
      } else if (sum < target) {
        left++;
      } else {
        res.add(new int[]{nums[left], nums[right]});
        left++;
        right--;
        while (left < right && nums[left] == nums[left - 1]) left++;
        while (left < right && nums[right] == nums[right + 1]) right--;
      }
    }
    return res;
  } 

}
```

#### 例题3: 四数之和
[四数之和](https://leetcode.cn/problems/4sum/)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220721104647.png)

代码：
```java
class Solution {
  public List<List<Integer>> fourSum(int[] nums, int target) {
    Arrays.sort(nums);
    return nSumTarget(nums, 4, 0, target);
  }

  List<List<Integer>> nSumTarget(int[] nums, int n, int start, long target) {
    int N = nums.length;
    List<List<Integer>> res = new ArrayList();
    // 至少是 2Sum，且数组大小不应该小于 n
    if (n < 2 || N < n) return res;
    if (n == 2) {
      int left = start, right = N - 1;
      while (left < right) {
        long sum = (long)nums[left] + nums[right];
        if (sum > target) {
          right--;
        } else if (sum < target) {
          left++;
        } else {
          List<Integer> temp = new ArrayList();
          temp.add(nums[left]);
          temp.add(nums[right]);
          res.add(temp);
          left++;
          right--;
          while (left < right && nums[left] == nums[left - 1]) left++;
          while (left < right && nums[right] == nums[right + 1]) right--;
        } 
      }
    } else {
      // n > 2 时，递归计算 (n-1)Sum 的结果
      for (int i = start; i < N; i++) {
        List<List<Integer>> sub = nSumTarget(nums, n - 1, i + 1, target - nums[i]);
        for (List<Integer> item : sub) {
          item.add(nums[i]);
          res.add(item);
        }
        while (i + 1 < N && nums[i + 1] == nums[i]) i++;
      }
    }
    return res;
  }
}
```

### 其他问题
#### 例题1: 反转数组
[反转数组](https://leetcode.cn/problems/reverse-string/)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220721105740.png)

代码：
```java
class Solution {
  public void reverseString(char[] s) {
    int left = 0, right = s.length - 1;
    while (left < right) {
      char temp = s[left];
      s[left] = s[right];
      s[right] = temp;
      left++;
      right--;
    }
  }
}
```

#### 例题2: 验证回文串
[验证回文串](https://leetcode.cn/problems/valid-palindrome/)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220721111436.png)

代码：
```java
class Solution {
  public boolean isPalindrome(String s) {
    s = s.toLowerCase();
    char[] sCh = s.toCharArray();
    int left = 0, right = sCh.length - 1;
    while (left < right) {
      if (!((sCh[left] <= 'z' && sCh[left] >= 'a' )|| (sCh[left] <= '9' && sCh[left] >= '0'))){
        left++;
        continue;
      }
      if (!((sCh[right] <= 'z' && sCh[right] >= 'a' )|| (sCh[right] <= '9' && sCh[right] >= '0'))){
        right--;
        continue;
      }
      if (sCh[left] != sCh[right]) {
        return false;
      }
      left++;
      right--;
    }
    return true;
  }
}
```

# 几何
## 扫描线算法

<div class="container">
  <iframe width="560" height="315" src="https://www.youtube.com/embed/NoPTAgfyCc8" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>

- 通用的思路: 假设一个平面上有n个几何对象，想像一条扫描线从左到右或者从上到下扫过它们。 
- 发生的事件：扫描线进入和离开一个几何对象。对于平行于坐标轴的矩形来说，可以理解为扫描线进入和离开一个线段。
- 对于事件的处理：用一个数据结构维护扫描线与几何对象们的交集。对于平行于坐标轴的矩形来说，可以使用线段树。

给事件排序时，需要考虑以下4件特殊情况:
1. 2个事件的开始位置相同
1. 2个事件的结束位置相同
2. 1个事件的结束位置与另一个事件的开始位置相同
3. 2个事件的开始以及结束位置都相同

### 模版
```java
public List<List<Integer>> funExample(int[][] buildings) {
  List<List<Integer>> res = new ArrayList();
  
  // 添加事件
  List<Event> events = new ArrayList(); 
  for (int i = 0; i < buildings.length; i++) {
    int[] build = buildings[i];
    events.add(new Event(i, build[0], 1, build[2]));
    events.add(new Event(i, build[1], -1, build[2]));
  }
  // 给事件排序
  events.sort((a, b) -> {
    if (a.pos == b.pos) {
      // 考虑4中特殊情况
    }
    return a.pos - b.pos;
  });

  // 维护扫描线与几何对象们的交集
  PriorityQueue<Event> pq = new PriorityQueue<Event>((a, b) -> {
    return b.height - a.height;
  });

  // 遍历事件
  for (Event event : events) {
    if (event.type == 1) { // 如果是进入事件
      ... 
      pq.add(event);
    } else if (event.type == -1) { // 如果是离开事件
      pq.remove(event);
      ...
    }
  }
  return res;
}

class Event {
  // 该事件的id
  int id;
  // 该事件位置
  int pos;
  int height;
  // 表示当前事件的类型，如果为1表示为进入事件；为2表示离开事件
  int type;

  public Event(int id, int pos, int type, int height) {
    this.id = id;
    this.pos = pos;
    this.type = type;
    this.height = height;
  }

  public boolean equals(Object o) {
    Event e = (Event) o;
    return e.id == id;
  }

  public int hashCode() {
    return Objects.hash(id);
  }
}
```

### 例题1: 天际线问题
[天际线问题](https://leetcode.cn/problems/the-skyline-problem/)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220724170751.png)

#### 分析

<div class="container">
  <iframe width="560" height="315" src="https://www.youtube.com/embed/ZbpfMkA_NfE" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>

代码：
```java
class Solution {
  public List<List<Integer>> getSkyline(int[][] buildings) {
    List<List<Integer>> res = new ArrayList();
    List<Event> events = new ArrayList(); 
    for (int i = 0; i < buildings.length; i++) {
      int[] build = buildings[i];
      events.add(new Event(i, build[0], 1, build[2]));
      events.add(new Event(i, build[1], -1, build[2]));
    }
    events.sort((a, b) -> {
      if (a.pos == b.pos) {
        return b.type * b.height - a.type * a.height;
      }
      return a.pos - b.pos;
    });

    PriorityQueue<Event> pq = new PriorityQueue<Event>((a, b) -> {
      return b.height - a.height;
    });

    for (Event event : events) {
      List<Integer> temp = new ArrayList();
      if (event.type == 1) { // 如果是进入事件
        if (pq.isEmpty() || event.height > pq.peek().height) {
          temp.add(event.pos);
          temp.add(event.height);
          res.add(temp);
        }
        pq.add(event);
      } else if (event.type == -1) { // 如果是离开事件
        pq.remove(event);
        if (pq.isEmpty() || event.height > pq.peek().height) {
          temp.add(event.pos);
          temp.add(pq.isEmpty() ? 0 : pq.peek().height);
          res.add(temp);
        }
      }
    }
    return res;
  }
}

class Event {
  int id;
  int pos;
  int height;
  int type;

  public Event(int id, int pos, int type, int height) {
    this.id = id;
    this.pos = pos;
    this.type = type;
    this.height = height;
  }

  public boolean equals(Object o) {
    Event e = (Event) o;
    return e.id == id;
  }

  public int hashCode() {
    return Objects.hash(id);
  }

}
```

### 例题2: 合并区间
[合并区间](https://leetcode.cn/problems/merge-intervals/)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220724171447.png)

代码：
```java
class Solution {
  public int[][] merge(int[][] intervals) {
    List<int[]> res = new ArrayList();
    List<Event> events = new ArrayList();
    for (int i = 0; i < intervals.length; i++) {
      int[] interval = intervals[i];
      events.add(new Event(i, interval[0], 1)); 
      events.add(new Event(i, interval[1], -1)); 
    }

    events.sort((a, b) -> {
      if (a.pos == b.pos) {
        return b.type - a.type;
      }
      return a.pos - b.pos;
    });

    List<Event> list = new ArrayList();
    int[] temp = new int[2];
    for (Event event : events) {
      if (event.type == 1) {
        if (list.isEmpty()) {
          temp[0] = event.pos;
        }
        list.add(event);
      } else if (event.type == -1) {
        list.remove(event);
        if (list.isEmpty()) {
          temp[1] = event.pos;
          res.add(temp.clone());
        }
      }
    }
    return res.toArray(new int[0][0]);
  }
}

class Event {
  int id;
  int pos;
  int type;

  public Event(int id, int pos, int type) {
    this.id = id;
    this.pos = pos;
    this.type = type;
  }

  public int hashCode() {
    return Objects.hash(id);
  }

  public boolean equals(Object o) {
    Event e = (Event) o;
    return e.id == id;
  }

}
```

### 例题3: 插入区间
[插入区间](https://leetcode.cn/problems/insert-interval/)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220724171554.png)

代码：
```java
class Solution {
  public int[][] insert(int[][] intervals, int[] newInterval) {
    List<int[]> res = new ArrayList();
    List<Event> events = new ArrayList();
    for (int i = 0; i < intervals.length; i++) {
      int[] interval = intervals[i];
      events.add(new Event(i, interval[0], 1));
      events.add(new Event(i, interval[1], -1));
    }
    events.add(new Event(intervals.length, newInterval[0], 1));
    events.add(new Event(intervals.length, newInterval[1], -1));

    events.sort((a, b) -> {
      if (a.pos == b.pos) {
        return b.type - a.type;
      }
      return a.pos - b.pos;
    });

    int[] temp = new int[2];
    List<Event> list = new ArrayList();
    for (Event event : events) {
      if (event.type == 1) {
        if (list.isEmpty()) {
          temp[0] = event.pos;
        }
        list.add(event);
      } else if (event.type == -1) {
        list.remove(event);
        if (list.isEmpty()) {
          temp[1] = event.pos;
          res.add(temp.clone());
        }
      }
    }
    return res.toArray(new int[0][0]);
  }
}

class Event {
  int id;
  int pos;
  int type;
  
  public Event(int id, int pos, int type) {
    this.id = id;
    this.pos = pos;
    this.type = type;
  }

  public int hashCode() {
    return Objects.hash(id);
  }

  public boolean equals(Object o) {
    Event e = (Event) o;
    return e.id == id;
  }
}
```

### 例题4: 无重叠区间
[无重叠区间](https://leetcode.cn/problems/non-overlapping-intervals/)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220724171653.png)

代码：
```java
class Solution {
  public int eraseOverlapIntervals(int[][] intervals) {
    int res = 0;
    List<Event> events = new ArrayList();
    for (int i = 0; i < intervals.length; i++) { 
      int[] interval = intervals[i];
      events.add(new Event(i, interval[0], 1)); 
      events.add(new Event(i, interval[1], -1)); 
    }

    events.sort((a, b) -> {
      if (a.pos == b.pos) {
        return a.type - b.type;
      }
      return a.pos - b.pos;
    });
    
    Set<Integer> removed = new HashSet();
    List<Event> list = new ArrayList();
    for (Event event : events) {
      if (event.type == 1) {
        list.add(event);
      } else if (event.type == -1 && !removed.contains(event.id)) {
        for (Event item : list) {
          removed.add(item.id);
        }
        res += list.size() - 1;
        list.clear();
      }
    }
    return res;

  }

}

class Event {
  int id;
  int pos;
  int type;

  public Event(int id, int pos, int type) {
    this.id = id;
    this.pos = pos;
    this.type = type;
  }

  public int hashCode() {
    return Objects.hash(id);
  }

  public boolean equlas(Object o) {
    Event e = (Event) o;
    return e.id == id;
  }

}
```

### 例题5: 删除被覆盖区间
[删除被覆盖区间](https://leetcode.cn/problems/remove-covered-intervals/)

![](https://raw.githubusercontent.com/NaisWang/images/master/20220724171753.png)

代码：
```java
class Solution {
  public int removeCoveredIntervals(int[][] intervals) {
    int res = 0;
    List<Event> events = new ArrayList();
    for (int i = 0; i < intervals.length; i++) {
      int[] interval = intervals[i];
      events.add(new Event(i, interval[0], 1, interval[1]));
      events.add(new Event(i, interval[1], -1, interval[1]));
    }
    events.sort((a, b) -> {
      if (a.pos == b.pos) {
        return b.end - a.end;
      }
      return a.pos - b.pos;
    });

    PriorityQueue<Event> pq = new PriorityQueue<Event>((a, b) -> {
      return b.end - a.end;
    });

    for (Event event : events) {
      if (event.type == 1) {
        if (!pq.isEmpty() && event.end <= pq.peek().end) {
          res++;
        }
        pq.add(event);
      } else if (event.type == -1) {
        pq.remove(event);
      }
    } 
    return intervals.length - res;

  }
}

class Event {
  int id;
  int pos;
  int type;
  // 区间的结束位置
  int end;

  public Event(int id, int pos, int type, int end) {
    this.id = id;
    this.pos = pos;
    this.type = type;
    this.end = end;
  }

  public int hashCode() {
    return Objects.hash(id);
  }

  public boolean equals(Object o) {
    Event e = (Event) o;
    return e.id == id;
  } 

}
```

# 算法模版总结
## 图论
### BFS
```java
/**
* visited: 用来存储被访问过的状态。如果允许状态是能够重复访问，则不需要创建visited变量
* path: 用来存储路径。如果不需要输出路径，则不需要创建path变量
* return: 是否可以到达目标状态
**/
boolean bfs(State startState) {
  Queue<State> queue = new LinkedList();
  Map<State, Boolean> visited = new HashMap();
  Map<State, State> path = new HashMap();
  
  queue.add(startState);
  visited.put(startState, true);

  while (!queue.isEmpty()) {
    State currentState = queue.poll();
    // 如果currentState是目标状态
    if (isObjective(currentState)) {
      // 可以在这里输出path
      return visited.get(currentState);
    }

    // 获取当前状态可以转换到的所有下一个状态。此时不需要考虑这个状态是否能被添加到队列中
    List<State> nextStates = transition(currentState);

    for (State nextState : nextStates) {
      if (visited.containsKey(nextState)) continue;
      queue.add(nextState);
      visited.put(nextState, true);
      path.put(nextState, currentState); 
    }
  }
  return false;
}
```

### DFS
```java
/**
 * visited: 用来存储被访问过的状态。如果允许状态是能够重复访问，则不需要创建visited变量
 * path: 用来存储路径。如果不需要输出路径，则不需要创建path变量
 * return: 是否可以到达目标状态
 */
boolean dfs(State currentState, Map<State, Boolean> visited, LinkedList<State> path) {
	visited.put(currentState, true);

	// 如果currentState是目标状态
	if (isObjective(currentState)) {
		// 可以在这里输出path
		return true;
	}

  // 获取当前状态可以转换到的所有下一个状态。此时不需要考虑这个状态是否能被添加到队列中
	List<State> nextStates = transition(currentState);

	for (State nextState : nextStates) {
		if (visited.containsKey(nextState)) continue;
		path.push(nextState);
		if (dfs(nextState, visited, path)){
			return true;
		}
		path.pop();
	}
	return false;
}
```

### 查找连通分量-BFS
```java
int findComponents() {
  // key表示节点/状态，value表示该节点/状态所属于的连通分支。
  // 该components可以作为visited使用, 即当componets.containsKey(i) == false时，表示i节点没有被访问，反之，则被访问了
  Map<State, Integer> components = new HashMap<>();

  // 现在所求的连通分支标识
  int currentComponent = 0;

  // 遍历每个节点/状态
  for (State state : States) {
    if (!components.containsKey(state)) {
      bfs(state, components, currentComponent++);
    }
  }
  return currentComponent;
}

void bfs(State startState, Map<State, Integer> components, Integer currentComponent) {
  Queue<State> queue = new LinkedList();

  queue.add(startState);
  components.put(startState, currentComponent);

  while (!queue.isEmpty()) {
    State currentState = queue.poll();

    // 获取当前状态可以转换到的所有下一个状态。此时不需要考虑这个状态是否能被添加到队列中
    List<State> nextStates = transition(currentState);

    for (State nextState : nextStates) {
      if (components.containsKey(nextState)) continue;
      queue.add(nextState);
      components.put(nextState, currentComponent);
    }
  }
}

class State {

}
```

### 查找连通分量-DFS
```java
int findComponents() {
  // key表示节点/状态，value表示该节点/状态所属于的连通分支。
  // 该components可以作为visited使用, 即当componets.containsKey(i) == false时，表示i节点没有被访问，反之，则被访问了
  Map<State, Integer> components = new HashMap<>();

  // 现在所求的连通分支标识
  int currentComponent = 0;

  // 遍历每个节点/状态
  for (State state : States) {
    if (!components.containsKey(state)) {
      bfs(state, components, currentComponent++);
    }
  }
  return currentComponent;
}

void dfs(State startState, Map<State, Integer> components, Integer currentComponent) {
  components.put(startState, currentComponent);

  // 获取当前状态可以转换到的所有下一个状态。此时不需要考虑这个状态是否能被添加到队列中
  List<State> nextStates = transition(currentState);

  for (State nextState : nextStates) {
    if (components.containsKey(nextState)) continue;
    dfs(nextState, components, currentComponent);
  }
}

class State {

}
```

### 并查集
#### 没有权值的并查集
```java
class DisjointSet {
  int[] parent;
  // 连通分量的个数
  int cnt;

  public DisjointSet(int n) {
    cnt = n;
    // 初始化parent
    parent = new int[n];
    for (int i = 0; i < n; i++) {
      parent[i] = i;
    }
  }

  // 查找x属于哪个连通分支
  int findParent(int x) {
    if (x == parent[x]) {
      return x; 
    } 
    parent[x] = findParent(parent[x]);
    return parent[x];
  }

  // 合并2个连通分支
  void unionSets(int a, int b) {
    a = findParent(a);
    b = findParent(b);
    if (a != b) {
      parent[a] = b;
      cnt--;
    }
  }
}
```

#### 有权值的并查集
```java
class DisjointSet {
  int[] parent;
  // weight[x]表示节点x指向父节点的权值
  double[] weight;
  // 连通分量的个数
  int cnt;

  public DisjointSet(int n) {
    cnt = n;
    parent = new int[n];
    weight = new double[n];
    for (int i = 0; i < n; i++) {
      parent[i] = i;
      // 权值初始化, 如何初始化，根据情况而定
      weight[i] = 1;
    }
  }

  int findParent(int x) {
    if (x == parent[x]) {
      return x;
    } 
    // 保存节点x没有进行路径压缩时的父节点。这样做是为了方便后续获取父节点的weight来更新节点x的weight
    int origin = parent[x];
    parent[x] = findParent(parent[x]);
    // 更新weight[x], 具体如何更新，根据情况而定
    weight[x] *= weight[origin];
    return parent[x];
  }

  void unionSets(int a, int b, double value) {
    int rootA = findParent(a);
    int rootB = findParent(b);
    
    if (rootA != rootB) {
      parent[rootA] = rootB;
      // 更新weight[rootA], 具体如何更新，根据情况而定
      weight[rootA] = value * weight[b] / weight[a];
      cnt--;
    }
  }
}
```

#### 需要记录每个连通分量中节点个数
```java
class DisjointSet {
  int[] parent;
  // 记录每个连通分量中的节点个数
  int[] size;
  // 连通分量的个数
  int cnt;

  public DisjointSet(int n) {
    cnt = n;
    // 初始化parent
    parent = new int[n];
    size = new int[n];
    for (int i = 0; i < n; i++) {
      parent[i] = i;
      size[i] = 1;
    }
  }

  // 查找x属于哪个连通分支
  int findParent(int x) {
    if (x == parent[x]) {
      return x;
    }
    parent[x] = findParent(parent[x]);
    return parent[x];
  }

  // 合并2个连通分支
  void unionSets(int a, int b) {
    a = findParent(a);
    b = findParent(b);
    if (a != b) {
      parent[a] = b;
      size[b] += size[a];
      cnt--;
    }
  }

  // 返回x节点所在连通分量的大小
  int getSize(int x) {
    return size[findParent(x)];
  }
}
```


#### 初始化时节点总数不确定的并查集
```java
class DisjointSet {
  // key：节点编号；value：该节点的父节点
  Map<Integer, Integer> parent;
  // 连通分量的个数
  int cnt;
  
  public DisjointSet() {
    parent = new HashMap();
    // 刚初始化话时，parent中节点个数为0，所以连通分量个数为0
    cnt = 0;
  }

  int findParent(int x) {
    // 如果parent没有统计当前节点x, 则将节点x添加到parent中，节点x的父节点为它自己。此时连通分量个数加1
    if (!parent.containsKey(x)) {
      parent.put(x, x);
      cnt++;
    }

    if (x == parent.get(x)) {
      return x;
    }
    parent.put(x, findParent(parent.get(x)));
    return parent.get(x);
  }

  void unionSets(int a, int b) {
    a = findParent(a);
    b = findParent(b);
    if (a != b) {
      parent.put(a, b);
      // 连通分量个数减1
      cnt--;
    }
  }
}
```

### 最短路径算法
#### Dijkstra算法
##### 模版1: 需求到达其他所有点的最短路径
```java
/**
* startState: 开始状态
* graph: 图的表示方式，这里是使用的带有的权值的邻接表的表示方式
*/
int[] dijkstra(State startState,  List<int[]>[] graph) {
  // 优先队列，distFromStart较小的排在前面
  Queue<State> pq = new PriorityQueue<>((a, b) -> {
    return a.distFromStart - b.distFromStart;
  });

  // 初始化dist
  // dist[i] 的值就是节点 start 到达节点 i 的最短路径权重
  int[] dist = new int[graph.length];
  // 起始点到各点的最短路径长度为Integer.MAX_VALUE
  Arrays.fill(dist, Integer.MAX_VALUE);
  // 节点start 到节点start的最短路径为0 
  dist[startState.id] = 0;

  // 用来标记节点是否已经被选择
  boolean[] isSelected = new boolean[graph.length];

  // 从起点start开始进bfs
  pq.add(startState);

  while (!pq.isEmpty()) {
    State currentState = pq.poll();
    
    if (isSelected[currentState.id]) {
      continue;
    }
    isSelected[currentState.id] = true;

    // 获取currentState相邻节点
    List<State> nextStates = new ArrayList();
    for (int[] neighbor : graph[currentState.id]) {
      int nextNodeID = neighbor[0];
      int distToNextNode = dist[currentState.id] + neighbor[1];
      nextStates.add(new State(nextNodeID, distToNextNode));
    }
     
    for (State nextState : nextStates) {
      if (isSelected[nextState.id]) continue;
      if (dist[nextState.id] > nextState.distFromStart) {
        dist[nextState.id] = nextState.distFromStart;
        pq.add(nextState);
      }
    }
  }
  
  return dist;
}

// 辅助类, 用于优先队列
class State {
    // 图节点的 id
    int id;
    // 从 start 节点到当前节点的距离
    int distFromStart;

    State(int id, int distFromStart) {
        this.id = id;
        this.distFromStart = distFromStart;
    }
}
```

##### 模版2: 只需求到达某个点的最短路径
```java
/**
* startState: 开始状态
* graph: 图的表示方式，这里是使用的带有的权值的邻接表的表示方式
* end: 目标点
*/
int dijkstra(State startState,  List<int[]>[] graph, int end) {
  // 优先队列，distFromStart较小的排在前面
  Queue<State> pq = new PriorityQueue<>((a, b) -> {
    return a.distFromStart - b.distFromStart;
  });

  // 初始化dist
  // dist[i] 的值就是节点 start 到达节点 i 的最短路径权重
  int[] dist = new int[graph.length];
  // 起始点到各点的最短路径长度为Integer.MAX_VALUE
  Arrays.fill(dist, Integer.MAX_VALUE);
  // 节点start 到节点start的最短路径为0 
  dist[startState.id] = 0;

  // 用来标记节点是否已经被选择
  boolean[] isSelected = new boolean[graph.length];

  // 从起点start开始进bfs
  pq.add(startState);

  while (!pq.isEmpty()) {
    State currentState = pq.poll();
    
    // 如果currentState是目标点
    if (currentState.id == end) {
      return currentState.distFromStart;
    }

    if (isSelected[currentState.id]) {
      continue;
    }
    isSelected[currentState.id] = true;


    // 获取currentState相邻节点
    List<State> nextStates = new ArrayList();
    for (int[] neighbor : graph[currentState.id]) {
      int nextNodeID = neighbor[0];
      int distToNextNode = dist[currentState.id] + neighbor[1];
      nextStates.add(new State(nextNodeID, distToNextNode));
    }
     
    for (State nextState : nextStates) {
      if (isSelected[nextState.id]) continue;
      if (dist[nextState.id] > nextState.distFromStart) {
        dist[nextState.id] = nextState.distFromStart;
        pq.add(nextState);
      }
    }
  }

  // 如果到达这里，说明从 start 开始无法到达 end，返回 -1
  return -1;
}

// 辅助类, 用于优先队列
class State {
    // 图节点的 id
    int id;
    // 从 start 节点到当前节点的距离
    int distFromStart;

    State(int id, int distFromStart) {
        this.id = id;
        this.distFromStart = distFromStart;
    }
}
```

#### Bellman-Ford算法
```java
/**
  * @param s     起点
  * @param k     得到使用小于等于k条边的最短路径
  * @param edges 边集数组存储的图
  * @param n     顶点个数
  * @return
  */
int[] bellmanFord(int s, int k, List<Edge> edges, int n) {
  int[] dist = new int[n];
  Arrays.fill(dist, 0x3f3f3f3f);
  dist[s] = 0;
  // 执行k次
  for (int i = 0; i < k; i++) {
    int[] distClone = dist.clone();
    boolean flag = false;
    for (Edge edge : edges) {
      if (dist[edge.end] > distClone[edge.begin] + edge.weight) {
        dist[edge.end] = distClone[edge.begin] + edge.weight;
        flag = true;
      }
    }
    if (!flag) {
      return dist;
    }
  }
  return dist;
}

/**
  * 使用边集数组存储图
  */
class Edge {
  int begin, end, weight;

  Edge(int begin, int end, int weight) {
    this.begin = begin;
    this.end = end;
    this.weight = weight;
  }
}
```

#### SPFA算法
```java
/**
 * @param startState 起点状态
 * @param n          节点个数
 * @param dist       用于得到起点到其它顶点之间的最短距离
 * @param graph      图
 * @return 是否存在负环，返回true，则存在负环
 */
boolean spfa(State startState, int n, int[] dist, List<int[]>[] graph) {
  Queue<State> queue = new LinkedList<>();
  // 标记顶点是否正在队列中
  boolean[] used = new boolean[n];
  // 标记顶点进入了几次队列
  int[] num = new int[n];
  Arrays.fill(dist, Integer.MAX_VALUE);
  dist[startState.id] = 0; //第s个顶点到自身距离为0
  queue.add(startState); // 第s个顶点入队
  num[startState.id] = 1; // 表示第s个顶点已进入了1次队列
  used[startState.id] = true; // 表示第s个节点正在队列中

  while (!queue.isEmpty()) {
    State currentState = queue.poll();
    used[currentState.id] = false;

    List<State> nextStates = new ArrayList<>();
    for (int[] neighbor : graph[currentState.id]) {
      nextStates.add(new State(neighbor[0], dist[currentState.id] + neighbor[1]));
    }

    for (State nextState : nextStates) {
      if (dist[nextState.id] > nextState.distFromStart) {
        dist[nextState.id] = nextState.distFromStart;
        if (!used[nextState.id]) {
          queue.add(nextState);
          num[nextState.id]++;
          if (num[nextState.id] > n) {
            return false;
          }
          used[nextState.id] = true;
        }
      }
    }
  }
  return false;
}

// 辅助类, 用于优先队列
class State {
    // 图节点的 id
    int id;
    // 从 start 节点到当前节点的距离
    int distFromStart;

    State(int id, int distFromStart) {
        this.id = id;
        this.distFromStart = distFromStart;
    }
}
```

## 搜索
### 二分查找
```java
/**
 * 二分查找转折点
 * f(left) = true
 * f(right) = false
 *
 * @param left  左边界下标
 * @param right 右边界下标
 * @return 转折点
 **/
int binarySearch(int left, int right) {
  while (left + 1 != right) {
    int mid = left + (right - left) / 2;
    if (f(mid)) {
      left = mid;
    } else if (!f(mid)) {
      right = mid;
    }
  }
  return left;
}

boolean f(int index) {
  // TODO
  return false;
}
```

## 数论
### 高斯消元法求行列式
```java
/**
 * 高斯消元法求行列式。复杂度O(n^3logn)。
 * 计算|mat|
 *
 * @param mat 行列式
 * @return 行列式值
 */
Integer det(Integer[][] mat) {
  int n = mat.length;
  int ret = 1;
  for (int i = 0; i < n; i++) {
    for (int j = i + 1; j < n; j++) {
      while (mat[j][i] != 0) {
        int t = mat[i][i] / mat[j][i];
        for (int k = i; k < n; k++) {
          mat[i][k] = ((mat[i][k] - mat[j][k] * t));
          int s = mat[i][k];
          mat[i][k] = mat[j][k];
          mat[j][k] = s;
        }
        ret = -ret;
      }
    }
    if (mat[i][i] == 0) {
      return 0;
    }
    ret = ret * mat[i][i];
  }
  return ret;
}
```

### 高斯消元法求行列式取模
```java
/**
 * 高斯消元法求行列式取模。复杂度O(n^3logn)。
 * 计算|mat| % m
 *
 * @param mat 行列式
 * @param m 模
 * @return 行列式值
 */
int detMod(Integer[][] mat, int m) {
  int n = mat.length;
  for (int i = 0; i < n; i++) {
    for (int j = 0; j < n; j++) {
      mat[i][j] %= m;
    }
  }
  long ret = 1;
  for (int i = 0; i < n; i++) {
    for (int j = i + 1; j < n; j++) {
      while (mat[j][i] != 0) {
        long t = mat[i][i] / mat[j][i];
        for (int k = i; k < n; k++) {
          mat[i][k] = (int) ((mat[i][k] - mat[j][k] * t) % m);
          int s = mat[i][k];
          mat[i][k] = mat[j][k];
          mat[j][k] = s;
        }
        ret = -ret;
      }
    }
    if (mat[i][i] == 0) {
      return 0;
    }
    ret = ret * mat[i][i] % m;
  }
  if (ret < 0) {
    ret += m;
  }
  return (int) ret;
}
```

### 求最大公因数
```java
/**
 * 求最大公因数(greatest common divisor)
 */
int gcd(int a, int b) {
  // 辗转相除
  return b ==0 ? a : gcd(b, a % b);
}
```

### 求最小公倍数
```java
/**
 * 求最小公倍数(Least Common Multiple)
 */
int lcm(int a, int b) {
  return a * b / gcd(a, b);
}
```

### 比较2个大数的大小
```java
/**
 * 比较2个大数的大小。
 *
 * @param str1 字符串表示的大数1
 * @param str2 字符串表示的大数2
 * @return 返回负数：str1小于str2；返回0：str1等于ste2；返回正数：str1大于str2
 */
int largeNumCompare(String str1, String str2) {
  // 首先比较字符串长度
  int lenDiff = str1.length() - str2.length();
  // 长度相等时比较字符串字典序大小
  if (lenDiff == 0) return str1.compareTo(str2);
  return lenDiff;
}
```

## 区间信息维护与查询
### 大小堆实现查找kth
```java
class FindKthByHeap {
  private int[] nums;
  // 所要找的第几大的元素
  int k;

  /**
   * 创建大根堆与小根堆。
   * 堆存储堆是元素的id。即nums的下标
   */
  Comparator<Integer> comparator = (a, b) -> nums[a] != nums[b] ? Integer.compare(nums[a], nums[b]) : a - b;
  TreeSet<Integer> maxHeap = new TreeSet<>(comparator.reversed());
  TreeSet<Integer> minHeap = new TreeSet<>(comparator);

  public FindKthByHeap(int[] nums, int k) {
    this.nums = nums;
    this.k = k;
  }

  /**
   * 往堆中添加元素
   */
  public void add(int itemId) {
    minHeap.add(itemId);
    maxHeap.add(minHeap.pollFirst());
    balance();
  }

  /**
   * 通过给定的元素id删除堆中对应的元素
   *
   * @param itemId 元素的id
   */
  public void remove(int itemId) {
    if (!maxHeap.remove(itemId)) {
      minHeap.remove(itemId);
    }
  }

  /**
   * @return 第k大元素的id
   */
  public int getKthItemId() {
    return maxHeap.first();
  }

  /**
   * @return 第k大元素
   */
  public int getKthItem() {
    return nums[maxHeap.first()];
  }


  /**
   * @return 第k+1大元素的id
   */
  public int getK1thItemId() {
    return minHeap.first();
  }

  /**
   * @return 第k+1大元素
   */
  public int getK1thItem() {
    return nums[minHeap.first()];
  }

  /**
   * 维持大根堆元素个数小于等于k
   */
  private void balance() {
    while (maxHeap.size() > k) {
      minHeap.add(maxHeap.pollFirst());
    }
  }

  }
```

### 一维ST表
```java
class ST {
  // F[i][j]: 表示[i, i+2^j-1]区间的最值
  int[][] F;

  public ST(int[] nums) {
    int n = nums.length;
    int k = (int) (Math.log(n) / Math.log(2));
    // 初始化F数组
    F = new int[n][k + 1];
    for (int i = 0; i < n; i++) {
      F[i][0] = nums[i];
    }
    for (int j = 1; j <= k; j++) {
      for (int i = 0; i < n - (1 << j) + 1; i++) {
        F[i][j] = Math.max(F[i][j - 1], F[i + (1 << (j - 1))][j - 1]);
      }
    }
  }

  // 求区间[l..r]的最值
  int query(int l, int r) {
    if (l > r) {
      // TODO
    }
    int k = (int) (Math.log(r - l + 1) / Math.log(2));
    return Math.max(F[l][k], F[r - (1 << k) + 1][k]);
  }

}
```

### 二维ST表
```java
class ST {
  // F[r][i][j]: 表示第r行的[i, i+2^j-1]区间的最大值
  int F[][][];

  public ST(int[][] nums) {
    int n = nums[0].length;
    int k = (int) (Math.log(n) / Math.log(2));
    int row = nums.length;
    F = new int[row][n][k + 1];
    for (int r = 0; r < row; r++) {
      for (int c = 0; c < n; c++) {
        F[r][c][0] = nums[r][c];
      }
      for (int j = 1; j <= k; j++) {
        for (int i = 0; i < n - (1 << j) + 1; i++) {
          F[r][i][j] = Math.max(F[r][i][j - 1], F[r][i + (1 << (j - 1))][j - 1]);
        }
      }
    }
  }

  /**
   * @param row    矩阵左上顶点位于的行
   * @param col    矩阵左上顶点位于的列
   * @param width  矩阵宽度（即一行元素的个数）
   * @param height 矩阵高度（即一列元素的个数）
   * @return 矩阵范围内的最值
   */
  int query(int row, int col, int width, int height) {
    int max = Integer.MIN_VALUE;
    for (int r = row; r < height + row; r++) {
      int k = (int) (Math.log(width) / Math.log(2));
      // 右边界
      int rightCol = col + width - 1;
      max = Math.max(max, Math.max(F[r][col][k], F[r][rightCol - (1 << k) + 1][k]));
    }
    return max;
  }
}
```

### 最近公共祖先LCA
#### 只需要求两个节点的LCA
```java
class LCA {
  // F[i][j]表示从i节点向上走2^j步
  int F[][];
  // 存储节点的深度
  int[] dep;
  // 使用邻接表来存储树
  List<Integer>[] tree;
  // 最多可以跳2^k步
  int k;

  /**
   * @param root 树的根节点
   */
  public LCA(List<Integer>[] tree, Integer root) {
    this.tree = tree;
    int n = tree.length;
    dep = new int[n];
    k = (int) (Math.log(n) / Math.log(2));
    F = new int[n][k + 1];
    // 初始化
    dep[root] = 1;
    dfs(root);
  }

  /**
   * @param v 当前节点
   */
  void dfs(int v) {
    for (int i = 1; (1 << i) <= dep[v]; i++) {
      F[v][i] = F[F[v][i - 1]][i - 1];
    }
    // 遍历当前当前节点的子节点
    for (int child : tree[v]) {
      dep[child] = dep[v] + 1;
      F[child][0] = v;
      dfs(child);
    }
  }

  /**
   * 查询x节点与y节点的最近公共祖先
   */
  int getLCA(int x, int y) {
    if (dep[x] < dep[y]) {
      int temp = x;
      x = y;
      y = temp;
    }
    for (int i = k; i >= 0; i--) {
      if (dep[F[x][i]] >= dep[y]) {
        x = F[x][i];
      }
      if (x == y) {
        return x;
      }
    }
    for (int i = k; i >= 0; i--) {
      if (F[x][i] != F[y][i]) {
        x = F[x][i];
        y = F[y][i];
      }
    }
    return F[x][0];
  }

}
```

#### 扩展成要求任何两点之间的距离
```java
class LCA {
  // F[i][j]表示从i节点向上走2^j步
  int F[][];
  // 存储节点的深度
  int[] dep;
  // dist[i]表示表示节点i到根节点的距离
  int[] dist;
  // 使用邻接表来存储树
  List<int[]>[] tree;
  // 最多可以跳2^k步
  int k;

  public LCA(List<int[]>[] tree, Integer root) {
    this.tree = tree;
    int n = tree.length;
    dep = new int[n];
    dist = new int[n];
    k = (int) (Math.log(n) / Math.log(2));
    F = new int[n][k + 1];
    // 初始化
    dep[root] = 1;
    dfs(root);
  }

  /**
   * @param v 当前节点
   */
  void dfs(int v) {
    for (int i = 1; (1 << i) <= dep[v]; i++) {
      F[v][i] = F[F[v][i - 1]][i - 1];
    }
    for (int[] child : tree[v]) {
      dep[child[0]] = dep[v] + 1;
      dist[child[0]] = dist[v] + child[1];
      F[child[0]][0] = v;
      dfs(child[0]);
    }
  }

  /**
   * 查询x节点与y节点的最近公共祖先
   */
  int getLCA(int x, int y) {
    if (dep[x] < dep[y]) {
      int temp = x;
      x = y;
      y = temp;
    }
    for (int i = k; i >= 0; i--) {
      if (dep[F[x][i]] >= dep[y]) {
        x = F[x][i];
      }
      if (x == y) {
        return x;
      }
    }
    for (int i = k; i >= 0; i--) {
      if (F[x][i] != F[y][i]) {
        x = F[x][i];
        y = F[y][i];
      }
    }
    return F[x][0];
  }

  /**
   * 查询x节点与y节点的之间的距离
   */
  int getDist(int x, int y) {
    int lac = getLCA(x, y);
    return dist[x] + dist[y] - 2 * dist[lac];
  }

}
```

### 树状数组
#### 模版
```java
class BIT {
  int[] a, c;

  public BIT(int[] nums) {
    int n = nums.length;
    a = new int[n];
    c = new int[n + 1];
    for (int i = 0; i < n; i++) update(i, nums[i]);
  }

  // 更新a[i]为val
  public void update(int i, int val) {
    int diff = val - a[i];
    a[i] = val;
    for (i++; i < c.length; i += (i & -i)) {
      c[i] += diff;
    }
  }

  // 求a[0...i]之和
  public int preSum(int i) {
    int sum = 0;
    for (i++; i > 0; i -= (i & -i)) sum += c[i];
    return sum;
  }
}
```

### 线段树
#### zkw线段树
```java
class SegmentTree {
  int n;
  int[] st;

  public SegmentTree(int[] nums) {
    n = nums.length;
    st = new int[2 * n];
    for (int i = n; i < n * 2; i++) st[i] = nums[i - n];
    for (int i = n - 1; i > 0; i--) st[i] = st[2 * i] + st[2 * i + 1];
  }

  // 将nums[i]更新为val
  void update(int i, int val) {
    int diff = val - st[i + n];
    for (i += n; i > 0; i /= 2) st[i] += diff;
  }

  // 求nums[i..j]之和
  int sumRange(int i, int j) {
    int res = 0;
    for (i += n, j += n; i <= j; i /= 2, j /= 2) {
      // s[i]是右子节点
      if (i % 2 == 1) res += st[i++];
      // s[j]是左子节点
      if (j % 2 == 0) res += st[j--];
    }
    return res;
  }
}
```

#### 基于tree的线段树
```java
class Node {
  int start, end, sum;
  Node left, right;

  Node(int start, int end) {
    this.start = start;
    this.end = end;
  }
}

class SegmentTree {
  int[] nums;
  Node root;

  public SegmentTree(int[] nums) {
    this.nums = nums;
    this.root = buildTree(nums, 0, nums.length - 1);
  }

  private Node buildTree(int[] nums, int start, int end) {
    if (start > end) return null;
    Node node = new Node(start, end);
    if (start == end) {
      node.sum = nums[start];
    } else {
      int mid = start + (end - start) / 2;
      node.left = buildTree(nums, start, mid);
      node.right = buildTree(nums, mid + 1, end);
      node.sum = node.left.sum + node.right.sum;
    }
    return node;
  }

  // 更新nums[i]为val
  public void update(Node node, int i, int val) {
    if (node.start == node.end) {
      node.sum = val;
      return;
    }
    int mid = node.start + (node.end - node.start) / 2;
    if (i <= mid) update(node.left, i, val);
    else if (i > mid) update(node.right, i, val);
    node.sum = node.left.sum + node.right.sum;
  }

  // 求nums[start...end]之和
  public int sumRange(Node node, int start, int end) {
    if (start > end) return 0;
    if (node.start == start && node.end == end) return node.sum;
    int mid = node.start + (node.end - node.start) / 2;
    if (end <= mid) return sumRange(node.left, start, end);
    else if (start > mid) return sumRange(node.right, start, end);
    else return sumRange(node.left, start, mid) + sumRange(node.right, mid + 1, end);
  }

}
```

## 双指针
### 滑动窗口
```java
void slidingWindow(int[] nums) {
  // 为左闭右开区间，即[left, right)
  int left = 0, right = 0;

  while (right < nums.length) {
    //增大窗口
    right++;
    // TODO 根据窗口内容进行处理

    // 缩小窗口
    while (left <= right && windowNeedsShrink(left, right)) {
      left++;
      // TODO 根据窗口内容发生的变化进行处理
    }

  }
}

// 判断左侧窗口是否要收缩
boolean windowNeedsShrink(int left, int right) {
  // TODO
  return false;
}
```

## 动态规划
### 最长公共子序列
```java
/**
 * 求s1与s2的最长公共子序列的长度
 */
public int lcs(String s1, String s2) {
  int s1Length = s1.length();
  int s2Length = s2.length();
  int[][] dp = new int[s1Length + 1][s2Length + 1];
  for (int i = 0; i < s1Length; i++) {
    for (int j = 0; j < s2Length; j++) {
      if (s1.charAt(i) == s2.charAt(j)) {
        dp[i + 1][j + 1] = dp[i][j] + 1;
      } else {
        dp[i + 1][j + 1] = Math.max(dp[i][j + 1], dp[i + 1][j]);
      }
    }
  }
  return dp[s1Length][s2Length];
}
```

# java算法小知识点
## `List<int[]>[]`初始化
```java
List<int[]>[] graph = new ArrayList[n];

// 错误写法
Arrays.fill(graph, new ArrayList()); // 这个语句会使得graph数组中的每个元素都指向的是同一地址

// 正确写法
for (int i = 0; i < n; i++) {
  graph[i] = new ArrayList();
}
```

## `List<int[]>`转`int[][]`
```java
List<int[]> res = new ArrayList<>();
res.add(new int[]{1, 2});
res.add(new int[]{22, 56});

int[][] nums = res.toArray(new int[0][0]);
```

