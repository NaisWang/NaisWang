# java基础
## 什么是字节码，采用字节码的好处
字节码：java经过虚拟机编辑器编译后产生的文件(即扩展为.class的文件)，它不面向任何特定的处理器，只面向虚拟机
采用字节码的好处：Java语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以Java程序运行时比较高效，而且，由于字节码并不专对一种特定的机器，因此，Java程序无须重新编译便可在多种不同的计算机上运

## java中的编译器和解释器
Java中引入了虚拟机的概念，即在机器和编译程序之间加入了一层抽象的虚拟机器。这台虚拟的机器在任何平台上都提供给编译程序一个的共同的接口。编译程序只需要面向虚拟机，生成虚拟机能够理解的代码，然后由解释器来将虚拟机代码转换为特定系统的机器码执行。在Java中，这种供虚拟机理解的代码叫做字节码（即扩展为.class的文件），它不面向任何特定的处理器，只面向虚拟机。每一种平台的解释器是不同的，但是实现的虚拟机是相同的。Java源程序经过编译器编译后变成字节码，字节码由虚拟机解释执行，虚拟机将每一条要执行的字节码送给解释器，解释器将其翻译成特定机器上的机器码，然后在特定的机器上运行，这就是上面提到的Java的特点的编译与解释并存的解释。

**流程：**
java源代码 --> 编译器 --> jvm可执行的java字节码(即虚拟指令) --> jvm --> jvm中解释器 --> 机器码

## java和C++的区别
- 都是面向对象的语言，都支持封装、继承和多态
- java不提供指针来直接访问内存，程序内存更加安全
- java的类是单继承的，c++支持多继承；虽然java的类不可以多继承，但是接口可以多继承
- java有自动内存管理机制，不需要程序员手动释放无用内存

## java中的数据类型与类型转换

![](https://raw.githubusercontent.com/NaisWang/images/master/20220409123915.png)

Java基本类型基本： byte,short,char  <  int  <  long  <  float  <  double
表达式中的类型会自动提升到表达式中类型最高的一级

java基本类型中基本高的不能自动转换为级别低的， 如果不进行强转，则会报错。
使用`-=`, `+=`, `/=`, `%=`会自动完成完成强转转换，而`=`不行

java中的整形常量默认为int型，声明long型常量可以在后面加`l`或`L`
java中的浮点型常量默认为double型，声明float型常量可以在后面加`f`或`F`

### float f = 3.5是否正确
不正确

### short s1=1; s1=s1+1有错吗？ short s1=1; s1+=1有错吗
第一个有错，第二个没错

## Switch是否能作用在byte、long、string上
在java5以前，switch(expr)中，expr只能是byte、short、int、char。从java5开始，java中引入了枚举型，expr也可以是enum类型，从java7开始，expr还可以是String。
其实，expr准确的说，数值型的只可以是int类型，但是 byte, short, char 都可以自动转换成 int 类型，所以expr也可以是byte, short, char。当然了，对应的包装类也是可以自动转换，所以x也可以是包装类型的。
无论哪个版本的JDK，都是不支持 long，float，double，boolean 这个一定要注意！
因为在Float/Double上执行精确的相等匹配通常是个坏主意。

## Math.round(11.5)等于多少？Math.round(-11.5)等于多少
Math.round(11.5)的返回值是12， Math.round(-11.5)的返回值是-11。四舍五入的原理是在参数上加0.5后向下取整

## java采用何种编码方案？有何特点
采用Unicode， 它为每个字符指定一个唯一的数值，因此在任何的语言、平台、程序都可以放心的使用

## 访问修饰符
|访问修饰符|在什么地方能使用`实例.属性`来访问|是否能被子类继承|能否用来修饰外部类|
|--|--|--|--|
|public|所有类|能|能|
|protected|同一包内|能|不能|
|默认(缺省),与默认方法区分开|同一包内|不能|不能|
|private|同一类|不能|能|

## &和&&区别
首先&运算符有两种用法：一种是位运算符，另一种是逻辑运算符
而&&是短路运算符，逻辑与跟短路与的差别是非常巨大的，虽然二者都要求运算符左右两端的布尔值都是true整个表达式的值才是true。&&之所以称为短路运算，是因为如果&&左边的表达式的值是false，右边的表达式会被直接短路掉，不会进行运算。而逻辑运算符一定是会把两端都算一边
注意：`|`的`||`的区别也是如此
```java
public static void main(String[] args){
  int a = 10;
  int b =1;
  System.out.println(a > 1 | ++b >= 2);//true
  System.out.println(b); //2
}
```

## java有没有goto
goto是java中的保留字，在目前版本中的java没有使用

## final有什么用
- 被final修饰的类不可以被继承
- 被final修饰的方法不可以被重写
- 被final修饰的变量不可以被改变，被final修饰不可变的是变量的引用，而不是引用指向的内容，引用指向的内容是可以改变的

## 抽象类能使用final修饰吗？
不能，定义抽象类就是让其他类继承的，如果定义为final该类就不能被继承，这样彼此就会产生矛盾，所以final不能修饰抽象类

## 对象实例域对象引用的区别
对象引用是指向对象实例的

## 内部类
广义上的内部类可以分为下面四种：
- 成员内部类
- 静态内部类
- 方法(局部)内部类
- 匿名内部类

### 成员内部类
- 在一个类中除了可以定义成员变量、成员方法，还可以定义类，这样的类就被称为成员内部类，这个类所在的类称为外部类
- 成员内部类可以访问外部类的所有成员，外部类要访问成员内部类的成员，必须要创建一个成员内部类的对象，再通过指向这个对象的引用来访问
- 当成员内部类拥有和外部类同名的成员变量或者方法时，在成员内部类中，默认情况下访问的是成员内部类的成员
- 如果访问外部类的同名成员，需要以`外部类.this.成员变量/方法`形式来访问
- 成员内部类是依附外部类而存在的，如果要创建成员内部类的对象，前提是必须存在一个外部类的对象
- 创建成员内部类对象的三种方法
```java
// 第一种
Outer.Inner in = new Outer().new Inner();

//第二种
Outer out = new Outer();
Outer.Inner in = out.new Inner();

//第三种
Outer out = new Outer();
Outer.Inner in = out.getInnerInstance();
```

### 静态内部类
- 可以使用static关键字来修饰一个成员内部类，此时就称为静态内部类。它可以在不创建外部类对象的情况下被实例化，创建静态内部类对象的具体语法格式如下
```java
Outer.Inner in = new Outer.Inner();
```
- 静态内部类只能访问外部类的静态成员
- 静态内部类中可以定义静态成员，而非静态内部类中不能定义静态成员

### 方法内部类
- 方法内部类是在成员方法中定义的类，只能在当前方法中被使用
- 方法内部类对象不能使用该内部类所在方法中的非final局部变量, 但注意，在jdk1.7之前需要手动将方法内部类使用的变量设置为final, 而在jdk1.7之后，jvm会自动将其设置为final, 而不需要手动添加final

### 匿名内部类
- 匿名内部类就是没有名字的方法内部类，不使用关键字class、extends、implements没有构造方法
- 匿名内部类必须要继承一个父类或者实现一个接口，没有class关键字，直接使用new来生成一个隐式的对象引用
- 一定是在new的后面，用其隐含实现一个接口或者继承一个类 


## 重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？
方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。
- 重载：发生在同一个类中，方法名相同参数列表不同（参数类型不同、个数不同、顺序不同），与方法返回值和访问修饰符无关，**即重载的方法不能根据返回类型进行区分**
- 重写：发生在父子类中，方法名、参数列表必须相同，返回值小于等于父类，抛出的异常小于等于父类，访问修饰符大于等于父类（里氏代换原则）；如果父类方法访问修饰符为private则子类中就不是重写。

## BIO，NIO，AIO有什么区别？
- BIO: BlockIO同步阻塞式IO，就是我们平常使用的传统I0，它的特点是模式简单使用方便，并发处理能力低。
- NIO:Non IO同步非阻塞IO，是传统IO的升级，客户端和服务器端通过Channel（通道）通讯，实现了多路复用。
- AIO：AsynchronousIO是NIO的升级，也叫NIO2，实现了异步非堵塞IO，异步IO的操作基于事件和回调机制。

## String为什么是不可变的
简单来说就是String类利用了final修饰的char类型数组存储字符

## 是否可以继承 String类
String类是final类，不可以被继承。

## 如何将字符串反转
使用StringBuilder或者stringBuffer的reverse()方法

## String、StringBuilder与StringBuffer之间的区别
String不可变，支持并发操作，线程安全的，适合多线程中使用。
StringBufferd可变，支持并发操作，线性安全的，适合多线程中使用。
StringBuilder可变，不支持并发操作，线性不安全的，不适合多线程中使用

## 在使用HashMap的时候，用String做key有什么好处？
因为HashMap判重以及根据key获取value都是是根据key的HashCode(),equals()来判断的。
所以从String的源码出发来分析, 以下是源码：
```java
public int hashCode() {
        int h = hash;     //private int hash; // Default to 0
        if (h == 0 && value.length > 0) {
            char val[] = value;    //获得 String 对象底层的字符数组

            for (int i = 0; i < value.length; i++) {
                h = 31 * h + val[i];    //在计算的时候加的是 int 类型的 ascii 码
            }
            hash = h; //缓存该String的hashCode值
        }
        return h;
    }
```
从源码我们可以分析出用String做key的2个原因：
1. 因为String对象的 hashCode()值是根据String对象的内容的，并不是根据对象的地址。所以内容相同的两个String对象具有相同的散列码，并且经过 equals() 判断后返回值为true。所以我们能很容易的根据string内容来获取value。
2. 因为String是不可变的，且String中有个hash变量，它可以缓存hashCode，避免重复计算hashCode

## 获取键盘输入常用的两种方法
方法1： 通过Scanner
```java
Scanner input = new Scanner(System.in);
String s = input.nextLine();
input.close();
```
方法2: 通过BufferedReader
```java
BufferedReader input = new BufferedReader(new InputStreamReader(System.in));
String s = input.readLine();
```

## Session/Cookie区别？
Session存储在服务器罐，类型可以是任意的Java对象
Cookie存储在客户端、类型只能为字符串

## 多态
多态性是指同名的不同方法在程序中共存，多态性又被称为'一个名字，多个方法'
多态性的实现有如下两种：
- 重写父类中的方法
- 通过重载(重载是发生在同一个类中的)：即定义同一个类中的多个同名的不同方法来实现；


## HashMap 底层是如何实现的？
在 JDK 1.7 中 HashMap 是以数组加链表的形式组成的，JDK 1.8 之后新增了红黑树的组成结构，当链表大于 8 并且哈希表长度大于 64 时，链表结构会转换成红黑树结构

![](https://raw.githubusercontent.com/NaisWang/images/master/20220409123927.png)

JDK 1.8 之所以添加红黑树是因为一旦链表过长，会严重影响 HashMap 的性能，而红黑树具有快速增删改查的特点，这样就可以有效的解决链表过长时操作比较慢的问题

### 什么是加载因子？加载因子为什么是 0.75？
所谓的加载因子，也叫扩容因子或者负载因子，它是用来进行扩容判断的。
假设加载因子是0.5，HashMap初始化容量是16，当HashMap中有16 * 0.5=8个元素时，HashMap就会进行扩容操作。
而HashMap中加载因子为0.75，是考虑到了性能和容量的平衡。
由加载因子的定义，可以知道它的取值范围是(0, 1]。
- 如果加载因子过小，那么扩容门槛低，扩容频繁，这虽然能使元素存储得更稀疏，有效避免了哈希冲突发生，同时操作性能较高，但是会占用更多的空间。
- 如果加载因子过大，那么扩容门槛高，扩容不频繁，虽然占用的空间降低了，但是这会导致元素存储密集，发生哈希冲突的概率大大提高，从而导致存储元素的数据结构更加复杂（用于解决哈希冲突），最终导致操作性能降低。
-  还有一个因素是为了提升扩容效率。因为HashMap的容量（size属性，构造函数中的initialCapacity变量）有一个要求：它一定是2的幂。所以加载因子选择了0.75就可以保证它与容量的乘积为整数。 

### resize方法
在Java中，数组是无法自动扩容的，所以扩容的方法是使用一个新的数组代替已有的容量小的数组，简单说就是换一个更大的数组重新映射
**什么时候发生扩容？**
当HashMap中的元素个数超过数组大小 x 加载因子时，就会进行数组扩容，上文中我们知道加载因子默认值为0.75，也就是说，默认情况下，数组大小为16，那么当HashMap中元素个数超过16 x 0.75=12的时候，就把数组的大小扩展为2 x 16=32，即扩大一倍，然后重新计算每个元素在数组中的位置，而这是一个非常消耗性能的操作， 而JDK 1.8 在扩容时并没有像 JDK 1.7 那样，重新计算每个元素的哈希值，而是通过高位运算（e.hash & oldCap）来确定元素是否需要移动，这种方式更加高效
比如 key1 的信息如下：
key1.hash = 10 0000 1010
oldCap = 16 0001 0000
使用 e.hash & oldCap 得到的结果，高一位为 0，当结果为 0 时表示元素在扩容时位置不会发生任何变化，而 key 2 信息如下：
key2.hash = 10 0001 0001
oldCap = 16 0001 0000
这时候得到的结果，高一位为 1，当结果为 1 时，表示元素在扩容时位置发生了变化，新的下标位置等于原下标位置 + 原数组长度，如下图所示：

### HASHMAP之扰动函数和低位掩码
我们都知道，hashMap在实现的时候，为了寻找在数组上的位置，主要做了两件事
```java
int hash = hash(key);
int i = indexFor(key, table.length);
```
这两个方法详解如下

JDK8对扰动函数的修改，只进行了一次移位（又移16bit），再和key.hashCode()做异或，如图
```java
static final int hash(Object key){
    int h;
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}
```
这个散列值是不能直接拿来用的。用之前还要先做对数组的长度取模运算，得到的余数才能用来访问数组下标。源码中模运算是在这个indexFor( )函数里完成的。
```java
bucketIndex = indexFor(int h, table.length);
```
其中IndexFor代码
```java
static int indexFor(int h, int length){
    return h & (length - 1);
}
```
indexFor代码，正好解释了为什么HashMap的数组长度要取2的整次幂。因为这样（数组长度-1）正好相当于一个“低位掩码”。“与”操作的结果就是散列值的高位全部归零，只保留低位值，用来做数组下标访问。以初始长度16为例，16-1=15。2进制表示是00000000 00000000 00001111。和某散列值做“与”操作如下，结果就是截取了最低的四位值。

![](https://raw.githubusercontent.com/NaisWang/images/master/20220409123937.png)

但这时候问题就来了，这样就算我的散列值分布再松散，要是只取最后几位的话，碰撞也会很严重。更要命的是如果散列本身做得不好，分布上成等差数列的漏洞，恰好使最后几个低位呈现规律性重复，就无比蛋疼。
这时候“扰动函数”的价值就体现出来了，说到这里大家应该猜出来了。看下面这个图，

![](https://raw.githubusercontent.com/NaisWang/images/master/20220409123949.png)

右位移16位，正好是32bit的一半，自己的高半区和低半区做异或，就是为了混合原始哈希码的高位和低位，以此来加大低位的随机性。而且混合后的低位掺杂了高位的部分特征，这样高位的信息也被变相保留下来。
JDK 7做了4次右移，估计是边际效应的原因，JDK8就只做了一次右移。
另外 JDK8在链表长度超过8的时候，就使用红黑树做存储。这一改变大大优化了很多性能。

### HashMap 是如何导致死循环的
HashMap会导致死循环是在jdk1.7中，由于扩容时的操作是使用头插法，在多线程的环境下可能产生循环链表，由此导致了死循环。在jdk1.8中改为使用尾插法，避免了该死循环的情况。

![](https://raw.githubusercontent.com/NaisWang/images/master/20220409123959.png)

## ArrayList
ArrayList作为List的典型实现，完全实现了List的全部接口功能，它是基于数组实现的List类，它封装了一个`Object[]`类型的数组，长度可以动态的增长。通过无参数构造方法创建对象时，JDK1.7初始长度是10；JDK1.8中初始长度是0，在第一次添加元素时再给出长度10。 它默认创建一个长度为10的数组，当新添加的元素已经没有位置存放的时候, ArrayList就会自动进行扩容，扩容的长度为原来长度的1.5倍。它的线程是不安全的。

## java集合里有一个迭代器，为什么要设计出这个迭代器
首先使用迭代器适用性强，因为如果用for循环遍历，需要事先知道集合的数据结构，而且当换了一种集合的话代码不可重用要修改，不符合开闭原则。而Iterator是用同一种逻辑来遍历集合。其次使用Iterator可以在不了解集合内部数据结构的情况下直接遍历，这样可以使得集合内部的的数据不暴露。

## 防止表单重复提交的2种方式
**通过JavaScript屏蔽提交按钮（不推荐）**
通过js代码，当用户点击提交按钮后，屏蔽提交按钮使用户无法点击提交按钮或点击无效，从而实现防止表单重复提交。
ps：js代码很容易被绕过。比如用户通过刷新页面方式，或使用postman等工具绕过前段页面仍能重复提交表单。因此不推荐此方法。

**利用Session防止表单重复提交（推荐）**
实现原理：
服务器返回表单页面时，会先生成一个subToken保存于session，并把该subToen传给表单页面。当表单提交时会带上subToken，服务器拦截器Interceptor会拦截该请求，拦截器判断session保存的subToken和表单提交subToken是否一致。若不一致或session的subToken为空或表单未携带subToken则不通过。
首次提交表单时session的subToken与表单携带的subToken一致走正常流程，然后拦截器内会删除session保存的subToken。当再次提交表单时由于session的subToken为空则不通过。从而实现了防止表单重复提交。

## NoClassDefFoundError与ClassNotFoundException的区别
一个直观的区别是一个是异常，一个是错误，异常和错误的区别就可以先讲一波。

**ClassNotFoundException**
当应用尝试在类路径中用全限量名去加载某个类时，如果找你不到它的定义就会报CLassNotFoundException 。它是一个可检测异常。
通常出现在用Class.forName(), ClassLoader.loadClass()或 ClassLoader.findSystemClass()这三个方法加载类的时候。我们在使用反射的时候，要特别注意这个异常。

**NoClassDefFoundError**
NoClassDefFoundError是一种致命错误。
当JVM尝试通过new关键字创建一个类实例或者方法调用来加载一个类时找不到这个类的定义就会出现这个错误。
通常是编译时正常编译，但是运行时找不到这个类。
通常发生在执行动态代码块或者初始化静态字段时报了异常，从而导致类初始化失败而引发NoClassDefFoundError。

## 构造器（constructor）是否可被重写（override）
构造器不能被继承，因此不能被重写，但可以被重载。

## HashCode()与equals()的相关规定
如果两个对象调用equals()方法，返回true，那么规定这两个对象的HashCode()返回的值应该要相同
所以，equals方法被覆盖过，则hashcode方法也必须被覆盖

## 对象的相等与指向他们的引用相等，两者有什么不同？
对象的相等比的是内存中存放的内容是否相等而引用相等比较的是他们指向的内存地址是否相等。

## 值传递与引用传递
**值传递：**把实参的值传递给形参
**引用传递：**把实参的地址传递给形参，此时形参的地址为实参的地址

java中只有值传递

## import java和javax有什么区别
刚开始的时候JavaAPI所必需的包是java开头的包，javax当时只是扩展API包来说使用。然而随着时间的推移，javax逐渐的扩展成为JavaAPI的组成部分。但是，将扩展从javax包移动到java包将是太麻烦了，最终会破坏一堆现有的代码。因此，最终决定javax包将成为标准API的一部分。
所以，实际上java和javax没有区别。这都是一个名字。

# Mysql
## 批量向MySQL导入1000万条数据的优化
1. 在事务中插入处理
将插入修改为
start transaction;
insert into tb1(id,name,age,sex) values(1,'khue',25,'m');
insert into tb1(id,name,age,sex) values(2,'green',24,'w');
commit;
在事务中可以提高数据的插入效率，因为在进行一个insert操作时，MySQL内部会建立一个事务，在事务内才能进行真正的插入处理操作，这样可以减少创建事务的消耗，让所有插入都在执行后才进行提交操作
2. 修改表的存储引擎InnoDB为MyISAM。(因为InnoDB中存在redo log日志，每次更新表的结果先写入redo log中，等redo log满了之后再写入磁盘而这个过程是会停止其他所有的事务)
3. 尽量顺序插入(存储引擎底层采用的数据结构是B+tree索引，如果每次插入记录都在索引的最后面，索引的定位效率很高，并且对索引调整较小；如果插入的记录在索引中间，则需要维护B+tree并且索引定位效率会下降，数据量较大时会有频繁的磁盘操作)
4. 合并SQL语句
一条SQL插入一条数据
insert into tb1(id,name,age,sex) values(1,'khue',25,'m');
insert into tb1(id,name,age,sex) values(2,'green',24,'w');
一条SQL插入多条数据
insert into tb1(id,name,age,sex) values(1,'khue',25,'m'),(2,'green',24,'w');
合并SQL语句能够提高程序的插入效率(原因在于合并后日志量减少了，降低日志刷盘的数据量和频率)，也能减少SQL语句解析的次数，减少网络传输的IO

# 计网
## TCP与UDP的区别
UDP：无连接， 提供最大努力的交互，即不保证可靠交付，面向报文的，有差错直接丢弃。 执行速度快、实时性好，如dns、实时传输协议、小文本传输协议
TCP：面向字节流的，不提供广播或组播服务（ipv6没有广播地址，由组播代替），适用于可靠性更重要的场合，如文件传输协议、http
