# 病毒，木马，蠕虫的区别
首先病毒，木马，蠕虫统称为电脑病毒。病毒（包含蠕虫）的共同特征是自我复制、传播、破坏电脑文件，对电脑造成数据上不可逆转的损坏。而木马独有特征是伪装成正常应用骗取用户信任而入侵，潜伏在电脑中盗取用户资料与信息。
- 什么是病毒：
病毒是编制者在计算机程序中插入的破坏计算机功能或者数据的代码，能影响计算机使用，能自我复制的一组计算机指令或者程序代码。
 
- 什么是木马：
木马也称木马病毒，是指通过特定的程序来控制另一台计算机。与一般的病毒不同，它不会自我繁殖，也专并不“刻意”地去感染其他文件，它通过将自身伪装吸引用户下载执行，向施种木马者提供打开被种主机的门户，使施属种者可以任意毁坏、窃取被种者的文件，甚至远程操控被种主机。
 
- 什么是蠕虫病毒：
蠕虫病毒一种能够利用系统漏洞通过网络进行自我传播的恶意程序。它不需要附着在其他程序上，而是独立存在的。当形成规模、传播速度过快时会极大地消耗网络资源导致大面积网络拥塞甚至瘫痪。

# 加密、数字签名和数字证书
## 加密
### 什么是加密
加密就是对明文数据按某种特殊算法进行处理，使其成为不可读的一段代码，通常称为“密文“， 密文通过”密钥“解密后还原出原来的明文，通过这样的途径可以达到保护数据不被非法人窃取、阅读的目的。
定义简单吧？那来看个题，考虑以下哪些属于加密方法：
- AES
- RSA
- MD5
- BASE64
- SM4
这几种都是日常开发中常用的数据编码技术，但是只有 AES、RSA、SM4 才能算是加密方法。
为什么呢？一个区分的简单方法就是看编码后的数据是否还能还原，能还原的是加密。
MD5 实际上是对数据进行有损压缩，无论数据有多长，1KB、1Mb 还是 1G，都会生成固定 128 位的散列值，并且 MD5 理论上是不可能对编码后的数据进行还原的，即不可逆。
MD5 因为其具有不可逆性、单向恒定性（相同的数据多次计算值不变）被广泛应用于文件完整性验证、口令加密以及接下来会讲到的数字签名中。
至于 BASE64 是否算做加密方法，仁者见仁。在这里不下结论，因为 BASE64 编码不需要密钥，且编码后的字符串任何人都可以解码出原串，所以一般不认为是加密方法。BASE64 常用来做转码，把二进制字节序列转化为 ASCII 字符序列。

### 加密算法的分类
1976年以前，所有的加密方法都是同一种模式：
```
（1）甲方选择某一种加密规则，对信息进行加密；
（2）乙方使用同一种规则，对信息进行解密。
```
由于加密和解密使用同样规则（简称"密钥"），这被称为**对称加密算法**（Symmetric-key algorithm）。
这种加密模式有一个最大弱点：甲方必须把加密规则告诉乙方，否则无法解密。保存和传递密钥，就成了最头疼的问题。

1976年，两位美国计算机学家Whitfield Diffie 和 Martin Hellman，提出了一种崭新构思，可以在不直接传递密钥的情况下，完成解密。这被称为"Diffie-Hellman密钥交换算法"。这个算法启发了其他科学家。人们认识到，加密和解密可以使用不同的规则，只要这两种规则之间存在某种对应关系即可，这样就避免了直接传递密钥。

这种新的加密模式被称为**非对称加密算法**。
```
（1）乙方生成两把密钥（公钥和私钥）。公钥是公开的，任何人都可以获得，私钥则是保密的。
（2）甲方获取乙方的公钥，然后用它对信息加密。
（3）乙方得到加密后的信息，用私钥解密。
```
**如果公钥加密的信息只有私钥解得开，那么只要私钥不泄漏，通信就是安全的。**
公钥和私钥通常有可以互相加解密的特性：
- 将原始信息用公钥加密后，**只能用私钥解密，不能用公钥解密；**
- 将原始信息用私钥加密后，通常可以使用公钥解密。

1977年，三位数学家Rivest、Shamir 和 Adleman 设计了一种算法，可以实现非对称加密。这种算法用他们三个人的名字命名，叫做**RSA算法**。从那时直到现在，RSA算法一直是最广为使用的"非对称加密算法"。毫不夸张地说，只要有计算机网络的地方，就有RSA算法。
这种算法非常可靠，密钥越长，它就越难破解。根据已经披露的文献，目前被破解的最长RSA密钥是768个二进制位。也就是说，长度超过768位的密钥，还无法破解（至少没人公开宣布）。因此可以认为，1024位的RSA密钥基本安全，2048位的密钥极其安全。

### 举例子
为了讲这个故事，小北请来了密码学中常用的学术情侣，Alice 和 Bob，以及窃听者代表 Eve。
我们从 Alice、Bob 约会的故事展开，来讲讲其中暗藏着哪些危机，又是如何一步步化解的。
九月，一个夜黑风高的晚上，Bob 想约 Alice 出来玩，于是给 Alice 发了一封邮件：
<img src="https://gitee.com/NaisWang/images/raw/master/img/20211019170415.png" width="700px"/>

但我们都知道网络是不可信的，并且由于消息在网络中是明文传输的，所以黑客可以轻易的截获、篡改甚至冒充 Bob。
来，我们看看黑客 Eve 是怎么干的：
<img src="https://gitee.com/NaisWang/images/raw/master/img/20211019170447.png" width="700px"/>

瞧，Eve 轻易的拿到了邮件内容 （窃听），并且修改了邮件内容 （篡改），甚至说他可以随时冒充 Bob 给 Alice 发送邮件 （伪装）。
如果上图中 Eve 伪造的内容被 Alice 接收到了，那么后果可想而知。
现实世界中，我们每天都在通过网络进行聊天、转账、浏览不存在网站。
如果都是这样明文传输数据，显然毫无安全感。

既然我们不能明文传输，那么 Bob 和 Alice 提前商量好密钥，使用对称加密对邮件内容加密不就好了~
<img src="https://gitee.com/NaisWang/images/raw/master/img/20211019170519.png" width="700px"/>

现在 Bob 发送的邮件都使用和 Alice 提前商量好的密钥加密后再传输。
由于没有密钥，Eve 就算截获到数据也无法获取邮件的内容，也没法篡改和冒充 Bob。
因为篡改后的数据必须使用密钥再次加密 Alice 才能正确解密。
那么只要 Bob 和 Alice 能够保证 密钥不泄露，整个通信就是安全的。
如果密钥泄露，被中间人截获，那么就等同于明文通信。
所以我们不能把安全性寄托在人上面。
并且这里也存在一个问题，如果两个人不能线下见面， 如何在网上安全的交换密钥呢？
这似乎是无解的，因为交换密钥的时候我们必须明文通信，不然对方根本看不懂。但是明文交换即意味着可能泄露。
但是别忘了我们的密码学工具箱里还有一个好东西— 「非对称加密」。
Bob 和 Alice 各自生成一对公私钥，因为公钥本来就是公开的，即可以被任何人获取，所以可以通过网络明文交换公钥。
然后使用公钥加密邮件内容后发送给对方，接收者使用自己的私钥即可解密。完美~

来看看，在非对称加密体系下，Bob 如何给 Alice 发消息的。
首先 Alice 需要先生成一对公私钥，私钥只能 Alice 自己知道，公钥是可以让任何人都知道的，因此可将公钥直接发送给 Bob，就算被截获也无所谓。
<img src="https://gitee.com/NaisWang/images/raw/master/img/20211019170611.png" width="700px"/>

Bob 使用 Alice 的公钥加密邮件内容，加密后的内容只能由 Alice 的私钥解密，所以就算 Eve 截获也是徒劳。
反之，如果 Alice 想给 Bob 回信，就需要用 Bob 的公钥加密后发送。
这就解决了密钥交换问题，也保证了邮件内容不会泄露。也就是说现在可以防窃听。

## 数字签名
不知道你注意到没有，这里也存在另外一个问题：Eve 也可以使用 Alice 的公钥冒充 Bob 给 Alice 发邮件啊，因为 Alice 的公钥本来就是公开的，任何人都可以获得。 
由于 Eve 也可以获得 Alice 公钥，所以没法防止 Eve 伪造和篡改，并且对于 Alice 而言，她无法分辨出邮件到底是 Eve 发的还是 Bob。
所以这个问题的本质就是 「Alice 如何确认邮件来自于 Bob」。
那么在生活中，我们如何做这件事呢？
那就是让 Bob 在纸上签名并且按手印，因为指纹和字迹是 Bob 独有的，其它人很难伪造。
所以我们需要在计算机中引入类似的机制：
即只有 Bob 自己能够产生的独一无二的标志，并且其它人能够验证这个标志确实是属于 Bob的。
这就是我们今天要讲的主题—「数字签名」。
还记得什么是 Bob 独有的吗？
对，就是 Bob 自己的私钥，Bob 用自己的私钥对邮件内容计算一个「签名」，将「签名」和邮件内容一起发送出去，接受者 Alice 可以使用 Bob 的公钥验证这个签名是否正确，这就叫「验签」。
如果不是 Bob 的私钥计算的签名，那么 Alice 用 Bob 公钥验签将会出错。
<img src="https://gitee.com/NaisWang/images/raw/master/img/20211019170817.png" width="700px"/>

可以看到， Eve 试图使用自己的私钥计算签名然后发送给 Alice， 但是 Alice 使用 Bob的公钥进行验签时将会出错！
那么 Eve 可能篡改内容并冒充 Bob 的签名吗？不可能！因为内容发生改变时，对应的签名也需要重新计算，而签名的生成依赖于私钥，只要 Bob 的私钥不泄露，签名就不会被冒充。
啊啥？你说万一私钥泄露了怎么办？那就当我没说......
所以使用数字签名，我们能够鉴别消息的发送者，也就是说黑客无法伪装发送者进行发送数据，也无法篡改。

>注意：
可以看出我们这里数据是明文传输的，存在窃听风险。但是我们为了阐述数字签名机制是如何运转的，故意将保证信息机密性的机制省略了。
如果想要保证数据的机密性，我们常见的做法是，通信双方通过非对称加密安全交换对称加密的密钥，后续通信过程的数据都使用对称加密保证数据机密性。
并且「签名」的作用本身也不是用来保证数据的机密性，而是用于验证数据来源的防止数据被篡改的，也就是确认发送者的身份。

一般而言，我们不会直接对数据本身直接计算数字签名，为什么呢？
因为数字签名属于非对称加密，非对称加密依赖于复杂的数学运算，包括大数乘法、大数模等等，耗时比较久。
如果数据量大的时候计算数字签名将会比较耗时，所以一般做法是先将原数据进行 Hash 运算，得到的 Hash 值就叫做「摘要」。
「摘要」就像人的指纹一样，可以代表一个人，只要内容发生了改变，计算出来的摘要也应该变化。
「摘要」最好是不可逆转的，一般使用开头提到的 MD5 作为 Hash 函数，MD5 输出的结果固定位 128 位。

>为什么「摘要」最好是不可逆转的？
因为既然 Alice 可以用 Bob 公钥解开签名，那么理论上其它人，比如 Eve 也可以使用 Bob 公钥解开签名拿到数据。
所以我们最好对数据的「摘要」进行签名，这样，Eve 就算解开签名，拿到的也是「摘要」，如果摘要是不可逆转的，也就是无法从摘要反推出原文，也就达到了保密的作用。

发送者使用私钥对「摘要」计算数字签名。那么接收者如何验证呢？
<img src="https://gitee.com/NaisWang/images/raw/master/img/20211019171004.png" width="700px"/>

接受者 Alice 收到后，取下数字签名，同时用 Bob 的公钥解密，得到「摘要1」，证明确实是 Bob 发的。
( 画外音：如果使用 Bob 的公钥验证签名出错，那么签名一定不是 Bob 的私钥生成的）
再对邮件内容使用相同的散列函数计算「摘要2」，与上面得到的「摘要1」进行对比，两者一致就说明信息未被篡改。
这样两步分证明发送者身份和保证数据未被篡改。

Bob 和 Alice 现在可以依赖于对称加密进行保密通信，也可以依赖于数字签名验证消息是否是对方发送的。
但是这一切的根基是建立在 Alice 持有的公钥确实是 Bob的，反之亦然。
什么意思呢？
试想，Eve 如果将自己的公钥冒充 Bob 发送给 Alice，然后 Alice 保存了下来，那以后凡是 Bob 发送的消息，反而会验证签名失败，被当做冒充者。
那你可能会问，为什么 Eve 可以将自己的公钥发送给 Alice，而 Alice 毫不知情呢？
<img src="https://gitee.com/NaisWang/images/raw/master/img/20211019171043.png" width="700px"/>


看！我们又回到了最初的起点，只不过这次被篡改的是公钥，之前是消息本身。
因为 Bob 的公钥是直接通过网络发送给 Alice的，所以 Eve 才可以在这一步做手脚，进行篡改，将自己的公钥冒充 Bob 发送给 Alice，也就是发送公钥这一步没有做到：
- 防篡改
- 防冒充
防篡改怎么和防冒充怎么实现的呢？
我们前面讲了，就是靠数字签名！ 但是数字签名需要接受者持有发送者公钥，才能进行验签。
而我们现在处理的是分发公钥这一步，所以.......死锁了。这像是先有鸡还是先有蛋的问题
现在的问题就是「Bob 无法证明它自己是 Bob」。
这个是不是似曾相识，以前去办事的时候经常被要求出具「我妈是我妈」这类证明。但是我们自己说“我妈就是我妈”，人家根本不会信呀，需要一个可信第三方出具证明，比如派出所。
那么「Alice 如何才能确认 Bob 发送给自己的公钥确实是 Bob 的，而没有被篡改？」
在只有 Alice 和 Bob 两人的情况下是没法验证的。
所以，我们这里也需要一个第三方帮 Bob证明 「Bob 的公钥就是 Bob 的公钥」，有点绕口令那感觉了~

## 数字证书
为了解决这个问题，就引入了「数字证书」，什么叫数字证书呢？

>百度百科：
数字证书是指在互联网通讯中标志通讯各方身份信息的一个数字认证，人们可以在网上用它来识别对方的身份。
因此数字证书又称为数字标识。数字证书对网络用户在交流中的信息和数据等以加密或解密的形式保证了信息和数据的完整性和安全性。

看了这个描述，是不是感觉还是云里雾里，还是我用大白话来说吧~
只要你理解了前面的数字签名，就能理解这里的数字证书，因为我把数字证书叫做「公钥的数字签名」。
为什么呢？我们引入数字证书的目的是为了保证公钥不被篡改，即使被篡改了也能识别出来。
而防篡改的方法就是数字签名，但是这个签名不能我们自己做，原因说过了，因为我们的公钥还没分发出去，别人无法验证。
所以只能找可信的第三方来帮我们签名，即证书颁布机构（CA），CA 会将：证书的颁布机构、有效期、公钥、持有者(subject)等信息用 CA 的私钥进行签名。
并且将签名结果和这些信息放在一起，这就叫做「数字证书」。
这样，Bob 就可以去 CA 申请一个证书，然后将自己的证书发给 Alice，那么 Alice 如何验证这个证书确实是 Bob的呢？
当然是使用 CA 的公钥进行验签。

>注意：
CA 的公钥也是需要使用证书来分发的，所以 Alice 的电脑必须安装 CA 的证书，证书里包含了 CA 的公钥。

收到 Bob 发过来的数字证书后，Alice 使用 CA 的公钥进行验证，验证通过即证明这确实是 Bob 证书，也就可以使用证书中包含的 Bob 的公钥，按照之前讨论的流程进行通信。
那么 Eve 是否可以在中途篡改 Bob 的证书呢？
答案是不行，因为证书的信息使用 CA 的私钥进行签名，只要 Eve 修改了任何一个 Bit 都会导致最后签名验证不通过。
那 Eve 可不可以修改证书信息后自己重新计算一次证书的数字签名呢？
也不行，因为证书的数字签名计算依赖于 CA 的私钥，Eve 是拿不到 CA 的私钥的。
如果拿到了，说明什么？整个世界都是不可信的。

### 数字证书长啥样
这是我电脑中的自带的证书：
<img src="https://gitee.com/NaisWang/images/raw/master/img/20211019171509.png" width="700px"/>

可以看到，包含了证书持有人的公钥和证书的签名。
另外，证书颁发机构是有层级关系的，下级 CA 的证书是需要由上级 CA 签名的。
换句话说一定存在根证书颁发机构，那么他们的证书是由谁签名的呢？
答案是自签，自己给自己认证。
这是我电脑中的一个自签的根证书颁发机构：
<img src="https://gitee.com/NaisWang/images/raw/master/img/20211019171543.png" width="700px"/>

为什么根证书可以自签，谁来保证安全？
你把钱存在银行，你会担心吗？我们基于对国家的信任，才信任银行，这就是信任链的基础！我们思考问题应该是分层的，如果不认可一个统一的基础，一直套娃下去，那么问题就无解。
那还有个问题，如何保证根证书的可靠性？
这是操作系统和浏览器预装的，由微软、苹果等操作系统厂商来选择根证书。

### 证书不可信？
那么什么情况下浏览器会提示 “证书不可信” 呢？
根据我们上面的分析，下面是可能的原因：
- 证书不是权威 CA 颁发; 有些企业为了贪图便宜使用盗版的证书，没有经过 CA 认证。也就是无法使用浏览器内置 CA 公钥进行验证。
- 证书过期; 上面说了，证书里有一项就是有效期，一般就是一年或者两年的时间。如果证书过期，那么浏览器就会提示“证书不可信”
- 证书部署错误; 可能是服务器证书部署出错，比如证书与域名不匹配，因为证书里有一项是持有人信息的。

好了，饶了一大圈，Bob 终于可以安全的向 Alice 发出前往红树林的邀请了~

## 总结
1. 加密与数字签名的区别?
加密是为了防止信息被泄露，而数字签名是为了防止信息被篡改

2. 非对称加密中公私钥都可以加密，那么什么时候用公钥加密，什么时候用私钥“加密” ？
加密场景，那么肯定希望只有我才能解密，别人只能加密。即**公钥加密，私钥解密**
签名场景，既然是签名，就希望只能我才能签名，别人只能验证。而能唯一确定是我的就是私钥。 即**私钥签名，公钥验签**

3. 什么是数字签名，数字签名的作用是什么？
数字签名就是使用私钥对数据摘要进行签名，并附带和数据一起发送。
可以起到防篡改、防伪装、防否认的作用。

4. 为什么要对数据的摘要进行签名，而不是直接计算原始数据的数字签名？
数据可能比较大，签名是使用非对称加密算法，比较耗时
防止第三方使用公钥解开签名后，拿到原始数据

5. 什么是数字证书，数字证书存在解决了什么问题？
数字证书就是由 CA 机构使用自己私钥，对证书申请者的公钥进行签名认证。
数字证书解决了如何安全分发公钥的问题，也奠定了信任链的基础。




# 常用的认证机制
## HTTP Basic Auth 
HTTP Basic Auth简单点说明就是每次请求API时都提供用户的username和password，简言之，Basic Auth是配合RESTful API使用的最简单的认证方式，只需提供用户名密码即可，但由于有把用户名密码暴露给第三方客户端的风险，在生产环境下被使用的越来越少。因此，在开发对外开放的RESTful APl时，尽量避免采用HTTP Basic Auth。
### Cookie Auth Cookie
认证机制就是为一次请求认证在服务端创建一个Session对象，同时在客户端的浏览器端创建了一个Cookie对象；通过客户端带上来Cookie对象来与服务器端的session对象匹配来实现状态管理的。默认的，当我们关闭浏览器的时候，cookie会被删除。但可以通过修改cookie 的expire time便cookie在一定时间内有效。
<img src="https://gitee.com/NaisWang/images/raw/master/img/20210412133827.png" width="700px"/>

## OAuth
OAuth（开放授权，Open Authorization）是一个开放的授权标准，允许用户让第三方应用访问该用户在某一web服务上存储的私密的资源（如照片，视频，联系人列表），而无需将用户名和密码提供给第三方应用。如网站通过微信、微博登录等，主要用于第三方登录。
OAuth允许用户提供一个令牌，而不是用户名和密码来访问他们存放在特定服务提供者的数据。每一个令牌授权一个特定的第三方系统（例如，视频编辑网站）在特定的时段（例如，接下来的2小时内）内访问特定的资源（例如仅仅是某一相册中的视频）。这样，OAuth让用户可以授权第三方网站访问他们存储在另外服务提供者的某些特定信息，而非所有内容。

这种基于OAuth的认证机制适用于个人消费者类的互联网产品，如社交类APP等应用，但是不太适合拥有自有认证权限管理的企业应用。

缺点：过重。

## Token auth
使用基于Token的身份验证方法，在服务端不需要存储用户的登录记录。大概的流程是这样的：
1. 客户端便用用户名跟密码请求登录
2. 服务端收到请求，去验证用户名与密码
3. 验证成功后，服务端会签发一个Token，再把这个Token发送给客户端
4. 客户端收到Token以后可以把它存储起来，比如放在Cookie里
5. 客户端每次向服务端请求资源的时候需要带着服务端签发的Token
6. 服务端收到请求，然后去验证客户端请求里面带着的Token，如果验证成功，就向客户端返回请求的数据

<img src="https://gitee.com/NaisWang/images/raw/master/img/20210412134501.png" width="700px"/>

`Token auth`比`http basic auth`更安全，比`Cookie Auth Cookes`更节约服务器资源，比OAuth更加轻量

**具体，Token Auth的优点（Token机制相对于Cookie机制又有什么好处呢？）：**
- 支持跨域访问：Cookie是不允许垮域访问的，这一点对Token机制是不存在的，前提是传输的用户认证信息通过HTTP头传输.
- 无状态（也称：服务端可扩展行）：Token机制在服务端不需要存储session信息，因为Token自身包含了所有登录用户的信息，只需要在客户端的cookie或本地介质存储状态信息。
- 更适用CDN：可以通过内容分发网络请求你服务端的所有资料（如：javascript，HTML，图片等），而你的服务端只要提供APl即可.
- 去耦：不需要绑定到一个特定的身份验证方案。Token可以在任何地方生成，只要在你的API被调用的时候，你可以进行Token生成调用即可
- 更适用于移动应用：当你的客户端是一个原生平台（iOS，Android等）时，Cookie是不被支持的（你需要通过Cookie容器进行处理），这时采用Token认证机制就会简单得多。
- CSRF：因为不再依赖于Cookie，所以你就不需要考虑对CSRF（跨站请求伪造）的防范。
- 性能：一次网络往返时间（通过数据库查询session信息）总比做一次HIMACSHA256计算的Token验证和解析要费时得多.
- 不需要为登录页面做特殊处理：如果你使用Protractor做功能测试的时候，不再需要为登录页面做特殊处理。
- 基于标准化：你的API可以采用标准化的JSON Web Token（JWT）.这个标准已经存在多个后端库（.NET，Ruby, Java，Python，PHP）和多家公司的支持（如：Firebase，Google，Microsoft）.

# SpringSecurity简介
spring Security是针对Spring项目的安全框架，也是SpringBoot底层安全模块默认的技术选型，它可以实现强大的web安全控制，对于安全控制，我们仅需引入spring-boot-starter-security模块，进行少量的配置，即可以实现强大的安全管理

Spring Security的两个主要目标是"认证(Authentication)"和"授权(Authorization)"(访问控制)
- 认证 （你是谁）: 是建立一个它声明的主体的过程(一个主体一般指用户，设备或一些可以在你的应用程序中执行动作的其他系统)，通俗点说就是系统认为用户是否能登陆
- 授权 （你能干什么）：指确定一个主体是否允许在你的应用程序执行一个动作的过程。通俗点讲就是系统判断用户是否有权限去做某些事情

**权限管理中的相关概念**
- 主体：使用系统的用户或设备或从其他系统远程登录的用户等等。简单说就是谁使用系统谁就是主体
- 认证：统确认一个主体的身份，允许主体进入系统。简单说就是“主体”证明自己是谁。
- 授权：将操作系统的“权力”“授予”“主体”，这样主体就具备了操作系统中特定功能的能力。

SpringSecurity 本质是一个过滤器链
<img src="https://gitee.com/NaisWang/images/raw/master/img/20210416145125.png" width="700px"/>
例如如下：
- FilterSecurityInterceptor：过滤器的最后一环， 这里会判定该请求是否能进行访问rest服务，判断的依据是 BrowserSecurityConfig中的配置，如果被拒绝了就会抛出不同的异常（根据具体的原因）
- ExceptionTranslationFilter：是个异常过滤器，用来处理在认证授权过程中抛出的异常
- UsernamePasswordAuthenticationFilter ：对/login 的 POST 请求做拦截，校验表单中用户名，密码。

## springSecurity表单登录认证过程
当我们访问一个受保护的资源时，如果之前没有进行登录认证，会触发认证异常，此时security会有该异常对应的默认处理类(LoginUrlAuthenticationEntryPoint.java)来处理这个异常, 这个异常处理类的处理逻辑是跳转到你指定的登陆页面。我们可以通过如下代码来指定我们的登陆页面地址：
```java
http.formLogin()
		.loginPage("/login.html");
```
我们也可以使用通过下面代码来使用我们自定义的异常处理类来处理认证异常
```java
http.exceptionHandling()
			.authenticationEntryPoint(自定义类);
```

如果我们在登陆页面提交表单登陆认证，会经历如下过程：
<img src="https://gitee.com/NaisWang/images/raw/master/img/20210407143840.png" width="700px"/>

<img src="https://gitee.com/NaisWang/images/raw/master/img/20210416152257.png" width="700px"/>

表单登陆认证过程：
- 用户提交用户名、密码被SecurityFilterChain中的`usernamePasswordAuthenticationFilter`过滤器获取到，封装为请求Authentication, 通常情况下是UsernamePasswordAuthenticationToken这个实现类
- 然后过滤器将Authentication提交至认证管理器(AuthenticationManager)进行认证
- 认证成功后，`AuthenticationManager`身份管理器返回一个被填充满了信息的(包括上面提到的权限信息，身份信息，细节信息，但密码通常会被移除)`Authentication`实例
- `SecurityContextHolder`安全上下文容器将第三步填充了信息的`Authentication`, 通过SecurityContextHolder.getContext().setAuthentication(...)方法，设置到其中。

通过上述，可以看出AuthenticationManager接口(认证管理器)是认证相关的核心接口，也是发起认证的出发点，它的实现类为ProviderManager。而Spring Security支持多种认证方式，因此ProviderManager维护`List<AuthenticationProvider>`列表，存放多种认证方式，最终实际的认证工作是由`AuthenticationProvider`完成的。我们知道web表达对应的`AuthenticationProvider`实现类为`DaoAuthenticationProvider`, 它的内部又维护着一个`UserDetailsService`类，通过调用该类的loadUserByUsername()来返回一个UserDetails对象。最终`AuthenticationProvider`将`UserDetials`填充至`Authentication`

## AuthenticationProvider
通过前面的Spring Security认证流程我们得知，认证管理器(AuthenticationManager)委托AuthenticationProvider完成认证工作
`AuthenticationProvider`是一个接口，定义如下：
```java
public interface AuthenticationProvider{
  Authentication authenticate(Authentication authentication) throws AuthenticationException;
  boolean supports(Class<?> var1);
}
```
authenticate()方法定义了认证的实现过程，它的参数是一个Authentication, 里面包含了登陆用户所提交的用户、密码等。而返回值也是一个Authentication, 这个Authentication则是在认证成功后，将用户的权限及其他信息重新组装后生成

Spring Security中维护着一个`List<AuthenticationProvider>`列表，存放多种认证方式，不同的认证方式使用不同的AuthenticationProvider。如使用用户名登陆时，使用AuthenticatinProvider1, 短信登陆时使用AuthenticationProvider2。

每个AuthenticationProvider需要实现supports()方法来表明自己支持的认证方式，如我们使用表单方式认证，在提交请求时Spring Security会生成UsernamePasswordAuthenticationToken, 它是一个Authentication, 里面封装着用户提交的用户名、密码信息，其由`DaoAuthenticationProvider`来处理

## Authentication接口
```java
public interface Authentication extends Principal, Serializable{
  Collection<? extends GrantedAuthority> getAuthorities();
  Object getCredentials();
  Object getDetails();
  Object getPrincipal();
  Object isAuthenticated();
  void setAuthentiated(boolean var1) throws IllegalArgumentException;
}
```
- getAuthorities(): 权限信息列表，默认是GrantedAuthority接口的一些实现类，通常是代表权限信息的一系列字符串
- getCredentials(): 凭证信息，用户输入的密码字符串，在认证过后通常会被移除，用于保障安全。
- getDetails(): 细节信息，web应用中的实现接口通常为WebAuthenticationDetails, 他记录了访问者的ip地址和session的值
- getPrincipal(): 身份信息，大部分情况下返回的是UserDetails接口的实现类，UserDetails代表用户的详细信息，那从Authentication中取出来的UserDetails就是当前登陆用户信息

## UserDetailsService接口讲解
DaoAuthenticationProvider处理了web表单的认证逻辑，认证成功后既得到一个Authentication(UsernamePasswordAuthenticationToken实现)，里面包含了身份信息(Principal)。这个身份信息就是一个Object,大多数情况下它可以被强转为UserDetails对象

DaoAuthenticationProvider中包含了一个UserDetailsService实例，<font color="red">通过调用UserDetailsService类中loadUserByUsername()方法来根据前端传来的用户名username来提取到用户信息UserDetails对象(包含密码)，而后DaoAuthenticationProvider会去对比UserDetailsService提取的用户密码与用户提交的密码是否匹配作为认证成功的关键依据</font>，因此可以通过将自定义的UserDetailsService公开为spring bean来自定义身份验证

`UserDetailsService接口中就只有一个方法`
```java
public interface UserDetailsService{
  //通过前端传来的username, 来获取对应的UserDetails
  UserDetails loadUserByUsername(String username) throws usernameNotFoundException;
}
```
很多人把DaoAuthenticationProvider和UserDetailsService的职责搞混淆，


当什么也没有配置的时候，账号和密码是由Spring Security定义生成的。而在实际项目中
账号和密码都是从数据库中查询出来的。 所以我们要通过自定义逻辑控制认证逻辑。
如果需要自定义逻辑时，只需要实现 UserDetailsService 接口即可。接口源码如下：

**返回值UserDetails接口的详解**
这个接口是系统默认的用户主体
该接口中的方法：
```java
// 获取登录用户所有权限
Collection<? extends GrantedAuthority> getAuthorities();
// 获取密码
String getPassword();
// 获取用户名
String getUsername();
// 判断账户是否过期
boolean isAccountNonExpired();
// 判断账户是否被锁定
boolean isAccountNonLocked();
// 判断段凭证{密码}是否过期
boolean isCredentialsNonExpired();
// 判断当前用户是否可用
boolean isEnabled();
```

**UserDetails的实现类User**
User类的两个构造参数：
```java
public User(String username, String password, Collection<? extends GrantedAuthority> authorities) {
  this(username, password, true, true, true, true, authorities);
}

public User(String username, String password, boolean enabled, boolean accountNonExpired, boolean credentialsNonExpired, boolean accountNonLocked, Collection<? extends GrantedAuthority> authorities) {
  if (username != null && !"".equals(username) && password != null) {
    this.username = username;
    this.password = password;
    this.enabled = enabled;
    this.accountNonExpired = accountNonExpired;
    this.credentialsNonExpired = credentialsNonExpired;
    this.accountNonLocked = accountNonLocked;
    this.authorities = Collections.unmodifiableSet(sortAuthorities(authorities));
  } else {
    throw new IllegalArgumentException("Cannot pass null or empty values to constructor");
  }
}
	```
注：User类的构造方法中的username参数是UserDetailsService接口中的loadUserByUsername方法中的username参数， 而User类的构造方法中的password等其他参数都是根据username从数据库中查出来的。
根据从数据库中得到的password与**前端传来的经过密码解析器加密的password相比较**，如果相同，则认证通过，反之不通过

## FilterSecurityInterceptor类的作用
FileterSecurityInterceptor中有2个重要的步骤：
1. 从安全对象中获取属性
```java
Collection<ConfigAttribute> attributes = this.obtainSecurityMetadataSource().getAttributes(object);
```
2. 由AccessDecisionManager进行权限判断
```java
this.accessDecisionManager.decide(authenticated, object, attributes);
```
接下来我们逐一分析这2步
### ConfigAtttribute
从表面意思上我们可以猜测到，它是和安全对象相关的配置的属性。其实它就是我们在HttpSecurity中给特定的url设置的安全属性：permitAll，denyAll，anonymous，authenticated，fullyAuthenticated，rememberMe。从debug中我们可以发现`this.obtainSecurityMetadataSource()`默认获得是ExpressionBasedFilterInvocationSecurityMetadataSource类，该类是FilterInvocationSecurityMetadataSource的实现类，该类的作用就是通过调用`getAttributes(object)`方法来获取此requestURL对应的ConfigAttributes。我们通过下面的方法来自定义这个`this.obtainSecurityMetadataSource()`所获取的类：
首先自定义该类，该类实现FilterInvocationSecurityMetadataSource接口
```java
@Component
public class CustomFilter implements FilterInvocationSecurityMetadataSource {
	@Autowired
	private IMenuService menuService;
	AntPathMatcher antPathMatcher = new AntPathMatcher();
	@Override
	public Collection<ConfigAttribute> getAttributes(Object object) throws IllegalArgumentException{
		//获取请求的url
		String requestUrl = ((FilterInvocation)object).getRequestUrl();
		List<Menu> menus = menuService.getMenusWithRole();
		for(Menu menu : menus){
			//判断请求url与菜单角色是否匹配menus = {ArrayList@11529}  size = 22
			if(antPathMatcher.match(menu.getUrl(), requestUrl)){
				String[] str = menu.getRoles().stream().map(Role::getName).toArray(String[]::new);
				return SecurityConfig.createList(str);
			}
		}
		//每匹配的url默认登陆即可访问
		return SecurityConfig.createList("ROLE_LOGIN");
	}
	@Override
	public Collection<ConfigAttribute> getAllConfigAttributes() {return null;}
	@Override
	public boolean supports(Class<?> aClass) {return false;}
}

```
然后指定这个类为`this.obtainSecurityMetadataSource()`所获取的类：
```java
http.csrf()
		////使用JWT时，不需要csrf
		.disable()
		.and()

		//动态权限配置
		.withObjectPostProcessor(new ObjectPostProcessor<FilterSecurityInterceptor>() {
			@Override
			public <O extends FilterSecurityInterceptor> O postProcess(O o) {
				o.setSecurityMetadataSource(customFilter); //自定义`this.obtainSecurityMetadataSource()`所获取的类：
				return o;
			}
		})

```
## AccessDecisionManager接口
AccessDecisionManager接口中最重要的方法是`decide`,该方法会根据获得到的`Collection<ConfigAttuibute>`来判断该用户是否有权力访问该资源。springsecurity对应着一个该默认的实现类，我们也通过下面的方式来设置成我们自定义的实现类
编写实现类
```java
@Component
public class CustomUrlDecisionManager implements AccessDecisionManager {
	@Override
	public void decide(Authentication authentication, Object o, Collection<ConfigAttribute> collection) throws AccessDeniedException, InsufficientAuthenticationException {
		for(ConfigAttribute configAttribute : collection)	{
			String needRole = configAttribute.getAttribute();
			//判断角色是否为登陆即可访问的角色，此角色在CustomFilter中设置
			if("ROLE_LOGIN".equals(needRole)){
				//判断是否登陆
				if(authentication instanceof AnonymousAuthenticationToken){
					throw new AccessDeniedException("尚未登陆，请登陆");
				}else{
					return;
				}
			}
			//判断用户角色是否为url所需角色
			Collection<? extends GrantedAuthority> authorities = authentication.getAuthorities();
			for(GrantedAuthority grantedAuthority : authorities){
				if(grantedAuthority.getAuthority().equals(needRole)){
					return;
				}
			}
		}
		throw new AccessDeniedException("权限不足，请联系管理员");
	}
	@Override
	public boolean supports(ConfigAttribute configAttribute) {return false;}
	@Override
	public boolean supports(Class<?> aClass) {return false;}
}
```
绑定
```java
http.csrf()
		.and()
		//动态权限配置
		.withObjectPostProcessor(new ObjectPostProcessor<FilterSecurityInterceptor>() {
			@Override
			public <O extends FilterSecurityInterceptor> O postProcess(O o) {
				o.setAccessDecisionManager(customUrlDecisionManager); //绑定
				return o;
			}
		})
```


## PasswordEncoder接口与BCryptPasswordEncoder类
**PasswordEncoder接口**
PasswordEncoder接口中的方法如下：
```java
// 表示把参数按照特定的解析规则进行解析
String encode(CharSequence rawPassword);

// 表示验证从存储中获取的编码密码与编码后提交的原始密码是否匹配。如果密码匹配，则返回 true；如果不匹配，则返回 false。第一个参数表示需要被解析的密码。第二个参数表示存储的密码。
boolean matches(CharSequence rawPassword, String encodedPassword);

// 表示如果解析的密码能够再次进行解析且达到更安全的结果则返回 true，否则返回false。默认返回 false。
default boolean upgradeEncoding(String encodedPassword) {return false; }
```

**BCryptPasswordEncoder类**
BCryptPasswordEncoder是PasswordEncoder接口的一个实现类，它是Spring Security官方推荐的密码解析器，平时多使用这个解析器
BCryptPasswordEncoder是对bcrypt强散列方法的具体实现。是基于Hash算法实现的单向加密。可以通过strength控制加密强度，默认为10
示例：
```java
@Test
public void test01(){
  // 创建密码解析器
  BCryptPasswordEncoder bCryptPasswordEncoder = new BCryptPasswordEncoder();
  // 对密码进行加密
  String atguigu = bCryptPasswordEncoder.encode("atguigu");
  // 打印加密之后的数据
  System.out.println("加密之后数据：\t"+atguigu);
  //判断原字符加密后和加密之前是否匹配
  boolean result = bCryptPasswordEncoder.matches("atguigu", atguigu);
  // 打印比较结果
  System.out.println("比较结果：\t"+result); //输出：true
}
```
springsecurity要求**一定要**有密码解析器，当用户登陆时，输入的密码会**自动**被你设置密码解析器进行加密，然后再放入数据库中


## SpringSecurity 的HttpSecurity，WebSecurity与AuthenticationManagerBuilder区别与应用
**configure（AuthenticationManagerBuilder）**
用于通过允许轻松添加AuthenticationProviders来建立身份验证机制：例如，以下内容定义了具有内置“用户”和“管理员”登录名的内存中身份验证。
```java
public void configure(AuthenticationManagerBuilder auth) {
    auth
        .inMemoryAuthentication()
        .withUser("user")
        .password("password")
        .roles("USER")
    .and()
        .withUser("admin")
        .password("password")
        .roles("ADMIN","USER");
}
```

**configure（HttpSecurity）**
允许基于选择匹配在资源级别配置基于Web的安全性-例如，以下示例将以/ admin /开头的URL限制为具有ADMIN角色的用户，并声明需要使用其他任何URL成功认证。
```java
protected void configure(HttpSecurity http) throws Exception {
    http
        .authorizeRequests()
        .antMatchers("/admin/**").hasRole("ADMIN")
        .anyRequest().authenticated()
}
```

**configure（WebSecurity）**
用于影响全局安全性的配置设置（忽略资源，设置调试模式，通过实现自定义防火墙定义拒绝请求）。例如，以下方法会使得以/resources/开头的任何请求都不需要认证
```java
public void configure(WebSecurity web) throws Exception {
    web
       .ignoring()
       .antMatchers("/resources/**");
}
```

## Spring Security 中的异常处理
Http 协议对认证授权的响应结果也有规定。
**401 未授权状态**
HTTP 401 错误 - 未授权(Unauthorized) 一般来说该错误消息表明您首先需要登录（输入有效的用户名和密码）。 如果你刚刚输入这些信息，立刻就看到一个 401 错误，就意味着，无论出于何种原因您的用户名和密码其中之一或两者都无效（输入有误，用户名暂时停用，账户被锁定，凭证失效等） 。总之就是认证失败了。对应`AuthenticationException`。

**403 被拒绝状态**
HTTP 403 错误 - 被禁止(Forbidden) 出现该错误表明您在访问受限资源时没有得到许可。服务器理解了本次请求但是拒绝执行该任务，该请求不该重发给服务器。并且服务器想让客户端知道为什么没有权限访问特定的资源，服务器应该在返回的信息中描述拒绝的理由。一般实践中我们会比较模糊的表明原因。 该错误对应的`AccessDeniedException`。

`AuthenticationEntryPoint`该类用来统一处理AuthenticationException异常
`AccessDeniedHandler`该类用来统一处理`AccessDeniedException`异常
我们只要实现并配置这两个异常处理类即可实现对 Spring Security 认证授权相关的异常进行统一的自定义处理。

**实现 AuthenticationEntryPoint**
以 json 信息响应。
```java
 public class SimpleAuthenticationEntryPoint implements AuthenticationEntryPoint {
     @Override
     public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException) throws IOException, ServletException {

         //todo your business
         HashMap<String, String> map = new HashMap<>(2);
         map.put("uri", request.getRequestURI());
         map.put("msg", "认证失败");
         response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
         response.setCharacterEncoding("utf-8");
         response.setContentType(MediaType.APPLICATION_JSON_VALUE);
         ObjectMapper objectMapper = new ObjectMapper();
         String resBody = objectMapper.writeValueAsString(map);
         PrintWriter printWriter = response.getWriter();
         printWriter.print(resBody);
         printWriter.flush();
         printWriter.close();
     }
 }
```
**实现 AccessDeniedHandler**
同样以 json 信息响应。
```java
 public class SimpleAccessDeniedHandler implements AccessDeniedHandler {
     @Override
     public void handle(HttpServletRequest request, HttpServletResponse response, AccessDeniedException accessDeniedException) throws IOException, ServletException {
         //todo your business
         HashMap<String, String> map = new HashMap<>(2);
         map.put("uri", request.getRequestURI());
         map.put("msg", "认证失败");
         response.setStatus(HttpServletResponse.SC_FORBIDDEN);
         response.setCharacterEncoding("utf-8");
         response.setContentType(MediaType.APPLICATION_JSON_VALUE);
         ObjectMapper objectMapper = new ObjectMapper();
         String resBody = objectMapper.writeValueAsString(map);
         PrintWriter printWriter = response.getWriter();
         printWriter.print(resBody);
         printWriter.flush();
         printWriter.close();
     }
 }
```
**配置**
实现了上述两个接口后，我们只需要在 WebSecurityConfigurerAdapter 的 configure(HttpSecurity http) 方法中配置即可。相关的配置片段如下：
```java
 http.exceptionHandling()
        .accessDeniedHandler(new SimpleAccessDeniedHandler())
        .authenticationEntryPoint(new SimpleAuthenticationEntryPoint())
```

## 安全上下文SecurityContext与其工具类SecurityContextHolder
当服务端对用户认证通过后，会将认证用户的信息封装到 UsernamePasswordAuthenticationToken 中 并使用工具类放入安全上下文 SecurityContext 中，当服务端响应用户后又使用同一个工具类将 UsernamePasswordAuthenticationToken 从 SecurityContext 中 clear 掉。
我们来简单了解 SecurityContext 具体是个什么东西。
```java
 package org.springframework.security.core.context;
 
 import java.io.Serializable;
 import org.springframework.security.core.Authentication;
 
 public interface SecurityContext extends Serializable {
     Authentication getAuthentication();
 
     void setAuthentication(Authentication var1);
 }
```
从源码上来看很简单就是一个存储 Authentication 的容器。而 Authentication 是一个用户凭证接口用来作为用户认证的凭证使用，通常常用的实现有 认证用户 UsernamePasswordAuthenticationToken 和 匿名用户AnonymousAuthenticationToken。其中 UsernamePasswordAuthenticationToken 包含了 UserDetails , AnonymousAuthenticationToken 只包含了一个字符串 anonymousUser 作为匿名用户的标识。我们通过 SecurityContext 获取上下文时需要来进行类型判断。接下来我们来聊聊操作 SecurityContext 的工具类SecurityContextHolder。

### SecurityContextHolder
SecurityContextHolder提供的方法：
```
clearContext  清除当前的 SecurityContext
getContext  获取当前的 SecurityContext
setContext  设置当前的 SecurityContext
```
平常我们通过这三个方法来操作安全上下文 SecurityContext 。你可以直接在代码中使用工具类 SecurityContextHolder 获取用户信息，像下面一样：
```java
 public String getCurrentUser() {
    Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
          
     if (authentication instanceof AnonymousAuthenticationToken){
         return "anonymousUser";
     }
    UserDetails principal = (UserDetails) authentication.getPrincipal();
    return principal.getUsername();
 }     
```
**SecurityContextHolder的存储策略**
SecurityContextHolder 默认有三种存储 SecurityContext 的策略：
- MODE_THREADLOCAL   利用ThreadLocal 机制来保存每个使用者的 SecurityContext，缺省策略，平常我们使用这个就行了。
- MODE_INHERITABLETHREADLOCAL  利用InheritableThreadLocal 机制来保存每个使用者的 SecurityContext，多用于多线程环境环境下。
- MODE_GLOBAL  静态机制，作用于全局。不太常用。

**总结**
SecurityContext 是 Spring Security 中的一个非常重要类，今天不但介绍 SecurityContext 是什么、有什么作用，也对以前讲过的一些知识进行回顾。
也对如何使用 SecurityContextHolder 操作 SecurityContext 进行了讲解。最后也简单讲述了 SecurityContextHolder 三种存储 SecurityContext 的策略和使用场景 。希望对你学习 Spring Security 有帮助。还请多多关注。
## SpringSecurity实战1
从网上找了一张Spring Security 的工作流程图，如下。
<img src="https://gitee.com/NaisWang/images/raw/master/img/v2-3322cbe0895680e3df05d1a97acc1990_720w.jpg" width="700px"/>

<img src="https://gitee.com/NaisWang/images/raw/master/img/20210527210105.png" width="700px"/>

**建表**
表结构
<img src="https://gitee.com/NaisWang/images/raw/master/img/20210526234401.png" width="700px"/>

**User**
```java
public class User implements UserDetails , Serializable {

    private Long id;
    private String username;
    private String password;

    private List<Role> authorities;

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    @Override
    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    @Override
    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }

    @Override
    public List<Role> getAuthorities() {
        return authorities;
    }

    public void setAuthorities(List<Role> authorities) {
        this.authorities = authorities;
    }

    /**
     * 用户账号是否过期
     */
    @Override
    public boolean isAccountNonExpired() {
        return true;
    }

    /**
     * 用户账号是否被锁定
     */
    @Override
    public boolean isAccountNonLocked() {
        return true;
    }

    /**
     * 用户密码是否过期
     */
    @Override
    public boolean isCredentialsNonExpired() {
        return true;
    }

    /**
     * 用户是否可用
     */
    @Override
    public boolean isEnabled() {
        return true;
    }
    
}
```
上面的 User 类实现了 UserDetails 接口，该接口是实现Spring Security 认证信息的核心接口。其中 getUsername 方法为 UserDetails 接口 的方法，这个方法返回 username，也可以是其他的用户信息，例如手机号、邮箱等。getAuthorities() 方法返回的是该用户设置的权限信息，在本实例中，从数据库取出用户的所有角色信息，权限信息也可以是用户的其他信息，不一定是角色信息。另外需要读取密码，最后几个方法一般情况下都返回 true，也可以根据自己的需求进行业务判断。

**Role**
```java
public class Role implements GrantedAuthority {

    private Long id;
    private String name;

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    @Override
    public String getAuthority() {
        return name;
    }

}
```
Role 类实现了 GrantedAuthority 接口，并重写 getAuthority() 方法。权限点可以为任何字符串，不一定非要用角色名。

所有的Authentication实现类都保存了一个GrantedAuthority列表，其表示用户所具有的权限。GrantedAuthority是通过AuthenticationManager设置到Authentication对象中的，然后AccessDecisionManager将从Authentication中获取用户所具有的GrantedAuthority来鉴定用户是否具有访问对应资源的权限。

**MyUserDetailsService**
```java
@Service
public class MyUserDetailsService implements UserDetailsService {

    @Autowired
    private UserMapper userMapper;
    @Autowired
    private RoleMapper roleMapper;

    @Override
    public UserDetails loadUserByUsername(String userName) throws UsernameNotFoundException {
        //查数据库
        User user = userMapper.loadUserByUsername( userName );
        if (null != user) {
            List<Role> roles = roleMapper.getRolesByUserId( user.getId() );
            user.setAuthorities( roles );
        }
        return user;
    }
    

}
```
Service 层需要实现 UserDetailsService 接口，该接口是根据用户名获取该用户的所有信息， 包括用户信息和权限点。

**MyInvocationSecurityMetadataSourceService**
```java
@Component
public class MyInvocationSecurityMetadataSourceService implements FilterInvocationSecurityMetadataSource {

    @Autowired
    private PermissionMapper permissionMapper;

    /**
     * 每一个资源所需要的角色 Collection<ConfigAttribute>决策器会用到
     */
    private static HashMap<String, Collection<ConfigAttribute>> map =null;


    /**
     * 返回请求的资源需要的角色
     */
    @Override
    public Collection<ConfigAttribute> getAttributes(Object o) throws IllegalArgumentException {
        if (null == map) {
            loadResourceDefine();
        }
        //object 中包含用户请求的request 信息
        HttpServletRequest request = ((FilterInvocation) o).getHttpRequest();
        for (Iterator<String> it = map.keySet().iterator() ; it.hasNext();) {
            String url = it.next();
            if (new AntPathRequestMatcher( url ).matches( request )) {
                return map.get( url );
            }
        }
        return null;
    }

    @Override
    public Collection<ConfigAttribute> getAllConfigAttributes() {
        return null;
    }

    @Override
    public boolean supports(Class<?> aClass) {
        return true;
    }

    /**
     * 初始化 所有资源 对应的角色
     */
    public void loadResourceDefine() {
        map = new HashMap<>(16);
        //权限资源 和 角色对应的表  也就是 角色权限 中间表
        List<RolePermisson> rolePermissons = permissionMapper.getRolePermissions();

        //某个资源 可以被哪些角色访问
        for (RolePermisson rolePermisson : rolePermissons) {
            String url = rolePermisson.getUrl();
            String roleName = rolePermisson.getRoleName();
            ConfigAttribute role = new SecurityConfig(roleName);

            if(map.containsKey(url)){
                map.get(url).add(role);
            }else{
                List<ConfigAttribute> list =  new ArrayList<>();
                list.add( role );
                map.put( url , list );
            }
        }
    }


}
```
MyInvocationSecurityMetadataSourceService 类实现了 FilterInvocationSecurityMetadataSource，FilterInvocationSecurityMetadataSource 的作用是用来储存请求与权限的对应关系。

FilterInvocationSecurityMetadataSource接口有3个方法：

- `boolean supports(Class<?> clazz)`：指示该类是否能够为指定的方法调用或Web请求提供ConfigAttributes。
- `Collection<ConfigAttribute> getAllConfigAttributes()`：Spring容器启动时自动调用, 一般把所有请求与权限的对应关系也要在这个方法里初始化, 保存在一个属性变量里。
- `Collection<ConfigAttribute> getAttributes(Object object)`：当接收到一个http请求时, filterSecurityInterceptor会调用的方法. 参数object是一个包含url信息的HttpServletRequest实例. 这个方法要返回请求该url所需要的所有权限集合。

**MyAccessDecisionManager**
```java
/**
 * 决策器
 */
@Component
public class MyAccessDecisionManager implements AccessDecisionManager {

    private final static Logger logger = LoggerFactory.getLogger(MyAccessDecisionManager.class);

    /**
     * 通过传递的参数来决定用户是否有访问对应受保护对象的权限
     *
     * @param authentication 包含了当前的用户信息，包括拥有的权限。这里的权限来源就是前面登录时UserDetailsService中设置的authorities。
     * @param object  就是FilterInvocation对象，可以得到request等web资源
     * @param configAttributes configAttributes是本次访问需要的权限
     */
    @Override
    public void decide(Authentication authentication, Object object, Collection<ConfigAttribute> configAttributes) throws AccessDeniedException, InsufficientAuthenticationException {
        if (null == configAttributes || 0 >= configAttributes.size()) {
            return;
        } else {
            String needRole;
            for(Iterator<ConfigAttribute> iter = configAttributes.iterator(); iter.hasNext(); ) {
                needRole = iter.next().getAttribute();

                for(GrantedAuthority ga : authentication.getAuthorities()) {
                    if(needRole.trim().equals(ga.getAuthority().trim())) {
                        return;
                    }
                }
            }
            throw new AccessDeniedException("当前访问没有权限");
        }

    }

    /**
     * 表示此AccessDecisionManager是否能够处理传递的ConfigAttribute呈现的授权请求
     */
    @Override
    public boolean supports(ConfigAttribute configAttribute) {
        return true;
    }

    /**
     * 表示当前AccessDecisionManager实现是否能够为指定的安全对象（方法调用或Web请求）提供访问控制决策
     */
    @Override
    public boolean supports(Class<?> aClass) {
        return true;
    }

}
```
MyAccessDecisionManager 类实现了AccessDecisionManager接口，AccessDecisionManager是由AbstractSecurityInterceptor调用的，它负责鉴定用户是否有访问对应资源（方法或URL）的权限。

**MyFilterSecurityInterceptor**
```java
@Component
public class MyFilterSecurityInterceptor extends AbstractSecurityInterceptor implements Filter {


    @Autowired
    private FilterInvocationSecurityMetadataSource securityMetadataSource;

    @Autowired
    public void setMyAccessDecisionManager(MyAccessDecisionManager myAccessDecisionManager) {
        super.setAccessDecisionManager(myAccessDecisionManager);
    }


    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {

        FilterInvocation fi = new FilterInvocation(servletRequest, servletResponse, filterChain);
        invoke(fi);
    }

    public void invoke(FilterInvocation fi) throws IOException, ServletException {

        InterceptorStatusToken token = super.beforeInvocation(fi);
        try {
            //执行下一个拦截器
            fi.getChain().doFilter(fi.getRequest(), fi.getResponse());
        } finally {
            super.afterInvocation(token, null);
        }
    }

    @Override
    public Class<?> getSecureObjectClass() {
        return FilterInvocation.class;
    }

    @Override
    public SecurityMetadataSource obtainSecurityMetadataSource() {

        return this.securityMetadataSource;
    }
    
    
}
```
每种受支持的安全对象类型（方法调用或Web请求）都有自己的拦截器类，它是AbstractSecurityInterceptor的子类，AbstractSecurityInterceptor 是一个实现了对受保护对象的访问进行拦截的抽象类。

AbstractSecurityInterceptor的机制可以分为几个步骤：
1. 查找与当前请求关联的“配置属性（简单的理解就是权限）”
2. 将 安全对象（方法调用或Web请求）、当前身份验证、配置属性 提交给决策器（AccessDecisionManager）
3. （可选）更改调用所根据的身份验证
4. 允许继续进行安全对象调用(假设授予了访问权)
5. 在调用返回之后，如果配置了AfterInvocationManager。如果调用引发异常，则不会调用AfterInvocationManager。


AbstractSecurityInterceptor中的方法说明：
- beforeInvocation()方法实现了对访问受保护对象的权限校验，内部用到了AccessDecisionManager和AuthenticationManager；
- finallyInvocation()方法用于实现受保护对象请求完毕后的一些清理工作，主要是如果在beforeInvocation()中改变了SecurityContext，则在finallyInvocation()中需要将其恢复为原来的SecurityContext，该方法的调用应当包含在子类请求受保护资源时的finally语句块中。
- afterInvocation()方法实现了对返回结果的处理，在注入了AfterInvocationManager的情况下默认会调用其decide()方法。

了解了AbstractSecurityInterceptor，就应该明白了，我们自定义MyFilterSecurityInterceptor就是想使用我们之前自定义的 AccessDecisionManager 和 securityMetadataSource。

**SecurityConfig**
@EnableWebSecurity注解以及WebSecurityConfigurerAdapter一起配合提供基于web的security。自定义类 继承了WebSecurityConfigurerAdapter来重写了一些方法来指定一些特定的Web安全设置。
```java
@Configuration
@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter {

    @Autowired
    private MyUserDetailsService userService;


    @Autowired
    public void configureGlobal(AuthenticationManagerBuilder auth) throws Exception {

        //校验用户
        auth.userDetailsService( userService ).passwordEncoder( new PasswordEncoder() {
            //对密码进行加密
            @Override
            public String encode(CharSequence charSequence) {
                System.out.println(charSequence.toString());
                return DigestUtils.md5DigestAsHex(charSequence.toString().getBytes());
            }
            //对密码进行判断匹配
            @Override
            public boolean matches(CharSequence charSequence, String s) {
                String encode = DigestUtils.md5DigestAsHex(charSequence.toString().getBytes());
                boolean res = s.equals( encode );
                return res;
            }
        } );

    }

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.authorizeRequests()
                .antMatchers("/","index","/login","/login-error","/401","/css/**","/js/**").permitAll()
                .anyRequest().authenticated()
                .and()
                .formLogin().loginPage( "/login" ).failureUrl( "/login-error" )
                .and()
                .exceptionHandling().accessDeniedPage( "/401" );
        http.logout().logoutSuccessUrl( "/" );
    }

}
```

**MainController**
```java
@Controller
public class MainController {

    @RequestMapping("/")
    public String root() {
        return "redirect:/index";
    }

    @RequestMapping("/index")
    public String index() {
        return "index";
    }

    @RequestMapping("/login")
    public String login() {
        return "login";
    }

    @RequestMapping("/login-error")
    public String loginError(Model model) {
        model.addAttribute( "loginError"  , true);
        return "login";
    }

    @GetMapping("/401")
    public String accessDenied() {
        return "401";
    }

    @GetMapping("/user/common")
    public String common() {
        return "user/common";
    }

    @GetMapping("/user/admin")
    public String admin() {
        return "user/admin";
    }


}
```

## SpringSecurity实战2
项目目录：
- java
  - com.example.springsecurity
    - config
      - <a href="#SecurityConfig">SecurityConfig.java</a>
    - controller
      - <a href="#LoginController">LoginController.java</a>
    - handler
      - <a href="#MyAccessDeniedHandler">MyAccessDeniedHandler.java</a>
      - <a href="#MyAuthenticationFailureHandler">MyAuthenticationFailureHandler.java</a>
      - <a href="#MyAuthenticationSuccessHandler">MyAuthenticationSuccessHandler.java</a>
    - service
      - <a href="#MyService">MyService.java</a>
      - <a href="#UserDetailsServiceImpl">UserDetailsServiceImpl.java</a>
    - <a href="#SpringsecurityApplication">SpringsecurityApplication.java</a>
- resources
  - <a href="#applicationProperties">application.properties</a>
  - static
    - <a href="#login">login.html</a>
    - <a href="#main">main.html</a>

**依赖**
```xml
<dependency>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-starter-security</artifactId>
</dependency>
```
**<span id="SecurityConfig">springSecurity配置类</span>**
```java
@Configuration
public class SecurityConfig extends WebSecurityConfigurerAdapter {

	@Autowired
	private MyAccessDeniedHandler myAccessDeniedHandler;

	@Autowired
	private UserDetailsServiceImpl userDetailsService;

	@Autowired
	private DataSource dataSource;

	@Autowired
	private PersistentTokenRepository persistentTokenRepository;

	@Override
	protected void configure(AuthenticationManagerBuilder auth) throws Exception{
		     //指定认证逻辑使用我们自定义的userDetailsService
		auth.userDetailsService(userDetailsService)
				//指定密码解析器
				.passwordEncoder(getPw());
	}

	@Override
	protected void configure(HttpSecurity http) throws Exception {
		//有关表单提交的设置
		http.formLogin()

				//设置form表单中的username对应的name
				.usernameParameter("username123")
				//设置form表单中的password对应的name
				.passwordParameter("password123")

				//当遇到'/login'请求时，去执行我们自定义认证逻辑UserDetailsServiceImpl中的loadUserByUsername方法,来进行用户认证。注：此处'/login'是form表单的action地址
				.loginProcessingUrl("/login")

				//自定义登陆页面
				.loginPage("/login.html")

				/**
				 * successHandler方法与successForwardUrl方法不能同时使用，有关它们的区别见后面
				 * successHandler()来指定认证成功后需要做的事情, 会调用MyAuthenticationSuccessHandler实例中的onAuthenticationSuccess方法
				 * successForwardUrl方法用来指定认证成功后要发送的页面请求，是请求转发且为POST请求。所以要写一个注解为@PostMapping("/toMain")的controller方法
				 */
				.successHandler(new MyAuthenticationSuccessHandler("http://www.baidu.com"))
				//.successForwardUrl("/toMain")

				/**
				 * failureHandler方法与failureForwardUrl方法不能同时使用，它们的区别跟successHandle方法与successForwardUrl方法的区别一样
				 * failureHandler()来指定认功失败后需要做的事情, 会调用MyAuthenticationFailreHandler实例中的onAuthenticationFailure方法
				 * failureForwardUrl方法用来指定认证失败后要发送的页面请求，是请求转发且为POST请求。所以要写一个注解为@PostMapping("/toError")的controller方法
				 */
				.failureHandler(new MyAuthenticationFailureHandler("http://www.bing.com"));
				//.failureForwardUrl("/toErro");


		//有关请求认证的设置
		http.authorizeRequests()
				//设置/error.html的请求不需要认证
				.antMatchers("/error.html").permitAll()
				//设置/login.html的请求不需要认证
				.antMatchers("/login.html").permitAll()
				//设置js文件夹、css文件夹、images文件夹下的内容不需要认证
				.antMatchers("/js/**", "/css/**", "/images/**").permitAll()
				//设置只要是png后缀的文件都不需要认证
				.antMatchers("/**/*.png").permitAll()
				//请求为/demo且为get请求的请求不需要认证
				.antMatchers(HttpMethod.GET, "/demo").permitAll()
				//只有有admin权限的用户才能访问/main1.html
				.antMatchers("/main1.html").hasAuthority("admin")
				//有admin或adminN权限的用户才能访问/main2.html
				.antMatchers("/main2.html").hasAnyAuthority("admin", "adminN")
				//只有属于abc角色的用户才能访问/main3.html
				.antMatchers("/main3.html").hasRole("abc")
				//属于abc角色或Abc角色的用户才能访问/main4.html
				.antMatchers("/main4.html").hasAnyRole("abc", "Abc")
				//只允许ip地址为127.0.0.1的设备才能访问/main5.html
				.antMatchers("/main5.html").hasIpAddress("127.0.0.1")
				//permitAll()对应的access实现方法
				.antMatchers("/main6.html").access("permitAll()")
				//hasRole()对应的access实现方法
				.antMatchers("/main7.html").access("hasRole('abc')")
				//设置/main8.html的请求对应的权限控制为自定义的方法，它会调用MyService实例中的hasPermission方法，如果返回true，则认证成功，反之，认证失败。
				//在access中通过@bean的id名.方法的形式调用配置类中的方法
				.antMatchers("/main8.html").access("@myService.hasPermission(request, authentication)")
				//所有请求都必须要认证，必须要登陆之后才被访问，即所有请求都会先跳转到登陆页面认证后才被访问
				.anyRequest().authenticated();

		//异常处理
		http.exceptionHandling()
				//当用户出现权限不足时，会调用MyAccessDeniedHandler实例中的handle方法
				.accessDeniedHandler(myAccessDeniedHandler);

		//记住我功能
		http.rememberMe()
				//设置Token失效时间，默认为2周
				.tokenValiditySeconds(60)
				//设置所能识别的记住我的复选框的name
				.rememberMeParameter("remember-me")
				//使用自定义认证逻辑处理
				.userDetailsService(userDetailsService)
				//springsecurity会自动将传入的有关Token对象放入数据库中
				.tokenRepository(persistentTokenRepository);

		//退出登陆,
		http.logout()
				//设置退出登陆的url请求。springSecurity默认会将'/logout'请求url看出退出登陆请求，返回会对其请求做相应的操作。
				.logoutUrl("/Mylogout")
				//退出登陆时跳转的页面
				.logoutSuccessUrl("/login.html");


		//关闭csrf防护
		http.csrf().disable();
	}

	@Bean
	public PasswordEncoder getPw(){
		return new BCryptPasswordEncoder();
	}


	@Bean
	public PersistentTokenRepository getPersistentTokenRepository(){
		JdbcTokenRepositoryImpl jdbcTokenRepository = new JdbcTokenRepositoryImpl();
		jdbcTokenRepository.setDataSource(dataSource); //指定数据库源
		//自动建用于存放Token的表，注意：只有当数据库中没有这个表时才能使用这个话，否则会报错
		jdbcTokenRepository.setCreateTableOnStartup(true);
		return jdbcTokenRepository;
	}
}
```

**<span id="LoginController">LoginController.java</span>**
```java
@Controller
public class LoginController {

	@RequestMapping("/login")
	public String login(){
		System.out.println("执行登陆操作");
		return "redirect:main.html";
	}

	@Secured("ROLE_admin") //基于注解的认证控制, 等价于.antMatchers("/main9.html").hasRole("abc")
	@RequestMapping("/main9")
	public String main9(){
		System.out.println("执行登陆操作");
		return "redirect:main9.html";
	}

	//基于注解的认证控制, 等价于 .antMatchers("/main10.html").access("hasRole('abc')")
	// PreAuthorize的表达式允许ROLE_开头，也可以不以ROLE_开头。
	@PreAuthorize("hasRole('abc')")
	@RequestMapping("/main10")
	public String main10(){
		System.out.println("执行登陆操作");
		return "redirect:main10.html";
	}

	@PostMapping("/toMain")
	public String toMain(){
		return "redirect:main.html";
	}

	@PostMapping("/toError")
	public String toError(){
		return "redirect:error.html";
	}
}
```

**<span id="MyAccessDeniedHandler">MyAccessDeniedHandler.java</span>**
```java
@Component
public class MyAccessDeniedHandler implements AccessDeniedHandler {

	@Override
	public void handle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, AccessDeniedException e) throws IOException, ServletException {
		//设置响应状态码
		httpServletResponse.setStatus(HttpServletResponse.SC_FORBIDDEN);
		httpServletResponse.setHeader("Content-Type", "application/json;charset=utf-8");
		PrintWriter writer = httpServletResponse.getWriter();
		writer.write("{\"status\":\"error\", \"msg\":\"权限不足，请联系管理员\"}");
		writer.flush();
		writer.close();
	}
}
```

**<span id="MyAuthenticationFailureHandler">MyAuthenticationFailureHandler.java</span>**
```java
@Component
public class MyAuthenticationFailureHandler implements AuthenticationFailureHandler {

	private String url;

	public MyAuthenticationFailureHandler(String url){
		this.url = url;
	}

	@Override
	public void onAuthenticationFailure(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, AuthenticationException e) throws IOException, ServletException {
		httpServletResponse.sendRedirect(url);
	}
}
```

**<span id="MyAuthenticationSuccessHandler">MyAuthenticationSuccessHandler.java</span>**
```java
@Component
public class MyAuthenticationSuccessHandler implements AuthenticationSuccessHandler {

	private String url;

	public MyAuthenticationSuccessHandler(String url){
		this.url = url;
	}

	@Override
	public void onAuthenticationSuccess(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Authentication authentication) throws IOException, ServletException {
		User user = (User) authentication.getPrincipal();
		System.out.println(user.getUsername());
		//springsecurity出于安全原因，user.getPassword()得到的是null
		System.out.println(user.getPassword());
		System.out.println(user.getAuthorities());
		httpServletResponse.sendRedirect(url);
	}
}
```

**<span id="MyService">MyService.java</span>**
```java
@Service
public class MyService {
	public boolean hasPermission(HttpServletRequest request, Authentication authentication){
		Object obj = authentication.getPrincipal();
		if(obj instanceof UserDetails){
			UserDetails userDetails = (UserDetails) obj;
			Collection<? extends GrantedAuthority> authorities = userDetails.getAuthorities();
			return authorities.contains(new SimpleGrantedAuthority("admin"));
		}
		return false;
	}
}
```
**<span id="UserDetailsServiceImpl">UserDetailsServiceImpl.java</span>**
```java
@Service
public class UserDetailsServiceImpl implements UserDetailsService {

	@Autowired
	private PasswordEncoder pw;

	@Override
	public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
		//这一步是在模拟判断从前端传来的username是否存在于数据库中，如果不存在则抛出UsernameNotFoundException异常
		if(!"admin".equals(username))	{
			throw new UsernameNotFoundException("用户名不存在!");
		}

		//模拟根据前端传来的username从数据库中获取到了其密码。
		//这里要用pw进行加密的原因：我们再前端密码输入框中输入123后，springsecurity会自动将其通过你设置的密码解析器进行加密。后续的认证过程的密码都是加密后的密码
		String password = pw.encode("123");

		//这里的admin,normal是用户拥有的权限, 而ROLE_abc表示该用户属于abc角色。注: 该用户不是属于ROLE_abc角色，“ROLE_”前缀只是用来与权限名相区别开
		//权限名与角色名是严格区分大小写的
		return new User(username, password, AuthorityUtils.commaSeparatedStringToAuthorityList("admin,normal,ROLE_abc"));
	}
}
```

**<span id="SpringsecurityApplication">SpringsecurityApplication.java</span>**
```java
@SpringBootApplication
@EnableGlobalMethodSecurity(securedEnabled = true, prePostEnabled = true)//开启@Secured、@PreAuthorize注解
public class SpringsecurityApplication {
	public static void main(String[] args) {
		SpringApplication.run(SpringsecurityApplication.class, args);
	}
}
```

**<span id="applicationProperties">application.properties</span>**
```
# 应用名称
spring.application.name=springsecurity
# 应用服务 WEB 访问端口
server.port=8080

spring.datasource.driver-class-name= com.mysql.cj.jdbc.Driver
spring.datasource.url= jdbc:mysql://localhost:3306/security?useUnicode=true&characterEncoding=UTF-8&serverTimezone=Asia/Shanghai
spring.datasource.username= root
spring.datasource.password= whz1152957995
```
**<span id="login">login.html</span>**
```html
<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>login</title>
</head>
<body>
<form action="/login" method="post">
	username: <input type="text" name="username123"/><br/>
	password: <input type="password" name="password123"/><br/>
	记住我:<input type="checkbox" name="remember-me" value="true"/>
	<input type="submit" value="login">
</form>
</body>
</html>
```

**<span id="main">main.html</span>**
```html
<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>success</title>
</head>
<body>
success！！！
<a href="/Mylogout">退出登陆</a>
</body>
</html>
```
## 自定义登陆逻辑
securityConfig配置文件
```java
@Configuration
public class SecurityConfig {
  //设置是使用BCryptPasswordEncoder加密
	@Bean
	public PasswordEncoder getPw(){
		return new BCryptPasswordEncoder();
	}
}
```
登陆逻辑代码
```java
@Service
public class UserDetailsServiceImpl implements UserDetailsService {
	@Autowired
	private PasswordEncoder pw;

	@Override
	public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
		//这一步是在模拟判断从前端传来的username是否存在于数据库中，如果不存在则抛出UsernameNotFoundException异常
		if(!"admin".equals(username))	{
			throw new UsernameNotFoundException("用户名不存在!");
		}
		//模拟根据前端传来的username从数据库中获取到了其密码。
		//这里要用pw进行加密的原因：我们再前端密码输入框中输入123后，springsecurity会自动将其通过你设置的密码解析器进行加密。后续的认证过程的密码都是加密后的密码
		String password = pw.encode("123");
		return new User(username, password, AuthorityUtils.commaSeparatedStringToAuthorityList("admin,normal"));//这里的admin,normal权限我们自定义的
	}
}
```
运行后，只有用户名为admin，密码为123的用户才能登陆


## successForwardUrl方法与successHandler方法的区别
successFrowardUrl方法的底层代码如下：
```java
public FormLoginConfigurer<H> successForwardUrl(String forwardUrl) {
  this.successHandler(new ForwardAuthenticationSuccessHandler(forwardUrl));
  return this;
}
```
```java
public class ForwardAuthenticationSuccessHandler implements AuthenticationSuccessHandler {
  private final String forwardUrl;
  public ForwardAuthenticationSuccessHandler(String forwardUrl) {
    Assert.isTrue(UrlUtils.isValidRedirectUrl(forwardUrl), () -> {
      return "'" + forwardUrl + "' is not a valid forward URL";
    });
    this.forwardUrl = forwardUrl;
  }
  public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException {
    request.getRequestDispatcher(this.forwardUrl).forward(request, response);
  }
}
```
由此使用successForwardUrl方法，认证成功后是通过**请求转发**来跳转到页面的。

如果我们想要通过**重定向**的方法来跳转到页面的话，我们需要自己实现AuthenticationSuccessHandler接口，然后使用successHandler()来指定认证成功后需要做的事情


## 认证的公式
```java
http.authorizeRequests()
  .antMatchers("/error.html").permitAll()
  ....
  .匹配的url.认证控制
```
### 其中用于`匹配的url`的方法有如下几种：
**anyRequest()**: 匹配任何请求

**antMatcher()**
方法定义如下：
```java
public C antMathcers(HttpMethod method, String... antPatterns) {
public C antMatchers(String... antPatterns)
```
参数是可变参数，每个参数是一个ant路径表达式，用于匹配url规则

**regexMatchers()**
方法定义如下：
```java
public C regexMatchers(HttpMethod method, String... regexPatterns) {
public C regexMatchers(String... regexPatterns)
```

regexPatterns形参是可变参数，每个参数是一个正则表达式，用于匹配url规则


### 其中用于`认证控制`的方法有如下几种
- permitAll(): 允许任何人访问
- denyAll() : 不允许任何人访问
- anonymous()
- authenticated()： 所有人需要进行认证才能访问
- fullyAuthenticated()
- rememberMe()
- hasAuthority()
- hasAnyAuthority()
- hasRole()
- hasAnyrole()
- hasIpAddress()
- access()

**access()方法的使用**
上述`认证控制`的方法实际上底层实现都是调用access(表达式)
以permitAll()为例：
```java
public ExpressionUrlAuthorizationConfigurer<H>.ExpressionInterceptUrlRegistry permitAll() {
  return this.access("permitAll");
}
```
通过access()我们可以自己写一个`认证控制`

### 基于注解的权限控制
在Spring Security中提供了一些认证控制的注解。这些注解默认都是不可用的，需要通过在启动类上添加`@EnableGlobalMethodSecurity`进行开启后使用
如果设置的条件允许，程序正常执行。如果不允许会报500，`org.springframework.security.access.AccessDeniedExceptin:不允许访问`

用于权限控制的注解可以写到Service类或方法上也可以写道Controller类或Controller的方法上，通常都是写在Controller的方法上的，来控制url是否允许被访问

**@Secured**
`@Secured`是专门用来判断是否具有角色的。能写在方法或类上。参数要以ROLE_开头
开启注解：`@EnableGlobalMethodSecurity(securedEnabled=true)`

**@PreAuthorize/@PostAuthorize**
@PreAuthorize：在访问方法或类在执行之前先认证，大多情况下都是使用这个注解，注解的参数和access()方法参数取值方式相同，都是权限表达式
@PostAuthorize表示方法或类执行结束后再认证，此注解很少被使用

开启注解：`@EnableGlobalMethodSecurity(prePostEnabled=true)`

## RememberMe功能实现
springSecurity中RmemeberMe为“记住我”功能，用户只需要再登陆时添加name为remember-me的复选框。当取值为true时，springSecurity会自动把用户信息存储到数据源中，以后就可以不登陆进行访问了，默认的有效时间为2周

## spring security 获取用户信息
本文描述在spring security中如何获取用户信息。分别介绍几种常用的方法实现。

### 通过Bean获取用户
获取当前认证用户(authenticated principal)最简单的方式是通过SecurityContextHolder类的静态方法：
```java
Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
String currentPrincipalName = authentication.getName();
```
下面是改进版本代码，获取前首先检查是否存在认证用户：
```java
Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
if (!(authentication instanceof AnonymousAuthenticationToken)) {
    String currentUserName = authentication.getName();
    return currentUserName;
}
```
当然，静态调用的缺点是代码的可测试性明显降低。我们继续探索新的方式实现。

### 在控制器中获取用户
在@Controller 注解的bean里，有额外的选项。principal 可以直接作为方法参数，框架会自动赋值。
```java
@Controller
public class SecurityController {
 
    @RequestMapping(value = "/username", method = RequestMethod.GET)
    @ResponseBody
    public String currentUserName(Principal principal) {
        return principal.getName();
    }
}
```
或者也可以使用认证信息：
```java
@Controller
public class SecurityController {
 
    @RequestMapping(value = "/username", method = RequestMethod.GET)
    @ResponseBody
    public String currentUserName(Authentication authentication) {
        return authentication.getName();
    }
}
```
框架为了尽可能的灵活，Authentication 类的API很方便使用。因此，通过转换可以返回principal对象。
```java
UserDetails userDetails = (UserDetails) authentication.getPrincipal();
System.out.println("User has authorities: " + userDetails.getAuthorities());
```
最后一种方式直接通过http request：
```java
```java
@Controller
public class SecurityController {
 
    @RequestMapping(value = "/username", method = RequestMethod.GET)
    @ResponseBody
    public String currentUserNameSimple(HttpServletRequest request) {
        Principal principal = request.getUserPrincipal();
        return principal.getName();
    }
}
```
### 通过自定义接口获取用户信息
为了充分利用spring的依赖注入功能，可以在在任何地方获取认证信息，不仅仅是@Controller注解的bean，我们通过简单的门面隐藏静态访问：
```java
public interface IAuthenticationFacade {
    Authentication getAuthentication();
}

@Component
public class AuthenticationFacade implements IAuthenticationFacade {
 
    @Override
    public Authentication getAuthentication() {
        return SecurityContextHolder.getContext().getAuthentication();
    }
}
```
该门面暴露了认证对象并隐藏静态访问代码，让业务解耦并方便测试：
```java
@Controller
public class SecurityController {
    @Autowired
    private IAuthenticationFacade authenticationFacade;
 
    @RequestMapping(value = "/username", method = RequestMethod.GET)
    @ResponseBody
    public String currentUserNameSimple() {
        Authentication authentication = authenticationFacade.getAuthentication();
        return authentication.getName();
    }
}
```
### 在jsp中获取用户信息
当前认证用户也可以在jsp页面中获取到。利用spring security标签支持。首先我们需要在页面中定义标签：
```java
<%@ taglib prefix="security" uri="http://www.springframework.org/security/tags" %>
```
然后，我们可以引用principal：
```java
<security:authorize access="isAuthenticated()">
    authenticated as <security:authentication property="principal.username" /> 
</security:authorize>
```

# JWT和Oauth2的区别和联系
**JWT**
提供了一种用于发布接入令牌（Access Token),并对发布的签名接入令牌进行验证的方法。 令牌（Token）本身包含了一系列声明，应用程序可以根据这些声明限制用户对资源的访问。
JWT是一种安全标准。**基本思路就是用户提供用户名和密码给认证服务器，服务器验证用户提交信息信息的合法性；如果验证成功，会产生并返回一个Token（令牌），用户可以使用这个token访问服务器上受保护的资源。**

**Oauth**
OAuth是一个关于授权（authorization）的开放网络协议，在全世界得到广泛应用，目前的版本是2.0版。
OAuth是一种安全的授权框架，提供了一套详细的授权机制。用户或应用可以通过公开的或私有的设置，授权第三方应用访问特定资源。它详细描述了系统中不同角色、用户、服务前端应用（比如API），以及客户端（比如网站或移动App）之间怎么实现相互认证。
Oauth2定义了一组相当复杂的规范。涉及到：Roles角色、Client Types客户端类型、Client Profile客户端描述、Authorization Grants认证授权、Endpoints终端等。


## JWT详解
Json web token（JWT）是为了网络应用环境间传递声明而执行的一种基于JSON的开发标准（RFC 7519），它定义了一种简介的、自包含的协议格式，用于在通信双方传递json对象token，传递的信息经过数字签名可以被验证和信任， 该token被设计为紧凑且安全的，特别适用于分布式站点的单点登陆（SSO）场景。JWT的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源，也可以增加一些额外的其它业务逻辑所必须的声明信息，该token也可直接被用于认证，也可被加密。

JWT令牌的优点：
- jwt基于json，非常方便解析。
- 可以在令牌中自定义丰富的内容，易扩展。
- 通过非对称加密算法及数字签名技术，JWT防止篡改，安全性高。
- 资源服务使用WT可不依赖认证服务即可完成授权。
缺点：
- JWT令牌较长，占存储空间比较大。

**基于session认证所显露的问题**
- Session：每个用户经过我们的应用认证之后，我们的应用都要在服务端做一次记录，以便用户下次请求的鉴别，通常而言session都是保存在内存中，而随着认证用户的增多，服务端的开销会明显增大
- 扩展性：用户认证之后，服务端做认证记录，如果认证的记录被保存在内存的话，这意味着用户下次请求还必须要请求在这台服务器上，这样才能拿到授权的资源，这样在分布式的应用上，响应的限制了负载均衡器的能力，也意味着限制了应用的扩展性
- CSRF：因为是基于cookie来进行用户识别的，cookie如果被截获，用户就会很容易受到跨站请求伪造的攻击

### JWT组成
JWT是由三部分构成（用.分隔），将这三段信息文本用链接构成了JWT字符串。就像这样
```
xxxxx.yyyyy.zzzzz
```
第一部分：头部（header）
第二部分：载荷（payload，该token里携带的有效信息。比如用户id、名字、年龄等等）
第三部分：签名（signature）

#### 头部（Header）
头部用于描述关于该JWT的最基本的信息，例如其类型（即JWT）以及签名所用的算法(如HMAC SHA256或RSA)等。这也可以被表示成一个JSON对象。
```json
{
	"alg": "HS256",
	"typ": "JWT"
}
```
- typ：是类型。
- alg：签名的算法，这里使用的算法是HS256算法
我们对头部的json字符串进行BASE64编码（网上有很多在线编码的网站），编码后的字符串如下：
```
eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9
```
Base64是一种基于64个可打印字符来表示二进制数据的表示方法。由于2的6次方等于64，所以每6个比特为一个单元，对应某个可打印字符。三个字节有24个比特，对应于4个Base64单元，即3个字节需要用4个可打印字符来表示。JDK中提供了非常方便的BASE64Encoder和BASE64Decoder，用它们可以非常方便的完成基于BASE64的编码和解码。

#### 载荷(Payload)
第二部分是载荷，就是存放有效信息的地方。这里放声明内容，可以说就是存放沟通讯息的地方，在定义上有3种声明（Claims）：
- **Registered claims（注册声明）**
这些是一组预先定义的声明，它们不是强制性的，但推荐使用，以提供一组有用的，可互操作的声明。 其中一些是：iss（发行者），exp（到期时间），sub（主题），aud（受众）等。
```
iss: jwt签发者
sub: jwt所面向的用户
aud: 接收jwt的一方
exp: jwt的过期时间，这个过期时间必须要大于签发时间
nbf: 定义在什么时间之前，该jwt都是不可用的.
iat: jwt的签发时间
jti: jwt的唯一身份标识，主要用来作为一次性token，从而回澄重放攻击。
```
- **Public claims（公开声明）**
公共的声明可以添加任何的信息，一般添加用户的相关信息或其他业务需要的必要信息.但不建议添加敏感信息，因为该部分在客户端可解密.
- **Private claims（私有声明）**
私有声明是提供者和消费者所共同定义的声明，一般不建议存放敏感信息，因为base64是对称解密的，意味着该部分信息可以归类为明文信息。
这个指的就是自定义的claim。比如下面那个举例中的name都属于自定的claim。这些claim跟JWT标准规定的claim区别在于：JWT规定的claim，JWT的接收方在拿到JWT之后，都知道怎么对这些标准的claim进行验证（还不知道是否能够验证）；而private claims不会验证，除非明确告诉接收方要对这些claim进行验证以及规则才行。

载荷实例：
```json
{
	"sub": "1234567890",
	"name": "John Doe",
	"iat": 1516239022
}
```
其中sub是标准的声明，name是自定义的声明（公共的或私有的）
然后将其进行base64编码，得到jwt的第二部分：
```
ey]zdwrioiIxMjMONTY30DkwriwibmFtZSI6IkphbwvzIiwiwRtaw4ionRydwv9
```

#### 签证/签名(Signature)
jwt的第三部分是一个签证信息，用来验证发送请求者身份，由前两部分加密形成。这个签证信息由三部分组成：
- header（base64后的）
- payload（base64后的）
- secret（盐，一定要保密）
这个部分需要base64加密后的header和base64加密后的payload使用，连接组成的字符串，然后通过header中声明的加密方式进行加盐secret组合加密，然后就构成了jwt的第三部分：
```
8HI-LodOncfVonbKIPJJqLH998duF9DSDGkx3gRPNVI
```

将这三部分用`.`连接成一个完整的字符串，构成了最终的jwt：
```
eyJhbscioi]IUzI1NiIsInRScCI6IkpXVCJ9.eyJzdwrioiIxMjMoNTY30DkwriwibmFtZSI6IkpvaG4gRG91riwiaMFOIjOxNTE2MjM5MDIyfQ.8HI-LodOncfVonbKIPJJqLH998duF9DSDGkx3gRPNVI
```
注意：secret是保存在服务器端的，jwt的签发生成也是在服务器端的，secret就是用来进行jwt的签发和jwt的验证，所以，它就是你服务端的私钥，在任何场景都不应该流露出去。一旦客户端得知这个secret，那就意味着客户端是可以自我签发jwt了

### JWT实战
**依赖**
```xml
<dependency>
	<groupId>io.jsonwebtoken</groupId>
	<artifactId>jjwt</artifactId>
	<version>0.9.0</version>
</dependency>
```
```java
@SpringBootTest
class JjwtApplicationTests {

	@Test
	void contextLoads() {
		Map adminClaims = new HashMap();
		adminClaims.put("age", "18");

		//创建JwtBuilder对象
		JwtBuilder jwtBuilder = Jwts.builder()
				// 声明的标识{'jti':'8888'}
				.setId("8888")
				// 主体，用户{'sub':"Rose"}
				.setSubject("Rose")
				// 设置token创建的日期{'ita':"xxxxxx"}
				.setIssuedAt(new Date())
				//设置token有效时间为1分钟
				.setExpiration(new Date(System.currentTimeMillis() + 60 * 1000))
				//设置签名的算法与盐，第一个参数为算法，第二个参数为盐
				.signWith(SignatureAlgorithm.HS256, "xxxx")
				// 自定义申明
				.claim("roles", "admin")
				.claim("logo", "xxx.png")
				//通过传入map的方式来自定义申明
				.addClaims(adminClaims);

		//获取jwt的token
		String token = jwtBuilder.compact();
		System.out.println(token); //输出：eyJhbGciOiJIUzI1NiJ9.eyJqdGkiOiI4ODg4Iiwic3ViIjoiUm9zZSIsImlhdCI6MTYxODIxODQ4OH0.elU_nO63OLxc7rVyIaIWAZRLx1Ocu35Lc32GqHbXFNs
		System.out.println("=================");

		//对token解密
		String[] split = token.split("\\.");
		System.out.println(Base64Codec.BASE64.decodeToString(split[0])); //输出：{"alg":"HS256"}
		System.out.println(Base64Codec.BASE64.decodeToString(split[1])); //输出：{"jti":"8888","sub":"Rose","iat":161821848}
		// 无法解密签名, 因为签名过程涉及到了盐secret, 所以输出的是乱码
		System.out.println(Base64Codec.BASE64.decodeToString(split[2]));//输出：zU';��/;�\�h��e���.ߒ��a���
		System.out.println("=================");

		//解析token获取载荷中声明的对象
		Claims claims = Jwts.parser()
				//指定盐来解密token
				.setSigningKey("xxxx")
				.parseClaimsJws(token)
				.getBody();
		System.out.println("id:"+ claims.getId()); //输出：id:8888
		System.out.println("subject:"+claims.getSubject()); //输出：subject:Rose

		SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
		try{
			Thread.sleep(3 * 1000);
		}catch (Exception e){
			e.printStackTrace();
		}
		System.out.println("签发时间："+simpleDateFormat.format(claims.getIssuedAt()));// 输出：签发时间：2021-04-12 17:30:04
		System.out.println("过期时间："+simpleDateFormat.format(claims.getExpiration()));//输出：过期时间：2021-04-12 17:31:04
		System.out.println("当前时间："+simpleDateFormat.format(new Date()));//输出：当前时间：2021-04-12 17:30:07

		System.out.println("roles:"+claims.get("roles")); //输出：admin
		System.out.println("logo:"+claims.get("logo"));//输出：xxx.png
		System.out.println("age:"+claims.get("age"));//输出：18
	}
}
```

### Spring Security 中实现接口 Jwt 认证
**定义 Json Web Token 过滤器**
无论上面提到的哪种认证方式，我们都可以使用 Spring Security 中的 Filter 来处理。 Spring Security 默认的基础配置没有提供对 Bearer Authentication 处理的过滤器， 但是提供了处理 Basic Authentication 的过滤器：
通过查看`BasicAuthentication`源码发现，它继承了OncePerRequestFilter类，我们所以我们也模仿 BasicAuthenticationFilter 来实现自己的 JwtAuthenticationFilter。 完整代码如下：
```java
/**
  * jwt 认证拦截器 用于拦截 请求 提取jwt 认证
  *
  * @author dax
  * @since 2019/11/7 23:02
  */
	@Component
 public class JwtAuthenticationFilter extends OncePerRequestFilter {
     @Override
     protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain chain) throws IOException, ServletException {

			   ....

         chain.doFilter(request, response);
     }
 }
```
**配置 JwtAuthenticationFilter**
首先将过滤器 JwtAuthenticationFilter 注入 Spring IoC 容器 ，然后一定要将 JwtAuthenticationFilter 顺序置于 UsernamePasswordAuthenticationFilter 之前：
```java
@Override
protected void configure(HttpSecurity http) throws Exception {
	http.csrf().disable()
					.and()
					.addFilterBefore(preLoginFilter, UsernamePasswordAuthenticationFilter.class)
					// jwt必须配置于 UsernamePasswordAuthenticationFilter 之前
					.addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter.class)
}
```

## OAuth2.0详解
第三方认证技术方案最主要是解决认证协议的通用标准问题，因为要实现跨系统认证，各系统之间要遵循一定的接口协议。
OAUTH协议为用户资源的授权提供了一个安全的、开放而又简易的标准。同时，任何第三方都可以使用OAUTH认证服务，任何服务提供商都可以实现自身的OAUTH认证服务，因而OAUTH是开放的。业界提供了OAUTH的多种实现如PHP、JavaScript，Java，Ruby等各种语言开发包，大大节约了程序员的时间，因而OAUTH是简易的。互联网很多服务如OpenAPI，很多大公司如Google，Yahoo，Microsoft等都提供了OAUTH认证服务，这些都足以说明OAUTH标准逐渐成为开放资源授权的标准。
oauth协议目前发展到2.0版本，1.0版本过于复杂，2.0版本已得到广泛应用。

**举个例子**
你想登录豆瓣去看看电影评论，但你丫的从来没注册过豆瓣账号，又不想新注册一个再使用豆瓣，怎么办呢？不用担心，豆瓣已经为你这种懒人做了准备，用你的qq号可以授权给豆瓣进行登录，请看：
第一步：在豆瓣官网点击用qq登录
<img src="https://gitee.com/NaisWang/images/raw/master/img/20210416161348.png" width="700px"/>

第二步：跳转到qq登录页面输入用户名密码，然后点授权并登录
<img src="https://gitee.com/NaisWang/images/raw/master/img/20210416161407.png" width="700px"/>

第三步：跳回到豆瓣页面，成功登录
<img src="https://gitee.com/NaisWang/images/raw/master/img/20210416161422.png" width="700px"/>

我们发现，我们竟然用QQ帐号登录进了豆瓣的系统里。到底发生了什么？
页面经历了从豆瓣到qq，再从qq到豆瓣的两次页面跳转。简单来说，上述例子中的豆瓣就是客户端，QQ就是认证服务器，OAuth2.0就是客户端和认证服务器之间由于相互不信任而产生的一个授权协议。
其实整个过程，用下面这一张图，
<img src="https://gitee.com/NaisWang/images/raw/master/img/20210416161558.png" width="700px"/>
备注：所用到的请求路径名称都是虚构的，所附带的请求参数忽略了一些非重点的。

1. 第一步：在豆瓣官网点击用qq登录
当你点击用qq登录的小图标时，实际上是向豆瓣的服务器发起了一个 http://www.douban.com/leadToAuthorize 的请求，豆瓣服务器会响应一个重定向地址，指向qq授权登录
浏览器接到重定向地址 http://www.qq.com/authorize?callback=www.douban.com/callback，再次访问。并注意到这次访问带了一个参数是callback，以便qq那边授权成功再次让浏览器发起这个callback请求。不然qq怎么知道你让我授权后要返回那个页面啊，每天像豆瓣这样的需要QQ授权的网站这么多。

2. 第二步：跳转到qq登录页面输入用户名密码，然后点授权并登录
上一步中浏览器接到重定向地址并访问 http://www.qq.com/authorize?callback=www.douban.com/callback
这时候来到的页面是QQ这边的登录授权页面。当访问QQ服务器验证用户名密码成功后，该方法会响应浏览器一个重定向地址，并附上一个code（**授权码**）。而这个授权码，就是豆瓣这边关心的了，因为豆瓣才不管QQ那边是怎么授权的呢。

3. 第三步：跳回到豆瓣页面，成功登录
这一步背后的过程其实是最繁琐的，但对于用户来说是完全感知不到的（所以你看页面上消耗的时间一般都比较长，长达好几秒）。用户在QQ登录页面点击授权登陆后，就直接跳转到豆瓣首页了，但其实经历了很多隐藏的过程。

QQ服务器在判断登录成功后，使页面重定向到之前豆瓣发来的callback的URL并且附上QQ自己提供的code授权码，即 callback=www.douban.com/callbackwithauthcode

当发送这个请求到豆瓣的服务器的时候，就复杂了，主要做了两件事（模拟了两次请求）：

用拿到的授权码code去换token（和QQ服务器交互）
用拿到的token换取用户信息，比如用户名、头像等等信息（和QQ服务器交互）
最后信息拿到后，豆瓣这边就把你的信息存下来，返回到首页给你看。这样就完成了一套完整的授权。QQ服务器成功的把你的qq信息授权交给豆瓣了，完美

**访问过程：**
1. 用户进入网站的登录页面，点击微信的图标以微信账号登录系统，用户是自己在微信里信息的资源拥有者。
2. 资源拥有者同意给客户端授权
资源拥有者扫描二维码表示资源拥有者同意给客户端授权，微信会对资源拥有者的身份进行验证，验证通过后，微信会询问用户是否给授权网站访问自己的微信数据，用户点击“确认登录”表示同意授权，微信认证服务器会颁发一个授权码，并重定向到网站。
3. 客户端获取到授权码，请求认证服务器申请令牌
此过程用户看不到，客户端应用程序请求认证服务器，请求携带授权码。
4. 认证服务器向客户端响应令牌
认证服务器验证了客户端请求的授权码，如果合法则给客户端颁发令牌，令牌是客户端访问资源的通行证。此交互过程用户看不到，当客户端拿到令牌后，用户在网站看到已经登录成功。
5. 客户端请求资源服务器的资源
客户端携带令牌访问资源服务器的资源。网站携带令牌请求访问微信服务器获取用户的基本信息。
6. 资源服务器校验令牌的合法性，如果合法则向用户响应资源信息内容。
注意：资源服务器和认证服务器可以是一个服务也可以分开的服务，如果是分开的服务资源服务器通常要请求认证服务器来校验令牌的合法性。


### 角色
**客户端**
本身不存储资源，需要通过资源拥有者的授权去请求资源服务器的资源，比如：Android客户端、Web客户端（浏览器端）、微信客户端等。
**资源拥有者**
通常为用户，也可以是应用程序，即该资源的拥有者。
**授权服务器（也称认证服务器）**
用来对资源拥有的身份进行认证、对访问资源进行授权。客户端要想访问资源需要通过认证服务器由资源拥有者授权后方可访问。
**资源服务器**
存储资源的服务器，比如，网站用户管理服务器存储了网站用户信息，网站相册服务器存储了用户的相册信息，微倍的资源服务存储了微信的用户信息等。客户端最终访问资源服务器获取资源信息。

### 常用话术
- 客户凭证（client Credentials）：客户端的clientId和密码用于认证客户
- 令牌（tokens）：授权服务器在接收到客户请求后，颁发的访问令牌
- 作用域（scopes）：客户请求访问令牌时，由资源拥有者额外指定的细分权限（permission）

### 令牌类型
- 授权码：仅用于授权码授权类型，用于交换获取访问令牌和刷新令牌
- 访问令牌：用于代表一个用户或服务直接去访问受保护的资源
- 刷新令牌：用于去授权服务器获取一个刷新访问令牌
- Bearer Token：不管谁拿到Token都可以访问资源，类似现金
- Proof of Possession（Pop）Token：可以校验client是否对Token有明确的拥有权

### Oauth2的特点
**优点**
- 更安全，客户端不接触用户密码，服务器端更易集中保护
- 广泛传播并被持续采用
- 短寿命和封装的token
- 资源服务器和授权服务器解耦
- 集中式授权，简化客户端
- HTTP/JSON友好，易于请求和传递token
- 考虑多种客户端架构场景
- 客户可以具有不同的信任级别
**缺点**
- 协议框架太宽泛，造成各种实现的兼容性和互操作性差
- 不是一个认证协议，本身并不能告诉你任何用户信息。

### Oauth2的授权模式类型
OAuth 引入了一个授权层，用来分离两种不同的角色：客户端和资源拥有者. 资源拥有者同意以后，资源服务器可以向客户端颁发令牌。客户端通过令牌，去请求数据。
这段话的意思就是，OAuth 的核心就是向第三方应用颁发令牌。然后，RFC 6749 接着写道：
（由于互联网有多种场景，）本标准定义了获得令牌的四种授权方式（authorization grant ）。
也就是说，OAuth 2.0 规定了四种获得令牌的流程。你可以选择最适合自己的那一种，向第三方应用颁发令牌。下面就是这四种授权方式。
- 授权码（authorization-code）
- 隐藏式（implicit）
- 密码式（password）：
- 客户端凭证（client credentials）
注意，不管哪一种授权方式，第三方应用申请令牌之前，都必须先到系统备案，说明自己的身份，然后会拿到两个身份识别码：客户端 ID（client ID）和客户端密钥（client secret）。这是为了防止令牌被滥用，没有备案过的第三方应用，是不会拿到令牌的。

#### 授权码模式(Authorization Code)
<img src="https://gitee.com/NaisWang/images/raw/master/img/20210412144422.png" width="700px"/>
授权码（authorization code）方式，指的是第三方应用先申请一个授权码，然后再用该码获取令牌。
这种方式是最常用的流程，安全性也最高，它适用于那些有后端的 Web 应用。授权码通过前端传送，令牌则是储存在后端，而且所有与资源服务器的通信都在后端完成。这样的前后端分离，可以避免令牌泄漏。

第一步，A 网站提供一个链接，用户点击后就会跳转到 B 网站，授权用户数据给 A 网站使用。下面就是 A 网站跳转 B 网站的一个示意链接。
`https://b.com/oauth/authorize?response_type=code&client_id=CLIENT_ID&redirect_uri=CALLBACK_URL&scope=read`
上面 URL 中，response_type参数表示要求返回授权码（code），client_id参数让 B 知道是谁在请求，redirect_uri参数是 B 接受或拒绝请求后的跳转网址，scope参数表示要求的授权范围（这里是只读）。
<img src="https://gitee.com/NaisWang/images/raw/master/img/20210412143953.png" width="700px"/>

第二步，用户跳转后，B 网站会要求用户登录，然后询问是否同意给予 A 网站授权。用户表示同意，这时 B 网站就会跳回redirect_uri参数指定的网址。跳转时，会传回一个授权码，就像下面这样。
`https://a.com/callback?code=AUTHORIZATION_CODE`
上面 URL 中，code参数就是授权码。
<img src="https://gitee.com/NaisWang/images/raw/master/img/20210412144104.png" width="700px"/>

第三步，A 网站拿到授权码以后，就可以在后端，向 B 网站请求令牌。
`https://b.com/oauth/token?client_id=CLIENT_ID&client_secret=CLIENT_SECRET&grant_type=authorization_code&code=AUTHORIZATION_CODE&redirect_uri=CALLBACK_URL`
上面 URL 中，client_id参数和client_secret参数用来让 B 确认 A 的身份（client_secret参数是保密的，因此只能在后端发请求），grant_type参数的值是AUTHORIZATION_CODE，表示采用的授权方式是授权码，code参数是上一步拿到的授权码，redirect_uri参数是令牌颁发后的回调网址。
<img src="https://gitee.com/NaisWang/images/raw/master/img/20210412144145.png" width="700px"/>


第四步，B 网站收到请求以后，就会颁发令牌。具体做法是向redirect_uri指定的网址，发送一段 JSON 数据。
```json
{    
  "access_token":"ACCESS_TOKEN",
  "token_type":"bearer",
  "expires_in":2592000,
  "refresh_token":"REFRESH_TOKEN",
  "scope":"read",
  "uid":100101,
  "info":{...}
}
```
上面 JSON 数据中，access_token字段就是令牌，A 网站在后端拿到了。
<img src="https://gitee.com/NaisWang/images/raw/master/img/20210412144211.png" width="700px"/>

#### 隐藏式模式
<img src="https://gitee.com/NaisWang/images/raw/master/img/20210412144452.png" width="700px"/>
有些 Web 应用是纯前端应用，没有后端。这时就不能用上面的方式了，必须将令牌储存在前端。RFC 6749 就规定了第二种方式，允许直接向前端颁发令牌。这种方式没有授权码这个中间步骤，所以称为（授权码）"隐藏式"（implicit）。

第一步，A 网站提供一个链接，要求用户跳转到 B 网站，授权用户数据给 A 网站使用。
`https://b.com/oauth/authorize?response_type=token&client_id=CLIENT_ID&redirect_uri=CALLBACK_URL&scope=read`
上面 URL 中，response_type参数为token，表示要求直接返回令牌。

第二步，用户跳转到 B 网站，登录后同意给予 A 网站授权。这时，B 网站就会跳回redirect_uri参数指定的跳转网址，并且把令牌作为 URL 参数，传给 A 网站。
`https://a.com/callback#token=ACCESS_TOKEN`
上面 URL 中，token参数就是令牌，A 网站因此直接在前端拿到令牌。

注意，令牌的位置是 URL 锚点（fragment），而不是查询字符串（querystring），这是因为 OAuth 2.0 允许跳转网址是 HTTP 协议，因此存在"中间人攻击"的风险，而浏览器跳转时，锚点不会发到服务器，就减少了泄漏令牌的风险。
<img src="https://gitee.com/NaisWang/images/raw/master/img/20210412144700.png" width="700px"/>
这种方式把令牌直接传给前端，是很不安全的。因此，只能用于一些安全要求不高的场景，并且令牌的有效期必须非常短，通常就是会话期间（session）有效，浏览器关掉，令牌就失效了。


#### 密码式
<img src="https://gitee.com/NaisWang/images/raw/master/img/20210412145159.png" width="700px"/>
如果你高度信任某个应用，RFC 6749 也允许用户把用户名和密码，直接告诉该应用。该应用就使用你的密码，申请令牌，这种方式称为"密码式"（password）。

第一步，A 网站要求用户提供 B 网站的用户名和密码。拿到以后，A 就直接向 B 请求令牌。
`https://oauth.b.com/token?grant_type=password&username=USERNAME&password=PASSWORD&client_id=CLIENT_ID`
上面 URL 中，grant_type参数是授权方式，这里的password表示"密码式"，username和password是 B 的用户名和密码。

第二步，B 网站验证身份通过后，直接给出令牌。注意，这时不需要跳转，而是把令牌放在 JSON 数据里面，作为 HTTP 回应，A 因此拿到令牌。

这种方式需要用户给出自己的用户名/密码，显然风险很大，因此只适用于其他授权方式都无法采用的情况，而且必须是用户高度信任的应用。

#### 客户端凭证式
<img src="https://gitee.com/NaisWang/images/raw/master/img/20210412145216.png" width="700px"/>
最后一种方式是凭证式（client credentials），适用于没有前端的命令行应用，即在命令行下请求令牌。

第一步，A 应用在命令行向 B 发出请求。
`https://oauth.b.com/token?grant_type=client_credentials&client_id=CLIENT_ID&client_secret=CLIENT_SECRET`
上面 URL 中，grant_type参数等于client_credentials表示采用凭证式，client_id和client_secret用来让 B 确认 A 的身份。

第二步，B 网站验证通过以后，直接返回令牌。

这种方式给出的令牌，是针对第三方应用的，而不是针对用户的，即有可能多个用户共享同一个令牌。

### Spring Security Oauth2
<img src="https://gitee.com/NaisWang/images/raw/master/img/20210411204730.png" width="700px"/>
- Authorize Endpoint：授权端点，进行授权
- Token Endpoint：令牌端点，进过授权拿到对应的Token 
- Introspection Endpoint：校验端点，校验Token的合法性
- Revocation Endpoint：撤销端点，撤销授权

### Spring Security Oauth2架构
<img src="https://gitee.com/NaisWang/images/raw/master/img/20210411204848.png" width="700px"/>
1. 用户访问，此时没有Token。Oauth2RestTemplate会报错，这个报错信息会被Oauth2ClientContextFilter捕获并重定向到认证服务器
2. 认证服务器通过Authorization Endpoint进行授权，并通过AuthorizationServerTokenServices生成授权码并返回给客户端
3. 客户端拿到授权码去认证服务器通过Token Endpoint调用AuthorizationServerTokenServices生成Token并返回给客户端
4. 客户端拿到Token去资源服务器访问资源，一般会通过Oauth2AuthenticationManager调用ResourceServerTokenServices进行校验。校验通过可以获取资源。

### 实战spring security Oauth2实现授权码模式
目录：
- config
  - <a href="#AuthorizationServerConfig">AuthorizationServerConfig</a>
  - <a href="#ResourceServerConfig">ResourceServerConfig</a>
  - <a href="#SecurityConfig2">SecurityConfig</a>
- controller
  - <a href="#UserController2">UserController</a>
- service
  - <a href="#UserService2">UserService</a>

**依赖**
```xml
<parent>
	<artifactId>spring-boot-dependencies</artifactId>
	<groupId>org.springframework.boot</groupId>
	<version>2.3.7.RELEASE</version>
</parent>

<properties>
	<java.version>11</java.version>
	<spring-cloud.version>Hoxton.SR8</spring-cloud.version>
</properties>

<dependencies>
	<dependency>
			<groupId>org.springframework.cloud</groupId>
		<artifactId>spring-cloud-starter-oauth2</artifactId>
	</dependency>
	<dependency>
		<groupId>org.springframework.cloud</groupId>
		<artifactId>spring-cloud-starter-security</artifactId>
	</dependency>
	<dependency>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-web</artifactId>
	</dependency>
	<dependency>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-test</artifactId>
	</dependency>
</dependencies>

<dependencyManagement>
	<dependencies>
		<dependency>
			<groupId>org.springframework.cloud</groupId>
			<artifactId>spring-cloud-dependencies</artifactId>
			<version>${spring-cloud.version}</version>
			<type>pom</type>
			<scope>import</scope>
		</dependency>
	</dependencies>
</dependencyManagement>
```
**<span id="SecurityConfig2">SecurityConfig</span>**
```java
@Configuration
@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter {
	@Bean
	public PasswordEncoder passwordEncoder(){
		return new BCryptPasswordEncoder();
	}

	@Override
	protected void configure(HttpSecurity http) throws Exception {
		http.csrf().disable()
				.authorizeRequests()
				.antMatchers("/oauth/**", "/login/**","logout/**").permitAll()
				.anyRequest().authenticated()
				.and()
				.formLogin()
				.permitAll();
	}
}
```
**<span id="ResourceServerConfig">ResourceServerConfig</span>**
```java
/**
 * 资源服务器的配置
 */
@Configuration
@EnableResourceServer
public class ResourceServerConfig extends ResourceServerConfigurerAdapter {
	@Override
	public void configure(HttpSecurity http) throws Exception {
		http.authorizeRequests()
			.anyRequest().authenticated()
			.and()
			.requestMatchers()
			.antMatchers("/user/**");
	}
}
```
**<span id="AuthorizationServerConfig">AuthorizationServerConfig</span>**
```java
/**
 * 授权服务器的配置
 */
@Configuration
@EnableAuthorizationServer
public class AuthorizationServerConfig extends AuthorizationServerConfigurerAdapter {
	@Autowired
	private PasswordEncoder passwordEncoder;

	@Override
	public void configure(ClientDetailsServiceConfigurer clients) throws Exception {
		/**
		 * 经过如下设置后，获取授权码的url为：
		 * http://localhost:8080/oauth/authorize?response_type=code&client_id=whz&redirect_url=http://www.baidu.com&scope=all
		 */
		clients.inMemory()
				//配置client-id
				.withClient("whz")
				//配置client-secret
				.secret(passwordEncoder.encode("123"))
				//配置访问token的有效期
				.accessTokenValiditySeconds(3600)
				//配置redirct-uri, 用于授权成功后的跳转
				.redirectUris("http://www.baidu.com")
				// 配置申请的权限范围
				.scopes("all")
				// 配置授权类型为authorization_code类型
				.authorizedGrantTypes("authorization_code");
	}
}
```
**<span id="UserController2">UserController</span>**
```java
@RestController
@RequestMapping("/user")
public class UserController {
	//获取当前用户的信息
	@RequestMapping("/getCurrentUser")
	public Object getCurrentUser(Authentication authenticaton){
		return authenticaton.getPrincipal();
	}
}
```
**<span id="UserService2">UserService</span>**
```java
@Service
public class UserService implements UserDetailsService {

	@Autowired
	private PasswordEncoder pw;

	@Override
	public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
		//这一步是在模拟判断从前端传来的username是否存在于数据库中，如果不存在则抛出UsernameNotFoundException异常
		if(!"admin".equals(username))	{
			throw new UsernameNotFoundException("用户名不存在!");
		}

		//模拟根据前端传来的username从数据库中获取到了其密码。
		//这里要用pw进行加密的原因：我们再前端密码输入框中输入123后，springsecurity会自动将其通过你设置的密码解析器进行加密。后续的认证过程的密码都是加密后的密码
		String password = pw.encode("123");

		//这里的admin,normal是用户拥有的权限, 而ROLE_abc表示该用户属于abc角色。注: 该用户不是属于ROLE_abc角色，“ROLE_”前缀只是用来与权限名相区别开
		//权限名与角色名是严格区分大小写的
		return new User(username, password, AuthorityUtils.commaSeparatedStringToAuthorityList("admin"));
	}
}
```
**Springsecurityoauth2Application**
```java
@SpringBootApplication
public class Springsecurityoauth2Application {
	public static void main(String[] args) {
		SpringApplication.run(Springsecurityoauth2Application.class, args);
	}
}
```
<img src="https://gitee.com/NaisWang/images/raw/master/img/20210411234153.png" width="1000px"/>

## 理解OAuth和JWT的区别
- oauth2有client和scope的概念，jwt没有。如果只是拿来用于颁布token的话，二者没区别。常用的bearer算法oauth、jwt都可以用。应用场景不同而已
- Spring Cloud 的权限框架就是用的jwt实现的oauth2 。二者没有必然联系
- Token功能不一样，JWT的token是包含用户基本信息的，然后通过加密的方式生成的字符串，服务器端拿到这个token之后不需要再去查询用户基本信息，解析完token之后就能拿到。想想在微服务架构下，用户服务是一个单独的服务，但是其他服务大部分情况下也会需要用户信息，难道要每次用到都去取一次吗？ JWT非常适合微服务。
- OAuth2用在使用第三方账号登录的情况(比如使用weibo, qq, github登录某个app)。OAuth2是一个相对复杂的协议, 有4种授权模式, 其中的access code模式在实现时可以使用jwt才生成code, 也可以不用. 它们之间没有必然的联系.
- JWT是用在前后端分离, 需要简单的对后台API进行保护时使用.(前后端分离无session, 频繁传用户密码不安全)
- JWT是一种认证协议 。JWT提供了一种用于**发布接入令牌（Access Token),**并对发布的签名接入令牌进行验证的方法。 令牌（Token）本身包含了一系列声明，应用程序可以根据这些声明限制用户对资源的访问。
- OAuth2是一种授权框架。提供了一套详细的授权机制（指导）。用户或应用可以通过公开的或私有的设置，授权第三方应用访问特定资源。

# RBAC
<img src="https://gitee.com/NaisWang/images/raw/master/img/20210621200159.png" width="500px"/>
